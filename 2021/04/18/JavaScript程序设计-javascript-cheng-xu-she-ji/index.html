<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>JavaScript程序设计 | HALO</title><meta name="author" content="Halo"><meta name="copyright" content="Halo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JavaScript概述JavaScript（简称“JS”） 是一种具有函数优先的轻量级，解释型或即时编译型的编程语言。虽然它是作为开发Web页面的脚本语言而出名，但是它也被用到了很多非浏览器环境中，JavaScript 基于原型编程、多范式的动态脚本语言，并且支持面向对象、命令式和声明式（如函数式编程）风格。 ECMAScript是一种由 Ecma 国际（前身为欧洲计算机制造商协会，Europe">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript程序设计">
<meta property="og:url" content="http://halo123.top/2021/04/18/JavaScript%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-javascript-cheng-xu-she-ji/index.html">
<meta property="og:site_name" content="HALO">
<meta property="og:description" content="JavaScript概述JavaScript（简称“JS”） 是一种具有函数优先的轻量级，解释型或即时编译型的编程语言。虽然它是作为开发Web页面的脚本语言而出名，但是它也被用到了很多非浏览器环境中，JavaScript 基于原型编程、多范式的动态脚本语言，并且支持面向对象、命令式和声明式（如函数式编程）风格。 ECMAScript是一种由 Ecma 国际（前身为欧洲计算机制造商协会，Europe">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img.imgdb.cn/item/5fc1285715e771908483588b.jpg">
<meta property="article:published_time" content="2021-04-18T13:58:10.360Z">
<meta property="article:modified_time" content="2021-04-21T10:54:58.360Z">
<meta property="article:author" content="Halo">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img.imgdb.cn/item/5fc1285715e771908483588b.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://halo123.top/2021/04/18/JavaScript%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-javascript-cheng-xu-she-ji/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-04-21 18:54:58'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/static-butterfly/dist/css/index.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://img.imgdb.cn/item/608289f3d1a9ae528feb09a8.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://img.imgdb.cn/item/5fc1285715e771908483588b.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">HALO</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JavaScript程序设计</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-04-18T13:58:10.360Z" title="发表于 2021-04-18 21:58:10">2021-04-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-04-21T10:54:58.360Z" title="更新于 2021-04-21 18:54:58">2021-04-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JavaScript/">JavaScript</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JavaScript程序设计"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="JavaScript概述"><a href="#JavaScript概述" class="headerlink" title="JavaScript概述"></a>JavaScript概述</h1><p>JavaScript（简称“JS”） 是一种具有函数优先的轻量级，解释型或即时编译型的编程语言。虽然它是作为开发Web页面的脚本语言而出名，但是它也被用到了很多非浏览器环境中，JavaScript 基于原型编程、多范式的动态脚本语言，并且支持面向对象、命令式和声明式（如函数式编程）风格。</p>
<p>ECMAScript是一种由 Ecma 国际（前身为欧洲计算机制造商协会，European Computer Manufacturers Association）通过ECMA-262标准化的脚本程序设计语言。这种语言在万维网上应用广泛，它往往被称为JavaScript或JScript，所以它可以理解为是JavaScript的一个标准，但实际上后两者是ECMA-262标准的实现和扩展。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="JavaScript使用"><a href="#JavaScript使用" class="headerlink" title="JavaScript使用"></a>JavaScript使用</h3><p>HTML 中的脚本必须位于 <code>&lt;script&gt;</code> 与 <code>&lt;/script&gt;</code> 标签之间。</p>
<p>脚本可被放置在 HTML 页面的 <code>&lt;body&gt;</code> 和 <code>&lt;head&gt;</code> 部分中。</p>
<p><code>&lt;script&gt;</code>标签用于引入JavaScript，<code>&lt;script&gt;</code> 和 <code>&lt;/script&gt;</code> 会告诉 JavaScript 在何处开始和结束。</p>
<p><code>&lt;script&gt;</code>元素具有6个属性：</p>
<ul>
<li><code>async</code>：可选。异步，表示应该立即下载脚本，但不应妨碍页面中的其他操作，比如下载其他资源或等待加载其他脚本。只对外部脚本文件有效。建议异步脚本不要在加载期间修改 DOM（属性设置为<code>async=&quot;async&quot;</code>）</li>
<li><code>charset</code>：可选。表示通过 <code>src</code> 属性指定的代码的字符集。由于大多数浏览器会忽略它的值，因此这个属性很少有人用。</li>
<li><code>defer</code>：可选。延迟，表示脚本可以<strong>延迟到文档完全被解析和显示之后再执行</strong>。只对外部脚本文件有效。IE7 及更早版本对嵌入脚本也支持这个属性。(属性设置为<code>defer=&quot;defer&quot;</code>)</li>
<li><code>language</code>：已废弃。原来用于表示编写代码使用的脚本语言（如 JavaScript、JavaScript1.2或 VBScript）。大多数浏览器会忽略这个属性，因此也没有必要再用了。</li>
<li><code>src</code>：可选。表示包含要执行代码的外部文件。</li>
<li><code>type</code>：可选。可以看成是<code>language </code>替代属性；表示编写代码使用的脚本语言的内容类型（也称为 MIME 类型）。如果没有指定这个属性，则其默认值为<code>text/javascript</code></li>
</ul>
<p><code>&lt;script&gt;</code>通常用以下两种<strong>使用方式</strong></p>
<ul>
<li>直接在页面中嵌入 JavaScript 代码</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    alert(<span class="string">&#x27;Hello, world&#x27;</span>);</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>由<code>&lt;script&gt;</code>…<code>&lt;/script&gt;</code>包含的代码就是JavaScript代码，它将直接被浏览器执行</p>
<ul>
<li>把JavaScript代码放到一个单独的<code>.js</code>文件，然后在HTML中通过<code>&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;</code>引入这个文件</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/static/js/abc.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样，<code>/static/js/abc.js</code>就会被浏览器执行。</p>
<blockquote>
<p>带有<code>src</code>属性的<code>&lt;script&gt;</code>元素不应该在其<code>&lt;script&gt;</code>和<code>&lt;/script&gt;</code>标签之间再包含额外的 JavaScript 代码。如果包含了嵌入的代码，则只会下载并执行外部脚本文件，嵌入的代码会被忽略。</p>
</blockquote>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>JavaScript的语法和Java语言类似，每个语句以<code>;</code>结束，语句块用<code>&#123;...&#125;</code>。</p>
<p>但是，JavaScript并不强制要求在每个语句的结尾加<code>;</code>，浏览器中负责执行JavaScript代码的引擎会自动在每个语句的结尾补上<code>;</code>。推荐语句使用分号结束。</p>
<h3 id="关键字和保留字"><a href="#关键字和保留字" class="headerlink" title="关键字和保留字"></a>关键字和保留字</h3><p>ECMA-262 描述了一组具有特定用途的关键字，这些关键字可用于表示控制语句的开始或结束，或者用于执行特定操作等。按照规则，关键字也是语言保留的，不能用作标识符或属性名。ECMA-262 第 6 版规定的所有关键字如下：</p>
<table>
<thead>
<tr>
<th>break</th>
<th>do</th>
<th>in</th>
<th>typeof</th>
</tr>
</thead>
<tbody><tr>
<td>case</td>
<td>else</td>
<td>instanceof</td>
<td>var</td>
</tr>
<tr>
<td>catch</td>
<td>export</td>
<td>new</td>
<td>void</td>
</tr>
<tr>
<td>class</td>
<td>extends</td>
<td>return</td>
<td>while</td>
</tr>
<tr>
<td>const</td>
<td>finally</td>
<td>super</td>
<td>with</td>
</tr>
<tr>
<td>continue</td>
<td>for</td>
<td>switch</td>
<td>yield</td>
</tr>
<tr>
<td>debugger</td>
<td>function</td>
<td>this</td>
<td></td>
</tr>
<tr>
<td>default</td>
<td>if</td>
<td>throw</td>
<td></td>
</tr>
<tr>
<td>delete</td>
<td>import</td>
<td>try</td>
<td></td>
</tr>
</tbody></table>
<p>规范中也描述了一组未来的保留字，同样不能用作标识符或属性名。虽然保留字在语言中没有特定用途，但它们是保留给将来做关键字用的。 以下是 ECMA-262 第 6 版为将来保留的所有词汇。</p>
<p>始终保留：<code>enum</code></p>
<p>严格模式下保留：<code>implements</code>、<code>package</code>、<code>public</code>、<code>interface</code>、<code>protected</code>、<code>static</code>、<code>let</code>、<code>private</code></p>
<p>模块代码中保留：<code>await</code></p>
<p>这些词汇不能用作标识符，但现在还可以用作对象的属性名。一般来说，最好还是不要使用关键字和保留字作为标识符和属性名，以确保兼容过去和未来的 ECMAScript 版本。</p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>ECMAScript 使用 C 风格的注释，包括单行注释和块级注释。</p>
<p>以<code>//</code>开头直到行末的字符被视为单行注释</p>
<p>另一种块注释是用<code>/*...*/</code>把多行字符包裹起来，把一大“块”视为一个注释</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单行注释</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 多</span></span><br><span class="line"><span class="comment"> * 行</span></span><br><span class="line"><span class="comment"> * 注</span></span><br><span class="line"><span class="comment"> * 释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>虽然上面注释中的第二和第三行都以一个星号开头，但这不是必需的。之所以添加那两个星号，纯粹是为了提高注释的可读性（这种格式在企业级应用中用得比较多）。</p>
</blockquote>
<h3 id="区分大小写"><a href="#区分大小写" class="headerlink" title="区分大小写"></a>区分大小写</h3><p>JavaScript<strong>严格区分大小写</strong>，如果弄错了大小写，程序将报错或者运行不正常。这也就意味着，变量名 test 和变量名 Test 分别表示两个不同的变量，而函数名不能使用 typeof，因为它是一个关键字，但 typeOf 则完全可以是一个有效的函数名。</p>
<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>标识符是指变量、函数、属性的名字，或者函数的参数。</p>
<p>标识符可以是按照下列格式规则组合起来的一或多个字符：</p>
<ul>
<li>第一个字符必须是一个字母、下划线（_）或一个美元符号（$）；</li>
<li>其他字符可以是字母、下划线、美元符号或数字</li>
</ul>
<p>推荐采用驼峰大小写格式，也就是第一个字母小写，剩下的每个单词的首字母大写</p>
<blockquote>
<p>不能把关键字、保留字、true、false 和 null 用作标识符。</p>
</blockquote>
<h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>ECMAScript 5引入了严格模式的概念。</p>
<p>严格模式是为 JavaScript 定义了一种不同的解析与执行模型。通过严格模式，可以在函数内部选择进行较为严格的全局或局部的错误条件检测。使用严格模式的好处是可以提早知道代码中存在的错误，及时捕获一些可能导致编程错误ECMAScript 行为。 理解严格模式的规则非常重要，ECMAScript 的下一个版本将以严格模式为基础制定。</p>
<h4 id="选择使用"><a href="#选择使用" class="headerlink" title="选择使用"></a>选择使用</h4><p>在严格模式下，ECMAScript3 中的一些不确定的行为将得到处理，而且对某些不安全的操作也会抛出错误。要在整个脚本中启用严格模式，可以在<strong>顶部</strong>添加如下代码： <code>&quot;use strict&quot;;</code></p>
<p>这行代码看起来像是字符串，而且也没有赋值给任何变量，但其实它是一个编译指示（pragma），用于告诉支持的 JavaScript 引擎切换到严格模式。这是为不破坏 ECMAScript 3 语法而特意选定的语法。</p>
<p>也可以只在函数中打开严格模式，就像下面这样： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line"><span class="meta">    &quot;use strict&quot;</span>; </span><br><span class="line">    <span class="comment">//其他代码 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>严格模式下，JavaScript 的执行结果会有很大不同，以下指出严格模式下的部分区别：</p>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>在严格模式下，什么时候创建变量以及怎么创建变量都是有限制的。首先，不允许意外创建全局变量。在非严格模式下，可以像下面这样创建全局变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//未声明变量 </span></span><br><span class="line"><span class="comment">//非严格模式：创建全局变量 </span></span><br><span class="line"><span class="comment">//严格模式：抛出 ReferenceError </span></span><br><span class="line"> </span><br><span class="line">message = <span class="string">&quot;Hello world! &quot;</span>;</span><br></pre></td></tr></table></figure>

<p>即使 message 前面没有 <code>var</code> 关键字，即使没有将它定义为某个全局对象的属性，也能将 message 创建为全局变量。但在严格模式下，如果给一个没有声明的变量赋值，那代码在执行时就会抛出<br><code>ReferenceError</code>。</p>
<p>其次，不能对变量调用 delete 操作符。非严格模式允许这样操作，但会静默失败（返回 false）。而在严格模式下，删除变量也会导致错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除变量  </span></span><br><span class="line"><span class="comment">//非严格模式：静默失败 </span></span><br><span class="line"><span class="comment">//严格模式：抛出 ReferenceError </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> color = <span class="string">&quot;red&quot;</span>; </span><br><span class="line"><span class="keyword">delete</span> color;</span><br></pre></td></tr></table></figure>

<p>严格模式下对变量名也有限制。特别地，不能使用 implements、interface、let、package、private、protected、public、static 和 yield 作为变量名。这些都是保留字，将来的 ECMAScript 版本中可能会用到它们。在严格模式下，用以上标识符作为变量名会导致语法错误。</p>
<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>在严格模式下操作对象比在非严格模式下更容易导致错误。一般来说，非严格模式下会静默失败的情形，在严格模式下就会抛出错误。因此，在开发中使用严格模式会加大早发现错误的可能性。<br>在下列情形下操作对象的属性会导致错误： </p>
<ul>
<li>为只读属性赋值会抛出 <code>TypeError</code>；</li>
<li>对不可配置的（nonconfigurable）的属性使用 delete 操作符会抛出 <code>TypeError</code>；</li>
<li>为不可扩展的（nonextensible）的对象添加属性会抛出 <code>TypeError</code>。 </li>
</ul>
<p>使用对象的另一个限制与通过对象字面量声明对象有关。在使用对象字面量时，属性名必须唯一。<br>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重名属性 </span></span><br><span class="line"><span class="comment">//非严格模式：没有错误，以第二个属性为准 </span></span><br><span class="line"><span class="comment">//严格模式：抛出语法错误 </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> person = &#123;  </span><br><span class="line">                name: <span class="string">&quot;Nicholas&quot;</span>, </span><br><span class="line">                name: <span class="string">&quot;Greg&quot;</span> </span><br><span class="line">             &#125;;</span><br></pre></td></tr></table></figure>

<p>这里的对象 <code>person</code> 有两个属性，都叫 <code>name</code>。在非严格模式下，<code>person</code> 对象的 <code>name</code> 属性值是第二个，而在严格模式下，这样的代码会导致语法错误。</p>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>首先，严格模式要求命名函数的参数必须唯一。以下面这个函数为例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重名参数 </span></span><br><span class="line"><span class="comment">//非严格模式：没有错误，只能访问第二个参数 </span></span><br><span class="line"><span class="comment">//严格模式：抛出语法错误</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">num, num</span>)</span>&#123; </span><br><span class="line">    <span class="comment">//do something </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在非严格模式下，这个函数声明不会抛出错误。通过参数名只能访问第二个参数，要访问第一个参数必须通过 arguments 对象。 </p>
<p>在严格模式下，arguments 对象的行为也有所不同。在非严格模式下，修改命名参数的值也会反映到 arguments 对象中，而严格模式下这两个值是完全独立的。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改命名参数的值 </span></span><br><span class="line"><span class="comment">//非严格模式：修改会反映到 arguments 中 </span></span><br><span class="line"><span class="comment">//严格模式：修改不会反映到 arguments 中 </span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showValue</span>(<span class="params">value</span>)</span>&#123; </span><br><span class="line">    value = <span class="string">&quot;Foo&quot;</span>;  </span><br><span class="line">    alert(value);        <span class="comment">//&quot;Foo&quot; </span></span><br><span class="line">    alert(<span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">//非严格模式：&quot;Foo&quot; </span></span><br><span class="line">                         <span class="comment">//严格模式：&quot;Hi&quot; </span></span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">showValue(<span class="string">&quot;Hi&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>以上代码中，函数 <code>showValue()</code> 只有一个命名参数 <code>value</code>。调用这个函数时传入了一个参数“Hi”，这个值赋给了 value。而在函数内部，value 被改为“Foo”。在非严格模式下，这个修改也会改变arguments[0]的值，但在严格模式下，arguments[0]的值仍然是传入的值。</p>
<h3 id="变量-1"><a href="#变量-1" class="headerlink" title="变量"></a>变量</h3><p>ECMAScript 的变量是松散类型的，所谓松散类型就是可以用来保存任何类型的数据。与Python变量类似。换句话说，<br>每个变量仅仅是一个用于保存值的占位符而已。有 3 个关键字可以声明变量：<code>var</code>、<code>const</code> 和 <code>let</code>。其中，var 在 ECMAScript 的所有版本中都可以使用，而 <code>const</code> 和 <code>let</code> 只能在 ECMAScript 6 及更晚的版本中使用。</p>
<h4 id="var-关键字"><a href="#var-关键字" class="headerlink" title="var 关键字"></a><code>var</code> 关键字</h4><p>要定义变量，可以使用 <code>var</code> 操作符（注意 <code>var</code> 是一个关键字），后跟变量名（即标识符，如前所述）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message;</span><br></pre></td></tr></table></figure>

<p>这行代码定义了一个名为<code>message</code> 的变量，该变量可以用来保存任何类型的值，像这样未经过初始化的变量，会保存一个特殊的值—<code>undefined</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">&quot;world&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> message = <span class="string">&quot;hello&quot;</span>; <span class="comment">// 局部变量</span></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"><span class="built_in">console</span>.log(message) <span class="comment">//world</span></span><br></pre></td></tr></table></figure>

<p>用 <code>var</code> 操作符定义的变量将成为定义该变量的作用域中的局部变量，如果在函数中使用 <code>var</code> 定义一个变量，那么这个变量在函数退出后就会被销毁。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">&quot;world&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    message = <span class="string">&quot;hello&quot;</span>; <span class="comment">// 全局变量</span></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"><span class="built_in">console</span>.log(message) <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>

<p>省略了 <code>var</code> 操作符，因而 <code>message</code> 就成了全局变量。这样，只要调用过一次 <code>test()</code> 函数，这个变量就有了定义，就可以在函数外部的任何地方被访问到。</p>
<blockquote>
<p>不推荐省略<code>var</code>操作符定义全局变量</p>
</blockquote>
<p>可以使用一条语句定义多个变量，变量间使用逗号分隔。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">&quot;hello&quot;</span>, </span><br><span class="line">    found = <span class="literal">false</span>,</span><br><span class="line">    age = <span class="number">29</span>;</span><br></pre></td></tr></table></figure>

<p>这个例子定义并初始化了 3 个变量。同样由于 ECMAScript 是松散类型的，因而使用不同类型初始化变量的操作可以放在一条语句中来完成。虽然代码里的换行和变量缩进不是必需的，但这样做可以提高可读性。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>ECMAScript 中有 5 种简单数据类型（也称为基本数据类型）：<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>和 <code>String</code>。还有 1 种复杂数据类型——<code>Object</code>，<code>Object</code>本质上是由一组无序的名值对组成的。</p>
<p>JavaScript不区分整数和浮点数，统一用Number表示,以下都是合法的Number类型：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123</span>; <span class="comment">// 整数123</span></span><br><span class="line"><span class="number">0.456</span>; <span class="comment">// 浮点数0.456</span></span><br><span class="line"><span class="number">1.2345e3</span>; <span class="comment">// 科学计数法表示1.2345x1000，等同于1234.5</span></span><br><span class="line">-<span class="number">99</span>; <span class="comment">// 负数</span></span><br><span class="line"><span class="literal">NaN</span>; <span class="comment">// NaN表示Not a Number，当无法计算结果时用NaN表示</span></span><br><span class="line"><span class="literal">Infinity</span>; <span class="comment">// Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>十六进制表示整数比较方便，十六进制用0x前缀和0~9，a~f表示，例如：<code>0xff00</code>，<code>0xa5b4c3d2</code>，等等，它们和十进制表示的数值完全一样。</p>
</blockquote>
<p>Number可以直接做四则运算，规则和数学一致</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="number">2</span>; <span class="comment">// 3</span></span><br><span class="line">(<span class="number">1</span> + <span class="number">2</span>) * <span class="number">5</span> / <span class="number">2</span>; <span class="comment">// 7.5</span></span><br><span class="line"><span class="number">2</span> / <span class="number">0</span>; <span class="comment">// Infinity</span></span><br><span class="line"><span class="number">0</span> / <span class="number">0</span>; <span class="comment">// NaN</span></span><br><span class="line"><span class="number">10</span> % <span class="number">3</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="number">10.5</span> % <span class="number">3</span>; <span class="comment">// 1.5</span></span><br><span class="line"><span class="comment">// 注意%是求余运算</span></span><br></pre></td></tr></table></figure>

<h3 id="typeof操作符"><a href="#typeof操作符" class="headerlink" title="typeof操作符"></a><code>typeof</code>操作符</h3><p><code>typeof</code>操作符用来检测给定变量的数据类型，返回以下字符串</p>
<ul>
<li><code>undefined</code>——这个值未定义；</li>
<li><code>boolean</code>——这个值是布尔值；</li>
<li><code>string</code>——这个值是字符串；</li>
<li><code>number</code>——这个值是数值；</li>
<li><code>object</code>——这个值是对象或 null；</li>
<li><code>function</code>——如果这个值是函数</li>
</ul>
<p>下面是几个使用 <code>typeof</code> 操作符的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">&quot;hello&quot;</span>,found = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> message) <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(found))  <span class="comment">// boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">95</span>);     <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>)    <span class="comment">// object</span></span><br></pre></td></tr></table></figure>

<p><code>typeof</code> 操作符的操作数可以是变量（message），也可以是数值字面量。</p>
<blockquote>
<p>注意，<br><code>typeof</code> 是一个操作符而不是函数，因此例子中的圆括号尽管可以使用，但不是必需的。</p>
</blockquote>
<blockquote>
<p>有些时候，<code>typeof</code> 操作符会返回一些令人迷惑但技术上却正确的值。比如，调用 <code>typeof null</code> 会返回“object”，因为特殊值 null 被认为是一个空的对象引用。Safari 5 及之前版本、Chrome 7 及之<br>前版本在对正则表达式调用 <code>typeof</code> 操作符时会返回“function”，而其他浏览器在这种情况下会返回<br>“object”。</p>
</blockquote>
<h3 id="null和undefined"><a href="#null和undefined" class="headerlink" title="null和undefined"></a><code>null</code>和<code>undefined</code></h3><p><code>null</code>表示一个“空”的值，它和<code>0</code>以及空字符串<code>&#39;&#39;</code>不同，<code>0</code>是一个数值，<code>&#39;&#39;</code>表示长度为0的字符串，而<code>null</code>表示“空”。</p>
<p><code>null</code>值表示一个空对象指针，而这也正是使用<code>typeof</code>操作符检测<code>null</code>值时会返回”object”的原因</p>
<p>在其他语言中，也有类似JavaScript的<code>null</code>的表示，例如Java也用<code>null</code>，Swift用<code>nil</code>，Python用<code>None</code>表示。但是，在JavaScript中，还有一个和<code>null</code>类似的<code>undefined</code>，它表示“未定义”。</p>
<p>JavaScript的设计者希望用<code>null</code>表示一个空的值，而<code>undefined</code>表示值未定义。事实证明，这并没有什么用，区分两者的意义不大。大多数情况下，我们都应该用<code>null</code>。<code>undefined</code>仅仅在判断函数参数是否传递的情况下有用。</p>
<p>只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存<code>null</code>值。这样做不仅可以体现<code>null</code>作为空对象指针的惯例，而且也有助于进一步区分<code>null</code>和 <code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message1; </span><br><span class="line">alert(message1 == <span class="literal">undefined</span>); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> message2 = <span class="literal">undefined</span>; </span><br><span class="line">alert(message2 == <span class="literal">undefined</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h3 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a><code>String</code>类型</h3><p>字符串是以单引号<code>&#39;</code>或双引号<code>&quot;</code>括起来的任意文本，比如<code>&#39;abc&#39;</code>，<code>&quot;xyz&quot;</code>等等。<code>&#39;&#39;</code>或<code>&quot;&quot;</code>本身只是一种表示方式，不是字符串的一部分，因此，字符串<code>&#39;abc&#39;</code>只有<code>a</code>，<code>b</code>，<code>c</code>这3个字符。不过，以双引号开头的字符串也必须以双引号结尾，而以单引号开头的字符串必须以单引号结尾。</p>
<p>如果字符串内部既包含<code>&#39;</code>又包含<code>&quot;</code>，可以用转义字符<code>\</code>来标识</p>
<h4 id="字符字面量"><a href="#字符字面量" class="headerlink" title="字符字面量"></a>字符字面量</h4><p>String 数据类型包含一些特殊的字符字面量，也叫转义序列，用于表示非打印字符，或者具有其他用途的字符。这些字符字面量如下表所示：</p>
<table>
<thead>
<tr>
<th>字面量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>\n</code></td>
<td>换行</td>
</tr>
<tr>
<td><code>\t</code></td>
<td>Tab制表</td>
</tr>
<tr>
<td><code>\b</code></td>
<td>空格</td>
</tr>
<tr>
<td><code>\r</code></td>
<td>回车</td>
</tr>
<tr>
<td><code>\f</code></td>
<td>换页</td>
</tr>
<tr>
<td><code>\\</code></td>
<td>转义斜杠</td>
</tr>
<tr>
<td><code>\&#39;</code></td>
<td>单引号（<code>&#39;</code>），在用单引号表示的字符串中使用。</td>
</tr>
<tr>
<td><code>\&quot;</code></td>
<td>双引号（<code>&quot;</code>），在用双引号表示的字符串中使用。</td>
</tr>
<tr>
<td><code>\xnn</code></td>
<td>以十六进制代码 nn 表示的一个字符（其中n为0～F）。例如，\x41表示”A”</td>
</tr>
<tr>
<td><code>\unnnn</code></td>
<td>以十六进制代码 nnnn 表示的一个Unicode字符（其中n为0～F）。例如，\u03a3表示希腊字符Σ</td>
</tr>
</tbody></table>
<p>这些字符字面量可以出现在字符串中的任意位置，而且也将被作为一个字符来解析，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">&quot;\u03a3&quot;</span>;</span><br><span class="line">alert(text.length); <span class="comment">// 输出 1</span></span><br></pre></td></tr></table></figure>

<h4 id="字符串的特点"><a href="#字符串的特点" class="headerlink" title="字符串的特点"></a>字符串的特点</h4><p>ECMAScript 中的字符串是不可变的，也就是说，字符串一旦创建，它们的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lang = <span class="string">&quot;Java&quot;</span>; </span><br><span class="line">lang = lang + <span class="string">&quot;Script&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>以上示例中的变量 lang 开始时包含字符串“Java”。而第二行代码把 lang 的值重新定义为“Java”与“Script”的组合，即“JavaScript”。实现这个操作的过程如下：首先创建一个能容纳 10 个字符的新字符串，然后在这个字符串中填充“Java”和“Script”，最后一步是销毁原来的字符串“Java”和字符串“Script”，因为这两个字符串已经没用了。</p>
<h4 id="转换为字符串"><a href="#转换为字符串" class="headerlink" title="转换为字符串"></a>转换为字符串</h4><p>要把一个值转换为一个字符串有两种方式。第一种是使用几乎每个值都有的 <code>toString()</code> 方法。这个方法唯一要做的就是返回相应值的字符串表现。来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">11</span>; </span><br><span class="line"><span class="keyword">var</span> ageAsString = age.toString();         <span class="comment">// 字符串&quot;11&quot; </span></span><br><span class="line"><span class="keyword">var</span> found = <span class="literal">true</span>; </span><br><span class="line"><span class="keyword">var</span> foundAsString = found.toString();     <span class="comment">// 字符串&quot;true&quot;</span></span><br></pre></td></tr></table></figure>

<p>数值、布尔值、对象和字符串值（没错，每个字符串也都有一个 <code>toString()</code> 方法，该方法返回字符串的一个副本）都有 <code>toString()</code> 方法。但 <code>null</code> 和 <code>undefined</code> 值没有这个方法。</p>
<p>多数情况下，调用 <code>toString()</code> 方法不必传递参数。但是，在调用数值的 <code>toString()</code> 方法时，可以传递一个参数：输出数值的基数。默认情况下，<code>toString()</code> 方法以十进制格式返回数值的字符串表示。而通过传递基数，<code>toString()</code> 可以输出以二进制、八进制、十六进制，乃至其他任意有效进制格式表示的字符串值。下面给出几个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>; </span><br><span class="line">alert(num.toString());         <span class="comment">// &quot;10&quot; </span></span><br><span class="line">alert(num.toString(<span class="number">2</span>));        <span class="comment">// &quot;1010&quot; </span></span><br><span class="line">alert(num.toString(<span class="number">8</span>));        <span class="comment">// &quot;12&quot; </span></span><br><span class="line">alert(num.toString(<span class="number">10</span>));       <span class="comment">// &quot;10&quot; </span></span><br><span class="line">alert(num.toString(<span class="number">16</span>));       <span class="comment">// &quot;a&quot;</span></span><br></pre></td></tr></table></figure>

<p>通过这个例子可以看出，通过指定基数，<code>toString()</code> 方法会改变输出的值。而数值 10 根据基数的不同，可以在输出时被转换为不同的数值格式。注意，默认的（没有参数的）输出值与指定基数 10 时的输出值相同。</p>
<p>在不知道要转换的值是不是 <code>null</code> 或 <code>undefined</code> 的情况下，还可以使用转型函数 <code>String()</code>，这个函数能够将任何类型的值转换为字符串。<code>String()</code>函数遵循下列转换规则：</p>
<ul>
<li>如果值有 <code>toString()</code> 方法，则调用该方法（没有参数）并返回相应的结果；</li>
<li>如果值是 null，则返回“null”；</li>
<li>如果值是 undefined，则返回“undefined”。</li>
</ul>
<p>下面再看几个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value1 = <span class="number">10</span>; </span><br><span class="line"><span class="keyword">var</span> value2 = <span class="literal">true</span>; </span><br><span class="line"><span class="keyword">var</span> value3 = <span class="literal">null</span>; </span><br><span class="line"><span class="keyword">var</span> value4;</span><br><span class="line"></span><br><span class="line">alert(<span class="built_in">String</span>(value1));     <span class="comment">// &quot;10&quot; </span></span><br><span class="line">alert(<span class="built_in">String</span>(value2));     <span class="comment">// &quot;true&quot; </span></span><br><span class="line">alert(<span class="built_in">String</span>(value3));     <span class="comment">// &quot;null&quot; </span></span><br><span class="line">alert(<span class="built_in">String</span>(value4));     <span class="comment">// &quot;undefined&quot;</span></span><br></pre></td></tr></table></figure>

<p>这里先后转换了 4 个值：数值、布尔值、null 和 undefined。数值和布尔值的转换结果与调用 <code>toString()</code> 方法得到的结果相同。因为 null 和 undefined 没有 <code>toString()</code> 方法，所以 <code>String()</code> 函数就返回了这两个值的字面量。</p>
<blockquote>
<p>要把某个值转换为字符串，可以使用加号操作符把它与一个字符串（<code>&quot;&quot;</code>）加在一起。</p>
</blockquote>
<h4 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h4><p>由于多行字符串用<code>\n</code>写起来比较费事，所以最新的ES6标准新增了一种多行字符串的表示方法，用反引号表示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`这是一个</span></span><br><span class="line"><span class="string">多行</span></span><br><span class="line"><span class="string">字符串`</span>;</span><br></pre></td></tr></table></figure>

<h4 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h4><p>要把多个字符串连接起来，可以用<code>+</code>号连接：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;小明&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> message = <span class="string">&#x27;你好, &#x27;</span> + name + <span class="string">&#x27;, 你今年&#x27;</span> + age + <span class="string">&#x27;岁了!&#x27;</span>;</span><br><span class="line">alert(message);</span><br></pre></td></tr></table></figure>

<p>如果有很多变量需要连接，用<code>+</code>号就比较麻烦。ES6新增了一种模板字符串，表示方法和上面的多行字符串一样，但是它会自动替换字符串中的变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;小明&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> message = <span class="string">`你好, <span class="subst">$&#123;name&#125;</span>, 你今年<span class="subst">$&#123;age&#125;</span>岁了!`</span>;</span><br><span class="line">alert(message);</span><br></pre></td></tr></table></figure>

<h4 id="操作字符串"><a href="#操作字符串" class="headerlink" title="操作字符串"></a>操作字符串</h4><p>字符串常见的操作如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;Hello, world!&#x27;</span>;</span><br><span class="line">s.length; <span class="comment">// 13</span></span><br></pre></td></tr></table></figure>

<p>要获取字符串某个指定位置的字符，使用类似Array的下标操作，索引号从0开始：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;Hello, world!&#x27;</span>;</span><br><span class="line"></span><br><span class="line">s[<span class="number">0</span>]; <span class="comment">// &#x27;H&#x27;</span></span><br><span class="line">s[<span class="number">6</span>]; <span class="comment">// &#x27; &#x27;</span></span><br><span class="line">s[<span class="number">7</span>]; <span class="comment">// &#x27;w&#x27;</span></span><br><span class="line">s[<span class="number">12</span>]; <span class="comment">// &#x27;!&#x27;</span></span><br><span class="line">s[<span class="number">13</span>]; <span class="comment">// undefined 超出范围的索引不会报错，但一律返回undefined</span></span><br></pre></td></tr></table></figure>

<p><strong>需要特别注意的是</strong>，字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;Test&#x27;</span>;</span><br><span class="line">s[<span class="number">0</span>] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">alert(s); <span class="comment">// s仍然为&#x27;Test&#x27;</span></span><br></pre></td></tr></table></figure>

<p>JavaScript为字符串提供了一些常用方法，注意，调用这些方法本身不会改变原有字符串的内容，而是返回一个新字符串：</p>
<h5 id="toUpperCase"><a href="#toUpperCase" class="headerlink" title="toUpperCase"></a>toUpperCase</h5><p><code>toUpperCase()</code>把一个字符串全部变为大写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line">s.toUpperCase(); <span class="comment">// 返回&#x27;HELLO&#x27;</span></span><br></pre></td></tr></table></figure>

<h5 id="toLowerCase"><a href="#toLowerCase" class="headerlink" title="toLowerCase"></a>toLowerCase</h5><p><code>toLowerCase()</code>把一个字符串全部变为小写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> lower = s.toLowerCase(); <span class="comment">// 返回&#x27;hello&#x27;并赋值给变量lower</span></span><br><span class="line">lower; <span class="comment">// &#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure>

<h5 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h5><p><code>indexOf()</code>会搜索指定字符串出现的位置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;hello, world&#x27;</span>;</span><br><span class="line">s.indexOf(<span class="string">&#x27;world&#x27;</span>); <span class="comment">// 返回7</span></span><br><span class="line">s.indexOf(<span class="string">&#x27;World&#x27;</span>); <span class="comment">// 没有找到指定的子串，返回-1</span></span><br></pre></td></tr></table></figure>

<h5 id="substring"><a href="#substring" class="headerlink" title="substring"></a>substring</h5><p><code>substring()</code>返回指定索引区间的子串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;hello, world&#x27;</span></span><br><span class="line">s.substring(<span class="number">0</span>, <span class="number">5</span>); <span class="comment">// 从索引0开始到5（不包括5），返回&#x27;hello&#x27;</span></span><br><span class="line">s.substring(<span class="number">7</span>); <span class="comment">// 从索引7开始到结束，返回&#x27;world&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a><code>Boolean</code>类型</h3><p>布尔值和布尔代数的表示完全一致，一个布尔值只有<code>true</code>、<code>false</code>两种值，要么是<code>true</code>，要么是<code>false</code>，可以直接用<code>true</code>、<code>false</code>表示布尔值，也可以通过布尔运算计算出来</p>
<ul>
<li><code>&amp;&amp;</code>运算是与运算，只有所有都为<code>true</code>，<code>&amp;&amp;</code>运算结果才是<code>true</code></li>
<li><code>||</code>运算是或运算，只要其中有一个为<code>true</code>，<code>||</code>运算结果就是<code>true</code></li>
<li><code>!</code>运算是非运算，它是一个单目运算符，把<code>true</code>变成<code>false</code>，<code>false</code>变成<code>true</code></li>
</ul>
<p>其他数据类型对于布尔值转换</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>true</th>
<th>false</th>
</tr>
</thead>
<tbody><tr>
<td>Boolean</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>String</td>
<td>非空字符串</td>
<td>“ ”</td>
</tr>
<tr>
<td>Number</td>
<td>非零数字（包括无穷大）</td>
<td>0和NaN</td>
</tr>
<tr>
<td>Object</td>
<td>任何对象</td>
<td>null</td>
</tr>
<tr>
<td>Undefined</td>
<td>N/A</td>
<td>undefined</td>
</tr>
</tbody></table>
<h3 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a><code>Number</code>类型</h3><p>默认十进制</p>
<p>八进制前两位为0o，八进制字面量在严格模式下是无效的，会导致支持的 JavaScript 引擎抛出错误。</p>
<p>十六进制前两位为0x</p>
<blockquote>
<p>在进行算术计算时，所有以八进制和十六进制表示的数值最终都将被转换成十进制数值。</p>
</blockquote>
<p>NaN（Not a Number），0除以 0会返回 NaN，因此不会影响其他代码的执行</p>
<p>NaN 与任何值都不相等，包括 NaN 本身，ECMAScript 定义了<code>isNaN()</code>函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">100</span>);  <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0o100</span>); <span class="comment">// 八进制的64</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0xAB</span>);  <span class="comment">// 十六进制的171</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span>/<span class="number">0</span>);   <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>/<span class="number">0</span>);   <span class="comment">// Infinity</span></span><br><span class="line"><span class="built_in">console</span>.log(-<span class="number">1</span>/<span class="number">0</span>);  <span class="comment">// -Infinity</span></span><br></pre></td></tr></table></figure>

<h4 id="浮点数值"><a href="#浮点数值" class="headerlink" title="浮点数值"></a>浮点数值</h4><p>所谓浮点数值，就是该数值中必须包含一个小数点，并且小数点后面必须至少有一位数字。虽然小数点前面可以没有整数，但我们不推荐这种写法。以下是浮点数值的几个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> floatNum1 = <span class="number">1.1</span>; </span><br><span class="line"><span class="keyword">var</span> floatNum2 = <span class="number">0.1</span>; </span><br><span class="line"><span class="keyword">var</span> floatNum3 = <span class="number">.1</span>;   <span class="comment">// 有效，但不推荐</span></span><br></pre></td></tr></table></figure>

<p>于保存浮点数值需要的内存空间是保存整数值的两倍，因此 ECMAScript 会不失时机地将浮点数值转换为整数值。显然，如果小数点后面没有跟任何数字，那么这个数值就可以作为整数值来保存。同样地，如果浮点数值本身表示的就是一个整数如 1.0），那么该值也会被转换为整数，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> floatNum1 = <span class="number">1.</span>;        <span class="comment">// 小数点后面没有数字——解析为 1 </span></span><br><span class="line"><span class="keyword">var</span> floatNum2 = <span class="number">10.0</span>;      <span class="comment">// 整数——解析为 10</span></span><br></pre></td></tr></table></figure>

<p>对于那些极大或极小的数值，可以用 e 表示法（即科学计数法）表示的浮点数值表示。用 e 表示法表示的数值等于 e 前面的数值乘以 10 的指数次幂。ECMAScript 中 e 表示法的格式也是如此，即前面是一个数值（可以是整数也可以是浮点），中间是一个大写或小写的字母 E，后面是 10 的幂中的指数，该幂值将用来与前面的数相乘。下面是一个使用 e 表示法表示数值的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> floatNum = <span class="number">3.125e7</span>;  <span class="comment">// 等于 31250000</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，使用 e 表示法表示的变量 floatNum 的形式虽然简洁，但它的实际值则是 31250000。在此，e 表示法的实际含义就是“3.125 乘以 107”。</p>
<p>也可以使用 e 表示法表示极小的数值，如 0.00000000000000003，这个数值可以使用更简洁的 3e-17 表示。在默认情况下，ECMASctipt 会将那些小数点后面带有 6 个零以上的浮点数值转换为以 e 表示法表示的数值（例如，0.0000003 会被转换成 3e-7）。</p>
<p>浮点数值的最高精度是 17 位小数，但在进行算术计算时其精确度远远不如整数。例如，0.1 加 0.2 的结果不是 0.3，而是 0.30000000000000004。这个小小的舍入误差会导致无法测试特定的浮点数值。</p>
<h4 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h4><p>由于内存的限制，ECMAScript 并不能保存世界上所有的数值。</p>
<ul>
<li>能够表示的最小数值保存在<code>Number.MIN_VALUE</code> 中——在大多数浏览器中，这个值是 5e-324；</li>
<li>能够表示的最大数值保存在 <code>Number.MAX_VALUE</code> 中——在大多数浏览器中，这个值是 1.7976931348623157e+308。</li>
</ul>
<p>结果得到了一个超出 JavaScript 数值范围的值，那么这个数值将被自动转换成特殊的 Infinity 值。具体来说，如果这个数值是负数，则会被转换成-Infinity（负无穷），如果这个数值是正数，则会被转换成 Infinity（正无穷）。</p>
<p>如上所述，如果某次计算返回了正或负的 Infinity 值，那么该值将无法继续参与下一次的计算，因为 Infinity 不是能够参与计算的数值。要想确定一个数值是不是有穷的（换句话说，是不是位于最小和最大的数值之间），可以使用 <code>isFinite()</code> 函数。这个函数在参数位于最小与最大数值之间时会返回 true，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="built_in">Number</span>.MAX_VALUE + <span class="built_in">Number</span>.MAX_VALUE; </span><br><span class="line">alert(<span class="built_in">isFinite</span>(result));  <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>尽管在计算中很少出现某些值超出表示范围的情况，但在执行极小或极大数值的计算时，检测监控这些值是可能的，也是必需的。</p>
<h4 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h4><p>NaN，即非数值（Not a Number）是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。例如，在其他编程语言中，任何数值除以 0 都会导致错误，从而停止代码执行。但在 ECMAScript 中，0除以 0 会返回 NaN，因此不会影响其他代码的执行。</p>
<p>NaN 本身有两个非同寻常的特点。首先，任何涉及 NaN 的操作（例如 <code>NaN/10</code>）都会返回 NaN，这个特点在多步计算中有可能导致问题。其次，NaN 与任何值都不相等，包括 NaN 本身。例如，下面的代码会返回 false：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="literal">NaN</span> == <span class="literal">NaN</span>);   <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>针对 NaN 的这两个特点，ECMAScript 定义了 <code>isNaN()</code> 函数。这个函数接受一个参数，该参数可以是任何类型，而函数会帮我们确定这个参数是否“不是数值”。<code>isNaN()</code> 在接收到一个值之后，会尝试将这个值转换为数值。某些不是数值的值会直接转换为数值，例如字符串“10”或 Boolean 值。而任何不能被转换为数值的值都会导致这个函数返回 true。请看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="built_in">isNaN</span>(<span class="literal">NaN</span>));         <span class="comment">//true </span></span><br><span class="line">alert(<span class="built_in">isNaN</span>(<span class="number">10</span>));          <span class="comment">//false（10 是一个数值） </span></span><br><span class="line">alert(<span class="built_in">isNaN</span>(<span class="string">&quot;10&quot;</span>));        <span class="comment">//false（可以被转换成数值 10） </span></span><br><span class="line">alert(<span class="built_in">isNaN</span>(<span class="string">&quot;blue&quot;</span>));      <span class="comment">//true（不能转换成数值） </span></span><br><span class="line">alert(<span class="built_in">isNaN</span>(<span class="literal">true</span>));        <span class="comment">//false（可以被转换成数值 1）</span></span><br></pre></td></tr></table></figure>

<p>这个例子测试了 5 个不同的值。测试的第一个值是 NaN 本身，结果当然会返回 true。然后分别测试了数值 10 和字符串”10”，结果这两个测试都返回了 false，因为前者本身就是数值，而后者可以被转换成数值。但是，字符串”blue”不能被转换成数值，因此函数返回了 true。由于 Boolean 值 true可以转换成数值 1，因此函数返回 false。</p>
<h4 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h4><p>有 3 个函数可以把非数值转换为数值：<code>Number()</code> 、<code>parseInt()</code> 和 <code>parseFloat()</code> 。第一个函数，即转型函数 Number()可以用于任何数据类型，而另两个函数则专门用于把字符串转换成数值。这 3 个函数对于同样的输入会有返回不同的结果。</p>
<p>Number()函数的转换规则如下：</p>
<ul>
<li>如果是 Boolean 值，true 和 false 将分别被转换为 1 和 0。</li>
<li>如果是数字值，只是简单的传入和返回。</li>
<li>如果是 null 值，返回 0。</li>
<li>如果是 undefined，返回 NaN。</li>
<li>如果是字符串，遵循下列规则：<ul>
<li>如果字符串中只包含数字（包括前面带正号或负号的情况），则将其转换为十进制数值，即”1”会变成 1，”123”会变成 123，而”011”会变成 11（注意：前导的零被忽略了）；</li>
<li>如果字符串中包含有效的浮点格式，如”1.1”，则将其转换为对应的浮点数值（同样，也会忽略前导零）；</li>
<li>如果字符串中包含有效的十六进制格式，例如”0xf”，则将其转换为相同大小的十进制整数值；</li>
<li>如果字符串是空的（不包含任何字符），则将其转换为 0；</li>
<li>如果字符串中包含除上述格式之外的字符，则将其转换为 NaN。</li>
</ul>
</li>
<li>如果是对象，则调用对象的 <code>valueOf()</code> 方法，然后依照前面的规则转换返回的值。如果转换的结果是 <code>NaN</code>，则调用对象的 <code>toString()</code> 方法，然后再次依照前面的规则转换返回的字符串值。</li>
</ul>
<p>根据这么多的规则使用 <code>Number()</code> 把各种数据类型转换为数值确实有点复杂。下面还是给出几个具体的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="built_in">Number</span>(<span class="string">&quot;Hello world!&quot;</span>);      <span class="comment">// NaN </span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="built_in">Number</span>(<span class="string">&quot;&quot;</span>);                  <span class="comment">// 0 </span></span><br><span class="line"><span class="keyword">var</span> num3 = <span class="built_in">Number</span>(<span class="string">&quot;000011&quot;</span>);            <span class="comment">// 11 </span></span><br><span class="line"><span class="keyword">var</span> num4 = <span class="built_in">Number</span>(<span class="literal">true</span>);                <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>字符串“Hello world!”会被转换为 NaN，因为其中不包含任何有意义的数字值。</li>
<li>空字符串会被转换为 0。</li>
<li>字符串”000011”会被转换为 11，因为忽略了其前导的零。</li>
<li>true 值被转换为 1。</li>
</ul>
<p>由于 <code>Number()</code> 函数在转换字符串时比较复杂而且不够合理，因此在处理整数的时候更常用的是<code>parseInt()</code> 函数。</p>
<p><code>parseInt()</code> 函数在转换字符串时，更多的是看其是否符合数值模式。它会忽略字符串前面的空格，直至找到第一个非空格字符。如果第一个字符不是数字字符或者负号，<code>parseInt()</code> 就会返回 NaN；也就是说，用 <code>parseInt()</code> 转换空字符串会返回 NaN（<code>Number()</code>对空字符返回 0）。如果第一个字符是数字字符，<code>parseInt()</code> 会继续解析第二个字符，直到解析完所有后续字符或者遇到了一个非数字字符。例如，“1234blue” 会被转换为 1234，因为”blue”会被完全忽略。类似地，”22.5”会被转换为 22，因为小数点并不是有效的数字字符。</p>
<p>如果字符串中的第一个字符是数字字符，<code>parseInt()</code> 也能够识别出各种整数格式（即前面讨论的十进制、八进制和十六进制数）。也就是说，如果字符串以“0x”开头且后跟数字字符，就会将其当作一个十六进制整数；如果字符串以“0”开头且后跟数字字符，则会将其当作一个八进制数来解析。</p>
<p>下面给出一些例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="built_in">parseInt</span>(<span class="string">&quot;1234blue&quot;</span>);    <span class="comment">// 1234 </span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="built_in">parseInt</span>(<span class="string">&quot;&quot;</span>);            <span class="comment">// NaN </span></span><br><span class="line"><span class="keyword">var</span> num3 = <span class="built_in">parseInt</span>(<span class="string">&quot;0xA&quot;</span>);         <span class="comment">// 10（十六进制数） </span></span><br><span class="line"><span class="keyword">var</span> num4 = <span class="built_in">parseInt</span>(<span class="number">22.5</span>);          <span class="comment">// 22 </span></span><br><span class="line"><span class="keyword">var</span> num5 = <span class="built_in">parseInt</span>(<span class="string">&quot;070&quot;</span>);         <span class="comment">// 56（八进制数 ECMAScript 3） </span></span><br><span class="line"><span class="keyword">var</span> num6 = <span class="built_in">parseInt</span>(<span class="string">&quot;70&quot;</span>);          <span class="comment">// 70（十进制数） </span></span><br><span class="line"><span class="keyword">var</span> num7 = <span class="built_in">parseInt</span>(<span class="string">&quot;0xf&quot;</span>);         <span class="comment">// 15（十六进制数）</span></span><br></pre></td></tr></table></figure>

<p>在使用 <code>parseInt()</code> 解析像八进制字面量的字符串时，ECMAScript 3 和 5 存在分歧。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ECMAScript 3 认为是 56（八进制），ECMAScript 5 认为是 70（十进制） </span></span><br><span class="line"><span class="keyword">var</span> num = <span class="built_in">parseInt</span>(<span class="string">&quot;070&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>在 ECMAScript 3 JavaScript 引擎中，“070” 被当成八进制字面量，因此转换后的值是十进制的 56。而在 ECMAScript 5 JavaScript 引擎中，<code>parseInt()</code> 已经不具有解析八进制值的能力，因此前导的零会被认为无效，从而将这个值当成 “70” ，结果就得到十进制的 70。在 ECMAScript 5 中，即使是在非严格模式下也会如此。</p>
<p>为了消除在使用 <code>parseInt()</code> 函数时可能导致的上述困惑，可以为这个函数提供第二个参数：转换时使用的基数（即多少进制）。如果知道要解析的值是十六进制格式的字符串，那么指定基数 16 作为第二个参数，可以保证得到正确的结果，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="built_in">parseInt</span>(<span class="string">&quot;0xAF&quot;</span>, <span class="number">16</span>);  <span class="comment">//175</span></span><br></pre></td></tr></table></figure>

<p>实际上，如果指定了 16 作为第二个参数，字符串可以不带前面的“0x”，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="built_in">parseInt</span>(<span class="string">&quot;AF&quot;</span>, <span class="number">16</span>);  <span class="comment">//175 </span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="built_in">parseInt</span>(<span class="string">&quot;AF&quot;</span>);   <span class="comment">//NaN</span></span><br></pre></td></tr></table></figure>

<p>这个例子中的第一个转换成功了，而第二个则失败了。差别在于第一个转换传入了基数，明确告诉parseInt()要解析一个十六进制格式的字符串；而第二个转换发现第一个字符不是数字字符，因此就自动终止了。</p>
<p>指定基数会影响到转换的输出结果。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>, <span class="number">2</span>);     <span class="comment">//2  （按二进制解析） </span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>, <span class="number">8</span>);      <span class="comment">//8  （按八进制解析） </span></span><br><span class="line"><span class="keyword">var</span> num3 = <span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>, <span class="number">10</span>);     <span class="comment">//10 （按十进制解析） </span></span><br><span class="line"><span class="keyword">var</span> num4 = <span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>, <span class="number">16</span>);     <span class="comment">//16 （按十六进制解析）</span></span><br></pre></td></tr></table></figure>

<p>不指定基数意味着让 <code>parseInt()</code> 决定如何解析输入的字符串，因此为了避免错误的解析，我们建议无论在什么情况下都明确指定基数。</p>
<blockquote>
<p>多数情况下，我们要解析的都是十进制数值，因此始终将 10 作为第二个参数是非常必要的。</p>
</blockquote>
<p>与 <code>parseInt()</code> 函数类似，<code>parseFloat()</code> 也是从第一个字符（位置 0）开始解析每个字符。而且也是一直解析到字符串末尾，或者解析到遇见一个无效的浮点数字字符为止。也就是说，字符串中的第一个小数点是有效的，而第二个小数点就是无效的了，因此它后面的字符串将被忽略。举例来说，“22.34.5” 将会被转换为 22.34。</p>
<p>除了第一个小数点有效之外，<code>parseFloat()</code> 与 <code>parseInt()</code> 的第二个区别在于它始终都会<strong>忽略前导的零</strong>。<code>parseFloat()</code> 可以识别前面讨论过的所有浮点数值格式，也包括十进制整数格式。但十六进制格式的字符串则始终会被转换成 0。由于 <code>parseFloat()</code> <strong>只解析十进制值</strong>，因此它没有用第二个参数指定基数的用法。最后还要注意一点：如果字符串包含的是一个可解析为整数的数（没有小数点，或者小数点后都是零），<code>parseFloat()</code> 会返回整数。以下是使用 <code>parseFloat()</code> 转换数值的几个典型示例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="built_in">parseFloat</span>(<span class="string">&quot;1234blue&quot;</span>);        <span class="comment">//1234 （整数） </span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="built_in">parseFloat</span>(<span class="string">&quot;0xA&quot;</span>);              <span class="comment">//0 </span></span><br><span class="line"><span class="keyword">var</span> num3 = <span class="built_in">parseFloat</span>(<span class="string">&quot;22.5&quot;</span>);             <span class="comment">//22.5 </span></span><br><span class="line"><span class="keyword">var</span> num4 = <span class="built_in">parseFloat</span>(<span class="string">&quot;22.34.5&quot;</span>);          <span class="comment">//22.34 </span></span><br><span class="line"><span class="keyword">var</span> num5 = <span class="built_in">parseFloat</span>(<span class="string">&quot;0908.5&quot;</span>);          <span class="comment">//908.5 </span></span><br><span class="line"><span class="keyword">var</span> num6 = <span class="built_in">parseFloat</span>(<span class="string">&quot;3.125e7&quot;</span>);          <span class="comment">//31250000</span></span><br></pre></td></tr></table></figure>

<h3 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h3><p>ECMAScript 中的对象其实就是一组数据和功能的集合。对象可以通过执行 new 操作符后跟要创建的对象类型的名称来创建。而创建 Object 类型的实例并为其添加属性和（或）方法，就可以创建自定义对象，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure>

<p>这个语法与 Java 中创建对象的语法相似；但在 ECMAScript 中，如果不给构造函数传递参数，则可以省略后面的那一对圆括号。也就是说，在像前面这个示例一样不传递参数的情况下，完全可以省略那对圆括号（但这不是推荐的做法）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>; <span class="comment">// 有效，但不推荐省略圆括号</span></span><br></pre></td></tr></table></figure>

<p>仅仅创建 Object 的实例并没有什么用处，但关键是要理解一个重要的思想：即在 ECMAScript 中，（就像 Java 中的 <code>java.lang.Object</code> 对象一样）Object 类型是所有它的实例的基础。换句话说，Object 类型所具有的任何属性和方法也同样存在于更具体的对象中。</p>
<p>Object 的每个实例都具有下列属性和方法</p>
<ul>
<li><code>constructor</code>：保存着用于创建当前对象的函数。对于前面的例子而言，构造函数（constructor）就是 <code>Object()</code>。</li>
<li><code>hasOwnProperty(propertyName)</code>：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名（<code>propertyName</code>）必须以字符串形式指定（例如：<code>o.hasOwnProperty(&quot;name&quot;)</code>）。</li>
<li><code>isPrototypeOf(object)</code>：用于检查传入的对象是否是传入对象的原型。</li>
<li><code>propertyIsEnumerable(propertyName)</code>：用于检查给定的属性是否能够使用 for-in 语句来枚举。与 <code>hasOwnProperty()</code>方法一样，作为参数的属性名必须以字符串形式指定。</li>
<li><code>toLocaleString()</code>：返回对象的字符串表示，该字符串与执行环境的地区对应。</li>
<li><code>toString()</code>：返回对象的字符串表示。</li>
<li><code>valueOf()</code>：返回对象的字符串、数值或布尔值表示。通常与 <code>toString()</code> 方法的返回值相同。</li>
</ul>
<p>由于在 ECMAScript 中 Object 是所有对象的基础，因此所有对象都具有这些基本的属性和方法。</p>
<blockquote>
<p>从技术角度讲，ECMA-262 中对象的行为不一定适用于 JavaScript 中的其他对象。浏览器环境中的对象，比如 BOM 和 DOM 中的对象，都属于宿主对象，因为它们是由宿主实现提供和定义的。ECMA-262 不负责定义宿主对象，因此宿主对象可能会也可能不会继承 Object。</p>
</blockquote>
<h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><p>ECMA-262 描述了一组用于操作数据值的操作符，包括算术操作符（如加号和减号）、位操作符、关系操作符和相等操作符。ECMAScript 操作符的与众不同之处在于，它们能够适用于很多值，例如字符串、数字值、布尔值，甚至对象。不过，在应用于对象时，相应的操作符通常都会调用对象的 <code>valueOf()</code> 和（或）<code>toString()</code> 方法，以便取得可以操作的值。</p>
<h4 id="一元操作符"><a href="#一元操作符" class="headerlink" title="一元操作符"></a>一元操作符</h4><p>一元操作符只能操作一个值的操作符，是 ECMAScript 中最简单的操作符。</p>
<h5 id="自增和自减"><a href="#自增和自减" class="headerlink" title="自增和自减"></a>自增和自减</h5><p>递增和递减操作符直接借鉴自 C，而且各有两个版本：前置型和后置型。顾名思义，前置型应该位于要操作的变量之前，而后置型则应该位于要操作的变量之后。因此，在使用前置递增操作符给一个数值加 1 时，要把两个加号（++）放在这个数值变量前面，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">29</span>; </span><br><span class="line">++age;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，前置递增操作符把 age 的值变成了 30（为 29 加上了 1）。实际上，执行这个前置递增操作与执行以下操作的效果相同：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">29</span>; </span><br><span class="line">age = age + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>执行前置递减操作的方法也类似，结果会从一个数值中减去 1。使用前置递减操作符时，要把两个减号（–）放在相应变量的前面，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">29</span>; </span><br><span class="line">--age;</span><br></pre></td></tr></table></figure>

<p>这样，age 变量的值就减少为 28（从 29 中减去了 1）。</p>
<p>执行前置递增和递减操作时，变量的值都是在语句被求值以前改变的。（在计算机科学领域，这种情况通常被称作<strong>副效应</strong>。）请看下面这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">29</span>; </span><br><span class="line"><span class="keyword">var</span> anotherAge = --age + <span class="number">2</span>; </span><br><span class="line"> </span><br><span class="line">alert(age);           <span class="comment">// 输出 28 </span></span><br><span class="line">alert(anotherAge);    <span class="comment">// 输出 30</span></span><br></pre></td></tr></table></figure>

<p>这个例子中变量 <code>anotherAge</code> 的初始值等于变量 <code>age</code> 的值前置递减之后加 2。由于先执行了减法操作，<code>age</code> 的值变成了 28，所以再加上 2 的结果就是 30。</p>
<p>由于前置递增和递减操作与执行语句的优先级相等，因此整个语句会从左至右被求值。再看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="number">2</span>; </span><br><span class="line"><span class="keyword">var</span> num2 = <span class="number">20</span>; </span><br><span class="line"><span class="keyword">var</span> num3 = --num1 + num2;      <span class="comment">// 等于 21 </span></span><br><span class="line"><span class="keyword">var</span> num4 = num1 + num2;        <span class="comment">// 等于 21</span></span><br></pre></td></tr></table></figure>

<p>在这里，num3 之所以等于 21 是因为 num1 先减去了 1 才与 num2 相加。而变量 num4 也等于 21 是因为相应的加法操作使用了 num1 减去 1 之后的值。</p>
<p>后置型递增和递减操作符的语法不变（仍然分别是++和–），只不过要放在变量的后面而不是前面。后置递增和递减与前置递增和递减有一个非常重要的区别，即递增和递减操作是在包含它们的语句被求值之后才执行的。这个区别在某些情况下不是什么问题，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">29</span>; </span><br><span class="line">age++;</span><br></pre></td></tr></table></figure>

<p>把递增操作符放在变量后面并不会改变语句的结果，因为递增是这条语句的唯一操作。</p>
<p>但是，当语句中还包含其他操作时，上述区别就会非常明显了。请看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="number">2</span>; </span><br><span class="line"><span class="keyword">var</span> num2 = <span class="number">20</span>; </span><br><span class="line"><span class="keyword">var</span> num3 = num1-- + num2;     <span class="comment">// 等于等于 22 </span></span><br><span class="line"><span class="keyword">var</span> num4 = num1 + num2;       <span class="comment">// 等于 21</span></span><br></pre></td></tr></table></figure>

<p>这里仅仅将前置递减改成了后置递减，就立即可以看到差别。在前面使用前置递减的例子中，num3 和 num4 最后都等于 21。而在这个例子中，num3 等于 22，num4 等于 21。差别的根源在于，这里在计算 num3 时使用了 num1 的原始值 2 完成了加法计算，而 num4 则使用了递减后的值 1 。</p>
<p>所有这 4 个操作符对任何值都适用，也就是它们不仅适用于整数，还可以用于字符串、布尔值、浮点数值和对象。在应用于不同的值时，递增和递减操作符遵循下列规则：</p>
<ul>
<li>在应用于一个包含有效数字字符的字符串时，先将其转换为数字值，再执行加减 1 的操作。字符串变量变成数值变量。</li>
<li>在应用于一个不包含有效数字字符的字符串时，将变量的值设置为 NaN。字符串变量变成数值变量。</li>
<li>在应用于布尔值 false 时，先将其转换为 0 再执行加减 1 的操作。布尔值变量变成数值变量。</li>
<li>在应用于布尔值 true 时，先将其转换为 1 再执行加减 1 的操作。布尔值变量变成数值变量。</li>
<li>在应用于浮点数值时，执行加减 1 的操作。</li>
<li>在应用于对象时，先调用对象的 <code>valueOf()</code> 方法以取得一个可供操作的值。然后对该值应用前述规则。如果结果是 NaN，则在调用 <code>toString()</code> 方法后再应用前述规则。对象变量变成数值变量。</li>
</ul>
<p>以下示例展示了上面的一些规则：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">&quot;2&quot;</span>; </span><br><span class="line"><span class="keyword">var</span> s2 = <span class="string">&quot;z&quot;</span>; </span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">false</span>; </span><br><span class="line"><span class="keyword">var</span> f = <span class="number">1.1</span>; </span><br><span class="line"><span class="keyword">var</span> o = &#123;  </span><br><span class="line">    valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line">s1++;     <span class="comment">// 值变成数值 3 </span></span><br><span class="line">s2++;     <span class="comment">// 值变成 NaN </span></span><br><span class="line">b++;      <span class="comment">// 值变成数值 1 </span></span><br><span class="line">f--;      <span class="comment">// 值变成 0.10000000000000009（由于浮点舍入错误所致） </span></span><br><span class="line">o--;      <span class="comment">// 值变成数值-2</span></span><br></pre></td></tr></table></figure>

<h5 id="一元加和减操作符"><a href="#一元加和减操作符" class="headerlink" title="一元加和减操作符"></a>一元加和减操作符</h5><p>绝大多数开发人员对一元加和减操作符都不会陌生，而且这两个 ECMAScript 操作符的作用与数学书上讲的完全一样。一元加操作符以一个加号（+）表示，放在数值前面，对数值不会产生任何影响，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">25</span>; </span><br><span class="line">num = +num;     <span class="comment">// 仍然是 25</span></span><br></pre></td></tr></table></figure>

<p>不过，在对非数值应用一元加操作符时，该操作符会像 <code>Number()</code> 转型函数一样对这个值执行转换。换句话说，布尔值 false 和 true 将被转换为 0 和 1，字符串值会被按照一组特殊的规则进行解析，而对象是先调用它们的 <code>valueOf()</code>和（或）<code>toString()</code> 方法，再转换得到的值。</p>
<p>下面的例子展示了对不同数据类型应用一元加操作符的结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">&quot;01&quot;</span>; </span><br><span class="line"><span class="keyword">var</span> s2 = <span class="string">&quot;1.1&quot;</span>; </span><br><span class="line"><span class="keyword">var</span> s3 = <span class="string">&quot;z&quot;</span>; </span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">false</span>; </span><br><span class="line"><span class="keyword">var</span> f = <span class="number">1.1</span>; </span><br><span class="line"><span class="keyword">var</span> o = &#123; </span><br><span class="line">    valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line">s1 = +s1;     <span class="comment">// 值变成数值 1 </span></span><br><span class="line">s2 = +s2;     <span class="comment">// 值变成数值 1.1 </span></span><br><span class="line">s3 = +s3;     <span class="comment">// 值变成 NaN </span></span><br><span class="line">b = +b;       <span class="comment">// 值变成数值 0 </span></span><br><span class="line">f = +f;       <span class="comment">// 值未变，仍然是 1.1 </span></span><br><span class="line">o = +o;       <span class="comment">// 值变成数值-1</span></span><br></pre></td></tr></table></figure>

<p>一元减操作符主要用于表示负数，例如将 1 转换成-1。下面的例子演示了这个简单的转换过程：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">25</span>; </span><br><span class="line">num = -num;    <span class="comment">// 变成了-25</span></span><br></pre></td></tr></table></figure>

<p>在将一元减操作符应用于数值时，该值会变成负数（如上面的例子所示）。而当应用于非数值时，一元减操作符遵循与一元加操作符相同的规则，最后再将得到的数值转换为负数，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">&quot;01&quot;</span>; </span><br><span class="line"><span class="keyword">var</span> s2 = <span class="string">&quot;1.1&quot;</span>; </span><br><span class="line"><span class="keyword">var</span> s3 = <span class="string">&quot;z&quot;</span>; </span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">false</span>; </span><br><span class="line"><span class="keyword">var</span> f = <span class="number">1.1</span>; </span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">s1 = -s1;         <span class="comment">// 值变成了数值-1 </span></span><br><span class="line">s2 = -s2;         <span class="comment">// 值变成了数值-1.1 </span></span><br><span class="line">s3 = -s3;         <span class="comment">// 值变成了 NaN </span></span><br><span class="line">b = -b;           <span class="comment">// 值变成了数值 0 </span></span><br><span class="line">f = -f;           <span class="comment">// 变成了-1.1 </span></span><br><span class="line">o = -o;           <span class="comment">// 值变成了数值 1</span></span><br></pre></td></tr></table></figure>

<p>一元加和减操作符主要用于基本的算术运算，也可以像前面示例所展示的一样用于转换数据类型。</p>
<h4 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h4><p>位操作符用于在最基本的层次上，即按内存中表示数值的位来操作数值。ECMAScript 中的所有数值都以 IEEE-754 64 位格式存储，但位操作符并不直接操作 64 位的值。而是先将 64 位的值转换成 32 位的整数，然后执行操作，最后再将结果转换回 64 位。对于开发人员来说，由于 64 位存储格式是透明的，因此整个过程就像是只存在 32 位的整数一样。</p>
<p>对于有符号的整数，32 位中的前 31 位用于表示整数的值。第 32 位用于表示数值的符号：0 表示正数，1 表示负数。这个表示符号的位叫做符号位，符号位的值决定了其他位数值的格式。其中，正数以纯二进制格式存储，31 位中的每一位都表示 2 的幂。第一位（叫做位 0）表示 2<sup>0</sup>，第二位表示 2<sup>1</sup>，以此类推 。 没有用到的位以 0 填充 ，即忽略不计 。</p>
<p>负数同样以二进制码存储，但使用的格式是二进制补码。计算一个数值的二进制补码，需要经过下列 3 个步骤：</p>
<ul>
<li>求这个数值绝对值的二进制码</li>
<li>求二进制反码，即将 0 替换为 1，将 1 替换为 0；</li>
<li>得到的二进制反码加 1。</li>
</ul>
<p>要根据这 3 个步骤求得-18 的二进制码，首先就要求得 18 的二进制码，即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0000 0000 0000 0000 0000 0000 0001 0010</span><br></pre></td></tr></table></figure>

<p>然后，求其二进制反码，即 0 和 1 互换：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1111 1111 1111 1111 1111 1111 1110 1101</span><br></pre></td></tr></table></figure>

<p>最后，二进制反码加 1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1111 1111 1111 1111 1111 1111 1110 1101 </span><br><span class="line">                                      1 </span><br><span class="line">--------------------------------------- </span><br><span class="line">1111 1111 1111 1111 1111 1111 1110 1110</span><br></pre></td></tr></table></figure>

<p>这样，就求得了-18 的二进制表示。要注意的是，在处理有符号整数时，是不能访问位 31 的。</p>
<p>ECMAScript 会尽力向我们隐藏所有这些信息。换句话说，在以二进制字符串形式输出一个负数时，我们看到的只是这个负数绝对值的二进制码前面加上了一个负号。如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = -<span class="number">18</span>; </span><br><span class="line">alert(num.toString(<span class="number">2</span>));    <span class="comment">// &quot;-10010&quot;</span></span><br></pre></td></tr></table></figure>

<p>要把数值-18 转换成二进制字符串时，得到的结果是“-10010”。这说明转换过程理解了二进制补码并将其以更合乎逻辑的形式展示了出来。</p>
<p>在 ECMAScript 中，当对数值应用位操作符时，后台会发生如下转换过程：64 位的数值被转换成 32 位数值，然后执行位操作，最后再将 32 位的结果转换回 64 位数值。这样，表面上看起来就好像是在操作 32 位数值，就跟在其他语言中以类似方式执行二进制操作一样。但这个转换过程也导致了一个严重的副效应，即在对特殊的 NaN 和 Infinity 值应用位操作时，这两个值都会被当成 0 来处理。</p>
<p>如果对非数值应用位操作符，会先使用 <code>Number()</code> 函数将该值转换为一个数值（自动完成），然后再应用位操作。得到的结果将是一个数值。</p>
<p>① 按位非（NOT）</p>
<p>按位非操作符由一个波浪线（<code>~</code>）表示，执行按位非的结果就是返回数值的反码。按位非是 ECMAScript 操作符中少数几个与二进制计算有关的操作符之一。下面看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="number">25</span>;        <span class="comment">// 二进制 00000000000000000000000000011001 </span></span><br><span class="line"><span class="keyword">var</span> num2 = ~num1;     <span class="comment">// 二进制 11111111111111111111111111100110 </span></span><br><span class="line">alert(num2);          <span class="comment">// -26</span></span><br></pre></td></tr></table></figure>

<p>这里，对 25 执行按位非操作，结果得到了-26。这也验证了按位非操作的本质：操作数的负值减 1。因此，下面的代码也能得到相同的结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="number">25</span>; </span><br><span class="line"><span class="keyword">var</span> num2 = -num1 - <span class="number">1</span>; </span><br><span class="line">alert(num2);            <span class="comment">// &quot;-26&quot;</span></span><br></pre></td></tr></table></figure>

<p>虽然以上代码也能返回同样的结果，但由于按位非是在数值表示的最底层执行操作，因此速度更快。</p>
<p>② 按位与（AND）</p>
<p>按位与操作符由一个和号字符（<code>&amp;</code>）表示，它有两个操作符数。从本质上讲，按位与操作就是将两个数值的每一位对齐，然后根据下表中的规则，对相同位置上的两个数执行 AND 操作：</p>
<table>
<thead>
<tr>
<th>第一个数值的位</th>
<th>第二个数值的位</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody></table>
<p>简而言之，按位与操作只在两个数值的对应位都是 1 时才返回 1，任何一位是 0，结果都是 0。</p>
<p>下面看一个对 25 和 3 执行按位与操作的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="number">25</span> &amp; <span class="number">3</span>; </span><br><span class="line">alert(result);     <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<p>可见，对 25 和 3 执行按位与操作的结果是 1。为什么呢？请看其底层操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> 25 &#x3D; 0000 0000 0000 0000 0000 0000 0001 1001 </span><br><span class="line">  3 &#x3D; 0000 0000 0000 0000 0000 0000 0000 0011 </span><br><span class="line">--------------------------------------------- </span><br><span class="line">AND &#x3D; 0000 0000 0000 0000 0000 0000 0000 0001</span><br></pre></td></tr></table></figure>

<p>原来，25 和 3 的二进制码对应位上只有一位同时是 1，而其他位的结果自然都是 0，因此最终结果等于 1。</p>
<p>③ 按位或（OR）</p>
<p>按位或操作符由一个竖线符号（<code>|</code>）表示，同样也有两个操作数。按位或操作遵循下面这个真值表。</p>
<table>
<thead>
<tr>
<th>第一个数值的位</th>
<th>第二个数值的位</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody></table>
<p>由此可见，按位或操作在有一个位是 1 的情况下就返回 1，而只有在两个位都是 0 的情况下才返回 0。</p>
<p>如果在前面按位与的例子中对 25 和 3 执行按位或操作，则代码如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="number">25</span> | <span class="number">3</span>; </span><br><span class="line">alert(result);       <span class="comment">//27</span></span><br></pre></td></tr></table></figure>

<p>25 与 3 按位或的结果是 27：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">25</span> = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">1001</span> </span><br><span class="line"> <span class="number">3</span> = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0011</span> </span><br><span class="line">-------------------------------------------- </span><br><span class="line">OR = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">1011</span></span><br></pre></td></tr></table></figure>

<p>这两个数值的都包含 4 个 1，因此可以把每个 1 直接放到结果中。二进制码 11011 等于十进制值 27。</p>
<p>④ 按位异或（XOR）</p>
<p>按位异或操作符由一个插入符号（<code>^</code>）表示，也有两个操作数。以下是按位异或的真值表。</p>
<table>
<thead>
<tr>
<th>第一个数值的位</th>
<th>第二个数值的位</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody></table>
<p>按位异或与按位或的不同之处在于，这个操作在两个数值对应位上只有一个 1 时才返回 1，如果对应的两位都是 1 或都是 0，则返回 0。</p>
<p>对 25 和 3 执行按位异或操作的代码如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="number">25</span> ^ <span class="number">3</span>; </span><br><span class="line">alert(result);    <span class="comment">//26</span></span><br></pre></td></tr></table></figure>

<p>25 与 3 按位异或的结果是 26，其底层操作如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  25 &#x3D; 0000 0000 0000 0000 0000 0000 0001 1001 </span><br><span class="line">   3 &#x3D; 0000 0000 0000 0000 0000 0000 0000 0011 </span><br><span class="line">--------------------------------------------- </span><br><span class="line">XOR  &#x3D; 0000 0000 0000 0000 0000 0000 0001 1010</span><br></pre></td></tr></table></figure>

<p>这两个数值都包含 4 个 1，但第一位上则都是 1，因此结果的第一位变成了 0。而其他位上的 1 在另一个数值中都没有对应的 1，可以直接放到结果中。二进制码 11010 等于十进制值 26（注意这个结果比执行按位或时小 1）。</p>
<p>⑤ 左移</p>
<p>左移操作符由两个小于号（<code>&lt;&lt;</code>）表示，这个操作符会将数值的所有位向左移动指定的位数。例如，<br>如果将数值 2（二进制码为 10）向左移动 5 位，结果就是 64（二进制码为 1000000），代码如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oldValue = <span class="number">2</span>;                      <span class="comment">// 等于二进制的 10 </span></span><br><span class="line"><span class="keyword">var</span> newValue = oldValue &lt;&lt; <span class="number">5</span>;          <span class="comment">// 等于二进制的 1000000，十进制的 64</span></span><br></pre></td></tr></table></figure>

<p>注意，在向左移位后，原数值的右侧多出了 5 个空位。左移操作会以 0 来填充这些空位，以便得到的结果是一个完整的 32 位二进制数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0000 0000 0000 0000 0000 0000 0000 0010 &#x2F;&#x2F; 2</span><br><span class="line">0000 0000 0000 0000 0000 0000 0100 0000 &#x2F;&#x2F; 64</span><br></pre></td></tr></table></figure>

<p>注意，左移不会影响操作数的符号位。换句话说，如果将-2 向左移动 5 位，结果将是-64，而非 64。</p>
<p>⑥ 有符号的右移</p>
<p>有符号的右移操作符由两个大于号（<code>&gt;&gt;</code>）表示，这个操作符会将数值向右移动，但保留符号位（即正负号标记）。有符号的右移操作与左移操作恰好相反，即如果将 64 向右移动 5 位，结果将变回 2：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oldValue = <span class="number">64</span>;               <span class="comment">// 等于二进制的 1000000 </span></span><br><span class="line"><span class="keyword">var</span> newValue = oldValue &gt;&gt; <span class="number">5</span>;    <span class="comment">// 等于二进制的 10 ，即十进制的 2</span></span><br></pre></td></tr></table></figure>

<p>同样，在移位过程中，原数值中也会出现空位。只不过这次的空位出现在原数值的左侧、符号位的右侧。而此时 ECMAScript 会用符号位的值来填充所有空位，以便得到一个完整的值。</p>
<p>⑦ 无符号右移</p>
<p>无符号右移操作符由 3 个大于号（<code>&gt;&gt;&gt;</code>）表示，这个操作符会将数值的所有 32 位都向右移动。对正数来说，无符号右移的结果与有符号右移相同。仍以前面有符号右移的代码为例，如果将 64 无符号右移 5 位，结果仍然还是 2：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oldValue = <span class="number">64</span>;                <span class="comment">// 等于二进制的 1000000 </span></span><br><span class="line"><span class="keyword">var</span> newValue = oldValue &gt;&gt;&gt; <span class="number">5</span>;    <span class="comment">// 等于二进制的 10 ，即十进制的 2</span></span><br></pre></td></tr></table></figure>

<p>但是对负数来说，情况就不一样了。首先，无符号右移是以 0 来填充空位，而不是像有符号右移那样以符号位的值来填充空位。所以，对正数的无符号右移与有符号右移结果相同，但对负数的结果就不一样了。其次，无符号右移操作符会把负数的二进制码当成正数的二进制码。而且，由于负数以其绝对值的二进制补码形式表示，因此就会导致无符号右移后的结果非常之大，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oldValue = -<span class="number">64</span>;               <span class="comment">// 等于二进制的等于二进制的 11111111111111111111111111000000 </span></span><br><span class="line"><span class="keyword">var</span> newValue = oldValue &gt;&gt;&gt; <span class="number">5</span>;    <span class="comment">// 等于十进制的 134217726</span></span><br></pre></td></tr></table></figure>

<p>这里，当对-64 执行无符号右移 5 位的操作后，得到的结果是 134217726。之所以结果如此之大，是因为 -64 的二进制码为 11111111111111111111111111000000，而且无符号右移操作会把这个二进制码当成正数的二进制码，换算成十进制就是 4294967232。如果把这个值右移 5 位，结果就变成了 00000111111111111111111111111110，即十进制的 134217726。</p>
<h4 id="布尔操作符"><a href="#布尔操作符" class="headerlink" title="布尔操作符"></a>布尔操作符</h4><p>在一门编程语言中，布尔操作符的重要性堪比相等操作符。如果没有测试两个值关系的能力，那么诸如 if…else 和循环之类的语句就不会有用武之地了。布尔操作符一共有 3 个：非（NOT）、与（AND）和或（OR）。</p>
<p>① 逻辑非</p>
<p>逻辑非操作符由一个叹号（<code>!</code>）表示，可以应用于 ECMAScript 中的任何值。无论这个值是什么数据类型，这个操作符都会返回一个布尔值。逻辑非操作符首先会将它的操作数转换为一个布尔值，然后再对其求反。也就是说，逻辑非操作符遵循下列规则：</p>
<ul>
<li>如果操作数是一个对象，返回 false；</li>
<li>如果操作数是一个空字符串，返回 true；</li>
<li>如果操作数是一个非空字符串，返回 false；</li>
<li>如果操作数是数值 0，返回 true；</li>
<li>如果操作数是任意非 0 数值（包括 Infinity），返回 false；</li>
<li>如果操作数是 null，返回 true；</li>
<li>如果操作数是 NaN，返回 true；</li>
<li>如果操作数是 undefined，返回 true。</li>
</ul>
<p>下面几个例子展示了应用上述规则的结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alert(!<span class="literal">false</span>);       <span class="comment">// true </span></span><br><span class="line">alert(!<span class="string">&quot;blue&quot;</span>);      <span class="comment">// false </span></span><br><span class="line">alert(!<span class="number">0</span>);           <span class="comment">// true </span></span><br><span class="line">alert(!<span class="literal">NaN</span>);         <span class="comment">// true </span></span><br><span class="line">alert(!<span class="string">&quot;&quot;</span>);          <span class="comment">// true </span></span><br><span class="line">alert(!<span class="number">12345</span>);       <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>逻辑非操作符也可以用于将一个值转换为与其对应的布尔值。而同时使用两个逻辑非操作符，实际上就会模拟 <code>Boolean()</code> 转型函数的行为。其中，第一个逻辑非操作会基于无论什么操作数返回一个布尔值，而第二个逻辑非操作则对该布尔值求反，于是就得到了这个值真正对应的布尔值。当然，最终结果与对这个值使用 <code>Boolean()</code> 函数相同，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alert(!!<span class="string">&quot;blue&quot;</span>);      <span class="comment">//true </span></span><br><span class="line">alert(!!<span class="number">0</span>);          <span class="comment">//false </span></span><br><span class="line">alert(!!<span class="literal">NaN</span>);        <span class="comment">//false </span></span><br><span class="line">alert(!!<span class="string">&quot;&quot;</span>);          <span class="comment">//false </span></span><br><span class="line">alert(!!<span class="number">12345</span>);      <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>② 逻辑与</p>
<p>逻辑与操作符由两个和号（<code>&amp;&amp;</code>）表示，有两个操作数，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="literal">true</span> &amp;&amp; <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>逻辑与的真值表如下：</p>
<table>
<thead>
<tr>
<th>第一个操作数</th>
<th>第二个操作数</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>true</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>true</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>false</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>false</td>
<td>false</td>
<td>false</td>
</tr>
</tbody></table>
<p>逻辑与操作可以应用于任何类型的操作数，而不仅仅是布尔值。在有一个操作数不是布尔值的情况下，逻辑与操作就不一定返回布尔值；此时，它遵循下列规则：</p>
<ul>
<li>如果第一个操作数是对象，则返回第二个操作数；</li>
<li>如果第二个操作数是对象，则只有在第一个操作数的求值结果为 true 的情况下才会返回该对象；</li>
<li>如果两个操作数都是对象，则返回第二个操作数；</li>
<li>如果有一个操作数是 null，则返回 null；</li>
<li>如果有一个操作数是 NaN，则返回 NaN；</li>
<li>如果有一个操作数是 undefined，则返回 undefined。</li>
</ul>
<p>逻辑与操作属于短路操作，即如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值。</p>
<p>对于逻辑与操作而言，如果第一个操作数是 false，则无论第二个操作数是什么值，结果都不再可能是 true 了。来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> found = <span class="literal">true</span>; </span><br><span class="line"><span class="keyword">var</span> result = (found &amp;&amp; someUndefinedVariable);    <span class="comment">// 这里会发生错误 </span></span><br><span class="line">alert(result);    <span class="comment">// 这一行不会执行</span></span><br></pre></td></tr></table></figure>

<p>在上面的代码中，当执行逻辑与操作时会发生错误，因为变量 <code>someUndefinedVariable</code> 没有声明。由于变量 <code>found</code> 的值是 <code>true</code>，所以逻辑与操作符会继续对变量 <code>someUndefinedVariable</code> 求值。但 <code>someUndefinedVariable</code> 尚未定义，因此就会导致错误。这说明不能在逻辑与操作中使用未定义的值。如果像下面这个例中一样，将 <code>found</code> 的值设置为 <code>false</code>，就不会发生错误了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> found = <span class="literal">false</span>; </span><br><span class="line"><span class="keyword">var</span> result = (found &amp;&amp; someUndefinedVariable);     <span class="comment">// 不会发生错误 </span></span><br><span class="line">alert(result);    <span class="comment">// 会执行（&quot;false&quot;）</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，警告框会显示出来。无论变量 <code>someUndefinedVariable</code> 有没有定义，也永远不会对它求值，因为第一个操作数的值是 false。而这也就意味着逻辑与操作的结果必定是 false，根本用不着再对<code>&amp;&amp;</code>右侧的操作数求值了。在使用逻辑与操作符时要始终铭记它是一个短路操作符。</p>
<p>③ 逻辑或</p>
<p>逻辑或操作符由两个竖线符号（<code>||</code>）表示，有两个操作数，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="literal">true</span> || <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>逻辑或的真值表如下：</p>
<table>
<thead>
<tr>
<th>第一个操作数</th>
<th>第二个操作数</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>true</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>true</td>
<td>false</td>
<td>true</td>
</tr>
<tr>
<td>false</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>false</td>
<td>false</td>
<td>false</td>
</tr>
</tbody></table>
<p>与逻辑与操作相似，如果有一个操作数不是布尔值，逻辑或也不一定返回布尔值；此时，它遵循下列规则：</p>
<ul>
<li>如果第一个操作数是对象，则返回第一个操作数；</li>
<li>如果第一个操作数的求值结果为 false，则返回第二个操作数；</li>
<li>如果两个操作数都是对象，则返回第一个操作数；</li>
<li>如果两个操作数都是 null，则返回 null；</li>
<li>如果两个操作数都是 NaN，则返回 NaN；</li>
<li>如果两个操作数都是 undefined，则返回 undefined。</li>
</ul>
<p>与逻辑与操作符相似，逻辑或操作符也是短路操作符。也就是说，如果第一个操作数的求值结果为 true，就不会对第二个操作数求值了。下面看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> found = <span class="literal">true</span>; </span><br><span class="line"><span class="keyword">var</span> result = (found || someUndefinedVariable);     <span class="comment">// 不会发生错误 </span></span><br><span class="line">alert(result);    <span class="comment">// 会执行（&quot;true&quot;）</span></span><br></pre></td></tr></table></figure>

<p>这个例子跟前面的例子一样，变量 <code>someUndefinedVariable</code> 也没有定义。但是，由于变量 <code>found</code>的值是 true，而变量 <code>someUndefinedVariable</code> 永远不会被求值，因此结果就会输出“true”。如果像下面这个例子一样，把 found 的值改为 false，就会导致错误：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> found = <span class="literal">false</span>; </span><br><span class="line"><span class="keyword">var</span> result = (found || someUndefinedVariable);     <span class="comment">// 这里会发生错误 </span></span><br><span class="line">alert(result);    <span class="comment">// 这一行不会执行</span></span><br></pre></td></tr></table></figure>

<p>我们可以利用逻辑或的这一行为来避免为变量赋 null 或 undefined 值。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = preferredObject || backupObject;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，变量 <code>myObject</code> 将被赋予等号后面两个值中的一个。变量 <code>preferredObject</code> 中包含优先赋给变量 <code>myObject</code> 的值，变量 <code>backupObject</code> 负责在 <code>preferredObject</code> 中不包含有效值的情况下提供后备值。如果<code>preferredObject</code> 的值不是 null，那么它的值将被赋给 <code>myObject</code>；如果是 null，则将 <code>backupObject</code> 的值赋给 <code>myObject</code>。ECMAScript 程序的赋值语句经常会使用这种模式。</p>
<h4 id="乘性操作符"><a href="#乘性操作符" class="headerlink" title="乘性操作符"></a>乘性操作符</h4><p>ECMAScript 定义了 3 个乘性操作符：乘法、除法和求模。这些操作符与 Java、C 或者 Perl 中的相应操作符用途类似，只不过在操作数为非数值的情况下会执行自动的类型转换。如果参与乘性计算的某个操作数不是数值，后台会先使用 <code>Number()</code>转型函数将其转换为数值。也就是说，空字符串将被当作0，布尔值 true 将被当作 1。</p>
<p>① 乘法</p>
<p>乘法操作符由一个星号（<code>*</code>）表示，用于计算两个数值的乘积。其语法类似于 C，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="number">34</span> * <span class="number">56</span>;</span><br></pre></td></tr></table></figure>

<p>在处理特殊值的情况下，乘法操作符遵循下列特殊的规则：</p>
<ul>
<li>如果操作数都是数值，执行常规的乘法计算，即两个正数或两个负数相乘的结果还是正数，而如果只有一个操作数有符号，那么结果就是负数。如果乘积超过了 ECMAScript 数值的表示范围，则返回 Infinity 或-Infinity；</li>
<li>如果有一个操作数是 NaN，则结果是 NaN；</li>
<li>如果是 Infinity 与 0 相乘，则结果是 NaN；</li>
<li>如果是 Infinity 与非 0 数值相乘，则结果是 Infinity 或-Infinity，取决于有符号操作数的符号；</li>
<li>如果是 Infinity 与 Infinity 相乘，则结果是 Infinity；</li>
<li>如果有一个操作数不是数值，则在后台调用 <code>Number()</code>将其转换为数值，然后再应用上面的规则。</li>
</ul>
<p>② 除法</p>
<p>除法操作符由一个斜线符号（<code>/</code>）表示，执行第二个操作数除第一个操作数的计算，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="number">66</span> / <span class="number">11</span>;</span><br></pre></td></tr></table></figure>

<p>与乘法操作符类似，除法操作符对特殊的值也有特殊的处理规则。这些规则如下：</p>
<ul>
<li>如果操作数都是数值，执行常规的除法计算，即两个正数或两个负数相除的结果还是正数，而如果只有一个操作数有符号，那么结果就是负数。如果商超过了 ECMAScript 数值的表示范围，则返回 Infinity 或 -Infinity；</li>
<li>如果有一个操作数是 NaN，则结果是 NaN；</li>
<li>如果是 Infinity 被 Infinity 除，则结果是 NaN；</li>
<li>如果是零被零除，则结果是 NaN；</li>
<li>如果是非零的有限数被零除，则结果是 Infinity 或-Infinity，取决于有符号操作数的符号；</li>
<li>如果是 Infinity 被任何非零数值除，则结果是 Infinity 或-Infinity，取决于有符号操作数的符号；</li>
<li>如果有一个操作数不是数值，则在后台调用 Number()将其转换为数值，然后再应用上面的规则。</li>
</ul>
<p>③ 求模</p>
<p>求模（余数）操作符由一个百分号（%）表示，用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="number">26</span> % <span class="number">5</span>;     <span class="comment">// 等于等于 1</span></span><br></pre></td></tr></table></figure>

<p>与另外两个乘性操作符类似，求模操作符会遵循下列特殊规则来处理特殊的值：</p>
<ul>
<li>如果操作数都是数值，执行常规的除法计算，返回除得的余数；</li>
<li>如果被除数是无穷大值而除数是有限大的数值，则结果是 NaN；</li>
<li>如果被除数是有限大的数值而除数是零，则结果是 NaN；</li>
<li>如果是 Infinity 被 Infinity 除，则结果是 NaN；</li>
<li>如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数；</li>
<li>如果被除数是零，则结果是零；</li>
<li>如果有一个操作数不是数值，则在后台调用 Number()将其转换为数值，然后再应用上面的规则。</li>
</ul>
<h4 id="加性操作符"><a href="#加性操作符" class="headerlink" title="加性操作符"></a>加性操作符</h4><p>加法和减法这两个加性操作符应该说是编程语言中最简单的算术操作符了。但是在 ECMAScript 中，这两个操作符却都有一系列的特殊行为。与乘性操作符类似，加性操作符也会在后台转换不同的数据类型。然而，对于加性操作符而言，相应的转换规则还稍微有点复杂。</p>
<p>① 加法</p>
<p>加法操作符（<code>+</code>）的用法如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="number">1</span> + <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>如果两个操作符都是数值，执行常规的加法计算，然后根据下列规则返回结果：</p>
<ul>
<li>如果有一个操作数是 NaN，则结果是 NaN；</li>
<li>如果是 Infinity 加 Infinity，则结果是 Infinity；</li>
<li>如果是-Infinity 加-Infinity，则结果是-Infinity；</li>
<li>如果是 Infinity 加-Infinity，则结果是 NaN；</li>
<li>如果是+0 加+0，则结果是+0；</li>
<li>如果是-0 加-0，则结果是-0；</li>
<li>如果是+0 加0，则结果是+0。</li>
</ul>
<p>不过，如果有一个操作数是字符串，那么就要应用如下规则：</p>
<ul>
<li>如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来；</li>
<li>如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来。</li>
<li>如果有一个操作数是对象、数值或布尔值，则调用它们的 <code>toString()</code>方法取得相应的字符串值，然后再应用前面关于字符串的规则。对于 <code>undefined</code> 和 <code>null</code>，则分别调用 <code>String()</code>函数并取得字符串“undefined”和“null”。</li>
</ul>
<p>下面来举几个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result1 = <span class="number">5</span> + <span class="number">5</span>;      <span class="comment">// 两个数值相加 </span></span><br><span class="line">alert(result1);          <span class="comment">// 10</span></span><br><span class="line"><span class="keyword">var</span> result2 = <span class="number">5</span> + <span class="string">&quot;5&quot;</span>;     <span class="comment">// 一个数值和一个字符串相加 </span></span><br><span class="line">alert(result2);          <span class="comment">// &quot;55&quot;</span></span><br></pre></td></tr></table></figure>

<p>以上代码演示了加法操作符在两种模式下的差别。第一行代码演示了正常的情况，即 5+5 等于 10（数值）。但是，如果将一个操作数改为字符串“5”，结果就变成了“55”（字符串值），因为第一个操作<br>数也被转换成了“5”。</p>
<p>忽视加法操作中的数据类型是 ECMAScript 编程中最常见的一个错误。再来看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="number">5</span>; </span><br><span class="line"><span class="keyword">var</span> num2 = <span class="number">10</span>; </span><br><span class="line"><span class="keyword">var</span> message = <span class="string">&quot;The sum of 5 and 10 is &quot;</span> + num1 + num2; </span><br><span class="line">alert(message);    <span class="comment">// &quot;The sum of 5 and 10 is 510&quot;</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，变量 <code>message</code> 的值是执行两个加法操作之后的结果。有人可能以为最后得到的字符串是“The sum of 5 and 10 is 15”，但实际的结果却是“The sum of 5 and 10 is 510”。之所以会这样，是因为每个加法操作是独立执行的。第一个加法操作将一个字符串和一个数值 5 拼接了起来，结果是一个字符串。而第二个加法操作又用这个字符串去加另一个数值 10 ，当然也会得到一个字符串。如果想先对数值执行算术计算，然后再将结果与字符串拼接起来，应该像下面这样使用圆括号：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="number">5</span>; </span><br><span class="line"><span class="keyword">var</span> num2 = <span class="number">10</span>; </span><br><span class="line"><span class="keyword">var</span> message = <span class="string">&quot;The sum of 5 and 10 is &quot;</span> + (num1 + num2); </span><br><span class="line">alert(message);    <span class="comment">//&quot;The sum of 5 and 10 is 15&quot;</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，一对圆括号把两个数值变量括在了一起，这样就会告诉解析器先计算其结果，然后再将结果与字符串拼接起来。因此，就得到了结果“The sum of 5 and 10 is 15”。</p>
<p>② 减法</p>
<p>减法操作符（<code>-</code>）是另一个极为常用的操作符，其用法如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="number">2</span> - <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>与加法操作符类似，ECMAScript 中的减法操作符在处理各种数据类型转换时，同样需要遵循一些特殊规则，如下所示：</p>
<ul>
<li>如果两个操作符都是数值，则执行常规的算术减法操作并返回结果；</li>
<li>如果有一个操作数是 NaN，则结果是 NaN；</li>
<li>如果是 Infinity 减 Infinity，则结果是 NaN；</li>
<li>如果是-Infinity 减-Infinity，则结果是 NaN；</li>
<li>如果是 Infinity 减-Infinity，则结果是 Infinity；</li>
<li>如果是-Infinity 减 Infinity，则结果是-Infinity；</li>
<li>如果是+0 减+0，则结果是+0；</li>
<li>如果是+0 减-0，则结果是-0；</li>
<li>如果是-0 减-0，则结果是+0；</li>
<li>如果有一个操作数是字符串、布尔值、null 或 undefined，则先在后台调用 <code>Number()</code>函数将其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是 NaN，则减法的结果就是 NaN；</li>
<li>如果有一个操作数是对象，则调用对象的 <code>valueOf()</code>方法以取得表示该对象的数值。如果得到的值是 NaN，则减法的结果就是 NaN。如果对象没有 <code>valueOf()</code>方法，则调用其 <code>toString()</code> 方法并将得到的字符串转换为数值。</li>
</ul>
<p>下面几个例子展示了上面的规则：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result1 = <span class="number">5</span> - <span class="literal">true</span>;    <span class="comment">// 4，因为 true 被转换成了 1 </span></span><br><span class="line"><span class="keyword">var</span> result2 = <span class="literal">NaN</span> - <span class="number">1</span>;    <span class="comment">// NaN </span></span><br><span class="line"><span class="keyword">var</span> result3 = <span class="number">5</span> - <span class="number">3</span>;      <span class="comment">// 2 </span></span><br><span class="line"><span class="keyword">var</span> result4 = <span class="number">5</span> - <span class="string">&quot;&quot;</span>;     <span class="comment">// 5，因为&quot;&quot; 被转换成了 0 </span></span><br><span class="line"><span class="keyword">var</span> result5 = <span class="number">5</span> - <span class="string">&quot;2&quot;</span>;    <span class="comment">// 3，因为&quot;2&quot;被转换成了 2 </span></span><br><span class="line"><span class="keyword">var</span> result6 = <span class="number">5</span> - <span class="literal">null</span>;   <span class="comment">// 5，因为 null 被转换成了 0</span></span><br></pre></td></tr></table></figure>

<h4 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h4><p>小于（<code>&lt;</code>）、大于（<code>&gt;</code>）、小于等于（<code>&lt;=</code>）和大于等于（<code>&gt;=</code>）这几个关系操作符用于对两个值进行比较，比较的规则与我们在数学课上所学的一样。这几个操作符都返回一个布尔值，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result1 = <span class="number">5</span> &gt; <span class="number">3</span>;   <span class="comment">//true </span></span><br><span class="line"><span class="keyword">var</span> result2 = <span class="number">5</span> &lt; <span class="number">3</span>;   <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>与 ECMAScript 中的其他操作符一样，当关系操作符的操作数使用了非数值时，也要进行数据转换或完成某些奇怪的操作。以下就是相应的规则：</p>
<ul>
<li>如果两个操作数都是数值，则执行数值比较。</li>
<li>如果两个操作数都是字符串，则比较两个字符串对应的字符编码值。</li>
<li>如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较。</li>
<li>如果一个操作数是对象，则调用这个对象的 <code>valueOf()</code>方法，用得到的结果按照前面的规则执行比较。如果对象没有 <code>valueOf()</code>方法，则调用 <code>toString()</code>方法，并用得到的结果根据前面的规则执行比较。</li>
<li>如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较。</li>
</ul>
<p>在使用关系操作符比较两个字符串时，会执行一种奇怪的操作。很多人都会认为，在比较字符串值时，小于的意思是“在字母表中的位置靠前”，而大于则意味着“在字母表中的位置靠后”，但实际上完全不是那么回事。在比较字符串时，实际比较的是两个字符串中对应位置的每个字符的字符编码值。经过这么一番比较之后，再返回一个布尔值。由于大写字母的字符编码全部小于小写字母的字符编码，因此我们就会看到如下所示的奇怪现象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="string">&quot;Brick&quot;</span> &lt; <span class="string">&quot;alphabet&quot;</span>;    <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，字符串“Brick”被认为小于字符串“alphabet”。原因是字母 B 的字符编码为 66，而字母 a 的字符编码是 97。如果要真正按字母表顺序比较字符串，就必须把两个操作数转换为相同的大小写形式（全部大写或全部小写），然后再执行比较，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="string">&quot;Brick&quot;</span>.toLowerCase() &lt; <span class="string">&quot;alphabet&quot;</span>.toLowerCase(); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>通过将两个操作数都转换为小写形式，就可以得出“alphabet”按字母表顺序排在“Brick”之前的正确判断了。</p>
<p>另一种奇怪的现象发生在比较两个数字字符串的情况下，比如下面这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="string">&quot;23&quot;</span> &lt; <span class="string">&quot;3&quot;</span>;    <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>确实，当比较字符串“23”是否小于“3”时，结果居然是 true。这是因为两个操作数都是字符串，而字符串比较的是字符编码（“2”的字符编码是 50，而“3”的字符编码是 51）。不过，如果像下面例子中一样，将一个操作数改为数值，比较的结果就正常了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="string">&quot;23&quot;</span> &lt; <span class="number">3</span>;    <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>此时，字符串“23”会被转换成数值 23，然后再与 3 进行比较，因此就会得到合理的结果。在比较数值和字符串时，字符串都会被转换成数值，然后再以数值方式与另一个数值比较。当然，这个规则对前面的例子是适用的。可是，如果那个字符串不能被转换成一个合理的数值呢？比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="string">&quot;a&quot;</span> &lt; <span class="number">3</span>;    <span class="comment">// false，因为&quot;a&quot;被转换成了 NaN</span></span><br></pre></td></tr></table></figure>

<p>由于字母“a”不能转换成合理的数值，因此就被转换成了 NaN。根据规则，任何操作数与 NaN 进行<br>关系比较，结果都是 false。于是，就出现了下面这个有意思的现象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result1 = <span class="literal">NaN</span> &lt; <span class="number">3</span>;    <span class="comment">//false </span></span><br><span class="line"><span class="keyword">var</span> result2 = <span class="literal">NaN</span> &gt;= <span class="number">3</span>;   <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>按照常理，如果一个值不小于另一个值，则一定是大于或等于那个值。然而，在与 NaN 进行比较时，这两个比较操作的结果都返回了 false。</p>
<h4 id="相等操作符"><a href="#相等操作符" class="headerlink" title="相等操作符"></a>相等操作符</h4><p>确定两个变量是否相等是编程中的一个非常重要的操作。在比较字符串、数值和布尔值的相等性时，问题还比较简单。但在涉及到对象的比较时，问题就变得复杂了。最早的 ECMAScript 中的相等和不等操作符会在执行比较之前，先将对象转换成相似的类型。后来，有人提出了这种转换到底是否合理的质疑。最后，ECMAScript 的解决方案就是提供两组操作符：<strong>相等和不相等</strong>——先转换再比较，<strong>全等和不全等</strong>——仅比较而不转换。</p>
<p>① 相等和不相等</p>
<p>ECMAScript 中的相等操作符由两个等于号（<code>==</code>）表示，如果两个操作数相等，则返回 true。而不相等操作符由叹号后跟等于号（<code>!=</code>）表示，如果两个操作数不相等，则返回 true。这两个操作符都会先转换操作数（通常称为强制转型），然后再比较它们的相等性。</p>
<p>在转换不同的数据类型时，相等和不相等操作符遵循下列基本规则：</p>
<ul>
<li>如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false 转换为 0，而 true 转换为 1；</li>
<li>如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值；</li>
<li>如果一个操作数是对象，另一个操作数不是，则调用对象的 <code>valueOf()</code>方法，用得到的基本类型值按照前面的规则进行比较；</li>
</ul>
<p>这两个操作符在进行比较时则要遵循下列规则：</p>
<ul>
<li>null 和 undefined 是相等的。</li>
<li>要比较相等性之前，不能将 null 和 undefined 转换成其他任何值。</li>
<li>如果有一个操作数是 NaN，则相等操作符返回 false，而不相等操作符返回 true。重要提示：即使两个操作数都是 NaN，相等操作符也返回 false；因为按照规则，NaN 不等于 NaN。</li>
<li>如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true；否则，返回 false。</li>
</ul>
<p>下表列出了一些特殊情况及比较结果：</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>值</th>
<th>表达式</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td><code>null == undefined</code></td>
<td>true</td>
<td><code>true == 1</code></td>
<td>true</td>
</tr>
<tr>
<td><code>&quot;NaN&quot; == NaN</code></td>
<td>false</td>
<td><code>true == 2</code></td>
<td>false</td>
</tr>
<tr>
<td><code>5 == NaN</code></td>
<td>false</td>
<td><code>undefined == 0</code></td>
<td>false</td>
</tr>
<tr>
<td><code>NaN == NaN</code></td>
<td>false</td>
<td><code>null == 0</code></td>
<td>false</td>
</tr>
<tr>
<td><code>NaN != NaN</code></td>
<td>true</td>
<td><code>&quot;5&quot;==5</code></td>
<td>true</td>
</tr>
<tr>
<td><code>false == 0</code></td>
<td>true</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>② 全等和不全等</p>
<p>除了在比较之前不转换操作数之外，全等和不全等操作符与相等和不相等操作符没有什么区别。全等操作符由 3 个等于号（<code>===</code>）表示，它只在两个操作数未经转换就相等的情况下返回 true，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result1 = (<span class="string">&quot;55&quot;</span> == <span class="number">55</span>);    <span class="comment">//true，因为转换后相等 </span></span><br><span class="line"><span class="keyword">var</span> result2 = (<span class="string">&quot;55&quot;</span> === <span class="number">55</span>);  <span class="comment">//false，因为不同的数据类型不相等</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，第一个比较使用的是相等操作符比较字符串“55”和数值 55，结果返回了 true。如前所述，这是因为字符串“55”先被转换成了数值 55，然后再与另一个数值 55 进行比较。第二个比较使用了全等操作符以不转换数值的方式比较同样的字符串和值。在不转换的情况下，字符串当然不等于数值，因此结果就是 false。</p>
<p>不全等操作符由一个叹号后跟两个等于号（<code>!==</code>）表示，它在两个操作数未经转换就不相等的情况下返回 true。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result1 = (<span class="string">&quot;55&quot;</span> != <span class="number">55</span>);     <span class="comment">//false，因为转换后相等 </span></span><br><span class="line"><span class="keyword">var</span> result2 = (<span class="string">&quot;55&quot;</span> !== <span class="number">55</span>);    <span class="comment">//true，因为不同的数据类型不相等</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，第一个比较使用了不相等操作符，而该操作符会将字符串“55”转换成 55，结果就与第二个操作数（也是 55）相等了。而由于这两个操作数被认为相等，因此就返回了 false。第二个比较使用了不全等操作符。假如我们这样想：字符串 55 与数值 55 不相同吗？，那么答案一定是：是的（true）。</p>
<p>记住：null == undefined 会返回 true，因为它们是类似的值；但 <code>null === undefined</code> 会返回 false，因为它们是不同类型的值。</p>
<blockquote>
<p>由于相等和不相等操作符存在类型转换问题，而为了保持代码中数据类型的完整性，推荐使用全等和不全等操作符。</p>
</blockquote>
<p>另一个例外是<code>NaN</code>这个特殊的Number与<strong>所有其他值都不相等，包括它自己</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><strong>唯一</strong>能判断<code>NaN</code>的方法是通过<code>isNaN()</code>函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>最后要注意浮点数的相等比较：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> / <span class="number">3</span> === (<span class="number">1</span> - <span class="number">2</span> / <span class="number">3</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>这不是JavaScript的设计缺陷。浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.abs(<span class="number">1</span> / <span class="number">3</span> - (<span class="number">1</span> - <span class="number">2</span> / <span class="number">3</span>)) &lt; <span class="number">0.0000001</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h4><p>条件操作符应该算是 ECMAScript 中最灵活的一种操作符了，而且它遵循与 Java 中的条件操作符相同的语法形式，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable = boolean_expression ? true_value : false_value;</span><br></pre></td></tr></table></figure>

<p>本质上，这行代码的含义就是基于对 <code>boolean_expression</code> 求值的结果，决定给变量 <code>variable</code>赋什么值。如果求值结果为 true，则给变量 <code>variable</code> 赋 <code>true_value</code> 值；如果求值结果为 false，则给变量 <code>variable</code> 赋 <code>false_value</code> 值。再看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> max = (num1 &gt; num2) ? num1 : num2;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>max</code> 中将会保存一个最大的值。这个表达式的意思是：如果 <code>num1</code> 大于 <code>num2</code>（关系表达式返回 true），则将 <code>num1</code> 的值赋给 <code>max</code>；如果 <code>num1</code> 小于或等于 <code>num2</code>（关系表达式返回 false），<br>则将 <code>num2</code> 的值赋给 max。</p>
<h4 id="赋值操作符"><a href="#赋值操作符" class="headerlink" title="赋值操作符"></a>赋值操作符</h4><p>简单的赋值操作符由等于号（<code>=</code>）表示，其作用就是把右侧的值赋给左侧的变量，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>如果在等于号（<code>=</code>）前面再添加乘性操作符、加性操作符或位操作符，就可以完成复合赋值操作。这种复合赋值操作相当于是对下面常规表达式的简写形式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>; </span><br><span class="line">num += <span class="number">10</span>; <span class="comment">// 等价于 num = num + 10;</span></span><br></pre></td></tr></table></figure>

<p>每个主要算术操作符（以及个别的其他操作符）都有对应的复合赋值操作符。这些操作符如下所示：</p>
<ul>
<li>乘赋值（<code>*=</code>）；</li>
<li>除赋值（<code>/=</code>）；</li>
<li>模赋值（<code>%=</code>）；</li>
<li>加赋值（<code>+=</code>）；</li>
<li>减赋值（<code>-=</code>）；</li>
<li>左移赋值（<code>&lt;&lt;=</code>）；</li>
<li>有符号右移赋值（<code>&gt;&gt;=</code>）；</li>
<li>无符号右移赋值（<code>&gt;&gt;&gt;=</code>）。</li>
</ul>
<p>设计这些操作符的主要目的就是简化赋值操作。使用它们不会带来任何性能的提升。</p>
<h4 id="逗号操作符"><a href="#逗号操作符" class="headerlink" title="逗号操作符"></a>逗号操作符</h4><p>使用逗号操作符可以在一条语句中执行多个操作，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1=<span class="number">1</span>, num2=<span class="number">2</span>, num3=<span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>逗号操作符多用于声明多个变量；但除此之外，逗号操作符还可以用于赋值。在用于赋值时，逗号操作符总会返回表达式中的最后一项，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = (<span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">0</span>); <span class="comment">// num 的值为 0</span></span><br></pre></td></tr></table></figure>

<p>由于 0 是表达式中的最后一项，因此 <code>num</code> 的值就是 0。虽然逗号的这种使用方式并不常见，但这个例子可以帮我们理解逗号的这种行为。</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组是一组按顺序排列的集合，集合的每个值称为元素。JavaScript的数组可以包括任意数据类型。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3.14</span>, <span class="string">&#x27;Hello&#x27;</span>, <span class="literal">null</span>, <span class="literal">true</span>];</span><br></pre></td></tr></table></figure>

<p>上述数组包含6个元素。数组用<code>[]</code>表示，元素之间用<code>,</code>分隔。</p>
<p>另一种创建数组的方法是通过<code>Array()</code>函数实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 创建了数组[1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>然而，出于代码的可读性考虑，强烈建议直接使用<code>[]</code>。</p>
<p>数组的元素可以通过索引来访问。请注意，索引的起始值为<code>0</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3.14</span>, <span class="string">&#x27;Hello&#x27;</span>, <span class="literal">null</span>, <span class="literal">true</span>];</span><br><span class="line">arr[<span class="number">0</span>]; <span class="comment">// 返回索引为0的元素，即1</span></span><br><span class="line">arr[<span class="number">5</span>]; <span class="comment">// 返回索引为5的元素，即true</span></span><br><span class="line">arr[<span class="number">6</span>]; <span class="comment">// 索引超出了范围，返回undefined</span></span><br></pre></td></tr></table></figure>

<p>要取得<code>Array</code>的长度，直接访问<code>length</code>属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3.14</span>, <span class="string">&#x27;Hello&#x27;</span>, <span class="literal">null</span>, <span class="literal">true</span>];</span><br><span class="line">arr.length; <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p><strong>请注意</strong>，直接给<code>Array</code>的<code>length</code>赋一个新的值会导致<code>Array</code>大小的变化：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.length; <span class="comment">// 3</span></span><br><span class="line">arr.length = <span class="number">6</span>;</span><br><span class="line">arr; <span class="comment">// arr变为[1, 2, 3, undefined, undefined, undefined]</span></span><br><span class="line">arr.length = <span class="number">2</span>;</span><br><span class="line">arr; <span class="comment">// arr变为[1, 2]</span></span><br></pre></td></tr></table></figure>

<p><code>Array</code>可以通过索引把对应的元素修改为新的值，因此，对<code>Array</code>的索引进行赋值会直接修改这个<code>Array</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>];</span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">99</span>;</span><br><span class="line">arr; <span class="comment">// arr现在变为[&#x27;A&#x27;, 99, &#x27;C&#x27;]</span></span><br></pre></td></tr></table></figure>

<p><strong>请注意</strong>，如果通过索引赋值时，索引超过了范围，同样会引起<code>Array</code>大小的变化：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr[<span class="number">5</span>] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">arr; <span class="comment">// arr变为[1, 2, 3, undefined, undefined, &#x27;x&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>大多数其他编程语言不允许直接改变数组的大小，越界访问索引会报错。然而，JavaScript的<code>Array</code>却不会有任何错误。在编写代码时，不建议直接修改<code>Array</code>的大小，访问索引时要确保索引不会越界。</p>
<h4 id="indexOf-1"><a href="#indexOf-1" class="headerlink" title="indexOf"></a>indexOf</h4><p>与String类似，<code>Array</code>也可以通过<code>indexOf()</code>来搜索一个指定的元素的位置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="string">&#x27;30&#x27;</span>, <span class="string">&#x27;xyz&#x27;</span>];</span><br><span class="line">arr.indexOf(<span class="number">10</span>); <span class="comment">// 元素10的索引为0</span></span><br><span class="line">arr.indexOf(<span class="number">20</span>); <span class="comment">// 元素20的索引为1</span></span><br><span class="line">arr.indexOf(<span class="number">30</span>); <span class="comment">// 元素30没有找到，返回-1</span></span><br><span class="line">arr.indexOf(<span class="string">&#x27;30&#x27;</span>); <span class="comment">// 元素&#x27;30&#x27;的索引为2</span></span><br></pre></td></tr></table></figure>

<p>注意了，数字<code>30</code>和字符串<code>&#39;30&#39;</code>是不同的元素。</p>
<h4 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h4><p><code>slice()</code>就是对应String的<code>substring()</code>版本，它截取<code>Array</code>的部分元素，然后返回一个新的<code>Array</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>];</span><br><span class="line">arr.slice(<span class="number">0</span>, <span class="number">3</span>); <span class="comment">// 从索引0开始，到索引3结束，但不包括索引3: [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span></span><br><span class="line">arr.slice(<span class="number">3</span>); <span class="comment">// 从索引3开始到结束: [&#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>注意到<code>slice()</code>的起止参数包括开始索引，不包括结束索引。</p>
<p>如果不给<code>slice()</code>传递任何参数，它就会从头到尾截取所有元素。利用这一点，我们可以很容易地复制一个<code>Array</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> aCopy = arr.slice();</span><br><span class="line">aCopy; <span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;]</span></span><br><span class="line">aCopy === arr; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h4 id="push和pop"><a href="#push和pop" class="headerlink" title="push和pop"></a>push和pop</h4><p><code>push()</code>向<code>Array</code>的末尾添加若干元素，<code>pop()</code>则把<code>Array</code>的最后一个元素删除掉：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">arr.push(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>); <span class="comment">// 返回Array新的长度: 4</span></span><br><span class="line">arr; <span class="comment">// [1, 2, &#x27;A&#x27;, &#x27;B&#x27;]</span></span><br><span class="line">arr.pop(); <span class="comment">// pop()返回&#x27;B&#x27;</span></span><br><span class="line">arr; <span class="comment">// [1, 2, &#x27;A&#x27;]</span></span><br><span class="line">arr.pop(); arr.pop(); arr.pop(); <span class="comment">// 连续pop 3次</span></span><br><span class="line">arr; <span class="comment">// []</span></span><br><span class="line">arr.pop(); <span class="comment">// 空数组继续pop不会报错，而是返回undefined</span></span><br><span class="line">arr; <span class="comment">// []</span></span><br></pre></td></tr></table></figure>

<h4 id="unshift和shift"><a href="#unshift和shift" class="headerlink" title="unshift和shift"></a>unshift和shift</h4><p>如果要往<code>Array</code>的头部添加若干元素，使用<code>unshift()</code>方法，<code>shift()</code>方法则把<code>Array</code>的第一个元素删掉：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">arr.unshift(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>); <span class="comment">// 返回Array新的长度: 4</span></span><br><span class="line">arr; <span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;, 1, 2]</span></span><br><span class="line">arr.shift(); <span class="comment">// &#x27;A&#x27;</span></span><br><span class="line">arr; <span class="comment">// [&#x27;B&#x27;, 1, 2]</span></span><br><span class="line">arr.shift(); arr.shift(); arr.shift(); <span class="comment">// 连续shift 3次</span></span><br><span class="line">arr; <span class="comment">// []</span></span><br><span class="line">arr.shift(); <span class="comment">// 空数组继续shift不会报错，而是返回undefined</span></span><br><span class="line">arr; <span class="comment">// []</span></span><br></pre></td></tr></table></figure>

<h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><p><code>sort()</code>可以对当前<code>Array</code>进行排序，它会直接修改当前<code>Array</code>的元素位置，直接调用时，按照默认顺序排序：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;A&#x27;</span>];</span><br><span class="line">arr.sort();</span><br><span class="line">arr; <span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>能否按照我们自己指定的顺序排序呢？完全可以，我们将在后面的函数中讲到。</p>
<h4 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h4><p><code>reverse()</code>把整个<code>Array</code>的元素给掉个个，也就是反转：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>];</span><br><span class="line">arr.reverse(); </span><br><span class="line">arr; <span class="comment">// [&#x27;three&#x27;, &#x27;two&#x27;, &#x27;one&#x27;]</span></span><br></pre></td></tr></table></figure>

<h4 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h4><p><code>splice()</code>方法是修改<code>Array</code>的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;Microsoft&#x27;</span>, <span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;Yahoo&#x27;</span>, <span class="string">&#x27;AOL&#x27;</span>, <span class="string">&#x27;Excite&#x27;</span>, <span class="string">&#x27;Oracle&#x27;</span>];</span><br><span class="line"><span class="comment">// 从索引2开始删除3个元素,然后再添加两个元素:</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Facebook&#x27;</span>); <span class="comment">// 返回删除的元素 [&#x27;Yahoo&#x27;, &#x27;AOL&#x27;, &#x27;Excite&#x27;]</span></span><br><span class="line">arr; <span class="comment">// [&#x27;Microsoft&#x27;, &#x27;Apple&#x27;, &#x27;Google&#x27;, &#x27;Facebook&#x27;, &#x27;Oracle&#x27;]</span></span><br><span class="line"><span class="comment">// 只删除,不添加:</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// [&#x27;Google&#x27;, &#x27;Facebook&#x27;]</span></span><br><span class="line">arr; <span class="comment">// [&#x27;Microsoft&#x27;, &#x27;Apple&#x27;, &#x27;Oracle&#x27;]</span></span><br><span class="line"><span class="comment">// 只添加,不删除:</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">0</span>, <span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Facebook&#x27;</span>); <span class="comment">// 返回[],因为没有删除任何元素</span></span><br><span class="line">arr; <span class="comment">// [&#x27;Microsoft&#x27;, &#x27;Apple&#x27;, &#x27;Google&#x27;, &#x27;Facebook&#x27;, &#x27;Oracle&#x27;]</span></span><br></pre></td></tr></table></figure>

<h4 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h4><p><code>concat()</code>方法把当前的<code>Array</code>和另一个<code>Array</code>连接起来，并返回一个新的<code>Array</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> added = arr.concat([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">added; <span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, 1, 2, 3]</span></span><br><span class="line">arr; <span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span></span><br></pre></td></tr></table></figure>

<p><strong>请注意</strong>，<code>concat()</code>方法并没有修改当前<code>Array</code>，而是返回了一个新的<code>Array</code>。</p>
<p>实际上，<code>concat()</code>方法可以接收任意个元素和<code>Array</code>，并且自动把<code>Array</code>拆开，然后全部添加到新的<code>Array</code>里：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>];</span><br><span class="line">arr.concat(<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]); <span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, 1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><p><code>join()</code>方法是一个非常实用的方法，它把当前<code>Array</code>的每个元素都用指定的字符串连接起来，然后返回连接后的字符串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.join(<span class="string">&#x27;-&#x27;</span>); <span class="comment">// &#x27;A-B-C-1-2-3&#x27;</span></span><br></pre></td></tr></table></figure>

<p>如果<code>Array</code>的元素不是字符串，将自动转换为字符串后再连接。</p>
<h4 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h4><p>如果数组的某个元素又是一个<code>Array</code>，则可以形成多维数组，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">400</span>, <span class="number">500</span>, <span class="number">600</span>], <span class="string">&#x27;-&#x27;</span>];</span><br></pre></td></tr></table></figure>

<h3 id="对象-1"><a href="#对象-1" class="headerlink" title="对象"></a>对象</h3><p>JavaScript的对象是一组由键-值组成的无序集合，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    tags: [<span class="string">&#x27;js&#x27;</span>, <span class="string">&#x27;web&#x27;</span>, <span class="string">&#x27;mobile&#x27;</span>],</span><br><span class="line">    city: <span class="string">&#x27;Beijing&#x27;</span>,</span><br><span class="line">    hasCar: <span class="literal">true</span>,</span><br><span class="line">    zipcode: <span class="literal">null</span> <span class="comment">// 每个属性用逗号隔开,最后一个不需要加逗号</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>JavaScript对象的键都是字符串类型，值可以是任意数据类型。上述<code>person</code>对象一共定义了6个键值对，其中每个键又称为对象的属性，例如，<code>person</code>的<code>name</code>属性为<code>&#39;Bob&#39;</code>，<code>zipcode</code>属性为<code>null</code>。</p>
<p>要获取一个对象的属性，我们用<code>对象变量.属性名</code>的方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">person.name; <span class="comment">// &#x27;Bob&#x27;</span></span><br><span class="line">person.zipcode; <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<p>JavaScript用一个<code>&#123;...&#125;</code>表示一个对象，键值对以<code>xxx: xxx</code>形式申明，用<code>,</code>隔开。注意，最后一个键值对不需要在末尾加<code>,</code>，如果加了，有的浏览器（如低版本的IE）将报错。</p>
<p>访问属性是通过<code>.</code>操作符完成的，但这要求属性名必须是一个有效的变量名。如果属性名包含特殊字符，就必须用<code>&#39;&#39;</code>括起来：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaohong = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小红&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;middle-school&#x27;</span>: <span class="string">&#x27;No.1 Middle School&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>xiaohong</code>的属性名<code>middle-school</code>不是一个有效的变量，就需要用<code>&#39;&#39;</code>括起来。访问这个属性也无法使用<code>.</code>操作符，必须用<code>[&#39;xxx&#39;]</code>来访问：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xiaohong[<span class="string">&#x27;middle-school&#x27;</span>]; <span class="comment">// &#x27;No.1 Middle School&#x27;</span></span><br><span class="line">xiaohong[<span class="string">&#x27;name&#x27;</span>]; <span class="comment">// &#x27;小红&#x27;</span></span><br><span class="line">xiaohong.name; <span class="comment">// &#x27;小红&#x27;</span></span><br></pre></td></tr></table></figure>

<p>如果访问一个不存在的属性会返回什么呢？JavaScript规定，访问不存在的属性不报错，而是返回<code>undefined</code></p>
<p>如果我们要检测<code>xiaoming</code>是否拥有某一属性，可以用<code>in</code>操作符：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    school: <span class="string">&#x27;No.1 Middle School&#x27;</span>,</span><br><span class="line">    height: <span class="number">1.70</span>,</span><br><span class="line">    weight: <span class="number">65</span>,</span><br><span class="line">    score: <span class="literal">null</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> xiaoming; <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;grade&#x27;</span> <span class="keyword">in</span> xiaoming; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>不过要小心，如果<code>in</code>判断一个属性存在，这个属性不一定是<code>xiaoming</code>的，它可能是<code>xiaoming</code>继承得到的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;toString&#x27;</span> <span class="keyword">in</span> xiaoming; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>因为<code>toString</code>定义在<code>object</code>对象中，而所有对象最终都会在原型链上指向<code>object</code>，所以<code>xiaoming</code>也拥有<code>toString</code>属性。</p>
<p>要判断一个属性是否是<code>xiaoming</code>自身拥有的，而不是继承得到的，可以用<code>hasOwnProperty()</code>方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.hasOwnProperty(<span class="string">&#x27;name&#x27;</span>); <span class="comment">// true</span></span><br><span class="line">xiaoming.hasOwnProperty(<span class="string">&#x27;toString&#x27;</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="变量-2"><a href="#变量-2" class="headerlink" title="变量"></a>变量</h3><p>变量的概念基本上和初中代数的方程变量是一致的，只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。</p>
<p>变量在JavaScript中就是用一个变量名表示，变量名是大小写英文、数字、<code>$</code>和<code>_</code>的组合，且不能用数字开头。变量名也不能是JavaScript的关键字，如<code>if</code>、<code>while</code>等。申明一个变量用<code>var</code>语句，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a; <span class="comment">// 申明了变量a，此时a的值为undefined</span></span><br><span class="line"><span class="keyword">var</span> $b = <span class="number">1</span>; <span class="comment">// 申明了变量$b，同时给$b赋值，此时$b的值为1</span></span><br><span class="line"><span class="keyword">var</span> s_007 = <span class="string">&#x27;007&#x27;</span>; <span class="comment">// s_007是一个字符串</span></span><br><span class="line"><span class="keyword">var</span> Answer = <span class="literal">true</span>; <span class="comment">// Answer是一个布尔值true</span></span><br><span class="line"><span class="keyword">var</span> t = <span class="literal">null</span>; <span class="comment">// t的值是null</span></span><br></pre></td></tr></table></figure>

<p>变量名也可以用中文，但是，请不要给自己找麻烦。</p>
<p>在JavaScript中，使用等号<code>=</code>对变量进行赋值。可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，但是要注意只能用<code>var</code>申明一次，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">123</span>; <span class="comment">// a的值是整数123</span></span><br><span class="line">a = <span class="string">&#x27;ABC&#x27;</span>; <span class="comment">// a变为字符串</span></span><br></pre></td></tr></table></figure>

<p>这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a = <span class="number">123</span>; <span class="comment">// a是整数类型变量，类型用int申明</span></span><br><span class="line">a = <span class="string">&quot;ABC&quot;</span>; <span class="comment">// 错误：不能把字符串赋给整型变量</span></span><br></pre></td></tr></table></figure>

<p>和静态语言相比，动态语言更灵活，就是这个原因。</p>
<p>请不要把赋值语句的等号等同于数学的等号。比如下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line">x = x + <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>如果从数学上理解<code>x = x + 2</code>那无论如何是不成立的，在程序中，赋值语句先计算右侧的表达式<code>x + 2</code>，得到结果<code>12</code>，再赋给变量<code>x</code>。由于<code>x</code>之前的值是<code>10</code>，重新赋值后，<code>x</code>的值变成<code>12</code>。</p>
<h3 id="strict模式"><a href="#strict模式" class="headerlink" title="strict模式"></a>strict模式</h3><p>JavaScript在设计之初，为了方便初学者学习，并不强制要求用<code>var</code>申明变量。这个设计错误带来了严重的后果：如果一个变量没有通过<code>var</code>申明就被使用，那么该变量就自动被申明为全局变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">10</span>; <span class="comment">// i现在是全局变量</span></span><br></pre></td></tr></table></figure>

<p>在同一个页面的不同的JavaScript文件中，如果都不用<code>var</code>申明，恰好都使用了变量<code>i</code>，将造成变量<code>i</code>互相影响，产生难以调试的错误结果。</p>
<p>使用<code>var</code>申明的变量则不是全局变量，它的范围被限制在该变量被申明的函数体内（函数的概念将稍后讲解），同名变量在不同的函数体内互不冲突。</p>
<p>为了修补JavaScript这一严重设计缺陷，ECMA在后续规范中推出了strict模式，在strict模式下运行的JavaScript代码，强制通过<code>var</code>申明变量，未使用<code>var</code>申明变量就使用的，将导致运行错误。</p>
<p>启用strict模式的方法是在JavaScript代码的第一行写上：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;use strict&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>这是一个字符串，不支持strict模式的浏览器会把它当做一个字符串语句执行，支持strict模式的浏览器将开启strict模式运行JavaScript。</p>
<h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p>ECMA-262 规定了一组语句（也称为流控制语句）。从本质上看，语句定义了 ECMAScript 中的主要语法，语句通常使用一或多个关键字来完成给定任务。语句可以很简单，例如通知函数退出；也可以比较复杂，例如指定重复执行某个命令的次数。</p>
<h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><p>大多数编程语言中最为常用的一个语句就是 if 语句。以下是 if 语句的语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) statement1 <span class="keyword">else</span> statement2</span><br></pre></td></tr></table></figure>

<p>其中的 condition（条件）可以是任意表达式；而且对这个表达式求值的结果不一定是布尔值。ECMAScript 会自动调用 <code>Boolean()</code>转换函数将这个表达式的结果转换为一个布尔值。如果对 condition 求值的结果是 true，则执行 statement1（语句 1），如果对 condition 求值的结果是 false，则执行 statement2（语句 2）。而且这两个语句既可以是一行代码，也可以是一个代码块（以一对花括号括起来的多行代码）。请看下面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">25</span>) </span><br><span class="line">    alert(<span class="string">&quot;Greater than 25.&quot;</span>);             <span class="comment">// 单行语句 </span></span><br><span class="line"><span class="keyword">else</span> &#123; </span><br><span class="line">    alert(<span class="string">&quot;Less than or equal to 25.&quot;</span>);    <span class="comment">// 代码块中的语句 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过，业界普遍推崇的最佳实践是始终使用代码块，即使要执行的只有一行代码。因为这样可以消除人们的误解，否则可能让人分不清在不同条件下要执行哪些语句。</p>
<p>另外，也可以像下面这样把整个 if 语句写在一行代码中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition1) statement1 <span class="keyword">else</span> <span class="keyword">if</span> (condition2) statement2 <span class="keyword">else</span> statement3</span><br></pre></td></tr></table></figure>

<p>但推荐的做法则是像下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">25</span>) &#123; </span><br><span class="line">    alert(<span class="string">&quot;Greater than 25.&quot;</span>); </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123; </span><br><span class="line">    alert(<span class="string">&quot;Less than 0.&quot;</span>); </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    alert(<span class="string">&quot;Between 0 and 25, inclusive.&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="do-while语句"><a href="#do-while语句" class="headerlink" title="do-while语句"></a>do-while语句</h3><p>do-while 语句是一种后测试循环语句，即只有在循环体中的代码执行之后，才会测试出口条件。换句话说，在对条件表达式求值之前，循环体内的代码至少会被执行一次。以下是 do-while 语句的语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123; </span><br><span class="line">    statement </span><br><span class="line">&#125; <span class="keyword">while</span> (expression);</span><br></pre></td></tr></table></figure>

<p>下面是一个示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">do</span> &#123; </span><br><span class="line">   i += <span class="number">2</span>; </span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; <span class="number">10</span>); </span><br><span class="line"> </span><br><span class="line">alert(i);</span><br></pre></td></tr></table></figure>

<p>在这个例子中，只要变量 i 的值小于 10，循环就会一直继续下去。而且变量 i 的值最初为 0，每次循环都会递增 2。</p>
<p>像 do-while 这种后测试循环语句最常用于循环体中的代码至少要被执行一次的情形。</p>
<h3 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h3><p>while 语句属于前测试循环语句，也就是说，在循环体内的代码被执行之前，就会对出口条件求值。因此，循环体内的代码有可能永远不会被执行。以下是 while 语句的语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(expression) statement</span><br></pre></td></tr></table></figure>

<p>下面是一个示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    i += <span class="number">2</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，变量 i 开始时的值为 0，每次循环都会递增 2。而只要 i 的值小于 10，循环就会继续下去。</p>
<h3 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h3><p>for 语句也是一种前测试循环语句，但它具有在执行循环之前初始化变量和定义循环后要执行的代码的能力。以下是 for 语句的语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (initialization; expression; post-loop-expression) statement</span><br></pre></td></tr></table></figure>

<p>下面是一个示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">10</span>; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; count; i++)&#123; </span><br><span class="line">    alert(i); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码定义了变量 i 的初始值为 0。只有当条件表达式（<code>i&lt;count</code>）返回 true 的情况下才会进入 for 循环，因此也有可能不会执行循环体中的代码。如果执行了循环体中的代码，则一定会对循环后的表达式（<code>i++</code>）求值，即递增 i 的值。这个 for 循环语句与下面的 while 语句的功能相同：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">10</span>; </span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">while</span> (i &lt; count)&#123; </span><br><span class="line">    alert(i); </span><br><span class="line">    i++; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 while 循环做不到的，使用 for 循环同样也做不到。也就是说，for 循环只是把与循环有关的代码集中在了一个位置。</p>
<p>有必要指出的是，在 for 循环的变量初始化表达式中，也可以不使用 var 关键字。该变量的初始化可以在外部执行，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">10</span>; </span><br><span class="line"><span class="keyword">var</span> i; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123; </span><br><span class="line">    alert(i); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码与在循环初始化表达式中声明变量的效果是一样的。由于 ECMAScript 中不存在块级作用域，因此在循环内部定义的变量也可以在外部访问到。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">10</span>; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">    alert(i); </span><br><span class="line">&#125; </span><br><span class="line">alert(i);    <span class="comment">//10</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，会有一个警告框显示循环完成后变量 i 的值，这个值是 10。这是因为，即使 i 是在循环内部定义的一个变量，但在循环外部仍然可以访问到它。</p>
<p>此外，for 语句中的初始化表达式、控制表达式和循环后表达式都是可选的。将这三个表达式全部省略，就会创建一个无限循环，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;   <span class="comment">// 无限循环 </span></span><br><span class="line">    doSomething(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而只给出控制表达式实际上就把 for 循环转换成了 while 循环，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">10</span>; </span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span> (; i &lt; count; )&#123; </span><br><span class="line">    alert(i); </span><br><span class="line">    i++; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 for 语句存在极大的灵活性，因此它也是 ECMAScript 中最常用的一个语句。</p>
<h3 id="for-in语句"><a href="#for-in语句" class="headerlink" title="for-in语句"></a>for-in语句</h3><p>for-in 语句是一种精准的迭代语句，可以用来枚举对象的属性。以下是 for-in 语句的语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (property <span class="keyword">in</span> expression) statement</span><br></pre></td></tr></table></figure>

<p>下面是一个示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> propName <span class="keyword">in</span> <span class="built_in">window</span>) &#123; </span><br><span class="line">     <span class="built_in">document</span>.write(propName); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们使用 for-in 循环来显示了 BOM 中 window 对象的所有属性。每次执行循环时，都会将 window 对象中存在的一个属性名赋值给变量 <code>propName</code>。这个过程会一直持续到对象中的所有属性都被枚举一遍为止。与 for 语句类似，这里控制语句中的 var 操作符也不是必需的。但是，为了保证使用局部变量，我们推荐上面例子中的这种做法。</p>
<p>ECMAScript 对象的属性没有顺序。因此，通过 for-in 循环输出的属性名的顺序是不可预测的。具体来讲，所有属性都会被返回一次，但返回的先后次序可能会因浏览器而异。</p>
<p>但是，如果表示要迭代的对象的变量值为 <code>null</code> 或 <code>undefined</code>，for-in 语句会抛出错误。ECMAScript 5 更正了这一行为；对这种情况不再抛出错误，而只是不执行循环体。为了保证最大限度的兼容性，建议在使用 for-in 循环之前，先检测确认该对象的值不是 null 或 undefined。</p>
<h3 id="label语句"><a href="#label语句" class="headerlink" title="label语句"></a>label语句</h3><p>使用 label 语句可以在代码中添加标签，以便将来使用。以下是 label 语句的语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label: statement</span><br></pre></td></tr></table></figure>

<p>下面是一个示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start: <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; count; i++) &#123; </span><br><span class="line">    alert(i);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子中定义的 start 标签可以在将来由 break 或 continue 语句引用。加标签的语句一般都要与 for 语句等循环语句配合使用。</p>
<h3 id="break和continue语句"><a href="#break和continue语句" class="headerlink" title="break和continue语句"></a>break和continue语句</h3><p>break 和 continue 语句用于在循环中精确地控制代码的执行。其中，break 语句会立即退出循环，强制继续执行循环后面的语句。而 continue 语句虽然也是立即退出循环，但退出循环后会从循环的顶部继续执行。请看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123; </span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">5</span> == <span class="number">0</span>) &#123; </span><br><span class="line">       <span class="keyword">break</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    num++; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">alert(num);    <span class="comment">//4</span></span><br></pre></td></tr></table></figure>

<p>这个例子中的 for 循环会将变量 i 由 1 递增至 10。在循环体内，有一个 if 语句检查 i 的值是否可以被 5 整除（使用求模操作符）。如果是，则执行 break 语句退出循环。另一方面，变量 num 从 0 开始，用于记录循环执行的次数。在执行 break 语句之后，要执行的下一行代码是 <code>alert()</code>函数，结果显示 4。也就是说，在变量 i 等于 5 时，循环总共执行了 4 次；而 break 语句的执行，导致了循环在num 再次递增之前就退出了。如果在这里把 break 替换为 continue 的话，则可以看到另一种结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123; </span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">5</span> == <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="keyword">continue</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    num++; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">alert(num);    <span class="comment">//8</span></span><br></pre></td></tr></table></figure>

<p>例子的结果显示 8，也就是循环总共执行了 8 次。当变量 i 等于 5 时，循环会在 num 再次递增之前退出，但接下来执行的是下一次循环，即 i 的值等于 6 的循环。于是，循环又继续执行，直到 i 等于10 时自然结束。而 num 的最终值之所以是 8，是因为 continue 语句导致它少递增了一次。</p>
<p>break 和 continue 语句都可以与 label 语句联合使用，从而返回代码中特定的位置。这种联合使用的情况多发生在循环嵌套的情况下，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line">outermost: </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; </span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">var</span> j=<span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123; </span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">5</span> &amp;&amp; j == <span class="number">5</span>) &#123; </span><br><span class="line">            <span class="keyword">break</span> outermost; </span><br><span class="line">        &#125; </span><br><span class="line">        num++; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">alert(num);    <span class="comment">//55</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，outermost 标签表示外部的 for 语句。如果每个循环正常执行 10 次，则 <code>num++</code> 语句就会正常执行 100 次。换句话说，如果两个循环都自然结束，num 的值应该是 100。但内部循环中的 break 语句带了一个参数：要返回到的标签。添加这个标签的结果将导致 break 语句不仅会退出内部的 for 语句（即使用变量 j 的循环），而且也会退出外部的 for 语句（即使用变量 i 的循环）。为此，当变量 i 和 j 都等于 5 时，num 的值正好是 55。同样，continue 语句也可以像这样与 label 语句联用，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line">outermost: </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j=<span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123; </span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">5</span> &amp;&amp; j == <span class="number">5</span>) &#123; </span><br><span class="line">            <span class="keyword">continue</span> outermost; </span><br><span class="line">        &#125; </span><br><span class="line">        num++; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">alert(num);    <span class="comment">//95</span></span><br></pre></td></tr></table></figure>

<p>在这种情况下，continue 语句会强制继续执行循环——退出内部循环，执行外部循环。当 j 是 5 时，continue 语句执行，而这也就意味着内部循环少执行了 5 次，因此 num 的结果是 95。</p>
<p>虽然联用 break、continue 和 label 语句能够执行复杂的操作，但如果使用过度，也会给调试带来麻烦。在此，建议如果使用 label 语句，一定要使用描述性的标签，同时不要嵌套过多的循环。</p>
<h3 id="with语句"><a href="#with语句" class="headerlink" title="with语句"></a>with语句</h3><p>with 语句的作用是将代码的作用域设置到一个特定的对象中。with 语句的语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> (expression) statement;</span><br></pre></td></tr></table></figure>

<p>定义 with 语句的目的主要是为了简化多次编写同一个对象的工作，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> qs = location.search.substring(<span class="number">1</span>); </span><br><span class="line"><span class="keyword">var</span> hostName = location.hostname; </span><br><span class="line"><span class="keyword">var</span> url = location.href;</span><br></pre></td></tr></table></figure>

<p>上面几行代码都包含 location 对象。如果使用 with 语句，可以把上面的代码改写成如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">with</span>(<span class="params">location</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">var</span> qs = search.substring(<span class="number">1</span>); </span><br><span class="line">    <span class="keyword">var</span> hostName = hostname; </span><br><span class="line">    <span class="keyword">var</span> url = href; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个重写后的例子中，使用 with 语句关联了 location 对象。这意味着在 with 语句的代码块内部，每个变量首先被认为是一个局部变量，而如果在局部环境中找不到该变量的定义，就会查询location 对象中是否有同名的属性。如果发现了同名属性，则以 location 对象属性的值作为变量的值。</p>
<p>严格模式下不允许使用 with 语句，否则将视为语法错误。</p>
<blockquote>
<p>由于大量使用 with 语句会导致性能下降，同时也会给调试代码造成困难，因此在开发大型应用程序时，不建议使用 with 语句。</p>
</blockquote>
<h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><p>switch 语句与 if 语句的关系最为密切，而且也是在其他语言中普遍使用的一种流控制语句。ECMAScript 中 switch 语句的语法与其他基于 C 的语言非常接近，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expression) &#123; </span><br><span class="line">  <span class="keyword">case</span> value: statement </span><br><span class="line">    <span class="keyword">break</span>; </span><br><span class="line">  <span class="keyword">case</span> value: statement </span><br><span class="line">    <span class="keyword">break</span>; </span><br><span class="line">  <span class="keyword">case</span> value: statement </span><br><span class="line">    <span class="keyword">break</span>; </span><br><span class="line">  <span class="keyword">case</span> value: statement </span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>: statement </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>switch 语句中的每一种情形（case）的含义是：“如果表达式等于这个值（value），则执行后面的语句（statement）”。而 break 关键字会导致代码执行流跳出 switch 语句。如果省略 break 关键字，就会导致执行完当前 case 后，继续执行下一个 case。最后的 default 关键字则用于在表达式不匹配前面任何一种情形的时候，执行机动代码（因此，也相当于一个 else 语句）。</p>
<p>从根本上讲，switch 语句就是为了让开发人员免于编写像下面这样的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i == <span class="number">25</span>)&#123; </span><br><span class="line">  alert(<span class="string">&quot;25&quot;</span>); </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">35</span>) &#123; </span><br><span class="line">  alert(<span class="string">&quot;35&quot;</span>); </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">45</span>) &#123; </span><br><span class="line">  alert(<span class="string">&quot;45&quot;</span>); </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">  alert(<span class="string">&quot;Other&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而与此等价的 switch 语句如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (i) &#123; </span><br><span class="line">    <span class="keyword">case</span> <span class="number">25</span>:  </span><br><span class="line">        alert(<span class="string">&quot;25&quot;</span>); </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">    <span class="keyword">case</span> <span class="number">35</span>:  </span><br><span class="line">        alert(<span class="string">&quot;35&quot;</span>); </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">    <span class="keyword">case</span> <span class="number">45</span>:  </span><br><span class="line">        alert(<span class="string">&quot;45&quot;</span>); </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">    <span class="keyword">default</span>:  </span><br><span class="line">        alert(<span class="string">&quot;Other&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过为每个 case 后面都添加一个 break 语句，就可以避免同时执行多个 case 代码的情况。假如确实需要混合几种情形，不要忘了在代码中添加注释，说明你是有意省略了 break 关键字，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (i) &#123; </span><br><span class="line">    <span class="keyword">case</span> <span class="number">25</span>:  </span><br><span class="line">        <span class="comment">/* 合并两种情形 */</span> </span><br><span class="line">    <span class="keyword">case</span> <span class="number">35</span>:  </span><br><span class="line">        alert(<span class="string">&quot;25 or 35&quot;</span>); </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">    <span class="keyword">case</span> <span class="number">45</span>:  </span><br><span class="line">        alert(<span class="string">&quot;45&quot;</span>); </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">    <span class="keyword">default</span>:  </span><br><span class="line">        alert(<span class="string">&quot;Other&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然 ECMAScript 中的 switch 语句借鉴自其他语言，但这个语句也有自己的特色。首先，可以在 switch 语句中使用任何数据类型（在很多其他语言中只能使用数值），无论是字符串，还是对象都没有问题。其次，每个 case 的值不一定是常量，可以是变量，甚至是表达式。请看下面这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (<span class="string">&quot;hello world&quot;</span>) &#123; </span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;hello&quot;</span> + <span class="string">&quot; world&quot;</span>:  </span><br><span class="line">        alert(<span class="string">&quot;Greeting was found.&quot;</span>); </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;goodbye&quot;</span>:  </span><br><span class="line">        alert(<span class="string">&quot;Closing was found.&quot;</span>); </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">    <span class="keyword">default</span>:  </span><br><span class="line">        alert(<span class="string">&quot;Unexpected message was found.&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，switch 语句使用的就是字符串。其中，第一种情形实际上是一个对字符串拼接操作求值的表达式。由于这个字符串拼接表达式的结果与 switch 的参数相等，因此结果就会显示”Greeting was found.”。而且，使用表达式作为 case 值还可以实现下列操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">25</span>; </span><br><span class="line"><span class="keyword">switch</span> (<span class="literal">true</span>) &#123; </span><br><span class="line">    <span class="keyword">case</span> num &lt; <span class="number">0</span>:  </span><br><span class="line">        alert(<span class="string">&quot;Less than 0.&quot;</span>); </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">    <span class="keyword">case</span> num &gt;= <span class="number">0</span> &amp;&amp; num &lt;= <span class="number">10</span>:  </span><br><span class="line">        alert(<span class="string">&quot;Between 0 and 10.&quot;</span>); </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">    <span class="keyword">case</span> num &gt; <span class="number">10</span> &amp;&amp; num &lt;= <span class="number">20</span>:  </span><br><span class="line">        alert(<span class="string">&quot;Between 10 and 20.&quot;</span>); </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">    <span class="keyword">default</span>:  </span><br><span class="line">        alert(<span class="string">&quot;More than 20.&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子首先在 switch 语句外面声明了变量 num。而之所以给 switch 语句传递表达式 true，是因为每个 case 值都可以返回一个布尔值。这样，每个 case 按照顺序被求值，直到找到匹配的值或者遇到 default 语句为止（这正是这个例子的最终结果）。</p>
<h2 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h2><p>函数对任何语言来说都是一个核心的概念。通过函数可以封装任意多条语句，而且可以在任何地方、任何时候调用执行。ECMAScript 中的函数使用 function 关键字来声明，后跟一组参数以及函数体。函数的基本语法如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">functionName</span>(<span class="params">arg0, arg1,...,argN</span>) </span>&#123; </span><br><span class="line">    statements </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是一个函数示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">name, message</span>) </span>&#123; </span><br><span class="line">    alert(<span class="string">&quot;Hello &quot;</span> + name + <span class="string">&quot;,&quot;</span> + message); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数可以通过其函数名来调用，后面还要加上一对圆括号和参数（圆括号中的参数如果有多个，<br>可以用逗号隔开）。调用 <code>sayHi()</code> 函数的代码如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sayHi(<span class="string">&quot;Nicholas&quot;</span>, <span class="string">&quot;how are you today?&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这个函数的输出结果是“Hello Nicholas,how are you today?”。函数中定义中的命名参数 name<br>和 message 被用作了字符串拼接的两个操作数，而结果最终通过警告框显示了出来。</p>
<p>ECMAScript 中的函数在定义时不必指定是否返回值。实际上，任何函数在任何时候都可以通过<br>return 语句后跟要返回的值来实现返回值。请看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> num1 + num2; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 sum()函数的作用是把两个值加起来返回一个结果。我们注意到，除了 return 语句之外，没有任何声明表示该函数会返回一个值。调用这个函数的示例代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = sum(<span class="number">5</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>这个函数会在执行完 return 语句之后停止并立即退出。因此，位于 return 语句之后的任何代码都永远不会执行。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> num1 + num2; </span><br><span class="line">    alert(<span class="string">&quot;Hello world&quot;</span>);    <span class="comment">// 永远不会执行永远不会执行 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，由于调用 <code>alert()</code> 函数的语句位于 return 语句之后，因此永远不会显示警告框。 当然，一个函数中也可以包含多个 return 语句，如下面这个例子中所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diff</span>(<span class="params">num1, num2</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (num1 &lt; num2) &#123; </span><br><span class="line">        <span class="keyword">return</span> num2 - num1; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> num1 - num2; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子中定义的 <code>diff()</code> 函数用于计算两个数值的差。如果第一个数比第二个小，则用第二个数减第一个数；否则，用第一个数减第二个数。代码中的两个分支都具有自己的 return 语句，分别用于<br>执行正确的计算。</p>
<p>另外，return 语句也可以不带有任何返回值。在这种情况下，函数在停止执行后将返回 undefined 值。这种用法一般用在需要提前停止函数执行而又不需要返回值的情况下。比如在下面这个例子中，就不会显示警告框：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">name, message</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span>; </span><br><span class="line">    alert(<span class="string">&quot;Hello &quot;</span> + name + <span class="string">&quot;,&quot;</span> + message);    <span class="comment">//永远不会调用 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>严格模式对函数有一些限制：</p>
<ul>
<li>不能把函数命名为 eval 或 arguments；</li>
<li>不能把参数命名为 eval 或 arguments；</li>
<li>不能出现两个命名参数同名的情况。</li>
</ul>
<p>如果发生以上情况，就会导致语法错误，代码无法执行。</p>
<h3 id="理解参数"><a href="#理解参数" class="headerlink" title="理解参数"></a>理解参数</h3><p>ECMAScript 函数的参数与大多数其他语言中函数的参数有所不同。ECMAScript 函数不介意传递进来多少个参数，也不在乎传进来参数是什么数据类型。也就是说，即便你定义的函数只接收两个参数，在调用这个函数时也未必一定要传递两个参数。可以传递一个、三个甚至不传递参数，而解析器永远不会有什么怨言。之所以会这样，原因是 ECMAScript 中的参数在内部是用一个数组来表示的。函数接收到的始终都是这个数组，而不关心数组中包含哪些参数（如果有参数的话）。如果这个数组中不包含任何元素，无所谓；如果包含多个元素，也没有问题。实际上，在函数体内可以通过 arguments 对象来访问这个参数数组，从而获取传递给函数的每一个参数。</p>
<p>其实，arguments 对象只是与数组类似（它并不是 Array 的实例），因为可以使用方括号语法访问它的每一个元素（即第一个元素是 <code>arguments[0]</code>，第二个元素是 <code>argumetns[1]</code>，以此类推），使用 length 属性来确定传递进来多少个参数。在前面的例子中，<code>sayHi()</code>函数的第一个参数的名字叫<code>name</code>，而该参数的值也可以通过访问 <code>arguments[0]</code>来获取。因此，那个函数也可以像下面这样重写，即不显式地使用命名参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    alert(<span class="string">&quot;Hello &quot;</span> + <span class="built_in">arguments</span>[<span class="number">0</span>] + <span class="string">&quot;,&quot;</span> + <span class="built_in">arguments</span>[<span class="number">1</span>]); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个重写后的函数中不包含命名的参数。虽然没有使用 <code>name</code> 和 <code>message</code> 标识符，但函数的功能依旧。这个事实说明了 ECMAScript 函数的一个重要特点：命名的参数只提供便利，但不是必需的。另外，在命名参数方面，其他语言可能需要事先创建一个函数签名，而将来的调用必须与该签名一致。但在 ECMAScript 中，没有这些条条框框，解析器不会验证命名参数。</p>
<p>通过访问 arguments 对象的 length 属性可以获知有多少个参数传递给了函数。下面这个函数会在每次被调用时，输出传入其中的参数个数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">howManyArgs</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    alert(<span class="built_in">arguments</span>.length); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">howManyArgs(<span class="string">&quot;string&quot;</span>, <span class="number">45</span>);  <span class="comment">//2 </span></span><br><span class="line">howManyArgs();              <span class="comment">//0 </span></span><br><span class="line">howManyArgs(<span class="number">12</span>);            <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<p>执行以上代码会依次出现 3 个警告框，分别显示 2、0 和 1。由此可见，开发人员可以利用这一点让函数能够接收任意个参数并分别实现适当的功能。请看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doAdd</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">arguments</span>.length == <span class="number">1</span>) &#123; </span><br><span class="line">        alert(<span class="built_in">arguments</span>[<span class="number">0</span>] + <span class="number">10</span>); </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">arguments</span>.length == <span class="number">2</span>) &#123; </span><br><span class="line">        alert(<span class="built_in">arguments</span>[<span class="number">0</span>] + <span class="built_in">arguments</span>[<span class="number">1</span>]); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">doAdd(<span class="number">10</span>);        <span class="comment">//20 </span></span><br><span class="line">doAdd(<span class="number">30</span>, <span class="number">20</span>);     <span class="comment">//50</span></span><br></pre></td></tr></table></figure>

<p>函数 <code>doAdd()</code> 会在只有一个参数的情况下给该参数加上 10；如果是两个参数，则将那个参数简单相加并返回结果。因此，<code>doAdd(10)</code>会返回 20，而 <code>doAdd(30,20)</code>则返回 50。虽然这个特性算不上完美的重载，但也足够弥补 ECMAScript 的这一缺憾了。</p>
<p>另一个与参数相关的重要方面，就是 arguments 对象可以与命名参数一起使用，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doAdd</span>(<span class="params">num1, num2</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">arguments</span>.length == <span class="number">1</span>) &#123; </span><br><span class="line">       alert(num1 + <span class="number">10</span>); </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">arguments</span>.length == <span class="number">2</span>) &#123; </span><br><span class="line">        alert(<span class="built_in">arguments</span>[<span class="number">0</span>] + num2); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在重写后的这个 <code>doAdd()</code> 函数中，两个命名参数都与 arguments 对象一起使用。由于 num1 的值<br>与 <code>arguments[0]</code> 的值相同，因此它们可以互换使用（当然，<code>num2</code> 和 <code>arguments[1]</code> 也是如此）。</p>
<p>关于 arguments 的行为，还有一点比较有意思。那就是它的值永远与对应命名参数的值保持同步。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doAdd</span>(<span class="params">num1, num2</span>) </span>&#123; </span><br><span class="line">    <span class="built_in">arguments</span>[<span class="number">1</span>] = <span class="number">10</span>;     </span><br><span class="line">    alert(<span class="built_in">arguments</span>[<span class="number">0</span>] + num2); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次执行这个 <code>doAdd()</code> 函数都会重写第二个参数，将第二个参数的值修改为 10。因为 arguments 对象中的值会自动反映到对应的命名参数，所以修改 <code>arguments[1]</code> ，也就修改了 <code>num2</code>，结果它们的值都会变成 10。不过，这并不是说读取这两个值会访问相同的内存空间；它们的内存空间是独立的，但它们的值会同步。另外还要记住，如果只传入了一个参数，那么为 <code>arguments[1]</code>设置的值不会反应到命名参数中。这是因为 arguments 对象的长度是由传入的参数个数决定的，不是由定义函数时的命名参数的个数决定的。</p>
<p>关于参数还要记住最后一点：没有传递值的命名参数将自动被赋予 undefined 值。这就跟定义了变量但又没有初始化一样。例如，如果只给 <code>doAdd()</code> 函数传递了一个参数，则 <code>num2</code> 中就会保存<br>undefined 值。</p>
<p>严格模式对如何使用 arguments 对象做出了一些限制。首先，像前面例子中那样的赋值会变得无效。也就是说，即使把 <code>arguments[1]</code>设置为 10，num2 的值仍然还是 undefined。其次，重写<br>arguments 的值会导致语法错误（代码将不会执行）。</p>
<h3 id="没有重载"><a href="#没有重载" class="headerlink" title="没有重载"></a>没有重载</h3><p>ECMAScript 函数不能像传统意义上那样实现重载。而在其他语言（如 Java）中，可以为一个函数编写两个定义，只要这两个定义的签名（接受的参数的类型和数量）不同即可。如前所述，ECMAScirpt函数没有签名，因为其参数是由包含零或多个值的数组来表示的。而没有函数签名，真正的重载是不可能做到的。</p>
<p>如果在 ECMAScript 中定义了两个名字相同的函数，则该名字只属于后定义的函数。请看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addSomeNumber</span>(<span class="params">num</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> num + <span class="number">100</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addSomeNumber</span>(<span class="params">num</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> num + <span class="number">200</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> result = addSomeNumber(<span class="number">100</span>);    <span class="comment">//300</span></span><br></pre></td></tr></table></figure>

<p>在此，函数 <code>addSomeNumber()</code> 被定义了两次。第一个版本给参数加 100，而第二个版本给参数加 200。由于后定义的函数覆盖了先定义的函数，因此当在最后一行代码中调用这个函数时，返回的结果就是 300。</p>
<p>如前所述，通过检查传入函数中参数的类型和数量并作出不同的反应，可以模仿方法的重载。</p>
<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>文档对象模型（DOM，Document Object Model）是 HTML 和 XML 文档的编程接口。DOM 表示由多层节点构成的文档，通过它开发者可以添加、删除和修改页面的各个部分。脱胎于网景和微软早期的动态 HTML（DHTML，Dynamic HTML），DOM 现在是真正跨平台、语言无关的表示和操作网页的方式。</p>
<p>DOM Level 1 在 1998 年成为 W3C 推荐标准，提供了基本文档结构和查询的接口。本章之所以介绍 DOM，主要因为它与浏览器中的 HTML 网页相关，并且在 JavaScript 中提供了 DOM API。</p>
<h3 id="节点层级"><a href="#节点层级" class="headerlink" title="节点层级"></a>节点层级</h3><p>任何 HTML 或 XML 文档都可以用 DOM 表示为一个由节点构成的层级结构。节点分很多类型，每种类型对应着文档中不同的信息和（或）标记，也都有自己不同的特性、数据和方法，而且与其他类型有某种关系。这些关系构成了层级，让标记可以表示为一个以特定节点为根的树形结构。以下面的 HTML 为例：</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>《JavaScript高级程序设计_第3版》</li>
<li>《JavaScript高级程序设计_第4版》</li>
</ul>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">G</span><span class="switch-btn"></span><span class="second-comment">i</span></div></div><div class="comment-wrap"><div></div><div></div><div></div><div></div><div></div><div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">JavaScript概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaScript%E4%BD%BF%E7%94%A8"><span class="toc-number">1.1.1.</span> <span class="toc-text">JavaScript使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-number">1.1.2.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E4%BF%9D%E7%95%99%E5%AD%97"><span class="toc-number">1.1.3.</span> <span class="toc-text">关键字和保留字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A"><span class="toc-number">1.1.4.</span> <span class="toc-text">注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%86%E5%A4%A7%E5%B0%8F%E5%86%99"><span class="toc-number">1.1.5.</span> <span class="toc-text">区分大小写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">1.1.6.</span> <span class="toc-text">标识符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.7.</span> <span class="toc-text">严格模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E4%BD%BF%E7%94%A8"><span class="toc-number">1.1.7.1.</span> <span class="toc-text">选择使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">1.1.7.2.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.7.3.</span> <span class="toc-text">对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.7.4.</span> <span class="toc-text">函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F-1"><span class="toc-number">1.1.8.</span> <span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#var-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.1.8.1.</span> <span class="toc-text">var 关键字</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#typeof%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">1.2.1.</span> <span class="toc-text">typeof操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null%E5%92%8Cundefined"><span class="toc-number">1.2.2.</span> <span class="toc-text">null和undefined</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.3.</span> <span class="toc-text">String类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">字符字面量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">字符串的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">转换为字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E8%A1%8C%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">多行字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.2.3.5.</span> <span class="toc-text">模板字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.2.3.6.</span> <span class="toc-text">操作字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#toUpperCase"><span class="toc-number">1.2.3.6.1.</span> <span class="toc-text">toUpperCase</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#toLowerCase"><span class="toc-number">1.2.3.6.2.</span> <span class="toc-text">toLowerCase</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#indexOf"><span class="toc-number">1.2.3.6.3.</span> <span class="toc-text">indexOf</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#substring"><span class="toc-number">1.2.3.6.4.</span> <span class="toc-text">substring</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Boolean%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.4.</span> <span class="toc-text">Boolean类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Number%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.5.</span> <span class="toc-text">Number类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E5%80%BC"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">浮点数值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E8%8C%83%E5%9B%B4"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">数值范围</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NaN"><span class="toc-number">1.2.5.3.</span> <span class="toc-text">NaN</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.2.5.4.</span> <span class="toc-text">数值转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.6.</span> <span class="toc-text">Object类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">1.2.7.</span> <span class="toc-text">操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E5%85%83%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">1.2.7.1.</span> <span class="toc-text">一元操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%A2%9E%E5%92%8C%E8%87%AA%E5%87%8F"><span class="toc-number">1.2.7.1.1.</span> <span class="toc-text">自增和自减</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E5%85%83%E5%8A%A0%E5%92%8C%E5%87%8F%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">1.2.7.1.2.</span> <span class="toc-text">一元加和减操作符</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">1.2.7.2.</span> <span class="toc-text">位操作符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">1.2.7.3.</span> <span class="toc-text">布尔操作符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B9%98%E6%80%A7%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">1.2.7.4.</span> <span class="toc-text">乘性操作符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E6%80%A7%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">1.2.7.5.</span> <span class="toc-text">加性操作符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">1.2.7.6.</span> <span class="toc-text">关系操作符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E7%AD%89%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">1.2.7.7.</span> <span class="toc-text">相等操作符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">1.2.7.8.</span> <span class="toc-text">条件操作符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">1.2.7.9.</span> <span class="toc-text">赋值操作符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%97%E5%8F%B7%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">1.2.7.10.</span> <span class="toc-text">逗号操作符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">1.2.8.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#indexOf-1"><span class="toc-number">1.2.8.1.</span> <span class="toc-text">indexOf</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#slice"><span class="toc-number">1.2.8.2.</span> <span class="toc-text">slice</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#push%E5%92%8Cpop"><span class="toc-number">1.2.8.3.</span> <span class="toc-text">push和pop</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unshift%E5%92%8Cshift"><span class="toc-number">1.2.8.4.</span> <span class="toc-text">unshift和shift</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sort"><span class="toc-number">1.2.8.5.</span> <span class="toc-text">sort</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#reverse"><span class="toc-number">1.2.8.6.</span> <span class="toc-text">reverse</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#splice"><span class="toc-number">1.2.8.7.</span> <span class="toc-text">splice</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#concat"><span class="toc-number">1.2.8.8.</span> <span class="toc-text">concat</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#join"><span class="toc-number">1.2.8.9.</span> <span class="toc-text">join</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">1.2.8.10.</span> <span class="toc-text">多维数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1-1"><span class="toc-number">1.2.9.</span> <span class="toc-text">对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F-2"><span class="toc-number">1.2.10.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#strict%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.2.11.</span> <span class="toc-text">strict模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.3.</span> <span class="toc-text">语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#if%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.3.1.</span> <span class="toc-text">if语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#do-while%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.3.2.</span> <span class="toc-text">do-while语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#while%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.3.3.</span> <span class="toc-text">while语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.3.4.</span> <span class="toc-text">for语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for-in%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.3.5.</span> <span class="toc-text">for-in语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#label%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.3.6.</span> <span class="toc-text">label语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#break%E5%92%8Ccontinue%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.3.7.</span> <span class="toc-text">break和continue语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#with%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.3.8.</span> <span class="toc-text">with语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#switch%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.3.9.</span> <span class="toc-text">switch语句</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0-1"><span class="toc-number">1.4.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E5%8F%82%E6%95%B0"><span class="toc-number">1.4.1.</span> <span class="toc-text">理解参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B2%A1%E6%9C%89%E9%87%8D%E8%BD%BD"><span class="toc-number">1.4.2.</span> <span class="toc-text">没有重载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DOM"><span class="toc-number">1.5.</span> <span class="toc-text">DOM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E5%B1%82%E7%BA%A7"><span class="toc-number">1.5.1.</span> <span class="toc-text">节点层级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">1.6.</span> <span class="toc-text">参考资料</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By Halo</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>