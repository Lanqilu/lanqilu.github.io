<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>数据结构——图 | HALO</title><meta name="author" content="HALO"><meta name="copyright" content="HALO"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="图"><meta property="og:type" content="article"><meta property="og:title" content="数据结构——图"><meta property="og:url" content="http://halo123.top/2021/05/09/DataStructure/F_graph/index.html"><meta property="og:site_name" content="HALO"><meta property="og:description" content="图"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/137f30002b2fd221da0e9.jpg"><meta property="article:published_time" content="2021-05-09T14:50:51.000Z"><meta property="article:modified_time" content="2021-05-11T07:20:14.716Z"><meta property="article:author" content="HALO"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/137f30002b2fd221da0e9.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://halo123.top/2021/05/09/DataStructure/F_graph/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""><link rel="preconnect" href="//hm.baidu.com"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-resources@latest/css/butterflyindex.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?874122390435717e6f6a55f14b9d7271";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-8ZMD16RCP5"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-8ZMD16RCP5")</script><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:1e3},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!1,islazyload:!1,isanchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2021-05-11 15:20:14"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));const n=saveToLocal.get("global-font-size");void 0!==n&&document.documentElement.style.setProperty("--global-font-size",n+"px")})(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-resources@latest/css/bilibili-banner.css" media="defer" onload='this.media="screen"'><link rel="stylesheet" href="/css/butterfly.css"><link rel="stylesheet" href="/css/link.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css" media="defer" onload='this.media="all"'><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="HALO" type="application/atom+xml"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://img.imgdb.cn/item/608289f3d1a9ae528feb09a8.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">89</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">51</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">27</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/page/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/page/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/page/message/"><i class="fa-fw fas fa-envelope"></i> <span>反馈</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i> <span>链接</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/page/link/"><i class="fa-fw fas fa-link"></i> <span>友情链接</span></a></li><li><a class="site-page child" href="/page/toolsLink/"><i class="fa-fw fas fa-link"></i> <span>实用工具</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/137f30002b2fd221da0e9.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">HALO</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/page/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/page/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/page/message/"><i class="fa-fw fas fa-envelope"></i> <span>反馈</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i> <span>链接</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/page/link/"><i class="fa-fw fas fa-link"></i> <span>友情链接</span></a></li><li><a class="site-page child" href="/page/toolsLink/"><i class="fa-fw fas fa-link"></i> <span>实用工具</span></a></li></ul></div></div><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div class="springBanner" id="springBanner"><div class="layer"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/BilibiliBannerSpring/i1.png" data-move-multiple="16.395" style="transform:matrix(1,0,0,1,0,-17.4194)"></div><div class="layer"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/BilibiliBannerSpring/i2.png" data-move-multiple="16.395" style="transform:matrix(1,0,0,1,1277.42,0)"></div><div class="layer"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/BilibiliBannerSpring/i3.png" data-move-multiple="12.145" style="transform:matrix(1,0,0,1,783.871,0)"></div><div class="layer"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/BilibiliBannerSpring/i4.png" data-move-multiple="3.718" style="transform:matrix(1,0,0,1,-739.742,0)"></div><div class="layer"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/BilibiliBannerSpring/i5.png" data-move-multiple="14.573" style="transform:matrix(1,0,0,1,705.484,52.2581)"></div><div class="layer"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/BilibiliBannerSpring/i6.png" data-move-multiple="29.277" data-is-opacity="0" style="transform:matrix(1,0,0,1,292.645,42.271)"></div><div class="layer"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/BilibiliBannerSpring/i7.png" data-move-multiple="2.342" style="transform:matrix(1,0,0,1,130.065,16.2581)"></div><div class="layer"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/BilibiliBannerSpring/i8.png" data-move-multiple="1.952" style="transform:matrix(1,0,0,1,-406.452,56.9032)"></div><div class="layer"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/BilibiliBannerSpring/i9.png" data-move-multiple="4.098" data-is-opacity="1" style="transform:matrix(1,0,0,1,-278.71,18.5806)"></div><div class="layer"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/BilibiliBannerSpring/i10.png" data-move-multiple="2.826" data-is-opacity="1" style="transform:matrix(1,0,0,1,-394.839,37.1613)"></div><div class="layer"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/BilibiliBannerSpring/i11.png" data-move-multiple="1.457" style="transform:matrix(1,0,0,1,-104.516,15.6774)"></div><div class="layer"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/BilibiliBannerSpring/i12.png" data-move-multiple="1.092" style="transform:matrix(1,0,0,1,116.129,0)"></div><div class="layer"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/BilibiliBannerSpring/i13.png" data-move-multiple="1.104" style="transform:matrix(1,0,0,1,250.839,15.6774)"></div><div class="layer"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/BilibiliBannerSpring/i14.png" data-move-multiple="0.781" style="transform:matrix(1,0,0,1,2438.71,0)"></div><div class="layer"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/BilibiliBannerSpring/i15.png" data-move-multiple="0.546" style="transform:matrix(1,0,0,1,-1161.29,0)"></div><div><canvas id="canvas" width="1920" height="180"></canvas></div></div><script async data-pjax src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-resources@latest/js/bilibiliBanner.js"></script><div id="post-info"><h1 class="post-title">数据结构——图</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-05-09T14:50:51.000Z" title="发表于 2021-05-09 22:50:51">2021-05-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-11T07:20:14.716Z" title="更新于 2021-05-11 15:20:14">2021-05-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="数据结构——图"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="图的基本概念"><a class="header-anchor" href="#图的基本概念"></a>图的基本概念</h2><h3 id="图的定义"><a class="header-anchor" href="#图的定义"></a>图的定义</h3><p>图 $G$ 由顶点集 $V$ 和边集 $E$ 组成，记为 $G=(V,E)$，其中 $V(G)$ 表示图 $G$ 中顶点的有限非空集；$E(G)$ 表示图 $G$ 中顶点之间的关系 （边）集合。若 $V= {v_1,v_2,\dots v_n}$，则用 $|V|$ 表示图 $G$ 中顶点的个数，也称图 $G$ 的阶，$E= {(\mu,\nu)|\mu \in V,\nu \in V } $，用 $|E|$ 表示图 $G$ 中边的条数。</p><p>注意：线性表可以是空表，树可以是空树，但图不可以是空图。就是说，图中不能一个顶点也没有，图的顶点集 $V$ 一定非空，但边集 $E$ 可以为空，此时图中只有顶点而没有边。</p><p>下面是图的一些基本概念及术语。</p><h4 id="有向图和无向图"><a class="header-anchor" href="#有向图和无向图"></a>有向图和无向图</h4><p>若 $E$ 是有向边（也称弧）的有限集合时，则图 $G$ 为有向图。弧是顶点的有序对，记为 $&lt;v, w&gt;$ ，其中 $v$，$w$ 是顶点，$v$ 称为弧尾，$w$ 称为弧头，$&lt;v, w&gt;$ 称为从顶点 $v$ 到顶点 $w$ 的弧，也称 $v$ 邻接到 $w$，或 $w$ 邻接自 $v$。</p><p>若 $E$ 是无向边（简称边）的有限集合时，则图 $G$ 为无向图。边是顶点的无序对，记为 $(v,w)$ 或 $(w,v)$，因为$(v, w)=(w,v)$ 其中 $v$，$w$ 是顶点。可以说顶点 $w$ 和顶点 $v$ 互为邻接点。边 $(v, w)$ 依附于顶点 $w$ 和 $v$ ，或者说边 $(v, w)$ 和顶点 $v$，$w$ 相关联。</p><h4 id="简单图和多重图"><a class="header-anchor" href="#简单图和多重图"></a>简单图和多重图</h4><p>一个图 $G$ 若满足：</p><ol><li>不存在重复边；</li><li>不存在顶点到自身的边，则称图 $G$ 为简单图。</li></ol><p>数据结构中仅讨论简单图。</p><p>若图 $G$ 中某两个结点之间的边数多于一条，又允许顶点通过同一.条边和自己关联，则 $G$ 为多重图。多重图的定义和简单图是相对的。</p><h4 id="顶点的度、入度和出度"><a class="header-anchor" href="#顶点的度、入度和出度"></a>顶点的度、入度和出度</h4><p>图中每个顶点的度定义为以该顶点为一个端点的边的数目。</p><p>对于无向图，顶点 $v$ 的度是指依附于该顶点的边的条数，记为 $\mathrm{TD} (v)$。</p><p>在具有 $n$ 个顶点、$e$ 条边的无向图中，$\sum_{i=1}^{n} \mathrm{TD} (v_i)=2e$，即无向图的全部顶点的度的和等于边数的2倍，因为每条边和两个顶点相关联。</p><p>对于有向图，顶点 $v$ 的度分为入度和出度，入度是以顶点 $v$ 为终点的有向边的数目，记为 $\mathrm{ID}(v)$；而出度是以顶点 $v$ 为起点的有向边的数目，记为 $\mathrm{OD}(v)$。顶点 $v$ 的度等于其入度和出度之和，即 $\mathrm{TD} (v)=\mathrm{ID}(v)+\mathrm{OD}(v)$。</p><p>在具有 $n$ 个顶点、$e$ 条边的有向图中，$\sum_{i=1}^{n} \mathrm{ID} (v_i)=\sum_{i=1}^{n} \mathrm{OD} (v_i)=e$，即有向图的全部顶点的入度之和与出度之和相等，并且等于边数。这是因为每条有向边都有一个起点和终点。</p><h4 id="路径、路径长度和回路"><a class="header-anchor" href="#路径、路径长度和回路"></a>路径、路径长度和回路</h4><p>顶点 $v_p$ 到顶点 $v_q$ 之间的一条路径是指顶点序列 $v_p,v_{i1},v_{i2},\dots ,v_{im},v_q$，当然关联的边也可以理解为路径的构成要素。</p><p>路径上边的数目称为路径长度。</p><p>第一个顶点和最后一个顶点相同的路径称为回路或环。若一个图有 $n$ 个顶点，并且有大于 $n-1$ 条边，则此图一定有环。</p><h4 id="简单路径、简单回路"><a class="header-anchor" href="#简单路径、简单回路"></a>简单路径、简单回路</h4><p>在路径序列中，顶点不重复出现的路径称为简单路径。</p><p>除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路称为简单回路。</p><h4 id="距离"><a class="header-anchor" href="#距离"></a>距离</h4><p>从顶点 $u$ 出发到顶点 $v$ 的最短路径若存在，则此路径的长度称为从 $u$ 到 $v$ 的距离；若从 $u$ 到 $v$ 根本不存在路径，则记该距离为无穷( $∞$ )</p><h4 id="连通、连通图"><a class="header-anchor" href="#连通、连通图"></a>连通、连通图</h4><p>在无向图中，若从顶点 $v$ 到顶点 $w$ 有路径存在，则称 $v$ 和 $w$ 是连通的。若图 $G$ 中任意两个顶点都是连通的，则称图 $G$为<font color="#ea66a6">连通图</font>，否则称为非连通图。</p><p>若图 $G$ 是连通图，则至少有 $n-1$ 条边。若 $G$ 是非连通图，则至多可能有 $C_{n-1}^{2}$ 条边</p><h4 id="强连通图、"><a class="header-anchor" href="#强连通图、"></a>强连通图、</h4><p>在有向图中，若从顶点 $v$ 到顶点 $w$ 和从顶点 $w$ 到顶点 $v$ 之间都有路径，则称这两个顶点是强连通的。若图中任何一对顶点都是强连通的，则称此图为强连通图。</p><p>若 $G$ 是强连通图，则最少有 $n$ 条边（形成回路）</p><p>注意：强连通图、强连通分量只是针对有向图而言的。一般在无向图中讨论连通性，在有向图中考虑强连通性。</p><h4 id="子图"><a class="header-anchor" href="#子图"></a>子图</h4><p>设有两个图 $G=(V,E)$ 和 $G’=(V’,E’)$ ，若 $V’$ 是 $V$ 的子集，且 $E’$ 是 $E$ 的子集，则称 $G’$ 是 $G$ 的子图。若有满足 $V(G’)=V(G)$ 的子图 $G’$ ，则称其为 $G$ 的生成子图。</p><p>注意：并非 $V$ 和 $E$ 的任何子集都能构成 $G$ 的子图，因为这样的子集可能不是图，即 $E$ 的子集中的某些边关联的顶点可能不在这个 $V$ 的子集中。</p><h4 id="连通分量、强连通分量"><a class="header-anchor" href="#连通分量、强连通分量"></a>连通分量、强连通分量</h4><p>无向图中的极大连通子图称为连通分量。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E6%97%A0%E5%90%91%E5%9B%BE%E5%8F%8A%E5%85%B6%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F.png" alt="无向图及其连通分量"></p><p>有向图中的极大强连通子图称为有向图的强连通分量。</p><blockquote><p>注意：要区分极大连通子图和极小连通子图，极大连通子图是无向图的连通分量，极大即要求该连通子图包含其所有的边；极小连通子图是既要保持图连通又要使得边数最少的子图。</p></blockquote><h4 id="生成树、生成森林"><a class="header-anchor" href="#生成树、生成森林"></a>生成树、生成森林</h4><p>连通图的生成树是包含图中全部顶点的一个极小连通子图。若图中顶点数为 $n$ ，则它的生成树含有 $n-1$ 条边。</p><p>对生成树而言，若砍去它的一条边，则会变成非连通图，若加上一条边则会形成一个回路。</p><p>在非连通图中，连通分量的生成树构成了非连通图的生成森林。</p><h4 id="边的权和网"><a class="header-anchor" href="#边的权和网"></a>边的权和网</h4><p>在一个图中，每条边都可以标上具有某种含义的数值，该数值称为该边的权值。这种边上带有权值的图称为带权图，也称网。</p><p>带权路径长度：当图是带权图时，一条路径上所有边的权值之和，称为该路径的带权路径长度</p><h4 id="完全图"><a class="header-anchor" href="#完全图"></a>完全图</h4><p>无向完全图：无向图中任意两个顶点之间都存在边，若无向图的顶点数 $|V|=n$ ，则 $|E|\in [0,C_n^2]=[0,\frac{n(n-1)}{2} ] $</p><p>有向完全图：有向图中任意两个顶点之间都存在方向相反的两条弧，若有向图的顶点数 $|V|=n$ ，则 $|E|\in [0,2C_n^2]=[0,n(n-1) ] $</p><h4 id="稠密图、稀疏图"><a class="header-anchor" href="#稠密图、稀疏图"></a>稠密图、稀疏图</h4><p>边数很少的图称为稀疏图，反之称为稠密图。</p><p>稀疏和稠密本身是模糊的概念，稀疏图和稠密图常常是相对而言的。一般当图 $G$ 满足 $|E| &lt; |V|\log|V|$ 时，可以将 $G$ 视为稀疏图。</p><h4 id="树、有向树"><a class="header-anchor" href="#树、有向树"></a>树、有向树</h4><p>树：不存在回路，且连通的无向图。$n$ 个顶点的树，必有 $n-1$ 条边。</p><p>一个顶点的入度为0，其余顶点的入度均为 1 的有向图，称为有向树。</p><h2 id="图的存储及基本操作"><a class="header-anchor" href="#图的存储及基本操作"></a>图的存储及基本操作</h2><h3 id="邻接矩阵法"><a class="header-anchor" href="#邻接矩阵法"></a>邻接矩阵法</h3><p>所谓邻接矩阵存储，是指用一个一维数组存储图中顶点的信息，用一个二维数组存储图中边的信息（即各顶点之间的邻接关系），存储顶点之间邻接关系的二维数组称为邻接矩阵。</p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/有向图、无向图及网的邻接矩阵.png" alt="有向图、无向图及网的邻接矩阵" style="zoom:200%"><p>图的邻接矩阵存储结构定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertexNum 100  <span class="comment">// 顶点数目的最大值</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VertexType;  <span class="comment">// 顶点的数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> EdgeType;     <span class="comment">// 带权图中边上权值的数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    VertexType Vex[MaxVertexNum];               <span class="comment">// 顶点表</span></span><br><span class="line">    EdgeType Edge[MaxVertexNum][MaxVertexNum];  <span class="comment">// 邻接矩阵，边表</span></span><br><span class="line">    <span class="keyword">int</span> vexnum, arcnum;  <span class="comment">// 图的当前顶点数和边数/弧数</span></span><br><span class="line">&#125; MGraph;</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>在简单应用中，可直接用二维数组作为图的邻接矩阵（顶点信息等均可省略）。</li><li>当邻接矩阵中的元素仅表示相应的边是否存在时，<code>EdgeType</code> 可定义为值为 0 和 1 的枚举类型。</li><li>无向图的邻接矩阵是<font color="#faa755">对称矩阵</font>，对规模特大的邻接矩阵可采用<a href="http://halo123.top/2021/05/02/DataStructure/C_StacksAndQueues/#%E5%AF%B9%E7%A7%B0%E7%9F%A9%E9%98%B5">压缩存储</a>。</li><li>邻接矩阵表示法的空间复杂度为 $O(n^2)$，其中 $n$ 为图的顶点数 $|V|$。</li></ol><p>图的邻接矩阵存储表示法具有以下特点：</p><ol><li>对于无向图，邻接矩阵的第 $i$ 行（或第 $i$ 列）非零元素（或非 $∞$ 元素）的个数正好是第 $i$ 个顶点的度 $TD(v)$。时间复杂度 $O(|V|)$。</li><li>对于有向图，邻接矩阵的第 $i$ 行（或第 $i$ 列）非零元素（或非 $∞$ 元素）的个数正好是第 $i$ 个顶点的出度 $OD(v)$ [或入度 $ID(v)$ ]。第 $i$ 行结点的度即为，第 $i$ 行和列的非零元素（或非 $∞$ 元素）的个数之和。时间复杂度 $O(|V|)$。</li><li>设图 $G$ 的邻接矩阵为 $\mathbf{A} $，$\mathbf{A}^n$ 的元素 $A^n[i][j]$ 等于由顶点 $i$ 到顶点 $j$ 的长度为 $n$ 的路径的数目。（妙啊）</li><li>稠密图适合使用邻接矩阵的存储表示。</li><li>无向图的邻接矩阵一定是一个对称矩阵（并且唯一）。 因此，在实际存储邻接矩阵时只需存储上（或下）三角矩阵的元素。</li><li>用邻接矩阵法存储图，很容易确定图中任意两个顶点之间是否有边相连。但是，要确定图中有多少条边，则必须按行、按列对每个元素进行检测，所花费的时间代价很大。</li></ol><h3 id="邻接表法"><a class="header-anchor" href="#邻接表法"></a>邻接表法</h3><p>当一个图为稀疏图时，使用邻接矩阵法显然要浪费大量的存储空间，而图的邻接表法结合了顺序存储和链式存储方法，大大减少了这种不必要的浪费。</p><p>所谓邻接表，是指对图 $G$ 中的每个顶点 $v_i$ 建立一个单链表，第 $i$ 个单链表中的结点表示依附于顶点 $v_i$ 的边（对于有向图则是以顶点 $v_i$ 为尾的弧），这个单链表就称为顶点 $v_i$ 的边表（对于有向图则称为出边表）。边表的头指针和顶点的数据信息采用顺序存储（称为顶点表），所以在邻接表中存在两种结点：顶点表结点和边表结点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertexNum 100 <span class="comment">// 图中顶点数目的最大值</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VertexType;  <span class="comment">// 顶点的数据类型</span></span><br><span class="line"><span class="comment">// &quot;边/弧&quot;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> adjvex;            <span class="comment">// &quot;边/弧&quot;指向哪个结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">next</span>;</span>  <span class="comment">// 指向下一条弧的指针</span></span><br><span class="line">    <span class="comment">// InfoType info       // 边权值</span></span><br><span class="line">&#125; ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;顶点&quot;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span> &#123;</span></span><br><span class="line">    VertexType data;  <span class="comment">// 顶点信息</span></span><br><span class="line">    ArcNode *first;   <span class="comment">// 第一条边/弧</span></span><br><span class="line">&#125; VNode, AdjList[MaxVertexNum];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用邻接表存储的图</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    AdjList vertices;</span><br><span class="line">    <span class="keyword">int</span> vexnum, arcnum;</span><br><span class="line">&#125; ALGraph;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E6%97%A0%E5%90%91%E5%9B%BE%E9%82%BB%E6%8E%A5%E8%A1%A8%E8%A1%A8%E7%A4%BA%E6%B3%95%E5%AE%9E%E4%BE%8B.png" alt="无向图邻接表表示法实例"></p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E6%9C%89%E5%90%91%E5%9B%BE%E9%82%BB%E6%8E%A5%E8%A1%A8%E8%A1%A8%E7%A4%BA%E6%B3%95%E5%AE%9E%E4%BE%8B.png" alt="有向图邻接表表示法实例"></p><p>图的邻接表存储方法具有以下特点：</p><ol><li>若 $G$ 为无向图，则所需的存储空间为 $O(|V|+ 2|E|)$；若 $G$ 为有向图，则所需的存储空间为 $O(|V|+ |E|)$。前者的倍数 2 是由于无向图中，每条边在邻接表中出现了两次。</li><li>对于稀疏图，采用邻接表表示将极大地节省存储空间。</li><li>在邻接表中，给定一顶点，能很容易地找出它的所有邻边，因为只需要读取它的邻接表。在邻接矩阵中，相同的操作则需要扫描一行，花费的时间为 $O(n)$ 。 但是，若要确定给定的两个顶点间是否存在边，则在邻接矩阵中可以立刻查到，而在邻接表中则需要在相应结点对应的边表中查找另一结点，效率较低。</li><li>在有向图的邻接表表示中，求一个给定顶点的<font color="#faa755">出度</font>只需计算其邻接表中的结点个数；但求其顶点的<font color="#faa755">入度</font>则需要遍历全部的邻接表。因此，也有人采用逆邻接表的存储方式来加速求解给定顶点的入度。当然，这实际上与邻接表存储方式是类似的。</li><li>图的邻接表表示并不唯一，因为在每个项点对应的单链表中，各边结点的链接次序可以是任意的，它取决于建立邻接表的算法及边的输入次序。</li></ol><h3 id="十字链表法"><a class="header-anchor" href="#十字链表法"></a>十字链表法</h3><p>十字链表是<font color="#faa755">有向图</font>的一种链式存储结构。在十字链表中，对应于有向图中的每条弧有一个结点，对应于每个顶点也有一个结点。</p><p>弧结点中有 5 个域：尾域（<code>tailvex</code>） 和头域（<code>headvex</code>）分别指示弧尾和弧头这两个顶点在图中的位置；链域 <code>hlink</code> 指向弧头相同的下一条弧；链域 <code>tlink</code> 指向弧尾相同的下一条弧；<code>info</code> 域指向该弧的相关信息。这样，弧头相同的弧就在同一个链表上，弧尾相同的弧也在同一个链表上。</p><p>顶点结点中有 3 个域：<code>data</code> 域存放顶点相关的数据信息，如顶点名称；<code>firstin</code> 和 <code>firstout</code> 两个域分别指向以该顶点为弧头或弧尾的第一个弧结点。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8%E8%A1%A8%E7%A4%BA.png" alt="有向图的十字链表表示"></p><p>在十字链表中，既容易找到 $V_i$ 为尾的弧，又容易找到 $V_i$ 为头的弧，因而容易求得顶点的出度和入度。图的十字链表表示是不唯一的， 但一个十字链表表示确定一个 图。空间复杂度：$O(|V|+|E|)$</p><p>TODO 代码实现十字链表法</p><h3 id="邻接多重表法"><a class="header-anchor" href="#邻接多重表法"></a>邻接多重表法</h3><p>邻接多重表是<font color="#faa755">无向图</font>的另一种链式存储结构。</p><p>在邻接表中，容易求得顶点和边的各种信息，但在邻接表中求两个顶点之间是否存在边而对边执行删除等操作时，需要分别在两个顶点的边表中遍历，效率较低。</p><p>与十字链表类似，在邻接多重表中，每条边用一个结点表示，其结构如下所示。</p><p>其中，<code>mark</code> 为标志域，可用以标记该条边是否被搜索过；<code>ivex</code> 和 <code>jvex</code> 为该边依附的两个顶点在图中的位置；<code>ilink</code> 指向下一条依附于顶点 <code>ivex</code> 的边；<code>jlink</code> 指向下一条依附于顶点 <code>jvex</code> 的边，<code>info</code> 为指向和边相关的各种信息的指针域。</p><p>每个顶点也用一个结点表示，它由如下所示的两个域组成。</p><p>其中，<code>data</code> 域存储该顶点的相关信息，<code>firstedge</code> 域指示第一条依附于该顶点的边。</p><p>在邻接多重表中，所有依附于同一顶点的边串联在同一链表中，由于每条边依附于两个顶点，因此每个边结点同时链接在两个链表中。对无向图而言，其邻接多重表和邻接表的差别仅在于，同一条边在邻接表中用两个结点表示，而在邻接多重表中只有一个结点。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8%E8%A1%A8%E7%A4%BA.png" alt="无向图的邻接多重表表示"></p><p>空间复杂度：$O(|V|+|E|)$。</p><h3 id="图的基本操作"><a class="header-anchor" href="#图的基本操作"></a>图的基本操作</h3><p>图的基本操作是独立于图的存储结构的。而对于不同的存储方式，操作算法的具体实现会有着不同的性能。在设计具体算法的实现时，应考虑采用何种存储方式的算法效率会更高。</p><p>图的基本操作主要包括（仅抽象地考虑，故忽略掉各变量的类型）：</p><ul><li><code>Adjacent (G,x,y)</code>：判断图 $G$ 是否存在边 $&lt;x,y&gt;$ 或 $(x,y)$。邻接矩阵时间复杂度：$O(1)$，邻接表时间复杂度：$O(1)\sim O(|V|)$。</li><li><code>Neighbors (G,x)</code>：列出图 $G$ 中与结点 $x$ 邻接的边。邻接矩阵时间复杂度：$O(|V|)$；邻接表无向图时间复杂度：$O(1)\sim O(|V|)$，邻接表有向图出边时间复杂度：$O(1)\sim O(|V|)$，邻接表有向图入边时间复杂度：$O(|E|)$。</li><li><code>InsertVertex(G,x)</code>：在图 $G$ 中插入顶点 $x$ 。邻接矩阵和邻接表时间复杂度：$O(1)$</li><li><code>DeleteVertex(G,x)</code>：从图 $G$ 中删除顶点 $x$。邻接矩阵无向图时间复杂度：$O(|V|)$，邻接表无向图时间复杂度：$O(1)\sim O(|E|)$；邻接矩阵有向图时间复杂度：$O(|V|)$，邻接表删出边：$O(1)\sim O(|V|)$，邻接表删入边：$O(|E|)$</li><li><code>AddEdge (G,x,y)</code>：若无向边 $(x, y)$ 或有向边 $&lt;x, y&gt;$ 不存在，则向图 $G$ 中添加该边。邻接矩阵 $O(1)$，邻接表 $O(1)$</li><li><code>RemoveEdge(G,x,y)</code>：若无向边 $(x, y)$ 或有向边 $&lt;x, y&gt;$ 存在，则从图 $G$ 中删除该边。邻接矩阵 $O(1)$，邻接表 $O(1) \sim O(|V|)$</li><li><code>FirstNeighbor(G,x)</code>：求图 $G$ 中顶点 $x$ 的第一个邻接点，若有则返回顶点号。若 $x$ 没有邻接点或图中不存在 $x$ ，则返回 -1。邻接矩阵无向图 $O(1)\sim O(|V|)$，邻接表无向图 $O(1)$；邻接矩阵有向图 $O(1)\sim O(|V|)$，邻接表有向图找出边邻接点：$O(1)$，邻接表有向图找入边邻接点：$O(1)\sim O(|E|)$</li><li><code>NextNeighbor (G,x,y)</code>：假设图 $G$ 中顶点 $y$ 是顶点 $x$ 的一个邻接点，返回除 $y$ 外顶点 $x$ 的下一个邻接点的顶点号，若 $y$ 是 $x$ 的最后一个邻接点，则返回 -1。邻接矩阵 $O(1)\sim O(|V|)$，邻接表 $O(1)$；</li><li><code>Get_edge_value(G,x,y)</code>：获取图 $G$ 中边 $(x, y)$ 或 $&lt;x, y&gt;$ 对应的权值。时间复杂度同 <code>Adjacent (G,x,y)</code></li><li><code>Set_edge_value(G,x,y,v)</code>：设置图 $G$ 中边 $(x, y)$ 或 $&lt;x, y&gt;$ 对应的权值为 $v$ 。时间复杂度同 <code>Adjacent (G,x,y)</code></li></ul><p>此外，还有图的遍历算法：按照某种方式访问图中的每个顶点且仅访问一次。图的遍历算法包括深度优先遍历和广度优先遍历。</p><p>TODO 分析十字链表法和邻接多重表法下的基本操作的时间复杂度</p><h2 id="图的遍历"><a class="header-anchor" href="#图的遍历"></a>图的遍历</h2><p>图的遍历是指从图中的某一顶点出发，按照某种搜索方法沿着图中的边对图中的所有顶点访问一次且仅访问一次。注意到树是一种特殊的图，所以树的遍历实际上也可视为一种特殊的图的遍历。图的遍历算法是求解图的连通性问题、拓扑排序和求关键路径等算法的基础。</p><p>图的遍历比树的遍历要复杂得多，因为图的任一顶点都可能和其余的顶点相邻接，所以在访问某个顶点后，可能沿着某条路径搜索又回到该顶点上。为避免同一顶点被访问多次，在遍历图的过程中，必须记下每个已访问过的顶点，为此可以设一个辅助数组 <code>visited[]</code> 来标记顶点是否被访问过。图的遍历算法主要有两种：广度优先搜索和深度优先搜索。</p><h3 id="广度优先搜索"><a class="header-anchor" href="#广度优先搜索"></a>广度优先搜索</h3><p>广度优先搜索（Breadth-First- Search, BFS）类似于二叉树的层序遍历算法。基本思想是：首先访问起始顶点 $v$ ，接着由 $v$ 出发，依次访问 $v$ 的各个未访问过的邻接顶点 $w_1,w_2,\dots ,w_i$ 然后依次访问 $w_1,w_2,\dots ,w_i$ 的所有未被访问过的邻接顶点；再从这些访问过的顶点出发，访问它们所有未被访问过的邻接顶点，直至图中所有顶点都被访问过为止。若此时图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作为始点，重复上述过程，直至图中所有顶点都被访问到为止。Dijkstra 单源最短路径算法和 Prim 最小生成树算法也应用了类似的思想。</p><p>换句话说，广度优先搜索遍历图的过程是以 $v$ 为起始点，由近至远依次访问和 $v$ 有路径相通且路径长度为 1，2，… 的顶点。广度优先搜索是一种分层的查找过程，每向前走一步可能访问一批顶点，不像深度优先搜索那样有往回退的情况，因此它不是一个递归的算法。为了实现逐层的访问，算法必须<font color="#faa755">借助一个辅助队列</font>，以记忆正在访问的顶点的下一层顶点。</p><p>广度优先遍历算法的伪代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> visited[MAX_VERTEX_NUM];  <span class="comment">// 访问标记数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//广度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Graph G, <span class="keyword">int</span> v)</span> </span>&#123;  <span class="comment">//从顶点v出发，广度优先遍历图G</span></span><br><span class="line">    <span class="built_in">visit</span>(v);  <span class="comment">//访问初始顶点v</span></span><br><span class="line">    visited[v] = TRUE;  <span class="comment">//对v做已访问标记</span></span><br><span class="line">    <span class="built_in">Enqueue</span>(Q, v);  <span class="comment">//顶点v入队列Q</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isEmpty</span>(Q)) &#123;</span><br><span class="line">        <span class="built_in">DeQueue</span>(Q, v);  <span class="comment">//顶点v出队列</span></span><br><span class="line">        <span class="keyword">for</span> (w = <span class="built_in">FirstNeighbor</span>(G, v); w &gt;= <span class="number">0</span>; w = <span class="built_in">NextNeighbor</span>(G, v, w))</span><br><span class="line">            <span class="comment">//检测v所有邻接点</span></span><br><span class="line">            <span class="keyword">if</span> (!visited[w]) &#123;      <span class="comment">// w为v的尚未访问的邻接顶点</span></span><br><span class="line">                <span class="built_in">visit</span>(w);           <span class="comment">//访问顶点w</span></span><br><span class="line">                visited[w] = TRUE;  <span class="comment">//对w做已访问标记</span></span><br><span class="line">                <span class="built_in">EnQueue</span>(Q, w);      <span class="comment">//顶点w入队列</span></span><br><span class="line">            &#125;                       </span><br><span class="line">    &#125;                              </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同一个图的邻接矩阵表示方式唯一，因此广度优先历序列唯一</p><p>同一个图邻接表表示方式不唯一，因此广度优先遍历序列不唯一</p></article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">图的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.</span> <span class="toc-text">图的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE%E5%92%8C%E6%97%A0%E5%90%91%E5%9B%BE"><span class="toc-number">1.1.1.</span> <span class="toc-text">有向图和无向图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%9B%BE%E5%92%8C%E5%A4%9A%E9%87%8D%E5%9B%BE"><span class="toc-number">1.1.2.</span> <span class="toc-text">简单图和多重图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B6%E7%82%B9%E7%9A%84%E5%BA%A6%E3%80%81%E5%85%A5%E5%BA%A6%E5%92%8C%E5%87%BA%E5%BA%A6"><span class="toc-number">1.1.3.</span> <span class="toc-text">顶点的度、入度和出度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E3%80%81%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6%E5%92%8C%E5%9B%9E%E8%B7%AF"><span class="toc-number">1.1.4.</span> <span class="toc-text">路径、路径长度和回路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%B7%AF%E5%BE%84%E3%80%81%E7%AE%80%E5%8D%95%E5%9B%9E%E8%B7%AF"><span class="toc-number">1.1.5.</span> <span class="toc-text">简单路径、简单回路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%9D%E7%A6%BB"><span class="toc-number">1.1.6.</span> <span class="toc-text">距离</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E9%80%9A%E3%80%81%E8%BF%9E%E9%80%9A%E5%9B%BE"><span class="toc-number">1.1.7.</span> <span class="toc-text">连通、连通图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%9B%BE%E3%80%81"><span class="toc-number">1.1.8.</span> <span class="toc-text">强连通图、</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E5%9B%BE"><span class="toc-number">1.1.9.</span> <span class="toc-text">子图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%E3%80%81%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F"><span class="toc-number">1.1.10.</span> <span class="toc-text">连通分量、强连通分量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E6%A0%91%E3%80%81%E7%94%9F%E6%88%90%E6%A3%AE%E6%9E%97"><span class="toc-number">1.1.11.</span> <span class="toc-text">生成树、生成森林</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%B9%E7%9A%84%E6%9D%83%E5%92%8C%E7%BD%91"><span class="toc-number">1.1.12.</span> <span class="toc-text">边的权和网</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E5%9B%BE"><span class="toc-number">1.1.13.</span> <span class="toc-text">完全图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%A0%E5%AF%86%E5%9B%BE%E3%80%81%E7%A8%80%E7%96%8F%E5%9B%BE"><span class="toc-number">1.1.14.</span> <span class="toc-text">稠密图、稀疏图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E3%80%81%E6%9C%89%E5%90%91%E6%A0%91"><span class="toc-number">1.1.15.</span> <span class="toc-text">树、有向树</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E5%8F%8A%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">2.</span> <span class="toc-text">图的存储及基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text">邻接矩阵法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">邻接表法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8%E6%B3%95"><span class="toc-number">2.3.</span> <span class="toc-text">十字链表法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8%E6%B3%95"><span class="toc-number">2.4.</span> <span class="toc-text">邻接多重表法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">2.5.</span> <span class="toc-text">图的基本操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">3.</span> <span class="toc-text">图的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-number">3.1.</span> <span class="toc-text">广度优先搜索</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By HALO</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-resources@latest/js/butterflyutils.js"></script><script src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-resources@latest/js/butterflymain.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if(window.MathJax)MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset();else{window.MathJax={loader:{source:{"[tex]/amsCd":"[tex]/amscd"}},tex:{inlineMath:[["$","$"],["\\(","\\)"]],tags:"ams"},options:{renderActions:{findScript:[10,t=>{for(const e of document.querySelectorAll('script[type^="math/tex"]')){const a=!!e.type.match(/; *mode=display/),n=new t.options.MathItem(e.textContent,t.inputJax[0],a),s=document.createTextNode("");e.parentNode.replaceChild(s,e),n.start={node:s,delim:"",n:0},n.end={node:s,delim:"",n:0},t.math.push(n)}},""],addClass:[200,()=>{document.querySelectorAll("mjx-container:not([display='true']").forEach(t=>{const e=t.parentNode;e.classList.contains("has-jax")||e.classList.add("mathjax-overflow")})},"",!1]}}};const t=document.createElement("script");t.src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js",t.id="MathJax-script",t.async=!0,document.head.appendChild(t)}</script><script>function addGitalkSource(){const e=document.createElement("link");e.rel="stylesheet",e.href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css",document.getElementsByTagName("head")[0].appendChild(e)}function loadGitalk(){function e(){new Gitalk(Object.assign({clientID:"e5a3e7481d96cd2d0a56",clientSecret:"ae9c98707484f2afb1db73120ce2f3347afb32eb",repo:"BlogResources",owner:"lanqilu",admin:["lanqilu"],id:"c7d527fc15f2db99538d24f2e634b765",language:"zh-CN",perPage:10,distractionFreeMode:!1,pagerDirection:"last",createIssueManually:!0,updateCountCallback:commentCount},null)).render("gitalk-container")}"function"==typeof Gitalk?e():(addGitalkSource(),getScript("https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js").then(e))}function commentCount(e){let t=document.querySelector("#post-meta .gitalk-comment-count");t&&(t.innerHTML=e)}{function loadOtherComment(){loadGitalk()}loadGitalk()}</script></div><script defer src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script defer src="/js/butterfly.js"></script><script defer src="https://cdn.jsdelivr.net/npm/hexo-theme-volantis@latest/source/js/issues.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>