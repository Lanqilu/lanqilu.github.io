<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>数据结构——树与二叉树 | HALO</title><meta name="author" content="HALO"><meta name="copyright" content="HALO"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="树"><meta property="og:type" content="article"><meta property="og:title" content="数据结构——树与二叉树"><meta property="og:url" content="http://halo123.top/2021/05/07/DataStructure/E_Tree/index.html"><meta property="og:site_name" content="HALO"><meta property="og:description" content="树"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/137f30002b2fd221da0e9.jpg"><meta property="article:published_time" content="2021-05-07T11:30:51.000Z"><meta property="article:modified_time" content="2021-05-08T16:08:33.901Z"><meta property="article:author" content="HALO"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/137f30002b2fd221da0e9.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://halo123.top/2021/05/07/DataStructure/E_Tree/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""><link rel="preconnect" href="//hm.baidu.com"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-resources@latest/css/butterflyindex.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?874122390435717e6f6a55f14b9d7271";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-8ZMD16RCP5"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-8ZMD16RCP5")</script><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:1e3},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!1,islazyload:!1,isanchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2021-05-09 00:08:33"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));const n=saveToLocal.get("global-font-size");void 0!==n&&document.documentElement.style.setProperty("--global-font-size",n+"px")})(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-resources@latest/css/bilibili-banner.css" media="defer" onload='this.media="screen"'><link rel="stylesheet" href="/css/butterfly.css"><link rel="stylesheet" href="/css/link.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css" media="defer" onload='this.media="all"'><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="HALO" type="application/atom+xml"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://img.imgdb.cn/item/608289f3d1a9ae528feb09a8.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">85</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">51</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">27</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/page/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/page/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/page/message/"><i class="fa-fw fas fa-envelope"></i> <span>反馈</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i> <span>链接</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/page/link/"><i class="fa-fw fas fa-link"></i> <span>友情链接</span></a></li><li><a class="site-page child" href="/page/toolsLink/"><i class="fa-fw fas fa-link"></i> <span>实用工具</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/137f30002b2fd221da0e9.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">HALO</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/page/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/page/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/page/message/"><i class="fa-fw fas fa-envelope"></i> <span>反馈</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i> <span>链接</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/page/link/"><i class="fa-fw fas fa-link"></i> <span>友情链接</span></a></li><li><a class="site-page child" href="/page/toolsLink/"><i class="fa-fw fas fa-link"></i> <span>实用工具</span></a></li></ul></div></div><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div class="springBanner" id="springBanner"><div class="layer"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/BilibiliBannerSpring/i1.png" data-move-multiple="16.395" style="transform:matrix(1,0,0,1,0,-17.4194)"></div><div class="layer"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/BilibiliBannerSpring/i2.png" data-move-multiple="16.395" style="transform:matrix(1,0,0,1,1277.42,0)"></div><div class="layer"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/BilibiliBannerSpring/i3.png" data-move-multiple="12.145" style="transform:matrix(1,0,0,1,783.871,0)"></div><div class="layer"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/BilibiliBannerSpring/i4.png" data-move-multiple="3.718" style="transform:matrix(1,0,0,1,-739.742,0)"></div><div class="layer"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/BilibiliBannerSpring/i5.png" data-move-multiple="14.573" style="transform:matrix(1,0,0,1,705.484,52.2581)"></div><div class="layer"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/BilibiliBannerSpring/i6.png" data-move-multiple="29.277" data-is-opacity="0" style="transform:matrix(1,0,0,1,292.645,42.271)"></div><div class="layer"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/BilibiliBannerSpring/i7.png" data-move-multiple="2.342" style="transform:matrix(1,0,0,1,130.065,16.2581)"></div><div class="layer"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/BilibiliBannerSpring/i8.png" data-move-multiple="1.952" style="transform:matrix(1,0,0,1,-406.452,56.9032)"></div><div class="layer"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/BilibiliBannerSpring/i9.png" data-move-multiple="4.098" data-is-opacity="1" style="transform:matrix(1,0,0,1,-278.71,18.5806)"></div><div class="layer"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/BilibiliBannerSpring/i10.png" data-move-multiple="2.826" data-is-opacity="1" style="transform:matrix(1,0,0,1,-394.839,37.1613)"></div><div class="layer"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/BilibiliBannerSpring/i11.png" data-move-multiple="1.457" style="transform:matrix(1,0,0,1,-104.516,15.6774)"></div><div class="layer"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/BilibiliBannerSpring/i12.png" data-move-multiple="1.092" style="transform:matrix(1,0,0,1,116.129,0)"></div><div class="layer"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/BilibiliBannerSpring/i13.png" data-move-multiple="1.104" style="transform:matrix(1,0,0,1,250.839,15.6774)"></div><div class="layer"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/BilibiliBannerSpring/i14.png" data-move-multiple="0.781" style="transform:matrix(1,0,0,1,2438.71,0)"></div><div class="layer"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/BilibiliBannerSpring/i15.png" data-move-multiple="0.546" style="transform:matrix(1,0,0,1,-1161.29,0)"></div><div><canvas id="canvas" width="1920" height="180"></canvas></div></div><script async data-pjax src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-resources@latest/js/bilibiliBanner.js"></script><div id="post-info"><h1 class="post-title">数据结构——树与二叉树</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-05-07T11:30:51.000Z" title="发表于 2021-05-07 19:30:51">2021-05-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-08T16:08:33.901Z" title="更新于 2021-05-09 00:08:33">2021-05-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="数据结构——树与二叉树"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>【考纲内容】</p><ol><li>树的基本概念</li><li>二叉树的定义及其主要特征</li><li>二叉树的顺序存储结构和链式存储结构</li><li>二叉树的遍历</li><li>线索二叉树的基本概念和构造</li><li>树的存储结构</li><li>森林与二叉树的转换</li><li>树和森林的遍历</li><li>二叉排序树</li><li>平衡二叉树</li><li>哈夫曼树和哈夫曼编码</li></ol><p>【知识框架】</p><p>TODO 完成树与二叉树章节的知识框架</p><p>【复习提示】</p><p>本章内容多以选择题的形式考查，但也会出涉及树遍历相关的算法题。树和二叉树的性质、遍历操作、转换、存储结构和操作特性等，满二叉树、完全二叉树、线索二叉树、哈夫曼树的定义和性质，二叉排序树和二叉平衡树的性质和操作等，都是选择题必然会涉及的内容。</p><h2 id="树的基本概念"><a class="header-anchor" href="#树的基本概念"></a>树的基本概念</h2><h3 id="树的定义"><a class="header-anchor" href="#树的定义"></a>树的定义</h3><p>树是 $n \ (n\ge 0)$ 个节点的有限集。当 $n=0$ 时，称为空树。在任意一颗非空树中应满足：</p><ol><li>有且仅有一个特定的称为根的结点。</li><li>当 $n&gt;1$ 时，其余节点可分为 $m\ (m&gt;0)$ 个互不相交的有限集 $T_1,T_2,\dots ,T_m$，其中每个集合本身又是一棵树，并称为根的子树。</li></ol><p>显然，树的定义是递归的，即在树的定义中又用到了其自身，树是一种递归的数据结构。树作为一种逻辑结构，同时也是一种分层结构，具有以下两个特点：</p><ol><li>树的根结点没有前驱，除根结点外的所有结点有且只有一个前驱。</li><li>树中所有结点可以有零个或多个后继。</li></ol><p>树适合于表示具有层次结构的数据。树中的某个结点（除根结点外）最多只和上一层的一个结点（即其父结点）有直接关系，根结点没有直接上层结点，因此在 $n$ 个结点的树中有 $n-1$ 条边。而树中每个结点与其下一层的零个或多个结点（即其子女结点）有直接关系。</p><h3 id="基本术语"><a class="header-anchor" href="#基本术语"></a>基本术语</h3><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E6%A0%91%E7%9A%84%E6%A0%91%E5%BD%A2%E8%A1%A8%E7%A4%BA.png" alt="树的树形表示"></p><ul><li>考虑结点 K 。根 A 到结点 K 的唯一路径上的任意结点，称为结点 K 的<font color="#ea66a6">祖先</font>。如结点 B 是结点 K 的祖先，而结点 K 是结点 B 的<font color="#ea66a6">子孙</font>。路径上最接近结点 K 的结点 E 称为 K 的<font color="#ea66a6">双亲</font>，而 K 为结点 E 的<font color="#ea66a6">孩子</font>。根 A 是树中唯一没有双亲的结点。有相同双亲的结点称为<font color="#ea66a6">兄弟</font>，如结点 K 和结点 L 有相同的双亲 E，即 K 和 L 为兄弟。</li><li>树中一个结点的孩子个数称为该<font color="#ea66a6">结点的度</font>，树中结点的最大度数称为树的度。如结点 B 的度为 2，结点 D 的度为 3，树的度为 3。</li><li>度大于 0 的结点称为<font color="#ea66a6">分支结点</font>（又称非终端结点）；度为 0 （没有子女结点）的结点称为<font color="#ea66a6">叶子结点</font>（又称终端结点）。在分支结点中，每个结点的分支数就是该结点的度。</li><li><font color="#ea66a6">结点的层次</font>从树根开始定义，根结点为第 1 层，它的子结点为第 2 层，以此类推。双亲在同一层的结点互为<font color="#ea66a6">堂兄弟</font>，图中结点 G 与 E，F，H，I，J 互为堂兄弟。</li><li><font color="#ea66a6">结点的深度</font>是从根结点开始自顶向下逐层累加的。</li><li><font color="#ea66a6">结点的高度</font>是从叶结点开始自底向上逐层累加的。</li><li><font color="#ea66a6">树的高度</font>（或深度）是树中结点的最大层数。图中树的高度为4。</li><li>有序树和无序树。树中结点的各子树从左到右是有次序的，不能互换，称该树为<font color="#ea66a6">有序树</font>，否则称为<font color="#ea66a6">无序树</font>。假设图为有序树，若将子结点位置互换，则变成一棵不同的树。</li><li>路径和路径长度。树中两个结点之间的<font color="#ea66a6">路径</font>是由这两个结点之间所经过的结点序列构成的，而<font color="#ea66a6">路径长度</font>是路径上所经过的边的个数。注意：由于树中的分支是有向的，即从双亲指向孩子，所以树中的路径是从上向下的，同一双亲的两个孩子之间不存在路径。</li><li><font color="#ea66a6">森林</font>是 $m\ (m \ge 0)$ 棵互不相交的树的集合。森林的概念与树的概念十分相近，因为只要把树的根结点删去就成了森林。反之，只要给 $m$ 棵独立的树加上一个结点，并把这 $m$ 棵树作为该结点的子树，则森林就变成了树。</li></ul><p>度为 $m$ 的树与 $m$ 叉树：前者表示树中各节点最少存在一个最大为 $m$ 度的结点，而 $m$ 叉树表示每个结点最多只能有 $m$ 个孩子的树</p><h3 id="树的性质"><a class="header-anchor" href="#树的性质"></a>树的性质</h3><p>树具有如下最基本的性质：</p><ol><li><p>树中的结点数等于所有结点的度数加 1 。</p></li><li><p>度为 $m$ 的树中第 $i$ 层上至多有 $m^{i-1}$ 个结点 $(i\ge 1)$。</p></li><li><p>高度为 $h$ 的 $m$ 叉树至多有 $\frac{m^h-1}{m-1} $ 个结点。</p></li><li><p>具有 $n$ 个结点的 $m$ 叉树的最小高度为 $\left \lceil \log_{m}{(n(m-1)+1) } \right \rceil $。<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p></li></ol><h2 id="二叉树的概念"><a class="header-anchor" href="#二叉树的概念"></a>二叉树的概念</h2><h3 id="二叉树的定义及其主要特性"><a class="header-anchor" href="#二叉树的定义及其主要特性"></a>二叉树的定义及其主要特性</h3><h4 id="二叉树的定义"><a class="header-anchor" href="#二叉树的定义"></a>二叉树的定义</h4><p>二叉树是另一种树形结构，其特点是每个结点至多只有两棵子树（即二叉树中不存在度大于 2 的结点），并且二叉树的子树有左右之分，其次序不能任意颠倒。</p><p>与树相似，二叉树也以递归的形式定义。二叉树是 $n\ (n\ge 0)$个结点的有限集合：</p><ol><li>或者为空二叉树，即 $n=0$ 。</li><li>或者由一个根结点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树又分别是一棵二叉树。</li></ol><p>二叉树是有序树，若将其左、右子树颠倒，则成为另一棵不同的二叉树。即使树中结点只有一颗子树，也要区分它是左子树还是右子树。</p><p>二叉树与度为 2 的有序树的区别：</p><ol><li>度为 2 的树至少有 3 个结点，而二叉树可以为空。</li><li>度为 2 的有序树的孩子的左右次序是相对于另一孩子而言的，若某个结点只有一个孩子，则这个孩子就无须区分其左右次序，而二叉树无论其孩子数是否为 2，均需确定其左右次序，即二叉树的结点次序不是相对于另一结点而言，而是确定的。</li></ol><h4 id="几个特殊的二叉树"><a class="header-anchor" href="#几个特殊的二叉树"></a>几个特殊的二叉树</h4><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E5%87%A0%E4%B8%AA%E7%89%B9%E6%AE%8A%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="几个特殊的二叉树"></p><p><strong>满二叉树</strong>。一棵高度为 $h$，且含有 $2^h-1$ 个结点的二叉树称为满二叉树，即树中的每层都含有最多的结点。满二叉树的叶子结点都集中在二叉树的最下一层，并且除叶子结点之外的每个结点度数均为 2 （不存在度为 1 的结点）。可以对满二叉树按层序编号：约定编号从根结点（根结点编号为 1 ）起，自上而下，自左向右。这样，每个结点对应一个编号，对于编号为 $i$ 的结点，若有双亲，则其双亲为 $\left \lfloor \frac{i}{2} \right \rfloor$，若有左孩子，则左孩子为 $2i$ ；若有右孩子，则右孩子为 $2i+1$。</p><p><strong>完全二叉树</strong>。高度为 $h$、有 $n$ 个结点的二叉树，当且仅当其每个结点都与高度为 $h$ 的满二叉树中编号为 $1\sim n$ 的结点一一对应时，称为完全二叉树。就是对应相同高度的满二叉树缺失最下层最右边的一些连续叶子结点。其特点如下：</p><ol><li>若 $ i \le \left \lfloor \frac{n}{2} \right \rfloor$，则结点 $i$ 为分支结点，否则为叶子结点。</li><li>叶子结点只可能在层次最大的两层上出现。对于最大层次中的叶子结点，都依次排列在该层最左边的位置上。</li><li>若有度为 1 的结点，则只可能有一个，且该结点只有左孩子而无右孩子（重要特征）。</li><li>按层序编号后，一旦出现某结点（编号为 $i$ ）为叶子结点或只有左孩子，则编号大于 $i$ 的结点均为叶子结点。</li><li>若 $n$ 为奇数，则每个分支结点都有左孩子和右孩子；若 $n$ 为偶数，则编号最大的分支结点（编号为 $\frac{n}{2}$ ）只有左孩子，没有右孩子，其余分支结点左、右孩子都有。</li></ol><p><strong>二叉排序树</strong>。一棵二叉树或者是空二叉树，或者是具有如下性质的二叉树：</p><ul><li>左子树上所有结点的关键字均小于根结点的关键字；</li><li>右子树上的所有结点的关键字均大于根结点的关键字；</li><li>左子树和右子树又各是一棵二叉排序树。</li></ul><p><strong>平衡二叉树</strong>。树上任一结点的左子树和右子树的深度之差不超过 1 。</p><h4 id="二叉树的性质"><a class="header-anchor" href="#二叉树的性质"></a>二叉树的性质</h4><p>（1）<font color="#FF666">非空二叉树上的叶子结点数等于度为 2 的结点数加 1</font>，即 $n_{0}=n_{2}+1$ 。</p><p>证明：设度为 0，1 和 2 的结点个数分别为 $n_{0}$，$n_{1}$ 和 $n_{2}$，结点总数 $n=n_{0}+n_{1}+n_{2}$。再看二叉树中的分支树，除根结点外，其余结点都有一个分支进入，设 $B$ 为分支总数，则 $n=B+1$ 。由于这些分支是由度为 1 或 2 的结点射出的，所以又有 $B=n_{1}+2n_{2}$。于是得 $n_{0}+n_{1}+n_{2}=n_{1}+2n_{2}+1$ ，则 $n_{0}=n_{2}+1$。</p><p>拓展到任意一棵树，若结点数量为 $n$，则边的数量为 $n-1$。</p><p>（2）非空二叉树上第 $k$ 层上至多有 $2^{k-1}$ 个结点 （ $k \ge 1$ ），可扩至 m 叉树</p><p>（3）高度为 $h$ 的二叉树至多有 $2^h-1$ 个结点（ $h \ge 1$ ）。高度为 $h$ 的 $m$ 叉树至多有 $\frac{m^h-1}{m-1} $ 个结点，推出。</p><p>（4）具有 $n$ 个（$n&gt;0$）结点的完全二叉树的高度 $h$ 为 $\left \lceil \log_{2}{(n+1)} \right \rceil $ 或 $\left \lfloor \log_{2}{n} \right \rfloor +1$</p><p>证明：高度为 $h$ 的满二叉树共有 $2^h-1$ 个结点，高度为 $h-1$ 的满二叉树共有 $2^{h-1}-1$ 个结点，可得：$$2^{h-1}-1&lt;n\le 2^{h}-1$$ $$2^{h-1}&lt;n+1\le 2^{h}$$ $$h-1&lt;\log{2}{(n+1)} \le h$$ $$h=\left \lceil \log_{2}{(n+1)} \right \rceil $$</p><p>高度为 $h-1$ 的满二叉树共有 $2^{h-1}-1$ 个结点，高为 $h$ 的完全二叉树至少有 $2^{h-1}$ 个结点，至多有 $2^{h}-1$ 个结点，可得：$$2^{h-1} \le n &lt; 2^{h}$$ $$h-1 \le \log{2}{n} &lt; h$$ $$h= \left \lfloor \log_{2}{n} \right \rfloor +1$$</p><p>（5）对于完全二叉树，可以由的结点数 $n$ 推出度为 0、1 和 2 的结点个数为 $n_0$、$n_1$和 $n_2$。</p><ul><li>完全二叉树最多只有一个度为 1 1 的结点，即：$n_{1}=0或1$ ；</li><li>$n_{0}=n_{2}+1$，两边各加上 $n_2$ 可得： $n_0+n_2=2n_2+1$ 可推出 $n_0+n_2$ 一定为奇数；</li></ul><p>根据上两个推论得：</p><ul><li>若完全二叉树有 $2k$ （偶数）个结点，则必有 $n_1=1,\ n_0=k , \ n_2=k-1$</li><li>若完全二叉树有 $2k-1$ （奇数）个结点，则必有 $n_1=0,\ n_0=k , \ n_2=k-1$</li></ul><h3 id="二叉树的存储结构"><a class="header-anchor" href="#二叉树的存储结构"></a>二叉树的存储结构</h3><h4 id="顺序存储结构"><a class="header-anchor" href="#顺序存储结构"></a>顺序存储结构</h4><p>二叉树的顺序存储是指用一组地址连续的存储单元依次<wavy>自上而下</wavy>、<wavy>自左至右</wavy>存储完全二叉树上的结点元素，即将完全二叉树上编号为 $i$ 的结点元素存储在一维数组下标为 $i-1$ 的分量中。（这种存储结构建议从数组下标 1 开始存储树中的结点）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">bool</span> isEmpty;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TreeNode t[MaxSize];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MaxSize; i++) &#123;</span><br><span class="line">        t[i].isEmpty = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依据二叉树的性质，完全二叉树和满二叉树采用顺序存储比较合适，树中结点的序号可以唯一地反映结点之间的逻辑关系，这样既能最大可能地节省存储空间，又能利用数组元素的下标值确定结点在二叉树中的位置，以及结点之间的关系。</p><p>但对于一般的二叉树，为了让数组下标能反映二叉树中结点之间的逻辑关系，只能添加一些并不存在的空结点，让其每个结点与完全二叉树上的结点相对照，再存储到一维数组的相应分量中。然而，在最坏情况下，一个高度为 $h$ 且只有 $h$ 个结点的单支树却需要占据近 $2^h-1$ 个存储单元。</p><h4 id="链式存储结构"><a class="header-anchor" href="#链式存储结构"></a>链式存储结构</h4><p>由于顺序存储的空间利用率较低，因此二叉树一般都采用链式存储结构，用链表结点来存储二叉树中的每个结点。在二叉树中，结点结构通常包括若干数据域和若干指针域，二叉链表至少包含3个域：数据域 <code>data</code>、左指针域 <code>lchild</code> 和右指针域 <code>rchild</code>。$n$ 个节点的二叉链表共有 $n+1$ 个空链域。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span>  <span class="comment">// 左右孩子指针</span></span><br><span class="line">    <span class="comment">// struct BiTNode *parent;  // 根据实际需求决定是否加父指针</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一棵空树</span></span><br><span class="line">    BiTree root = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入根节点</span></span><br><span class="line">    root = (BiTree)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(BiTNode));</span><br><span class="line">    root-&gt;data = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">    root-&gt;lchild = <span class="literal">nullptr</span>;</span><br><span class="line">    root-&gt;rchild = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入新结点</span></span><br><span class="line">    BiTNode *p = (BiTNode *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(BiTNode));</span><br><span class="line">    p-&gt;data = &#123;<span class="number">2</span>&#125;;</span><br><span class="line">    p-&gt;lchild = <span class="literal">nullptr</span>;</span><br><span class="line">    p-&gt;rchild = <span class="literal">nullptr</span>;</span><br><span class="line">    root-&gt;lchild = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到指定结点的左右孩子结点十分容易，但如果要寻找父节点只能从根结点开始遍历寻找。可以在结构体中额外定义父节点指针（三叉链表）。</p><h2 id="二叉树的遍历和线索二叉树"><a class="header-anchor" href="#二叉树的遍历和线索二叉树"></a>二叉树的遍历和线索二叉树</h2><h3 id="二叉树的遍历"><a class="header-anchor" href="#二叉树的遍历"></a>二叉树的遍历</h3><p>二叉树的遍历是指按某条搜索路径访问树中每个结点，使得每个结点均被访问一次，而且仅被访问一次。由于二叉树是一种非线性结构，每个结点都可能有两棵子树，因而需要寻找一种规律，以便使二叉树上的结点能排列在一个线性队列上，进而便于遍历。</p><p>由二叉树的递归定义可知，遍历一棵二叉树便要决定对根结点 N、左子树 L​ 和右子树 R 的访问顺序。按照先遍历左子树再遍历右子树的原则，常见的遍历次序有先序（NLR）、中序（LNR）和后序（LRN）三种遍历算法，其中“序”指的是根结点在何时被访问。</p><h4 id="先序遍历"><a class="header-anchor" href="#先序遍历"></a>先序遍历</h4><p>先序遍历（ PreOrder ）的操作过程如下：</p><p>若二叉树为空，则什么也不做；否则，</p><ol><li>访问根结点；</li><li>先序遍历左子树；</li><li>先序遍历右子树。</li></ol><p>对应的递归算法如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">visit</span>(T);             <span class="comment">// 访问根节点</span></span><br><span class="line">        <span class="built_in">PreOrder</span>(T-&gt;lchild);  <span class="comment">// 递归遍历左子树</span></span><br><span class="line">        <span class="built_in">PreOrder</span>(T-&gt;rchild);  <span class="comment">// 递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中序遍历"><a class="header-anchor" href="#中序遍历"></a>中序遍历</h4><p>中序遍历（ InOrder ）的操作过程如下：</p><p>若二叉树为空，则什么也不做；否则，</p><ul><li>中序遍历左子树；</li><li>访问根结点；</li><li>中序遍历右子树。</li></ul><p>对应的递归算法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">InOrder</span>(T-&gt;lchild);  <span class="comment">// 递归遍历左子树</span></span><br><span class="line">        <span class="built_in">visit</span>(T);            <span class="comment">// 访问根节点</span></span><br><span class="line">        <span class="built_in">InOrder</span>(T-&gt;rchild);  <span class="comment">// 递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后序遍历"><a class="header-anchor" href="#后序遍历"></a>后序遍历</h4><p>后序遍历（ PostOrder ）的操作过程如下：</p><p>若二叉树为空，则什么也不做；否则，</p><ol><li>后序遍历左子树；</li><li>后序遍历右子树；</li><li>访问根结点。</li></ol><p>对应的递归算法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">PostOrder</span>(T-&gt;lchild);  <span class="comment">// 递归遍历左子树</span></span><br><span class="line">        <span class="built_in">PostOrder</span>(T-&gt;rchild);  <span class="comment">// 递归遍历右子树</span></span><br><span class="line">        <span class="built_in">visit</span>(T);              <span class="comment">// 访问根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三种遍历算法中，递归遍历左、右子树的顺序都是固定的，只是访问根结点的顺序不同。不管采用哪种遍历算法，每个结点都访问一次且仅访问一次，故时间复杂度都是 $O(n)$ 。在递归遍历中，递归工作栈的栈深恰好为树的深度，所以在最坏情况下，二叉树是有 $n$ 个结点且深度为 $n$ 的单支树，遍历算法的空间复杂度为 $O(n)$。</p><p>TODO 递归算法和非递归算法的转换</p><h4 id="层次遍历"><a class="header-anchor" href="#层次遍历"></a>层次遍历</h4><p>要进行层次遍历，需要借助一个队列。先将二叉树根结点入队，然后出队，访问出队结点，若它有左子树，则将左子树根结点入队；若它有右子树，则将右子树根结点入队。然后出队，访问出队结点…如此反复，直至队列为空。</p><p>二叉树的层次遍历算法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    LinkQueue Q;</span><br><span class="line">    <span class="built_in">InirQueue</span>(Q);  <span class="comment">// 初始化辅助队列</span></span><br><span class="line">    BiTree p;</span><br><span class="line">    <span class="built_in">EnQueue</span>(Q, T);  <span class="comment">// 将根结点入队</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isEmpty</span>(Q)) &#123;</span><br><span class="line">        <span class="built_in">DeQueue</span>(Q, p);  <span class="comment">// 对头结点出队</span></span><br><span class="line">        <span class="built_in">visit</span>(p);       <span class="comment">// 访问出队结点</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lchild != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">EnQueue</span>(Q, p-&gt;lchild);  <span class="comment">// 左孩子入队,入队指针</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;rchild != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">EnQueue</span>(Q, p-&gt;rchild);  <span class="comment">// 右孩子入队</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="由遍历序列构造二又树"><a class="header-anchor" href="#由遍历序列构造二又树"></a>由遍历序列构造二又树</h4><p>若只给出一棵二叉树的前/中/后/层序遍历序列中的一种，不能唯一确定一棵二叉树。必须有中序遍历和其他任意一种遍历序列才能确定唯一一种二叉树。</p><p>先序序列和中序序列：在先序遍历序列中，第一个结点一定是二叉树的根结点；而在中序遍历中，根结点必然将中序序列分割成两个子序列，前一个子序列是根结点的左子树的中序序列，后一个子序列是根结点的右子树的中序序列。根据这两个子序列，在先序序列中找到对应的左子序列和右子序列。在先序序列中，左子序列的第一个结点是左子树的根结点，右子序列的第一个结点是右子树的根结点。如此递归地进行下去，便能唯一地确定这棵二叉树。</p><p>类似，由二叉树的后序序列和中序序列，层序序列和中序序列也可以唯一地确定一棵二叉树。找到树的根节点，并根据<br>中序序列划分左右子树，再找至左右子树根节点。</p><h3 id="线索二叉树"><a class="header-anchor" href="#线索二叉树"></a>线索二叉树</h3><h4 id="线索二叉树的基本概念"><a class="header-anchor" href="#线索二叉树的基本概念"></a>线索二叉树的基本概念</h4><p>遍历二叉树是以一定的规则将二叉树中的结点排列成一个线性序列，从而得到几种遍历序列，使得该序列中的每个结点（第一个和最后一个结点除外）都有一个直接前驱和直接后继。</p><p>传统的二叉链表存储仅能体现一种父子关系，不能直接得到结点在遍历中的前驱或后继。前面提到，在含 $n$ 个结点的二叉树中，有 $n+1$ 个空指针。这是因为每个叶结点有 2 个空指针，每个度为 1 的结点有 1 个空指针，空指针总数为 $2n_{0} + n_1$ ，又 $n_{0}=n_{2}+ 1$，所以空指针总数为 $n_0+n_1+n_2+1=n+1$ 。由此设想能否利用这些空指针来存放指向其前驱或后继的指针？这样就可以像遍历单链表那样方便地遍历二叉树。引入线索二叉树正是为了加快查找结点前驱和后继的速度。</p><p>规定：若无左子树，令 <code>lchild</code> 指向其前驱结点；若无右子树，令 <code>rchild</code> 指向其后继结点。还需增加两个标志域（<code>ltag</code>、<code>rtag</code>）标识指针域是指向左（右）孩子还是指向前驱（后继）。当 tag 值等于 0 时，表示指针指向孩子，等于 1 时，表示指针指向线索。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E4%B8%AD%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="中序线索二叉树"></p><p>线索二叉树的存储结构描述如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ltag, rtag;  <span class="comment">// 左右线索标志，0指向孩子，1指向线索</span></span><br><span class="line">&#125; ThreadNode, *ThreadTree;</span><br></pre></td></tr></table></figure><p>以这种结点结构构成的二叉链表作为二叉树的存储结构，称为<font color="#ea66a6">线索链表</font>，其中指向结点前驱和后继的指针称为<font color="#ea66a6">线索</font>。加上线索的二叉树称为<font color="#ea66a6">线索二叉树</font>。</p><h4 id="中序线索二叉树的构造"><a class="header-anchor" href="#中序线索二叉树的构造"></a>中序线索二叉树的构造</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局遍历 pre 指向当前访问结点的前驱</span></span><br><span class="line">ThreadNode *pre = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历二叉树并进行线索化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThread</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">InThread</span>(T-&gt;lchild);  <span class="comment">// 中序遍历左子树</span></span><br><span class="line">        <span class="built_in">visit</span>(T);             <span class="comment">// 访问根节点并线索化</span></span><br><span class="line">        <span class="built_in">InThread</span>(T-&gt;rchild);  <span class="comment">// 中序遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(ThreadNode *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;lchild == <span class="literal">nullptr</span>) &#123;  <span class="comment">// 左子树为空，建立前驱线索</span></span><br><span class="line">        q-&gt;lchild = pre;</span><br><span class="line">        q-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pre != <span class="literal">nullptr</span> &amp;&amp; pre-&gt;rchild == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        pre-&gt;rchild = q;  <span class="comment">// 建立前驱结点的后继线索</span></span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = q;  <span class="comment">// 将 pre 指针指向当前结点（即下一个访问结点的前驱结点）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序线索化二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateInThread</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">InThread</span>(T);  <span class="comment">// 中序线索化除最后一个结点的其他结点</span></span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;rchild == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;  <span class="comment">// 注意：处理最后一个结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="先序线索二叉树的构造"><a class="header-anchor" href="#先序线索二叉树的构造"></a>先序线索二叉树的构造</h4><blockquote><p>当 <code>ltag == 0</code> 时，才能对左子树先序线索化</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局遍历 pre 指向当前访问结点的前驱</span></span><br><span class="line">ThreadNode *pre = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先序遍历二叉树并进行线索化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreThread</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">visit</span>(T);                  <span class="comment">// 访问根节点并线索化</span></span><br><span class="line">        <span class="keyword">if</span> (T-&gt;ltag == <span class="number">0</span>) &#123;        <span class="comment">// 注意：需要判断lchild不是前驱线索</span></span><br><span class="line">            <span class="built_in">PreThread</span>(T-&gt;lchild);  <span class="comment">// 先序遍历左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">PreThread</span>(T-&gt;rchild);  <span class="comment">// 先序遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(ThreadNode *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;lchild == <span class="literal">nullptr</span>) &#123;  <span class="comment">// 左子树为空，建立前驱线索</span></span><br><span class="line">        q-&gt;lchild = pre;</span><br><span class="line">        q-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pre != <span class="literal">nullptr</span> &amp;&amp; pre-&gt;rchild == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        pre-&gt;rchild = q;  <span class="comment">// 建立前驱结点的后继线索</span></span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = q;  <span class="comment">// 将 pre 指针指向当前结点（即下一个访问结点的前驱结点）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先序线索化二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateInThread</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">PreThread</span>(T);  <span class="comment">// 先序线索化除最后一个结点的其他结点</span></span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;rchild == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;  <span class="comment">// 处理最后一个结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后序线索二叉树的构造"><a class="header-anchor" href="#后序线索二叉树的构造"></a>后序线索二叉树的构造</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局遍历 pre 指向当前访问结点的前驱</span></span><br><span class="line">ThreadNode *pre = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历二叉树并进行线索化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostThread</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">PostThread</span>(T-&gt;lchild);  <span class="comment">// 后序遍历左子树</span></span><br><span class="line">        <span class="built_in">PostThread</span>(T-&gt;rchild);  <span class="comment">// 后序遍历右子树</span></span><br><span class="line">        <span class="built_in">visit</span>(T);               <span class="comment">// 访问根节点并线索化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(ThreadNode *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;lchild == <span class="literal">nullptr</span>) &#123;  <span class="comment">// 左子树为空，建立前驱线索</span></span><br><span class="line">        q-&gt;lchild = pre;</span><br><span class="line">        q-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pre != <span class="literal">nullptr</span> &amp;&amp; pre-&gt;rchild == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        pre-&gt;rchild = q;  <span class="comment">// 建立前驱结点的后继线索</span></span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = q;  <span class="comment">// 将 pre 指针指向当前结点（即下一个访问结点的前驱结点）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序线索化二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateInThread</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">PostThread</span>(T);  <span class="comment">// 后序线索化除最后一个结点的其他结点</span></span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;rchild == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;  <span class="comment">// 注意：处理最后一个结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线索二叉树的遍历"><a class="header-anchor" href="#线索二叉树的遍历"></a>线索二叉树的遍历</h4><p>在中序线索二叉树中找到指定结点 <code>*p</code> 的中序后继 <code>next</code>：</p><ol><li><p>若 <code>p-&gt;rtag == 1</code>，则 <code>next = p-&gt;rchild</code></p></li><li><p>若 <code>p-&gt;rtag == 0</code>，则 <code>next</code> 等于 <code>p</code> 的右子树中最左下的结点</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到以 p 为根的子树中，第一个被中序遍历的结点</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">FirstNode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 循环找到最左下结点（不一定是叶结点）</span></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;ltag == <span class="number">0</span>)&#123;</span><br><span class="line">        p = p-&gt;lchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在中序线索二叉树中找到结点 p 的后继结点</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">NextNode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 右子树中最左下结点</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;rtag == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">FirstNode</span>(p-&gt;rchild);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123; <span class="comment">// rtag==1 直接返回后继线索</span></span><br><span class="line">        <span class="keyword">return</span> p-&gt;rchild; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对中序线索二叉树进行中序遍历</span></span><br><span class="line"><span class="comment">// 利用线索实现的非递归算法 空间复杂度 O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(ThreadNode *T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ThreadNode *p = <span class="built_in">FirstNode</span>(T);p != <span class="literal">nullptr</span>;p = <span class="built_in">NextNode</span>(p))&#123;</span><br><span class="line">        <span class="built_in">visit</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在中序线索二叉树中找到指定结点 <code>*p</code> 的中序前驱 <code>pre</code>：</p><ol><li>若 <code>p-&gt;ltag == 1</code>，则 <code>pre = p-&gt;lchild</code></li><li>若 <code>p-&gt;ltag == 0</code>，则 <code>pre</code> 等于 <code>p</code> 的左子树中最右下的结点</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到以 p 为根的子树中，最后一个被中序遍历的结点</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">LastNode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 循环找到最右下结点(不一定是叶结点)</span></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;rtag == <span class="number">0</span>)&#123;</span><br><span class="line">        p = p-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在中序线索二叉树中找到结点 p 的前驱结点</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">PreNode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 左子树中最右下结点</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ltag == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">LastNode</span>(p-&gt;lchild);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123; <span class="comment">// ltag==1 直接返回前驱线索</span></span><br><span class="line">        <span class="keyword">return</span> p-&gt;lchild; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对中序线索二叉树进行逆向中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RevInOrder</span><span class="params">(ThreadNode *T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ThreadNode *p = <span class="built_in">LastNode</span>(T);p != <span class="literal">nullptr</span>;p = <span class="built_in">PreNode</span>(p))&#123;</span><br><span class="line">        <span class="built_in">visit</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>先序线索二叉树找指定结点 <code>*p</code> 的先序后继 <code>next</code></p><ol><li>若 <code>p-&gt;rtag == 1</code>，则 <code>next = p-&gt;rchild</code>；</li><li>若 <code>p-&gt;rtag == 0</code>，则 <code>p</code> 必有右孩子，分成两种情况考虑：<ul><li>若 <code>p</code> 有左孩子则先序后继为左孩子；</li><li>若没有左孩子则先序后继为右孩子</li></ul></li></ol><p>TODO 代码实现先序线索二叉树的后继遍历</p><p>在先序线索二叉树中找到指定结点 <code>*p</code> 的先序前驱 <code>pre</code></p><ol><li>若 <code>p-&gt;ltag == 1</code>，则 <code>next = p-&gt; lchild</code>；</li><li>若 <code>p-&gt;ltag == 0</code>，则 <code>p</code> 必有左孩子。二叉链表在先序遍历中，左右子树中的结点只可能是根的后继，不可能是前驱，故找不到先序前驱。三叉链表在先序遍历中，如果能找到 <code>p</code> 的父节点：<ul><li><code>p</code> 为左孩子，<code>p</code> 的父节点即为其前驱结点；</li><li><code>p</code> 是右孩子，其左兄弟为空，<code>p</code> 的父节点即为其前驱结点；</li><li><code>p</code> 是右孩子，其左兄弟非空，<code>p</code> 的前驱为左兄弟子树中最后一个被先序遍历的结点；</li><li>如果 <code>p</code> 是根结点，则 <code>p</code> 没有先序前驱。</li></ul></li></ol><hr><p>在后序线索二叉树找到指定结点 <code>*p</code> 的后序前驱 <code>pre</code>：</p><ol><li>若 <code>p-&gt;ltag == 1</code>，则 <code>pre = p-&gt;lchild</code></li><li>若 <code>p-&gt;ltag == 0</code>，则 <code>p</code> 必有左孩子，若 <code>p</code> 有右孩子，则后序前驱为右孩子；若 <code>p</code> 没有右孩子，则后序前驱为左孩子</li></ol><p>TODO 后序前驱遍历代码实现</p><p>在后序线索二叉树中找到指定结点 <code>*p</code> 的后序后继 <code>next</code>：</p><ol><li>若 <code>p-&gt;rtag == 1</code>，则 <code>next = p-&gt;rchild</code></li><li>若 <code>p-&gt;rtag == 0</code>，则 <code>p</code> 必有右孩子。二叉链表在后序遍历中，左右子树中的结点只可能是根的前驱，不可能是后继。三叉链表在后序遍历中，如果能找到 <code>p</code> 的父节点：<ul><li><code>p</code> 是右孩子，<code>p</code> 的父节点即为其后继结点；</li><li><code>p</code> 是左孩子，其右兄弟为空，<code>p</code> 的父节点即为其后继结点；</li><li><code>p</code> 是左孩子，其右兄弟非空，<code>p</code> 的后继为右兄弟子树中第一个被后序遍历的结点；</li><li>如果 <code>p</code> 是根节点，则 <code>p</code> 没有后继结点</li></ul></li></ol><h2 id="树、森林"><a class="header-anchor" href="#树、森林"></a>树、森林</h2><h3 id="树的存储结构"><a class="header-anchor" href="#树的存储结构"></a>树的存储结构</h3><p>树的存储方式有多种，既可采用顺序存储结构，又可采用链式存储结构，但无论采用何种存储方式，都要求能唯一地反映树中各结点之间的逻辑关系，这里介绍 3 种常用的存储结构。</p><h4 id="双亲表示法（顺序存储）"><a class="header-anchor" href="#双亲表示法（顺序存储）"></a>双亲表示法（顺序存储）</h4><p>这种存储方式采用一组连续空间来存储每个结点，同时在每个结点中增设一个伪指针，指示其<wavy>双亲结点</wavy>在数组中的位置。根结点下标为 0，其伪指针域为 -1。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E6%A0%91%E7%9A%84%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95.png" alt="树的双亲表示法"></p><p>双亲表示法的存储结构描述如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;     <span class="comment">// 数据元素</span></span><br><span class="line">    <span class="keyword">int</span> partent;  <span class="comment">// 双亲位置域</span></span><br><span class="line">&#125; PTNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PTNode nodoes[MAX_TREE_SIZE];  <span class="comment">// 双亲表示</span></span><br><span class="line">    <span class="keyword">int</span> n;                         <span class="comment">// 结点数</span></span><br><span class="line">&#125; PTree；</span><br></pre></td></tr></table></figure><h4 id="孩子表示法（顺序-链式存储）"><a class="header-anchor" href="#孩子表示法（顺序-链式存储）"></a>孩子表示法（顺序+链式存储）</h4><p>孩子表示法是将每个结点的孩子结点都用单链表链接起来形成一个线性结构，此时 $n$ 个结点就有 $n$ 个孩子链表（叶子结点的孩子链表为空表）。这种存储方式寻找子女的操作非常直接，而寻找双亲的操作需要遍历 $n$ 个结点中孩子链表指针域所指向的 $n$ 个孩子链表。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> child;            <span class="comment">// 孩子结点在数组中的位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span>  <span class="comment">// 下一个孩子</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">firstChild</span>;</span>  <span class="comment">// 第一个孩子</span></span><br><span class="line">&#125; CTBox;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    CTBox nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="keyword">int</span> n, r;  <span class="comment">// 结点数和根的位置</span></span><br><span class="line">&#125; CTree;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E5%AD%A9%E5%AD%90%E5%92%8C%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95.png" alt="孩子和孩子兄弟表示法"></p><h4 id="孩子兄弟表示法（链式存储）"><a class="header-anchor" href="#孩子兄弟表示法（链式存储）"></a>孩子兄弟表示法（链式存储）</h4><p>孩子兄弟表示法又称二叉树表示法，即以二叉链表作为树的存储结构。孩子兄弟表示法使每个结点包括三部分内容：结点值、指向结点第一个孩子结点的指针，及指向结点下一个兄弟结点的指针（沿此域可以找到结点的所有兄弟结点）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>, *<span class="title">nextsibling</span>;</span>  <span class="comment">// 第一个孩子和右兄弟指针</span></span><br><span class="line">&#125; CSNode, *CSTree;</span><br></pre></td></tr></table></figure><p>这种存储表示法比较灵活，其最大的优点是可以方便地实现树转换为二叉树的操作，易于查找结点的孩子等，但缺点是从当前结点查找其双亲结点比较麻烦。若为每个结点增设一个 <code>parent</code> 域指向其父结点，则查找结点的父结点也很方便。</p><h3 id="树、森林与二叉树的转换"><a class="header-anchor" href="#树、森林与二叉树的转换"></a>树、森林与二叉树的转换</h3><p>由于二叉树和树都可以用二叉链表作为存储结构，因此以二叉链表作为媒介可以导出树与二叉树的一个对应关系，即给定一棵树， 可以找到唯一的一棵二叉树与之对应。从物理结构上看，它们的二叉链表是相同的，只是解释不同而已。</p><p>树转换为二叉树的规则：每个结点左指针指向它的第一个孩子，右指针指向它在树中的相邻右兄弟，这个规则又称“左孩子右兄弟”。由于根结点没有兄弟，所以对应的二叉树没有右子树。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB.png" alt="树与二叉树的对应关系"></p><p>树转换成二叉树的画法：</p><ol><li>在兄弟结点之间加一连线；</li><li>对每个结点，只保留它与第一个孩子的连线，而与其他孩子的连线全部抹掉；</li><li>以树根为轴心，顺时针旋转45°。</li></ol><p>将森林转换为二叉树的规则与树类似。先将森林中的每棵树转换为二叉树，由于任何一棵和树对应的二叉树的右子树必空，若把森林中第二棵树根视为第一棵树根的右兄弟，即将第二棵树对应的二叉树当作第一棵二叉树根的右子树，将第三棵树对应的二叉树当作第二棵二叉树根的右子…以此类推，就可以将森林转换为二叉树。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E6%A3%AE%E6%9E%97%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB.png" alt="森林与二叉树的对应关系"></p><p>森林转换成二叉树的画法：</p><ol><li>将森林中的每棵树转换成相应的二叉树</li><li>每棵树的根也可视为兄弟关系，在每棵树的根之间加一根连线；</li><li>以第一棵树的根为轴心顺时针旋转45°。</li></ol><p>二叉树转换为森林的规则：若二叉树非空，则二叉树的根及其左子树为第一棵树的二叉树形式，故将根的右链断开。二叉树根的右子树又可视为一个由除第一棵树 外的森林转换后的二叉树，应用同样的方法，直到最后只剩一棵没有右子树的二叉树为止，最后再将每棵二叉树依次转换成树，就得到了原森林。二叉树转换为树或森林是唯一的。</p><h3 id="树和森林的遍历"><a class="header-anchor" href="#树和森林的遍历"></a>树和森林的遍历</h3><p>树的遍历是指用某种方式访问树中的每个结点，且仅访问一次。主要有两种方式（深度优先遍历）：</p><ol><li>先根遍历。若树非空，先访问根结点，再依次遍历根结点的每棵子树，遍历子树时仍遵循先根后子树的规则。其遍历序列与这棵树相应二叉树的先序序列相同。</li><li>后根遍历。若树非空，先依次遍历根结点的每棵子树，再访问根结点，遍历子树时仍遵循先子树后根的规则。其遍历序列与这棵树相应二叉树的中序序列相同。</li></ol><p>另外，树也有层次遍历（广度优先遍历），与二叉树的层次遍历思想基本相同，即按层序依次访问各结点。</p><p>按照森林和树相互递归的定义，可得到森林的两种遍历方法。</p><ol><li>先序遍历森林。若森林为非空，则按如下规则进行遍历（效果等同于依次对各个树进行先根遍历）：<ul><li>访问森林中第一棵树的根结点。</li><li>先序遍历第一棵树中根结点的子树森林。</li><li>先序遍历除去第一棵树之后剩余的树构成的森林。</li></ul></li><li>中序遍历森林。森林为非空时，按如下规则进行遍历（效果等同于依次对各个树进行后根遍历）：<ul><li>中序遍历森林中第一棵树的根结点的子树森林。</li><li>访问第一棵树的根结点。</li><li>中序遍历除去第一棵树之后剩余的树构成的森林。</li></ul></li></ol><h2 id="树与二叉树的应用"><a class="header-anchor" href="#树与二叉树的应用"></a>树与二叉树的应用</h2><h3 id="二叉排序树（BST）"><a class="header-anchor" href="#二叉排序树（BST）"></a>二叉排序树（BST）</h3><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>推导过程：$$\frac{m^{h-1}-1}{m-1}&lt;n\le \frac{m^h-1}{m-1}$$ $$m^{h-1}&lt;n(m-1)+1\le m^h $$ $$ h-1 &lt; \log_{m}{(n(m-1)+1)} \le h $$ $$h_{min}= \left \lceil \log_{m}{(n(m-1)+1) } \right \rceil $$ <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section></article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">树的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.</span> <span class="toc-text">树的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD"><span class="toc-number">1.2.</span> <span class="toc-text">基本术语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">1.3.</span> <span class="toc-text">树的性质</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">2.</span> <span class="toc-text">二叉树的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E5%85%B6%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7"><span class="toc-number">2.1.</span> <span class="toc-text">二叉树的定义及其主要特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.1.</span> <span class="toc-text">二叉树的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%A0%E4%B8%AA%E7%89%B9%E6%AE%8A%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.1.2.</span> <span class="toc-text">几个特殊的二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">2.1.3.</span> <span class="toc-text">二叉树的性质</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.</span> <span class="toc-text">二叉树的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.1.</span> <span class="toc-text">顺序存储结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.2.</span> <span class="toc-text">链式存储结构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E5%92%8C%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">3.</span> <span class="toc-text">二叉树的遍历和线索二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">3.1.</span> <span class="toc-text">二叉树的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">3.1.1.</span> <span class="toc-text">先序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">3.1.2.</span> <span class="toc-text">中序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">3.1.3.</span> <span class="toc-text">后序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="toc-number">3.1.4.</span> <span class="toc-text">层次遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%B1%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%88%E6%A0%91"><span class="toc-number">3.1.5.</span> <span class="toc-text">由遍历序列构造二又树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">3.2.</span> <span class="toc-text">线索二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">3.2.1.</span> <span class="toc-text">线索二叉树的基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0"><span class="toc-number">3.2.2.</span> <span class="toc-text">中序线索二叉树的构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0"><span class="toc-number">3.2.3.</span> <span class="toc-text">先序线索二叉树的构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0"><span class="toc-number">3.2.4.</span> <span class="toc-text">后序线索二叉树的构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">3.2.5.</span> <span class="toc-text">线索二叉树的遍历</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97"><span class="toc-number">4.</span> <span class="toc-text">树、森林</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">4.1.</span> <span class="toc-text">树的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95%EF%BC%88%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%EF%BC%89"><span class="toc-number">4.1.1.</span> <span class="toc-text">双亲表示法（顺序存储）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95%EF%BC%88%E9%A1%BA%E5%BA%8F-%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%EF%BC%89"><span class="toc-number">4.1.2.</span> <span class="toc-text">孩子表示法（顺序+链式存储）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95%EF%BC%88%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%EF%BC%89"><span class="toc-number">4.1.3.</span> <span class="toc-text">孩子兄弟表示法（链式存储）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.2.</span> <span class="toc-text">树、森林与二叉树的转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">4.3.</span> <span class="toc-text">树和森林的遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">5.</span> <span class="toc-text">树与二叉树的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%EF%BC%88BST%EF%BC%89"><span class="toc-number">5.1.</span> <span class="toc-text">二叉排序树（BST）</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By HALO</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-resources@latest/js/butterflyutils.js"></script><script src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-resources@latest/js/butterflymain.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if(window.MathJax)MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset();else{window.MathJax={loader:{source:{"[tex]/amsCd":"[tex]/amscd"}},tex:{inlineMath:[["$","$"],["\\(","\\)"]],tags:"ams"},options:{renderActions:{findScript:[10,t=>{for(const e of document.querySelectorAll('script[type^="math/tex"]')){const a=!!e.type.match(/; *mode=display/),n=new t.options.MathItem(e.textContent,t.inputJax[0],a),s=document.createTextNode("");e.parentNode.replaceChild(s,e),n.start={node:s,delim:"",n:0},n.end={node:s,delim:"",n:0},t.math.push(n)}},""],addClass:[200,()=>{document.querySelectorAll("mjx-container:not([display='true']").forEach(t=>{const e=t.parentNode;e.classList.contains("has-jax")||e.classList.add("mathjax-overflow")})},"",!1]}}};const t=document.createElement("script");t.src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js",t.id="MathJax-script",t.async=!0,document.head.appendChild(t)}</script><script>function addGitalkSource(){const e=document.createElement("link");e.rel="stylesheet",e.href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css",document.getElementsByTagName("head")[0].appendChild(e)}function loadGitalk(){function e(){new Gitalk(Object.assign({clientID:"e5a3e7481d96cd2d0a56",clientSecret:"ae9c98707484f2afb1db73120ce2f3347afb32eb",repo:"BlogResources",owner:"lanqilu",admin:["lanqilu"],id:"125a5bc5412a7793a8725dcc6ce862ec",language:"zh-CN",perPage:10,distractionFreeMode:!1,pagerDirection:"last",createIssueManually:!0,updateCountCallback:commentCount},null)).render("gitalk-container")}"function"==typeof Gitalk?e():(addGitalkSource(),getScript("https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js").then(e))}function commentCount(e){let t=document.querySelector("#post-meta .gitalk-comment-count");t&&(t.innerHTML=e)}{function loadOtherComment(){loadGitalk()}loadGitalk()}</script></div><script defer src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script defer src="/js/butterfly.js"></script><script defer src="https://cdn.jsdelivr.net/npm/hexo-theme-volantis@latest/source/js/issues.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>