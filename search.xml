<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>线性代数-行列式</title>
      <link href="2021/04/23/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E8%A1%8C%E5%88%97%E5%BC%8F/"/>
      <url>2021/04/23/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E8%A1%8C%E5%88%97%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="二阶与三阶行列式"><a class="header-anchor" href="#二阶与三阶行列式"></a>二阶与三阶行列式</h2><p>二阶行列式，记作：</p><div>$$\begin{vmatrix}  a_{1} & a_{2}\\  b_{1} & b_{2}\end{vmatrix}$$</div><p>三阶行列式，记作：</p><div>$$\begin{vmatrix}a_{1} & a_{2} & a_{3}\\b_{1} & b_{2} & b_{3}\\c_{1} & c_{2} & c_{3}\end{vmatrix}$$</div><div>$$\begin{vmatrix} a_{1} & a_{2} & a_{3}\\ b_{1} & b_{2} & b_{3}\\ c_{1} & c_{2} & c_{3}\end{vmatrix}= a_{1}b_{2}c_{3}+a_{2}b_{3}c_{1}+a_{3}b_{1}c_{2}-a_{3}b_{2}c_{1}-a_{1}b_{3}c_{2}$$</div><p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E4%B8%89%E9%98%B6%E8%A1%8C%E5%88%97%E5%BC%8F%E7%9A%84%E8%AE%A1%E7%AE%97.png" alt="三阶行列式的计算"></p><h2 id="全排列和对换"><a class="header-anchor" href="#全排列和对换"></a>全排列和对换</h2><h3 id="排列及其逆序数"><a class="header-anchor" href="#排列及其逆序数"></a>排列及其逆序数</h3><p>把$n$个不同的元素排成一列，叫做这$n$个元素的全排列（也简称<font color="#ea66a6">排列</font>）<br>$n$个不同元素的所有排列的种数，通常用$P_{n}$表示：</p><span>$$P_{n}=n\cdot(n-1)\cdot\dots\cdot3\cdot2\cdot1=n!$$</span><span>$$\left( \sum_{k=1}^n a_k b_k \right)^{\!\!2}\leq   \left( \sum_{k=1}^n a_k^2 \right) \left( \sum_{k=1}^n b_k^2 \right)  $$</span>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>物理层</title>
      <link href="2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/02_%E7%89%A9%E7%90%86%E5%B1%82/"/>
      <url>2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/02_%E7%89%A9%E7%90%86%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h2 id="物理层的基本概念"><a class="header-anchor" href="#物理层的基本概念"></a>物理层的基本概念</h2><p>物理层解决如何在连接各种计算机的传输媒体上<font color="#FF666">传输数据比特流</font>，而不是指具体的传输媒体。</p><p>物理层主要任务:确定与传输媒体<font color="#faa755">接口</font>有关的一些特性(定义标准)</p><ol><li><p>机械特性:定义物理连接的特性，规定物理连接时所采用的规格、接口形状、<font color="#faa755">引线数目</font>、<font color="#faa755">引脚数量</font>和排列情况。</p></li><li><p>电气特性:规定传输二进制位时，线路上信号的<font color="#faa755">电压范围</font>、阻抗匹配、传输<font color="#faa755">速率</font>和<font color="#faa755">距离</font>限制等。</p><blockquote><p>某网络在物理层规定，信号的电平用+10V<sub>+15V表示二进制0，用-10V</sub>-15V表示二进制1，电线长度限于15m以内</p></blockquote></li><li><p>功能特性:指明某条线上出现的某一<font color="#faa755">电平表示何种意义</font>，接口部件的信号线的用途。</p><blockquote><p>描述一个物理层接口引脚处于高电平时的含义时</p></blockquote></li><li><p>规程特性:(过程特性) 定义各条物理线路的工作<font color="#faa755">规程和时序</font>关系。</p></li></ol><h1>通信基础</h1><h2 id="1-基本概念"><a class="header-anchor" href="#1-基本概念"></a>1 基本概念</h2><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B8%E5%9E%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B.png" alt="典型的数据通信模型" style="object-fit: cover; border-radius: 10px; width: 100%;" /><p>通信的目的是<font color="#faa755">传送信息</font>。</p><p><font color="#ea66a6">数据</font>:传送信息的实体，通常是有意义的符号序列。</p><p><font color="#ea66a6">信号</font>:数据的电气或电磁的表现，是数据在传输过程中的<font color="#faa755">存在形式</font>。</p><ul><li>数字信号:代表消息的参数取值是离散的。取值仅允许为有限的几个离散数值的数据(或信号)称为数字数据(或数字信号)。</li><li>模拟信号:代表消息的参数取值是连续的。连续变化的数据(或信号)称为模拟数据(或模拟信号);</li></ul><p><font color="#ea66a6">信源</font>:产生和发送数据的源头。</p><p><font color="#ea66a6">信宿</font>:接收数据的终点。</p><p><font color="#ea66a6">信道</font>:信号的传输媒介。一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接收信道。</p><ul><li><p>信道按传输<font color="#ef5b9c">信号形式</font>的不同可分为传送模拟信号的<font color="#faa755">模拟信道</font>和传送数字信号的<font color="#faa755">数字信道</font>两大类;</p></li><li><p>信道按传输<font color="#ef5b9c">介质</font>的不同可分为<font color="#faa755">无线信道</font>和<font color="#faa755">有线信道</font>。</p></li></ul><p>从通信双方信息的交互方式看，可分为三种基本方式:</p><ol><li><font color="#ea66a6">单工通信</font>。只有一个方向的通信而没有反方向的交互，仅需要<font color="#FF666">一条</font>信道。例如，无线电广播、电视广播就属于这种类型。</li><li><font color="#ea66a6">半双工通信</font>。通信的双方都可以发送或接收信息，但任何一方都<font color="#faa755">不能同时</font>发送和接收信息，此时需要<font color="#FF666">两条</font>信道。(对讲机)</li><li><font color="#ea66a6">全双工通信</font>。通信双方可以同时发送和接收信息，也需要<font color="#FF666">两条</font>信道。</li></ol><p>数据传输方式可分为串行传输和并行传输。</p><ul><li><font color="#ea66a6">串行传输</font>是指一个一个的比特按照时间顺序传输(出于经济上的考虑，远距离通信通常采用串行传输)</li><li><font color="#ea66a6">并行传输</font>是指多个比特通过多条通信信道同时传输。</li></ul><hr><p><font color="#ea66a6">码元</font>是指用一个<font color="#FF666">固定时长</font>的<font color="#FF666">信号波形</font>(数字脉冲)表示一位k进制数字，代表不同离散数值的基本波形，是数字通信中数字信号的计量单位，这个时长内的信号称为<font color="#ea66a6">k进制码元</font>，而该时长称为<font color="#ea66a6">码元宽度</font>。1码元可以携带多个比特的信息量。例如，在使用二进制编码时，只有两种不同的码元: 一种代表0状态，另一种代表1状态。</p><p>速率也称数据率，指的是数据的<font color="#FF666">传输速率</font>，表示单位时间内传输的数据量。可以用<font color="#faa755">码元传输速率</font>和<font color="#faa755">信息传输速率</font>表示。</p><ul><li><font color="#ea66a6">码元传输速率</font>。又称码元速率、波形速率、调制速率、符号速率等，它表示单位时间内数字通信系统所传输的码元个数(也可称为<font color="#faa755">脉冲个数或信号变化的次数</font>)，单位是<font color="#FF666">波特</font>(Baud)。 1波特表示数字通信系统每秒传输一个码元。这里的码元可以是多进制的，也可以是二进制的，但码元速率与进制数无关。<font color="#FF666">1s传输多少个码元</font></li><li><font color="#ea66a6">信息传输速率</font>。又称信息速率、比特率等，它表示单位时间内数字通信系统传输的二进制码元个数(即比特数)，单位是比特/秒(b/s)。<font color="#FF666">1s传输多少个比特</font></li></ul><blockquote><p>关系:<font color="#faa755">若一个码元携带n比特的信息量，则M波特率的码元传输速率所对应的信息传输速率为M×n bit/s</font>。</p></blockquote><p><font color="#ea66a6">带宽</font>:表示在单位时间内从网络中的某一点到另一点所能通过的“<font color="#faa755">最高数据率</font>”，常用来表示网络的通信线路所能传输数据的能力。单位是b/s。</p><h2 id="font-color-d9730d-2-奈奎斯特定理与香农定理-font"><a class="header-anchor" href="#font-color-d9730d-2-奈奎斯特定理与香农定理-font"></a><font color="#d9730d">2 奈奎斯特定理与香农定理</font></h2><p>影响失真程度的影响因素:</p><ol><li>码元传输速率,速率越快失真越严重</li><li>信号传输距离,距离越远失真越严重</li><li>噪声干扰,干扰越多失真越严重</li><li>传输媒体质量,质量越差失真越严重</li></ol><p>具体的信道所能通过的频率范围总是有限的(信道带宽).信号中的许多高频分量往往不能通过信道,否则在传输中会衰减,导致接收端收到的信号波形<font color="#faa755">失去码元之间清晰界限</font>,这种现象称为<font color="#ea66a6">码间串扰</font></p><p><font color="#ea66a6">信道带宽</font>:是信道能通过的最高频率和最低频率之差.</p><h3 id="奈奎斯特定理"><a class="header-anchor" href="#奈奎斯特定理"></a>奈奎斯特定理</h3><p>奈奎斯特(Nyquist)定理又称<font color="#ea66a6">奈氏准则</font>，它指出在理想低通(没有噪声、带宽有限)的信道中，极限码元传输率为2W波特，其中<font color="#faa755">W</font>是理想低通信道的带宽，单位为<font color="#FF666">Hz</font>。若用<font color="#faa755">V</font>表示每个码元离散电平的数目(码元的离散电平数目是指有多少种不同的码元，比如有16种不同的码元，则需要4位二进制位，因此数据传输率是码元传输率的4倍)，则极限数据率为</p><p>理想低通信道下的极限数据传输率= 2W log<sub>2</sub>V (单位为b/s)</p><p>对于奈氏准则，可以得出以下结论:</p><ol><li>在任何信道中，码元传输的速率是有上限的。若传输速率超过此上限，就会出现严重的码间串扰问题(指在接收端收到的信号波形失去了码元之间的清晰界限)，使得接收端不可能完全正确识别码元。</li><li>信道的频带越宽(即通过的信号高频分量越多)，就可用更高的速率进行码元的有效传输。</li><li>奈氏准则给出了码元传输速率的限制，但并未对信息传输速率给出限制，即未对一个码元可以对应多少个二进制位给出限制。</li></ol><p>由于码元的传输速率受奈氏准则的制约，所以要提高数据的传输速率，就必须设法使每个码元携带更多个比特的信息量，此时就需要采用多元制的调制方法。</p><h3 id="香农定理"><a class="header-anchor" href="#香农定理"></a>香农定理</h3><p><font color="#ea66a6">噪声</font>存在于所有的电子设备和通信信道中。由于噪声随机产生，它的瞬时值有时会很大，因此噪声会使接收端对码元的判决产生错误。但是噪声的影响是相对的，若信号较强，那么噪声影响相对较小。因此，<font color="#ea66a6">信噪比</font>就很重要。</p><p>香农(Shannon)定理给出了带宽受限且有高斯白噪声干扰的信道的极限数据传输率，当用此速率进行传输时，可以做到不产生误差。香农定理定义为</p><p><font color="#faa755">信道的极限数据传输率 = Wlog<sub>2</sub>(1+S/N) (单位为b/s)</font></p><p>式中，W为信道的带宽，S为信道所传输信号的平均功率，N为信道内部的高斯噪声功率。S/N为信噪比，即信号的平均功率与噪声的平均功率之比，<font color="#FF666">信噪比 = 10log<sub>10</sub>(S/N) (单位为dB)</font>，例如如当S/N= 10时，信噪比为10dB，而当S/N= 1000时，信噪比为30dB。</p><p>对于香农定理，可以得出以下结论:</p><ol><li>信道的带宽或信道中的信噪比越大，信息的极限传输速率越高。</li><li>对一定的传输带宽和一定的信噪比，信息传输速率的上限是确定的。</li><li>只要信息的传输速率低于信道的极限传输速率，就能找到某种方法来实现无差错的传输。</li><li>香农定理得出的是极限信息传输速率，实际信道能达到的传输速率要比它低不少。</li></ol><p>从香农定理可以看出，若信道带宽W或信噪比SIN没有上限(实际信道当然不可能这样)，则信道的极限信息传输速率也没有上限。</p><p>奈氏准则只考虑了带宽与极限码元传输速率的关系，而香农定理不仅考虑到了带宽，也考虑到了信噪比。这从另一个侧面表明，一个码元对应的二进制位数是有限的。</p><h2 id="3-编码与调制"><a class="header-anchor" href="#3-编码与调制"></a>3 编码与调制</h2><p>信道上传送信号的两种形式:基带信号和宽带信号</p><ul><li><p>基带信号:将数字信号1和0直接用两种不同的电压表示，再送到<font color="#faa755">数字信道</font>上去传输(<font color="#faa755">基带传输</font>)</p><blockquote><p><font color="#ef5b9c">来自信源的信号</font>，像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。基带信号就是发出的直接表达了要传输的信息的信号，比如我们说话的声波就是基带信号。</p></blockquote></li><li><p>宽带信号:将基带信号进行调制后形成的频分复用模拟信号，再传送到<font color="#faa755">模拟信道</font>上去传输(<font color="#faa755">宽带传输</font>)</p><blockquote><p>把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输(即仅在一段频率范围内能够通过信道)。</p></blockquote></li></ul><p>在传输距离较<font color="#faa755">近</font>时，计算机网络采用<font color="#ef5b9c">基带传输</font>方式(近距离衰减小，从而信号内容不易发生变化)</p><p>在传输距离较<font color="#faa755">远</font>时，计算机网络采用<font color="#ef5b9c">宽带传输</font>方式(远距离衰减大，即使信号变化大也能最后过滤出来基带信号)</p><h3 id="数字数据编码为数字信号"><a class="header-anchor" href="#数字数据编码为数字信号"></a>数字数据编码为数字信号</h3><p>数字数据编码用于基带传输中，即在基本不改变数字数据信号频率的情况下，直接传输数字信号。具体用什么样的数字信号表示0及用什么样的数字信号表示1就是所谓的编码。编码的规则有多种，只要能有效地把1和0区分开即可，常用的编码方式有以下几种，如下图所示。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E5%AD%97%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F.png" alt="常用的数字数据编码方式" style="object-fit: cover; border-radius: 10px; width: 80%;" /><ol><li><p>归零编码(RZ)</p><p>在归零编码中用高电平代表1、低电平代表0 (或者相反)，每个时钟周期的中间均跳变到低电平(归零)，接收方根据该跳变调整本方的时钟基准，这就为传输双方提供了自同步机制。由于归零需要占用一部分带宽，因此传输效率受到了一定的影响。</p></li><li><p>非归零编码(NRZ)</p><p>非归零编码与RZ编码的区别是不用归零,一个周期可以全部用来传输数据。但NRZ编码无法传递时钟信号，双方难以同步，因此若想传输高速同步数据，则需要都带有时钟线。</p></li><li><p>反向非归零编码(NRZI)</p><p>反向非归零码与NRZ编码的区别是用信号的翻转代表0、信号保持不变代表1。翻转的信号本身可以作为一种通知机制。这种编码方式集成了前两种编码的优点，既能传输时钟信号，又能尽量不损失系统带宽。USB2.0通信的编码方式就是NRZI编码。</p></li><li><p>曼彻斯特编码(Manchester Encoding)</p><p>曼彻斯特编码将一个码元分成两个相等的间隔，前一个间隔为高电平而后一个间隔为低电平表示码元1;码元0的表示方法则正好相反。当然，也可采用相反的规定。该编码的特点是，在每个码元的中间出现电平跳变，位中间的跳变既作为时钟信号(可用于同步)，又作为数据信号，但它所占的频带宽度是原始基带宽度的两倍。<font color="#faa755">以太网使用的编码方式就是曼彻斯特编码</font>。</p></li><li><p>差分曼彻斯特编码</p><p>差分曼彻斯特编码常用于局域网传输,其规则是,若码元为1,则前半个码元的电平与上一个码元的后半个码元的电平相同;若码元为0，则情形相反。该编码的特点是，在每个码元的中间都有一次电平的跳转，可以实现自同步，且<font color="#faa755">抗干扰性较好</font>。</p></li><li><p>4B/5B编码</p><p>将欲发送数据流的每4位作为一组，然后按照4B/5B编码规则将其转换成相应的5位码。5位码共32种组合，但只采用其中的16种对应16种不同的4位码，其他的16种作为控制码(帧的开始和结束、线路的状态信息等)或保留。</p></li></ol><h3 id="数字数据调制为模拟信号"><a class="header-anchor" href="#数字数据调制为模拟信号"></a>数字数据调制为模拟信号</h3><p>数字数据调制技术在发送端将数字信号转换为模拟信号,而在接收端将模拟信号还原为数字信号，分别对应于调制解调器的调制和解调过程。基本的调制方法有如下几种:</p><ol><li>幅移键控(ASK)。通过改变载波信号的振幅来表示数字信号1和0，而载波的频率和相位都不改变。比较容易实现，但抗干扰能力差。调幅(AM)</li><li>频移键控(FSK)。 通过改变载波信号的频率来表示数字信号1和0，而载波的振幅和相位都不改变。容易实现，抗干扰能力强，目前应用较为广泛。调频(FM)</li><li>相移键控(PSK)。 通过改变载波信号的相位来表示数字信号1和0，而载波的振幅和频率都不改变。它又分为绝对调相和相对调相。调相</li><li>正交振幅调制(QAM)。在频率相同的前提下，将ASK与PSK结合起来，形成叠加信号。设波特率为B,采用m个相位，每个相位有n种振幅，则该QAM技术的数据传输率R为:R= Blog<sub>2</sub>(mn) (单位为b/s).调幅+调相</li></ol><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E5%AD%97%E8%B0%83%E5%88%B6%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F.png" alt="数字调制的三种方式" style="object-fit: cover; border-radius: 10px; width: 900%;" /><h3 id="模拟数据编码为数字信号"><a class="header-anchor" href="#模拟数据编码为数字信号"></a>模拟数据编码为数字信号</h3><p>这种编码方式最典型的例子是常用于对音频信号进行编码的<font color="#ea66a6">脉码调制(PCM)</font>。它主要包括三个步骤，即采样、量化和编码。</p><p><font color="#ea66a6">采样定理</font>:在通信领域，带宽是指信号最高频率与最低频率之差，单位为Hz。因此，将模拟信号转换成数字信号时，假设原始信号中 的最大频率为$f$,那么采样频率$f_{采样}$必须大于等于最大频率$f$的两倍，才能保证采样后的数字信号完整保留原始模拟信号的信息(只需记住结论)。另外，采样定理又称奈奎斯特定理。</p><ol><li><font color="#ea66a6">采样</font>:是指对模拟信号进行周期性扫描，把时间上连续的信号变成时间上离散的信号。根据采样定理，当采样的频率大于等于模拟数据的频带带宽(最高变化频率)的两倍时，所得的离散信号可以无失真地代表被采样的模拟数据。</li><li><font color="#ea66a6">量化</font>:是把采样取得的电平幅值按照一定的分级标度转化为对应的数字值并取整数，这样就把连续的电平幅值转换为了离散的数字量。采样和量化的实质就是分割和转换。</li><li><font color="#ea66a6">编码</font>:是把量化的结果转换为与之对应的二进制编码。</li></ol><h3 id="模拟数据调制为模拟信号"><a class="header-anchor" href="#模拟数据调制为模拟信号"></a>模拟数据调制为模拟信号</h3><p>为了实现传输的有效性，可能需要较高的频率。这种调制方式还可以使用频分复用(FDM)技术，充分利用带宽资源。电话机和本地局交换机采用模拟信号传输模拟数据的编码方式;模拟的声音数据是加载到模拟的载波信号中传输的。</p><h3 id="4-电路交换、报文交换与分组交换"><a class="header-anchor" href="#4-电路交换、报文交换与分组交换"></a>4 电路交换、报文交换与分组交换</h3><p>P40</p><h1>传输介质</h1><p><font color="#ea66a6">传输介质</font>也称传输媒体，它是发送设备和接收设备之间的<font color="#faa755">物理通路</font>。</p><blockquote><p><font color="#faa755">传输媒体并不是物理层</font>。传输媒体在物理层的下面，因为物理层是体系结构的第一层， 因此有时称传输媒体为0层。在传输媒体中传输的是信号，但传输媒体并不知道所传输的信号代表什么意思。但物理层规定了电气特性，因此能够识别所传送的比特流。</p></blockquote><p>传输介质可分为导向传输介质和非导向传输介质。</p><ul><li><font color="#ea66a6">导向传输介质</font>中，电磁波被导向沿着固体媒介(铜线或光纤)传播</li><li><font color="#ea66a6">非导向传输介质</font>可以是空气、真空或海水等</li></ul><h2 id="双绞线、同轴电缆、光纤与无线传输介质"><a class="header-anchor" href="#双绞线、同轴电缆、光纤与无线传输介质"></a>双绞线、同轴电缆、光纤与无线传输介质</h2><h3 id="双绞线"><a class="header-anchor" href="#双绞线"></a>双绞线</h3><p>双绞线是最常用的古老传输介质,它由两根采用一定规则并排绞合的、相互绝缘的铜导线组成。<font color="#faa755">绞合可以减少对相邻导线的电磁干扰</font>。</p><p>为了进一步提高抗电磁干扰能力，可在双绞线的外面再加上一个由<font color="#faa755">金属丝</font>编织成的屏蔽层，这就是屏蔽双绞线(STP)。无屏蔽层的双绞线称为非屏蔽双绞线(UTP)。</p><p>它们的结构如图下所示。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%8F%8C%E7%BB%9E%E7%BA%BF%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="双绞线的结构" style="object-fit: cover; border-radius: 10px; width: 100%;" /><p>双绞线价格便宜，是最常用的传输介质之一，在局域网和传统电话网中普遍使用。</p><p>双绞线的带宽取决于铜线的粗细和传输的距离。</p><p>模拟传输和数字传输都可使用双绞线，其通信距离一般为几千米到数十千米。</p><p>距离太远时，对于<font color="#ef5b9c">模拟传输</font>，要用<font color="#ef5b9c">放大器</font>放大衰减的信号;对于<font color="#faa755">数字传输</font>，要用<font color="#faa755">中继器</font>将失真的信号整形。</p><h3 id="同轴电缆"><a class="header-anchor" href="#同轴电缆"></a>同轴电缆</h3><p>同轴电缆由内导体、绝缘层、网状编织屏蔽层和塑料外层构成，如下图所示。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%90%8C%E8%BD%B4%E7%94%B5%E7%BC%86%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="同轴电缆的结构" style="object-fit: cover; border-radius: 10px; width: 80%;" /><p>按特性阻抗数值的不同，通常将同轴电缆分为两类: 50Ω同轴电缆和75Ω同轴电缆。</p><ul><li>50Ω同轴电缆主要用于传送基带数字信号，又称<font color="#ea66a6">基带同轴电缆</font>，它在局域网中应用广泛;</li><li>75Ω同轴电缆主要用于传送宽带信号，又称<font color="#ea66a6">宽带同轴电缆</font>，主要用于有线电视系统。</li></ul><p>由于外导体屏蔽层的作用，同轴电缆具有良好的抗干扰特性，被广泛用于传输较高速率的数据，其传输距离更远，但价格较双绞线贵。</p><h3 id="光纤"><a class="header-anchor" href="#光纤"></a>光纤</h3><p>光纤通信就是利用光导纤维(简称光纤)传递光脉冲来进行通信。有光脉冲表示1，无光脉冲表示0。可见光的频率约为10<sup>8</sup>MHz，因此光纤通信系统的带宽范围极大。</p><p>光纤在发送端有光源，可以采用发光二极管或半导体激光器，它们在电脉冲作用下能产生出光脉冲;在接收端用光电二极管做成光检测器，在检测到光脉冲时可还原出电脉冲。</p><p>光纤主要由<font color="#faa755">纤心</font>和<font color="#faa755">包层</font>构成，光波通过纤心进行传导，包层较纤心有较低的折射率。当光线从高折射率的介质射向低折射率的介质时，其折射角大于入射角。因此，如果入射角足够大，那么就会出现全反射，即光线碰到包层时会折射回纤心，这个过程不断重复，光也就沿着光纤传输下去。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%89%E6%B3%A2%E5%9C%A8%E7%BA%A4%E5%BF%83%E4%B8%AD%E7%9A%84%E4%BC%A0%E6%92%AD.png" alt="光波在纤心中的传播" style="object-fit: cover; border-radius: 10px; width: 100%;" /><p>只要从纤心中射到纤心表面的光线的入射角大于某个临界角度，就会产生全反射。因此，从不同角，度入射的多束光线可在一条光纤中传输， 这种光纤称为<font color="#ea66a6">多模光纤</font>，多模光纤的光源为<font color="#faa755">发光二极管</font>。光脉冲在多模光纤中传输时会逐渐展宽，造成失真，因此多模光纤只适合于<font color="#faa755">近距离传输</font>。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%A4%9A%E6%A8%A1%E5%85%89%E7%BA%A4.png" alt="多模光纤" style="object-fit: cover; border-radius: 10px; width: 100%;" /><p>光纤的直径减小到仅一个光波长度时，光纤就像一根波导 那样，可使光线一直向前传播， 而不会产生多次反射，这样的光纤就是单模光纤。 单模光纤的纤心很细，直径只有几微米，制造成本较高。同时，单模光纤的光源为<font color="#faa755">定向性很好的激光二极管</font>，因此单模光纤的衰减较小，适合<font color="#faa755">远距离传输</font>。</p><p>光纤的特点:</p><ol><li>传输损耗小，中继距离长，对远距离传输特别经济。</li><li>抗雷电和电磁干扰性能好。</li><li>无串音干扰，保密性好，也不易被窃听或截取数据。</li><li>体积小，重量轻。</li></ol><h3 id="无线传输介质（非导向传播介质）"><a class="header-anchor" href="#无线传输介质（非导向传播介质）"></a>无线传输介质（非导向传播介质）</h3><p>无线通信已广泛应用于移动电话领域，构成蜂窝式无线电话网。随着便携式计算机的出现，以及在军事、野外等特殊场合下移动通信联网的需要，促进了数字化移动通信的发展，现在无线局域网产品的应用已非常普遍。</p><h4 id="无线电波"><a class="header-anchor" href="#无线电波"></a>无线电波</h4><p>无线电波具有<font color="#faa755">较强的穿透能力</font>，可以传输很长的距离，所以它被广泛应用于通信领域，如无线手机通信、计算机网络中的无线局域网(WLAN)等。因为无线电波使信号向所有方向散播,因此有效距离范围内的接收设备无须对准某个方向，就可与无线电波发射者进行通信连接，大大简化了通信连接。这也是无线电传输的最重要优点之一。</p><h4 id="微波、红外线和激光"><a class="header-anchor" href="#微波、红外线和激光"></a>微波、红外线和激光</h4><p>目前高带宽的无线通信主要使用三种技术:微波、红外线和激光。它们都需要发送方和接收方之间存在一条视线(Line-of-sight) 通路，有很强的方向性，都沿直线传播，有时统称这三者为视线介质。不同的是，红外通信和激光通信把要传输的信号分别转换为各自的信号格式，即红外光信号和激光信号，再直接在空间中传播。</p><p>微波通信的频率较高，频段范围也很宽，载波频率通常为2~40GHz,因而通信信道的容量大。例如，一个带宽为2MHz的频段可容纳500条语音线路，若用来传输数字信号，数据率可达数兆比特/秒。与通常的无线电波不同，微波通信的信号是沿直线传播的，因此在地面的传播距离有限，超过一定距离后就要用中继站来接力。</p><p>卫星通信利用地球同步卫星作为中继来转发微波信号，可以克服地面微波通信距离的限制。三颗相隔120°的同步卫星几乎能覆盖整个地球表面，因而基本能实现全球通信。卫星通信的优点是通信容量大、距离远、覆盖广、广播通信和多址通信，缺点是端到端传播时延长，一般为 250~270ms、受气候影响大（强风、太阳黑子爆发、日凌）、误码率较高、成本高。</p><h1>物理层设备</h1><h2 id="中继器"><a class="header-anchor" href="#中继器"></a>中继器</h2><p>诞生原因:由于存在损耗，在线路上传输的信号功率会逐渐衰减，衰减到一定程度时将造成信号失真，因此会导致接收错误。</p><p>中继器的功能:对信号进行<font color="#faa755">再生和还原</font>，对衰减的信号进行放大，保持与原数据相同，以增加信号传输的距离，延长网络的长度。<font color="#FF666">再生数字信号</font></p><p>中继器的两端:</p><ul><li>两端的网络部分是网段，而不是子网，适用于完全相同的两类网络的互连，且两个网段速率要相同。</li><li>中继器只将任何电缆段上的数据发送到另一段电缆上，它仅作用于信号的电气部分，并不管数据中是否有错误数据或不适于网段的数据。</li><li>两端可连相同媒体，也可连不同媒体。</li><li>中继器两端的网段一定要是同一个协议。</li></ul><p>中继器又称转发器，主要功能是将信号整形并放大再转发出去，以消除信号经过一长段电缆后，因噪声或其他原因而造成的失真和衰减，使信号的波形和强度达到所需要的要求，进而扩大网络传输的距离。其原理是信号再生(而非简单地将衰减的信号放大)。中继器有两个端口，数据从一个端口输入，再从另一个端口发出。端口仅作用于信号的电气部分，而不管数据中是否有错误数据或不适于网段的数据。</p><p>中继器是局域网环境下用来扩大网络规模的最简单、最廉价的互联设备。使用中继器连接的几个网段仍然是一个局域网。一般情况下，中继器的两端连接的是相同的媒体，但有的中继器也可以完成不同媒体的转接工作。但由于中继器工作在物理层，因此它不能连接两个具有不同速率的局域网。中继器两端的网络部分是网段，而不是子网。中继器若出现故障，对相邻两个网段的工作都将产生影响。</p><p>从理论上讲，中继器的使用数目是无限的，网络因而也可以无限延长。但事实上这不可能,因为网络标准中对信号的延迟范围做了具体的规定，<font color="#faa755">中继器只能在此规定范围内进行有效的工作，否则会引起网络故障</font>。例如，在采用粗同轴电缆的10BASE5 以太网规范中，互相串联的中继器的个数不能超过4个，而且用4个中继器串联的5段通信介质中只有3段可以挂接计算机，其余两段只能用作扩展通信范围的链路段，不能挂接计算机。这就是所谓的“<font color="#faa755">5-4-3规则</font>”。</p><blockquote><p>注意:放大器和中继器都起放大作用，只不过放大器放大的是模拟信号,原理是将衰减的信号放大，而中继器放大的是数字信号，原理是将衰减的信号整形再生。如果某个网络设备具有存储转发的功能，那么可以认为它能连接两个不同的协议，如果该网络设备没有存储转发功能，那么认为它不能连接两个不同的协议。中继器是没有存储转发功能的，因此它不能连接两个速率不同的网段，中继器两端的网段一定要使用同一个协议。</p></blockquote><h3 id="集线器-多口中继器"><a class="header-anchor" href="#集线器-多口中继器"></a>集线器(多口中继器)</h3><p>集线器(Hub)实质上是一个多端口的中继器，它也工作在物理层。当Hub工作时，一个端口接收到数据信号后，由于信号在从端口到Hub的传输过程中已有衰减，所以Hub便将该信号进行整形放大，使之<font color="#faa755">再生(恢复)到发送时的状态</font>，紧接着转发到其他所有(除输入端口外)处于工作状态的端口。如果同时有两个或多个端口输入，那么输出时会发生冲突，致使这些数据都无效。从Hub的工作方式可以看出，它在网络中只起信号放大和转发作用，目的是扩大网络的传输范围，而<font color="#faa755">不具备信号的定向传送能力</font>，即信号传输的方向是固定的，是一个标准的共享式设备。</p><p>Hub主要使用双绞线组建共享网络，是从服务器连接到桌面的最经济方案。在交换式网络中，Hub直接与交换机相连，将交换机端口的数据送到桌面上。使用Hub组网灵活，它把所有结点的通信集中在以其为中心的结点上，对结点相连的工作站进行集中管理，不让出问题的工作站影响整个网络的正常运行，并且用户的加入和退出也很自由。</p><p>由Hub组成的网络是共享式网络，但逻辑上仍是一个总线网。Hub的每个端口连接的网络部分是同一个网络的不同网段，同时Hub也只能在半双工状态下工作，网络的吞吐率因而受到限制.</p><blockquote><p>注意:多台计算机必须会发生同时通信的情形，因此集线器不能分割冲突域，所有集线器的端口都属于同一个冲突域。集线器在一个时钟周期中只能传输一组信息，如果一台集线器连接的机器数目较多，且多台机器经常需要同时通信，那么将导致信息碰撞，使得集线器的工作效率很差。比如，一个带宽为10Mb/s的集线器上连接了8台计算机，当这8台计算机同时工作时，每台计算机真正所拥有的带宽为10/8Mb/s = 1.25Mb/s.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络体系结构</title>
      <link href="2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
      <url>2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1>计算机网络概述</h1><h2 id="1-计算机网络的概念"><a class="header-anchor" href="#1-计算机网络的概念"></a>1 计算机网络的概念</h2><p>计算机网络：是一个将分散的、具有独立功能的<font color="#FF666">计算机系统</font>，通过<font color="#FF666">通信设备</font>与<font color="#FF666">线路</font>连接起来，由功能完善的<font color="#FF666">软件</font>实现<font color="#FF666">资源共享</font>和<font color="#FF666">信息传递</font>的系统。</p><p>简而言之，计算机网络就是一些<font color="#e03e3e">互联</font>的、<font color="#e03e3e">自治</font>的计算机系统的集合。（互联：互联互通；自治：无主从关系）</p><h2 id="2-计算机网络的功能"><a class="header-anchor" href="#2-计算机网络的功能"></a>2 计算机网络的功能</h2><h3 id="font-color-d9730d-数据通信-font"><a class="header-anchor" href="#font-color-d9730d-数据通信-font"></a><font color="#d9730d">数据通信</font></h3><p>它是计算机网络最基本和最重要的功能，用来实现联网计算机之间的各种信息的传输，并将将分散在不同地理位置的计算机联系起来，进行统一的调配、控制和管理。比如，文件传输、电子邮件等应用，离开了计算机网络将无法实现。</p><h3 id="font-color-d9730d-资源共享-font"><a class="header-anchor" href="#font-color-d9730d-资源共享-font"></a><font color="#d9730d">资源共享</font></h3><p>资源共享可以是软件共享、数据共享，也可以是硬件共享。使计算机网络中的资源互通有无分工协作，从而极大地提高硬件资源、软件资源和数据资源的利用率</p><h3 id="分布式处理"><a class="header-anchor" href="#分布式处理"></a>分布式处理</h3><p>当计算机网络中的某个计算机系统负荷过重时，可以将其处理的某个复杂任务分配给网络中的其他计算机系统，从而利用空闲计算机资源以提高整个系统的利用率。</p><h3 id="提高可靠性"><a class="header-anchor" href="#提高可靠性"></a>提高可靠性</h3><p>计算机网络中的各台计算机可以通过网络互为替代机。</p><h3 id="负载均衡"><a class="header-anchor" href="#负载均衡"></a>负载均衡</h3><p>将工作任务均衡地分配给计算机网络中的各台计算机。</p><hr><p>除以上几大主要功能外，计算机网络还可以实现电子化办公与服务、远程教育、娱乐等功能，满足了社会的需求，方便了人们学习、工作和生活，具有巨大的经济效益。</p><h2 id="3-计算机网络的组成"><a class="header-anchor" href="#3-计算机网络的组成"></a>3 计算机网络的组成</h2><h3 id="组成部分上来看"><a class="header-anchor" href="#组成部分上来看"></a>组成部分上来看</h3><p>一个完整的计算机网络主要由硬件、软件、协议三大部分组成，缺一不可。</p><ul><li>硬件主要由主机（也称端系统）、通信链路（如双绞线、光纤）、交换设备（如路由器、交换机等）和通信处理机（如网卡）等组成。</li><li>软件主要包括各种实现资源共享的软件和方便用户使用的各种工具软件（如网络操作系统、邮件收发程序、FTP程序、聊天程序等）。软件部分多属于应用层。</li><li><font color="#faa755">协议是计算机网络的核心</font>，如同交通规则制约汽车驾驶一样，协议规定了网络传输数据时所遵循的规范。</li></ul><h3 id="font-color-d9730d-从工作方式上看-font"><a class="header-anchor" href="#font-color-d9730d-从工作方式上看-font"></a><font color="#d9730d">从工作方式上看</font></h3><p>计算机网络（这里主要指 internet）可分为边缘部分和核心部分。</p><ul><li>边缘部分由所有连接到因特网上、供用户直接使用的主机组成，用来进行通信（如传输数据、音频或视频）和资源共享；（C/S方式和P2P方式）</li><li>核心部分由大量的网络和连接这些网络的路由器组成，它为边缘部分提供连通性和交换服务。</li></ul><p>图1.1给出了这两部分的示意图。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9B%A0%E7%89%B9%E7%BD%91%E7%9A%84%E6%A0%B8%E5%BF%83%E9%83%A8%E5%88%86%E4%B8%8E%E8%BE%B9%E7%BC%98%E9%83%A8%E5%88%86.png" alt="因特网的核心部分与边缘部分" style="object-fit: cover; border-radius: 10px; width: 80%; " /><h3 id="font-color-d9730d-从功能组成上看-font"><a class="header-anchor" href="#font-color-d9730d-从功能组成上看-font"></a><font color="#d9730d">从功能组成上看</font></h3><p>计算机网络由通信子网和资源子网组成。</p><ul><li>通信子网由各种传输介质、通信设备和相应的网络协议组成，它使网络具有数据传输、交换、控制和存储的能力，实现联网计算机之间的<font color="#faa755">数据通信</font>。</li><li>资源子网是实现<font color="#faa755">资源共享</font>功能的设备及其软件的集合，向网络用户提供共享其他计算机上的硬件资源、软件资源和数据资源的服务。</li></ul><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%B5%84%E6%BA%90%E5%AD%90%E7%BD%91%E5%92%8C%E9%80%9A%E4%BF%A1%E5%AD%90%E7%BD%91.png" alt="资源子网和通信子网" style="object-fit: cover; border-radius: 10px; width: 80%;" /><h2 id="4-计算机网络的分类"><a class="header-anchor" href="#4-计算机网络的分类"></a>4 计算机网络的分类</h2><h3 id="按分布范分类"><a class="header-anchor" href="#按分布范分类"></a>按分布范分类</h3><ul><li>广域网（WAN）。广域网的任务是提供长距离通信，运送主机所发送的数据，其覆盖范围通常为几十千米到几千千米的区域，因而有时也称远程网。广域网是因特网的核心部分。连接广域网的各结点交换机的链路一般都是高速链路，具有较大的通信容量。（交换技术）</li><li>城域网（MAN）。城域网的覆盖范围可以跨越几个街区甚至整个城市，覆盖范围约为5~50km。城域网大多采用以太网技术，因此有时也常并入局域网的范围进行讨论。</li><li>局域网（LAN）。局域网一般用微机或工作站通过高速线路相连，覆盖范围较小，通常为几十米到几千米的区域。局域网在计算机配置的数量上没有太多的限制，少的可以只有两台，多的可达几百台。传统上，局域网使用广播技术，而广域网使用交换技术。（广播技术）</li><li>个人区域网（PAN）。个人区域网是指在个人工作的地方将消费电子设备（如平板电脑、智能手机等）用无线技术连接起来的网络，也常称为无线个人区域网（WPAN），其覆盖的区域直径约为10m。</li></ul><blockquote><p>:bulb: 注意：若中央处理器之间的距离非常近（如仅1m的数量级或甚至更小），则一般就称之为多处理器系统，而不称它为计算机网络。</p></blockquote><h3 id="按使用者分类"><a class="header-anchor" href="#按使用者分类"></a>按使用者分类</h3><ul><li>公用网（ Public network）。指电信公司出资建造的大型网络。“公用”的意思是指所有愿意按电信公司的规定交纳费用的人都可以使用这种网络，因此也称公众网。</li><li>专用网（ Private Network）。指某个部门为满足本单位特殊业务的需要而建造的网络。这种网络不向本单位以外的人提供服务。例如铁路、电力、军队等部门的专用网。</li></ul><h3 id="按交换技术分类"><a class="header-anchor" href="#按交换技术分类"></a>按交换技术分类</h3><p>交换技术是指各台主机之间、各通信设备之间或主机与通信设备之间为交换信息所采用的数据格式和交换装置的方式。</p><p>按交换技术可将网络分为如下几种</p><ul><li><p>电路交换网络。在源结点和目的结点之间建立一条专用的通路用于传送数据，包括建立连接、传输数据和断开连接三个阶段。最典型的电路交换网是传统电话网络。</p><blockquote><p>该类网络的主要特点是整个报文的比特流连续地从源点直达终点，好像是在一条管道中传送。优点是数据直接传送、时延小。缺点是线路利用率低、不能充分利用线路容量、不便于进行差错控制</p></blockquote></li><li><p>报文交换网络。用户数据加上源地址、目的地址、校验码等辅助信息，然后封装成报文整个报文传送到相邻结点，全部存储后，再转发给下一个结点，重复这一过程直到到达目的结点。每个报文可以单独选择到达目的结点的路径。</p><blockquote><p>报文交换网络。用户数据加上源地址、目的地址、校验码等辅助信息，然后封装成报文整个报文传送到相邻结点，全部存储后，再转发给下一个结点，重复这一过程直到到达目的结点。每个报文可以单独选择到达目的结点的路径。</p></blockquote></li><li><p>分组交换网络，也称包交换网络。其原理是将数据分成较短的固定长度的数据块，在每个数据块中加上目的地址、源地址等辅助信息组成分组（包），以存储-转发方式传输其主要特点是单个分组（它只是整个报文的一部分）传送到相邻结点，存储后查找转发表，转发到下一个结点。除具备报文交换网络的优点外，分组交换网络还具有自身的优点：缓冲易于管理；包的平均时延更小，网络占用的平均缓冲区更少；更易于标准化；更适合应用。现在的主流网络基本上都可视为分组交换网络。</p></li></ul><h3 id="按拓扑结构分类"><a class="header-anchor" href="#按拓扑结构分类"></a>按拓扑结构分类</h3><p>网络拓扑结构是指由网中结点（路由器、主机等）与通信线路（网线）之间的几何关系（如总线形、环形）表示的网络结构，主要指通信子网的拓扑结构按网络的拓扑结构，主要分为总线形、星形、环形和网状形网络等。</p><p>星形、总线形和环形网络多用于局域网，网状形网络多用于广域网。</p><h3 id="按传输介质分类"><a class="header-anchor" href="#按传输介质分类"></a>按传输介质分类</h3><p>传输介质可分为有线和无线两大类，因此网络可以分为有线网络和无线网络。有线网络又分为双绞线网络、同轴电缆网络等。无线网络又可分为蓝牙、微波、无线电等类型</p><h3 id="按传输技术分类"><a class="header-anchor" href="#按传输技术分类"></a>按传输技术分类</h3><ul><li>广播式网络。所有联网计算机都共享一个公共通信信道。当一台计算机利用共享通信信道发送报文分组时，所有其他的计算机都会“收听”到这个分组。接收到该分组的计算机将通过检查目的地址来决定是否接收该分组局域网基本上都采用广播式通信技术，广域网中的无线、卫星通信网络也采用广播式通信技术。</li><li>点对点网络。每条物理线路连接一对计算机。如果通信的两台主机之间没有直接连接的线路，那么它们之间的分组传输就要通过中间结点的接收、存储和转发，直至目的结点。</li></ul><p><font color="#e03e3e">是否采用分组存储转发与路由选择机制是点对点式网络与广播式网络的重要区别</font>，广域网基本都属于点对点网络。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E7%AC%AC1%E8%8A%82%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.svg" alt="第一节思维导图" style="object-fit: cover; border-radius: 10px; width: 100%;"/><h2 id="5-计算机网络的标准化工作"><a class="header-anchor" href="#5-计算机网络的标准化工作"></a>5 计算机网络的标准化工作</h2><h3 id="标准的分类"><a class="header-anchor" href="#标准的分类"></a>标准的分类</h3><ol><li>法定标准，由权威机构制定的正式的、合法的标准（OSI）</li><li>事实标准，某些公司的产品在竞争中占据了主流，时间长了，这些产品中的协议和技术就成了标准（TCP/IP）</li></ol><p>计算机网络的标准化对计算机网络的发展和推广起到了极为重要的作用。</p><p>因特网的所有标准都以RFC（ Request For Comments）的形式在因特网上发布，但并非每个RFC都是因特网标准，RFC要上升为因特网的正式标准需经过以下4个阶段</p><ol><li>因特网草案（ Internet Draft）。这个阶段还不是RFC文档。</li><li>建议标准（ Proposed Standard）。从这个阶段开始就成为RFC文档。</li><li>草案标准（ Draft Standard）。</li><li>因特网标准（ Internet Standard）</li></ol><p>此外，还有实验的RFC和提供信息的RFC。各种RFC之间的关系如图1.3所示。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%90%84%E7%A7%8DRFC%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="各种RFC之间的关系" style="object-fit: cover; border-radius: 10px; width: 80%;" /><p>在国际上，负责制定、实施相关网络标准的标准化组织众多，主要有如下几个</p><ul><li>国际标准化组织（ISO）。制定的主要网络标准或规范有OSI参考模型、HDLC等。</li><li>国际电信联盟（ITU）。其前身为国际电话电报咨询委员会（CCITT），其下属机构ITU-T制定了大量有关远程通信的标准。</li><li>国际电气电子工程师协会（IEEE）。世界上最大的专业技术团体，由计算机和工程学专业人士组成。IEEE在通信领域最著名的研究成果是802标准</li></ul><h2 id="6-计算机网络的性能指标"><a class="header-anchor" href="#6-计算机网络的性能指标"></a>6 计算机网络的性能指标</h2><h3 id="速率-Speed"><a class="header-anchor" href="#速率-Speed"></a>速率(Speed)</h3><p>网络中的速率是指连接到计算机网络上的主机在数字信道上传送数据的速率，也称数据率或比特率，单位为b/s（比特秒）（或bit/s，有时也写为bps）。数据率较高时，可用kb/s（k=10<sup>3</sup>​）、Mbs（M=10<sup>5</sup>）或Gbs（G=10<sup>9</sup>）表示。在计算机网络中，通常把最高数据率称为带宽。</p><h3 id="带宽-Bandwidth"><a class="header-anchor" href="#带宽-Bandwidth"></a>带宽(Bandwidth)</h3><p>本来表示通信线路允许通过的信号频带范围，单位是赫兹（Hz）。而在计算机网络中，带宽表示网络的通信线路所能传送数据的能力，是数字信道所能传送的“<font color="#faa755">最高数据率</font>”的同义语，单位是比特/秒（bs）。</p><h3 id="吞吐量-Throughput"><a class="header-anchor" href="#吞吐量-Throughput"></a>吞吐量(Throughput)</h3><p>指<font color="#faa755">单位时间</font>内通过某个网络（或信道、接口）的数据量。吞吐量受网络带宽或网络额定速率的限制。</p><h3 id="时延-Delay"><a class="header-anchor" href="#时延-Delay"></a>时延(Delay)</h3><p>指数据（一个报文或分组）从网络（或链路）的一端传送到另一端所需要的总时间，它由4部分构成：发送时延、传播时延、处理时延和排队时延。</p><ul><li><p>发送时延。结点将分组的所有比特推向（传输）链路所需的时间，即从发送分组的第一个比特算起，到该分组的最后一个比特发送完毕所需的时间，因此也称传输时延。</p><blockquote><p>计算公式为：发送时延=分组长度/信道宽度(发送速率)</p></blockquote></li><li><p>传播时延。电磁波在信道中传播一定的距离需要花费的时间，即一个比特从链路的端传播到另一端所需的时间。</p><blockquote><p>计算公式为：传播时延=信道长度/电磁波在信道上的传播速率</p></blockquote></li><li><p>处理时延。数据在交换结点为存储转发而进行的一些必要的处理所花费的时间。例如，分析分组的首部、从分组中提取数据部分、进行差错检验或査找适当的路由等。</p></li><li><p>排队时延。分组在进入路由器后要先在输入队列中排队等待处理。路由器确定转发端口后，还要在输出队列中排队等待转发，这就产生了排队时延。</p></li></ul><p>因此，数据在网络中经历的总时延就是以上4部分时延之和：<font color="#faa755">总时延=发送时延+传播时延+处理时延+排队时延</font></p><blockquote><p>:bulb: 注意：做题时，排队时延和处理时延一般可忽略不计（除非题目另有说明）。另外，<font color="#faa755">对于高速链路，提高的仅是数据发送速率而非比特在链路上的传播速率</font>。提高数据的发送速率只是为了减少数据的发送时延</p></blockquote><p>类比车站机场安检过程</p><h3 id="时延带宽积"><a class="header-anchor" href="#时延带宽积"></a>时延带宽积</h3><p>指发送端发送的第一个比特即将到达终点时，发送端已经发出了多少个比特，因此又称以比特为单位的链路长度，即<font color="#faa755">时延带宽积=传播时延×信道带宽</font>。 考虑—个代表链路的圆柱形管道，其长度表示链路的传播时延，横截面积表示链路带宽，则时延带宽积表示该管道可以容纳的比特数量。以比特为单位的链路长度，即“某端链路现在有多少比特”（容量）</p><h3 id="往返时延-Round-Trip-Time-RTT"><a class="header-anchor" href="#往返时延-Round-Trip-Time-RTT"></a>往返时延(Round-Trip Time,RTT)</h3><p>指从发送端发送数据开始，到发送端收到来自接收端的确认(接收端收到数据后立即发送确认)，总共经历的时延。在互联网中，往返时延还包括各中间结点的处理时延、排队时延及转发数据时的发送时延。RTT越大，在收到确认之前，可以发送的数据越多。</p><h3 id="信道利用率"><a class="header-anchor" href="#信道利用率"></a>信道利用率</h3><p>指出某一信道有百分之多少的时间是有数据通过的，即<font color="#faa755">信道利用率 = 有数据通过时间/(有+无)数据通过时间</font>。</p><p>网络利用率：信道利用率加权平均值</p><h1>计算机网络体系结构与参考模型</h1><h2 id="1-计算机网络分层结构"><a class="header-anchor" href="#1-计算机网络分层结构"></a>1 计算机网络分层结构</h2><h3 id="为什么要分层"><a class="header-anchor" href="#为什么要分层"></a>为什么要分层</h3><p>对于发送文件前要完成的工作:</p><ol><li>发起通信的计算机必须将数据通信的通路进行激活。</li><li>要告诉网络如何识别目的主机。</li><li>发起通信的计算机要查明目的主机是否开机，并且与网络连接正常。</li><li>发起通信的计算机要弄清楚，对方计算机中文件管理程序是否已经做好准备工作。</li><li>确保差错和意外可以解决。</li></ol><p>两个系统中实体间的通信是一个很复杂的过程，为了降低协议设计和调试过程的复杂性，也为了便于对网络进行研究、实现和维护，促进标准化工作，通常对计算机网络的体系结构以分层的方式进行建模。</p><h3 id="分层的基本原则"><a class="header-anchor" href="#分层的基本原则"></a>分层的基本原则</h3><p>我们把计算机网络的各层及其协议的集合称为<font color="#ea66a6">网络的体系结构</font>(Architecture)。 换言之，计算机网络的体系结构就是这个计算机网络及其所应完成的<font color="#faa755">功能</font>的精确定义，它是计算机网络中的层次、各层的协议及层间接口的集合。需要强调的是，这些功能究竟是用何种硬件或软件完成的，则是一个遵循这种体系结构的实现（Implementation）问题。体系结构是抽象的，而实现是具体的，是真正在运行的计算机硬件和软件。。</p><p>计算机网络的体系结构通常都具有可分层的特性，它将复杂的大系统分成若干较容易实现的层次。分层的基本原则如下：</p><ol><li>每层都实现一种相对<font color="#faa755">独立</font>的功能，降低大系统的复杂度。</li><li>各层之间<font color="#faa755">界面自然清晰</font>，易于理解，相互交流尽可能少。</li><li>各层功能的精确定义独立于具体的实现方法，可以采用<font color="#faa755">最合适的技术</font>来实现。</li><li>保持<font color="#faa755">下层对上层的独立性</font>，<font color="#faa755">上层单向使用下层提供的服务</font>。</li><li>整个分层结构应能促进标准化工作。</li></ol><p>由于分层后各层之间相对独立，灵活性好，因而分层的体系结构易于更新(替换单个模块)，易于调试，易于交流，易于抽象，易于标准化。但<font color="#0f7b6c">层次越多</font>，有些功能在不同层中难免重复出现，产生额外的开销，导致整体运行效率越低。<font color="#0f7b6c">层次越少</font>，就会使每层的协议太复杂。因此，在分层时应考虑层次的清晰程度与运行效率间的折中、层次数量的折中。</p><h3 id="计算机网络层次结构"><a class="header-anchor" href="#计算机网络层次结构"></a>计算机网络层次结构</h3><p>依据一定的规则，将分层后的网络从低层到高层依次称为第1层、第2.层…第n层，通常还为每层取一个特定的名称，如第1层的名称为<font color="#faa755">物理层</font>。</p><p>在计算机网络的分层结构中，第n层中的活动元素通常称为n层实体。具体来说，<font color="#ea66a6">实体</font>指任何可发送或接收信息的硬件或软件进程，通常是一个特定的软件模块。不同机器上的同一层称为对等层，同一层的实体称为<font color="#ea66a6">对等实体</font>。n层实体实现的服务为 n+ 1 层所利用。在这种情况下，n层被称为服务提供者，n+1 层则服务于用户。</p><p>每一层还有自己传送的数据单位，其名称、大小、含义也各有不同。</p><p>在计算机网络体系结构的各个层次中，每个报文都分为两部分：一是<font color="#faa755">数据部分</font>， 即SDU；二是<font color="#faa755">控制信息部分</font>，即PCI，它们共同组成PDU。</p><ul><li><font color="#ea66a6">服务数据单元</font>(SDU)：为完成用户所要求的功能而应传送的数据。第n层的服务数据单元记为n-SDU。</li><li><font color="#ea66a6">协议控制信息</font>(PCI)：控制协议操作的信息。第n层的协议控制信息记为n-PCI。</li><li><font color="#ea66a6">协议数据单元</font>(PDU)：对等层次之间传送的数据单位称为该层的PDU。第n层的协议数据单元记为n-PDU。在实际的网络中，每层的协议数据单元都有一个通俗的名称，如物理层的PDU称为比特，链路层的PDU称为帧，网络层的PDU称为分组，传输层的PDU称为报文。</li></ul><p>在各层间传输数据时，把从第n+1层收到的PDU作为第n层的SDU，加上第n层的PCI，就变成了第n层的PDU，交给第n-1层后作为SDU发送，接收方接收时做相反的处理，因此可知三者的关系为n-SDU + n-PCI= n-PDU= (n-1)-SDU，其变换过程如图1.5所示。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E6%95%B0%E6%8D%AE%E5%8D%95%E5%85%83%E7%9A%84%E8%81%94%E7%B3%BB.png" alt="网络各层数据单元的联系" style="object-fit: cover; border-radius: 10px; width: 80%;" /><p>具体地，层次结构的含义包括以下几方面：</p><ol><li>第 n 层的实体不仅要使用第 n-1 层的服务来实现自身定义的功能，还要向第 n+1 层提供本层的服务，该服务是第 n 层及其下面各层提供的服务总和。</li><li>最低层只提供服务，是整个层次结构的基础；中间各层既是下一层的服务使用者，又是上一层的服务提供者；最高层面向用户提供服务。</li><li>上一层只能通过相邻层间的接口使用下一层的服务，而不能调用其他层的服务；下一层所提供服务的实现细节对上一层透明。</li><li>两台主机通信时，对等层在逻辑上有一条直接信道，表现为不经过下层就把信息传送到对方。</li></ol><h3 id="概念总结"><a class="header-anchor" href="#概念总结"></a>概念总结</h3><ol><li>网络体系结构是从功能上描述计算机网络结构。</li><li>计算机网络体系结构简称网络体系结构是分层结构。</li><li>每层遵循某个/些网络协议以完成本层功能。</li><li>计算机网络体系结构是计算机网络的各层及其协议的集合。</li><li>第 n 层在向 n+1 层提供服务时，此服务不仅包含第 n 层本身的功能，还包含由下层服务提供的功能。</li><li>仅仅在相邻层间有接口，且所提供服务的具体实现细节对上一层完全屏蔽。</li><li>体系结构是抽象的，而实现是指能运行的一些软件和硬件。</li></ol><h2 id="2-计算机网络协议、接口、服务的概念"><a class="header-anchor" href="#2-计算机网络协议、接口、服务的概念"></a>2 计算机网络协议、接口、服务的概念</h2><h3 id="协议"><a class="header-anchor" href="#协议"></a>协议</h3><p>协议，就是规则的集合。在网络中要做到有条不紊地交换数据，就必须遵循一些事先约定好的规则。这些规则明确规定了所交换的数据的格式及有关的同步问题。这些为进行网络中的数据交换而建立的规则、标准或约定称为网络协议（ Network Protocol ），它是控制两个(或多个)对等实体进行通信的规则的集合，是<font color="#e03e3e">水平</font>的。不对等实体之间是没有协议的，比如用 TCP/IP 协议栈通信的两个结点，结点A的传输层和结点 B 的传输层之间存在协议，但结点A的传输层和结点B的网络层之间不存在协议。网络协议也简称为协议。</p><p>协议由语法、语义和同步三部分组成。</p><ul><li>语法：规定了传输数据的格式；</li><li>语义：规定了所要完成的功能，即需要发出何种控制信息、完成何种动作及做出何种应答；</li><li>同步：规定了执行各种操作的条件、时序关系等，即事件实现顺序的详细说明。</li></ul><p>一个完整的协议通常应具有线路管理(建立、释放连接)、差错控制、数据转换等功能。</p><h3 id="接口"><a class="header-anchor" href="#接口"></a>接口</h3><p>接口是同一结点内相邻两层间交换信息的连接点，是一个系统内部的规定。每层只能为紧邻的层次之间定义接口，不能跨层定义接口。在典型的接口上，同一结点相邻两层的实体通过服务访问点（Service Access Point，SAP）进行交互。服务是通过 SAP 提供给上层使用的，第 n 层的 SAP 就是第 n+1 层可以访问第 n 层服务的地方（上层使用下层服务的入口，下层为上层提供的接口）。每个 SAP 都有一个能够标识它的地址。SAP 是一个抽象的概念，它实际上是一个逻辑接口（类似于邮政信箱），但和通常所说的两个设备之间的硬件接口是很不一样的。</p><h3 id="服务"><a class="header-anchor" href="#服务"></a>服务</h3><p>服务是指下层为紧邻的上层提供的功能调用（单向），它是<font color="#e03e3e">垂直</font>的。对等实体在协议的控制下，使得本层能为上一层提供服务，但要实现本层协议还需要使用下一层所提供的服务。</p><p>上层使用下层所提供的服务时必须与下层交换一些命令，这些命令在OSI中称为服务原语。</p><p>OSI将原语划分为4类:</p><ol><li>请求(Request)。 由服务用户发往服务提供者，请求完成某项工作。</li><li>指示( Indication)。由服务提供者发往服务用户，指示用户做某件事情。</li><li>响应(Response)。 由服务用户发往服务提供者，作为对指示的响应。</li><li>证实(Confirmation)。由服务提供者发往服务用户，作为对请求的证实。</li></ol><p>这4类原语用于不同的功能，如建立连接、传输数据和断开连接等。有应答服务包括全部4类原语，而无应答服务则只有请求和指示两类原语。</p><p>一定要注意，协议和服务在概念上是不一样的。</p><ul><li>首先，只有本层协议的实现才能保证向上一层提供服务。本层的服务用户只能看见服务而无法看见下面的协议，即下面的协议对上层的服务用户是透明的。</li><li>其次，协议是“水平的”，即协议是控制对等实体之间通信的规则。但服务是“垂直的”，即服务是由下层通过层间接口向上层提供的。</li><li>另外，并非在一层内完成的全部功能都称为服务，只有那些能够被高一层实体 “看得见”的功能才称为服务。</li></ul><p>协议、接口、服务三者之间的关系如图1.7所示。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%8D%8F%E8%AE%AE%E3%80%81%E6%8E%A5%E5%8F%A3%E3%80%81%E6%9C%8D%E5%8A%A1%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="协议、接口、服务三者之间的关系" style="object-fit: cover; border-radius: 10px; width: 80%;" /><hr><p>计算机网络提供的服务可按以下三种方式分类。</p><h4 id="面向连接服务与无连接服务"><a class="header-anchor" href="#面向连接服务与无连接服务"></a>面向连接服务与无连接服务</h4><p>在面向连接服务中，通信前双方必须先建立连接，分配相应的资源（如缓冲区），以保证通信能正常进行，传输结束后释放连接和所占用的资源。因此这种服务可以分为连接建立、数据传输和连接释放三个阶段。例如TCP就是一种面向连接服务的协议。</p><p>在无连接服务中，通信前双方不需要先建立连接，需要发送数据时可直接发送，把每个带有目的地址的包（报文分组）传送到线路上，由系统选定路线进行传输。这是一种不可靠的服务。这种服务常被描述为“尽最大努力交付”（Best-Effort-Delivery），它并不保证通信的可靠性。例如IP、UDP就是一种无连接服务的协议。</p><h4 id="可靠服务和不可靠服务"><a class="header-anchor" href="#可靠服务和不可靠服务"></a>可靠服务和不可靠服务</h4><p>可靠服务是指网络具有纠错、检错、应答机制，能保证数据正确、可靠地传送到目的地。不可靠服务是指网络只是尽量正确、可靠地传送，而不能保证数据正确、可靠地传送到目的地，是一种尽力而为的服务。</p><p>对于提供不可靠服务的网络，其网络的正确性、可靠性要由应用或用户来保障。例如，用户收到信息后要判断信息的正确性，如果不正确，那么用户要把出错信息报告给信息的发送者，以便发送者采取纠正措施。通过用户的这些措施，可以把不可靠的服务变成可靠的服务。</p><blockquote><p>注意：在一层内完成的全部功能并非都称之为服务，只有那些能够被高一层实体“看得见”的功能才能称为服务。</p></blockquote><h4 id="有应答服务和无应答服务"><a class="header-anchor" href="#有应答服务和无应答服务"></a>有应答服务和无应答服务</h4><p>有应答服务是指接收方在收到数据后向发送方给出相应的应答，该应答由传输系统内部自动实现，而不由用户实现。所发送的应答既可以是肯定应答，也可以是否定应答，通常在接收到的数据有错误时发送否定应答。例如，文件传输服务就是一种有应答服务。</p><p>无应答服务是指接收方收到数据后不自动给出应答。若需要应答，则由高层实现。例如，对于WWW服务，客户端收到服务器发送的页面文件后不给出应答。</p><h2 id="3-ISO-OSI参考模型"><a class="header-anchor" href="#3-ISO-OSI参考模型"></a>3 ISO/OSI参考模型</h2><p>国际标准化组织（ISO）提出的网络体系结构模型，称为开放系统互连参考模型（OSI/ RM）,通常简称为OSI参考模型。OSI有7层，自下而上依次为物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p><ul><li>高三层统称为<font color="#FF666">资源子网</font>，它相当于计算机系统，完成<font color="#faa755">数据的处理</font>等功能。</li><li>传输层承上启下。</li><li>低三层统称为<font color="#FF666">通信子网</font>，它是为了联网而附加的通信设备，完成<font color="#faa755">数据的传输</font>功能；</li></ul><p>OSI的层次结构如图1.8所示。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSI%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" alt="OSI的层次结构" style="object-fit: cover; border-radius: 10px; width: 100%;" /><p>下面详述OSI参考模型各层的功能。</p><h3 id="应用层（Application-Layer）"><a class="header-anchor" href="#应用层（Application-Layer）"></a>应用层（Application Layer）</h3><p>应用层是 OSI 模型的最高层，是用户与网络的界面。应用层为特定类型的网络应用提供访问 OSI 环境的手段。因为用户的实际应用多种多样，这就要求应用层采用不同的应用协议来解决不同类型的应用要求，因此应用层是最复杂的一层，使用的协议也最多。典型的协议有用于文件传：送的FTP、用于电子邮件的SMTP、用于万维网的HTTP等。</p><h3 id="表示层（Presentation-Layer）"><a class="header-anchor" href="#表示层（Presentation-Layer）"></a>表示层（Presentation Layer）</h3><p>表示层主要处理在两个通信系统中交换信息的表示方式。不同机器采用的编码和表示方法不同，使用的数据结构也不同。为了使不同表示方法的数据和信息之间能互相交换，表示层采用抽象的标准方法定义数据结构，并采用标准的编码形式。数据压缩、加密和解密也是表示层可提供的数据表示变换功能。</p><p>功能一：数据格式变换</p><p>功能二：数据加密解密</p><p>功能三：数据压缩和恢复</p><h3 id="会话层（Session-Layer）"><a class="header-anchor" href="#会话层（Session-Layer）"></a>会话层（Session Layer）</h3><p>会话层允许不同主机上的各个进程之间进行会话。会话层利用传输层提供的端到端的服务，向表示层提供它的增值服务。这种服务主要为表示层实体或用户进程建立连接并在连接上有序地传输数据，这就是会话，也称建立同步（SYN）。</p><p>会话层负责管理主机间的会话进程，包括建立、管理及终止进程间的会话。会话层可以使用校验点使通信会话在通信失效时从校验点继续恢复通信，实现数据同步。</p><p>功能一：建立、管理、终止会话</p><p>功能二：使用校验点可使会话在通信失效时从校验点/同步点继续恢复通信，实现数据同步。</p><h3 id="传输层（Transport-Layer）"><a class="header-anchor" href="#传输层（Transport-Layer）"></a>传输层（Transport Layer）</h3><p>传输层也称运输层，传输单位是报文段（TCP） 或用户数据报（UDP），传输层负责主机中两个进程之间的通信，功能是为端到端连接提供可靠的传输服务，为端到端连接提供流量控制、差错控制、服务质量、数据传输管理等服务。</p><p>数据链路层提供的是点到点的通信，传输层提供的是端到端的通信，两者不同。</p><p>通俗地说，点到点可以理解为主机到主机之间的通信，一个点是指一个硬件地址或IP地址，网络中参与通信的主机是通过硬件地址或IP地址标识的；端到端的通信是指运行在不同主机内的两个进程之间的通信，一个进程由一个端口来标识，所以称端到端通信。</p><p>使用传输层的服务，高层用户可以直接进行端到端的数据传输，从而忽略通信子网的存在。通过传输层的屏蔽，高层用户看不到子网的交替和变化。由于一台主机可同时运行多个进程，因此传输层具有复用和分用的功能。复用是指多个应用层进程可同时使用下面传输层的服务，分用是指传输层把收到的信息分别交付给上面应用层中相应的进程。</p><p>传输层的协议有TCP、UDP。</p><p>功能一：可靠传输、不可靠传输</p><p>功能二：差错控制</p><p>功能三：流量控制</p><p>功能四：复用分用</p><h3 id="网络层（Network-Layer）"><a class="header-anchor" href="#网络层（Network-Layer）"></a>网络层（Network Layer）</h3><p>主要任务是把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务。网络层传输单位是数据报。（分组是对数据报进行分割后的结果）</p><p>它关心的是通信子网的运行控制，主要任务是把网络层的协议数据单元（分组）从源端传到目的端，为分组交换网上的不同主机提供通信服务。关键问题是对分组进行路由选择，并实现流量控制、拥塞控制、差错控制和网际互联等功能。</p><p>如图1.10所示，结点A向结点B传输一个分组时，既可经过边a、c、g,也可经过边b、h，有很多条可以选择的路由，而网络层的作用就是根据网络的情况，利用相应的路由算法计算出一条合适的路径,使这个分组可以顺利到达结点B。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%9F%90%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="某网络结构图" style="object-fit: cover; border-radius: 10px; width: 80%;" /><p>流量控制与数据链路层的流量控制含义一样，都是协调 A 的发送速率和 B 的接收速率。</p><p>差错控制是通信两结点之间约定的特定检错规则，如奇偶校验码，接收方根据这个规则检查接收到的分组是否出现差错，如果出现了差错，那么能纠错就纠错，不能纠错就丢弃，确保向上层提交的数据都是无误的。</p><p>如果图1.9中的结点都处于来不及接收分组而要丢弃大量分组的情况，那么网络就处于拥塞状态，拥塞状态使得网络中的两个结点无法正常通信。网络层要采取一定的措施来缓解这种拥塞，这就是拥塞控制。</p><p>因特网是一个很大的互联网，它由大量异构网络通过路由器（Router）相互连接起来。因特网的主要网络层协议是无连接的网际协议（Internet Protocol，IP）和许多路由选择协议，因此因特网的网络层也称网际层或IP层。</p><p>注意，网络层中的“网络”一词并不是我们通常谈及的具体网络，而是在计算机网络体系结构中使用的专有名词。</p><p>网络层的协议有IP、IPX、ICMP、IGMP、ARP、 RARP和OSPF等。</p><p>功能一：路由选择</p><p>功能二：流量控制</p><p>功能三：差错控制</p><p>功能四：拥塞控制</p><h3 id="数据链路层（Data-Link-Layer）"><a class="header-anchor" href="#数据链路层（Data-Link-Layer）"></a>数据链路层（Data Link Layer）</h3><p>数据链路层的传输单位是帧，任务是将网络层传来的IP数据报组装成帧。数据链路层的功能可以概括为成帧、差错控制、流量控制和传输管理等。</p><p>由于外界噪声的干扰，原始的物理连接在传输比特流时可能发生错误。如图1.8 所示，左边结点想向右边结点传输数字0，于是发出了信号A；但传输过程中受到干扰，信号A变成了信号B，而信号B又刚好代表1，右边结点接收到信号B时，就会误以为左边结点传送了数字1，从而发生差错。两个结点之间如果规定了数据链路层协议，那么就可以检测出这些差错，然后把收到的错误信息丢弃，这就是差错控制功能。</p><p>如图1.8 所示，在两个相邻结点之间传送数据时，由于两个结点性能的不同，可能结点A发送数据的速率会比结点B接收数据的速率快,如果不加控制，那么结点B就会丢弃很多来不及接收的正确数据，造成传输线路效率的下降。流量控制可以协调两个结点的速率，使结点A发送数据的速率刚好是结点B可以接收的速率。</p><p>广播式网络在数据链路层还要处理新的问题，即如何控制对共享信道的访问。数据链路层的一个特殊的子层一介 质访问子层，就是专门处理这个问题的。</p><p>典型的数据链路层协议有SDLC、HDLC、PPP、STP和帧中继等。</p><p>功能一：成帧（定义帧的开始和结束）</p><p>功能二：差错控制（帧错、位错）</p><p>功能三：流量控制</p><p>功能四：访问（接入）控制 控制对信道的访问</p><h3 id="物理层（Physical-Layer）"><a class="header-anchor" href="#物理层（Physical-Layer）"></a>物理层（Physical Layer）</h3><p>物理层的传输单位是比特，任务是透明的传输比特流，功能是在物理媒体上为数据端设备透明地传输原始比特流。</p><p>透明传输：指不管所传数据是什么样的比特组合都应当能够在链路上传送。</p><p>物理层主要定义数据终端设备（DTE）和数据通信设备（DCE）的物理与逻辑连接方法，所以物理层协议也称物理层接口标准。由于在通信技术的早期阶段，通信规则称为规程（Procedure），因此物理层协议也称物理层规程。</p><p>物理层接口标准很多，如 EIA-232C、EIA/TIA RS-449、CCITT 的 X.21 等。在计算机网络的复习过程中，不要忽略对各层传输协议的记忆，到了后期，读者对链路层、网络层、传输层和应用层的协议会比较熟悉，但往往容易忽视物理层的协议。</p><p>物理层主要研究以下内容:</p><p>① 通信链路与通信结点的连接需要一些电路接口，物理层规定了这些接口的一些参数，如机械形状和尺寸、交换电路的数量和排列等，例如，笔记本电脑上的网线接口，就是物理层规定的内容之一。</p><p>② 物理层也规定了通信链路上传输的信号的意义和电气特征。例如物理层规定信号A代表数字0，那么当结点要传输数字0时，就会发出信号A，当结点接收到信号A时，就知道自己接收到的实际上是数字0。</p><p>注意，传输信息所利用的一些物理媒体，如双绞线、光缆、无线信道等，并不在物理层协议之内而在物理层协议下面。因此，有人把物理媒体当作第0层。</p><p>功能一：定义接口特性</p><p>功能二：定义传输模式（单工、半双工、双工）</p><p>功能三：定义传输速率</p><p>功能四：比特同步</p><p>功能五：比特编码</p><h2 id="4-TCP-IP模型与OSI参考模型的比较"><a class="header-anchor" href="#4-TCP-IP模型与OSI参考模型的比较"></a>4 TCP/IP模型与OSI参考模型的比较</h2><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%8D%E5%90%8C%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B.png" alt="不同参考模型" style="object-fit: cover; border-radius: 10px; width: 100%;" /><p>OSI参考模型与TCP/IP参考模型相同点</p><ol><li>首先，二者都采取分层的体系结构，将庞大且复杂的问题划分为若干较容易处理的、范围较小的问题，而且分层的功能也大体相似。</li><li>其次，二者都是基于独立的协议栈的概念。</li><li>最后，二者都可以解决异构网络的互联，实现世界上不同厂家生产的计算机之间的通信。</li></ol><p>OSI参考模型与TCP/IP参考模型不同点</p><ol><li>OSI参考模型的最大贡献就是精确定义了三个主要概念：服务、协议和接口，这与现代的面向对象程序设计思想非常吻合。而 TCP/IP 模型在这三个概念上却没有明确区分，不符合软件工程的思想。</li><li>OSI参考模型产生在协议发明之前，没有偏向于任何特定的协议，通用性良好。但设计者在协议方面没有太多经验，不知道把哪些功能放到哪一层更好。TCP/IP模型正好相反，首先出现的是协议，模型实际上是对已有协议的描述，因此不会出现协议不能匹配模型的情况，但该模型不适合于任何其他非TCP/IP的协议栈。</li><li>TCP/IP 模型在设计之初就考虑到了多种异构网的互联问题，并将网际协议（ IP ）作为一个单独的重要层次。OSI 参考模型最初只考虑到用一种标准的公用数据网将各种不同的系统互联。OSI参考模型认识到网际协议 IP 的重要性后，只好在网络层中划分出一个子层来完成类似于 TCP/IP 模型中的 IP 的功能。</li><li>OSI参考模型在网络层支持无连接和面向连接的通信，但在传输层仅有面向连接的通信。而 TCP/IP 模型认为可靠性是端到端的问题，因此它在网际层仅有一种无连接的通信模式，但传输层支持无连接和面向连接两种模式。这个不同点常常作为考查点。</li></ol><blockquote><p>面向连接分为三个阶段，第一是建立连接，在此阶段，发出一个建立连接的请求。只有在连接成功建立之后，才能开始数据传输，这是第二阶段。接着，当数据传输完毕，必须释放连接。而面向无连接没有这么多阶段，它直接进行数据传输。</p></blockquote><p>无连接和面向连接</p><table><thead><tr><th>模型</th><th>ISO/OSI参考模型</th><th>TCP/IP模型</th></tr></thead><tbody><tr><td>网络层</td><td>无连接+面向连接</td><td>无连接</td></tr><tr><td>传输层</td><td>面向连接</td><td>无连接+面向连接</td></tr></tbody></table><p>无论是 OSI 参考模型还是 TCP/IP 模型，都不是完美的，对二者的讨论和批评都很多。OSI 参考模型的设计者从工作的开始，就试图建立一个全世界的计算机网络都要遵循的统一标准。 从技术角度来看，他们希望追求一种完美的理想状态，这也导致基于 OSI 参考模型的软件效率极低。OSI参考模型缺乏市场与商业动力，结构复杂，实现周期长，运行效率低，这是它未能达到预期目标的重要原因</p><p>学习计算机网络时，我们往往采取折中的办法，即综合 OSI 和 TCP/IP 的优点，采用一种如图1.13所示的只有五层协议的体系结构，即我们所熟知的物理层、数据链路层、网络层、传输层和应用层。本书也采用这种体系结构进行讨论。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E7%9A%84%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E5%9E%8B.png" alt="图1.13 网络的五层协议结构模型" style="object-fit: cover; border-radius: 10px; width: 100%;" /><p>最后简单介绍使用通信协议栈进行通信的结点的数据传输过程。每个协议栈的最顶端都是一个面向用户的接口，下面各层是为通信服务的协议。用户传输一个数据报时，通常给出用户能够理解的自然语言，然后通过应用层，将自然语言会转化为用于通信的通信数据。通信数据到达传输层，作为传输层的数据部分（传输层SDU），加上传输层的控制信息（传输层PCI），组成传输层的 PDU ,然后交到网络层，传输层的PDU下放到网络层后，就成为网络层的SDU，然后加上网络层的 PCI ，又组成了网络层的PDU，下放到数据链路层，就这样层层下放，层层包裹，最后形成的数据报通过通信线路传输，到达接收方结点协议栈，接收方再逆向地逐层把“包裹”拆开，然后把收到的数据提交给用户，如下图所示。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E6%A0%88%E7%9A%84%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B%E7%A4%BA%E4%BE%8B.png" alt="图1.14 通信协议栈的通信过程示例" style="object-fit: cover; border-radius: 10px; width: 100%;" />]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>考研资料收集</title>
      <link href="2021/04/21/%E8%80%83%E7%A0%94/%E8%80%83%E7%A0%94%E8%B5%84%E6%96%99%E6%94%B6%E9%9B%86/"/>
      <url>2021/04/21/%E8%80%83%E7%A0%94/%E8%80%83%E7%A0%94%E8%B5%84%E6%96%99%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<Script Language="JavaScript"> 　　var timedate= new Date("December 25,2021"); 　　var times="研究生考试"; 　　var now = new Date(); 　　var date = timedate.getTime() - now.getTime(); 　　var time = Math.floor(date / (1000 * 60 * 60 * 24)); 　　if (time >= 0) ; document.write("<div title='初试时间预测为2021年12月24日-25日，12月倒数第二周的周六周日，具体时间以教育局公布为准'><font color=#343a40>现在离2022年"+times+"还有: <font color=#dc3545><b>"+time +"</b></font> 天</font></div>"); </Script> <h2 id="📚考研资料"><a class="header-anchor" href="#📚考研资料"></a>📚考研资料</h2><p><a href="https://mp.weixin.qq.com/s/5TNZQG0QBWf1IrOd8L9NGA">好好考研公众号，网课推荐</a><br><a href="https://note.youdao.com/ynoteshare1/index.html?id=fcce8b92cbcedbcbe9b34e27c2275ea9&amp;type=note">好好考研公众号，每日更新资料</a></p><h3 id="考研英语资料"><a class="header-anchor" href="#考研英语资料"></a>考研英语资料</h3><table><thead><tr><th>2022资料</th><th>百度云盘链接</th><th>提取码</th></tr></thead><tbody><tr><td>2022英语唐迟资料合集</td><td><a href="https://pan.baidu.com/s/12KUkxOukT-QIBbpJgO6R7A">云盘链接</a></td><td>ufh6</td></tr><tr><td>2022英语刘晓燕资料合集（高教版）</td><td><a href="https://pan.baidu.com/s/1RLFcQ6KLDwsWk5euTmbv0A">云盘链接</a></td><td>fa7q</td></tr><tr><td>2022英语刘晓燕资料合集（启航版）</td><td><a href="https://pan.baidu.com/s/1XAkWIgmBG1vXdHkeC0e7dA">云盘链接</a></td><td>jbpg</td></tr><tr><td>2022英语朱伟资料合集</td><td><a href="http://pan.baidu.com/s/1rEFa8e0-7Qm11fJo9T0aNQ">云盘链接</a></td><td>u985</td></tr></tbody></table><hr><table><thead><tr><th>2021资料</th><th>百度云盘链接</th><th>提取码</th></tr></thead><tbody><tr><td>2021英语唐迟资料合集</td><td><a href="https://pan.baidu.com/s/1-bIRqHH_N6A6xuDX3eEw5Q">云盘链接</a></td><td>bgfa</td></tr><tr><td>2021英语刘晓燕资料合集（高教版）</td><td><a href="https://pan.baidu.com/s/1YneD1u3YhbXl5yKPVzM2CQ">云盘链接</a></td><td>4h97</td></tr><tr><td>2021英语刘晓燕资料合集（启航版）</td><td><a href="https://pan.baidu.com/s/1vmlzGjD4YwG_JcHoNW9Hmw">云盘链接</a></td><td>tbuh</td></tr></tbody></table><h3 id="考研政治资料"><a class="header-anchor" href="#考研政治资料"></a>考研政治资料</h3><table><thead><tr><th>2022资料</th><th>百度云盘链接</th><th>提取码</th></tr></thead><tbody><tr><td>2022政治徐涛资料合集</td><td><a href="https://pan.baidu.com/s/1oX7YB9pN5fRNnfHttEidwA">云盘链接</a></td><td>phyg</td></tr></tbody></table><hr><table><thead><tr><th>2021资料</th><th>百度云盘链接</th><th>提取码</th></tr></thead><tbody><tr><td>2021政治肖秀荣资料合集</td><td><a href="https://pan.baidu.com/s/1oL_EwF0WwOhYih0SVNqbXg">云盘链接</a></td><td>gbwk</td></tr><tr><td>2021政治徐涛资料合集</td><td><a href="https://pan.baidu.com/s/1jHTsjdSYc6qfhTtp0lE5KA">云盘链接</a></td><td>73rf</td></tr></tbody></table><h3 id="考研数学资料"><a class="header-anchor" href="#考研数学资料"></a>考研数学资料</h3><table><thead><tr><th>2022资料</th><th>百度云盘链接</th><th>提取码</th></tr></thead><tbody><tr><td>2022数学汤家凤资料合集（文都版）</td><td><a href="https://pan.baidu.com/s/1pSWXHJfDzou_5x7lMvjKuA">云盘链接</a></td><td>49sj</td></tr><tr><td>2022数学汤家凤资料合集（新文道版）</td><td><a href="https://pan.baidu.com/s/1KwaRNs0yLBEV9GgEgWIhWQ">云盘链接</a></td><td>a678</td></tr><tr><td>2022数学武忠祥资料合集</td><td><a href="https://pan.baidu.com/s/1QSwjqeTShMwf5uwUNykWRw">云盘链接</a></td><td>sjnp</td></tr><tr><td>2022数学张宇资料合集</td><td><a href="https://pan.baidu.com/s/1J81U7MXeBZUrJb-b2X3sYw">云盘链接</a></td><td>gshh</td></tr><tr><td>2022数学李永乐资料合集</td><td><a href="https://pan.baidu.com/s/1HPVw62L5B2X1fZ1rEqTyTg">云盘链接</a></td><td>u985</td></tr></tbody></table><hr><table><thead><tr><th>2021资料</th><th>百度云盘链接</th><th>提取码</th></tr></thead><tbody><tr><td>2021数学汤家凤资料合集</td><td><a href="https://pan.baidu.com/s/1Vcv3UWsxbBNopIqeyXQcwg">云盘链接</a></td><td>kxvq</td></tr></tbody></table><h3 id="计算机408资料"><a class="header-anchor" href="#计算机408资料"></a>计算机408资料</h3><table><thead><tr><th>2022资料</th><th>百度云盘链接</th><th>提取码</th></tr></thead><tbody><tr><td>2022年计算机资料合集</td><td><a href="https://pan.baidu.com/s/1ADIdKQ_xHOnhgetC1ZiRqA">云盘链接</a></td><td>gihh</td></tr></tbody></table><hr><table><thead><tr><th>2021资料</th><th>百度云盘链接</th><th>提取码</th></tr></thead><tbody><tr><td>2021年计算机资料合集</td><td><a href="https://pan.baidu.com/s/1PKi1g5N03f3nt40TUIX7uA">云盘链接</a></td><td>q5xg</td></tr><tr><td>2021年计算机资料合集</td><td><a href="https://pan.baidu.com/s/1Rcwo6MYwEJZQOvq7KzkXFA">云盘链接</a></td><td>3333</td></tr></tbody></table><br/><blockquote><p>资料来源：<a href="https://mp.weixin.qq.com/s/Knp9-UbYStQXAS3vjuDZrA">研料库公众号</a>、好好考研</p></blockquote><h3 id="其他资料"><a class="header-anchor" href="#其他资料"></a>其他资料</h3><p>微信公众号：</p><ul><li>给力考研资料</li><li>好好考研</li><li>槟果考研</li><li>小白考研</li><li>灰灰考研(计算机)</li></ul><p>官方<a href="https://yz.chsi.com.cn/">中国研究生招生信息网(研招网)</a></p><h2 id="🧭知乎有关问题及回答"><a class="header-anchor" href="#🧭知乎有关问题及回答"></a>🧭知乎有关问题及回答</h2><p><a href="https://zhuanlan.zhihu.com/p/352816017">2022考研全程复习规划</a><br><a href="https://www.zhihu.com/question/20462634/answer/728661676">考研规划，看这一篇就够了！</a><br><a href="https://zhuanlan.zhihu.com/p/72965483">考研资料书推荐大全+考研经验分享</a></p><h3 id="各大院校官网"><a class="header-anchor" href="#各大院校官网"></a>各大院校官网</h3><h2 id="📆考研公共课规划"><a class="header-anchor" href="#📆考研公共课规划"></a>📆考研公共课规划</h2>]]></content>
      
      
      <categories>
          
          <category> 考研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计划与记录</title>
      <link href="2021/04/18/%E8%A7%84%E5%88%92/%E8%AE%A1%E5%88%92%E4%B8%8E%E8%AE%B0%E5%BD%95/"/>
      <url>2021/04/18/%E8%A7%84%E5%88%92/%E8%AE%A1%E5%88%92%E4%B8%8E%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="⏳自律的人有多可怕"><a class="header-anchor" href="#⏳自律的人有多可怕"></a>⏳自律的人有多可怕</h2><ul><li>我的梦想到底是什么，我有为此付出过什么吗</li><li>无特殊情况，一天至少8小时考研学习时间</li><li>其中每天原神时间不超过40分钟</li><li>不许带手机到床上</li><li>1点前要睡觉</li><li>锻炼？</li></ul><h2 id="📝每日计划及记录"><a class="header-anchor" href="#📝每日计划及记录"></a>📝每日计划及记录</h2><h3 id="2021年4月24日"><a class="header-anchor" href="#2021年4月24日"></a>2021年4月24日</h3><ul><li>[ ] 17:30，一号楼二阶二，党日活动</li></ul><h3 id="2021年4月23日"><a class="header-anchor" href="#2021年4月23日"></a>2021年4月23日</h3><table><thead><tr><th>内容</th><th>备注</th><th>用时</th><th>完成情况</th></tr></thead><tbody><tr><td>数据结构完成前两章整理学习内容</td><td></td><td></td><td></td></tr><tr><td>线性代数矩阵整理学习</td><td></td><td></td><td></td></tr><tr><td>高等数学复习函数</td><td></td><td></td><td></td></tr><tr><td>学习英语7000词1P</td><td></td><td></td><td></td></tr></tbody></table><h3 id="2021年4月22日"><a class="header-anchor" href="#2021年4月22日"></a>2021年4月22日</h3><p><strong>待办事项</strong></p><ul><li>[X] 17:30-18:55，一号楼204，形势与政策</li><li>[X] 进化生物学作业</li></ul><p><strong>考研规划表</strong></p><table><thead><tr><th>内容</th><th>备注</th><th>用时</th><th>完成情况</th></tr></thead><tbody><tr><td>学完操作系统第2章</td><td>学到<a href="https://www.bilibili.com/video/BV1YE411D7nH?t=4&amp;p=33">P33</a></td><td>5h</td><td>✔</td></tr><tr><td>学1P题源7000词</td><td>学完<a href="https://www.bilibili.com/video/BV12E411B7A5?p=3&amp;spm_id_from=pageDriver">P2</a></td><td>2.5h</td><td>✔</td></tr><tr><td>对计算机网络前两章进行复习整理</td><td></td><td>20min</td><td>✔</td></tr><tr><td>对数据结构前两章进行复习整理</td><td></td><td></td><td>❌</td></tr><tr><td>对计算机组成原理前两章进行复习整理</td><td></td><td></td><td>❌</td></tr><tr><td>可以的话对线性代数第一章进行复习整理</td><td></td><td></td><td>❌</td></tr></tbody></table><p><strong>时间统计</strong></p><table><thead><tr><th>项目</th><th>时间</th><th>备注</th></tr></thead><tbody><tr><td>Typora</td><td>5:59:20</td><td>写文档</td></tr><tr><td>浏览器</td><td>4:34:39</td><td>学习课程</td></tr><tr><td>原神</td><td>0:46:09</td><td>日常任务，9次火本</td></tr><tr><td>进化生物学作业</td><td>40min左右</td><td></td></tr></tbody></table><details><summary>2021年4月22日小结</summary><p>今天学了不少内容，但是通过做题发现学的不够深，还需要及时复习。</p><p>至于下一阶段，我觉得先开始复习数据结构，数学，以及英语，这些数据结构和数学对计组、网络和操作系统记忆内容相对较少，可以先复习，英语要坚持下去。政治等这些课程一轮复习完成后在开始背吧。</p></details><h3 id="2021年4月21日"><a class="header-anchor" href="#2021年4月21日"></a>2021年4月21日</h3><table><thead><tr><th>内容</th><th>备注</th><th>用时</th><th>完成情况</th></tr></thead><tbody><tr><td>学习操作系统并进行相关资料整理</td><td>从<a href="https://www.bilibili.com/video/BV1YE411D7nH?p=22&amp;spm_id_from=pageDriver">P16-P22</a></td><td>4h</td><td>✔</td></tr><tr><td>学习数据结构</td><td></td><td></td><td>❌</td></tr><tr><td>学单词</td><td><a href="https://www.bilibili.com/video/BV12E411B7A5?t=2948">P1 50:00</a></td><td></td><td>✔</td></tr></tbody></table><p><strong>时间统计</strong></p><table><thead><tr><th>项目</th><th>时间</th><th>备注</th></tr></thead><tbody><tr><td>浏览器</td><td>8:05:25</td><td>整理资料，学习课程</td></tr><tr><td>Typora</td><td>4:15:40</td><td>写文档</td></tr><tr><td>原神</td><td>0:15:09</td><td>日常任务</td></tr></tbody></table><details><summary>2021年4月21日小结</summary><p>今天整理了有关<a href="http://blog.halo123.top:8090/archives/%E8%80%83%E7%A0%94%E8%B5%84%E6%96%99%E6%94%B6%E9%9B%86">考研资料</a>，也对考研计划进行了细化，还有有好多任务需要完成</p><blockquote><p>Doctor，您还有许多事要处理，现在还不能休息（阿米娅_严肃）</p></blockquote><p>时间主要花在了收集和整理资料中，也是通过对资料的整理才更清楚自己要学些什么，对于基础相对薄弱的科目(说的就是你英语)，还是要老老实实看视频跟着老师去学，一些规律还是要有一定经验的人教授才更方便理解。</p><p>而学不在于学多少，在于有多少被吸收成为自己的知识。之前没注意考研时间，现在发现只剩下246天，对我来说时间是有些紧张了。</p><p>最近有关的一些社会新闻，就如特斯拉维权频频出现在消息中。<a href="https://t.bilibili.com/516161348504803949?tab=2">中消协对此事回应</a></p><p>顺便一提，今天发布的 M1 芯片的 Ipad Pro 确实有些在我的意料之外，但也是情理之中，打通各平台的生态圈，这是其他品牌难以做到的一件事，这也会成为苹果公司一张大牌，只能说技术是产品竞争的关键。</p></details><h3 id="2021年4月20日"><a class="header-anchor" href="#2021年4月20日"></a>2021年4月20日</h3><p><strong>每日计划</strong></p><ul><li>[X] 学习前端，<a href="https://www.bilibili.com/video/BV1pE411q7FU?p=84&amp;spm_id_from=pageDriver">Web前端入门教程 P61-P84</a></li><li>[ ] 学习操作系统并整理资料</li><li>[ ] 学习数据结构</li><li>[ ] 背单词</li><li>[X] 15:00至16:00，红船边的思政课主题直播活动。今晚10点前上交一份观后感（字数不得少于400字）</li></ul><p><strong>时间统计</strong></p><table><thead><tr><th>项目</th><th>时间</th><th>备注</th></tr></thead><tbody><tr><td>浏览器</td><td>6:07:42</td><td>看视频，学前端课程，写博客，看B站动态，看知乎</td></tr><tr><td>Typora</td><td>1:03:26</td><td>写观后感，写博客</td></tr><tr><td>原神</td><td>0:48:09</td><td>日常任务，龙，4浓缩树脂，9层深渊</td></tr><tr><td>Word</td><td>0:12:20</td><td>写观后感</td></tr></tbody></table><details><summary>2021年4月20日小结</summary><p>几天晚上上完课回来，写了观后感后，在b站看到央视新闻的<a href="https://t.bilibili.com/515733926241528411">动态</a>，被评论区@到一个<a href="https://space.bilibili.com/23947287">UP</a>，为了吃瓜看了些视频，结果越看越深，看的视频如下：</p><ul><li><a href="https://www.bilibili.com/video/BV11i4y1L7QQ">苏联为何而强大？【小约翰】</a></li><li><a href="https://www.bilibili.com/video/BV1zZ4y1H7h2">你真的了解切格瓦拉吗？带你走进精神领袖伟大的一生【历史故事会】</a></li><li><a href="https://www.bilibili.com/video/BV1Z54y1m7FB">美国是如何走向世界舞台的【财经故事会】</a></li><li><a href="https://www.bilibili.com/video/BV1fk4y1B7tv">兔子的大布局：人民币国际化</a></li><li><a href="https://www.bilibili.com/video/BV1NT4y1j7J8">何以成为苏联争议最大的领导人？带你走进斯大林波澜壮阔的一生【有机社会Vol.16】</a></li><li><a href="https://www.bilibili.com/video/BV1m54y1Y7r3">我们到底在走一条什么路？共同富裕最终能实现吗？【有机社会32】</a></li></ul><p>对于视频中的一些观点需要辩证的看待，从侧面也反映出我的历史知识的匮乏，在感想中我写到</p><blockquote><p>学党史，学的不仅是历史，更是精神，而很多精神难以从黑白纸张中感受到，当与物与人与环境，多方面多角度的“对话”，一件历史中发生的某些事的细节可能会忘记，但是历史带给我们的激励作用将会一直伴随。</p></blockquote><p>历史的重要性不言而喻，而我想要了解真实的历史是一件非常难的事，仅从现在来看，我们正处于未来的历史当中，疫情、日本核排放这些事终将会写入历史书中，但身处历史中也难以了解全貌，更何况用十多分钟的视频来概括一个世纪的故事。我们站在制高点俯瞰和中山底仰视看到的风景是截然不同的。</p><p>突然想到，我之前也这样写过总结，打开看竟是去年9月开始的时候，emm只坚持了两天，话说也过去了怎么久了，当再次看到当时的总结，感觉回忆突然涌了上来，这是真的。相比较不知不觉中过日子，不如让每天都有纪念意义，我曾经以为仪式是虚的，但现在就当做开始记录的小仪式吧。感觉有点自言自语有些奇怪。</p><p>正经人谁写日记啊，我又不是什么正经人，ko no ya rou ！</p></details><h3 id="2021年4月19日"><a class="header-anchor" href="#2021年4月19日"></a>2021年4月19日</h3><ul><li>[X] 学习前端，<a href="https://www.bilibili.com/video/BV1pE411q7FU?p=61&amp;spm_id_from=pageDriver">Web前端入门教程 P42-P61</a></li><li>[ ] 学习操作系统并整理资料</li><li>[ ] 学习数据结构</li><li>[ ] 背单词</li></ul><details><summary>2021年4月19日小结</summary><ul><li>打疫苗</li><li>看《哥斯拉大战金刚》体验不是很好，声音太大了，3D还是带夹片吧，对近视很不友好</li></ul></details><h3 id="2021年4月18日"><a class="header-anchor" href="#2021年4月18日"></a>2021年4月18日</h3><ul><li>[X] 学习前端，<a href="https://www.bilibili.com/video/BV1pE411q7FU?p=42&amp;spm_id_from=pageDriver">Web前端入门教程 P1-P41 </a></li></ul><details><summary>2021年4月18日小结</summary><p>知乎上看到的中科院自动化所的博士论文致谢的消息。<a href="https://www.zhihu.com/question/454961393">网站链接</a></p><p>看完后也是十分触动，我也是农村出来的，不富裕，而生活在现在的环境中让我产生了逃避的想法，一箪食一瓢饮的生活对我来说并没有什么不好，但对于社会环境来说，只是要活的体面，照成贫穷原因有很多，与环境与自身，当上一辈人确实因为环境等因素制约了发展，但对于我来说，有着足够的条件来过上好生活，但如果还不向上努力，便是自身的因素。我可以选择过平淡的人生，但是我也从来不是没有独立思想，随波逐流的人。</p><p>屈原与渔夫的故事我印象非常深，选择“宁赴湘流，葬于江鱼之腹中。安能以皓皓之白，而蒙世俗之尘埃乎”与“沧浪之水清兮，可以濯吾缨；沧浪之水浊兮，可以濯吾足。”那时候我的答案是屈原，当别人多数人选择了渔夫时，我是有些不解，但这快4年下来，我也渐渐被“磨平棱角”，这件事没有谁对谁错，如果以马原来选择那就是”因地制宜“，总之有些晚了我要碎觉了。</p></details><h2 id="每周任务"><a class="header-anchor" href="#每周任务"></a>每周任务</h2><h3 id="2021年第15周"><a class="header-anchor" href="#2021年第15周"></a>2021年第15周</h3><ul><li>[X] 青年大学习</li><li>[ ] 看一篇英文文献并记录</li></ul><h2 id="每月计划"><a class="header-anchor" href="#每月计划"></a>每月计划</h2><h3 id="2021年4月"><a class="header-anchor" href="#2021年4月"></a>2021年4月</h3><table><thead><tr><th>计划内容</th><th>创建</th><th>开始时间</th><th>计划结束时间</th><th>结果</th></tr></thead><tbody><tr><td>学完《操作系统》</td><td>2021年4月21日00点22分</td><td></td><td></td><td></td></tr></tbody></table><h2 id="考研各项目规划"><a class="header-anchor" href="#考研各项目规划"></a>考研各项目规划</h2><h3 id="操作系统"><a class="header-anchor" href="#操作系统"></a>操作系统</h3><table><thead><tr><th>学习内容</th><th>开始时间</th><th>结束时间</th><th>学习结果</th></tr></thead><tbody><tr><td>计算机系统概述</td><td>2021年3月29日</td><td>2021年3月31日</td><td><a href="http://blog.halo123.top:8090/archives/overviewofcomputersystems">文章链接</a></td></tr><tr><td>进程管理</td><td>2021年4月1日</td><td>2021年4月22日</td><td><a href="http://blog.halo123.top:8090/archives/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86">文章链接</a></td></tr><tr><td>内存管理</td><td></td><td></td><td></td></tr><tr><td>文件管理</td><td></td><td></td><td></td></tr><tr><td>I/O管理</td><td></td><td></td><td></td></tr></tbody></table><h3 id="数据结构"><a class="header-anchor" href="#数据结构"></a>数据结构</h3><table><thead><tr><th>学习内容</th><th>开始时间</th><th>结束时间</th><th>学习结果</th></tr></thead><tbody><tr><td>绪论</td><td>3月</td><td>3月</td><td></td></tr><tr><td>线性表</td><td>3月</td><td>3月</td><td></td></tr><tr><td>栈和队列</td><td>3月</td><td></td><td></td></tr><tr><td>串</td><td></td><td></td><td></td></tr><tr><td>树和二叉树</td><td></td><td></td><td></td></tr><tr><td>图</td><td></td><td></td><td></td></tr><tr><td>查找</td><td></td><td></td><td></td></tr><tr><td>排序</td><td></td><td></td><td></td></tr></tbody></table><h3 id="计算机组成原理"><a class="header-anchor" href="#计算机组成原理"></a>计算机组成原理</h3><table><thead><tr><th>学习内容</th><th>开始时间</th><th>结束时间</th><th>学习结果</th></tr></thead><tbody><tr><td>计算机系统概述</td><td>3月</td><td>3月</td><td></td></tr><tr><td>数据的表示和运算</td><td>3月</td><td></td><td></td></tr><tr><td>储存系统</td><td></td><td></td><td></td></tr><tr><td>指令系统</td><td></td><td></td><td></td></tr><tr><td>中央处理器</td><td></td><td></td><td></td></tr><tr><td>总线</td><td></td><td></td><td></td></tr><tr><td>输入/输出系统</td><td></td><td></td><td></td></tr></tbody></table><h3 id="计算机网络"><a class="header-anchor" href="#计算机网络"></a>计算机网络</h3><table><thead><tr><th>学习内容</th><th>开始时间</th><th>结束时间</th><th>学习结果</th></tr></thead><tbody><tr><td>计算机网络体系结构</td><td>3月</td><td>3月</td><td></td></tr><tr><td>物理层</td><td>3月</td><td>3月</td><td></td></tr><tr><td>数据链路层</td><td></td><td></td><td></td></tr><tr><td>网络层</td><td></td><td></td><td></td></tr><tr><td>传输层</td><td></td><td></td><td></td></tr><tr><td>应用层</td><td></td><td></td><td></td></tr></tbody></table><h3 id="线性代数"><a class="header-anchor" href="#线性代数"></a>线性代数</h3><table><thead><tr><th>学习内容</th><th>开始时间</th><th>结束时间</th><th>学习结果</th></tr></thead><tbody><tr><td>行列式</td><td>3月</td><td>3月</td><td></td></tr><tr><td>矩阵</td><td>3月</td><td></td><td></td></tr><tr><td>向量</td><td></td><td></td><td></td></tr><tr><td>线性方程组</td><td></td><td></td><td></td></tr><tr><td>特征值和特征向量</td><td></td><td></td><td></td></tr><tr><td>二次型</td><td></td><td></td><td></td></tr></tbody></table><h3 id="概率论与梳理统计"><a class="header-anchor" href="#概率论与梳理统计"></a>概率论与梳理统计</h3><table><thead><tr><th>学习内容</th><th>开始时间</th><th>结束时间</th><th>学习结果</th></tr></thead><tbody><tr><td>随机时间和概率</td><td></td><td></td><td></td></tr><tr><td>随机变量及其概论分布</td><td></td><td></td><td></td></tr><tr><td>多维随机变量及其分布</td><td></td><td></td><td></td></tr><tr><td>随机变量的数字特征</td><td></td><td></td><td></td></tr><tr><td>大数定理和中心极限定理</td><td></td><td></td><td></td></tr><tr><td>数理统计的基本概念</td><td></td><td></td><td></td></tr><tr><td>参数估计</td><td></td><td></td><td></td></tr><tr><td>假设检验</td><td></td><td></td><td></td></tr></tbody></table><h3 id="高等数学"><a class="header-anchor" href="#高等数学"></a>高等数学</h3><table><thead><tr><th>学习内容</th><th>开始时间</th><th>结束时间</th><th>学习结果</th></tr></thead><tbody><tr><td>函数、极限、连续</td><td></td><td></td><td></td></tr><tr><td>导数与微分</td><td></td><td></td><td></td></tr><tr><td>微分中值定理及导数应用</td><td></td><td></td><td></td></tr><tr><td>不定积分</td><td></td><td></td><td></td></tr><tr><td>定积分与反常积分</td><td></td><td></td><td></td></tr><tr><td>定积分的应用</td><td></td><td></td><td></td></tr><tr><td>微分方程</td><td></td><td></td><td></td></tr><tr><td>多元函数微分学</td><td></td><td></td><td></td></tr><tr><td>二重积分</td><td></td><td></td><td></td></tr><tr><td>无穷级数</td><td></td><td></td><td></td></tr><tr><td>向量代数与空间解析几何及多元微分学在几何上的应用</td><td></td><td></td><td></td></tr><tr><td>多元积分学及其应用</td><td></td><td></td><td></td></tr></tbody></table><h3 id="思想道德修养与法律基础"><a class="header-anchor" href="#思想道德修养与法律基础"></a>思想道德修养与法律基础</h3><h3 id="毛泽东思想和中国特色社会主义理论体系概论"><a class="header-anchor" href="#毛泽东思想和中国特色社会主义理论体系概论"></a>毛泽东思想和中国特色社会主义理论体系概论</h3><h3 id="马克思主义基本原理概论"><a class="header-anchor" href="#马克思主义基本原理概论"></a>马克思主义基本原理概论</h3><h3 id="中国近代史纲要"><a class="header-anchor" href="#中国近代史纲要"></a>中国近代史纲要</h3><h3 id="英语词汇"><a class="header-anchor" href="#英语词汇"></a>英语词汇</h3><table><thead><tr><th>学习内容</th><th>开始时间</th><th>结束时间</th><th>学习结果</th></tr></thead><tbody><tr><td>题源报刊7000词Unit 1</td><td>2021年4月21日</td><td></td><td></td></tr></tbody></table><h3 id="英语语法"><a class="header-anchor" href="#英语语法"></a>英语语法</h3><h3 id="英语核心长难句"><a class="header-anchor" href="#英语核心长难句"></a>英语核心长难句</h3><h3 id="英语强化练习"><a class="header-anchor" href="#英语强化练习"></a>英语强化练习</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>创建型模式之简单工厂模式</title>
      <link href="2021/04/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>2021/04/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="简单工厂模式概述"><a class="header-anchor" href="#简单工厂模式概述"></a>简单工厂模式概述</h2><p>简单工厂模式并不属于GoF 23个经典设计模式，但通常将它作为学习其他工厂模式的基础，它的设计思想很简单，其基本流程如下：</p><ol><li>首先将需要创建的各种不同对象（例如各种不同的Chart对象）的相关代码封装到不同的类中，这些类称为具体产品类，而将它们公共的代码进行抽象和提取后封装在一个抽象产品类中，每一个具体产品类都是抽象产品类的子类；</li><li>然后提供一个工厂类用于创建各种产品，在工厂类中提供一个创建产品的工厂方法，该方法可以根据所传入的参数不同创建不同的具体产品对象；</li><li>客户端只需调用工厂类的工厂方法并传入相应的参数即可得到一个产品对象。</li></ol><p>简单工厂模式定义如下：</p><p>简单工厂模式(Simple Factory Pattern)：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。</p><p>因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。</p><p>简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。</p><h2 id="简单工厂模式结构"><a class="header-anchor" href="#简单工厂模式结构"></a>简单工厂模式结构</h2><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84.png" alt="简单工厂模式结构" style="object-fit: cover; border-radius: 10px; width: 100%;" /><p>在简单工厂模式结构中包含如下几个角色：</p><ul><li>Factory（工厂角色）：工厂角色即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂方法<code>factoryMethod()</code>，它的返回类型为抽象产品类型Product。</li><li>Product（抽象产品角色）：它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法，它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。</li><li>ConcreteProduct（具体产品角色）：它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法。</li></ul><h2 id="简单工厂模式实现"><a class="header-anchor" href="#简单工厂模式实现"></a>简单工厂模式实现</h2><p>在简单工厂模式中，客户端通过工厂类来创建一个产品类的实例，而无须直接使用<code>new</code>关键字来创建对象，它是工厂模式家族中最简单的一员。</p><p>在使用简单工厂模式时，首先需要对产品类进行重构，不能设计一个包罗万象的产品类，而需根据实际情况设计一个产品层次结构，将所有产品类公共的代码移至抽象产品类，并在抽象产品类中声明一些抽象方法，以供不同的具体产品类来实现，典型的抽象产品类代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="comment">//所有产品类的公共业务方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodSame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//公共方法的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//声明抽象业务方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">methodDiff</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在具体产品类中实现了抽象产品类中声明的抽象业务方法，不同的具体产品类可以提供不同的实现，典型的具体产品类代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实现业务方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodDiff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//业务方法的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单工厂模式的核心是工厂类，在没有工厂类之前，客户端一般会使用<code>new</code>关键字来直接创建产品对象，而在引入工厂类之后，客户端可以通过工厂类来创建产品，在简单工厂模式中，工厂类提供了一个静态工厂方法供客户端使用，根据所传入的参数不同可以创建不同的产品对象，典型的工厂类代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//静态工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title">getProduct</span><span class="params">(String arg)</span> </span>&#123;</span><br><span class="line">        Product product = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (arg.equalsIgnoreCase(<span class="string">&quot;A&quot;</span>)) &#123;</span><br><span class="line">            product = <span class="keyword">new</span> ConcreteProductA();</span><br><span class="line">            <span class="comment">//初始化设置product</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arg.equalsIgnoreCase(<span class="string">&quot;B&quot;</span>)) &#123;</span><br><span class="line">            product = <span class="keyword">new</span> ConcreteProductB();</span><br><span class="line">            <span class="comment">//初始化设置product</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在客户端代码中，我们通过调用工厂类的工厂方法即可得到产品对象，典型代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Product product;</span><br><span class="line">        product = Factory.getProduct(<span class="string">&quot;A&quot;</span>); <span class="comment">//通过工厂类创建产品对象</span></span><br><span class="line">        product.methodSame();</span><br><span class="line">        product.methodDiff();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单工厂模式应用实例"><a class="header-anchor" href="#简单工厂模式应用实例"></a>简单工厂模式应用实例</h2><p>通过设置不同参数即可得到不同类型的图表，且能易扩展。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B%E7%BB%93%E6%9E%84.png" alt="简单工厂模式应用实例结构" style="object-fit: cover; border-radius: 20px; width: 100%;" /><p><code>Chart</code>接口充当抽象产品类，其子类<code>HistogramChart</code>、<code>PieChart</code>和<code>LineChart</code>充当具体产品类，<code>ChartFactory</code>充当工厂类。完整代码如下所示：</p><ol><li><p><code>Chart</code>：抽象图表接口，充当抽象产品类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Chart</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>HistogramChart</code>：柱状图类，充当具体产品类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HistogramChart</span> <span class="keyword">implements</span> <span class="title">Chart</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HistogramChart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;创建柱状图！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;显示柱状图！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>PieChart</code>：饼状图类，充当具体产品类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PieChart</span> <span class="keyword">implements</span> <span class="title">Chart</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PieChart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;创建饼状图！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;显示饼状图！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>LineChart</code>：折线图类，充当具体产品类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineChart</span> <span class="keyword">implements</span> <span class="title">Chart</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LineChart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;创建折线图！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;显示折线图！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>ChartFactory</code>：图表工厂类，充当工厂类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChartFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//静态工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Chart <span class="title">getChart</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        Chart chart = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">&quot;histogram&quot;</span>)) &#123;</span><br><span class="line">            chart = <span class="keyword">new</span> HistogramChart();</span><br><span class="line">            System.out.println(<span class="string">&quot;初始化设置柱状图！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">&quot;pie&quot;</span>)) &#123;</span><br><span class="line">            chart = <span class="keyword">new</span> PieChart();</span><br><span class="line">            System.out.println(<span class="string">&quot;初始化设置饼状图！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">&quot;line&quot;</span>)) &#123;</span><br><span class="line">            chart = <span class="keyword">new</span> LineChart();</span><br><span class="line">            System.out.println(<span class="string">&quot;初始化设置折线图！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chart;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>Client</code>：客户端测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Chart chart;</span><br><span class="line">        chart = ChartFactory.getChart(<span class="string">&quot;histogram&quot;</span>); <span class="comment">//通过静态工厂方法创建产品</span></span><br><span class="line">        chart.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>编译并运行程序，输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">创建柱状图！</span><br><span class="line">初始化设置柱状图！</span><br><span class="line">显示柱状图！</span><br></pre></td></tr></table></figure><p>在客户端测试类中，我们使用工厂类的静态工厂方法创建产品对象，如果需要更换产品，只 需修改静态工厂方法中的参数即可，例如将柱状图改为饼状图，只需将代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chart = ChartFactory.getChart(<span class="string">&quot;histogram&quot;</span>);</span><br></pre></td></tr></table></figure><p>改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chart = ChartFactory.getChart(<span class="string">&quot;pie&quot;</span>);</span><br></pre></td></tr></table></figure><p>编译并运行程序，输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">创建饼状图！</span><br><span class="line">初始化设置饼状图！</span><br><span class="line">显示饼状图！</span><br></pre></td></tr></table></figure><p>不难发现在创建具体<code>Chart</code>对象时，每更换一个<code>Chart</code>对象都需要修改客户端代码中静态工厂方法的参数，客户端代码将要重新编译，这对于客户端而言，违反了“开闭原则”，有没有一种方法能够在不修改客户端代码的前提下更换具体产品对象呢？答案是肯定的，下面将介绍一种常用的实现方式。</p><p>我们可以将静态工厂方法的参数存储在XML或properties格式的配置文件中，如下config.xml所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">chartType</span>&gt;</span>histogram<span class="tag">&lt;/<span class="name">chartType</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>再通过一个工具类XMLUtil来读取配置文件中的字符串参数，XMLUtil类的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.xml.parsers.*;</span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.*;</span><br><span class="line"><span class="keyword">import</span> org.xml.sax.SAXException;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XMLUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">//该方法用于从XML配置文件中提取图表类型，并返回类型名</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getChartType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建文档对象</span></span><br><span class="line">            DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance();</span><br><span class="line">            DocumentBuilder builder = dFactory.newDocumentBuilder();</span><br><span class="line">            Document doc;</span><br><span class="line">            doc = builder.parse(<span class="keyword">new</span> File(<span class="string">&quot;config.xml&quot;</span>));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//获取包含图表类型的文本节点</span></span><br><span class="line">            NodeList nl = doc.getElementsByTagName(<span class="string">&quot;chartType&quot;</span>);</span><br><span class="line">            Node classNode = nl.item(<span class="number">0</span>).getFirstChild();</span><br><span class="line">            String chartType = classNode.getNodeValue().trim();</span><br><span class="line">            <span class="keyword">return</span> chartType;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在引入了配置文件和工具类<code>XMLUtil</code>之后，客户端代码修改如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Chart chart;</span><br><span class="line">        String type = XMLUtil.getChartType(); <span class="comment">//读取配置文件中的参数</span></span><br><span class="line">        chart = ChartFactory.getChart(type); <span class="comment">//创建产品对象</span></span><br><span class="line">        chart.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难发现，在上述客户端代码中不包含任何与具体图表对象相关的信息，如果需要更换具体图表对象，只需修改配置文件config.xml，无须修改任何源代码，符合“开闭原则”。</p><h2 id="简单工厂模式的简化"><a class="header-anchor" href="#简单工厂模式的简化"></a>简单工厂模式的简化</h2><p>有时候，为了简化简单工厂模式，我们可以将抽象产品类和工厂类合并，将静态工厂方法移至抽象产品类中，如图所示：</p><p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%AE%80%E5%8C%96%E7%BB%93%E6%9E%84.png" alt="简单工厂模式的简化结构"></p><p>客户端可以通过产品父类的静态工厂方法，根据参数的不同创建不同类型的产品子 类对象，这种做法在JDK等类库和框架中也广泛存在。</p><h2 id="简单工厂模式总结"><a class="header-anchor" href="#简单工厂模式总结"></a>简单工厂模式总结</h2><h3 id="简单工厂模式优点"><a class="header-anchor" href="#简单工厂模式优点"></a>简单工厂模式优点</h3><ol><li>工厂类包含必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的职责，而仅仅“消费”产品，简单工厂模式<font color="#faa755">实现了对象创建和使用的分离</font>。</li><li>客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以在一定程度减少使用者的记忆量。</li><li>通过引入配置文件，可以在<font color="#faa755">不修改任何客户端代码的情况下更换和增加新的具体产品类</font>，在一定程度上提高了系统的灵活性。</li></ol><h3 id="简单工厂模式缺点"><a class="header-anchor" href="#简单工厂模式缺点"></a>简单工厂模式缺点</h3><ol><li>由于工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响。</li><li>使用简单工厂模式势必会增加系统中类的个数（引入了新的工厂类），增加了系统的复杂度和理解难度。</li><li>系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。</li><li>简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。</li></ol><h3 id="模式适用环境"><a class="header-anchor" href="#模式适用环境"></a>模式适用环境</h3><ol><li>工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。</li><li>客户端只知道传入工厂类的参数，对于如何创建对象并不关心。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式概述及面向对象设计原则</title>
      <link href="2021/04/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0%E5%8F%8A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
      <url>2021/04/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0%E5%8F%8A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h1>设计模式概述</h1><h2 id="掌握设计模式的层次"><a class="header-anchor" href="#掌握设计模式的层次"></a>掌握设计模式的层次</h2><ol><li>第 1 层：刚开始学编程不久，听说过什么是设计模式</li><li>第 2 层：有很长时间的编程经验，自己写了很多代码，其中用到了设计模式，但是自己却不知道</li><li>第 3 层：学习过了设计模式，发现自己已经在使用了，并且发现了一些新的模式挺好用的</li><li>第 4 层：阅读了很多别人写的源码和框架，在其中看到别人设计模式，并且能够领会设计模式的精妙和带来的好处。</li><li>第 5 层：代码写着写着，自己都没有意识到使用了设计模式，并且熟练的写了出来</li></ol><h2 id="设计模式介绍"><a class="header-anchor" href="#设计模式介绍"></a>设计模式介绍</h2><ol><li>设计模式是程序员在面对同类软件工程设计问题所总结出来的有用的经验，模式不是代码，而是某类问题的通用解决方案，设计模式（Design pattern）代表了最佳的实践。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</li><li>设计模式的本质提高 软件的维护性，通用性和扩展性，并降低软件的复杂度。</li></ol><h2 id="设计模式类型"><a class="header-anchor" href="#设计模式类型"></a>设计模式类型</h2><p>设计模式分为三种类型，共 <strong>23</strong> 种</p><ol><li>创建型模式：<font color="#faa755">单例模式</font>、抽象工厂模式、原型模式、建造者模式、<font color="#faa755">工厂模式</font>。</li><li>结构型模式：适配器模式、桥接模式、<font color="#faa755">装饰模式</font>、组合模式、外观模式、享元模式、<font color="#faa755">代理模式</font>。</li><li>行为型模式：模版方法模式、命令模式、访问者模式、迭代器模式、<font color="#faa755">观察者模式</font>、中介者模式、备忘录模式、解释器模式（Interpreter 模式）、状态模式、策略模式、职责链模式(责任链模式)。</li></ol><table><thead><tr><th>模式名称</th><th>定义</th><th>学习难度</th><th>使用频率</th></tr></thead><tbody><tr><td>简单工厂模式 (Simple Factory Pattern)</td><td>定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。</td><td>★★☆☆☆</td><td>★★★☆☆</td></tr><tr><td>工厂方法模式 (Factory Method Pattern)</td><td>定义一个用于创建对象的接口，但是让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。</td><td>★★☆☆☆</td><td>★★★★★</td></tr><tr><td>抽象工厂模式 (Abstract Factory Pattern)</td><td>提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。</td><td>★★★★☆</td><td>★★★★★</td></tr><tr><td>建造者模式 (Builder Pattern)</td><td>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</td><td>★★★★☆</td><td>★★☆☆☆</td></tr><tr><td>原型模式 (Prototype Pattern)</td><td>使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象。</td><td>★★★☆☆</td><td>★★★☆☆</td></tr><tr><td>单例模式 (Singleton Pattern)</td><td>确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一实例。</td><td>★☆☆☆☆</td><td>★★★★☆</td></tr></tbody></table><h1>面向对象设计原则</h1><p>编写软件过程中，程序员面临着来自耦合性，内聚性以及可维护性，可扩展性，重用性，灵活性等多方面的挑战，设计模式是为了让程序(软件)，具有更好的：</p><ol><li>代码重用性 (即：相同功能的代码，不用多次编写)</li><li>可读性 (即：编程规范性, 便于其他程序员的阅读和理解)</li><li>可扩展性 (即：当需要增加新的功能时，非常的方便，称为可维护)</li><li>可靠性 (即：当我们增加新的功能后，对原来的功能没有影响）</li><li>使程序呈现高内聚，低耦合的特性</li></ol><h2 id="设计模式七大原则介绍"><a class="header-anchor" href="#设计模式七大原则介绍"></a>设计模式七大原则介绍</h2><p>设计模式原则，其实就是程序员在编程时，应当遵守的原则，也是各种设计模式的基础(即：设计模式为什么这样设计的依据)</p><p>设计模式常用的七大原则有:</p><ol><li>单一职责原则</li><li>接口隔离原则</li><li>依赖倒转(倒置)原则</li><li>里氏替换原则</li><li>开闭原则</li><li>迪米特法则</li><li>合成复用原则</li></ol><h2 id="单一职责原则"><a class="header-anchor" href="#单一职责原则"></a>单一职责原则</h2><h3 id="基本介绍"><a class="header-anchor" href="#基本介绍"></a>基本介绍</h3><p>单一职责原则是最简单的面向对象设计原则，它用于控制类的粒度大小。</p><p>单一职责原则(Single Responsibility Principle, SRP)：一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中。就一个类而言，应该仅有一个引起它变化的原因。</p><p>在软件系统中，一个类（大到模块，小到方法） 承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将它们封装在同一类中。</p><p>如类 A 负责两个不同职责：职责 1，职责 2。当职责 1 需求变更而改变 A 时，可能造成职责 2 执行错误，所以需要将类 A 的粒度分解为 A1，A2。</p><p>单一职责原则是实现高内聚、低耦合的指导方针，它是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关实践经验。</p><h3 id="应用实例"><a class="header-anchor" href="#应用实例"></a>应用实例</h3><h4 id="方案1"><a class="header-anchor" href="#方案1"></a>方案1</h4><ol><li>在方案1的<code>run</code>方法中，违反了单一职责原则</li><li>解决的方案非常的简单，根据交通工具运行方法不同，分解成不同类即可</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleResponsibility1</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Vehicle vehicle = <span class="keyword">new</span> Vehicle();</span><br><span class="line">vehicle.run(<span class="string">&quot;摩托车&quot;</span>);</span><br><span class="line">vehicle.run(<span class="string">&quot;汽车&quot;</span>);</span><br><span class="line">vehicle.run(<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交通工具类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123;</span><br><span class="line">System.out.println(vehicle + <span class="string">&quot; 在公路上运行....&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方案2"><a class="header-anchor" href="#方案2"></a>方案2</h4><ol><li>遵守单一职责原则</li><li>但是这样做的改动很大，即将类分解，同时修改客户端</li><li>改进：直接修改<code>Vehicle</code> 类，改动的代码会比较少=&gt;方案3</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleResponsibility2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">RoadVehicle roadVehicle = <span class="keyword">new</span> RoadVehicle();</span><br><span class="line">roadVehicle.run(<span class="string">&quot;摩托车&quot;</span>);</span><br><span class="line">roadVehicle.run(<span class="string">&quot;汽车&quot;</span>);</span><br><span class="line"></span><br><span class="line">AirVehicle airVehicle = <span class="keyword">new</span> AirVehicle();</span><br><span class="line">airVehicle.run(<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoadVehicle</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123;</span><br><span class="line">System.out.println(vehicle + <span class="string">&quot;公路运行&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AirVehicle</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123;</span><br><span class="line">System.out.println(vehicle + <span class="string">&quot;天空运行&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaterVehicle</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123;</span><br><span class="line">System.out.println(vehicle + <span class="string">&quot;水中运行&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方案3"><a class="header-anchor" href="#方案3"></a>方案3</h4><ol><li>这种修改方法没有对原来的类做大的修改，只是增加方法</li><li>这里虽然没有在类这个级别上遵守单一职责原则，但是在方法级别上，仍然是遵守单一职责</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleResponsibility3</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Vehicle vehicle  = <span class="keyword">new</span> Vehicle();</span><br><span class="line">vehicle.run(<span class="string">&quot;汽车&quot;</span>);</span><br><span class="line">vehicle.runWater(<span class="string">&quot;轮船&quot;</span>);</span><br><span class="line">vehicle.runAir(<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123;</span><br><span class="line">System.out.println(vehicle + <span class="string">&quot; 在公路上运行....&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runAir</span><span class="params">(String vehicle)</span> </span>&#123;</span><br><span class="line">System.out.println(vehicle + <span class="string">&quot; 在天空上运行....&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runWater</span><span class="params">(String vehicle)</span> </span>&#123;</span><br><span class="line">System.out.println(vehicle + <span class="string">&quot; 在水中行....&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单一职责原则注意事项和细节"><a class="header-anchor" href="#单一职责原则注意事项和细节"></a>单一职责原则注意事项和细节</h3><ol><li>降低类的复杂度，一个类只负责一项职责。</li><li>提高类的可读性，可维护性</li><li>降低变更引起的风险</li><li>通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则</li></ol><h2 id="接口隔离原则"><a class="header-anchor" href="#接口隔离原则"></a>接口隔离原则</h2><h3 id="基本介绍-v2"><a class="header-anchor" href="#基本介绍-v2"></a>基本介绍</h3><p>接口隔离原则(Interface Segregation Principle)：客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上</p><h3 id="应用实例-v2"><a class="header-anchor" href="#应用实例-v2"></a>应用实例</h3><p>类 A 通过接口 Interface1 依赖类 B，类 C 通过接口 Interface1 依赖类 D，如果接口 Interface1 对于类 A 和类 C 来说不是最小接口，那么类 B 和类 D 必须去实现他们不需要的方法。</p><p><img src="../../../../Image/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%991.svg" alt="接口隔离原则1"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Segregation1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation4</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation5</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">Interface1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B 实现了 operation1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B 实现了 operation2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B 实现了 operation3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B 实现了 operation4&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B 实现了 operation5&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">Interface1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;D 实现了 operation1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;D 实现了 operation2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;D 实现了 operation3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;D 实现了 operation4&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;D 实现了 operation5&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; <span class="comment">//A 类通过接口Interface1 依赖(使用) B类，但是只会用到1,2,3方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(Interface1 i)</span> </span>&#123;</span><br><span class="line">        i.operation1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(Interface1 i)</span> </span>&#123;</span><br><span class="line">        i.operation2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(Interface1 i)</span> </span>&#123;</span><br><span class="line">        i.operation3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123; <span class="comment">//C 类通过接口Interface1 依赖(使用) D类，但是只会用到1,4,5方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(Interface1 i)</span> </span>&#123;</span><br><span class="line">        i.operation1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend4</span><span class="params">(Interface1 i)</span> </span>&#123;</span><br><span class="line">        i.operation4();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend5</span><span class="params">(Interface1 i)</span> </span>&#123;</span><br><span class="line">        i.operation5();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>按隔离原则应当这样处理：将接口 <strong>Interface1</strong> 拆分为独立的几个接口**(<strong>这里我们拆分成 <strong>3</strong> 个接口</strong>)**，类 A 和类 C 分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则</p><p><img src="../../../../Image/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99.svg" alt="接口隔离原则"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Segregation1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">A a = <span class="keyword">new</span> A();</span><br><span class="line">a.depend1(<span class="keyword">new</span> B()); <span class="comment">// A类通过接口去依赖B类</span></span><br><span class="line">a.depend2(<span class="keyword">new</span> B());</span><br><span class="line">a.depend3(<span class="keyword">new</span> B());</span><br><span class="line"></span><br><span class="line">C c = <span class="keyword">new</span> C();</span><br><span class="line"></span><br><span class="line">c.depend1(<span class="keyword">new</span> D()); <span class="comment">// C类通过接口去依赖(使用)D类</span></span><br><span class="line">c.depend4(<span class="keyword">new</span> D());</span><br><span class="line">c.depend5(<span class="keyword">new</span> D());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口1</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface1</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口2</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口3</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface3</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operation4</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operation5</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">Interface1</span>, <span class="title">Interface2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;B 实现了 operation1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;B 实现了 operation2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;B 实现了 operation3&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">Interface1</span>, <span class="title">Interface3</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;D 实现了 operation1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;D 实现了 operation4&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;D 实现了 operation5&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; <span class="comment">// A 类通过接口Interface1,Interface2 依赖(使用) B类，但是只会用到1,2,3方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(Interface1 i)</span> </span>&#123;</span><br><span class="line">i.operation1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(Interface2 i)</span> </span>&#123;</span><br><span class="line">i.operation2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(Interface2 i)</span> </span>&#123;</span><br><span class="line">i.operation3();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123; <span class="comment">// C 类通过接口Interface1,Interface3 依赖(使用) D类，但是只会用到1,4,5方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(Interface1 i)</span> </span>&#123;</span><br><span class="line">i.operation1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend4</span><span class="params">(Interface3 i)</span> </span>&#123;</span><br><span class="line">i.operation4();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend5</span><span class="params">(Interface3 i)</span> </span>&#123;</span><br><span class="line">i.operation5();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="依赖倒转原则"><a class="header-anchor" href="#依赖倒转原则"></a>依赖倒转原则</h2><h3 id="基本原则"><a class="header-anchor" href="#基本原则"></a>基本原则</h3><p>依赖倒转原则(Dependence Inversion Principle)是指：</p><ol><li>高层模块不应该依赖低层模块，二者都应该依赖其抽象</li><li>抽象不应该依赖细节，细节应该依赖抽象</li><li>依赖倒转(倒置)的中心思想是<font color="#faa755">面向接口编程</font></li><li>依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在 java 中，抽象指的是接口或抽象类，细节就是具体的实现类</li><li>使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成</li></ol><h3 id="应用实例-v3"><a class="header-anchor" href="#应用实例-v3"></a>应用实例</h3><h4 id="方式1"><a class="header-anchor" href="#方式1"></a>方式1</h4><ol><li>简单，比较容易想到</li><li>如果我们获取的对象是 微信，短信等等，则新增类，同时<code>Perons</code>也要增加相应的接收方法</li><li>解决思路：引入一个抽象的接口<code>IReceiver</code>, 表示接收者, 这样<code>Person</code>类与接口<code>IReceiver</code>发生依赖。因为<code>Email</code>, <code>WeiXin</code> 等等属于接收的范围，他们各自实现<code>IReceiver</code> 接口就ok, 这样我们就符号依赖倒转原则</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyInversion</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.receive(<span class="keyword">new</span> Email());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Email</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;电子邮件信息: hello,world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Email email)</span> </span>&#123;</span><br><span class="line">        System.out.println(email.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方式2"><a class="header-anchor" href="#方式2"></a>方式2</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyInversion</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//客户端无需改变</span></span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.receive(<span class="keyword">new</span> Email());</span><br><span class="line"></span><br><span class="line">        person.receive(<span class="keyword">new</span> WeiXin());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IReceiver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Email</span> <span class="keyword">implements</span> <span class="title">IReceiver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;电子邮件信息: hello,world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加微信</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeiXin</span> <span class="keyword">implements</span> <span class="title">IReceiver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;微信信息: hello,ok&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里我们是对接口的依赖</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(IReceiver receiver)</span> </span>&#123;</span><br><span class="line">        System.out.println(receiver.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="依赖关系传递的三种方式和应用案例"><a class="header-anchor" href="#依赖关系传递的三种方式和应用案例"></a>依赖关系传递的三种方式和应用案例</h3><p>方式1：通过接口传递实现依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开关的接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(ITV tv)</span></span>; <span class="comment">//抽象方法,接收接口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ITV</span> </span>&#123; <span class="comment">//ITV接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenAndClose</span> <span class="keyword">implements</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(ITV tv)</span> </span>&#123;</span><br><span class="line">        tv.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//============使用============</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChangHong</span> <span class="keyword">implements</span> <span class="title">ITV</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;长虹电视机，打开&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyPass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ChangHong changHong = <span class="keyword">new</span> ChangHong();</span><br><span class="line">        OpenAndClose openAndClose = <span class="keyword">new</span> OpenAndClose();</span><br><span class="line">openAndClose.open(changHong);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>方式2：通过构造方法依赖传递</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>; <span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ITV</span> </span>&#123; <span class="comment">//ITV接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenAndClose</span> <span class="keyword">implements</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ITV tv; <span class="comment">//成员</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OpenAndClose</span><span class="params">(ITV tv)</span> </span>&#123; <span class="comment">//构造器</span></span><br><span class="line">        <span class="keyword">this</span>.tv = tv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tv.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//============使用============</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChangHong</span> <span class="keyword">implements</span> <span class="title">ITV</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;长虹电视机，打开&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyPass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ChangHong changHong = <span class="keyword">new</span> ChangHong();</span><br><span class="line">OpenAndClose openAndClose = <span class="keyword">new</span> OpenAndClose(changHong);</span><br><span class="line">openAndClose.open();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>方式3：通过setter方法传递</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>; <span class="comment">// 抽象方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTv</span><span class="params">(ITV tv)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ITV</span> </span>&#123; <span class="comment">// ITV接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenAndClose</span> <span class="keyword">implements</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ITV tv;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTv</span><span class="params">(ITV tv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tv = tv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tv.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//============使用============</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChangHong</span> <span class="keyword">implements</span> <span class="title">ITV</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;长虹电视机，打开&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyPass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ChangHong changHong = <span class="keyword">new</span> ChangHong();</span><br><span class="line">        OpenAndClose openAndClose = <span class="keyword">new</span> OpenAndClose();</span><br><span class="line">        openAndClose.setTv(changHong);</span><br><span class="line">        openAndClose.open();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="依赖倒转原则的注意事项和细节"><a class="header-anchor" href="#依赖倒转原则的注意事项和细节"></a>依赖倒转原则的注意事项和细节</h3><ol><li>低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好.</li><li>变量的声明类型尽量是抽象类或接口, 这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化</li><li>继承时遵循里氏替换原则</li></ol><h2 id="里氏替换原则"><a class="header-anchor" href="#里氏替换原则"></a>里氏替换原则</h2><h3 id="面向对象中的继承性的思考和说明"><a class="header-anchor" href="#面向对象中的继承性的思考和说明"></a>面向对象中的继承性的思考和说明</h3><ol><li>继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。</li><li>继承在给程序设计带来便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低， 增加对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障</li><li>问题提出：在编程中，如何正确的使用继承? =&gt; 里氏替换原则</li></ol><h3 id="基本原理"><a class="header-anchor" href="#基本原理"></a>基本原理</h3><ol><li>如果对每个类型为 T1 的对象 o1，都有类型为 T2 的对象 o2，使得以 T1 定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。换句话说，所有引用基类的地方必须能透明地使用其子类的对象。</li><li>在使用继承时，遵循里氏替换原则，在<font color="#faa755">子类中尽量不要重写父类的方法</font></li><li>里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过<font color="#faa755">聚合，组合，依赖</font>来解决问题。</li></ol><h3 id="应用案例"><a class="header-anchor" href="#应用案例"></a>应用案例</h3><p>错误示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Liskov</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        System.out.println(<span class="string">&quot;11-3=&quot;</span> + a.func1(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;1-8=&quot;</span> + a.func1(<span class="number">1</span>, <span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        System.out.println(<span class="string">&quot;11-3=&quot;</span> + b.func1(<span class="number">11</span>, <span class="number">3</span>));<span class="comment">//这里本意是求出11-3</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1-8=&quot;</span> + b.func1(<span class="number">1</span>, <span class="number">8</span>));<span class="comment">// 1-8</span></span><br><span class="line">        System.out.println(<span class="string">&quot;11+3+9=&quot;</span> + b.func2(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回两个数的差</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 - num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B类继承了A</span></span><br><span class="line"><span class="comment">// 增加了一个新功能：完成两个数相加,然后和9求和</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里，重写了A类的方法, 可能是无意识</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> func1(a, b) + <span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Liskov</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        System.out.println(<span class="string">&quot;11-3=&quot;</span> + a.func1(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;1-8=&quot;</span> + a.func1(<span class="number">1</span>, <span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        <span class="comment">//因为B类不再继承A类，因此调用者，不会再func1是求减法</span></span><br><span class="line">        <span class="comment">//调用完成的功能就会很明确</span></span><br><span class="line">        System.out.println(<span class="string">&quot;11+3=&quot;</span> + b.func1(<span class="number">11</span>, <span class="number">3</span>));<span class="comment">//这里本意是求出11+3</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1+8=&quot;</span> + b.func1(<span class="number">1</span>, <span class="number">8</span>));<span class="comment">// 1+8</span></span><br><span class="line">        System.out.println(<span class="string">&quot;11+3+9=&quot;</span> + b.func2(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用组合仍然可以使用到A类相关方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;11-3=&quot;</span> + b.func3(<span class="number">11</span>, <span class="number">3</span>));<span class="comment">// 这里本意是求出11-3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个更加基础的基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="comment">//把更加基础的方法和成员写到Base类</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回两个数的差</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 - num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B类继承了A</span></span><br><span class="line"><span class="comment">// 增加了一个新功能：完成两个数相加,然后和9求和</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果B需要使用A类的方法,使用组合关系</span></span><br><span class="line">    <span class="keyword">private</span> A a = <span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里，重写了A类的方法, 可能是无意识</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> func1(a, b) + <span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//我们仍然想使用A的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func3</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.a.func1(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="开闭原则"><a class="header-anchor" href="#开闭原则"></a>开闭原则</h2><h3 id="基本介绍-v3"><a class="header-anchor" href="#基本介绍-v3"></a>基本介绍</h3><p>开闭原则是面向对象的可复用设计的第一块基石，它是最重要的面向对象设计原则。</p><p>开闭原则(Open-Closed Principle, OCP)：一个软件实体应当对扩展开放(对提供方)，对修改关闭(对使用方)。即软件实体应尽量在不修改原有代码的情况下进行扩展。</p><p>用抽象构建框架，用实现扩展细节。</p><ol start="3"><li>当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。</li><li>编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。</li></ol><h3 id="应用案例-v2"><a class="header-anchor" href="#应用案例-v2"></a>应用案例</h3><h4 id="方式一"><a class="header-anchor" href="#方式一"></a>方式一</h4><ol><li>优点是比较好理解，简单易操作。</li><li>缺点是违反了设计模式的开闭原则，即对扩展开放(提供方)，对修改关闭(使用方)。即当我们给类增加新功能的时候，尽量不修改代码，或者尽可能少修改代码.</li><li>比如我们这时要新增加一个图形种类 三角形，我们需要做如下修改，修改的地方较多</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ocp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用看看存在的问题</span></span><br><span class="line">        GraphicEditor graphicEditor = <span class="keyword">new</span> GraphicEditor();</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> Rectangle());</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> Circle());</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> Triangle());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是一个用于绘图的类 [使用方]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphicEditor</span> </span>&#123;</span><br><span class="line">    <span class="comment">//接收Shape对象，然后根据type，来绘制不同的图形</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawShape</span><span class="params">(Shape s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s.m_type == <span class="number">1</span>) &#123;</span><br><span class="line">drawRectangle(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s.m_type == <span class="number">2</span>) &#123;</span><br><span class="line">drawCircle(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s.m_type == <span class="number">3</span>) &#123;</span><br><span class="line">drawTriangle(s);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绘制矩形</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawRectangle</span><span class="params">(Shape r)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 绘制矩形 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绘制圆形</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawCircle</span><span class="params">(Shape r)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 绘制圆形 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绘制三角形</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawTriangle</span><span class="params">(Shape r)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 绘制三角形 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Shape类，基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    Rectangle() &#123;</span><br><span class="line">        <span class="keyword">super</span>.m_type = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    Circle() &#123;</span><br><span class="line">        <span class="keyword">super</span>.m_type = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增画三角形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    Triangle() &#123;</span><br><span class="line">        <span class="keyword">super</span>.m_type = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>改进的思路分析：把创建 <strong>Shape</strong> 类做成抽象类，并提供一个抽象的 <strong>draw</strong> 方法，让子类去实现即可，这样我们有新的图形种类时，只需要让新的图形类继承 Shape，并实现 draw 方法即可，使用方的代码就不需要修  -&gt;  满足了开闭原则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.principle.ocp.improve;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ocp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用看看存在的问题</span></span><br><span class="line">        GraphicEditor graphicEditor = <span class="keyword">new</span> GraphicEditor();</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> Rectangle());</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> Circle());</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> Triangle());</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> OtherGraphic());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是一个用于绘图的类 [使用方]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphicEditor</span> </span>&#123;</span><br><span class="line">    <span class="comment">//接收Shape对象，调用draw方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawShape</span><span class="params">(Shape s)</span> </span>&#123;</span><br><span class="line">        s.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Shape类，基类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m_type;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;<span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    Rectangle() &#123;</span><br><span class="line">        <span class="keyword">super</span>.m_type = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">&quot; 绘制矩形 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    Circle() &#123;</span><br><span class="line">        <span class="keyword">super</span>.m_type = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 绘制圆形 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增画三角形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    Triangle() &#123;</span><br><span class="line">        <span class="keyword">super</span>.m_type = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 绘制三角形 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增一个图形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OtherGraphic</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    OtherGraphic() &#123;</span><br><span class="line">        <span class="keyword">super</span>.m_type = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 绘制其它图形 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迪米特法则"><a class="header-anchor" href="#迪米特法则"></a>迪米特法则</h2><h3 id="基本介绍-v4"><a class="header-anchor" href="#基本介绍-v4"></a>基本介绍</h3><ol><li><p>一个对象应该对其他对象保持最少的了解</p></li><li><p>类与类关系越密切，耦合度越大</p></li><li><p>迪米特法则(Demeter Principle)又叫最少知道原则，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的 public 方法，不对外泄露任何信息</p></li><li><p>迪米特法则还有个更简单的定义：只与直接的朋友通信</p><blockquote><p>直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。</p></blockquote></li></ol><h3 id="应用示例"><a class="header-anchor" href="#应用示例"></a>应用示例</h3><p>有一个学校，下属有各个学院和总部，现要求打印出学校总部员工 ID 和学院员工的 id</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demeter1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建了一个 SchoolManager 对象</span></span><br><span class="line">        SchoolManager schoolManager = <span class="keyword">new</span> SchoolManager();</span><br><span class="line">        <span class="comment">//输出学院的员工id 和 学校总部的员工信息</span></span><br><span class="line">        schoolManager.printAllEmployee(<span class="keyword">new</span> CollegeManager());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学校总部员工类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//学院的员工类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeEmployee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//管理学院员工的管理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回学院的所有员工</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;CollegeEmployee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;CollegeEmployee&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; <span class="comment">//这里我们增加了10个员工到 list</span></span><br><span class="line">            CollegeEmployee emp = <span class="keyword">new</span> CollegeEmployee();</span><br><span class="line">            emp.setId(<span class="string">&quot;学院员工id= &quot;</span> + i);</span><br><span class="line">            list.add(emp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学校管理类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//分析 SchoolManager 类的直接朋友类有哪些 Employee、CollegeManager</span></span><br><span class="line"><span class="comment">//CollegeEmployee 不是 直接朋友 而是一个陌生类，这样违背了 迪米特法则</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SchoolManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回学校总部的员工</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Employee&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; <span class="comment">//这里我们增加了5个员工到 list</span></span><br><span class="line">            Employee emp = <span class="keyword">new</span> Employee();</span><br><span class="line">            emp.setId(<span class="string">&quot;学校总部员工id= &quot;</span> + i);</span><br><span class="line">            list.add(emp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该方法完成输出学校总部和学院员工信息(id)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printAllEmployee</span><span class="params">(CollegeManager sub)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分析问题</span></span><br><span class="line">        <span class="comment">//1. 这里的 CollegeEmployee 不是  SchoolManager的直接朋友</span></span><br><span class="line">        <span class="comment">//2. CollegeEmployee 是以局部变量方式出现在 SchoolManager</span></span><br><span class="line">        <span class="comment">//3. 违反了 迪米特法则</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取到学院员工</span></span><br><span class="line">        List&lt;CollegeEmployee&gt; list1 = sub.getAllEmployee();</span><br><span class="line">        System.out.println(<span class="string">&quot;------------学院员工------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (CollegeEmployee e : list1) &#123;</span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取到学校总部员工</span></span><br><span class="line">        List&lt;Employee&gt; list2 = <span class="keyword">this</span>.getAllEmployee();</span><br><span class="line">        System.out.println(<span class="string">&quot;------------学校总部员工------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Employee e : list2) &#123;</span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用实例改进分析：前面设计的问题在于 <code>SchoolManager</code> 中，<code>CollegeEmployee</code> 类并不是 <code>SchoolManager</code> 类的直接朋友 (分析)，按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demeter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;~~~使用迪米特法则的改进~~~&quot;</span>);</span><br><span class="line">        <span class="comment">//创建了一个 SchoolManager 对象</span></span><br><span class="line">        SchoolManager schoolManager = <span class="keyword">new</span> SchoolManager();</span><br><span class="line">        <span class="comment">//输出学院的员工id 和  学校总部的员工信息</span></span><br><span class="line">        schoolManager.printAllEmployee(<span class="keyword">new</span> CollegeManager());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//学校总部员工类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//学院的员工类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeEmployee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//管理学院员工的管理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回学院的所有员工</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;CollegeEmployee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;CollegeEmployee&gt; list = <span class="keyword">new</span> ArrayList&lt;CollegeEmployee&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; <span class="comment">//这里我们增加了10个员工到 list</span></span><br><span class="line">            CollegeEmployee emp = <span class="keyword">new</span> CollegeEmployee();</span><br><span class="line">            emp.setId(<span class="string">&quot;学院员工id= &quot;</span> + i);</span><br><span class="line">            list.add(emp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出学院员工的信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取到学院员工</span></span><br><span class="line">        List&lt;CollegeEmployee&gt; list1 = getAllEmployee();</span><br><span class="line">        System.out.println(<span class="string">&quot;------------学院员工------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (CollegeEmployee e : list1) &#123;</span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学校管理类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//分析 SchoolManager 类的直接朋友类有哪些 Employee、CollegeManager</span></span><br><span class="line"><span class="comment">//CollegeEmployee 不是 直接朋友 而是一个陌生类，这样违背了 迪米特法则 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SchoolManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回学校总部的员工</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Employee&gt; list = <span class="keyword">new</span> ArrayList&lt;Employee&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; <span class="comment">//这里我们增加了5个员工到 list</span></span><br><span class="line">            Employee emp = <span class="keyword">new</span> Employee();</span><br><span class="line">            emp.setId(<span class="string">&quot;学校总部员工id= &quot;</span> + i);</span><br><span class="line">            list.add(emp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该方法完成输出学校总部和学院员工信息(id)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printAllEmployee</span><span class="params">(CollegeManager sub)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分析问题</span></span><br><span class="line">        <span class="comment">//1. 将输出学院的员工方法，封装到CollegeManager</span></span><br><span class="line">        sub.printEmployee();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取到学校总部员工</span></span><br><span class="line">        List&lt;Employee&gt; list2 = <span class="keyword">this</span>.getAllEmployee();</span><br><span class="line">        System.out.println(<span class="string">&quot;------------学校总部员工------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Employee e : list2) &#123;</span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="迪米特法则注意事项和细节"><a class="header-anchor" href="#迪米特法则注意事项和细节"></a>迪米特法则注意事项和细节</h3><ol><li>迪米特法则的核心是降低类之间的耦合</li><li>但是注意：由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间(对象间)耦合关系， 并不是要求完全没有依赖关系</li></ol><h2 id="合成复用原则"><a class="header-anchor" href="#合成复用原则"></a>合成复用原则</h2><h3 id="基本介绍-v5"><a class="header-anchor" href="#基本介绍-v5"></a>基本介绍</h3><p>原则是尽量使用合成/聚合的方式，而不是使用继承</p><h2 id="设计原则核心思想"><a class="header-anchor" href="#设计原则核心思想"></a>设计原则核心思想</h2><ol><li>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。</li><li>针对接口编程，而不是针对实现编程。</li><li>为了交互对象之间的松耦合设计而努力</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 | 面向对象编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL常用算法</title>
      <link href="2021/04/18/C++/STL%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95-stl%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
      <url>2021/04/18/C++/STL%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95-stl%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><strong>概述</strong>:</p><ul><li>算法主要是由头文件<code>&lt;algorithm&gt;</code> <code>&lt;functional&gt;</code> <code>&lt;numeric&gt;</code>组成。</li><li><code>&lt;algorithm&gt;</code>是所有STL头文件中最大的一个，范围涉及到比较、 交换、查找、遍历操作、复制、修改等等</li><li><code>&lt;numeric&gt;</code>体积很小，只包括几个在序列上面进行简单数学运算的模板函数</li><li><code>&lt;functional&gt;</code>定义了一些模板类,用以声明函数对象。</li></ul><h2 id="常用遍历算法"><a class="header-anchor" href="#常用遍历算法"></a>常用遍历算法</h2><p><strong>学习目标</strong>：掌握常用的遍历算法</p><p><strong>算法简介</strong>：</p><ul><li><code>for_each</code> //遍历容器</li><li><code>transform</code> //搬运容器到另一个容器中</li></ul><h3 id="for-each"><a class="header-anchor" href="#for-each"></a>for_each</h3><p><strong>功能描述</strong>：实现遍历容器</p><p><strong>函数原型</strong>：</p><ul><li><code>for_each(iterator beg, iterator end, _func);</code> // 遍历算法 遍历容器元素<ul><li><code>beg</code> 开始迭代器</li><li><code>end</code> 结束迭代器</li><li><code>_func</code> 函数或者函数对象</li></ul></li></ul><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print01</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">print02</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//for_each算法基本用法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历算法</span></span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), print01);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">print02</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="transform"><a class="header-anchor" href="#transform"></a>transform</h3><p><strong>功能描述</strong>：搬运容器到另一个容器中</p><p><strong>函数原型</strong>：</p><ul><li><code>transform(iterator beg1, iterator end1, iterator beg2, _func);</code><ul><li><code>beg1</code> 源容器开始迭代器</li><li><code>end1</code> 源容器结束迭代器</li><li><code>beg2</code> 目标容器开始迭代器</li><li><code>_func</code> 函数或者函数对象</li></ul></li></ul><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//常用遍历算法  搬运 transform</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TransForm</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vTarget; <span class="comment">//目标容器</span></span><br><span class="line"></span><br><span class="line">    vTarget.<span class="built_in">resize</span>(v.<span class="built_in">size</span>()); <span class="comment">// 目标容器需要提前开辟空间</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">transform</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>(), <span class="built_in">TransForm</span>());</span><br><span class="line"></span><br><span class="line">    for_each(vTarget.<span class="built_in">begin</span>(), vTarget.<span class="built_in">end</span>(), <span class="built_in">MyPrint</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong>： 搬运的目标容器必须要提前开辟空间，否则无法正常搬运</p><h2 id="常用查找算法"><a class="header-anchor" href="#常用查找算法"></a>常用查找算法</h2><p><strong>算法简介</strong>：</p><ul><li><code>find</code> //查找元素</li><li><code>find_if</code> //按条件查找元素</li><li><code>adjacent_find</code> //查找相邻重复元素</li><li><code>binary_search</code> //二分查找法</li><li><code>count</code> //统计元素个数</li><li><code>count_if</code> //按条件统计元素个数</li></ul><h3 id="find"><a class="header-anchor" href="#find"></a>find</h3><p><strong>功能描述</strong>：</p><ul><li>查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end()</li></ul><p><strong>函数原型</strong>：</p><ul><li><code>find(iterator beg, iterator end, value);</code> // 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置<ul><li><code>beg</code> 开始迭代器</li><li><code>end</code> 结束迭代器</li><li><code>value</code> 查找的元素</li></ul></li></ul><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查找容器中是否有 5 这个元素</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;找到:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载 ==</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Person &amp;p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_Name;</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建数据</span></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p4);</span><br><span class="line"></span><br><span class="line">    vector&lt;Person&gt;::iterator it = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), p2);</span><br><span class="line">    <span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;找到姓名:&quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄: &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结： 利用find可以在容器中找指定的元素，返回值是<strong>迭代器</strong></p><h3 id="find-if"><a class="header-anchor" href="#find-if"></a>find_if</h3><p><strong>功能描述</strong>：按条件查找元素</p><p><strong>函数原型</strong>：</p><ul><li><code>find_if(iterator beg, iterator end, _Pred);</code> // 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置<ul><li><code>beg</code> 开始迭代器</li><li><code>end</code> 结束迭代器</li><li><code>_Pred</code> 函数或者谓词（返回bool类型的仿函数）</li></ul></li></ul><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreaterFive</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val &gt; <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">GreaterFive</span>());</span><br><span class="line">    <span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;找到大于5的数字:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_Name;</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greater20</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Person &amp;p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p.m_Age &gt; <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建数据</span></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p4);</span><br><span class="line"></span><br><span class="line">    vector&lt;Person&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">Greater20</span>());</span><br><span class="line">    <span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;找到姓名:&quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄: &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：find_if按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略</p><h3 id="adjacent-find"><a class="header-anchor" href="#adjacent-find"></a>adjacent_find</h3><p><strong>功能描述</strong>：查找相邻重复元素</p><p><strong>函数原型</strong>：</p><ul><li><code>adjacent_find(iterator beg, iterator end);</code>  // 查找相邻重复元素,返回相邻元素的第一个位置的迭代器<ul><li><code>beg</code> 开始迭代器</li><li><code>end</code> 结束迭代器</li></ul></li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找相邻重复元素</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">adjacent_find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;找不到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;找到相邻重复元素为:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="binary-search"><a class="header-anchor" href="#binary-search"></a>binary_search</h3><p><strong>功能描述</strong>：查找指定元素是否存在</p><p>注意: 在<strong>无序序列中不可用</strong></p><p><strong>函数原型</strong>：</p><ul><li><code>bool binary_search(iterator beg, iterator end, value);</code>  // 查找指定的元素，查到 返回true 否则false<ul><li><code>beg</code> 开始迭代器</li><li><code>end</code> 结束迭代器</li><li><code>value</code> 查找的元素</li></ul></li></ul><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//二分查找</span></span><br><span class="line">    <span class="keyword">bool</span> ret = <span class="built_in">binary_search</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;找到了&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;未找到&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong>：二分查找法查找效率很高，值得注意的是查找的容器中元素必须的有序序列</p><h3 id="count"><a class="header-anchor" href="#count"></a>count</h3><p><strong>功能描述</strong>：</p><ul><li>统计元素个数</li></ul><p><strong>函数原型</strong>：</p><ul><li><code>count(iterator beg, iterator end, value);</code> // 统计元素出现次数<ul><li><code>beg</code> 开始迭代器</li><li><code>end</code> 结束迭代器</li><li><code>value</code> 统计的元素</li></ul></li></ul><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="built_in">count</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;4的个数为： &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Person &amp;p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Age == p.m_Age) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    string m_Name;</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p5);</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;诸葛亮&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="built_in">count</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), p);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong>： 统计自定义数据类型时候，需要配合重载 <code>operator==</code></p><h3 id="count-if"><a class="header-anchor" href="#count-if"></a>count_if</h3><p><strong>功能描述</strong>：</p><ul><li>按条件统计元素个数</li></ul><p><strong>函数原型</strong>：</p><ul><li><code>count_if(iterator beg, iterator end, _Pred);</code> // 按条件统计元素出现次数<ul><li><code>beg</code> 开始迭代器</li><li><code>end</code> 结束迭代器</li><li><code>_Pred</code> 谓词</li></ul></li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greater4</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val &gt;= <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="built_in">count_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">Greater4</span>());</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;大于4的个数为： &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string m_Name;</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AgeLess35</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Person &amp;p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p.m_Age &lt; <span class="number">35</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p5);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="built_in">count_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">AgeLess35</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;小于35岁的个数：&quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常见的排序算法"><a class="header-anchor" href="#常见的排序算法"></a>常见的排序算法</h2><p><strong>学习目标</strong>：掌握常用的排序算法</p><p><strong>算法简介</strong>：</p><ul><li><code>sort</code> //对容器内元素进行排序</li><li><code>random_shuffle</code> //洗牌 指定范围内的元素随机调整次序</li><li><code>merge</code> // 容器元素合并，并存储到另一容器中</li><li><code>reverse</code> // 反转指定范围的元素</li></ul><h3 id="sort"><a class="header-anchor" href="#sort"></a>sort</h3><p><strong>功能描述</strong>：对容器内元素进行排序</p><p><strong>函数原型</strong>：</p><ul><li><code>sort(iterator beg, iterator end, _Pred);</code> // 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置<ul><li><code>beg</code> 开始迭代器</li><li><code>end</code> 结束迭代器</li><li><code>_Pred</code> 谓词</li></ul></li></ul><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sort默认从小到大排序</span></span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), myPrint);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从大到小排序</span></span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), myPrint);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="random-shuffle"><a class="header-anchor" href="#random-shuffle"></a>random_shuffle</h3><p><strong>功能描述</strong>：洗牌 指定范围内的元素随机调整次序</p><p><strong>函数原型</strong>：</p><ul><li><code>random_shuffle(iterator beg, iterator end);</code> // 指定范围内的元素随机调整次序<ul><li>beg 开始迭代器</li><li>end 结束迭代器</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>((<span class="keyword">unsigned</span> <span class="keyword">int</span>) <span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打乱顺序</span></span><br><span class="line">    <span class="built_in">random_shuffle</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong>：random_shuffle洗牌算法比较实用，使用时记得加随机数种子</p><h3 id="merge"><a class="header-anchor" href="#merge"></a>merge</h3><p><strong>功能描述</strong>：两个容器元素合并，并存储到另一容器中</p><p>注意: 两个容器必须是<font color="#faa755">有序的</font></p><p><strong>函数原型</strong>：</p><ul><li><code>merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code> // 容器元素合并，并存储到另一容器中<ul><li><code>beg1</code> 容器1开始迭代器</li><li><code>end1</code> 容器1结束迭代器</li><li><code>beg2</code> 容器2开始迭代器</li><li><code>end2</code> 容器2结束迭代器</li><li><code>dest</code> 目标容器开始迭代器</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">        v2.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vtarget;</span><br><span class="line">    <span class="comment">//目标容器需要提前开辟空间</span></span><br><span class="line">    vtarget.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>() + v2.<span class="built_in">size</span>());</span><br><span class="line">    <span class="comment">//合并  需要两个有序序列</span></span><br><span class="line">    <span class="built_in">merge</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vtarget.<span class="built_in">begin</span>());</span><br><span class="line">    for_each(vtarget.<span class="built_in">begin</span>(), vtarget.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="reverse"><a class="header-anchor" href="#reverse"></a>reverse</h3><p><strong>功能描述</strong>：将容器内元素进行反转</p><p><strong>函数原型</strong>：</p><ul><li><code>reverse(iterator beg, iterator end);</code> // 反转指定范围的元素<ul><li><code>beg</code> 开始迭代器</li><li><code>end</code> 结束迭代器</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;反转前： &quot;</span> &lt;&lt; endl;</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;反转后： &quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">reverse</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常用拷贝和替换算法"><a class="header-anchor" href="#常用拷贝和替换算法"></a>常用拷贝和替换算法</h2><p><strong>算法简介</strong>：</p><ul><li><code>copy</code> // 容器内指定范围的元素拷贝到另一容器中</li><li><code>replace</code> // 将容器内指定范围的旧元素修改为新元素</li><li><code>replace_if</code> // 容器内指定范围满足条件的元素替换为新元素</li><li><code>swap</code> // 互换两个容器的元素</li></ul><h3 id="copy"><a class="header-anchor" href="#copy"></a>copy</h3><p><strong>功能描述</strong>：容器内指定范围的元素拷贝到另一容器中</p><p><strong>函数原型</strong>：</p><ul><li><code>copy(iterator beg, iterator end, iterator dest);</code> // 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置<ul><li><code>beg</code> 开始迭代器</li><li><code>end</code> 结束迭代器</li><li><code>dest</code> 目标起始迭代器</li></ul></li></ul><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">    v2.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>());</span><br><span class="line">    <span class="built_in">copy</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">    for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong>：利用copy算法在拷贝时，目标容器记得提前开辟空间</p><h3 id="replace-if"><a class="header-anchor" href="#replace-if"></a>replace_if</h3><p><strong>功能描述</strong>：将区间内满足条件的元素，替换成指定元素</p><p><strong>函数原型</strong>：</p><ul><li><code>replace_if(iterator beg, iterator end, _pred, newvalue);</code> // 按条件替换元素，满足条件的替换成指定元素<ul><li><code>beg</code> 开始迭代器</li><li><code>end</code> 结束迭代器</li><li><code>_pred</code> 谓词</li><li><code>newvalue</code> 替换的新元素</li></ul></li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReplaceGreater30</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val &gt;= <span class="number">30</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;替换前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将容器中大于等于的30 替换成 3000</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;替换后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">replace_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">ReplaceGreater30</span>(), <span class="number">3000</span>);</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong>：replace_if按条件查找，可以利用仿函数灵活筛选满足的条件</p><h3 id="swap"><a class="header-anchor" href="#swap"></a>swap</h3><p><strong>功能描述</strong>：互换两个容器的元素</p><p><strong>函数原型</strong>：</p><ul><li><code>swap(container c1, container c2);</code> // 互换两个容器的元素<ul><li><code>c1</code>容器1</li><li><code>c2</code>容器2</li></ul></li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">        v2.<span class="built_in">push_back</span>(i + <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;交换前： &quot;</span> &lt;&lt; endl;</span><br><span class="line">    for_each(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;交换后： &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">swap</span>(v1, v2);</span><br><span class="line">    for_each(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong>：swap交换容器时，注意交换的容器要同种类型</p><h2 id="常用算术生成算法"><a class="header-anchor" href="#常用算术生成算法"></a>常用算术生成算法</h2><p><strong>注意</strong>：算术生成算法属于小型算法，使用时包含的头文件为 <code>#include &lt;numeric&gt;</code></p><p><strong>算法简介</strong>：</p><ul><li><code>accumulate</code> // 计算容器元素累计总和</li><li><code>fill</code> // 向容器中添加元素</li></ul><h3 id="accumulate"><a class="header-anchor" href="#accumulate"></a>accumulate</h3><p><strong>功能描述</strong>：计算区间内 容器元素累计总和</p><p><strong>函数原型</strong>：</p><ul><li><code>accumulate(iterator beg, iterator end, value); </code>// 计算容器元素累计总和<ul><li><code>beg</code> 开始迭代器</li><li><code>end</code> 结束迭代器</li><li><code>value</code> 起始值</li></ul></li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> total = <span class="built_in">accumulate</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;total = &quot;</span> &lt;&lt; total &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong>：accumulate使用时头文件注意是 numeric，这个算法很实用</p><h3 id="fill"><a class="header-anchor" href="#fill"></a>fill</h3><p><strong>功能描述</strong>：向容器中填充指定的元素</p><p><strong>函数原型</strong>：</p><ul><li><code>fill(iterator beg, iterator end, value);</code> // 向容器中填充元素<ul><li><code>beg</code> 开始迭代器</li><li><code>end</code> 结束迭代器</li><li><code>value</code> 填充的值</li></ul></li></ul><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//填充</span></span><br><span class="line">    <span class="built_in">fill</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong>：利用fill可以将容器区间内元素填充为指定的值</p><h2 id="常用集合算法"><a class="header-anchor" href="#常用集合算法"></a>常用集合算法</h2><p><strong>算法简介</strong>：</p><ul><li><code>set_intersection</code> // 求两个容器的交集</li><li><code>set_union</code> // 求两个容器的并集</li><li><code>set_difference</code> // 求两个容器的差集</li></ul><h3 id="set-intersection"><a class="header-anchor" href="#set-intersection"></a>set_intersection</h3><p><strong>功能描述</strong>：求两个容器的交集</p><p><strong>注意：两个集合必须是有序序列</strong></p><p><strong>函数原型</strong>：</p><ul><li><code>set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code> // 求两个集合的交集<ul><li><code>beg1</code> 容器1开始迭代器</li><li><code>end1</code> 容器1结束迭代器</li><li><code>beg2</code> 容器2开始迭代器</li><li><code>end2</code> 容器2结束迭代器</li><li><code>dest</code> 目标容器开始迭代器</li></ul></li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">        v2.<span class="built_in">push_back</span>(i + <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vTarget;</span><br><span class="line">    <span class="comment">//取两个里面较小的值给目标容器开辟空间</span></span><br><span class="line">    vTarget.<span class="built_in">resize</span>(<span class="built_in">min</span>(v1.<span class="built_in">size</span>(), v2.<span class="built_in">size</span>()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator itEnd =</span><br><span class="line">            <span class="built_in">set_intersection</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">    for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong>：</p><ul><li>求交集的两个集合必须的有序序列</li><li>目标容器开辟空间需要从<strong>两个容器中取小值</strong></li><li>set_intersection返回值是交集中最后一个元素的位置</li></ul><h3 id="set-union"><a class="header-anchor" href="#set-union"></a>set_union</h3><p><strong>功能描述</strong>：求两个集合的并集</p><p><strong>注意：两个集合必须是有序序列</strong></p><p><strong>函数原型</strong>：</p><ul><li><code>set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code> // 求两个集合的并集<ul><li><code>beg1</code> 容器1开始迭代器</li><li><code>end1</code> 容器1结束迭代器</li><li><code>beg2</code> 容器2开始迭代器</li><li><code>end2</code> 容器2结束迭代器</li><li><code>dest</code> 目标容器开始迭代器</li></ul></li></ul><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">        v2.<span class="built_in">push_back</span>(i + <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vTarget;</span><br><span class="line">    <span class="comment">//取两个容器的和给目标容器开辟空间</span></span><br><span class="line">    vTarget.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>() + v2.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator itEnd =</span><br><span class="line">            <span class="built_in">set_union</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">    for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong>：</p><ul><li>求并集的两个集合必须的有序序列</li><li>目标容器开辟空间需要<strong>两个容器相加</strong></li><li>set_union返回值是并集中最后一个元素的位置</li></ul><h3 id="set-difference"><a class="header-anchor" href="#set-difference"></a>set_difference</h3><p><strong>功能描述</strong>：求两个集合的差集</p><p><strong>注意：两个集合必须是有序序列</strong></p><p><strong>函数原型</strong>：</p><ul><li><code>set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code> // 求两个集合的差集<ul><li><code>beg1</code> 容器1开始迭代器</li><li><code>end1</code> 容器1结束迭代器</li><li><code>beg2</code> 容器2开始迭代器</li><li><code>end2</code> 容器2结束迭代器</li><li><code>dest</code> 目标容器开始迭代器</li></ul></li></ul><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">        v2.<span class="built_in">push_back</span>(i + <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vTarget;</span><br><span class="line">    <span class="comment">//取两个里面较大的值给目标容器开辟空间</span></span><br><span class="line">    vTarget.<span class="built_in">resize</span>(<span class="built_in">max</span>(v1.<span class="built_in">size</span>(), v2.<span class="built_in">size</span>()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v1与v2的差集为： &quot;</span> &lt;&lt; endl;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator itEnd =</span><br><span class="line">            <span class="built_in">set_difference</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line">    for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v2与v1的差集为： &quot;</span> &lt;&lt; endl;</span><br><span class="line">    itEnd = <span class="built_in">set_difference</span>(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line">    for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong>：</p><ul><li>求差集的两个集合必须的有序序列</li><li>目标容器开辟空间需要从<strong>两个容器取较大值</strong></li><li>set_difference返回值是差集中最后一个元素的位置</li></ul>]]></content>
      
      
      <categories>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL函数对象</title>
      <link href="2021/04/18/C++/STL%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1-stl-han-shu-dui-xiang/"/>
      <url>2021/04/18/C++/STL%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1-stl-han-shu-dui-xiang/</url>
      
        <content type="html"><![CDATA[<h2 id="函数对象"><a class="header-anchor" href="#函数对象"></a>函数对象</h2><h3 id="函数对象概念"><a class="header-anchor" href="#函数对象概念"></a>函数对象概念</h3><p><strong>概念：</strong></p><ul><li>重载<strong>函数调用操作符</strong>的类，其对象常称为<strong>函数对象</strong></li><li><strong>函数对象</strong>使用重载的()时，行为类似函数调用，也叫<strong>仿函数</strong></li></ul><p><strong>本质：<strong>函数对象(仿函数)是一个</strong>类</strong>，不是一个函数</p><h3 id="函数对象使用"><a class="header-anchor" href="#函数对象使用"></a>函数对象使用</h3><p><strong>特点：</strong></p><ul><li>函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</li><li>函数对象超出普通函数的概念，函数对象可以有自己的状态</li><li>函数对象可以作为参数传递</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAdd</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v1 + v2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyAdd myAdd;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">myAdd</span>(<span class="number">10</span>, <span class="number">10</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、函数对象可以有自己的状态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyPrint</span>() &#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string test)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; test &lt;&lt; endl;</span><br><span class="line">        count++; <span class="comment">//统计使用次数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count; <span class="comment">//内部自己的状态</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyPrint myPrint;</span><br><span class="line">    <span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;myPrint调用次数为： &quot;</span> &lt;&lt; myPrint.count &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、函数对象可以作为参数传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doPrint</span><span class="params">(MyPrint &amp;mp, string test)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">mp</span>(test);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyPrint myPrint;</span><br><span class="line">    <span class="built_in">doPrint</span>(myPrint, <span class="string">&quot;Hello C++&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：仿函数写法非常灵活，可以作为参数进行传递。</p><h2 id="谓词"><a class="header-anchor" href="#谓词"></a>谓词</h2><h3 id="谓词概念"><a class="header-anchor" href="#谓词概念"></a>谓词概念</h3><p><strong>概念：</strong></p><ul><li>返回bool类型的仿函数称为<strong>谓词</strong></li><li>如果operator()接受一个参数，那么叫做一元谓词</li><li>如果operator()接受两个参数，那么叫做二元谓词</li></ul><h3 id="一元谓词"><a class="header-anchor" href="#一元谓词"></a>一元谓词</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.一元谓词</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GreaterFive</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val &gt; <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">GreaterFive</span>());</span><br><span class="line">    <span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;没找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;找到:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：参数只有一个的谓词，称为一元谓词</p><h3 id="二元谓词"><a class="header-anchor" href="#二元谓词"></a>二元谓词</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二元谓词</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCompare</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 &gt; num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认从小到大</span></span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;----------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用函数对象改变算法策略，排序从大到小</span></span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">MyCompare</span>());</span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：参数只有两个的谓词，称为二元谓词</p><h2 id="内建函数对象"><a class="header-anchor" href="#内建函数对象"></a>内建函数对象</h2><h3 id="内建函数对象意义"><a class="header-anchor" href="#内建函数对象意义"></a>内建函数对象意义</h3><p><strong>概念：</strong></p><ul><li>STL内建了一些函数对象</li></ul><p><strong>分类:</strong></p><ul><li>算术仿函数</li><li>关系仿函数</li><li>逻辑仿函数</li></ul><p><strong>用法：</strong></p><ul><li>这些仿函数所产生的对象，用法和一般函数完全相同</li><li>使用内建函数对象，需要引入头文件 <code>#include&lt;functional&gt;</code></li></ul><h3 id="算术仿函数"><a class="header-anchor" href="#算术仿函数"></a>算术仿函数</h3><p><strong>功能描述：</strong></p><ul><li>实现四则运算</li><li>其中negate是一元运算，其他都是二元运算</li></ul><p><strong>仿函数原型：</strong></p><ul><li><code>template&lt;class T&gt; T plus&lt;T&gt;</code> //加法仿函数</li><li><code>template&lt;class T&gt; T minus&lt;T&gt;</code> //减法仿函数</li><li><code>template&lt;class T&gt; T multiplies&lt;T&gt;</code> //乘法仿函数</li><li><code>template&lt;class T&gt; T divides&lt;T&gt;</code> //除法仿函数</li><li><code>template&lt;class T&gt; T modulus&lt;T&gt;</code> //取模仿函数</li><li><code>template&lt;class T&gt; T negate&lt;T&gt;</code> //取反仿函数</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//negate</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    negate&lt;<span class="keyword">int</span>&gt; n;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">n</span>(<span class="number">50</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//plus</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    plus&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">p</span>(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：使用内建函数对象时，需要引入头文件 <code>#include &lt;functional&gt;</code></p><h3 id="关系仿函数"><a class="header-anchor" href="#关系仿函数"></a>关系仿函数</h3><p><strong>功能描述：</strong></p><ul><li>实现关系对比</li></ul><p><strong>仿函数原型：</strong></p><ul><li><code>template&lt;class T&gt; bool equal_to&lt;T&gt;</code> //等于</li><li><code>template&lt;class T&gt; bool not_equal_to&lt;T&gt;</code> //不等于</li><li><code>template&lt;class T&gt; bool greater&lt;T&gt;</code> //大于</li><li><code>template&lt;class T&gt; bool greater_equal&lt;T&gt;</code> //大于等于</li><li><code>template&lt;class T&gt; bool less&lt;T&gt;</code> //小于</li><li><code>template&lt;class T&gt; bool less_equal&lt;T&gt;</code> //小于等于</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCompare</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自己实现仿函数</span></span><br><span class="line">    <span class="comment">//sort(v.begin(), v.end(), MyCompare());</span></span><br><span class="line">    <span class="comment">//STL内建仿函数  大于仿函数</span></span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="逻辑仿函数"><a class="header-anchor" href="#逻辑仿函数"></a>逻辑仿函数</h3><p><strong>功能描述：</strong></p><ul><li>实现逻辑运算</li></ul><p><strong>函数原型：</strong></p><ul><li><code>template&lt;class T&gt; bool logical_and&lt;T&gt;</code> //逻辑与</li><li><code>template&lt;class T&gt; bool logical_or&lt;T&gt;</code> //逻辑或</li><li><code>template&lt;class T&gt; bool logical_not&lt;T&gt;</code> //逻辑非</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">bool</span>&gt; v;</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="literal">true</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="literal">true</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="keyword">bool</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//逻辑非  将v容器搬运到v2中，并执行逻辑非运算</span></span><br><span class="line">    vector&lt;<span class="keyword">bool</span>&gt; v2;</span><br><span class="line">    v2.<span class="built_in">resize</span>(v.<span class="built_in">size</span>());</span><br><span class="line">    <span class="built_in">transform</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), logical_not&lt;<span class="keyword">bool</span>&gt;());</span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="keyword">bool</span>&gt;::iterator it = v2.<span class="built_in">begin</span>(); it != v2.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL常用容器</title>
      <link href="2021/04/18/C++/STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8-stl-container/"/>
      <url>2021/04/18/C++/STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8-stl-container/</url>
      
        <content type="html"><![CDATA[<h2 id="string容器"><a class="header-anchor" href="#string容器"></a>string容器</h2><h3 id="string基本概念"><a class="header-anchor" href="#string基本概念"></a>string基本概念</h3><p><strong>本质</strong>：<code>string</code>是C++风格的字符串，而<code>string</code>本质上是一个类。</p><p><strong><code>string</code>和<code>char*</code> 区别</strong>：</p><ul><li><code>char*</code> 是一个指针</li><li><code>string</code>是一个类，类内部封装了<code>char*</code>，管理这个字符串，是一个<code>char*</code>型的容器。</li></ul><p><strong>特点</strong>：</p><ol><li><code>string</code> 类内部封装了很多成员方法，例如：查找find，拷贝copy，删除delete 替换replace，插入insert</li><li>string管理<code>char*</code>所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责。</li></ol><h3 id="string构造函数"><a class="header-anchor" href="#string构造函数"></a>string构造函数</h3><p>构造函数原型：</p><ul><li><code>string();</code>  //创建一个空的字符串 例如: string str;</li><li><code>string(const char* s);</code> //使用字符串s初始化</li><li><code>string(const string&amp; str);</code> //使用一个string对象初始化另一个string对象</li><li><code>string(int n, char c);</code> //使用n个字符c初始化</li></ul><p>使用不同构造函数创建string对象，<strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//string构造</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s1; <span class="comment">//创建空字符串，调用无参构造函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; s1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="function">string <span class="title">s2</span><span class="params">(str)</span></span>; <span class="comment">//把c_string转换成了string</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str2 = &quot;</span> &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">s3</span><span class="params">(s2)</span></span>; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">s4</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：string的多种构造方式没有可比性，灵活使用即可</p><h3 id="string赋值操作"><a class="header-anchor" href="#string赋值操作"></a>string赋值操作</h3><p>功能描述：给string字符串进行赋值</p><p>函数原型：</p><ul><li><code>string&amp; operator=(const char* s);</code> //char*类型字符串 赋值给当前的字符串</li><li><code>string&amp; operator=(const string &amp;s);</code> //把字符串s赋给当前的字符串</li><li><code>string&amp; operator=(char c);</code> //字符赋值给当前的字符串</li><li><code>string&amp; assign(const char *s);</code> //把字符串s赋给当前的字符串</li><li><code>string&amp; assign(const char *s, int n);</code> //把字符串s的前n个字符赋给当前的字符串</li><li><code>string&amp; assign(const string &amp;s);</code> //把字符串对象s的值赋给当前字符串</li><li><code>string&amp; assign(int n, char c);</code> //用n个字符c赋给当前字符串</li></ul><p>不同赋值函数的使用，示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str1;</span><br><span class="line">    str1 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    string str2;</span><br><span class="line">    str2 = str1;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str2 = &quot;</span> &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    string str3;</span><br><span class="line">    str3 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把字符串s赋给当前的字符串</span></span><br><span class="line">    string str4;</span><br><span class="line">    str4.<span class="built_in">assign</span>(<span class="string">&quot;hello c++&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str4 = &quot;</span> &lt;&lt; str4 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把字符串s的前n个字符赋给当前的字符串</span></span><br><span class="line">    string str5;</span><br><span class="line">    str5.<span class="built_in">assign</span>(<span class="string">&quot;hello c++&quot;</span>,<span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str5 = &quot;</span> &lt;&lt; str5 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把字符串对象s的值赋给当前字符串</span></span><br><span class="line">    string str6;</span><br><span class="line">    str6.<span class="built_in">assign</span>(str5);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str6 = &quot;</span> &lt;&lt; str6 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用n个字符c赋给当前字符串</span></span><br><span class="line">    string str7;</span><br><span class="line">    str7.<span class="built_in">assign</span>(<span class="number">5</span>, <span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str7 = &quot;</span> &lt;&lt; str7 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结： string的赋值方式很多，<code>operator=</code> 这种方式是比较实用的</p><h3 id="string字符串拼接"><a class="header-anchor" href="#string字符串拼接"></a>string字符串拼接</h3><p><strong>功能描述</strong>：实现在字符串末尾拼接字符串</p><p><strong>函数原型</strong>：</p><ul><li><code>string&amp; operator+=(const char* str);</code> //重载+=操作符</li><li><code>string&amp; operator+=(const char c);</code> //重载+=操作符</li><li><code>string&amp; operator+=(const string&amp; str);</code> //重载+=操作符</li><li><code>string&amp; append(const char *s);</code> //把字符串s连接到当前字符串结尾</li><li><code>string&amp; append(const char *s, int n);</code> //把字符串s的前n个字符连接到当前字符串结尾</li><li><code>string&amp; append(const string &amp;s);</code> //同operator+=(const string&amp; str)</li><li><code>string&amp; append(const string &amp;s, int pos, int n);</code>//字符串s中从pos开始的n个字符连接到字符串结尾</li></ul><p>拼接示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串拼接</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string str1 = <span class="string">&quot;你好&quot;</span>;</span><br><span class="line">    str1 += <span class="string">&quot;世界 &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    str1 += <span class="string">&#x27;:&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    string str2 = <span class="string">&quot; Hello,World&quot;</span>;</span><br><span class="line">    str1 += str2;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    string str3 = <span class="string">&quot;I&quot;</span>;</span><br><span class="line">    str3.<span class="built_in">append</span>(<span class="string">&quot; am &quot;</span>);</span><br><span class="line">    str3.<span class="built_in">append</span>(<span class="string">&quot;Halo Hola&quot;</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="comment">//str3.append(str2);</span></span><br><span class="line">    str3.<span class="built_in">append</span>(str2, <span class="number">4</span>, <span class="number">2</span>); <span class="comment">// 从下标4位置开始 ，截取3个字符，拼接到字符串末尾</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="string查找和替换"><a class="header-anchor" href="#string查找和替换"></a>string查找和替换</h3><p><strong>功能描述</strong>：</p><ul><li>查找：查找指定字符串是否存在</li><li>替换：在指定的位置替换字符串</li></ul><p><strong>函数原型</strong>：</p><ul><li><code>int find(const string&amp; str, int pos = 0) const;</code> //查找str第一次出现位置,从pos开始查找</li><li><code>int find(const char* s, int pos = 0) const;</code> //查找s第一次出现位置,从pos开始查找</li><li><code>int find(const char* s, int pos, int n) const;</code> //从pos位置查找s的前n个字符第一次位置</li><li><code>int find(const char c, int pos = 0) const;</code> //查找字符c第一次出现位置</li><li><code>int rfind(const string&amp; str, int pos = npos) const;</code> //查找str最后一次位置,从pos开始查找</li><li><code>int rfind(const char* s, int pos = npos) const;</code> //查找s最后一次出现位置,从pos开始查找</li><li><code>int rfind(const char* s, int pos, int n) const;</code> //从pos查找s的前n个字符最后一次位置</li><li><code>int rfind(const char c, int pos = 0) const;</code> //查找字符c最后一次出现位置</li><li><code>string&amp; replace(int pos, int n, const string&amp; str);</code> //替换从pos开始n个字符为字符串str</li><li><code>string&amp; replace(int pos, int n,const char* s);</code> //替换从pos开始的n个字符为字符串s</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找和替换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//查找</span></span><br><span class="line">    string str1 = <span class="string">&quot;abcdefgde&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> pos = str1.<span class="built_in">find</span>(<span class="string">&quot;de&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pos == <span class="number">-1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;未找到&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;pos = &quot;</span> &lt;&lt; pos &lt;&lt; endl; <span class="comment">// pos = 3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pos = str1.<span class="built_in">rfind</span>(<span class="string">&quot;de&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pos = &quot;</span> &lt;&lt; pos &lt;&lt; endl; <span class="comment">// pos = 7</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//替换</span></span><br><span class="line">    string str1 = <span class="string">&quot;abcdefgde&quot;</span>;</span><br><span class="line">    str1.<span class="built_in">replace</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="string">&quot;1111&quot;</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl; <span class="comment">// str1 = a1111efgde</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>find查找是从左往后，rfind从右往左</li><li>find找到字符串后返回查找的第一个字符位置，找不到返回-1</li><li>replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串</li></ul><h3 id="string字符串比较"><a class="header-anchor" href="#string字符串比较"></a>string字符串比较</h3><p><strong>功能描述</strong>：字符串之间的比较</p><p><strong>比较方式</strong>：字符串比较是按字符的ASCII码进行对比。等于返回 0；大于返回 1；小于返回 -1。</p><p><strong>函数原型</strong>：</p><ul><li><code>int compare(const string &amp;s) const;</code> //与字符串s比较</li><li><code>int compare(const char *s) const;</code> //与字符串s比较</li></ul><p>比较，示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串比较</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    string s2 = <span class="string">&quot;aello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = s1.<span class="built_in">compare</span>(s2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;s1 等于 s2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;s1 大于 s2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;s1 小于 s2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：字符串对比主要是用于比较两个字符串是否相等，判断谁大谁小的意义并不是很大</p><h3 id="string字符存取"><a class="header-anchor" href="#string字符存取"></a>string字符存取</h3><p>string中单个字符存取方式有两种</p><ul><li><code>char&amp; operator[](int n);</code> //通过[]方式取字符</li><li><code>char&amp; at(int n);</code> //通过at方法获取字符</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; str[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; str.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//字符修改</span></span><br><span class="line">    str[<span class="number">0</span>] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">    str.<span class="built_in">at</span>(<span class="number">1</span>) = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="string插入和删除"><a class="header-anchor" href="#string插入和删除"></a>string插入和删除</h3><p><strong>功能描述</strong>：对string字符串进行插入和删除字符操作</p><p><strong>函数原型</strong>：</p><ul><li><code>string&amp; insert(int pos, const char* s);</code> //插入字符串</li><li><code>string&amp; insert(int pos, const string&amp; str);</code> //插入字符串</li><li><code>string&amp; insert(int pos, int n, char c);</code> //在指定位置插入n个字符c</li><li><code>string&amp; erase(int pos, int n = npos);</code> //删除从pos开始的n个字符</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    str.<span class="built_in">insert</span>(<span class="number">1</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    str.<span class="built_in">erase</span>(<span class="number">1</span>, <span class="number">3</span>);  <span class="comment">//从1号位置开始3个字符</span></span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong>：插入和删除的起始下标都是从0开始</p><h3 id="string子串"><a class="header-anchor" href="#string子串"></a>string子串</h3><p><strong>功能描述</strong>：从字符串中获取想要的子串</p><p><strong>函数原型</strong>：<code>string substr(int pos = 0, int n = npos) const;</code> //返回由pos开始的n个字符组成的字符串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    string str = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">    string subStr = str.<span class="built_in">substr</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;subStr = &quot;</span> &lt;&lt; subStr &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    string email = <span class="string">&quot;hello@sina.com&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> pos = email.<span class="built_in">find</span>(<span class="string">&quot;@&quot;</span>);</span><br><span class="line">    string username = email.<span class="built_in">substr</span>(<span class="number">0</span>, pos);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;username: &quot;</span> &lt;&lt; username &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong>：灵活的运用求子串功能，可以在实际开发中获取有效的信息</p><h2 id="vector容器"><a class="header-anchor" href="#vector容器"></a>vector容器</h2><h3 id="vector基本概念"><a class="header-anchor" href="#vector基本概念"></a>vector基本概念</h3><p><strong>功能</strong>：vector数据结构和<strong>数组非常相似</strong>，也称为<strong>单端数组</strong>。vector容器的迭代器是支持随机访问的迭代器</p><p><strong>vector与普通数组区别</strong>：不同之处在于数组是静态空间，而vector可以<font color="#faa755">动态扩展</font></p><p><strong>动态扩展</strong>：并不是在原空间之后接新空间，而是找更大的内存空间，然后将原数据拷贝到新空间，释放原空间</p><h3 id="vector构造函数"><a class="header-anchor" href="#vector构造函数"></a>vector构造函数</h3><p><strong>功能描述</strong>：创建vector容器</p><p><strong>函数原型</strong>：</p><ul><li><code>vector&lt;T&gt; v;</code> //采用模板实现类实现，默认构造函数</li><li><code>vector(v.begin(), v.end());</code> //将<code>v[begin(), end())</code>区间中的元素拷贝给本身。</li><li><code>vector(n, elem);</code> //构造函数将n个elem拷贝给本身。</li><li><code>vector(const vector &amp;vec);</code> //拷贝构造函数。</li></ul><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v1; <span class="comment">//无参构造</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v2</span><span class="params">(v1.begin(), v1.end())</span></span>;</span><br><span class="line">    <span class="built_in">printVector</span>(v2);</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">10</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="built_in">printVector</span>(v3);</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v4</span><span class="params">(v3)</span></span>;</span><br><span class="line">    <span class="built_in">printVector</span>(v4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="vector赋值操作"><a class="header-anchor" href="#vector赋值操作"></a>vector赋值操作</h3><p><strong>功能描述</strong>：给vector容器进行赋值</p><p><strong>函数原型</strong>：</p><ul><li><code>vector&amp; operator=(const vector &amp;vec);</code>//重载等号操作符</li><li><code>assign(beg, end);</code> //将[beg, end)区间中的数据拷贝赋值给本身。</li><li><code>assign(n, elem);</code> //将n个elem拷贝赋值给本身。</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v1; <span class="comment">//无参构造</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">    v2 = v1;</span><br><span class="line">    <span class="built_in">printVector</span>(v2);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v3;</span><br><span class="line">    v3.<span class="built_in">assign</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">printVector</span>(v3);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v4;</span><br><span class="line">    v4.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">printVector</span>(v4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="vector容量和大小"><a class="header-anchor" href="#vector容量和大小"></a>vector容量和大小</h3><p><strong>功能描述</strong>：对vector容器的容量和大小操作</p><p><strong>函数原型</strong>：</p><ul><li><code>empty();</code> //判断容器是否为空</li><li><code>capacity();</code> //容器的容量</li><li><code>size();</code> //返回容器中元素的个数</li><li><code>resize(int num);</code> //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</li><li><code>resize(int num, elem);</code> //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printVector</span>(v1);</span><br><span class="line">    <span class="keyword">if</span> (v1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;v1为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;v1不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;v1的容量 = &quot;</span> &lt;&lt; v1.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;v1的大小 = &quot;</span> &lt;&lt; v1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//resize 重新指定大小 ，若指定的更大，默认用0填充新位置，可以利用重载版本替换默认填充</span></span><br><span class="line">    v1.<span class="built_in">resize</span>(<span class="number">15</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//resize 重新指定大小 ，若指定的更小，超出部分元素被删除</span></span><br><span class="line">    v1.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printVector</span>(v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>判断是否为空 — empty</li><li>返回元素个数 — size</li><li>返回容器容量 — capacity</li><li>重新指定大小 — resize</li></ul><h3 id="vector插入和删除"><a class="header-anchor" href="#vector插入和删除"></a>vector插入和删除</h3><p><strong>功能描述</strong>：对vector容器进行插入、删除操作</p><p><strong>函数原型</strong>：</p><ul><li><code>push_back(ele);</code> //尾部插入元素ele</li><li><code>pop_back();</code> //删除最后一个元素</li><li><code>insert(const_iterator pos, ele);</code> //迭代器指向位置pos插入元素ele</li><li><code>insert(const_iterator pos, int count,ele);</code>//迭代器指向位置pos插入count个元素ele</li><li><code>erase(const_iterator pos);</code> //删除迭代器指向的元素</li><li><code>erase(const_iterator start, const_iterator end);</code>//删除迭代器从start到end之间的元素</li><li><code>clear();</code> //删除容器中所有元素</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    <span class="comment">//尾插</span></span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">    <span class="built_in">printVector</span>(v1);</span><br><span class="line">    <span class="comment">//尾删</span></span><br><span class="line">    v1.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="built_in">printVector</span>(v1);</span><br><span class="line">    <span class="comment">//插入</span></span><br><span class="line">    v1.<span class="built_in">insert</span>(v1.<span class="built_in">begin</span>(), <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">    v1.<span class="built_in">insert</span>(v1.<span class="built_in">begin</span>(), <span class="number">2</span>, <span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除</span></span><br><span class="line">    v1.<span class="built_in">erase</span>(v1.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清空</span></span><br><span class="line">    v1.<span class="built_in">erase</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line">    v1.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">printVector</span>(v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>尾插 — push_back</li><li>尾删 — pop_back</li><li>插入 — insert (位置迭代器)</li><li>删除 — erase （位置迭代器）</li><li>清空 — clear</li></ul><h3 id="vector数据存取"><a class="header-anchor" href="#vector数据存取"></a>vector数据存取</h3><p><strong>功能描述</strong>：对vector中的数据的存取操作</p><p><strong>函数原型</strong>：</p><ul><li><code>at(int idx);</code> //返回索引idx所指的数据</li><li><code>operator[];</code> //返回索引idx所指的数据</li><li><code>front();</code> //返回容器中第一个数据元素</li><li><code>back();</code> //返回容器中最后一个数据元素</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; v1.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v1的第一个元素为： &quot;</span> &lt;&lt; v1.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v1的最后一个元素为： &quot;</span> &lt;&lt; v1.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>除了用迭代器获取vector容器中元素，[ ]和at也可以</li><li>front返回容器第一个元素</li><li>back返回容器最后一个元素</li></ul><h3 id="vector互换容器"><a class="header-anchor" href="#vector互换容器"></a>vector互换容器</h3><p><strong>功能描述</strong>：实现两个容器内元素进行互换</p><p><strong>函数原型</strong>：<code>swap(vec);</code> // 将vec与本身的元素互换</p><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        v2.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printVector</span>(v2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//互换容器</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;互换后&quot;</span> &lt;&lt; endl;</span><br><span class="line">    v1.<span class="built_in">swap</span>(v2);</span><br><span class="line">    <span class="built_in">printVector</span>(v1);</span><br><span class="line">    <span class="built_in">printVector</span>(v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    v.<span class="built_in">resize</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//收缩内存</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;(v).<span class="built_in">swap</span>(v); <span class="comment">//匿名对象</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：swap可以使两个容器互换，可以达到实用的收缩内存效果</p><h3 id="vector预留空间"><a class="header-anchor" href="#vector预留空间"></a>vector预留空间</h3><p><strong>功能描述</strong>：减少vector在动态扩展容量时的扩展次数</p><p><strong>函数原型</strong>：<code>reserve(int len);</code>//容器预留len个元素长度，预留位置不初始化，元素不可访问。</p><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//预留空间</span></span><br><span class="line">    v.<span class="built_in">reserve</span>(<span class="number">100000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="comment">// 统计扩容次数</span></span><br><span class="line">        <span class="keyword">if</span> (p != &amp;v[<span class="number">0</span>]) &#123;</span><br><span class="line">            p = &amp;v[<span class="number">0</span>];</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;扩容了 &quot;</span> &lt;&lt; num - <span class="number">1</span> &lt;&lt; <span class="string">&quot; 次&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：如果数据量较大，可以一开始利用reserve预留空间</p><h2 id="deque容器"><a class="header-anchor" href="#deque容器"></a>deque容器</h2><h3 id="deque容器基本概念"><a class="header-anchor" href="#deque容器基本概念"></a>deque容器基本概念</h3><p><strong>功能</strong>：双端数组，可以对头端进行插入删除操作</p><p><strong>deque与vector区别</strong>：</p><ul><li>vector对于头部的插入删除效率低，数据量越大，效率越低</li><li>deque相对而言，对头部的插入删除速度回比vector快</li><li>vector访问元素时的速度会比deque快，这和两者内部实现有关</li></ul><p>deque内部工作原理：deque内部有个<strong>中控器</strong>，维护每段缓冲区中的内容，缓冲区中存放真实数据，中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间。</p><p>deque容器的迭代器也是支持随机访问的</p><h3 id="deque构造函数"><a class="header-anchor" href="#deque构造函数"></a>deque构造函数</h3><p><strong>功能描述</strong>：deque容器构造</p><p><strong>函数原型</strong>：</p><ul><li><code>deque&lt;T&gt; deqT;</code> //默认构造形式</li><li><code>deque(beg, end);</code> //构造函数将[beg, end)区间中的元素拷贝给本身。</li><li><code>deque(n, elem);</code> //构造函数将n个elem拷贝给本身。</li><li><code>deque(const deque &amp;deq);</code> //拷贝构造函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> deque&lt;<span class="keyword">int</span>&gt; &amp;d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (deque&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//deque构造</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; d1; <span class="comment">//无参构造函数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        d1.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printDeque</span>(d1);</span><br><span class="line">    <span class="function">deque&lt;<span class="keyword">int</span>&gt; <span class="title">d2</span><span class="params">(d1.begin(), d1.end())</span></span>;</span><br><span class="line">    <span class="built_in">printDeque</span>(d2);</span><br><span class="line"></span><br><span class="line">    <span class="function">deque&lt;<span class="keyword">int</span>&gt; <span class="title">d3</span><span class="params">(<span class="number">10</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="built_in">printDeque</span>(d3);</span><br><span class="line"></span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; d4 = d3;</span><br><span class="line">    <span class="built_in">printDeque</span>(d4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong>：deque容器和vector容器的构造方式几乎一致，灵活使用即可</p><h3 id="deque赋值操作"><a class="header-anchor" href="#deque赋值操作"></a>deque赋值操作</h3><p><strong>功能描述</strong>：给deque容器进行赋值</p><p><strong>函数原型</strong>：</p><ul><li><code>deque&amp; operator=(const deque &amp;deq);</code> //重载等号操作符</li><li><code>assign(beg, end);</code> //将[beg, end)区间中的数据拷贝赋值给本身。</li><li><code>assign(n, elem);</code> //将n个elem拷贝赋值给本身。</li></ul><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> deque&lt;<span class="keyword">int</span>&gt; &amp;d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (deque&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; d1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        d1.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; d2;</span><br><span class="line">    d2 = d1;</span><br><span class="line">    <span class="built_in">printDeque</span>(d2);</span><br><span class="line"></span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; d3;</span><br><span class="line">    d3.<span class="built_in">assign</span>(d1.<span class="built_in">begin</span>(), d1.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">printDeque</span>(d3);</span><br><span class="line"></span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; d4;</span><br><span class="line">    d4.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">printDeque</span>(d4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：deque赋值操作也与vector相同，需熟练掌握</p><h3 id="deque大小操作"><a class="header-anchor" href="#deque大小操作"></a>deque大小操作</h3><p><strong>功能描述</strong>：对deque容器的大小进行操作</p><p><strong>函数原型</strong>：</p><ul><li><code>deque.empty();</code> //判断容器是否为空</li><li><code>deque.size();</code> //返回容器中元素的个数</li><li><code>deque.resize(num);</code> //重新指定容器的长度为num,若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</li><li><code>deque.resize(num, elem);</code> //重新指定容器的长度为num,若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</li></ul><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> deque&lt;<span class="keyword">int</span>&gt; &amp;d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (deque&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; d1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        d1.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断容器是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (d1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;d1为空!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;d1不为空!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">//统计大小</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;d1的大小为：&quot;</span> &lt;&lt; d1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重新指定大小</span></span><br><span class="line">    d1.<span class="built_in">resize</span>(<span class="number">15</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">    d1.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printDeque</span>(d1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>deque没有容量的概念</li><li>判断是否为空 — empty</li><li>返回元素个数 — size</li><li>重新指定个数 — resize</li></ul><h3 id="deque-插入和删除"><a class="header-anchor" href="#deque-插入和删除"></a>deque 插入和删除</h3><p><strong>功能描述</strong>：向deque容器中插入和删除数据</p><p><strong>函数原型</strong>：</p><p>两端插入操作：</p><ul><li><code>push_back(elem);</code> //在容器尾部添加一个数据</li><li><code>push_front(elem);</code> //在容器头部插入一个数据</li><li><code>pop_back();</code> //删除容器最后一个数据</li><li><code>pop_front();</code> //删除容器第一个数据</li></ul><p>指定位置操作：</p><ul><li><code>insert(pos,elem);</code> //在pos位置插入一个elem元素的拷贝，返回新数据的位置。</li><li><code>insert(pos,n,elem);</code> //在pos位置插入n个elem数据，无返回值。</li><li><code>insert(pos,beg,end);</code> //在pos位置插入[beg,end)区间的数据，无返回值。</li><li><code>clear();</code> //清空容器的所有数据</li><li><code>erase(beg,end);</code> //删除[beg,end)区间的数据，返回下一个数据的位置。</li><li><code>erase(pos);</code> //删除pos位置的数据，返回下一个数据的位置。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> deque&lt;<span class="keyword">int</span>&gt; &amp;d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (deque&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两端操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;=======两端操作=======&quot;</span> &lt;&lt; endl;</span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">    <span class="comment">//尾插</span></span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="comment">//头插</span></span><br><span class="line">    d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">    d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尾删</span></span><br><span class="line">    d.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="comment">//头删</span></span><br><span class="line">    d.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="built_in">printDeque</span>(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;=========插入=========&quot;</span> &lt;&lt; endl;</span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">    d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line">    <span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">    d.<span class="built_in">insert</span>(d.<span class="built_in">begin</span>(), <span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">    d.<span class="built_in">insert</span>(d.<span class="built_in">begin</span>(), <span class="number">2</span>, <span class="number">10000</span>);</span><br><span class="line">    <span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; d2;</span><br><span class="line">    d2.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    d2.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    d2.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    d.<span class="built_in">insert</span>(d.<span class="built_in">begin</span>(), d2.<span class="built_in">begin</span>(), d2.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">printDeque</span>(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;=========删除=========&quot;</span> &lt;&lt; endl;</span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">    d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line">    <span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">    d.<span class="built_in">erase</span>(d.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">    d.<span class="built_in">erase</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line">    d.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">printDeque</span>(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>插入和删除提供的位置是迭代器！</li><li>尾插 — push_back</li><li>尾删 — pop_back</li><li>头插 — push_front</li><li>头删 — pop_front</li></ul><h3 id="deque-数据存取"><a class="header-anchor" href="#deque-数据存取"></a>deque 数据存取</h3><p><strong>功能描述</strong>：对deque 中的数据的存取操作</p><p><strong>函数原型</strong>：</p><ul><li><code>at(int idx);</code> //返回索引idx所指的数据</li><li><code>operator[];</code> //返回索引idx所指的数据</li><li><code>front();</code> //返回容器中第一个数据元素</li><li><code>back();</code> //返回容器中最后一个数据元素</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据存取</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">    d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; d[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; d.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;front:&quot;</span> &lt;&lt; d.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;back:&quot;</span> &lt;&lt; d.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>除了用迭代器获取deque容器中元素，[ ]和at也可以</li><li>front返回容器第一个元素</li><li>back返回容器最后一个元素</li></ul><h3 id="deque-排序"><a class="header-anchor" href="#deque-排序"></a>deque 排序</h3><p><strong>功能描述</strong>：利用算法实现对deque容器进行排序</p><p><strong>算法</strong>：</p><ul><li><code>sort(iterator beg, iterator end)</code> //对beg和end区间内元素进行排序</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> deque&lt;<span class="keyword">int</span>&gt; &amp;d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (deque&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">    d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printDeque</span>(d);</span><br><span class="line">    <span class="built_in">sort</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：sort算法非常实用，使用时包含头文件 algorithm即可</p><h2 id="stack容器"><a class="header-anchor" href="#stack容器"></a>stack容器</h2><h3 id="stack-基本概念"><a class="header-anchor" href="#stack-基本概念"></a>stack 基本概念</h3><p>概念：stack是一种<strong>先进后出</strong>(First In Last Out,FILO)的数据结构，它只有一个出口</p><p>栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为</p><p>栈中进入数据称为 — <strong>入栈</strong> <code>push</code></p><p>栈中弹出数据称为 — <strong>出栈</strong> <code>pop</code></p><h3 id="stack-常用接口"><a class="header-anchor" href="#stack-常用接口"></a>stack 常用接口</h3><p>功能描述：栈容器常用的对外接口</p><p>构造函数：</p><ul><li><code>stack&lt;T&gt; stk;</code> //stack采用模板类实现， stack对象的默认构造形式</li><li><code>stack(const stack &amp;stk);</code> //拷贝构造函数</li></ul><p>赋值操作：</p><ul><li><code>stack&amp; operator=(const stack &amp;stk);</code> //重载等号操作符</li></ul><p>数据存取：</p><ul><li><code>push(elem);</code> //向栈顶添加元素</li><li><code>pop();</code> //从栈顶移除第一个元素</li><li><code>top();</code> //返回栈顶元素</li></ul><p>大小操作：</p><ul><li><code>empty();</code> //判断堆栈是否为空</li><li><code>size();</code> //返回栈的大小</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈容器常用接口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建栈容器 栈容器必须符合先进后出</span></span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向栈中添加元素，叫做 压栈 入栈</span></span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">//输出栈顶元素</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;栈顶元素为： &quot;</span> &lt;&lt; s.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="comment">//弹出栈顶元素</span></span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;栈的大小为：&quot;</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>入栈 — push</li><li>出栈 — pop</li><li>返回栈顶 — top</li><li>判断栈是否为空 — empty</li><li>返回栈大小 — size</li></ul><h2 id="queue-容器"><a class="header-anchor" href="#queue-容器"></a>queue 容器</h2><h3 id="queue-基本概念"><a class="header-anchor" href="#queue-基本概念"></a>queue 基本概念</h3><p>概念：Queue是一种<strong>先进先出</strong>(First In First Out,FIFO)的数据结构，它有两个出口</p><p>队列容器允许从一端新增元素，从另一端移除元素</p><p>队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为</p><p>队列中进数据称为 — <strong>入队</strong> <code>push</code></p><p>队列中出数据称为 — <strong>出队</strong> <code>pop</code></p><h3 id="queue-常用接口"><a class="header-anchor" href="#queue-常用接口"></a>queue 常用接口</h3><p>功能描述：栈容器常用的对外接口</p><p>构造函数：</p><ul><li><code>queue&lt;T&gt; que;</code> //queue采用模板类实现，queue对象的默认构造形式</li><li><code>queue(const queue &amp;que);</code> //拷贝构造函数</li></ul><p>赋值操作：</p><ul><li><code>queue&amp; operator=(const queue &amp;que);</code> //重载等号操作符</li></ul><p>数据存取：</p><ul><li><code>push(elem);</code> //往队尾添加元素</li><li><code>pop();</code> //从队头移除第一个元素</li><li><code>back();</code> //返回最后一个元素</li><li><code>front();</code> //返回第一个元素</li></ul><p>大小操作：</p><ul><li><code>empty();</code> //判断堆栈是否为空</li><li><code>size();</code> //返回栈的大小</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string m_Name;</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建队列</span></span><br><span class="line">    queue&lt;Person&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//准备数据</span></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;唐僧&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">1000</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">900</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;沙僧&quot;</span>, <span class="number">800</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向队列中添加元素  入队操作</span></span><br><span class="line">    q.<span class="built_in">push</span>(p1);</span><br><span class="line">    q.<span class="built_in">push</span>(p2);</span><br><span class="line">    q.<span class="built_in">push</span>(p3);</span><br><span class="line">    q.<span class="built_in">push</span>(p4);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列不提供迭代器，更不支持随机访问</span></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">//输出队头元素</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;队头元素-- 姓名： &quot;</span> &lt;&lt; q.<span class="built_in">front</span>().m_Name</span><br><span class="line">             &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; q.<span class="built_in">front</span>().m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;队尾元素-- 姓名： &quot;</span> &lt;&lt; q.<span class="built_in">back</span>().m_Name</span><br><span class="line">             &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; q.<span class="built_in">back</span>().m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="comment">//弹出队头元素</span></span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;队列大小为：&quot;</span> &lt;&lt; q.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>入队 — push</li><li>出队 — pop</li><li>返回队头元素 — front</li><li>返回队尾元素 — back</li><li>判断队是否为空 — empty</li><li>返回队列大小 — size</li></ul><h2 id="list容器"><a class="header-anchor" href="#list容器"></a>list容器</h2><h3 id="list基本概念"><a class="header-anchor" href="#list基本概念"></a>list基本概念</h3><p><strong>功能</strong>：将数据进行链式存储</p><p><strong>链表</strong>（list）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的</p><p>链表的组成：链表由一系列<strong>结点</strong>组成</p><p>结点的组成：一个是存储数据元素的<strong>数据域</strong>，另一个是存储下一个结点地址的<strong>指针域</strong></p><p>STL中的链表是一个双向循环链表</p><p>由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于<strong>双向迭代器</strong></p><p>list的优点：</p><ul><li>采用动态存储分配，不会造成内存浪费和溢出</li><li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li></ul><p>list的缺点：</p><ul><li>链表灵活，但是空间(指针域) 和 时间（遍历）额外耗费较大</li></ul><p>List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。</p><p>总结：STL中<strong>List和vector是两个最常被使用的容器</strong>，各有优缺点</p><h3 id="list构造函数"><a class="header-anchor" href="#list构造函数"></a>list构造函数</h3><p><strong>功能描述</strong>：创建list容器</p><p><strong>函数原型</strong>：</p><ul><li><code>list&lt;T&gt; lst;</code> //list采用采用模板类实现,对象的默认构造形式：</li><li><code>list(beg,end);</code> //构造函数将[beg, end)区间中的元素拷贝给本身。</li><li><code>list(n,elem);</code> //构造函数将n个elem拷贝给本身。</li><li><code>list(const list &amp;lst);</code> //拷贝构造函数。</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> list&lt;<span class="keyword">int</span>&gt; &amp;L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (list&lt;<span class="keyword">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    list&lt;<span class="keyword">int</span>&gt; L1;</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printList</span>(L1);</span><br><span class="line"></span><br><span class="line">    <span class="function">list&lt;<span class="keyword">int</span>&gt; <span class="title">L2</span><span class="params">(L1.begin(), L1.end())</span></span>;</span><br><span class="line">    <span class="built_in">printList</span>(L2);</span><br><span class="line"></span><br><span class="line">    <span class="function">list&lt;<span class="keyword">int</span>&gt; <span class="title">L3</span><span class="params">(L2)</span></span>;</span><br><span class="line">    <span class="built_in">printList</span>(L3);</span><br><span class="line"></span><br><span class="line">    <span class="function">list&lt;<span class="keyword">int</span>&gt; <span class="title">L4</span><span class="params">(<span class="number">10</span>, <span class="number">1000</span>)</span></span>;</span><br><span class="line">    <span class="built_in">printList</span>(L4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：list构造方式同其他几个STL常用容器，熟练掌握即可</p><h3 id="list-赋值和交换"><a class="header-anchor" href="#list-赋值和交换"></a>list 赋值和交换</h3><p><strong>功能描述</strong>：</p><ul><li>给list容器进行赋值，以及交换list容器</li></ul><p><strong>函数原型</strong>：</p><ul><li><code>assign(beg, end);</code> //将[beg, end)区间中的数据拷贝赋值给本身。</li><li><code>assign(n, elem);</code> //将n个elem拷贝赋值给本身。</li><li><code>list&amp; operator=(const list &amp;lst);</code> //重载等号操作符</li><li><code>swap(lst);</code> //将lst与本身的元素互换。</li></ul><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> list&lt;<span class="keyword">int</span>&gt; &amp;L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (list&lt;<span class="keyword">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值和交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;=========赋值=========&quot;</span> &lt;&lt; endl;</span><br><span class="line">    list&lt;<span class="keyword">int</span>&gt; L1;</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">    <span class="built_in">printList</span>(L1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//赋值</span></span><br><span class="line">    list&lt;<span class="keyword">int</span>&gt; L2;</span><br><span class="line">    L2 = L1;</span><br><span class="line">    <span class="built_in">printList</span>(L2);</span><br><span class="line"></span><br><span class="line">    list&lt;<span class="keyword">int</span>&gt; L3;</span><br><span class="line">    L3.<span class="built_in">assign</span>(L2.<span class="built_in">begin</span>(), L2.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">printList</span>(L3);</span><br><span class="line"></span><br><span class="line">    list&lt;<span class="keyword">int</span>&gt; L4;</span><br><span class="line">    L4.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">printList</span>(L4);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;=========交换=========&quot;</span> &lt;&lt; endl;</span><br><span class="line">    list&lt;<span class="keyword">int</span>&gt; L1;</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    list&lt;<span class="keyword">int</span>&gt; L2;</span><br><span class="line">    L2.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;交换前： &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">printList</span>(L1);</span><br><span class="line">    <span class="built_in">printList</span>(L2);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    L1.<span class="built_in">swap</span>(L2);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;交换后： &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">printList</span>(L1);</span><br><span class="line">    <span class="built_in">printList</span>(L2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="list-大小操作"><a class="header-anchor" href="#list-大小操作"></a>list 大小操作</h3><p><strong>功能描述</strong>：对list容器的大小进行操作</p><p><strong>函数原型</strong>：</p><ul><li><code>size();</code> //返回容器中元素的个数</li><li><code>empty();</code> //判断容器是否为空</li><li><code>resize(num);</code> //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。 如果容器变短，则末尾超出容器长度的元素被删除。</li><li><code>resize(num, elem);</code> //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。 如果容器变短，则末尾超出容器长度的元素被删除。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> list&lt;<span class="keyword">int</span>&gt; &amp;L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (list&lt;<span class="keyword">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    list&lt;<span class="keyword">int</span>&gt; L1;</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (L1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;L1为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;L1不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;L1的大小为： &quot;</span> &lt;&lt; L1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重新指定大小</span></span><br><span class="line">    L1.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printList</span>(L1);</span><br><span class="line"></span><br><span class="line">    L1.<span class="built_in">resize</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printList</span>(L1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>判断是否为空 — empty</li><li>返回元素个数 — size</li><li>重新指定个数 — resize</li></ul><h3 id="list-插入和删除"><a class="header-anchor" href="#list-插入和删除"></a>list 插入和删除</h3><p><strong>功能描述</strong>：</p><ul><li>对list容器进行数据的插入和删除</li></ul><p><strong>函数原型</strong>：</p><ul><li><code>push_back(elem);</code>//在容器尾部加入一个元素</li><li><code>pop_back();</code>//删除容器中最后一个元素</li><li><code>push_front(elem);</code>//在容器开头插入一个元素</li><li><code>pop_front();</code>//从容器开头移除第一个元素</li><li><code>insert(pos,elem);</code>//在pos位置插elem元素的拷贝，返回新数据的位置。</li><li><code>insert(pos,n,elem);</code>//在pos位置插入n个elem数据，无返回值。</li><li><code>insert(pos,beg,end);</code>//在pos位置插入[beg,end)区间的数据，无返回值。</li><li><code>clear();</code>//移除容器的所有数据</li><li><code>erase(beg,end);</code>//删除[beg,end)区间的数据，返回下一个数据的位置。</li><li><code>erase(pos);</code>//删除pos位置的数据，返回下一个数据的位置。</li><li><code>remove(elem);</code>//删除容器中所有与elem值匹配的元素。</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> list&lt;<span class="keyword">int</span>&gt; &amp;L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (list&lt;<span class="keyword">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    list&lt;<span class="keyword">int</span>&gt; L;</span><br><span class="line">    <span class="comment">//尾插</span></span><br><span class="line">    L.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    L.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    L.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    <span class="comment">//头插</span></span><br><span class="line">    L.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">    L.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line">    L.<span class="built_in">push_front</span>(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尾删</span></span><br><span class="line">    L.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//头删</span></span><br><span class="line">    L.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入</span></span><br><span class="line">    list&lt;<span class="keyword">int</span>&gt;::iterator it = L.<span class="built_in">begin</span>();</span><br><span class="line">    L.<span class="built_in">insert</span>(++it, <span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除</span></span><br><span class="line">    it = L.<span class="built_in">begin</span>();</span><br><span class="line">    L.<span class="built_in">erase</span>(++it);</span><br><span class="line">    <span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除</span></span><br><span class="line">    L.<span class="built_in">push_back</span>(<span class="number">10000</span>);</span><br><span class="line">    L.<span class="built_in">push_back</span>(<span class="number">10000</span>);</span><br><span class="line">    L.<span class="built_in">push_back</span>(<span class="number">10000</span>);</span><br><span class="line">    <span class="built_in">printList</span>(L);</span><br><span class="line">    L.<span class="built_in">remove</span>(<span class="number">10000</span>);</span><br><span class="line">    <span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清空</span></span><br><span class="line">    L.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">printList</span>(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>尾插 — push_back</li><li>尾删 — pop_back</li><li>头插 — push_front</li><li>头删 — pop_front</li><li>插入 — insert</li><li>删除 — erase</li><li>移除 — remove</li><li>清空 — clear</li></ul><h3 id="list-数据存取"><a class="header-anchor" href="#list-数据存取"></a>list 数据存取</h3><p><strong>功能描述</strong>：对list容器中数据进行存取</p><p><strong>函数原型</strong>：</p><ul><li><code>front();</code> //返回第一个元素。</li><li><code>back();</code> //返回最后一个元素。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据存取</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    list&lt;<span class="keyword">int</span>&gt; L1;</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//cout &lt;&lt; L1.at(0) &lt;&lt; endl;//错误 不支持at访问数据</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; L1[0] &lt;&lt; endl; //错误  不支持[]方式访问数据</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一个元素为： &quot;</span> &lt;&lt; L1.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;最后一个元素为： &quot;</span> &lt;&lt; L1.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//list容器的迭代器是双向迭代器，不支持随机访问</span></span><br><span class="line">    list&lt;<span class="keyword">int</span>&gt;::iterator it = L1.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">//it = it + 1;//错误，不可以跳跃访问，即使是+1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>list容器中不可以通过[]或者at方式访问数据</li><li>返回第一个元素 — front</li><li>返回最后一个元素 — back</li></ul><h3 id="list-反转和排序"><a class="header-anchor" href="#list-反转和排序"></a>list 反转和排序</h3><p><strong>功能描述</strong>：将容器中的元素反转，以及将容器中的数据进行排序</p><p><strong>函数原型</strong>：</p><ul><li><code>reverse();</code> //反转链表</li><li><code>sort();</code> //链表排序</li></ul><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> list&lt;<span class="keyword">int</span>&gt; &amp;L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (list&lt;<span class="keyword">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCompare</span><span class="params">(<span class="keyword">int</span> val1, <span class="keyword">int</span> val2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val1 &gt; val2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反转和排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    list&lt;<span class="keyword">int</span>&gt; L;</span><br><span class="line">    L.<span class="built_in">push_back</span>(<span class="number">90</span>);</span><br><span class="line">    L.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    L.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    L.<span class="built_in">push_back</span>(<span class="number">70</span>);</span><br><span class="line">    <span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反转容器的元素</span></span><br><span class="line">    L.<span class="built_in">reverse</span>();</span><br><span class="line">    <span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//排序</span></span><br><span class="line">    L.<span class="built_in">sort</span>(); <span class="comment">//默认的排序规则 从小到大</span></span><br><span class="line">    <span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">    L.<span class="built_in">sort</span>(myCompare); <span class="comment">//指定规则，从大到小</span></span><br><span class="line">    <span class="built_in">printList</span>(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>反转 — reverse</li><li>排序 — sort （成员函数）</li></ul><h2 id="set-multiset-容器"><a class="header-anchor" href="#set-multiset-容器"></a>set/multiset 容器</h2><h3 id="set基本概念"><a class="header-anchor" href="#set基本概念"></a>set基本概念</h3><p><strong>简介</strong>：所有元素都会在插入时自动被排序</p><p><strong>本质</strong>：set/multiset属于<strong>关联式容器</strong>，底层结构是用<strong>二叉树</strong>实现。</p><p><strong>set和multiset区别</strong>：</p><ul><li>set不允许容器中有重复的元素</li><li>multiset允许容器中有重复的元素</li></ul><h3 id="set构造和赋值"><a class="header-anchor" href="#set构造和赋值"></a>set构造和赋值</h3><p>功能描述：创建set容器以及赋值</p><p>构造：</p><ul><li><code>set&lt;T&gt; st;</code> //默认构造函数：</li><li><code>set(const set &amp;st);</code> //拷贝构造函数</li></ul><p>赋值：</p><ul><li><code>set&amp; operator=(const set &amp;st);</code> //重载等号操作符</li></ul><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSet</span><span class="params">(set&lt;<span class="keyword">int</span>&gt; &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (set&lt;<span class="keyword">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造和赋值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line"></span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">    <span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拷贝构造</span></span><br><span class="line">    <span class="function">set&lt;<span class="keyword">int</span>&gt; <span class="title">s2</span><span class="params">(s1)</span></span>;</span><br><span class="line">    <span class="built_in">printSet</span>(s2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//赋值</span></span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt; s3;</span><br><span class="line">    s3 = s2;</span><br><span class="line">    <span class="built_in">printSet</span>(s3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>set容器插入数据时用insert</li><li>set容器插入数据的数据会自动排序</li></ul><h3 id="set大小和交换"><a class="header-anchor" href="#set大小和交换"></a>set大小和交换</h3><p><strong>功能描述</strong>：</p><ul><li>统计set容器大小以及交换set容器</li></ul><p><strong>函数原型</strong>：</p><ul><li><code>size();</code> //返回容器中元素的数目</li><li><code>empty();</code> //判断容器是否为空</li><li><code>swap(st);</code> //交换两个集合容器</li></ul><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSet</span><span class="params">(set&lt;<span class="keyword">int</span>&gt; &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (set&lt;<span class="keyword">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line"></span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;s1为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;s1不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;s1的大小为： &quot;</span> &lt;&lt; s1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line"></span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt; s2;</span><br><span class="line"></span><br><span class="line">    s2.<span class="built_in">insert</span>(<span class="number">100</span>);</span><br><span class="line">    s2.<span class="built_in">insert</span>(<span class="number">300</span>);</span><br><span class="line">    s2.<span class="built_in">insert</span>(<span class="number">200</span>);</span><br><span class="line">    s2.<span class="built_in">insert</span>(<span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;交换前&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">printSet</span>(s1);</span><br><span class="line">    <span class="built_in">printSet</span>(s2);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;交换后&quot;</span> &lt;&lt; endl;</span><br><span class="line">    s1.<span class="built_in">swap</span>(s2);</span><br><span class="line">    <span class="built_in">printSet</span>(s1);</span><br><span class="line">    <span class="built_in">printSet</span>(s2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>统计大小 — size</li><li>判断是否为空 — empty</li><li>交换容器 — swap</li></ul><h3 id="set插入和删除"><a class="header-anchor" href="#set插入和删除"></a>set插入和删除</h3><p><strong>功能描述</strong>：</p><ul><li>set容器进行插入数据和删除数据</li></ul><p><strong>函数原型</strong>：</p><ul><li><code>insert(elem);</code> //在容器中插入元素。</li><li><code>clear();</code> //清除所有元素</li><li><code>erase(pos);</code> //删除pos迭代器所指的元素，返回下一个元素的迭代器。</li><li><code>erase(beg, end);</code> //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li><li><code>erase(elem);</code> //删除容器中值为elem的元素。</li></ul><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSet</span><span class="params">(set&lt;<span class="keyword">int</span>&gt; &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (set&lt;<span class="keyword">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">    <span class="comment">//插入</span></span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">    <span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除</span></span><br><span class="line">    s1.<span class="built_in">erase</span>(s1.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line">    s1.<span class="built_in">erase</span>(<span class="number">30</span>);</span><br><span class="line">    <span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清空</span></span><br><span class="line">    <span class="comment">//s1.erase(s1.begin(), s1.end());</span></span><br><span class="line">    s1.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">printSet</span>(s1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>插入 — insert</li><li>删除 — erase</li><li>清空 — clear</li></ul><h3 id="set查找和统计"><a class="header-anchor" href="#set查找和统计"></a>set查找和统计</h3><p><strong>功能描述</strong>：</p><ul><li>对set容器进行查找数据以及统计数据</li></ul><p><strong>函数原型</strong>：</p><ul><li><code>find(key);</code> //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li><li><code>count(key);</code> //统计key的元素个数</li></ul><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找和统计</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">    <span class="comment">//插入</span></span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找</span></span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt;::iterator pos = s1.<span class="built_in">find</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pos != s1.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;找到了元素 ： &quot;</span> &lt;&lt; *pos &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;未找到元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//统计</span></span><br><span class="line">    <span class="keyword">int</span> num = s1.<span class="built_in">count</span>(<span class="number">30</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>查找 — find （返回的是迭代器）</li><li>统计 — count （对于set，结果为0或者1）</li></ul><h3 id="set和multiset区别"><a class="header-anchor" href="#set和multiset区别"></a>set和multiset区别</h3><p>掌握set和multiset的区别</p><p><strong>区别</strong>：</p><ul><li>set不可以插入重复数据，而multiset可以</li><li>set插入数据的同时会返回插入结果，表示插入是否成功</li><li>multiset不会检测数据，因此可以插入重复数据</li></ul><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//set和multiset区别</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    pair&lt;set&lt;<span class="keyword">int</span>&gt;::iterator, <span class="keyword">bool</span>&gt; ret = s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret.second) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;第一次插入成功!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;第一次插入失败!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret.second) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;第二次插入成功!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;第二次插入失败!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//multiset</span></span><br><span class="line">    multiset&lt;<span class="keyword">int</span>&gt; ms;</span><br><span class="line">    ms.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    ms.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (multiset&lt;<span class="keyword">int</span>&gt;::iterator it = ms.<span class="built_in">begin</span>(); it != ms.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>如果不允许插入重复数据可以利用set</li><li>如果需要插入重复数据利用multiset</li></ul><h3 id="pair对组创建"><a class="header-anchor" href="#pair对组创建"></a>pair对组创建</h3><p><strong>功能描述</strong>：成对出现的数据，利用对组可以返回两个数据</p><p><strong>两种创建方式</strong>：</p><ul><li><code>pair&lt;type, type&gt; p ( value1, value2 );</code></li><li><code>pair&lt;type, type&gt; p = make_pair( value1, value2 );</code></li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对组创建</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pair&lt;string, int&gt; p(string(&quot;Tom&quot;), 20);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.first &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p.second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    pair&lt;string, <span class="keyword">int</span>&gt; p2 = <span class="built_in">make_pair</span>(<span class="string">&quot;Jerry&quot;</span>, <span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p2.first &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p2.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="set容器排序"><a class="header-anchor" href="#set容器排序"></a>set容器排序</h3><p>学习目标：set容器默认排序规则为从小到大，掌握如何改变排序规则</p><p>主要技术点：利用仿函数，可以改变排序规则</p><p><strong>示例一</strong> set存放内置数据类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCompare</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认从小到大</span></span><br><span class="line">    <span class="keyword">for</span> (set&lt;<span class="keyword">int</span>&gt;::iterator it = s1.<span class="built_in">begin</span>(); it != s1.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定排序规则</span></span><br><span class="line">    set&lt;<span class="keyword">int</span>, MyCompare&gt; s2;</span><br><span class="line">    s2.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    s2.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">    s2.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">    s2.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">    s2.<span class="built_in">insert</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (set&lt;<span class="keyword">int</span>, MyCompare&gt;::iterator it = s2.<span class="built_in">begin</span>(); it != s2.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例二</strong> set存放自定义数据类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string m_Name;</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">comparePerson</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Person &amp;p1, <span class="keyword">const</span> Person &amp;p2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//按照年龄进行排序  降序</span></span><br><span class="line">        <span class="keyword">return</span> p1.m_Age &gt; p2.m_Age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    set&lt;Person, comparePerson&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">23</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">27</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">21</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    s.<span class="built_in">insert</span>(p1);</span><br><span class="line">    s.<span class="built_in">insert</span>(p2);</span><br><span class="line">    s.<span class="built_in">insert</span>(p3);</span><br><span class="line">    s.<span class="built_in">insert</span>(p4);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (set&lt;Person, comparePerson&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于自定义数据类型，set必须指定排序规则才可以插入数据</p><h3 id="map-multimap容器"><a class="header-anchor" href="#map-multimap容器"></a>map/multimap容器</h3><h3 id="map基本概念"><a class="header-anchor" href="#map基本概念"></a>map基本概念</h3><p><strong>简介</strong>：</p><ul><li>map中所有元素都是pair</li><li>pair中第一个元素为key（键值），起到索引作用，第二个元素为value（实值）</li><li>所有元素都会根据元素的键值自动排序</li></ul><p><strong>本质</strong>：</p><ul><li>map/multimap属于<strong>关联式容器</strong>，底层结构是用二叉树实现。</li></ul><p><strong>优点</strong>：</p><ul><li>可以根据key值快速找到value值</li></ul><p>map和multimap<strong>区别</strong>：</p><ul><li>map不允许容器中有重复key值元素</li><li>multimap允许容器中有重复key值元素</li></ul><h3 id="map构造和赋值"><a class="header-anchor" href="#map构造和赋值"></a>map构造和赋值</h3><p><strong>功能描述</strong>：对map容器进行构造和赋值操作</p><p><strong>函数原型</strong>：</p><p><strong>构造</strong>：</p><ul><li><code>map&lt;T1, T2&gt; mp;</code> //map默认构造函数:</li><li><code>map(const map &amp;mp);</code> //拷贝构造函数</li></ul><p><strong>赋值</strong>：</p><ul><li><code>map&amp; operator=(const map &amp;mp);</code> //重载等号操作符</li></ul><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMap</span><span class="params">(map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m; <span class="comment">//默认构造</span></span><br><span class="line">    m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">    <span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line">    map&lt;int, int&gt; m2(m); //拷贝构造</span><br><span class="line">    <span class="built_in">printMap</span>(m2);</span><br><span class="line"></span><br><span class="line">    map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m3;</span><br><span class="line">    m3 = m2; <span class="comment">//赋值</span></span><br><span class="line">    <span class="built_in">printMap</span>(m3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：map中所有元素都是成对出现，插入数据时候要使用对组</p><h3 id="map大小和交换"><a class="header-anchor" href="#map大小和交换"></a>map大小和交换</h3><p><strong>功能描述</strong>：</p><ul><li>统计map容器大小以及交换map容器</li></ul><p>函数原型：</p><ul><li><code>size();</code> //返回容器中元素的数目</li><li><code>empty();</code> //判断容器是否为空</li><li><code>swap(st);</code> //交换两个集合容器</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMap</span><span class="params">(map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;m为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;m不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;m的大小为： &quot;</span> &lt;&lt; m.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">    map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m2;</span><br><span class="line">    m2.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">4</span>, <span class="number">100</span>));</span><br><span class="line">    m2.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">5</span>, <span class="number">200</span>));</span><br><span class="line">    m2.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">6</span>, <span class="number">300</span>));</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;交换前&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">printMap</span>(m);</span><br><span class="line">    <span class="built_in">printMap</span>(m2);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;交换后&quot;</span> &lt;&lt; endl;</span><br><span class="line">    m.<span class="built_in">swap</span>(m2);</span><br><span class="line">    <span class="built_in">printMap</span>(m);</span><br><span class="line">    <span class="built_in">printMap</span>(m2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>统计大小 — size</li><li>判断是否为空 — empty</li><li>交换容器 — swap</li></ul><h3 id="map插入和删除"><a class="header-anchor" href="#map插入和删除"></a>map插入和删除</h3><p><strong>功能描述</strong>：</p><ul><li>map容器进行插入数据和删除数据</li></ul><p><strong>函数原型</strong>：</p><ul><li><code>insert(elem);</code> //在容器中插入元素。</li><li><code>clear();</code> //清除所有元素</li><li><code>erase(pos);</code> //删除pos迭代器所指的元素，返回下一个元素的迭代器。</li><li><code>erase(beg, end);</code> //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li><li><code>erase(key);</code> //删除容器中值为key的元素。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMap</span><span class="params">(map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//插入</span></span><br><span class="line">    map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="comment">//第一种插入方式</span></span><br><span class="line">    m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">    <span class="comment">//第二种插入方式</span></span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">    <span class="comment">//第三种插入方式</span></span><br><span class="line">    m.<span class="built_in">insert</span>(map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::<span class="built_in">value_type</span>(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">    <span class="comment">//第四种插入方式</span></span><br><span class="line">    m[<span class="number">4</span>] = <span class="number">40</span>;</span><br><span class="line">    <span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除</span></span><br><span class="line">    m.<span class="built_in">erase</span>(m.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line">    m.<span class="built_in">erase</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清空</span></span><br><span class="line">    m.<span class="built_in">erase</span>(m.<span class="built_in">begin</span>(), m.<span class="built_in">end</span>());</span><br><span class="line">    m.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">printMap</span>(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>map插入方式很多，记住其一即可</li><li>插入 — insert</li><li>删除 — erase</li><li>清空 — clear</li></ul><h3 id="map查找和统计"><a class="header-anchor" href="#map查找和统计"></a>map查找和统计</h3><p><strong>功能描述</strong>：</p><ul><li>对map容器进行查找数据以及统计数据</li></ul><p><strong>函数原型</strong>：</p><ul><li><code>find(key);</code> //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li><li><code>count(key);</code> //统计key的元素个数</li></ul><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找和统计</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找</span></span><br><span class="line">    map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator pos = m.<span class="built_in">find</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pos != m.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;找到了元素 key = &quot;</span> &lt;&lt; (*pos).first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; (*pos).second &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;未找到元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//统计</span></span><br><span class="line">    <span class="keyword">int</span> num = m.<span class="built_in">count</span>(<span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>查找 — find （返回的是迭代器）</li><li>统计 — count （对于map，结果为0或者1）</li></ul><h3 id="map容器排序"><a class="header-anchor" href="#map容器排序"></a>map容器排序</h3><p><strong>学习目标</strong>：map容器默认排序规则为 按照key值进行 从小到大排序，掌握如何改变排序规则</p><p><strong>主要技术点</strong>：利用仿函数，可以改变排序规则</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCompare</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//默认从小到大排序</span></span><br><span class="line">    <span class="comment">//利用仿函数实现从大到小排序</span></span><br><span class="line">    map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, MyCompare&gt; m;</span><br><span class="line"></span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">4</span>, <span class="number">40</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">5</span>, <span class="number">50</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, MyCompare&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;key:&quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value:&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>利用仿函数可以指定map容器的排序规则</li><li>对于自定义数据类型，map必须要指定排序规则，同set容器</li></ul>]]></content>
      
      
      <categories>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL介绍</title>
      <link href="2021/04/18/C++/STL%E4%BB%8B%E7%BB%8D-stl-introduce/"/>
      <url>2021/04/18/C++/STL%E4%BB%8B%E7%BB%8D-stl-introduce/</url>
      
        <content type="html"><![CDATA[<h2 id="1-1-STL的诞生"><a class="header-anchor" href="#1-1-STL的诞生"></a>1.1 STL的诞生</h2><ul><li>长久以来，软件界一直希望建立一种可重复利用的东西</li><li>C++的<strong>面向对象</strong>和<strong>泛型编程</strong>思想，目的就是<strong>复用性的提升</strong></li><li>大多情况下，数据结构和算法都未能有一套标准,导致被迫从事大量重复工作</li><li>为了建立数据结构和算法的一套标准,诞生了<strong>STL</strong></li></ul><h2 id="1-2-STL基本概念"><a class="header-anchor" href="#1-2-STL基本概念"></a>1.2 STL基本概念</h2><ul><li>STL(Standard Template Library，<strong>标准模板库</strong>)</li><li>STL 从广义上分为: <strong>容器(container)、 算法(algorithm)、 迭代器(iterator)</strong></li><li><strong>容器</strong>和<strong>算法</strong>之间通过<strong>迭代器</strong>进行无缝连接。</li><li>STL 几乎所有的代码都采用了模板类或者模板函数</li></ul><h2 id="1-3-STL六大组件"><a class="header-anchor" href="#1-3-STL六大组件"></a>1.3 STL六大组件</h2><p>STL大体分为六大组件，分别是：<strong>容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器</strong></p><ol><li>容器：各种数据结构，如<code>vector</code>、<code>list</code>、<code>deque</code>、<code>set</code>、<code>map</code>等,用来存放数据。</li><li>算法：各种常用的算法，如<code>sort</code>、<code>find</code>、<code>copy</code>、<code>for_each</code>等</li><li>迭代器：扮演了容器与算法之间的胶合剂。</li><li>仿函数：行为类似函数，可作为算法的某种策略。</li><li>适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。</li><li>空间配置器：负责空间的配置与管理。</li></ol><h2 id="1-4-STL中容器、算法、迭代器"><a class="header-anchor" href="#1-4-STL中容器、算法、迭代器"></a>1.4 STL中容器、算法、迭代器</h2><h3 id="1-4-1-容器"><a class="header-anchor" href="#1-4-1-容器"></a>1.4.1 容器</h3><p><strong>容器</strong>：置物之所也</p><p>STL<strong>容器</strong>就是将运用<strong>最广泛的一些数据结构</strong>实现出来，常用的数据结构：数组, 链表,树, 栈, 队列, 集合, 映射表 等</p><p>这些容器分为<strong>序列式容器</strong>和<strong>关联式容器</strong>两种：</p><ul><li><strong>序列式容器</strong>：强调值的排序，序列式容器中的每个元素均有固定的位置。</li><li><strong>关联式容器</strong>：二叉树结构，各元素之间没有严格的物理上的顺序关系</li></ul><h3 id="1-4-2-算法"><a class="header-anchor" href="#1-4-2-算法"></a>1.4.2 算法</h3><p><strong>算法</strong>：问题之解法也</p><p>有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms)</p><p>算法分为：<strong>质变算法</strong>和<strong>非质变算法</strong>。</p><ul><li><p>质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等</p></li><li><p>非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等</p></li></ul><h3 id="1-4-3-迭代器"><a class="header-anchor" href="#1-4-3-迭代器"></a>1.4.3 迭代器</h3><p><strong>迭代器</strong>：容器和算法之间粘合剂</p><p>提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。</p><p>每个容器都有自己专属的迭代器</p><p>迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针</p><p>迭代器种类：</p><table><thead><tr><th>种类</th><th>功能</th><th>支持运算</th></tr></thead><tbody><tr><td>输入迭代器</td><td>对数据的只读访问</td><td>只读，支持++、==、！=</td></tr><tr><td>输出迭代器</td><td>对数据的只写访问</td><td>只写，支持++</td></tr><tr><td>前向迭代器</td><td>读写操作，并能向前推进迭代器</td><td>读写，支持++、==、！=</td></tr><tr><td>双向迭代器</td><td>读写操作，并能向前和向后操作</td><td>读写，支持++、–，</td></tr><tr><td>随机访问迭代器</td><td>读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器</td><td>读写，支持++、–、[n]、-n、&lt;、&lt;=、&gt;、&gt;=</td></tr></tbody></table><p>常用的容器中迭代器种类为双向迭代器，和随机访问迭代器</p><h2 id="1-5-容器、算法、迭代器初识"><a class="header-anchor" href="#1-5-容器、算法、迭代器初识"></a>1.5 容器、算法、迭代器初识</h2><p>STL中最常用的容器为Vector，可以理解为数组，下面我们将学习如何向这个容器中插入数据、并遍历这个容器</p><h3 id="1-5-1-Vector存放内置数据类型"><a class="header-anchor" href="#1-5-1-Vector存放内置数据类型"></a>1.5.1 Vector存放内置数据类型</h3><p>容器： <code>vector</code></p><p>算法： <code>for_each</code></p><p>迭代器： <code>vector&lt;int&gt;::iterator</code></p><p>创建<code>vector</code>容器并遍历输出，<strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyPrint</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建vector容器对象，并且通过模板参数指定容器中存放的数据的类型</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="comment">//向容器中放数据</span></span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//每一个容器都有自己的迭代器，迭代器是用来遍历容器中的元素</span></span><br><span class="line"><span class="comment">//v.begin()返回迭代器，这个迭代器指向容器中第一个数据</span></span><br><span class="line"><span class="comment">//v.end()返回迭代器，这个迭代器指向容器元素的最后一个元素的下一个位置</span></span><br><span class="line"><span class="comment">//vector&lt;int&gt;::iterator 拿到vector&lt;int&gt;这种容器的迭代器类型</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;::iterator pBegin = v.<span class="built_in">begin</span>();</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;::iterator pEnd = v.<span class="built_in">end</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种遍历方式：</span></span><br><span class="line"><span class="keyword">while</span> (pBegin != pEnd) &#123;</span><br><span class="line">cout &lt;&lt; *pBegin &lt;&lt; endl;</span><br><span class="line">pBegin++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种遍历方式：</span></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种遍历方式：</span></span><br><span class="line"><span class="comment">//使用STL提供标准遍历算法  头文件 algorithm</span></span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), MyPrint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">test</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-2-Vector存放自定义数据类型"><a class="header-anchor" href="#1-5-2-Vector存放自定义数据类型"></a>1.5.2 Vector存放自定义数据类型</h3><p><code>vector</code>中存放自定义数据类型，并打印输出，示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">        mName = name;</span><br><span class="line">        mAge = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string mName;</span><br><span class="line">    <span class="keyword">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存放对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建数据</span></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;eee&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p5);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;Person&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; (*it).mName &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; (*it).mAge &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//放对象指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;Person *&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建数据</span></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;eee&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    v.<span class="built_in">push_back</span>(&amp;p1);</span><br><span class="line">    v.<span class="built_in">push_back</span>(&amp;p2);</span><br><span class="line">    v.<span class="built_in">push_back</span>(&amp;p3);</span><br><span class="line">    v.<span class="built_in">push_back</span>(&amp;p4);</span><br><span class="line">    v.<span class="built_in">push_back</span>(&amp;p5);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;Person *&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        Person *p = (*it);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; p-&gt;mName &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; (*it)-&gt;mAge &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-3-Vector容器嵌套容器"><a class="header-anchor" href="#1-5-3-Vector容器嵌套容器"></a>1.5.3 Vector容器嵌套容器</h3><p>容器中嵌套容器，并将所有数据进行遍历输出，示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//容器嵌套容器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; v;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v3;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v4;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">        v2.<span class="built_in">push_back</span>(i + <span class="number">2</span>);</span><br><span class="line">        v3.<span class="built_in">push_back</span>(i + <span class="number">3</span>);</span><br><span class="line">        v4.<span class="built_in">push_back</span>(i + <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将容器元素插入到vector v中</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(v1);</span><br><span class="line">    v.<span class="built_in">push_back</span>(v2);</span><br><span class="line">    v.<span class="built_in">push_back</span>(v3);</span><br><span class="line">    v.<span class="built_in">push_back</span>(v4);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;vector&lt;<span class="keyword">int</span> &gt;&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator vit = (*it).<span class="built_in">begin</span>(); vit != (*it).<span class="built_in">end</span>(); vit++) &#123;</span><br><span class="line">            cout &lt;&lt; *vit &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统概述</title>
      <link href="2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
      <url>2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1>1 操作系统的概念</h1><p>操作系统（Operating System, OS）是指控制和管理整个计算机系统的硬件与软件资源，合理地组织、调度计算机的工作与资源的分配，进而为用户和其他软件提供方便接口与环境的程序集合。操作系统是计算机系统中最基本的<font color="#faa755">系统软件</font>。</p><h2 id="1-1-操作系统的目标和功能"><a class="header-anchor" href="#1-1-操作系统的目标和功能"></a>1.1 操作系统的目标和功能</h2><p>为了给多道程序提供良好的运行环境，操作系统应具有以下几方面的功能：<font color="#faa755">处理机管理</font>、<font color="#faa755">存储器管理</font>、<font color="#faa755">设备管理</font>和<font color="#faa755">文件管理</font>。为了方便用户使用操作系统，还必须向用户提供接口。同时，操作系统可用来扩充机器，以提供更方便的服务、更高的资源利用率。</p><h3 id="1-1-1-操作系统作为计算机系统资源的管理者"><a class="header-anchor" href="#1-1-1-操作系统作为计算机系统资源的管理者"></a>1.1.1 操作系统作为计算机系统资源的管理者</h3><ol><li><p>处理机管理</p><p>在多道程序环境下，处理机的分配和运行都以进程(或线程)为基本单位，因而对处理机的管理可归结为对进程的管理。并发是指在计算机内同时运行多个进程，因此进程何时创建、何时撤销、如何管理、如何避免冲突、合理共享就是进程管理的最主要的任务。进程管理的主要功能包括进程控制、进程同步、进程通信、死锁处理、处理机调度等。</p></li><li><p>存储器管理</p><p>存储器管理是为了给多道程序的运行提供良好的环境，方便用户使用及提高内存的利用率，主要包括内存分配与回收、地址映射、内存保护与共享和内存扩充等功能。</p></li><li><p>文件管理</p><p>计算机中的信息都是以文件的形式存在的，操作系统中负责文件管理的部分称为文件系统。文件管理包括文件存储空间的管理、目录管理及文件读写管理和保护等。</p></li><li><p>设备管理</p><p>设备管理的主要任务是完成用户的I/O请求，方便用户使用各种设备,并提高设备的利用率，主要包括缓冲管理、设备分配、设备处理和虚拟设备等功能。</p></li></ol><h3 id="1-1-2-操作系统作为用户与计算机硬件系统之间的接口"><a class="header-anchor" href="#1-1-2-操作系统作为用户与计算机硬件系统之间的接口"></a>1.1.2 操作系统作为用户与计算机硬件系统之间的接口</h3><p>为了让用户方便、快捷、可靠地操纵计算机硬件并运行自己的程序，操作系统还提供了用户接口。操作系统提供的接口主要分为两类:</p><ul><li>一类是命令接口，用户利用这些操作命令来组织和控制作业的执行;</li><li>另一类是程序接口，编程人员可以使用它们来请求操作系统服务。</li></ul><ol><li><p>命令接口</p><p>使用命令接口进行作业控制的主要方式有两种，即联机控制方式和脱机控制方式。按作业控制方式的不同，可将命令接口分为<font color="#ea66a6">联机命令接口</font>和<font color="#ea66a6">脱机命令接口</font>。</p><ul><li><p>联机命令接口又称交互式命令接口，适用于分时或实时系统的接口。它由一组键盘操作命令组成。用户通过控制台或终端输入操作命令，向系统提出各种服务要求。用户每输入一条命令，控制权就转给操作系统的命令解释程序，然后由命令解释程序解释并执行输入的命令，完成指定的功能。之后，控制权转回控制台或终端，此时用户又可输入下一条命令。联机命令接口可以这样理解:“雇主”说一句话,“工人”做一件事，并做出反馈，这就强调了<font color="#faa755">交互性</font>。</p></li><li><p>脱机命令接口又称批处理命令接口，适用于批处理系统，它由一组作业控制命令组成。脱机用户不能直接干预作业的运行，而应事先用相应的作业控制命令写成一份作业操作说明书，连同!作业一起提交给系统。系统调度到该作业时，由系统中的命令解释程序逐条解释执行作业说明书上的命令，从而间接地控制作业的运行。脱机命令接口可以这样理解:“雇主”把要“工人”做的事写在清单上,“工人”按照清单命令逐条完成这些事，这就是<font color="#faa755">批处理</font>。</p></li></ul></li><li><p>程序接口</p><p>程序接口由一组<font color="#ea66a6">系统调用</font>（也称<font color="#ea66a6">广义指令</font>）组成。用户通过在程序中使用这些系统调用来请求操作系统为其提供服务，如使用各种外部设备、申请分配和回收内存及其他各种要求。</p></li></ol><p>当前最为流行的是图形用户界面（GUI），即<font color="#ea66a6">图形接口</font>。GUI最终是通过调用程序接口实现的，用户通过鼠标和键盘在图形界面上单击或使用快捷键，就能很方便地使用操作系统。严格来说，图形接口不是操作系统的一部分，但图形接口所调用的系统调用命令是操作系统的一部分。</p><h3 id="1-1-3-操作系统用作扩充机器"><a class="header-anchor" href="#1-1-3-操作系统用作扩充机器"></a>1.1.3 操作系统用作扩充机器</h3><p>没有任何软件支持的计算机称为裸机，它仅构成计算机系统的物质基础，而实际呈现在用户面前的计算机系统是经过若干层软件改造的计算机。裸机在最里层，其外面是操作系统。操作系统所提供的资源管理功能和方便用户的各种服务功能，将裸机改造成功能更强、使用更方便的机器;因此，我们通常把覆盖了软件的机器称为扩充机器或虚拟机。</p><h2 id="1-2-操作系统的特征"><a class="header-anchor" href="#1-2-操作系统的特征"></a>1.2 操作系统的特征</h2><p>操作系统是一种系统软件，但与其他系统软件和应用软件有很大的不同，它有自己的特殊性即基本特征。操作系统的基本特征包括并发、共享、虚拟和异步。这些概念对理解和掌握操作系统的核心至关重要，将一直贯穿于各个章节中。</p><h3 id="1-2-1-并发-Concurrence"><a class="header-anchor" href="#1-2-1-并发-Concurrence"></a>1.2.1 并发(Concurrence)</h3><p><font color="#ad1a72">并发</font>是指两个或多个事件在同一时间间隔内发生。操作系统的并发性是指计算机系统中同时存在多个运行的程序，因此它具有处理和调度多个程序同时执行的能力。在操作系统中，引入进程的目的是使程序能并发执行。</p><p>注意同一时间间隔(并发)和同一时刻(并行)的区别。在多道程序环境下，一段时间内，<font color="#faa755">宏观</font>上有多道程序在同时执行，而在每个时刻，单处理机环境下实际仅能有一道程序执行，因此<font color="#faa755">微观</font>上这些程序仍是分时交替执行的。操作系统的并发性是<font color="#faa755">通过分时得以实现的</font>。</p><p>注意，<font color="#ad1a72">并行性</font>是指系统具有同时进行运算或操作的特性，在同一时刻能完成两种或两种以上的工作。并行性需要有相关硬件的支持，如多流水线或多处理机硬件环境。</p><p>我们以现实生活中的直观例子来认识并发和并行的区别。例如，如果你在9:00-9:10 仅吃面包，在9:10-9:20 仅写字，在9:20-9:30 仅吃面包，在9:30-10:00仅写字，那么在9:00-10:00吃面包和写字这两种行为就是并发执行的;再如，如果你在9:00-10:00 右手写字，左手同时拿着面包吃，那么这两个动作就是并行执行的。</p><h3 id="1-2-2-共享-Sharing"><a class="header-anchor" href="#1-2-2-共享-Sharing"></a>1.2.2 共享(Sharing)</h3><p>资源共享即共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。</p><p>共享可分为以下两种资源共享方式:</p><ol><li><p>互斥共享方式</p><p>系统中的某些资源，如打印机、磁带机，虽然可供多个进程使用，但为使得所打印或记录的结果不致造成混淆，应规定<font color="#faa755">在一段时间内只允许一个进程访问该资源</font>。为此，当进程A访问某个资源时，必须先提出请求，若此时该资源空闲，则系统便将之分配给进程A使用，此后有其他进程也要访问该资源时(只要A未用完)就必须等待。仅当进程A访问完并释放该资源后，才允许另一个进程对该资源进行访问。我们把这种资源共享方式称为互斥式共享，而把在一段时间内只允许一个进程访问的资源称为临界资源或独占资源。计算机系统中的大多数物理设备及某些软件中所用的栈、变量和表格，都属于临界资源，它们都要求被互斥地共享。</p></li><li><p>同时访问方式</p><p>系统中还有另一类资源，这类资源<font color="#faa755">允许在一段时间内由多个进程“同时”访问</font>。这里所说的“同时”通常是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问即“分时共享”的。可供多个进程“同时”访问的典型资源是磁盘设备，一些用重入码编写的文件也可被“同时”共享，即允许若干个用户同时访问该文件。</p></li></ol><p>注意，互斥共享要求一种资源在一段时间内(哪怕是一段很小的时间)只能满足一个请求，否则就会出现严重的问题，(你能想象打印机第一行打印A文档的内容、第二行打印B文档的内容的效果吗?)而同时访问共享通常要求一个请求分几个时间片段间隔地完成，其效果与连续完成的效果相同。</p><p><font color="#FF666">并发和共享是操作系统两个最基本的特征，两者之间互为存在的条件</font>:</p><ol><li>资源共享是以程序的并发为条件的，若系统不允许程序并发执行，则自然不存在资源共享问题;</li><li>若系统不能对资源共享实施有效的管理，则必将影响到程序的并发执行，甚至根本无法并发执行。</li></ol><h3 id="1-2-3-虚拟（Virtual）"><a class="header-anchor" href="#1-2-3-虚拟（Virtual）"></a>1.2.3 虚拟（Virtual）</h3><p>虚拟是指把一个物理上的实体变为若干逻辑上的对应物。物理实体(前者)是实的，即实际存在的;而后者是虚的，是用户感觉上的事物。用于实现虚拟的技术，称为虚拟技术。操作系统中利用了多种虚拟技术来实现虚拟处理器、虚拟内存和虚拟外部设备等。</p><p><font color="#FF666">时分复用技术</font>:虚拟处理器技术是通过多道程序设计技术，采用让多道程序并发执行的方法，来分时使用一个处理器的。此时，虽然只有一个处理器，但它能同时为多个用户服务，使每个终端用户都感觉有一个中央处理器(CPU) 在专门为它服务。利用多道程序设计技术把一个物理 上的CPU虚拟为多个逻辑上的CPU，称为虚拟处理器。</p><p><font color="#FF666">空分复用技术</font>:类似地，可以采用虚拟存储器技术将一台机器的物理存储器变为虚拟存储器，以便从逻辑上扩充存储器的容量。当然，这时用户所感觉到的内存容量是虚的。我们把用户感觉到(但实际不存在)的存储器称为虚拟存储器。</p><p>还可采用虚拟设备技术将一台物理I/O设备虚拟为多台逻辑上的I/O设备，并允许每个用户占用一台逻辑上的I/O设备，使原来仅允许在一段时间内由一个用户访问的设备(即临界资源)变为在一段时间内允许多个用户同时访问的共享设备。</p><p>因此，操作系统的虚拟技术可归纳为:时分复用技术，如处理器的分时共享;空分复用技术，如虚拟存储器。</p><h3 id="1-2-4-异步（Asynchronism）"><a class="header-anchor" href="#1-2-4-异步（Asynchronism）"></a>1.2.4 异步（Asynchronism）</h3><p>多道程序环境允许多个程序并发执行，但由于资源有限，进程的执行并不是一贯到底的，而是走走停停的，它以不可预知的速度向前推进，这就是进程的异步性。</p><p>异步性使得操作系统运行在一种随机的环境下，可能导致进程产生与时间有关的错误(就像对全局变量的访问顺序不当会导致程序出错一样)。然而，只要运行环境相同，操作系统就须保证多次运行进程后都能获得相同的结果。</p><h1>2 操作系统的发展与分类</h1><h2 id="2-1-手工操作系统阶段-此阶段无操作系统"><a class="header-anchor" href="#2-1-手工操作系统阶段-此阶段无操作系统"></a>2.1 手工操作系统阶段(此阶段无操作系统)</h2><p>用户在计算机上算题的所有工作都要人工干预，如程序的装入、运行、结果的输出等。随着计算机硬件的发展，人机矛盾(速度和资源利用)越来越大，必须寻求新的解决办法。</p><p>手工操作阶段有两个突出的缺点:</p><ol><li>用户独占全机，不会出现因资源已被其他用户占用而等待的现象，但资源利用率低。</li><li>CPU等待手工操作，CPU的利用不充分。</li></ol><p>唯一的解决办法就是用高速的机器代替相对较慢的手工操作来对作业进行控制。</p><h2 id="2-2-批处理阶段-操作系统开始出现"><a class="header-anchor" href="#2-2-批处理阶段-操作系统开始出现"></a>2.2 批处理阶段(操作系统开始出现)</h2><p>为了解决人机矛盾及CPU和I/O设备之间速度不匹配的矛盾，出现了批处理系统。它按发展历程又分为单道批处理系统、多道批处理系统(多道程序设计技术出现以后)。</p><h3 id="2-2-1-单道批处理系统"><a class="header-anchor" href="#2-2-1-单道批处理系统"></a>2.2.1 单道批处理系统</h3><p>系统对作业的处理是成批进行的，但内存中始终保持一道作业。 单道批处理系统是在解决人机矛盾及CPU和I/O设备速率不匹配的矛盾中形成的。单道批处理系统的主要特征如下:</p><ol><li><font color="#faa755">自动性</font>。在顺利的情况下，磁带上的一批作业能自动地逐个运行，而无须人工干预。</li><li><font color="#faa755">顺序性</font>。磁带上的各道作业顺序地进入内存，各道作业的完成顺序与它们进入内存的顺序在正常情况下应完全相同，亦即先调入内存的作业先完成。</li><li><font color="#faa755">单道性</font>。内存中仅有一道程序运行，即监督程序每次从磁带上只调入一道程序进入内存运行，当该程序完成或发生异常情况时，才换入其后继程序进入内存运行。</li></ol><p>此时面临的问题是:每次主机内存中仅存放一道作业， 每当它在运行期间(注意这里是“运行时”而不是“完成后”)发出输入/输出请求后，高速的CPU便处于等待低速的I/O完成状态。为了进一步提高资源的利用率和系统的吞吐量，引入了多道程序技术。</p><h3 id="2-2-2-多道批处理系统"><a class="header-anchor" href="#2-2-2-多道批处理系统"></a>2.2.2 多道批处理系统</h3><p>多道程序设计技术允许多个程序同时进入内存并允许它们在CPU中交替地运行，这些程序共享系统中的各种硬/软件资源。当一道程序因I/O请求而暂停运行时，CPU便立即转去运行另一道程序。它不采用某些机制来提高某一技术方面的瓶颈问题，而让系统的各个组成部分都尽量去“忙”，因此切换任务所花费的时间很少，可实现系统各部件之间的并行工作，使其整体在单位时间内的效率翻倍。</p><p>当然，多道批处理系统的设计和实现要比单道系统复杂很多，因为要充分利用各种资源，就要涉及各种资源的调度问题。</p><p>多道程序设计的特点是多道、宏观上并行、微观上串行。</p><ol><li><font color="#faa755">多道</font>。计算机内存中同时存放多道相互独立的程序。</li><li><font color="#faa755">宏观上并行</font>。同时进入系统的多道程序都处于运行过程中，即它们先后开始各自的运行，但都未运行完毕。</li><li><font color="#faa755">微观上串行</font>。内存中的多道程序轮流占有CPU，交替执行。</li></ol><p>多道程序设计技术的实现需要解决下列问题:</p><ol><li>如何分配处理器。</li><li>多道程序的内存分配问题。</li><li>I/O设备如何分配。</li><li>如何组织和存放大量的程序和数据，以方便用户使用并保证其安全性与一致性。</li></ol><p>在批处理系统中采用多道程序设计技术就形成了多道批处理操作系统。该系统把用户提交的作业成批地送入计算机内存，然后由作业调度程序自动地选择作业运行.</p><p>优点:</p><ul><li>资源利用率高，多道程序共享计算机资源，从而使各种资源得到充分利用;</li><li>系统吞吐量大，CPU和其他资源保持“忙碌”状态。</li></ul><p>缺点:</p><ul><li>用户响应的时间较长;</li><li>不提供人机交互能力，用户既不能了解自己的程序的运行情况，又不能控制计算机。</li></ul><h3 id="2-2-3-分时操作系统"><a class="header-anchor" href="#2-2-3-分时操作系统"></a>2.2.3 分时操作系统</h3><p>所谓<font color="#ea66a6">分时技术</font>，是指把处理器的运行时间分成很短的时间片，按时间片轮流把处理器分配给各联机作业使用。若某个作业在分配给它的时间片内不能完成其计算，则该作业暂时停止运行，把处理器让给其他作业使用，等待下一轮再继续运行。由于计算机速度很快，作业运行轮转得也很快，因此给每个用户的感觉就像是自己独占一台计算机。</p><p>分时操作系统是指多个用户通过终端同时共享一台主机，这些终端连接在主机上，用户可以同时与主机进行交互操作而互不干扰。因此，实现分时系统最关键的问题是如何使用户能与自己的作业进行交互，即当用户在自己的终端上键入命令时，系统应能及时接收并及时处理该命令，再将结果返回用户。分时系统也是支持多道程序设计的系统，但它不同于多道批处理系统。多道批处理是实现作业自动控制而无须人工干预的系统，而分时系统是实现人机交互的系统，这使得分时系统具有与批处理系统不同的特征。分时系统的主要特征如下:</p><ol><li><font color="#faa755">同时性</font>。同时性也称多路性，指允许多个终端用户同时使用一台计算机，即一台计算机与若干台终端相连接，终端上的这些用户可以同时或基本同时使用计算机。</li><li><font color="#faa755">交互性</font>。用户能够方便地与系统进行人机对话，即用户通过终端采用人机对话的方式直接控制程序运行，与同程序进行交互。</li><li><font color="#faa755">独立性</font>。系统中多个用户可以彼此独立地进行操作，互不干扰，单个用户感觉不到别人也在使用这台计算机，好像只有自己单独使用这台计算机一样。</li><li><font color="#faa755">及时性</font>。用户请求能在很短时间内获得响应。分时系统采用时间片轮转方式使一台计算机同时为多个终端服务，使用户能够对系统的及时响应感到满意。</li></ol><p>虽然分时操作系统较好地解决了人机交互问题，但在一些应用场合，需要系统能对外部的信息在规定的时间(比时间片的时间还短)内做出处理(比如飞机订票系统或导弹制导系统)。因此，实时系统应运而生。</p><h3 id="2-2-4-实时操作系统"><a class="header-anchor" href="#2-2-4-实时操作系统"></a>2.2.4 实时操作系统</h3><p>为了能在某个时间限制内完成某些紧急任务而不需要时间片排队，诞生了实时操作系统。这里的时间限制可以分为两种情况:</p><ol><li>若某个动作必须绝对地在规定的时刻(或规定的时间范围)发生，则称为<font color="#ea66a6">硬实时系统</font>，如飞行器的飞行自动控制系统，这类系统必须提供绝对保证，让某个特定的动作在规定的时间内完成。</li><li>若能够接受偶尔违反时间规定且不会引起任何永久性的损害，则称为<font color="#ea66a6">软实时系统</font>，如飞机订票系统、银行管理系统。</li></ol><p>在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并在严格的时限内处理完接收的事件。实时操作系统的主要特点是及时性和可靠性。</p><h3 id="2-2-5-网络操作系统和分布式计算机系统"><a class="header-anchor" href="#2-2-5-网络操作系统和分布式计算机系统"></a>2.2.5 网络操作系统和分布式计算机系统</h3><p>网络操作系统把计算机网络中的各台计算机有机地结合起来，提供一种统一、 经济而有效的使用各台计算机的方法，实现各台计算机之间数据的互相传送。网络操作系统最主要的特点是网络中各种资源的共享及各台计算机之间的通信。</p><p>分布式计算机系统是由多台计算机组成并满足下列条件的系统:</p><ul><li>系统中任意两台计算机通过通信方式交换信息;</li><li>系统中的每台计算机都具有同等的地位，即没有主机也没有从机;</li><li>每台计算机上的资源为所有用户共享;</li><li>系统中的任意台计算机都可以构成一个子系统，并且还能重构;</li><li>任何工作都可以分布在几台计算机上，由它们并行工作、协同完成。</li></ul><p>用于管理分布式计算机系统的操作系统称为分布式计算机系统。该系统的主要特点是:<font color="#faa755">分布性和并行性</font>。分布式操作系统与网络操作系统的本质不同是,分布式操作系统中的若干计算机相互协同完成同一任务。</p><h3 id="2-2-6-个人计算机操作系统"><a class="header-anchor" href="#2-2-6-个人计算机操作系统"></a>2.2.6 个人计算机操作系统</h3><p>个人计算机操作系统是目前使用最广泛的操作系统，它广泛应用于文字处理、电子表格、游戏中，常见的有Windows、Linux和Macintosh等。</p><hr><p>此外,还有嵌入式操作系统、服务器操作系统、智能手机操作系统等。</p><h1>3 操作系统的运行环境</h1><h2 id="3-1-操作系统的运行机制"><a class="header-anchor" href="#3-1-操作系统的运行机制"></a>3.1 操作系统的运行机制</h2><p>两种指令:特权指令和非特权指令;</p><p>两种处理器状态:用户态(目态)和核心态(管态);</p><p>两种程序:内核程序和应用程序.</p><hr><p>计算机系统中，通常CPU执行两种不同性质的程序:</p><ol><li>一种是操作系统内核程序;</li><li>另一种是用户自编程序(即系统外层的应用程序，或简称“应用程序”)。</li></ol><p>对操作系统而言，这两种程序的作用不同，前者是后者的管理者，因此“管理程序”(即内核程序)要执行一些特权指令，而“被<br>管理程序”(即用户自编程序)出于安全考虑不能执行这些指令。</p><p>所谓<font color="#ea66a6">特权指令</font>，是指计算机中<font color="#faa755">不允许用户直接使用的指令</font>，如I/O指令、置中断指令，存取用于内存保护的寄存器、送程序状态字到程序状态字寄存器等的指令。</p><p>在具体实现上，将CPU的状态划分为<font color="#ea66a6">用户态(目态)</font>和<font color="#ea66a6">核心态(又称管态、内核态)</font>。可以理解为CPU内部有一个小开关，</p><ul><li>当小开关为1时，CPU处于核心态，此时CPU可以执行特权指令；</li><li>当小开关为0时，CPU处于用户态，此时CPU只能执行非特权指令。</li></ul><p><font color="#ea66a6">用户自编程序</font>运行在用户态，<font color="#ea66a6">操作系统内核程序</font>运行在核心态。</p><p>在软件工程思想和结构程序设计方法影响下诞生的现代操作系统,几乎都是层次式的结构。操作系统的各项功能分别被设置在不同的层次上。</p><p>一些与硬件关联较紧密的模块，如时钟管理、中断处理、设备驱动等处于最低层。其次是运行频率较高的程序，如进程管理、存储器管理和设备管理等。这两部分内容构成了<font color="#ea66a6">操作系统的内核</font>。这部分内容的指令操作工作在核心态。</p><p>内核是计算机上配置的底层<font color="#faa755">软件</font>，是计算机功能的延伸,是操作系统最基本、最核心的部分。不同系统对内核的定义稍有区别，大多数操作系统内核包括4方面的内容。</p><ol><li><p>时钟管理</p><p>在计算机的各种部件中，时钟是最关键的设备。时钟的第一功能是<font color="#faa755">计时</font>，操作系统需要通过时钟管理，向用户提供标准的系统时间。另外，通过<font color="#faa755">时钟中断的管理</font>，可以实现进程的切换。例如，在分时操作系统中采用时间片轮转调度，在实时系统中按截止时间控制运行，在批处理系统中通过时钟管理来衡量一个作业的运行程度等。因此，系统管理的方方面面无不依赖于时钟。</p></li><li><p>中断机制</p><p>引入中断技术的初衷是提高多道程序运行环境中CPU的利用率，而且主要是针对外部设备的。后来逐步得到发展，形成了多种类型，成为操作系统各项操作的基础。例如，键盘或鼠标信息的输入、进程的管理和调度、系统功能的调用、设备驱动、文件访问等，无不依赖于中断机制。可以说，现代操作系统是靠中断驱动的软件。</p><p>中断机制中，只有一小部分功能属于内核，它们负责保护和恢复中断现场的信息，转移控制权到相关的处理程序。这样可以减少中断的处理时间，提高系统的并行处理能力。</p></li><li><p>原语</p></li></ol><p>按层次结构设计的操作系统，底层必然是一些可被调用的公用小程序，它们各自完成一个规定的操作。它们的特点如下:</p><ul><li><p>处于操作系统的最低层，是最接近硬件的部分。</p></li><li><p>这些程序的运行具有<font color="#faa755">原子性</font>，其操作只能一气呵成(主要从系统安全性和便于管理考虑)。</p></li><li><p>这些程序的运行时间都较短，而且调用频繁。</p><p>通常把具有这些特点的程序称为原语(Atomic Operation)。定义原语的直接方法是关闭中断，让其所有动作不可分割地完成后再打开中断。<br>系统中的设备驱动、CPU切换、进程通信等功能中的部分操作都可定义为原语，使它们成为内核的组成部分。</p></li></ul><ol start="4"><li><p>系统控制的数据结构及处理.</p><p>系统中用来登记状态信息的数据结构很多，如作业控制块、进程控制块(PCB)、设备控制块、各类链表、消息队列、缓冲区、空闲区登记表、内存分配表等。为了实现有效的管理，系统需要一些基本的操作，常见的操作有以下3种:</p><ul><li>进程管理。进程状态管理、进程调度和分派、创建与撤销进程控制块等。</li><li>存储器管理。存储器的空间分配和回收、内存信息保护程序、代码对换程序等。</li><li>设备管理。缓冲区管理、设备分配和回收等。</li></ul></li></ol><p>从上述内容可以了解，核心态指令实际上包括系统调用类指令和一些针对时钟、中断和原语的操作指令。</p><h2 id="3-2-大内核和微内核"><a class="header-anchor" href="#3-2-大内核和微内核"></a>3.2 大内核和微内核</h2><p>操作系统的体系结构是一个开放的问题 。 如上文所述，操作系统在核心态为应用程序提供公共的服务，那么操作系统在核心态应该提供什么服务、怎样提供服务？有关这一 问题的回答形成了两种主要的体系结构：大内核和微内核 。</p><p>大内核系统将操作系统的主要功能模块都作为一个紧密联系的整体运行在核心态，从而为应用提供高性能的系统服务 。 因为各管理模块之间共享信息，能有效利用相互之间的有效特性，所以具有无可比拟的性能优势 。</p><p>但随着体系结构和应用 需求的不断发展，需要操作系统提供的服务越来越多，而且接口形式越来越复杂，操作系统的设计规模急剧增长，操作系统也面临着 “软件危机”困境 。 为此，操作系统设计人员试图按照复杂性、时间常数、抽象级别等因素，将操作系统内核分成基本进程管理 、虚存、I/O 与设备管理、IPC 、文件系统等几个层次，继而定义层次之间的服务结构，提高操作系统内核设计上的模块化。 但是，由于层次之间的交互关系错综复杂 ，定义清晰的层次间接口非常困难，复杂的交互关系也使得层次之间的界限极其模糊。</p><p>为解决操作系统的内核代码难以维护的问题，提出了微内核的体系结构 。 它将内核中最基本的功能（如进程管理等 ）保留在内核，而将那些不需要在核心态执行的功能移到用户态执行，从而降低了内核的设计复杂性 。 那些移出内核的操作系统代码根据分层的原则被划分成若干服务程序，它们的执行相互独立，交互则都借助于微内核进行通信。</p><p>微内核结构有效地分离了内核与服务、服务与服务，使得它们之间的接口更加清晰，维护的代价大大降低，各部分可以独立地优化和演进 ，从而保证了操作系统的可靠性。</p><p>微内核结构的最大问题是性能问题，因为需要频繁地在核心态和用户态之间进行切换，操作系统的执行开销偏大 。 因此有的操作系统将那些频繁使用的系统服务又移回内核，从而保证系统性能。但相当多的实验数据表明，体系结构不是引起性能下降的主要因素，体系结构带来的性能提升足以弥补切换开销带来的缺陷 。 为减少切换开销，也有人提出将系统服务作为运行库链接到用户程序的一种解决方案，这样的体系结构称为库操作系统。</p><h2 id="3-3-font-color-33a3dc-中断和异常的概念-font"><a class="header-anchor" href="#3-3-font-color-33a3dc-中断和异常的概念-font"></a>3.3 <font color="#33a3dc">中断和异常的概念</font></h2><ol><li>当中断发生时，CPU立即进入核心态（并且是进入核心态的<font color="#FF666">唯一方式</font>）</li><li>当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理</li><li>对于不同的中断信号，会进行不同的处理</li></ol><p>在操作系统中引入核心态和用户态这两种工作状态后，就需要考虑这两种状态之间如何切换 。操作系统内核工作在核心态，而用户程序工作在用户态 。系统不允许用户程序实现核心态的功能，而它们又必须使用这些功能 。因此，需要在核心态建立一些“门”以便实现从用户态进入核心态 。</p><p>在实际操作系统中，CPU 运行上层程序时唯一能进入这些“门”的途径就是通过中断或异常。发生中断或异常时，运行用户态的 CPU 会主即进入核心态，这是通过硬件实现的（例如，用一个特殊寄存器的一位来表示CPU所处的工作状态，0表示核心态，1表示用户态。若要进入核心态，则只需将该位置0即可)。</p><p>中断是操作系统中非常重要的一个概念，对一个运行在计算机上的实用操作系统而言，缺少了中断机制，将是不可想象的。原因是，操作系统的发展过程大体上就是一个想方设法不断提高资源利用率的过程，而提高资源利用率就需要在程序并未使用某种资源时，把它对那种资源的占有权释放，而这一行为就需要通过中断实现。</p><h3 id="3-3-1-font-color-33a3dc-中断和异常的定义-font"><a class="header-anchor" href="#3-3-1-font-color-33a3dc-中断和异常的定义-font"></a>3.3.1 <font color="#33a3dc">中断和异常的定义</font></h3><p>中断(Interruption)也称<font color="#faa755">外中断</font>，指来自CPU执行<font color="#faa755">指令以外</font>的事件的发生，如设备发出的I/O结束中断，表示设备输入/输出处理已经完成，希望处理机能够向设备发下一个输入/输出请求,同时让完成输入/输出后的程序继续运行。时钟中断，表示一个固定的时间片已到，让处理机处理计时、启动定时运行的任务等。这一类中断通常是与当前指令执行无关的事件，即它们与当前处理机运行的程序无关。</p><p>异常(Exception)也称<font color="#faa755">内中断</font>、例外或陷入(trap),指源自CPU执行<font color="#faa755">指令内部</font>的事件，如程序的非法操作码、地址越界、算术溢出、虚存系统的缺页及专门的陷入指令等引起的事件。对异常的处理一般要依赖于当前程序的运行现场，而且异常不能被屏蔽，一旦出现应立即处理。关于内中断和外中断的联系与区别如图1.2 所示。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E4%B8%AD%E6%96%AD%E5%92%8C%E5%A4%96%E4%B8%AD%E6%96%AD%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB.png" alt="内中断和外中断的联系与区别" style="object-fit: cover; border-radius: 10px; width: 80%;" /><h3 id="3-3-2-中断处理的过程"><a class="header-anchor" href="#3-3-2-中断处理的过程"></a>3.3.2 中断处理的过程</h3><p>不同计算机的中断（指外中断〉处理过程各具特色，所示。各阶段处理流程的描述如下：</p><ol><li>关中断 。CPU 响应中断后，首先要保护程序的现场状态，在保护现场的过程中，CPU 不应响应更高级中断源的中断请求。否则，若现场保存不完整，在中断服务程序结束后，也就不能正确地恢复并继续执行现行程序 。</li><li>保存断点。为保证中断服务程序执行完毕后能正确地运回到原来的程序，必须将原来的程序的断点（即程序计数器 PC）保存起来。</li><li>引出中断服务程序 。其实质是取出中断服务程序的入口地址送入程序计数器 PC 。</li><li>存现场和屏蔽字。 进入中断服务程序后 ，首先要保存现场，现场信息一般是指程序状态字寄存器 PSWR 和某些通用寄存器的内容。</li><li>开中断。 允许更高级中断请求得到响应。</li><li>执行中断服务程序。这是中断请求的目的。</li><li>关中断。保证在恢复现场和屏蔽字时不被中断。</li><li>恢复现场和屏蔽字。将现场和屏蔽字恢复到原来的状态。</li><li>开中断、中断返回。中断服务程序的最后一条指令通常是一条中断返回指令，使其返回到原程序的断点处，以便继续执行原程序 。</li></ol><p>其中，1~3步是在 CPU 进入中断周期后，由硬件自动（中断隐指令）完成的；4~9 步由中断服务程序完成。恢复现场是指在中断返回前，必须将寄存器的内容恢复到中断处理前的状态，这部分工作由中断服务程序完成 。中断返回由中断服务程序的最后一条中断返回指令完成。</p><h2 id="4-系统调用"><a class="header-anchor" href="#4-系统调用"></a>4 系统调用</h2><p>所谓<font color="#ea66a6">系统调用</font>， 是指用户在程序中调用操作系统所提供的一些子功能，系统调用可视为特殊的公共子程序。系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作（如存储分配、进行 I/0 传输及管理文件等），都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成 。 通常，一个操作系统提供的系统调用命令有几十条乃至上百条之多。这些系统调用按功能大致可分为如下几类。</p><ul><li>设备管理。完成设备的请求或释放，以及设备启动等功能。</li><li>文件管理。完成文件的读、写、创建及删除等功能。</li><li>进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。</li><li>进程通信。完成进程之间的消息传递或信号传递等功能。</li><li>内存管理。完成内存的分配、回收以及获取作业占用内存区大小及始址等功能。</li></ul><p>显然，系统调用相关功能涉及系统资源管理、进程管理之类的操作，对整个系统的影响非常大，因此必定需要使用某些特权指令才能完成，所以系统调用的处理需要由操作系统内核程序负责完成，要运行在核心态。</p><p>用户程序可以执行陷入指令(又称访管指令或trap指令)来发起系统调用，请求操作系统提供服务。可以这么理解，用户程序执行“陷入指令”，相当于把CPU的使用权主动交给操作系统内核程序(CPU状态会从用户态进入核心态)，之后操作系统内核程序再对系统调用请求做出相应处理。处理完成后，操作系统内核程序又会把CPU的使用权还给用户程序(即CPU状态会从核心态回到用户态)。这么设计的目的是:用户程序不能直接执行对系统影响非常大的操作，必须通过系统调用的方式请求操作系统代为执行，以便保证系统的稳定性和安全性，防止用户程序随意更改或访问重要的系统资源，影响其他进程的运行。</p><p>这样，操作系统的运行环境就可以理解为:用户通过操作系统运行上层程序(如系统提供的命令解释程序或用户自编程序)，而这个上层程序的运行依赖于操作系统的底层管理程序提供服务支持，当需要管理程序服务时，系统则通过硬件中断机制进入核心态，运行管理程序;也可能是程序运行出现异常情况，被动地需要管理程序的服务，这时就通过异常处理来进入核心态。管理程序运行结束时，用户程序需要继续运行，此时通过相应的保存的程序现场退出中断处理程序或异常处理程序，返回断点处继续执行，如图1.4 所示。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.png" alt="系统调用执行过程" style="object-fit: cover; border-radius: 10px; width: 100%;;" /><p>在操作系统这一层面上，我们关心的是系统核心态和用户态的软件实现与切换，对于硬件层面的具体理解，可以结合 “计算机组成原理”课程中有关中断的内容进行学习 。</p><p>下面列举一些由用户态转向核心态的例子：</p><ol><li>用户程序要求操作系统的服务，即系统调用。</li><li>发生一次中断。</li><li>用户程序中产生了一个错误状态。</li><li>用户程序中企图执行一条特权指令。</li><li>从核心态转向用户态由一条指令实现， 这条指令也是特权命令，一般是中断返回指令。</li></ol><p>注意：由用户态进入核心态，不仅状态需要切换，而且所用的堆栈也可能需要由用户堆栈切换为系统堆栈，但这个系统堆栈也是属于该进程的。</p><p>若程序的运行由用户态转到核心态，则会用到<font color="#faa755">访管指令(陷入指令)</font>，访管指令是在用户态使用的，发出系统调用请求，所以它不可能是特权指令。</p><p>陷入指令是唯一一个只能在用户态执行，而不可在核心态执行的指令。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客增加锚点功能</title>
      <link href="2020/12/28/Hexo%E5%8D%9A%E5%AE%A2%E5%A2%9E%E5%8A%A0%E9%94%9A%E7%82%B9%E5%8A%9F%E8%83%BD/"/>
      <url>2020/12/28/Hexo%E5%8D%9A%E5%AE%A2%E5%A2%9E%E5%8A%A0%E9%94%9A%E7%82%B9%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<p>Here is a footnote reference,<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> and another.<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p><p>Hexo自带的Markdown渲染器没有脚注等语法的支持，提供以下方法增加该功能的支持<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup></p><h2 id="锚点功能的解决途径"><a class="header-anchor" href="#锚点功能的解决途径"></a>锚点功能的解决途径</h2><p>一种是手动添加<code>a</code>标签，但这种方法比较麻烦。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#bib1&quot;</span> <span class="attr">id</span>=<span class="string">&quot;bib1ref&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">sup</span>&gt;</span>[1]<span class="tag">&lt;/<span class="name">sup</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">&quot;bib1&quot;</span> <span class="attr">href</span>=<span class="string">&quot;#bib1ref&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">sup</span>&gt;</span>[1]<span class="tag">&lt;/<span class="name">sup</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>还有一种是采用插件，这里选择了<a href="https://github.com/hexojs/hexo-renderer-markdown-it">hexo-renderer-markdown-it</a>插件</p><p>插件的安装</p><p>首先在Hexo博客目录下，选择删除原来的渲染器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm un hexo-renderer-marked --save</span><br></pre></td></tr></table></figure><p>在安装该插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-renderer-markdown-it --save</span><br></pre></td></tr></table></figure><p>之后在 Hexo 的 _config.yml 文件中进行相关的配置。</p><p>2021年4月24日更换了博客主题对配置进行了修改（来源：<a href="https://zhanghuimeng.github.io/post/add-footnote-plugin-for-hexo-blog/#fnref3">链接</a>）</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Markdown-it config</span></span><br><span class="line"><span class="comment">## Docs: https://github.com/celsomiranda/hexo-renderer-markdown-it/wiki</span></span><br><span class="line"><span class="attr">markdown:</span></span><br><span class="line">  <span class="comment"># 渲染设置</span></span><br><span class="line">  <span class="attr">render:</span></span><br><span class="line">    <span class="comment"># 置为true时，html内容保持不变；置为false时，html内容将被转义成普通字符串</span></span><br><span class="line">    <span class="attr">html:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 是否生成与XHTML完全兼容的标签（虽然我不懂是什么意思）</span></span><br><span class="line">    <span class="attr">xhtmlOut:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 置为true时，每个换行符都被渲染成一个&lt;br&gt;（即Hexo的默认表现）；置为false时，只有空行才会被渲染为&lt;br&gt;（GFM的默认表现）</span></span><br><span class="line">    <span class="attr">breaks:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 是否自动识别链接并把它渲染成链接</span></span><br><span class="line">    <span class="attr">linkify:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 是否自动识别印刷格式（意思是把(c)渲染为©这样的）</span></span><br><span class="line">    <span class="attr">typographer:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 如果typographer被设置为true，则该选项用于设置将dumb quotes（&quot;&quot;）自动替换为smart quotes</span></span><br><span class="line">    <span class="attr">quotes:</span> <span class="string">&#x27;“”‘’&#x27;</span></span><br><span class="line">  <span class="comment"># 设置所需插件</span></span><br><span class="line">  <span class="attr">plugins:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-abbr</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-footnote</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-ins</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-sub</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-sup</span></span><br><span class="line">  <span class="comment"># 锚点设置（因为我没有尝试相关内容，所以就不翻译相关说明了）</span></span><br><span class="line">  <span class="attr">anchors:</span></span><br><span class="line">    <span class="attr">level:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">collisionSuffix:</span> <span class="string">&#x27;v&#x27;</span></span><br><span class="line">    <span class="attr">permalink:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">permalinkClass:</span> <span class="string">header-anchor</span></span><br><span class="line">    <span class="attr">permalinkSymbol:</span> <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">markdown:</span></span><br><span class="line">  <span class="attr">preset:</span> <span class="string">&#x27;default&#x27;</span></span><br><span class="line">  <span class="attr">render:</span></span><br><span class="line">    <span class="attr">html:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">xhtmlOut:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">langPrefix:</span> <span class="string">&#x27;language-&#x27;</span></span><br><span class="line">    <span class="attr">breaks:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">linkify:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">typographer:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">quotes:</span> <span class="string">&#x27;“”‘’&#x27;</span></span><br><span class="line">  <span class="attr">enable_rules:</span></span><br><span class="line">  <span class="attr">disable_rules:</span></span><br><span class="line">  <span class="attr">plugins:</span></span><br><span class="line">  <span class="attr">anchors:</span></span><br><span class="line">    <span class="attr">level:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">collisionSuffix:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="attr">permalink:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">permalinkClass:</span> <span class="string">&#x27;header-anchor&#x27;</span></span><br><span class="line">    <span class="attr">permalinkSide:</span> <span class="string">&#x27;left&#x27;</span></span><br><span class="line">    <span class="attr">permalinkSymbol:</span> <span class="string">&#x27;¶&#x27;</span></span><br><span class="line">    <span class="attr">case:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">separator:</span> <span class="string">&#x27;-&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p>在安装插件的过程中遇到没有生效的问题，首先使用<code>hexo clean</code>命令清理，在重新尝试<br>如果仍不生效可以查看 packge.json 和 node_modules 有没有导入包，Markdown脚注的格式是否正确，</p></blockquote><h2 id="对于锚点的适配问题"><a class="header-anchor" href="#对于锚点的适配问题"></a>对于锚点的适配问题</h2><p>在我使用的<a href="https://github.com/blinkfox/hexo-theme-matery/">matery</a>主题中，文章内<code>a</code>标签中默认加入了<code>target:_brank</code>属性，这使得点击链接会跳转到新的窗口中现实，不符合锚点需要的页面内的跳转功能</p><p>解决办法，在主题的 source\js\matery.js 文件中找到如下代码，并注释<code>$('#articleContent a').attr('target', '_blank');</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*文章内容详情的一些初始化特性*/</span></span><br><span class="line"><span class="keyword">let</span> articleInit = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//$(&#x27;#articleContent a&#x27;).attr(&#x27;target&#x27;, &#x27;_blank&#x27;);</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>完成以上内容，即可使用锚点，但锚点总会跳转到页面最顶端，由于主题banner是浮动效果，会导致遮住跳转的链接。</p><p>下面提供一种Js代码的解决方式，<a href="https://www.cnblogs.com/attlia/p/7488271.html">参考文章</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*文章内容详情的一些初始化特性*/</span></span><br><span class="line"><span class="keyword">let</span> articleInit = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// $(&#x27;#articleContent a&#x27;).attr(&#x27;target&#x27;, &#x27;_blank&#x27;);</span></span><br><span class="line">    $(<span class="string">&#x27;#articleContent a&#x27;</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> target = $(<span class="built_in">this</span>).attr(<span class="string">&#x27;href&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(target);</span><br><span class="line">        $(<span class="string">&#x27;html, body&#x27;</span>).animate(&#123;</span><br><span class="line">           scrollTop: $(target).offset().top - <span class="number">65</span> <span class="comment">//65位设置的偏移值</span></span><br><span class="line">         &#125;, <span class="number">500</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自此完成了对脚注的支持，但因为这个renderer-markdown-it渲染器的原因，可以会存在一些问题，之后遇到了在说。</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>Here is the footnote. <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>Here’s one with multiple blocks. <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p>这是脚注内容 <a href="#fnref3" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>植物组织培养复习整理</title>
      <link href="2020/12/25/%E7%94%9F%E7%89%A9%E5%AD%A6/%E6%A4%8D%E7%89%A9%E7%BB%84%E7%BB%87%E5%9F%B9%E5%85%BB%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86_v202101062123/"/>
      <url>2020/12/25/%E7%94%9F%E7%89%A9%E5%AD%A6/%E6%A4%8D%E7%89%A9%E7%BB%84%E7%BB%87%E5%9F%B9%E5%85%BB%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86_v202101062123/</url>
      
        <content type="html"><![CDATA[<blockquote><p>如文档内容有误，点击<a href="http://doc.halo123.top:3000/ygHmkfBjRZq1ZoAtW8Wk5g?both">该链接</a>对文档进行修改，定时会同步到网站上，感谢参与整理的同学们</p></blockquote><h2 id="第1章-组培绪论思考题（无）"><a class="header-anchor" href="#第1章-组培绪论思考题（无）"></a>第1章 组培绪论思考题（无）</h2><h2 id="第2章-组培基本技术思考题"><a class="header-anchor" href="#第2章-组培基本技术思考题"></a>第2章 组培基本技术思考题</h2><h3 id="1、培养基中的主要成分有哪几类？（PPT23）"><a class="header-anchor" href="#1、培养基中的主要成分有哪几类？（PPT23）"></a>1、培养基中的主要成分有哪几类？（PPT23）</h3><p>培养基的成分：水、无机成分、有机成分、天然有机添加物质、植物生长调节物质、培养基的pH值、凝固剂（琼脂）、活性炭、抗生素。</p><h3 id="2、培养基中常添加的植物生长调节物质有哪两大类？各包括哪些常用种类？培养基中使用浓度范围？-PPT28、29"><a class="header-anchor" href="#2、培养基中常添加的植物生长调节物质有哪两大类？各包括哪些常用种类？培养基中使用浓度范围？-PPT28、29"></a>2、培养基中常添加的植物生长调节物质有哪两大类？各包括哪些常用种类？培养基中使用浓度范围？(PPT28、29)</h3><p>培养基中常添加的植物生长调节物质有生长素类和细胞分裂素类这两大类</p><ul><li>生长素类常用种类有吲哆乙酸（IAA），2,4-二氯苯氧乙酸（2,4-D），吲哆丁酸（IBA），萘乙酸（NAA）。培养基中常用浓度：0.1~10mg/L</li><li>细胞分裂素类常用种类有6-BA，激动素（KT），异戊烯基腺嘌呤（2-ip） ，噻重氮苯基脲（TDZ），玉米素（Zt）， 6-苄基腺嘌呤（BAP）。培养基中常用浓度： 0.1~10mg/L</li></ul><h3 id="3、培养基中经常加入的生长素类和细胞分裂素类物质各有何作用？这两类激素的使用规律如何？"><a class="header-anchor" href="#3、培养基中经常加入的生长素类和细胞分裂素类物质各有何作用？这两类激素的使用规律如何？"></a>3、培养基中经常加入的生长素类和细胞分裂素类物质各有何作用？这两类激素的使用规律如何？</h3><ul><li>生长素类主要被用于诱导愈伤组织形成；诱导根的分化和促进细胞分裂，伸长生长。</li><li>细胞分裂素类促进细胞分裂和分化，诱导胚状体和不定芽的形成，延缓组织的衰老和蛋白质的合成</li></ul><p>根和芽的分化由细胞分裂素和生长素的比值所决定：二者比值低时促进生根；比值高时促进茎芽的分化；比值适中则组织倾向于以一种无结构的方式生长。</p><h3 id="4、母液配制流程？（PPT40）"><a class="header-anchor" href="#4、母液配制流程？（PPT40）"></a>4、母液配制流程？（PPT40）</h3><p>计算 → 称量 → 加成分溶解 → 混合定容 → 测pH → 贴标签 → 冰箱贮存</p><h3 id="5、选择外植体需要注意哪些方面（PPT50）"><a class="header-anchor" href="#5、选择外植体需要注意哪些方面（PPT50）"></a>5、选择外植体需要注意哪些方面（PPT50）</h3><ol><li><strong>选择优良的基因型</strong>。基因型是控制愈伤组织形态建成的关键。不同物种的外植体诱导的愈伤组织器官分化明显不同，如烟草、胡萝卜、苜蓿等较易发生器官分化，而禾本科（禾谷类）、豆类、棉花等的愈伤组织形态建成相对较难。 同属不同种，甚至同一物种不同品种的愈伤组织器官分化的能力也不同。根据目的，选择优良的基因型，提高成功率。</li><li><strong>外植体的增殖能力</strong>。不同组织细胞的脱分化能力不同。</li><li><strong>外植体大小</strong>。胚胎培养或脱毒，外植体宜小； 若快速繁殖，外植体宜大；但过大杀菌不彻底，过小难以长活。一般在5~10mm为宜。</li><li><strong>选择外植体的季节和时间</strong>。在生长季节取材，较幼嫩的外植体培养容易；秋冬季取材需要处理，夏季，雨季取材不容易灭菌成功。</li><li><strong>外植体的生理状态和发育年龄</strong>。越幼嫩，年限越短的组织具有较高的形态发生能力；同株植物，较低部位外植体比上部的外植体容易启动，培养成功可能性大。</li></ol><h3 id="6、外植体污染原因？（PPT68）"><a class="header-anchor" href="#6、外植体污染原因？（PPT68）"></a>6、外植体污染原因？（PPT68）</h3><ol><li>外植体材料消毒不彻底</li><li>培养基灭菌不彻底</li><li>操作环境不洁净</li><li>操作人员操作不规范、不熟练。</li></ol><h3 id="7、污染的病原类型？（PPT68）"><a class="header-anchor" href="#7、污染的病原类型？（PPT68）"></a>7、污染的病原类型？（PPT68）</h3><p>污染原因从病源方面主要有细菌和真菌两大类。造成污染的病原菌主要包括外部污染菌和内源菌。</p><ul><li>外部污染菌：主要由外植体带菌或培养基灭菌不彻底以及操作人员操作不慎造成。</li><li>内源菌：外植体带菌引起的污染与外植体的种类、取材季节、部位、预处理及消毒方法等密切相关。</li></ul><h3 id="8、防污染对策？（PPT69）"><a class="header-anchor" href="#8、防污染对策？（PPT69）"></a>8、防污染对策？（PPT69）</h3><ol><li>减少或防止材料带菌，取材时应选择嫩梢，新芽或胚作为外植体材料</li><li>外植体灭菌要彻底</li><li>培养基灭菌要彻底</li><li>玻璃器皿和金属器皿的灭菌要彻底</li><li>无菌室的消毒</li><li>操作人员一定要严格按照无菌操作的程序进行接种。</li></ol><h3 id="9、常用消毒剂及外植体的消毒步骤？（PPT60、62）"><a class="header-anchor" href="#9、常用消毒剂及外植体的消毒步骤？（PPT60、62）"></a>9、常用消毒剂及外植体的消毒步骤？（PPT60、62）</h3><table><thead><tr><th>常用消毒剂</th><th>使用浓度(%)</th><th>消毒时间(min)</th><th>效 果</th><th>残液去除难易</th></tr></thead><tbody><tr><td><strong>乙醇</strong></td><td>70~75</td><td>0.1~3</td><td>好</td><td>易</td></tr><tr><td><strong>氯化汞</strong></td><td>0.1~1</td><td>2~15</td><td>最好</td><td>最难</td></tr><tr><td><strong>次氯酸钙</strong></td><td>10~20</td><td>5~30</td><td>好</td><td>易</td></tr><tr><td><strong>次氯酸钠</strong></td><td>2</td><td>5~30</td><td>好</td><td>易</td></tr></tbody></table><p>外植体表面消毒的一般过程：</p><p>外植体取材 → 预处理 → 无菌条件下，70%~75%酒精表面消毒30s~60s → 无菌条件下，消毒剂处理 → 无菌水充分漂洗3~5次 → 备用</p><h3 id="10、继代培养定义？（PPT84）"><a class="header-anchor" href="#10、继代培养定义？（PPT84）"></a>10、继代培养定义？（PPT84）</h3><p>培养物在培养基上生长一段时间以后，由于营养物质枯竭，水分散失，以及代谢产物的积累，必须转移到新鲜培养基上培养,这个过程叫做继代培养。</p><h3 id="11、何为外植体的褐变，减轻外植体褐变的方法？（PPT87、90）"><a class="header-anchor" href="#11、何为外植体的褐变，减轻外植体褐变的方法？（PPT87、90）"></a>11、何为外植体的褐变，减轻外植体褐变的方法？（PPT87、90）</h3><p>外植体褐变是指在接种后，其表面开始褐变，有时甚至会使整个培养基褐变的现象。</p><ul><li>它的出现是由于植物组织中的多酚氧化酶（PPO）被激活，而使细胞的代谢发生变化所致。</li><li>在褐变过程中，会产生醌类物质，它们多呈棕褐色，当扩散到培养基后，就会抑制其他酶的活性，从而影响所接种外植体的培养。</li></ul><p>减轻褐变现象发生的方法：</p><ol><li><strong>选择合适的外植体</strong>。一般来说，最好选择生长处于旺盛的外植体，这样可以使褐变现象明显减轻。</li><li><strong>合适的培养条件</strong>。无机盐成分、植物生长物质水平、适宜温度、及时继代培养均可以减轻材料的褐变现象。</li><li><strong>使用抗氧化剂</strong>。在培养基中，使用半胱氨酸、抗坏血酸、PVP等抗氧化剂能够较为有效地避免或减轻很多外植体的褐变现象。另外，使用0.1%~0.5%的活性炭对防止褐变也有较为明显的效果。</li><li><strong>连续转移</strong>。对容易褐变的材料可间隔12~24h的培养后，再转移到新的培养基上，这样经过连续处理7~10d后，褐变现象便会得到控制或大为减轻。</li></ol><hr><ol><li><p>在培养室和操作室中，一年中要定期进行一两次熏蒸，使用的药品是：<br>A、甲醛和高锰酸钾✔<br>B、酒精和次氯酸钠<br>C、紫外灯和酒精<br>D、升汞和酒精</p></li><li><p>组织培养中常用的生长素：吲哆乙酸（IAA），2,4-二氯苯氧乙酸（2,4-D），吲哆丁酸（IBA），萘乙酸（NAA），它们的作用强弱顺序为 <u>2,4-D</u> &gt; <u>NAA</u> &gt; <u>IBA</u> &gt; <u>IAA</u> 。</p></li><li><p>细胞分裂素中作用最强的是 <u>TDZ</u> 。</p></li></ol><h2 id="第3章-组培基本理论思考题"><a class="header-anchor" href="#第3章-组培基本理论思考题"></a>第3章 组培基本理论思考题</h2><h3 id="1、为什么利用植物的一个花瓣就可以培育出完整的植株？"><a class="header-anchor" href="#1、为什么利用植物的一个花瓣就可以培育出完整的植株？"></a>1、为什么利用植物的一个花瓣就可以培育出完整的植株？</h3><p>细胞全能性</p><h3 id="2、细胞为什么具有全能性？"><a class="header-anchor" href="#2、细胞为什么具有全能性？"></a>2、细胞为什么具有全能性？</h3><p>生物的每一个细胞都包含有该物种所特有的全套遗传物质，都有发育成完整个体所必需的全部基因。</p><h3 id="3、细胞表现出全能性的条件"><a class="header-anchor" href="#3、细胞表现出全能性的条件"></a>3、细胞表现出全能性的条件</h3><ul><li>离体状态</li><li>有一定营养物质、激素和其他外界条件（如无菌、温度、pH）</li></ul><h3 id="4、植物组织培养一般要经过哪两个的基本过程？"><a class="header-anchor" href="#4、植物组织培养一般要经过哪两个的基本过程？"></a>4、植物组织培养一般要经过哪两个的基本过程？</h3><p>脱分化和再分化</p><h3 id="5、决定细胞脱分化、再分化的关键因素是什么？"><a class="header-anchor" href="#5、决定细胞脱分化、再分化的关键因素是什么？"></a>5、决定细胞脱分化、再分化的关键因素是什么？</h3><p>植物激素的种类和比例浓度。</p><h3 id="6、愈伤组织的细胞有何特点？"><a class="header-anchor" href="#6、愈伤组织的细胞有何特点？"></a>6、愈伤组织的细胞有何特点？</h3><p>排列疏松、高度液泡化的薄壁细胞</p><h3 id="6、胚状体有何特点？"><a class="header-anchor" href="#6、胚状体有何特点？"></a>6、胚状体有何特点？</h3><p>胚状体是由体细胞诱导分化出具有胚芽、胚根、胚轴的胚状结构，进而长成完整植株。</p><hr><ol><li>当细胞分裂素与生长素共同使用时，能强烈促进愈伤组织的形成。当细胞分裂素与生长素<strong>浓度比高</strong>时，<strong>有利于</strong>芽的发生；<strong>浓度比低</strong>时，<strong>有利于</strong>根的发生。</li><li>一般情况下外植体越幼小，分化的程度就越低，组织培养的成功率就越高。</li><li>在一个生物体内，细胞没有表现出全能性，原因是:<br>A、细胞失去了全能性<br>B、细胞中的基因部分丢失<br>C、细胞中的基因选择性表达✔<br>D、细胞中的基因变异不同</li><li>关于愈伤组织形成过程的正确叙述是:<br>A、愈伤组织的形成是离体植物细胞分化的结果<br>B、愈伤组织的形成是离体植物细胞分裂的结果<br>C、愈伤组织的形成是离体动物细胞分化的结果<br>D、愈伤组织的形成是离体植物细胞脱分化的结果✔</li><li>当植物细胞脱离了原来所在植物体的器官或组织而处于离体状态时，下列有可能使其表现出全能性，发育成完整的植株的是:<br>A、细胞分裂素<br>B、生长素<br>C、一定的营养物质<br>D、以上三者均是✔</li><li>要将胡萝卜韧皮部细胞培养成完整植株，不需要:<br>A、具有完整细胞核的细胞<br>B、离体状态<br>C、导入外源基因✔<br>D、一定的营养物质和激素</li><li>下列植物细胞全能性最高的是:<br>A、形成层细胞✔<br>B、韧皮部细胞<br>C、木质部细胞<br>D、叶肉细胞</li><li>下列细胞全能性最高的是:<br>A、植物的卵细胞<br>B、植物的精子细胞<br>C、被子植物的受精卵✔<br>D、被子植物的的叶肉细胞</li><li>绝大多数培养植物再生植株时都先经过 <u>愈伤组织</u> 阶段。</li><li>愈伤组织形成大致经历 <u>诱导期</u> 、<u>分裂期</u> 和 <u>分化期</u> 三个时期。</li><li>愈伤组织的形态发生方式主要有 <u>不定芽和不定根</u> 方式和 <u>胚状体</u> 方式。</li></ol><hr><p>某二倍体植物是杂合子,下图为其花药中未成熟花粉在适宜的培养基上培养产生完整植株的过程。据图回答：<br><img src="https://pic.downk.cc/item/5ff5b86e3ffa7d37b3fa31a5.png" style="zoom:67%;" /></p><ol><li>①表示的是该花粉培养过程中的 <u>脱分化</u> 过程</li><li>②表示的是 <u>再分化</u> 过程,X代表的是 <u>胚状体</u></li><li>③表示的是 <u>分化（或发育）</u> 过程</li><li>④表示的是诱导 <u>生根</u> 过程。</li></ol><hr><p>下图是植物组织培养的简略表示。据此回答：<br><img src="https://pic.downk.cc/item/5ff5b9083ffa7d37b3fb27b9.jpg" style="zoom:80%;" /></p><ol><li>①表示 <u>离体的器官、组织或细胞</u> 它能被培养成为④的根本原因是 <u>植物细胞的全能性</u></li><li>②表示 <u>愈伤组织</u> ，它与①相比分化程度 <u>低</u> 全能性 <u>高</u> 。</li><li>若想制作人工种子，应该选用（填编号） <u>③</u> 。</li><li>若①是胡萝卜根尖细胞，则培养成的④的叶片的颜色是 <u>绿色</u> ，这说明根尖细胞 <u>含有叶绿体形成相关的基因</u> 。</li></ol><h2 id="第4章-植物组织器官形成思考题"><a class="header-anchor" href="#第4章-植物组织器官形成思考题"></a>第4章 植物组织器官形成思考题</h2><h3 id="1、愈伤组织形态发生（再分化过程）的两种方式（PPT4）"><a class="header-anchor" href="#1、愈伤组织形态发生（再分化过程）的两种方式（PPT4）"></a>1、愈伤组织形态发生（再分化过程）的两种方式（PPT4）</h3><ul><li>体细胞发生途径（胚状体）</li><li>器官发生途径（不定芽不定根）</li></ul><h3 id="2、器官发生再生植株的四种基本方式（PPT8）"><a class="header-anchor" href="#2、器官发生再生植株的四种基本方式（PPT8）"></a>2、器官发生再生植株的四种基本方式（PPT8）</h3><ol><li>愈伤组织仅有根或芽器官的分别形成，即无根的芽或无芽的根</li><li>先长芽，后长根，多数情况；</li><li>先长根，再从根的基部长芽。这种情况较难诱导芽的形成，尤其对于单子叶植物；</li><li>先在愈伤组织的邻近不同部位分别形成芽和根，然后两者结合起来形成一株植株。</li></ol><h3 id="3、胚状体定义（PPT26）"><a class="header-anchor" href="#3、胚状体定义（PPT26）"></a>3、胚状体定义（PPT26）</h3><p>体细胞胚又叫胚状体：指在组织培养中，由一个非合子细胞（体细胞），经胚胎发生和胚胎发育过程（经过原胚、球形胚、心形胚、鱼雷胚和子叶胚5个时期），形成具有双极性的胚状结构。</p><h3 id="4、体细胞胚发生途径的特点（PPT33）"><a class="header-anchor" href="#4、体细胞胚发生途径的特点（PPT33）"></a>4、体细胞胚发生途径的特点（PPT33）</h3><ol><li>胚状体具有明显的两极性，即有茎端和根端；</li><li>存在生理隔离，即体细胞胚和外植体的维管束系统无直接联系，胚状体与周围组织间形成缝隙，处于较独立的状态。</li><li>遗传的稳定性。</li><li>发生数量大，增殖率高。</li></ol><h3 id="5、影响体细胞胚胎发生的因素（PPT37-54、课本P53-55）"><a class="header-anchor" href="#5、影响体细胞胚胎发生的因素（PPT37-54、课本P53-55）"></a>5、影响体细胞胚胎发生的因素（PPT37~54、课本P53~55）</h3><p>植物材料的内在因素</p><ol><li>供体植物的基因型<ul><li>不同物种产生胚状体的能力不同</li><li>同一物种的不同品种之间产生胚状体的能力也不同</li></ul></li><li>外植体的来源<ul><li>大多数植物只有处于一定发育阶段的某一种器官的外植体能产生胚状体；</li><li>芹菜、人参、葡萄、甘蔗的组织培养</li><li>离体产生的胚状体可以再次作为外植体，经继代培养能够产生大量的次级和三级胚状体</li><li>利用胚状体进行连续培养快速繁殖种苗</li><li>在继代培养过程中，胚状体的发生能力会逐渐降低</li><li>不同植物callus分化胚状体的速度不同</li></ul></li><li>培养物的生理状况<ul><li>培养细胞的内源激素水平</li><li>不同采样时期的外植体</li><li>采用增殖能力较强的外植体</li><li>获得较多的体细胞胚</li></ul></li><li>培养物的倍性<ul><li>体细胞胚可以从不同倍性的组织中获得，单倍性的小孢子（花粉）；二倍体、三倍体、多倍体体细胞</li><li>倍性水平不影响体细胞胚的发生但体细胞胚的发育和转换过程会有差异</li></ul></li></ol><p>组织培养的外部因素</p><ol><li><p>培养基中的外源激素</p><ul><li>根据不同植物对外源激素的需求分3种情况：①全过程不需要外源激素。添加少量会提高诱导频率；②诱导胚状体的全过程需要外源激素。较高的激动素和生长素的配比才有较高的频率(咖啡)；③前期需要激素，后期不需要或极低浓度即可。常见，激素诱导出后callus，诱导胚状体无需激素（或很低）</li><li>不同植物的体胚发生，要求不同的激素种类（颠茄: NAA和激动素，南瓜：NAA和IBA）</li><li>玉米素，一种天然的细胞分裂素，促进胡萝卜体胚的发生，猕猴桃的胚乳callus只有在培养基中添加玉米素才能分化出体胚</li></ul></li><li><p>培养基成分对体胚形成的影响</p><ul><li>氮源：还原态的氮（铵盐）的浓度直接影响胚状体的诱导效果，培养基中添加有机氮源（水解酪蛋白、氨基酸）有利于胚状体的发生</li><li>碳源：碳水化合物能维持组织培养中外植体的渗透压，同时又作为体胚发育的能源。其种类和浓度可以影响体胚的生长发育</li><li>天然提取物：椰子乳被认为是对体胚发生最有效的物质；其它未成熟的胚乳，如玉米胚乳、水稻胚乳、小麦胚乳对胚的生长也有一定作用；酵母、麦芽、酪蛋白等提取物对促进体胚的产生和发育，都是较为有效的天然物质。</li><li>活性炭：吸附一些外植体分泌出的有毒物质；提高体胚的诱导频率和生长发育</li></ul></li><li><p>另外，一些其他因素如培养过程中的环境条件如光照、温度，对外植体的预处理如辐射、低温及离心等都会影响胚状体发发生。</p></li></ol><h2 id="第5章-胚胎培养思考题"><a class="header-anchor" href="#第5章-胚胎培养思考题"></a>第5章 胚胎培养思考题</h2><h3 id="1、为什么幼胚培养比成熟胚培养要求的培养基和培养条件更为严格？"><a class="header-anchor" href="#1、为什么幼胚培养比成熟胚培养要求的培养基和培养条件更为严格？"></a>1、为什么幼胚培养比成熟胚培养要求的培养基和培养条件更为严格？</h3><p>成熟胚培养：指子叶期至发育成熟的胚培养。成熟胚是自养的，培养基需要简单。仅提供一定的温度、湿度就可以发芽生成植物体。如种子的发育。</p><p>幼胚培养：是指处于原胚期、球形期、心形期、鱼雷期的胚培养；幼胚基本是<strong>异养</strong>的，离体条件下培养要求培养基成分复杂，培养不易成功。</p><h3 id="2、离体培养时胚的发育方式有哪几种？（PPT11）"><a class="header-anchor" href="#2、离体培养时胚的发育方式有哪几种？（PPT11）"></a>2、离体培养时胚的发育方式有哪几种？（PPT11）</h3><p>离体胚培养：是指从植物种子中分离出胚组织进行离体培养的技术</p><ol><li>合子胚发育途径：由合子形成球形胚，心形胚，鱼雷形胚，子叶形胚，形成完整的种子，合适条件下即可萌发成苗。</li><li>早熟萌发：幼胚离体培养不经历休眠过程，不经历胚胎发育迅速萌发成幼苗。多数情况一个幼胚萌发成一个植株，有时因细胞分裂形成许多胚状体，进而形成许多植株，即丛生胚现象。<strong>苗弱小，不易成活</strong>。</li><li>脱分化形成愈伤组织：多数植物幼胚形成愈伤组织。再分化成胚状体或形成芽苗，主要原因是培养基成分不适宜。</li></ol><h3 id="3、胚胎培养在育种工作中有哪些应用（意义）？（PPT12）"><a class="header-anchor" href="#3、胚胎培养在育种工作中有哪些应用（意义）？（PPT12）"></a>3、胚胎培养在育种工作中有哪些应用（意义）？（PPT12）</h3><ol><li>用于的胚挽救，克服远缘杂种的不育性</li><li>使无生活力的种子获得后代</li><li>使发育不完全的植物获得后代</li><li>克服种子休眠、缩短育种年限</li><li>克服珠心胚的干扰</li><li>诱导胚状体及胚性愈伤组织</li><li>稀有植物的繁殖</li></ol><h3 id="4、离体授粉的类型和意义有哪些方面？（PPT55）"><a class="header-anchor" href="#4、离体授粉的类型和意义有哪些方面？（PPT55）"></a>4、离体授粉的类型和意义有哪些方面？（PPT55）</h3><p>离体授粉的类型：</p><ul><li>离体胎座（胚珠）授粉：把花粉授于连在胎座的胚珠上，进而实现受精作用的方法</li><li>离体子房授粉：将花粉粒直接送入子房以实现受精作用的方法。</li><li>离体柱头（雌蕊）授粉：把花粉授于离体子房的柱头上，进而实现受精作用的方法</li></ul><p>意义：</p><ol><li>可以克服植物受精不育障碍，特别是离体子房授粉和离体胚珠授粉，能消除柱头和花柱所造成的受精前障碍。</li><li>克服自我不亲和性</li><li>诱导孤雌生殖</li><li>双受精及胚台早期发育的机理研究</li></ol><h2 id="第6章-人工种子思考题（无）"><a class="header-anchor" href="#第6章-人工种子思考题（无）"></a>第6章 人工种子思考题（无）</h2><h2 id="第7章-单倍体细胞培养思考题"><a class="header-anchor" href="#第7章-单倍体细胞培养思考题"></a>第7章 单倍体细胞培养思考题</h2><h3 id="1、说明植物花药培养和花粉培养概念（PPT21、32）"><a class="header-anchor" href="#1、说明植物花药培养和花粉培养概念（PPT21、32）"></a>1、说明植物花药培养和花粉培养概念（PPT21、32）</h3><p>花药培养：将发育到一定阶段的花药剥离下来（切去花丝部分）接种到培养基上进行培养，最终形成完整植株的过程。</p><p>花粉培养：是从花药中分离出来的花粉粒，使之成为分散的或游离的状态，通过培养使花粉粒脱分化，进而再分化并发育成完整植株的过程。</p><h3 id="2、通过离体培养获得单倍体的途径有哪些？（课本P97）"><a class="header-anchor" href="#2、通过离体培养获得单倍体的途径有哪些？（课本P97）"></a>2、通过离体培养获得单倍体的途径有哪些？（课本P97）</h3><p>花药培养、花粉（小孢子）培养和未受精子房及卵细胞培养，其中花药和小孢子培养是体外诱导单倍体的主要途径</p><h3 id="3、花药培养中如何选择外植体？"><a class="header-anchor" href="#3、花药培养中如何选择外植体？"></a>3、花药培养中如何选择外植体？</h3><p>选择花粉发育时期：单核早期到双核早期</p><h3 id="4、花药培养与花粉培养有什么不同（或异同）？（PPT33）"><a class="header-anchor" href="#4、花药培养与花粉培养有什么不同（或异同）？（PPT33）"></a>4、花药培养与花粉培养有什么不同（或异同）？（PPT33）</h3><p>相同点：培养目的相同，均获得单倍体植株。胚状体成苗途径、愈伤组织再分化成苗途径。</p><p>不同点：</p><ol><li>花药培养其外植体是植物雄性生殖器官的一部分，就培养方法和技术来讲，属于器官培养；而花粉培养属于细胞培养。</li><li>花粉培养没有药壁组织干扰；可计数小孢子产胚率；可观察雄核发育的全过程；单倍体产量高。但技术更复杂</li></ol><h3 id="5、花药培养过程中花药为什么要经过低温处理？（课本P108）"><a class="header-anchor" href="#5、花药培养过程中花药为什么要经过低温处理？（课本P108）"></a>5、花药培养过程中花药为什么要经过低温处理？（课本P108）</h3><p>对于有些物种，培养前对花药进行低温预处理，能显著提高培养效果。是成功的前提条件。</p><h2 id="第8章-植物细胞培养及应用思考题（无）"><a class="header-anchor" href="#第8章-植物细胞培养及应用思考题（无）"></a>第8章 植物细胞培养及应用思考题（无）</h2><h2 id="第9章-植物体细胞杂交思考题（无）"><a class="header-anchor" href="#第9章-植物体细胞杂交思考题（无）"></a>第9章 植物体细胞杂交思考题（无）</h2><h2 id="第10章-植物脱毒技术思考题"><a class="header-anchor" href="#第10章-植物脱毒技术思考题"></a>第10章 植物脱毒技术思考题</h2><h3 id="某地区的一种马铃薯经多年的种植后，植株变的矮小，产量和品质都下降，怀疑是由病毒所至。请你设计一个病毒的鉴定和脱毒的技术方案"><a class="header-anchor" href="#某地区的一种马铃薯经多年的种植后，植株变的矮小，产量和品质都下降，怀疑是由病毒所至。请你设计一个病毒的鉴定和脱毒的技术方案"></a>某地区的一种马铃薯经多年的种植后，植株变的矮小，产量和品质都下降，怀疑是由病毒所至。请你设计一个病毒的鉴定和脱毒的技术方案</h3><p>脱毒植物的鉴定方法：</p><ol><li>直接鉴定法：观察脱毒后植株茎、叶等器官生长情况，有无病毒引起的症状。</li><li>指示植物鉴定：对病毒反应敏感、症状明显的植物。如烟草、马铃薯、葡萄、柑桔等。方法①摩擦接种法：用脱毒植物叶片中汁液与金刚砂或石英沙摩擦指示植物叶片，冲冼培养数天，观察有无出现病毒感染症状。方法②嫁接法：木本植物病毒不通过汁液传播。将脱毒植物茎尖微嫁接在指示植物砧木上，观察有无出现病毒感染症状。</li><li>电镜检测：电镜下检测病毒形态、大小及结构。</li><li>抗血清检测法：病毒蛋白抗原免疫动物，获得含特异结合抗体的血清，再与脱毒植物是否发生血清反应检测。酶联免疫吸附测定</li><li>分子检测技术：利用已知病毒DNA序列设计引物或探针，检测脱毒植物</li></ol><p>脱毒的技术方案：</p><ol><li>茎尖培养脱毒</li><li>热处理脱毒</li><li>茎尖与热处理相结合方法</li><li>其它途径脱毒：愈伤组织培养脱毒、茎尖微体嫁接、化学疗法脱毒（病毒抑制剂）</li></ol><h2 id="第11章-无性系变异及种质离体保存思考题"><a class="header-anchor" href="#第11章-无性系变异及种质离体保存思考题"></a>第11章 无性系变异及种质离体保存思考题</h2><h3 id="1、超低温保存离体种质资源的原理和一般程序是什么？（PPT34-35、38）"><a class="header-anchor" href="#1、超低温保存离体种质资源的原理和一般程序是什么？（PPT34-35、38）"></a>1、超低温保存离体种质资源的原理和一般程序是什么？（PPT34~35、38）</h3><p>超低温保存：也叫冷冻保存，指在<b>-196℃</b>的液氮超低温下使细胞代谢和生长处于基本停止的状态，在适宜条件下可繁殖，再生出新的植株，并保持原来的遗传特性。</p><p>保存原理：低温冰冻过程中，如果生物细胞内水分结冰，细胞结构就遭到不可逆的破坏，导致细胞和组织死亡。<strong>植物材料在超低温条件下，冰冻过程中避免了细胞内水分结冰</strong>，并且在解冻过程中防止细胞内水分次生结冰而达到植物材料保存目的。</p><p>基本程序：超低温保存的基本程序包括预处理、冷冻处理、冷冻贮存、解冻和再培养。</p><h3 id="2、限制生长保存离体种质资源有哪些方式？"><a class="header-anchor" href="#2、限制生长保存离体种质资源有哪些方式？"></a>2、限制生长保存离体种质资源有哪些方式？</h3><ul><li>常温限制生长保存</li><li>低温保存</li><li>超低温保存</li></ul><h3 id="3、细胞活力检测有哪些方法？（课本P258）"><a class="header-anchor" href="#3、细胞活力检测有哪些方法？（课本P258）"></a>3、细胞活力检测有哪些方法？（课本P258）</h3><ul><li>TTC法（氯化三苯基四氮唑还原法）</li><li>FDA染色法（二醋酸酯荧光素染色法）</li><li>色谱分析法</li><li>再培养</li><li>细胞学变化</li><li>生化稳定性</li><li>遗传性分析</li></ul><h3 id="4、有哪些冷冻保护剂？（课本P249）"><a class="header-anchor" href="#4、有哪些冷冻保护剂？（课本P249）"></a>4、有哪些冷冻保护剂？（课本P249）</h3><p>常见的防冻剂有二甲基亚砜（DMSO）、聚乙二醇（PEG）、甘油及多种糖类等</p><h3 id="5、利用马铃薯无毒苗学习实践植物种质资源的限制生长保存技术"><a class="header-anchor" href="#5、利用马铃薯无毒苗学习实践植物种质资源的限制生长保存技术"></a>5、利用马铃薯无毒苗学习实践植物种质资源的限制生长保存技术</h3><h2 id="影响因素整理"><a class="header-anchor" href="#影响因素整理"></a>影响因素整理</h2><h3 id="1、影响器官分化的因素（课本P46、第4章PPT12）"><a class="header-anchor" href="#1、影响器官分化的因素（课本P46、第4章PPT12）"></a>1、影响器官分化的因素（课本P46、第4章PPT12）</h3><ol><li><p>培养基成分</p><ul><li><strong>无机营养</strong>：培养基中的N，大多数都用硝态氮，对细胞分化起重要作用。</li><li><strong>植物生长调节物质</strong>：培养基中生长调节物质对愈伤组织的诱导及增殖起着重要的调节作用。使用植物生长调节剂时，要注意种类和浓度，特别是生长素和细胞分裂素的比值。</li><li><strong>有机成分</strong>：培养基中加入糖、维生素类、肌醇和甘氨酸等，可满足愈伤组织生长和分化的要求。各种氨基酸和嘌呤、嘧啶类物质，可促进器官分化。水解酪蛋白中含有多种氨基酸，助于器官分化。糖的种类和浓度对组织培养物的增殖和器官分化均有明显的影响。</li><li><strong>培养基pH值</strong>：培养基pH值影响愈伤组织对营养元素的吸收、呼吸代谢、多胺代谢、DNA合成以及植物激素对细胞的影响，从而影响愈伤组织的形成及形态建成。</li><li><strong>活性炭等一些惰性物质</strong>：活性炭有时会对愈伤组织的分化起到很好的作用，活性炭可促进愈伤组织的器官发生（根、芽）和体细胞胚胎发生。</li><li><strong>培养方式</strong>：有固体培养、液体培养等</li></ul></li><li><p>环境条件</p><ul><li><strong>光照</strong>：光照包括光强、光质和光周期，对器官分化有重要影响。光照对器官发生的调节可能与调节培养物的内源激素平衡有关，光照还可能影响生长素的信号转导系统，调整生长素的极性运输，从而引起器官分化。光质对器官分化的影响可能与光受体精确调节系统有关。</li><li><strong>温度</strong>：昼夜温差处理，低温处理</li><li><strong>湿度</strong>：培养室适宜的湿度为70%~80%</li></ul></li><li><p>植株材料</p><ul><li>不同品种基因型的差异</li><li>外植体的生理状况和外植体的类型：生长活跃的，幼嫩，自然繁殖的外植体利于培养</li></ul></li></ol><h3 id="2、影响体细胞胚胎发生的因素（第4章PPT37-54）"><a class="header-anchor" href="#2、影响体细胞胚胎发生的因素（第4章PPT37-54）"></a>2、影响体细胞胚胎发生的因素（第4章PPT37~54）</h3><p>植物材料的内在因素</p><ol><li>供体植物的基因型<ul><li>不同物种产生胚状体的能力不同</li><li>同一物种的不同品种之间产生胚状体的能力也不同</li></ul></li><li>外植体的来源<ul><li>大多数植物只有处于一定发育阶段的某一种器官的外植体能产生胚状体；</li><li>芹菜、人参、葡萄、甘蔗的组织培养</li><li>离体产生的胚状体可以再次作为外植体，经继代培养能够产生大量的次级和三级胚状体</li><li>利用胚状体进行连续培养快速繁殖种苗</li><li>在继代培养过程中，胚状体的发生能力会逐渐降低</li><li>不同植物callus分化胚状体的速度不同</li></ul></li><li>培养物的生理状况<ul><li>培养细胞的内源激素水平</li><li>不同采样时期的外植体</li><li>采用增殖能力较强的外植体</li><li>获得较多的体细胞胚</li></ul></li><li>培养物的倍性<ul><li>体细胞胚可以从不同倍性的组织中获得，单倍性的小孢子（花粉）；二倍体、三倍体、多倍体体细胞</li><li>倍性水平不影响体细胞胚的发生但体细胞胚的发育和转换过程会有差异</li></ul></li></ol><p>组织培养的外部因素</p><ol><li><p>培养基中的外源激素</p><ul><li>根据不同植物对外源激素的需求分3种情况：①全过程不需要外源激素。添加少量会提高诱导频率；②诱导胚状体的全过程需要外源激素。较高的激动素和生长素的配比才有较高的频率(咖啡)；③前期需要激素，后期不需要或极低浓度即可。常见，激素诱导出后callus，诱导胚状体无需激素（或很低）</li><li>不同植物的体胚发生，要求不同的激素种类（颠茄: NAA和激动素，南瓜：NAA和IBA）</li><li>玉米素，一种天然的细胞分裂素，促进胡萝卜体胚的发生，猕猴桃的胚乳callus只有在培养基中添加玉米素才能分化出体胚</li></ul></li><li><p>培养基成分对体胚形成的影响</p><ul><li>氮源：还原态的氮（铵盐）的浓度直接影响胚状体的诱导效果，培养基中添加有机氮源（水解酪蛋白、氨基酸）有利于胚状体的发生</li><li>碳源：碳水化合物能维持组织培养中外植体的渗透压，同时又作为体胚发育的能源。其种类和浓度可以影响体胚的生长发育</li><li>天然提取物：椰子乳被认为是对体胚发生最有效的物质；其它未成熟的胚乳，如玉米胚乳、水稻胚乳、小麦胚乳对胚的生长也有一定作用；酵母、麦芽、酪蛋白等提取物对促进体胚的产生和发育，都是较为有效的天然物质。</li><li>活性炭：吸附一些外植体分泌出的有毒物质；提高体胚的诱导频率和生长发育</li></ul></li><li><p>另外，一些其他因素如培养过程中的环境条件如光照、温度，对外植体的预处理如辐射、低温及离心等都会影响胚状体发发生。</p></li></ol><h3 id="3、影响离体授粉的因素（课本P63）"><a class="header-anchor" href="#3、影响离体授粉的因素（课本P63）"></a>3、影响离体授粉的因素（课本P63）</h3><ol><li>外植体的发育阶段</li><li>花粉粒数量及萌发力</li><li>营养及环境条件</li><li>授粉方式</li><li>保留母体组织的影响</li><li>基因型的影响</li><li>培养前的预处理</li></ol><h3 id="4、影响花药培养的因素"><a class="header-anchor" href="#4、影响花药培养的因素"></a>4、影响花药培养的因素</h3><p>课本P105</p><ol><li><p>植株的生长条件</p></li><li><p>供体植株的年龄</p></li><li><p>花粉发育时期</p></li><li><p>花蕾和花药的预处理</p></li><li><p>供体植株的基因型</p></li><li><p>培养基</p><ul><li>基本培养基</li><li>碳源</li><li>激素成分</li><li>氮源</li><li>硝酸银</li><li>其他成分</li><li>pH值</li></ul></li><li><p>培养条件</p></li><li><p>活性炭的作用</p></li></ol><hr><p>第7章PPT30</p><ol><li>供体植株的基因型：不同种和品种的花药，在离体培养条件下的反应能力有明显差异。</li><li>花粉发育时期：花粉的发育时期使诱导小孢子分裂的关键，多数植物在单核中期至单核晚期（单核靠边期）的花粉都易形成花粉愈伤组织或花粉胚。</li><li>花药的生理状态：适宜条件下的健康植株，花药培养的胚诱导率，再生率高，冬春季较夏秋季适合花药培养；多数情况下，幼年植株优于老年植株。</li><li>花蕾和花药的预处理：预处理是小孢子培养成功的前提条件。有低温，高温及甘露醇等预处理，其中以低温预处理应用最广。</li><li>培养基的影响：基本培养基是花药培养中影响花粉启动和再分化的重要条件，不仅决定花药培养的成功，还决定着雄核发育的方式。培养基因植物种类的不同而异。<ul><li>多采用MS培养基</li><li>对氨态氮和硝态氮比例加以调整</li><li>植物生长调节剂为大多数的雄核发育所必需，常诱发细胞的分裂，生长和分化。</li><li>所需蔗糖的浓度在3%-10%</li><li>pH值有一定的要求</li></ul></li></ol><h3 id="影响花药培养和花粉培养的因素（第7章PPT42）"><a class="header-anchor" href="#影响花药培养和花粉培养的因素（第7章PPT42）"></a>影响花药培养和花粉培养的因素（第7章PPT42）</h3><ol><li>基因型：不同基因型的培养难易及植株再生有很大差别。</li><li>植株的生理状态和环境条件：母体植株的年龄和所经历的环境条件如：光周期、光照强度、温度等对以后的花粉离体培养有很大影响。一般田间比温室，幼龄比老龄植株易于培养。</li><li>花粉的发育时期：多数植物<strong>单核期</strong>的花粉培养容易成功。</li><li>培养基：基因型不同，所需培养基种类，蔗糖浓度以及添加激素种类和浓度不同</li></ol><h3 id="5、影响花粉-小孢子-培养的因素（课本P118）"><a class="header-anchor" href="#5、影响花粉-小孢子-培养的因素（课本P118）"></a>5、影响花粉(小孢子)培养的因素（课本P118）</h3><p>很大程度上与影响花药培养效果的因素相类似</p><ol><li>合适的基因型分离小孢子是培养成功的关键因素</li><li>外植体的生理状态对游离花粉的分裂能力有重要影响</li><li>一定条件下预培养后的花药分离出的花粉在进行培养容易收到良好的效果</li><li>培养基的成分当然影响花粉的培养效果</li><li>培养基的物理状态与培养效果有关</li><li>良好的培养与再生效果需要多种因素综合改进使用</li></ol><h3 id="6、影响单细胞培养的因素（课本P128）"><a class="header-anchor" href="#6、影响单细胞培养的因素（课本P128）"></a>6、影响单细胞培养的因素（课本P128）</h3><p>培养基的成分和细胞植板密度是单细胞培养成败的关键，这两个因子是相互依赖的。</p><h3 id="7、影响细胞悬浮培养的因素（课本P136）"><a class="header-anchor" href="#7、影响细胞悬浮培养的因素（课本P136）"></a>7、影响细胞悬浮培养的因素（课本P136）</h3><ol><li>基本培养基的组成</li><li>有机成分</li><li>碳源</li><li>植物激素</li><li>培养基的pH值及渗透压</li><li>振荡频率</li><li>培养条件</li></ol><h3 id="8、影响幼胚培养成功的因素（第5章PPT25）"><a class="header-anchor" href="#8、影响幼胚培养成功的因素（第5章PPT25）"></a>8、影响幼胚培养成功的因素（第5章PPT25）</h3><ol><li><p>基本培养基+附加物</p><ul><li>无机盐，成熟胚培养基简单，如White.幼胚培养有MS，B5等，可使K<sup>+</sup>,Ca<sup>2+</sup>水平稍高。</li><li>碳水化合物，糖的作用：调节渗透压；碳源；防止幼胚早萌。渗透压：提高培养基渗透压是防止早熟萌发的有效方法。最适蔗糖浓度随着胚的发育时期二降低。提高渗透压的方法：提高糖浓度，提高无机盐浓度，加入甘露醇。</li></ul></li><li><p>激素的作用</p><ul><li>成熟胚一般不需要外源激素即可萌发。单激素能促进休眠胚的 萌发。</li><li>幼胚需要外源激素，应保持外源激素与内源激素的平衡。过低不能促进生长，过高易导致幼胚脱分化形成愈伤。</li></ul></li><li><p>天然提取物及某些蛋白制品：促进幼胚的发育</p></li><li><p>环境条件</p><ul><li>温度：多数为25~30℃；</li><li>光照：一般认为黑暗或弱光条件较为合适。</li></ul></li><li><p>提高幼胚的成活萌发的有效率，可采用胚乳看护培养</p></li></ol><h2 id="有关流程整理"><a class="header-anchor" href="#有关流程整理"></a>有关流程整理</h2><h3 id="1、外植体表面消毒的一般过程（第2章PPT62、课本P34）"><a class="header-anchor" href="#1、外植体表面消毒的一般过程（第2章PPT62、课本P34）"></a>1、外植体表面消毒的一般过程（第2章PPT62、课本P34）</h3><p>外植体表面消毒的一般过程：</p><p>外植体取材 → 预处理 → 无菌条件下，70%~75%酒精表面消毒30s~60s → 无菌条件下，消毒剂处理 → 无菌水充分漂洗3~5次 → 备用</p><h3 id="2、配置母液流程（第2章PPT40）"><a class="header-anchor" href="#2、配置母液流程（第2章PPT40）"></a>2、配置母液流程（第2章PPT40）</h3><p>计算 → 称量 → 加成分溶解 → 混合定容 → 测pH → 贴标签 → 冰箱贮存</p><h3 id="3、培养基的配制流程（第2章PPT43）"><a class="header-anchor" href="#3、培养基的配制流程（第2章PPT43）"></a>3、培养基的配制流程（第2章PPT43）</h3><p>准备 → 将水、母液和糖混合定容 → 调pH → 加入琼脂 → 加热溶解 → 分装到已经清洗干燥的培养器皿中 → 封口 → 标记 → 高压蒸汽灭菌 → 冷却 → 凝固 → 接种</p><h3 id="4、外植体接种步骤（第2章PPT74）"><a class="header-anchor" href="#4、外植体接种步骤（第2章PPT74）"></a>4、外植体接种步骤（第2章PPT74）</h3><p>切割外植体 → 培养瓶倾斜靠近酒精灯火焰 → 瓶盖外部在火焰上旋转灼烧数秒钟 → 旋开瓶盖，放在酒精灯旁边 → 瓶口在火焰上旋转灼烧数秒钟 → 用无菌镊子将外植体均匀放置在培养基上 → 瓶盖在火焰上灼烧两圈 → 盖紧瓶盖</p><h3 id="5、茎尖脱毒培育程序（课本P76）"><a class="header-anchor" href="#5、茎尖脱毒培育程序（课本P76）"></a>5、茎尖脱毒培育程序（课本P76）</h3><p>采样 → 取外叶 → 剥离茎尖 → 切取分生组织 → 茎尖培养 → 茎尖再生植株 → 病毒鉴定 → 防虫网内繁殖脱毒苗</p><h3 id="6、花药培养的基本程序（第7章PPT23）"><a class="header-anchor" href="#6、花药培养的基本程序（第7章PPT23）"></a>6、花药培养的基本程序（第7章PPT23）</h3><p>培养材料的选择 → 材料（花蕾）预处理 → 外植体消毒灭菌 → 接种培养 → 植株再生 → 诱导生根 → 单倍体植株的染色体加倍及驯化移栽。</p><h3 id="7、花粉培养的基本程序（第7章PPT35）"><a class="header-anchor" href="#7、花粉培养的基本程序（第7章PPT35）"></a>7、花粉培养的基本程序（第7章PPT35）</h3><p>取花蕾（镜检） → 消毒 → 取花药 → 预培养数天 → 分离花粉 → 接种 → 培养 → 胚状体或愈伤组织发生</p><h3 id="8、成熟胚培养过程（第5章PPT21）"><a class="header-anchor" href="#8、成熟胚培养过程（第5章PPT21）"></a>8、成熟胚培养过程（第5章PPT21）</h3><p>选取完好种子 → 70%酒精浸数秒 → 0.1%升汞或2%次氯酸钠浸泡 → 无菌水冲洗 → 种子培养几天 → 剥离种胚 → 接种在培养基上。</p><h3 id="9、幼胚培养的基本程序（第5章PPT22）"><a class="header-anchor" href="#9、幼胚培养的基本程序（第5章PPT22）"></a>9、幼胚培养的基本程序（第5章PPT22）</h3><p>取子房 → 常规表面消毒 → 解剖镜下，取胚珠、去珠被、取出完整幼胚 → 固体培养</p><h3 id="10、超低温保存的基本程序（第11章PPT38）"><a class="header-anchor" href="#10、超低温保存的基本程序（第11章PPT38）"></a>10、超低温保存的基本程序（第11章PPT38）</h3><p>超低温保存的基本程序包括预处理、冷冻处理、冷冻贮存、解冻和再培养。</p><p>预处理：为保证茎尖在液N<sub>2</sub>处理后具有稳定且高的存活率，需进行一定的预处理，或在冷冻防护剂存在下进行预培养，或直接进行低温（-3~10℃）预处理。</p><h3 id="11、植物组织培养一般过程（第3章PPT64）"><a class="header-anchor" href="#11、植物组织培养一般过程（第3章PPT64）"></a>11、植物组织培养一般过程（第3章PPT64）</h3><p>初代培养 → 继代培养 → 丛芽培养 → 生根培养 → 驯化培养</p><h2 id="计算题培养基的配置"><a class="header-anchor" href="#计算题培养基的配置"></a>计算题培养基的配置</h2><p>母液配制注意的问题：</p><ol><li>几种试剂混合配制时要按一定顺序将各种溶液混合。</li><li>在配制母液时应注意防止产生沉淀,如Ca<sup>2+</sup>和SO<sub>4</sub><sup>2+</sup> , Ca<sup>2+</sup>、Mg<sup>2+</sup>和PO<sub>4</sub><sup>2+</sup> 一起溶解后,会产生沉淀。</li><li>应采用纯度等级较高的分析纯或化学纯。</li><li>要用纯度较高的蒸馏水或去离子水。</li><li>母液一旦出现沉淀或有可见微生物的污染，应立即停止使用，重新配制。</li></ol><p>母液吸取体积计算公式：</p><p>所需母液的体积=所需要培养基的体积/母液的浓缩倍数</p><h2 id="重点知识点整理"><a class="header-anchor" href="#重点知识点整理"></a>重点知识点整理</h2><ol><li>培养基的成分：水、无机成分、有机成分、天然有机添加物质、植物生长调节物质、培养基的pH值、凝固剂–琼脂、活性炭、抗生素。</li><li>无机成分中大量元素化合物指浓度&gt;0.5mmol/L，有N、P、K、Ca、Mg、S。</li><li>无机成分中微量元素化合物指浓度&lt;0.5mmol/L，有B、Mn、Zn、Cu、Mo、Co、Cl、Fe</li><li>铁盐容易发生沉淀，需要<strong>单独配制</strong>，一般与Na<sub>2</sub>EDTA相互配</li><li>培养基中糖类的功能：碳源及维持培养基一定的渗透压，蔗糖是最好的碳源，葡萄糖和果糖次之。</li><li>培养基中氨基酸类的功能：蛋白质组成，优质有机氮源，促进细胞生长分化</li><li>生长素类、细胞分裂素类的作用、常用种类、强弱顺序</li><li>培养基的pH值：灭菌前pH值<strong>调控范围</strong>：pH=5.0~6.0。pH对培养基凝固的影响：<strong>高6.0会变硬，低于5.0凝固效果不好</strong>。pH调节剂：HCl、NaOH</li><li>凝固剂–琼脂,用量范围：0.4%~1.0%，影响琼脂凝固的因素：厂家的加工方式；灭菌的时间，温度，pH值；存放的时间</li><li>抗生素<strong>不耐高温，需单独过滤灭菌</strong>。作用：防止外植体内生菌造成的污染。</li><li>基本培养基较于完全培养基<strong>不包括激素和天然有机附加物</strong>。</li><li><strong>高无机盐含量</strong>的培养基代表类型：MS培养基、ER培养基</li><li>硝酸钾含量较高的培养基代表类型：B5、N6</li><li>干热灭菌（如烘烤和灼烧）；湿热灭菌（如常压或高压蒸煮）；过滤灭菌（如空气过滤和液体过滤）</li><li>高温高压蒸气灭菌温度：<strong>121°C</strong>；<strong>1.1~1.2kg/cm<sup>2</sup></strong>，压力不要超过<strong>0.15MP</strong>，维持<strong>15~20</strong>分钟即可关闭电源。</li><li>过滤灭菌：用于高温高压下易分解的培养基和激素类</li><li>细胞全能性理论：植物每一个具有完整细胞核的体细胞，都含有植物体的全部遗传信息，在适当条件下，具有发育成完整植株的潜在能力。</li><li>植物细胞全能性表现根据细胞类型不同从强到弱:<strong>营养生长中心</strong> &gt; <strong>形成层</strong> &gt; 薄壁细胞 &gt; 厚壁细胞(木质化细胞) &gt; 特化细胞(筛管、导管细胞)</li><li>植物细胞全能性表达的条件：①体细胞与完整植株分离，脱离完整植株的控制；②创造理想的适于细胞生长和分化的环境（主要是激素的作用）</li><li>细胞实现全能性的过程：通过<strong>脱分化</strong>和<strong>再分化</strong>两个阶段。</li><li><strong>液泡消失</strong>和<strong>叶绿体的转变</strong>是脱分化的重要特征。</li><li>根据脱分化细胞过程中细胞结构发生变化的时空顺序，细胞的脱分化过程可分为3个阶段：<strong>启动阶段</strong>、<strong>演变阶段</strong>和<strong>脱分化终结期</strong></li><li>脱分化的关键<strong>植物激素</strong></li><li>脱分化细胞特点：细胞质显著变浓，大液泡消失，核体积增加并逐渐移位至细胞中央，细胞器增加。</li><li>愈伤组织的定义：在组织培养过程中，沿用了这一名称，实际上是指外植体在离体培养条件下，形成的一团没有分化、又能旺盛分裂的薄壁细胞团，是组织培养过程中经常出现的一种组织状态。</li><li>愈伤组织的产生原因：内因：内源激素，材料被切伤后分泌的伤源激素；外因：外源生长调节剂，人为在培养基内加入激素。</li><li>从外植体脱分化形成典型的愈伤组织大致可分为三个时期：<strong>诱导期</strong>、<strong>分裂期</strong>和<strong>分化期</strong></li><li>两种愈伤组织间的转化关系：坚实型升高生长素浓度转化成松脆型，松脆型降低或去除生长素转化成松脆型</li><li>优良的愈伤组织通常具备以下4个特性：①高度的胚性或再分化能力。②容易散碎，建立优良的悬浮系，并能分离出全能性原生质体。③旺盛的自我增殖能力。④经过长期继代保存而不丧失胚性，以便有可能对它们进行各种遗传操作。</li><li>愈伤组织的形态发生：愈伤组织在适宜的培养条件下发生再分化，产生芽和根，或者形成胚状体，发育成苗或完整植株。</li><li>愈伤组织形态发生形成完整植株的途径：<strong>体细胞发生途径（胚状体）</strong>、<strong>器官发生途径（不定芽不定根）</strong></li><li>器官发生的途径有两种：直接途径：不经愈伤组织阶段直接分化器官；间接途径：经过愈伤组织阶段</li><li>愈伤组织通过不定芽方式再分化成完整植株的的方式主要有四种(器官发生再生植株的基本方式)：①<strong>愈伤组织仅有根或芽器官的分别形成，即无根的芽或无芽的根；<strong>②</strong>先长芽，后长根，多数情况；<strong>③</strong>先长根，再从根的基部长芽。这种情况较难诱导芽的形成，尤其对于单子叶植物；<strong>④</strong>先在愈伤组织的邻近不同部位分别形成芽和根，然后两者结合起来形成一株植株。</strong></li><li>影响器官分化的因素（要点，详见影响因素）</li><li>体细胞胚又叫胚状体：指在组织培养中，由一个非合子细胞(体细胞)，经胚胎发生和胚胎发育过程（经过<strong>原胚</strong>、<strong>球形胚</strong>、<strong>心形胚</strong>、<strong>鱼雷胚</strong>和<strong>子叶</strong>胚5个时期），形成具有<strong>双极性</strong>的胚状结构。</li><li>体细胞胚发生的途径：直接形成胚胎指在外植体上直接分化出胚状体，大多数外植体为子叶和下轴胚最易诱导体细胞胚发生。间接形成胚胎是指在外植体上先分化出胚性愈伤组织，然后由胚性愈伤组织再分化形成胚状体</li><li>体细胞胚发生途径的特点:①胚状体具有明显的两极性，即有茎端和根端；存在生理隔离，即体细胞胚和外植体的维管束系统无直接联系，胚状体与周围组织间形成缝隙，处于较独立的状态。②遗传的稳定性。③发生数量大，增殖率高。</li><li>影响体细胞胚胎发生的因素（重点，详见影响因素）</li><li>胚培养：是将胚从胚珠或种子中取出，置于适宜的培养基生长；包括<strong>未成熟胚(原胚)<strong>和</strong>成熟胚</strong>两种类型的离体培养。</li><li>胚发育可分为<strong>异养</strong>和<strong>自养</strong>两个阶段。</li><li>胚培养的意义</li><li>依据所剥离胚的发育时期不同：分为两种培养类型<strong>幼胚培养</strong>（子叶形成前）和<strong>成熟胚培养</strong>（子叶形成后）</li><li>幼胚培养：是指处于原胚期、球形期、心形期、鱼雷期的胚培养；<strong>幼胚基本是异养的</strong>，离体条件下培养要求培养基成分复杂，培养不易成功。</li><li>幼胚的分离及培养：<strong>幼胚剥离</strong>是关键。</li><li>影响幼胚培养成功的因素（要点，详见影响因素）</li><li>胚乳培养（Endosperm culture）：是指将胚乳组织从母体上分离出来，通过离体培养，使其发育成完整植株的技术。</li><li>胚乳离体培养的意义</li><li>带胚培养胚乳组织容易成功，不带胚培养胚乳组织成功率低</li><li>根据细胞分化特点，胚乳发育可分为以下3类：<strong>核型胚乳</strong>、<strong>细胞型胚乳</strong>、<strong>沼生目型胚乳</strong></li><li>胚乳培养的关键技术，胚乳发育时期中<strong>游离核型期</strong>难以培养，<strong>细胞型期</strong>易培养成功</li><li>离体授粉：指将未授粉的胚珠或子房从母体上分离下来，进行无菌培养，并以一定的方式授以无菌花粉，使之在试管内实现受精的技术。</li><li>离体授粉的类型：<strong>离体胎座（胚珠）授粉</strong>、<strong>离体子房授粉</strong>、<strong>离体柱头（雌蕊）授粉</strong></li><li>离体子房授粉的方法：<strong>直接引入法</strong>、<strong>注射法</strong></li><li>离体授粉的目的：<strong>克服受精前障碍</strong></li><li>人工种子：将植物离体培养中产生的胚状体(体胚)或者能发育成完整植株的分生组织(不定芽、小鳞茎、短枝、毛状根、愈伤组织等)包裹在有养分和具有保护功能的物质中形成的类似于天然植物种子的结构，并在适宜条件下发芽出苗的颗粒体。</li><li>人工种子的结构：最外面一层是<strong>人工种皮</strong>，中间是<strong>人工胚乳</strong>，种子内面则是被包埋的<strong>胚状体</strong>或类似物</li><li>人工种子的包埋技术最佳的凝胶包埋材料是<strong>藻酸盐</strong>，包埋方法有滴注法和装模法。（课本P67）</li><li>单倍体（Haploid）：指具有配子体（gametophyte）染色体数的个体或组织，即体细胞染色体数为n。 <strong>单倍体不等于一倍体</strong>。把只有一个染色体组的细胞或体细胞中只含有单个染色体组的个体称为一倍体。由合子发育来的个体，细胞中含有几个染色体组，就叫几倍体;而由配子直接发育来的,不管含有几个染色组，都只能叫单倍体，</li><li>单倍体植物与二倍体相比较，有三个明显的特点：体细胞染色体数<strong>减半</strong>；生长发育<strong>弱</strong>，体形<strong>小</strong>、各器官明显<strong>减小</strong>； 雌雄配子严重<strong>败育</strong>，有的甚至不能进入有性世代。</li><li>植物单倍体细胞培养方法：<strong>胚珠或子房培养（未受精）</strong>、<strong>花药培养</strong>、<strong>花粉培养</strong></li><li>花药培养：将发育到一定阶段的花药剥离下来(切去花丝部分)接种到培养基上进行培养，最终形成完整植株的过程。</li><li>花药培养的基本程序（详见有关程序）</li><li>花药培养材料的选择：花粉发育时期为<strong>单核早期到双核早期</strong></li><li>压片染色法：花药在接种以前，一般需先用<strong>醋酸洋红</strong>压片法进行镜检，以确定花粉的发育时期，并找出花粉发育与花蕾或幼穗大小、颜色等特征之间的相应关系。（第7章PPT25、课本P107）</li><li>花药培养材料的<strong>预处理</strong>是小孢子培养成功的前提条件。</li><li>影响花药培养效率的因素：<strong>供体植株的基因型</strong>；<strong>花粉发育时期</strong>；<strong>花药的生理状态</strong>；<strong>花蕾和花药的预处理</strong>；<strong>培养基的影响</strong></li><li>花粉培养的概念：是从花药中分离出来的花粉粒，使之成为分散的或游离的状态，通过培养使花粉粒脱分化，进而再分化并发育成完整植株的过程。</li><li>花药培养与花粉培养的异同</li><li>花粉的分离的3个方法：<strong>自然散落法</strong>、<strong>挤压法</strong>、<strong>机械游离</strong></li><li>单倍体育种：指将具有单套染色体的单倍体植物，经人工染色体加倍，使其成为纯合二倍体。从中选出具有优良性状的个体，直接繁育成新品种；或选出具有单一优良性状的个体，作为杂交育种的原理材料。</li><li>由完整的植物器官分离单细胞：<strong>叶片</strong>是分离单细胞的最好材料</li><li>植物单细胞的分离的方法：<strong>机械法</strong>、<strong>酶解法</strong></li><li>酶解法：指用专一的水解酶（<strong>纤维素酶</strong>、<strong>果胶酶</strong>、<strong>琼脂酶</strong>等）在温和条件下分解胞间层，分离细胞。</li><li>植物单细胞培养的方法：<strong>平板培养</strong>、<strong>看护培养</strong>、<strong>微室培养</strong>、<strong>纸桥培养</strong>、<strong>饲养层培养法</strong></li><li>悬浮细胞培养的同步化：①<strong>物理方法</strong>：体积选择法、低温休克法；②<strong>化学法</strong>：饥饿法；抑制法；不连续密度梯度离心法</li><li>生物反应器的类型：<strong>搅拌式反应器</strong>、<strong>气动式反应器</strong>、<strong>固定化反应器</strong></li><li>固定化细胞活力测定：①荧光染色观察法：根据<strong>活细胞</strong>对FDA（二乙酸荧光素）黄绿色荧光染料<strong>能被吸收</strong>，而<strong>死细胞无法吸收原理鉴定</strong>。②呼吸强度测定：用氧电极法测定固定化细胞的呼吸强度判断存活率。③细胞分解和生长速率的测定：通过测定细胞的湿重或干重增加率反映细胞活性大小。</li><li>在幼胚培养中，蔗糖是效果最好的碳源之一，同时又起<strong>调节渗透压</strong>的主要作用，这一点对幼胚尤其重要。（课本P58）</li><li>对于体细胞发生的同步化控制和纯化筛选的方法有化学抑制法、低温抑制法、渗透压选择法、机械过筛选择法、应用植物胚性细胞分级仪。（课本P67）</li><li>原生质体：除去植物细胞壁的裸露细胞，称为原生质体</li><li>原生质体的分离方法：机械分离法、酶解分离法（<strong>纤维素酶</strong>、<strong>半纤维素酶</strong>、<strong>果胶酶</strong>、<strong>果酸酶等</strong>）</li><li>原生质体的纯化方法：<strong>沉降法</strong>、<strong>漂浮法</strong>、<strong>界面法</strong></li><li>原生质体活力的测定：目测法：形态识别；<strong>荧光素双醋酸酯(FDA)染色法</strong>（FDA本身不发荧光，也不具有极性，能自由穿过细胞质膜。活细胞内FDA可以被酯酶分解，形成有荧光的极性物质（荧光素）。荧光素则不能自由穿越质膜，在完整的活细胞内积累。<strong>活细胞被染色</strong>）；染色法，酚藏花红染色法（0.01%）（无活力的原生质体染成红色，有活力的原生质体不着色。）、伊凡蓝(Evan’s blue)染色法（0.025%）（有活力但受损伤的细胞和死细胞能够摄取这种染料，活细胞不摄取，无色；无活力的细胞吸收染料为蓝色。）</li><li>细胞杂种的鉴定：①<strong>杂种植物形态特征、特性鉴定</strong>；②<strong>杂种植物的核型分析</strong>；③<strong>同工酶分析</strong>；④<strong>分子标记鉴定</strong>：RFLP、RAPD、SSR标记鉴定</li><li>无病毒苗：指不含该种植物的主要危害病毒，即经检测主要病毒在植物体内的存在表现阴性反应的苗木。</li><li>茎尖脱毒一般切取<strong>0.2~0.3mm</strong>，带1~2个叶原基的茎尖作为培养材料较好。</li><li>热处理去除病毒的原因：利用某些病毒受<strong>热以后的不稳定性</strong>，而使病毒钝化，失去活性。（课本P75）</li><li>去除植物病毒的方法有<strong>热处理法</strong>、<strong>微茎尖培养法</strong>、<strong>愈伤组织培养法</strong>和<strong>茎尖微体嫁接法</strong>等。</li><li>茎尖微体嫁接：木本植物茎尖培养难以生根成植株，将实生苗砧木在人工培养基上种植培育，再从成年无病树枝上切取0.4~1mm茎尖，在砧木上进行试管微体嫁接，以获得无病毒幼苗。</li><li>脱毒植物的鉴定方法：<strong>直接鉴定法</strong>、<strong>指示植物鉴定</strong>、<strong>抗血清反应鉴定</strong>、<strong>分子检测</strong>、<strong>电镜检测</strong></li><li>无病毒苗的保存繁殖：<strong>隔离保存</strong>、<strong>长期保存</strong></li><li>无毒苗的鉴定方法主要有：①<strong>指示植物鉴定法</strong>；②<strong>抗血清鉴定法</strong>；③<strong>电子显微镜检查法</strong>；④<strong>酶联免疫鉴定法</strong>。其中，最后一种是目前比较精确和常用的鉴定方法。多次监测，有延时性</li><li>体细胞无性系：由任何形式的细胞培养所产生的植株统称为<strong>体细胞无性系</strong>（somaclones）。</li><li>在培养阶段发生变异，进而导致再生植株亦发生遗传改变的现象，称为<strong>体细胞无性系变异</strong>（somaclonal variation）。</li><li><strong>嵌合性</strong>是指同一有机体中同时存在有遗传组成不同的细胞，它是组织培养中常见的现象。</li><li>影响体细胞遗传与变异的因素：<strong>培养基和培养方式</strong>、<strong>继代培养的次数</strong></li><li>体细胞变异的细胞遗传学基础：<strong>染色体数量和结构的改变</strong></li><li>染色体结构变异是体细胞变异的另一重要类型。染色体断裂与重组是离体培养中染色体结构变异的主要原因之一，也是体细胞变异中经常发生的现象，其细胞学特征是<strong>分裂中期出现断裂的染色体片段、落后染色体以及染色体桥</strong>，其结果是在体细胞中出现染色体易位、缺失、倒位等多种类型的结构变异。</li><li>种质：是亲代通过生殖细胞或体细胞传递给子代的遗传物质。</li><li>植物种质资源：即为携带各种不同遗传物质的植物总称，又称遗传资源或品种资源，包括栽培，野生及人工创造的各种植物的品种或品系。</li><li>种质资源保存：是指在天然或人工创造的适宜环境条件下，贮存植物种质，使其保持生命力与遗传性的技术。</li><li>植物种质离体保存的方法：<strong>常温限制生长</strong>、<strong>低温保存</strong>、<strong>超低温保存</strong></li><li>低温保存：温度（非冰冻低温，一般为<strong>1~9℃</strong>）；超低温保存：<strong>-196℃</strong>的<strong>液氮</strong></li><li>超低温保存的原理：植物材料在超低温条件下，冰冻过程中避免了细胞内水分结冰，并且在解冻过程中防止细胞内水分次生结冰而达到植物材料保存目的。</li><li>冷冻防护剂：常见的防冻剂有二甲基亚砜（<strong>DMSO</strong>）、聚乙二醇（PEG）、甘油及多种糖类等，防止细胞冰冻或解冻时引起过度脱水而遭到破坏，保护细胞。</li><li>冷冻保护剂应具有以下特性：<strong>分子质量较小</strong>、<strong>易于与溶剂混合</strong>、<strong>快速渗入细胞</strong>；<strong>无毒或毒性小</strong>、<strong>易洗脱</strong>。常用的是DMSO。</li></ol><h2 id="重点知识点自测"><a class="header-anchor" href="#重点知识点自测"></a>重点知识点自测</h2><ol><li>培养基的成分： <u>水</u> 、 <u>无机成分</u> 、 <u>有机成分</u> 、 <u>天然有机添加物质</u> 、 <u>植物生长调节物质</u> 、 <u>培养基的pH值</u> 、 <u>凝固剂–琼脂</u> 、 <u>活性炭</u> 、 <u>抗生素</u> 。</li><li>无机成分中大量元素化合物指浓度 <u>&gt;0.5mmol/L</u> ，有 <u>N、P、K、Ca、Mg、S</u> 。</li><li>无机成分中微量元素化合物指浓度 <u>&lt;0.5mmol/L</u> ，有 <u>B、Mn、Zn、Cu、Mo、Co、Cl、Fe</u> 。</li><li>铁盐容易发生沉淀，需要 <u>单独配制</u> ，一般与 <u>Na<sub>2</sub>EDTA</u> 相互配</li><li>培养基中糖类的功能：碳源及维持培养基一定的 <u>渗透压</u> ，蔗糖是最好的碳源，葡萄糖和果糖次之。</li><li>培养基中氨基酸类的功能：蛋白质组成，优质有机 <u>氮源</u> ，促进细胞生长分化</li><li>生长素类、细胞分裂素类的作用、常用种类、强弱顺序</li><li>培养基的pH值：灭菌前pH值调控范围：pH= <u>5.0~6.0</u> 。pH对培养基凝固的影响：高6.0会变 <u>硬</u> ，低于5.0凝固 <u>效果不好</u> 。pH调节剂：HCl、NaOH</li><li>凝固剂–琼脂,用量范围： <u>0.4%~1.0%</u> ，影响琼脂凝固的因素：厂家的加工方式；灭菌的时间，温度，pH值；存放的时间</li><li>抗生素不耐高温，需单独 <u>过滤</u> 灭菌。作用：防止外植体内生菌造成的污染。</li><li>基本培养基较于完全培养基 <u>不包括激素和天然有机附加物</u> 。</li><li>高无机盐含量的培养基代表类型： <u>MS培养基</u> 、 <u>ER培养基</u> 。</li><li>硝酸钾含量较高的培养基代表类型： <u>B5</u> 、 <u>N6</u> 。</li><li>干热灭菌（如烘烤和灼烧）；湿热灭菌（如常压或高压蒸煮）；过滤灭菌（如空气过滤和液体过滤）</li><li>高温高压蒸气灭菌温度： <u>121</u> °C； <u>1.1~1.2</u> kg/cm<sup>2</sup>，压力不要超过 <u>0.15</u> MP，维持 <u>15-20</u> 分钟即可关闭电源。</li><li>过滤灭菌：在高温高压下易分解的培养基和激素类</li><li>细胞全能性理论： <u>植物每一个具有完整细胞核的体细胞，都含有植物体的全部遗传信息，在适当条件下，具有发育成完整植株的潜在能力</u> 。</li><li>植物细胞全能性表现根据细胞类型不同从强到弱: <u>营养生长中心</u>  &gt;  <u>形成层</u>  &gt;  <u>薄壁细胞</u>  &gt;  <u>厚壁细胞(木质化细胞)</u>  &gt;  <u>特化细胞(筛管、导管细胞)</u> 。</li><li>植物细胞全能性表达的条件：① <u>体细胞与完整植株分离，脱离完整植株的控制</u> ；② <u>创造理想的适于细胞生长和分化的环境（主要是激素的作用）</u></li><li>细胞实现全能性的过程：通过 <u>脱分化</u> 和 <u>再分化</u> 两个阶段。</li><li><u>液泡消失</u> 和 <u>叶绿体的转变</u> 是脱分化的重要特征。</li><li>根据脱分化细胞过程中细胞结构发生变化的时空顺序，细胞的脱分化过程可分为3个阶段： <u>启动阶段</u> 、 <u>演变阶段</u> 和 <u>脱分化终结期</u> 。</li><li>脱分化的关键 <u>植物激素</u> 。</li><li>脱分化细胞特点： <u>细胞质显著变浓，大液泡消失，核体积增加并逐渐移位至细胞中央，细胞器增加。</u></li><li>愈伤组织的定义： <u>在组织培养过程中，沿用了这一名称，实际上是指外植体在离体培养条件下，形成的一团没有分化、又能旺盛分裂的薄壁细胞团，是组织培养过程中经常出现的一种组织状态。</u> 。</li><li>愈伤组织的产生原因：内因： <u>内源激素，材料被切伤后分泌的伤源激素</u> ；外因： <u>外源生长调节剂，人为在培养基内加入激素。</u> 。</li><li>从外植体脱分化形成典型的愈伤组织大致可分为三个时期： <u>诱导期</u> 、 <u>分裂期</u> 和 <u>分化期</u></li><li>两种愈伤组织间的转化关系：坚实型 <u>升高生长素浓度</u> 转化成松脆型，松脆型 <u>降低或去除生长素</u> 转化成松脆型</li><li>优良的愈伤组织通常具备以下4个特性：① <u>高度的胚性或再分化能力</u> 。② <u>容易散碎，建立优良的悬浮系，并能分离出全能性原生质体</u> 。③ <u>旺盛的自我增殖能力</u> 。④ <u>经过长期继代保存而不丧失胚性，以便有可能对它们进行各种遗传操作</u> 。</li><li>愈伤组织的形态发生：愈伤组织在适宜的培养条件下发生再分化，产生芽和根，或者形成胚状体，发育成苗或完整植株。</li><li>愈伤组织形态发生形成完整植株的途径： <u>体细胞发生途径（胚状体）</u> 、 <u>器官发生途径（不定芽不定根）</u> 。</li><li>器官发生的途径有两种： <u>直接途径：不经愈伤组织阶段直接分化器官</u> ； <u>间接途径：经过愈伤组织阶段</u> 。</li><li>愈伤组织通过不定芽方式再分化成完整植株的的方式主要有四种(器官发生再生植株的基本方式)：① <u>愈伤组织仅有根或芽器官的分别形成，即无根的芽或无芽的根</u> ；② <u>先长芽，后长根，多数情况</u> ；③ <u>先长根，再从根的基部长芽。这种情况较难诱导芽的形成，尤其对于单子叶植物</u> ；④ <u>先在愈伤组织的邻近不同部位分别形成芽和根，然后两者结合起来形成一株植株</u> 。</li><li>影响器官分化的因素（要点，详见影响因素）</li><li>体细胞胚又叫胚状体（embryoid）：指在组织培养中，由一个非合子细胞(体细胞)，经胚胎发生和胚胎发育过程（经过 <u>原胚</u> 、 <u>球形胚</u> 、 <u>心形胚</u> 、 <u>鱼雷胚</u> 和 <u>子叶</u> 胚5个时期），形成具有双极性的胚状结构。</li><li>体细胞胚发生的途径： <u>直接形成胚胎指在外植体上直接分化出胚状体，大多数外植体为子叶和下轴胚最易诱导体细胞胚发生</u> 。 <u>间接形成胚胎是指在外植体上先分化出胚性愈伤组织，然后由胚性愈伤组织再分化形成胚状体</u> 。</li><li>体细胞胚发生途径的特点:① <u>胚状体具有明显的两极性，即有茎端和根端；存在生理隔离，即体细胞胚和外植体的维管束系统无直接联系，胚状体与周围组织间形成缝隙，处于较独立的状态</u> 。② <u>遗传的稳定性</u> 。③ <u>发生数量大，增殖率高</u> 。</li><li>影响体细胞胚胎发生的因素（重点，详见影响因素）</li><li>胚培养： <u>是将胚从胚珠或种子中取出，置于适宜的培养基生长；包括未成熟胚(原胚)和成熟胚两种类型的离体培养。</u></li><li>胚发育可分为 <u>异养</u> 和 <u>自养</u> 两个阶段。</li><li>胚培养的意义</li><li>依据所剥离胚的发育时期不同：分为两种培养类型 <u>幼胚培养</u> （子叶形成前）和 <u>成熟胚培养</u> （子叶形成后）</li><li>幼胚培养： <u>是指处于原胚期、球形期、心形期、鱼雷期的胚培养</u> ；幼胚基本是 <u>异养的</u> ，离体条件下培养要求培养基成分复杂，培养不易成功。</li><li>幼胚的分离及培养： <u>幼胚剥离</u> 是关键。</li><li>影响幼胚培养成功的因素（要点，详见影响因素）</li><li>胚乳培养（Endosperm culture）： <u>是指将胚乳组织从母体上分离出来，通过离体培养，使其发育成完整植株的技术。</u></li><li>胚乳离体培养的意义</li><li><u>带胚</u> 培养胚乳组织容易成功， <u>不带胚</u> 培养胚乳组织成功率低</li><li>根据细胞分化特点，胚乳发育可分为以下3类： <u>核型胚乳</u> 、 <u>细胞型胚乳</u> 、 <u>沼生目型胚乳</u></li><li>胚乳培养的关键技术，胚乳发育时期中 <u>游离核型期</u> 难以培养， <u>细胞型期</u> 易培养成功</li><li>离体授粉： <u>指将未授粉的胚珠或子房从母体上分离下来，进行无菌培养，并以一定的方式授以无菌花粉，使之在试管内实现受精的技术。</u></li><li>离体授粉的类型： <u>离体胎座（胚珠）授粉</u> 、 <u>离体子房授粉</u> 、 <u>离体柱头（雌蕊）授粉</u></li><li>离体子房授粉的方法： <u>直接引入法</u> 、 <u>注射法</u></li><li>离体授粉的目的： <u>克服受精前障碍</u></li><li>人工种子： <u>将植物离体培养中产生的胚状体(体胚)或者能发育成完整植株的分生组织(不定芽、小鳞茎、短枝、毛状根、愈伤组织等)包裹在有养分和具有保护功能的物质中形成的类似于天然植物种子的结构，并在适宜条件下发芽出苗的颗粒体。</u></li><li>人工种子的结构：最外面一层是 <u>人工种皮</u> ，中间是 <u>人工胚乳</u> ，种子内面则是被包埋的 <u>胚状体</u> 或类似物</li><li>人工种子的包埋技术最佳的凝胶包埋材料是 <u>藻酸盐</u> ，包埋方法有 <u>滴注法</u> 和 <u>装模法</u> 。（课本P67）</li><li>单倍体（Haploid）： <u>指具有配子体（gametophyte）染色体数的个体或组织，即体细胞染色体数为n。 单倍体不等于一倍体</u> 。把只有一个染色体组的细胞或体细胞中只含有单个染色体组的个体称为一倍体。由合子发育来的个体，细胞中含有几个染色体组，就叫几倍体;而由配子直接发育来的,不管含有几个染色组，都只能叫单倍体，</li><li>单倍体植物与二倍体相比较，有三个明显的特点：体细胞染色体数 <u>减半</u> ；生长发育 <u>弱</u> ，体形 <u>小</u> 、各器官明显 <u>减小</u> ； 雌雄配子严重 <u>败育</u> ，有的甚至不能进入有性世代。</li><li>植物单倍体细胞培养方法: <u>胚珠或子房培养（未受精）</u> 、 <u>花药培养</u> 、 <u>花粉培养</u></li><li>花药培养： <u>将发育到一定阶段的花药剥离下来(切去花丝部分)接种到培养基上进行培养，最终形成完整植株的过程。</u></li><li>花药培养的基本程序（详见有关程序）</li><li>花药培养材料的选择：花粉发育时期为 <u>单核早期到双核早期</u></li><li>压片染色法：花药在接种以前，一般需先用 <u>醋酸洋红</u> 压片法进行镜检，以确定花粉的发育时期，并找出花粉发育与花蕾或幼穗大小、颜色等特征之间的相应关系。（第7章PPT25、课本P107）</li><li>花药培养材料的 <u>预处理</u> 是小孢子培养成功的前提条件。</li><li>影响花药培养效率的因素： <u>供体植株的基因型</u> ； <u>花粉发育时期</u> ； <u>花药的生理状态</u> ； <u>花蕾和花药的预处理</u> ； <u>培养基的影响</u></li><li>花粉培养的概念： <u>是从花药中分离出来的花粉粒，使之成为分散的或游离的状态，通过培养使花粉粒脱分化，进而再分化并发育成完整植株的过程。</u></li><li>花药培养与花粉培养的异同</li><li>花粉的分离的3个方法： <u>自然散落法</u> 、 <u>挤压法</u> 、 <u>机械游离</u></li><li>单倍体育种： <u>指将具有单套染色体的单倍体植物，经人工染色体加倍，使其成为纯合二倍体。从中选出具有优良性状的个体，直接繁育成新品种；或选出具有单一优良性状的个体，作为杂交育种的原理材料。</u></li><li>由完整的植物器官分离单细胞： <u>叶片</u> 是分离单细胞的最好材料</li><li>植物单细胞的分离的方法： <u>机械法</u> 、 <u>酶解法</u></li><li>酶解法：指用专一的水解酶（<u>纤维素酶</u> 、 <u>果胶酶</u> 、 <u>琼脂酶</u> 等）在温和条件下分解胞间层，分离细胞。</li><li>植物单细胞培养的方法： <u>平板培养</u> 、 <u>看护培养</u> 、 <u>微室培养</u> 、 <u>纸桥培养</u> 、 <u>饲养层培养法</u></li><li>悬浮细胞培养的同步化：① <u>物理方法：体积选择法、低温休克法</u> ；② <u>化学法：饥饿法；抑制法；不连续密度梯度离心法</u></li><li>生物反应器的类型： <u>搅拌式反应器</u> 、 <u>气动式反应器</u> 、 <u>固定化反应器</u></li><li>固定化细胞活力测定：① <u>荧光染色观察法：根据活细胞对FDA（二乙酸荧光素）黄绿色荧光染料能被吸收，而死细胞无法吸收原理鉴定。</u> ② <u>呼吸强度测定：用氧电极法测定固定化细胞的呼吸强度判断存活率。③细胞分解和生长速率的测定：通过测定细胞的湿重或干重增加率反映细胞活性大小。</u></li><li>在幼胚培养中，蔗糖是效果最好的碳源之一，同时又起 <u>调节渗透压</u> 的主要作用，这一点对幼胚尤其重要。（课本P58）</li><li>对于体细胞发生的同步化控制和纯化筛选的方法有 <u>化学抑制法</u> 、 <u>低温抑制法</u> 、 <u>渗透压选择法</u> 、 <u>机械过筛选择法</u> 、 <u>应用植物胚性细胞分级仪</u> 。（课本P67）</li><li>原生质体： <u>除去植物细胞壁的裸露细胞，称为原生质体</u></li><li>原生质体的分离方法： <u>机械分离法</u> 、 <u>酶解分离法</u> （ <u>纤维素</u> 酶、 <u>半纤维素</u> 酶、 <u>果胶</u> 酶、 <u>果酸</u> 酶等）</li><li>原生质体的纯化方法： <u>沉降法</u> 、 <u>漂浮法</u> 、 <u>界面法</u></li><li>原生质体活力的测定： <u>目测</u> 法：形态识别； <u>荧光素双醋酸酯(FDA)染色</u> 法（FDA本身不发荧光，也不具有极性，能自由穿过细胞质膜。活细胞内FDA可以被酯酶分解，形成有荧光的极性物质（荧光素）。荧光素则不能自由穿越质膜，在完整的活细胞内积累。活细胞被染色）； <u>染色</u> 法，酚藏花红染色法（0.01%)、伊凡蓝(Evan’s blue)染色法(0.025%)</li><li>细胞杂种的鉴定：① <u>杂种植物形态特征、特性鉴定</u> ；② <u>杂种植物的核型分析</u> ；③ <u>同工酶分析</u> ；④ <u>分子标记鉴定：RFLP、RAPD、SSR标记鉴定</u></li><li>无病毒苗： <u>指不含该种植物的主要危害病毒，即经检测主要病毒在植物体内的存在表现阴性反应的苗木。</u></li><li>茎尖脱毒一般切取 <u>0.2~0.3mm</u> ，带1~2个叶原基的茎尖作为培养材料较好。</li><li>热处理去除病毒的原因：利用某些病毒受 <u>热以后的不稳定性</u> ，而使病毒钝化，失去活性。（课本P75）</li><li>去除植物病毒的方法有 <u>热处理法</u> 、 <u>微茎尖培养法</u> 、 <u>愈伤组织培养法</u> 和 <u>茎尖微体嫁接法</u> 等。</li><li>茎尖微体嫁接： <u>木本植物茎尖培养难以生根成植株，将实生苗砧木在人工培养基上种植培育，再从成年无病树枝上切取0.4~1mm茎尖，在砧木上进行试管微体嫁接，以获得无病毒幼苗。</u></li><li>脱毒植物的鉴定方法： <u>直接鉴定法</u> 、 <u>指示植物鉴定</u> 、 <u>抗血清反应鉴定</u> 、 <u>分子检测</u> 、 <u>电镜检测</u></li><li>无病毒苗的保存繁殖： <u>隔离保存</u> 、 <u>长期保存</u></li><li>无毒苗的鉴定方法主要有：① <u>指示植物鉴定法</u> ；② <u>抗血清鉴定法</u> ；③ <u>电子显微镜检查法</u> ；④ <u>酶联免疫鉴定法</u> 。其中，最后一种是目前比较精确和常用的鉴定方法。</li><li>体细胞无性系： <u>由任何形式的细胞培养所产生的植株统称为体细胞无性系（somaclones）。</u></li><li><u>在培养阶段发生变异，进而导致再生植株亦发生遗传改变的现象</u> ，称为体细胞无性系变异（somaclonal variation）。</li><li>嵌合性是指 <u>同一有机体中同时存在有遗传组成不同的细胞，它是组织培养中常见的现象。</u></li><li>影响体细胞遗传与变异的因素： <u>培养基和培养方式</u> 、 <u>继代培养的次数</u></li><li>体细胞变异的细胞遗传学基础： <u>染色体数量和结构的改变</u></li><li>染色体结构变异是体细胞变异的另一重要类型。染色体断裂与重组是离体培养中染色体结构变异的主要原因之一，也是体细胞变异中经常发生的现象，其细胞学特征是 <u>分裂中期出现断裂的染色体片段</u> 、落后染色体以及染色体桥，其结果是在体细胞中出现染色体易位、缺失、倒位等多种类型的结构变异。</li><li>种质：是 <u>亲代通过生殖细胞或体细胞传递给子代的遗传物质。</u> 。</li><li>植物种质资源：即为 <u>携带各种不同遗传物质的植物总称，又称遗传资源或品种资源，包括栽培，野生及人工创造的各种植物的品种或品系。</u></li><li>种质资源保存：是指 <u>在天然或人工创造的适宜环境条件下，贮存植物种质，使其保持生命力与遗传性的技术。</u></li><li>植物种质离体保存的方法： <u>常温限制生长</u> 、 <u>低温保存</u> 、 <u>超低温保存</u></li><li>低温保存：温度（ <u>非冰冻低温，一般为1-9℃</u> ）；超低温保存： <u>-196℃的液氮</u></li><li>超低温保存的原理： <u>植物材料在超低温条件下，冰冻过程中避免了细胞内水分结冰，并且在解冻过程中防止细胞内水分次生结冰而达到植物材料保存目的。</u></li><li>冷冻防护剂：常见的防冻剂有 <u>二甲基亚砜（DMSO）</u> 、 <u>聚乙二醇（PEG）</u> 、 <u>甘油及多种糖类</u> 等，防止细胞冰冻或解冻时引起过度脱水而遭到破坏，保护细胞。</li><li>冷冻保护剂应具有以下特性： <u>分子质量较小</u> 、 <u>易于与溶剂混合</u> 、 <u>快速渗入细胞</u> ； <u>无毒或毒性小</u> 、 <u>易洗脱</u> 。常用的是 <u>DMSO</u> 。</li></ol><h2 id="有关名词整理"><a class="header-anchor" href="#有关名词整理"></a>有关名词整理</h2><h3 id="第1章-组培绪论"><a class="header-anchor" href="#第1章-组培绪论"></a>第1章 组培绪论</h3><ol><li><strong>植物组织培养</strong>：指在无菌条件下，将离体的植物器官、组织、细胞或原生质体，培养在人工配制的培养基上，人为控制培养条件，使其生长、分化、增殖，发育成完整植株或生产次生代谢物质的过程和技术。狭义指由植物组织或器官培养产生愈伤组织，经过再分化进而培养成完整植株。广义指人工培养植物体一部分(即外植体) 生成完整植株。⭐</li><li><strong>愈伤组织</strong>：原本是指植物在受伤后与其伤口表面形成的一团薄壁细胞。在植物细胞组织培养中，愈伤组织则指在人工培养基上由外植体长出来的一团无序生长的薄壁细胞。特征：细胞排列疏松而无规则，是一种高度液泡化的呈无定形状态的薄壁细胞。 ⭐</li><li><strong>外植体</strong>：从植物体分离并用于离体培养的材料。⭐</li><li><strong>植株培养</strong>：对具有完整植株形态的幼苗或较大植株进行离体培养的方法</li><li><strong>器官培养</strong>：即离体器官的培养。根据作物和需要的不同，可以包括分离的茎尖﹑茎段﹑根尖﹑叶片﹑叶原基﹑子叶﹑花瓣﹑雄蕊﹑雌蕊﹑胚珠﹑胚﹑子房﹑果实等外植体的培养。</li><li><strong>组织培养</strong>：是对植物体的各部分组织进行培养，如茎尖分生组织﹑形成层﹑木质部﹑韧皮部﹑表皮组织﹑胚乳组织和薄壁组织等等；或对由植物器官培养产生的愈伤组织进行培养，二者均通过在分化诱导形成植株。</li><li><strong>胚胎培养</strong>：对植物的胚及胚器官进行人工离体的无菌培养，使其发育成幼苗的技术</li><li><strong>细胞培养</strong>：对植物的单个细胞或较小的细胞团进行离体培养的方法。常用的细胞培养材料有性细胞，叶肉细胞，根尖细胞等。</li><li><strong>细胞看护培养</strong>：用一块活跃生长的愈伤组织块来看护单个细胞，并使其生长和增殖的方法。</li><li><strong>细胞平板培养</strong>：把单个细胞与融化的琼脂培养基均匀混合，并平铺一薄层在培养皿底上的培养方法。</li><li><strong>原生质体培养</strong>：是用酶及物理方法除去细胞壁的原生质体的培养</li><li><strong>初代/诱导培养</strong>：芽、茎段、叶片、花器等外植体在离体培养条件下诱导愈伤组织、侧芽或不定芽、胚状体过程。</li><li><strong>继代培养/增殖培养</strong>：更换新鲜培养基来繁殖同种类型的材料（愈伤组织、芽）。</li><li><strong>生根培养</strong>：将芽苗转接到生根培养基上培养成为完整植株的过程。</li><li><strong>驯化移栽</strong>： 组培苗经人工炼苗后移栽到驯化苗床上使之适应露地或保护地条件的过程。</li><li><strong>人工种子</strong>：指植物离体培养中产生的胚状体或不定芽，被包裹在含有养分和保护功能的人工胚乳和种皮中，从而形成能发芽出苗颗粒体。</li><li><strong>工厂化育苗</strong>：指以植物培养基为基础，将外植体接种在人工配制的培养基上，通过控制环境条件，使细胞脱分化﹑再分化成新的组织﹑器官，进而培育出与母株一样的批量幼苗的方法。</li><li><strong>植物激素</strong>：是指植物体内合成的，对生长发育有显著调节作用的微量小分子有机物，它们在某些组织中产生，既可以在产生它的组织中，也可运输到其它组织中发挥作用</li><li><strong>植物生长调节剂</strong>：人工合成的具有植物激素活性的物质称为植物生长调节剂</li></ol><h3 id="第2章-组培基本技术"><a class="header-anchor" href="#第2章-组培基本技术"></a>第2章 组培基本技术</h3><ol><li><strong>基本培养基</strong>：指只含有维持离体植物细胞基本生命活动所需的营养成分的培养基。通常包括水分、无机营养成分和有机营养成分，<strong>不包括激素和天然有机附加物</strong>。</li><li><strong>完全培养基</strong>：指在基本培养基的基础上另外附加激素或天然有机附加物所组成的培养基。</li><li><strong>继代培养</strong>：培养物在培养基上生长一段时间以后，由于营养物质枯竭，水分散失，以及代谢产物的积累，必须转移到新鲜培养基上培养。⭐</li><li><strong>外植体</strong>：从植物体分离并用于离体培养的材料。⭐</li><li><strong>愈伤组织培养</strong>：外植体接种到人工培养基上，在激素作用下，进行愈伤组织诱导、生长和分化的培养过程。</li><li><strong>外植体褐变</strong>：是指在接种后，其表面开始褐变，有时甚至会使整个培养基褐变的现象。</li><li><strong>玻璃化现象</strong>：植物组织培养中，常会出现一些半透明状的畸形试管植物，培养物的嫩茎、叶片往往会呈半透明水渍状, 这类植物体被称为“玻璃苗”，这种现象称为玻璃化现象，又称过度水化现象。</li></ol><h3 id="第3章-组培基本理论"><a class="header-anchor" href="#第3章-组培基本理论"></a>第3章 组培基本理论</h3><ol><li><strong>细胞全能性理论</strong>：植物每一个具有完整细胞核的体细胞，都含有植物体的全部遗传信息，在适当条件下，具有发育成完整植株的潜在能力。⭐</li><li><strong>分化</strong>：分化是指个体发育过程中，不同部位的细胞形态结构和生理功能发生改变，形成不同组织或器官。</li><li><strong>脱分化</strong>：已分化好的细胞在人工诱导条件下，恢复分生能力，回复到分生组织状态的过程。</li><li><strong>再分化</strong>：脱分化后具有分生能力的细胞再经过与原来相同的分化过程，重新形成各类组织和器官的过程。</li></ol><h3 id="第4章-植物组织器官形成"><a class="header-anchor" href="#第4章-植物组织器官形成"></a>第4章 植物组织器官形成</h3><ol><li><strong>体细胞胚(胚状体)</strong>：指在组织培养中，由一个非合子细胞(体细胞)，经胚胎发生和胚胎发育过程（经过原胚、球形胚、心形胚、鱼雷胚和子叶胚5个时期），形成具有双极性的胚状结构。⭐</li></ol><h3 id="第5章-植物胚胎培养"><a class="header-anchor" href="#第5章-植物胚胎培养"></a>第5章 植物胚胎培养</h3><ol><li><strong>植物胚胎培养</strong>：指对植物的胚、子房、胚珠和胚乳进行离体培养，使其发育成完整植物的技术。包括：胚培养、胚乳培养、胚珠培养、子房培养、离体受精。</li><li><strong>胚培养</strong>：是将胚从胚珠或种子中取出，置于适宜的培养基生长；包括未成熟胚(原胚)和成熟胚两种类型的离体培养。⭐</li><li><strong>成熟胚培养</strong>：指子叶期至发育成熟的胚培养。成熟胚是自养的，培养基需要简单。仅提供一定的温度、湿度就可以发芽生成植物体。如种子的发育。</li><li><strong>幼胚培养</strong>：是指处于原胚期、球形期、心形期、鱼雷期的胚培养；幼胚基本是异养的，离体条件下培养要求培养基成分复杂，培养不易成功。</li><li><strong>胚乳培养</strong> ：指处于细胞期胚乳的离体培养，获得三倍体⭐</li><li><strong>胚珠培养</strong> ：未受精，为试管受精提供雌配子体，受精后，从两个细胞的原胚开始至球形胚阶段。⭐</li><li><strong>子房培养</strong> ：亲缘关系较远的物种杂交可获得杂种。</li><li><strong>离体受精</strong> ：培养未受精胚珠并在试管内撒播花粉，使其受精形成具有生活力的种子。</li><li><strong>离体胚培养</strong>：是指从植物种子中分离出胚组织进行离体培养的技术</li></ol><h3 id="第7章-单倍体细胞培养"><a class="header-anchor" href="#第7章-单倍体细胞培养"></a>第7章 单倍体细胞培养</h3><ol><li><strong>花粉培养</strong>：是从花药中分离出来的花粉粒，使之成为分散的或游离的状态，通过培养使花粉粒脱分化，进而再分化并发育成完整植株的过程。⭐</li><li><strong>花药培养</strong>：将发育到一定阶段的花药剥离下来(切去花丝部分)接种到培养基上进行培养，最终形成完整植株的过程。⭐</li><li><strong>嵌合性</strong>：指的是遗传组成不同的细胞在个体中同时存在的现象。（课本P203）⭐</li><li><strong>单倍体</strong>：指具有配子体（gametophyte）染色体数的个体或组织，即体细胞染色体数为n。</li><li><strong>单倍体育种</strong>：指将具有单套染色体的单倍体植物，经人工染色体加倍，使其成为纯合二倍体。从中选出具有优良性状的个体，直接繁育成新品种；或选出具有单一优良性状的个体，作为杂交育种的原理材料。</li></ol><h3 id="第10章-植物脱毒技术"><a class="header-anchor" href="#第10章-植物脱毒技术"></a>第10章 植物脱毒技术</h3><ol><li><strong>无病毒苗</strong>：指<strong>不含</strong>该种植物的<strong>主要危害病毒</strong>，即经检测主要病毒在植物体内的存在表现阴性反应的苗木）。<strong>能相对保持物种遗传稳定性</strong>。⭐（PPT10）</li></ol><h3 id="第11章-植物体细胞无性系变异及种质离体保存"><a class="header-anchor" href="#第11章-植物体细胞无性系变异及种质离体保存"></a>第11章 植物体细胞无性系变异及种质离体保存</h3><ol><li><strong>体细胞无性系</strong>：由任何形式的细胞培养所产生的植株统称为体细胞无性系。⭐</li><li><strong>体细胞无性系变异</strong>：在培养阶段发生变异，进而导致再生植株亦发生遗传改变的现象。⭐</li><li><strong>种质</strong>：是亲代通过生殖细胞或体细胞传递给子代的遗传物质。</li><li><strong>植物种质资源</strong>：即为携带各种不同遗传物质的植物总称，又称遗传资源或品种资源，包括栽培，野生及人工创造的各种植物的品种或品系。</li><li><strong>种质资源保存</strong>：是指在天然或人工创造的适宜环境条件下，贮存植物种质，使其保持生命力与遗传性的技术。</li><li><strong>超低温保存</strong>：也叫冷冻保存，指在-196℃的液氮超低温下使细胞代谢和生长处于基本停止的状态，在适宜条件下可繁殖，再生出新的植株，并保持原来的遗传特性。</li></ol><hr><p><a href="https://halo123.top/2020/12/25/%E7%94%9F%E7%89%A9%E5%AD%A6/%E7%BB%84%E5%9F%B9%E8%B5%84%E6%96%99/">其他组培资料</a><br><a href="https://halo123.top/2020/12/25/%E7%94%9F%E7%89%A9%E5%AD%A6/%E7%BB%84%E5%9F%B9PPT/">组培PPT资料整理（未完成）</a></p>]]></content>
      
      
      <categories>
          
          <category> 生物学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 植物组织培养 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>专业英语复习整理</title>
      <link href="2020/12/25/%E7%94%9F%E7%89%A9%E5%AD%A6/%E4%B8%93%E4%B8%9A%E8%8B%B1%E8%AF%AD%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86_v202101040129/"/>
      <url>2020/12/25/%E7%94%9F%E7%89%A9%E5%AD%A6/%E4%B8%93%E4%B8%9A%E8%8B%B1%E8%AF%AD%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86_v202101040129/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近一次同步时间:2021年1月4日01点30分<br>如文档内容有误，点击<a href="http://doc.halo123.top:3000/m06H0jw0QDC0327_Bn1xEw?both">该链接</a>对文档进行修改，定时会同步到网站上<br>文档采用Markdown格式排版，可以参考<a href="https://halo123.top/2019/05/08/Markdown%E8%AF%AD%E6%B3%95/">该网站</a>进行简单学习，感谢参与整理的同学们</p></blockquote><h2 id="第1章-Inside-the-Living-Cell-Structure-and-Function-of-Internal-Cell-Parts"><a class="header-anchor" href="#第1章-Inside-the-Living-Cell-Structure-and-Function-of-Internal-Cell-Parts"></a>第1章 Inside the Living Cell: Structure and Function of Internal Cell Parts</h2><ol><li><p>Cytoplasm: The Dynamic, Mobile Factory (细胞质：动力工厂)</p><p>Most of the properties we associate with life are properties of the cytoplasm.  Much of the mass of a cell consists of this semifluid substance, which is bounded on the outside by the plasma membrane.  Organelles are suspended within it, supported by the filamentous network of the cytoskeleton.  Dissolved in the cytoplasmic fluid are nutrients, ions, soluble proteins, and other materials needed for cell functioning.</p><blockquote><p>生命的大部分特征表现在细胞质的特征上。细胞质大部分由半流体物质组成，并由细胞膜（原生质膜）包被。细胞器悬浮在其中，并由丝状的细胞骨架支撑。细胞质中溶解了大量的营养物质，离子，可溶蛋白以及维持细胞生理需求的其它物质。</p></blockquote></li><li><p>The Nucleus: Information Central（细胞核：信息中心）</p><p>The eukaryotic cell nucleus is the largest organelle and houses the genetic material (DNA) on chromosomes. (In prokaryotes the hereditary material is found in the nucleoid.) The nucleus also contains one or two organelles-the nucleoli-that play a role in cell division.  A pore-perforated sac called the nuclear envelope separates the nucleus and its contents from the cytoplasm.  Small molecules can pass through the nuclear envelope, but larger molecules such as mRNA and ribosomes must enter and exit via the pores.</p><blockquote><p>真核细胞的细胞核是最大的细胞器，细胞核对染色体组有保护作用（原核细胞的遗传物质存在于拟核中）。细胞核含有一或二个核仁，核仁促进细胞分裂。核膜贯穿许多小孔，小分子可以自由通过核膜，而象mRNA和核糖体等大分子必须通过核孔运输。</p></blockquote></li><li><p>Organelles: Specialized Work Units（细胞器：特殊的功能单位）</p><p>All eukaryotic cells contain most of the various kinds of organelles, and each organelle performs a specialized function in the cell.  Organelles described in this section include ribosomes, the endoplasmic reticulum, the Golgi complex, vacuoles, lysosomes, mitochondria, and the plastids of plant cells.</p><blockquote><p>所有的真核细胞都含有多种细胞器，每个细胞器都有其特定功能。本节主要介绍核糖体，内质网，高尔基体系，液泡，溶酶体，线粒体和植物细胞中的质体。</p></blockquote><p>The number of ribosomes within a cell may range from a few hundred to many thousands.  This quantity reflects the fact that, ribosomes are the sites at which amino acids are assembled into proteins for export or for use in cell processes.  A complete ribosome is composed of one larger and one smaller subunit.  During protein synthesis the two subunits move along a strand of mRNA, “reading” the genetic sequence coded in it and translating that sequence into protein.  Several ribosomes may become attached to a single mRNA strand; such a combination is called a polysome.  Most cellular proteins are manufactured on ribosomes in the cytoplasm.  Exportable proteins and membrane proteins are usually made in association with the endoplasmic reticulum.</p><blockquote><p>核糖体的数量变化从几百到几千，核糖体是氨基酸组装成蛋白质的重要场所。完整的核糖体由大亚基和小亚基组成。核糖体沿着mRNA移动并阅读遗传密码，翻译成蛋白质。一条mRNA上可能有多个核糖体，称多聚核糖体。大多数细胞蛋白是由细胞质中核糖体生产。输出蛋白和膜蛋白通常与内质网有关。</p></blockquote><p>The endoplasmic reticulum, a lacy array of membranous sacs, tubules, and vesicles, may be either rough (RER) or smooth (SER).  Both types play roles in the synthesis and transport of proteins. The RER, which is studded with polysomes, also seems to be the source of the nuclear envelope after a cell divides. SER lacks polysomes; it is active in the synthesis of fats and steroids and in the oxidation of toxic substances in the cell.  Both types of endoplasmic reticulum serve as compartments within the cell where specific products can be isolated and subsequently shunted to particular areas in or outside the cell.</p><blockquote><p>内质网，带有花边的生物囊，有管状，泡状之分，以及光滑和粗糙面区别。两种都与蛋白质的合成和运输有关。粗糙内质网上分布许多核糖体，也可能提供细胞分裂后所需的细胞膜。光滑内质网上无核糖体，主要作用是脂肪和类固醇的合成以及细胞内有毒物质的氧化。两种内质网合成的产物在其中进行分流或运输到细胞外。</p></blockquote><p>Transport vesicles may carry exportable molecules from the endoplasmic reticulum to another membranous organelle, the Golgi complex.  Within the Golgi complex molecules are modified and packaged for export out of the cell or for delivery else where in the cytoplasm.</p><blockquote><p>运输小泡能够将可运输分子从内质网运输到高尔基复合体上。在高尔基复合体中修饰，包装后输出细胞或传递到细胞质中的其他场所。</p></blockquote><p>Vacuoles in cells appear to be hollow sacs but are actually filled with fluid and soluble molecules.  The most prominent vacuoles appear in plant cells and serve as water reservoirs and storage sites for sugars and other molecules.  Vacuoles in animal cells carry out phagocytosis (the intake of particulate matter) and pinocytosis (vacuolar drinking).</p><blockquote><p>细胞中的液泡好象是中空的，但实际上充满了液体和可溶分子。最典型的液泡存在于植物细胞中，储备水，糖以及其它分子。动物中的液泡起吞噬和胞饮作用。</p></blockquote><p>A subset of vacuoles are the organelles known as lysosomes, which contain digestive enzymes (packaged in lysosomes in the Golgi complex) that can break down most biological macromolecules.  They act to digest food particles and to degrade damaged cell parts.</p><blockquote><p>溶酶体是液泡亚单位，含有消化酶，降解大部分生物大分子。消化食物微粒和降解损伤的细胞残片。</p></blockquote><p>Mitochondria are the sites of energy-yielding chemical reactions in all cells.  In addition, plant cells contain plastids that utilize light energy to manufacture carbohydrates in the process of photosynthesis.  It is on the large surface area provided by the inner cristae of mitochondria that ATP-generating enzymes are located.  Mitochondria are self-replicating, and probably they are the evolutionary descendants of what were once free-living prokaryotes.</p><blockquote><p>线粒体是细胞中化学产能的场所。另外，植物细胞中的质体在光合作用中利用光能产生碳水化合物，线粒体内嵴上提供了很大的表面积并分布着产ATP酶。线粒体自我复制，并且可能是自由生活的原核生物在进化中形成的后代。</p></blockquote><p>There are two types of plastids: leucoplasts, which lack pigments and serve as storage sites for starch, proteins, and oils; and chromoplasts, which contain pigments.  The most important chromoplasts are chloroplasts-organelles that contain the chlorophyll used in photosynthesis.  The internal structure of chloroplasts includes stacks of membranes called grana, which are embedded in a matrix called the stroma.</p><blockquote><p>质体有两种类型：白色体，缺乏色素，是淀粉，蛋白质和油的储备场所；色质体，含有色素。叶绿体是最重要的色质体，含有与光合作用有关的叶绿素。叶绿体的内部结构是由多层膜形成的叶绿体基粒，其中包埋在基质中的基粒称子座。</p></blockquote></li><li><p>The Cytoskeleton（细胞骨架）</p><p>All eukaryotic cells have a cytoskeleton, which is a convoluted latticework of filaments and tubules that appears to fill all available space in the cell and provides support for various other organelles.  A large portion of the cytoskeleton consists of threadlike microfilaments composed mainly of the contractile protein actin.  They are involved in many types of intracellular movements in plant and animal cells.  A second protein, myosin, is involve in the contraction of muscle cells.  Another main structural component of the cytoskeleton consists of microtubules, which are composed of the globular protein tubulin and together act as scaffolding that provides a stable cell shape.  Cytoskeletal intermediate filaments appear to impart tensile strength to the cell cytoplasm.  Mechanoenzymes such as myosin, dynein, and kinesin interact with the cytoskeletal filaments and tubules to generate forces that cause movements.</p><blockquote><p>所有的细胞都有细胞骨架，网络结构的纤丝充满了它所能触及的全部空间并且对细胞器提供支持作用。细胞骨架大部分由微丝组成，微丝主要由可收缩的肌动蛋白组成。动植物细胞的许多种类型细胞内运动与肌动蛋白有关。第二类蛋白是肌球蛋白，它与肌肉细胞的收缩有关。细胞骨架的另一个主要结构成分是微管，由球状的微管蛋白组成，象脚手架一般维持细胞的稳定形态。细胞骨架的中间丝提供了细胞质伸缩动力。机械酶，例如，肌球蛋白，动力蛋白，驱动蛋白与微丝，微管相互作用产生动力而引起细胞运动。</p></blockquote></li><li><p>Cellular Movements（细胞运动）</p><p>Although the cytoskeleton provides some stability to cells, its microtubules and filaments and their associated proteins enable cells to move by creeping or gliding .  Such movements require a solid substrate to which the cell can adhere and can be guided by the geometry of the surface.  Some cells also exhibit chemotaxis, the ability to move toward or away from the source of a diffusing chemical.</p><blockquote><p>尽管细胞骨架提供了细胞的某些稳定性，微丝，微管及相关蛋白能使细胞爬行或滑动。这种运动需要固体基质依托并通过表面几何形状的改变而运动。某些细胞具备趋药性，即趋向或逃离扩散开的化学源。</p></blockquote><p>Certain eukaryotic cells can swim freely in liquid environments, propelled by whiplike cilia or flagella. Both cilia and flagella have the same internal structure: nine doublets (pairs of microtubules) are arranged in a ring and extend the length of the cilium or flagellum, and two more microtubules run down the center of the ring. Every cilium or flagellum grows only from the cell surface where a basal body is located. Movement is based on the activities of tiny dynein side arms that extend from one of the microtubules of each doublet.</p><blockquote><p>某些真核细胞能在液体液体中自由运动，由纤毛或鞭毛推动。纤毛和鞭毛具有同样的内部结构：九个双微管环形排列，纵向延伸，环中心是两个或以上微管组成。纤毛或鞭毛从细胞表面的基体出生长，双微管的动力蛋白臂从一侧延伸到另一侧而引起运动。</p></blockquote><p>Nutrients, proteins, and other materials within most plant cells are moved about via cytoplasmic streaming. The process occurs as myosin ˈmaiəusin肌凝蛋白 proteins attached to organelles 细胞器,小器官 push against microfilaments arrayed [əˈrei] 展示throughout the cell. Microfilaments and microtubules are responsible for almost all major cytoplasmic movements. During cell division, microtubules of the spindle assembled 集合, 收集 from tubutin subunits near organelles called centrioles move the chromosomes.</p><blockquote><p>大部分植物细胞的营养，蛋白质和其它物质由细胞质流运输。这个过程是由于依附在细胞器上的肌球蛋白反推排列在细胞周围的微丝形成的。绝大部分细胞质运动由微丝和微管完成。在细胞分裂期间，中心粒周围的由微管蛋白亚基装配形成的纺锤体微管移向染色体。</p></blockquote></li></ol><h2 id="第二章-Photosynthesis"><a class="header-anchor" href="#第二章-Photosynthesis"></a>第二章 Photosynthesis</h2><p>Photosynthesis occurs only in the chlorophyllchlorophyll叶绿素-containing cells of green plants, algae藻, and certain protists原生生物and bacteria.  Overall, it is a process that converts light energy into chemical energy that is stored in the molecular bonds.  From the point of view of chemistry and energetics, it is the opposite of cellular respiration.  Whereas 然而 cellular细胞的 respiration 呼吸is highly exergonic吸收能量的 and releases energy, photosynthesis光合作用 requires energy and is highly endergonic.</p><blockquote><p>光合作用只发生在含有叶绿素的绿色植物细胞，海藻，某些原生动物和细菌之中。总体来说，这是一个将光能转化成化学能，并将能量贮存在分子键中，从化学和动能学角度来看，它是细胞呼吸作用的对立面。细胞呼吸作用是高度放能的，光合作用是需要能量并高吸能的过程。</p></blockquote><p>Photosynthesis starts with CO2 and H2O as raw materials and proceeds through two sets of partial reactions.  In the first set, called the light-dependent reactions, water molecules are split裂开 (oxidized), 02 is released, and ATP and NADPH are formed.  These reactions must take place in the presence of 在面前 light energy.  In the second set, called light-independent reactions, CO2 is reduced (via the addition of H atoms) to carbohydrate.  These chemical events rely on the electron carrier NADPH and ATP generated by the first set of reactions.</p><blockquote><p>光合作用以二氧化碳和水为原材料并经历两步化学反应。第一步，称光反应，水分子分解，氧分子释放，ATP和NADPH形成。此反应需要光能的存在。第二步，称暗反应，二氧化碳被还原成碳水化合物，这步反应依赖电子载体NADPH以及第一步反应产生的ATP。</p></blockquote><p>Both sets of reactions take place in chloroplasts.  Most of the enzymes and pigments 色素for the lightdependent reactions are embedded 深入的内含的in the thylakoid类囊体 membrane膜隔膜 of chloroplasts 叶绿体.  The dark reactions take place in the stroma.基质</p><blockquote><p>两步反应都发生在叶绿体中。光反应需要的大部分酶和色素包埋在叶绿体的类囊体膜上。暗反应发生在基质中。</p></blockquote><ol><li><p>How Light Energy Reaches Photosynthetic Cells（光合细胞如何吸收光能的）</p><p>The energy in light photons in the visible part of the spectrum can be captured by biological molecules to do constructive work.  The pigment chlorophyll in plant cells absorbs photons within a particular absorption spectrums statement of the amount of light absorbed by chlorophyll at different wavelengths.  When light is absorbed it alters the arrangement of electrons in the absorbing molecule.  The added energy of the photon boosts the energy condition of the molecule from a stable state to a less-stable excited state.  During the light-dependent reactions of photosynthesis, as the absorbing molecule returns to the ground state, the “excess” excitation energy is transmitted to other molecules and stored as chemical energy.</p><blockquote><p>生物分子能捕获可见光谱中的光能。植物细胞中叶绿素在不同光波下吸收部分吸收光谱。在吸收分子中，光的作用使分子中的电子发生重排。光子的能量激活了分子的能量状态，使其从稳定态进入不稳定的激活态。</p></blockquote><p>All photosynthetic organisms contain various classes of chlorophylls and one or more carotenoid (accessory) pigments that also contribute to photosynthesis.  Groups of pigment molecules called antenna complexes are present on thylakoids.  Light striking any one of the pigment molecules is funneled to a special chlorophyll a molecule, termed a reaction-center chlorophyll, which directly participates in photosynthesis.  Most photosynthetic organisms possess two types of reaction-center chlorophylls, P680 and P700, each associated with an electron acceptor molecule and an electron donor.  These aggregations are known respectively as photosystem Ⅰ (P700) and photosystem Ⅱ (P680).</p><blockquote><p>所有的光合作用生物含有不同等级的叶绿素和一个或多个类胡萝卜素（光合作用的辅助色素）。称作天线复合体的色素分子群存在于类囊体中。激活色素分子的光能进入叶绿素反应中心，其直接参与光合作用。大部分光反应细胞器拥有两套反应中心，P680和P700，每个光系统都含有一个电子受体和电子供体。这些集合体就是大家熟识的光合系统Ⅰ和光合系统Ⅱ。</p></blockquote></li><li><p>The Light-Dependent Reaction: Converting Solar Energy into Chemical-Bond Energy（光反应：光能转化成化学键能）</p><p>The photosystems of the light-dependent reactions are responsible for the packaging of light energy in the chemical compounds ATP and NADPH.  This packaging takes place through a series of oxidation reduction reactions set in motion when light strikes the P680 reaction center in photosystem Ⅱ.  In this initial event water molecules are cleaved, oxygen is released, and electrons are donated.  These electrons are accepted first by plastoquinone and then by a series of carriers as they descend an electron transport chain.  For each four electrons that pass down the chain, two ATPs are formed. The last acceptor in the chain is the P700 reaction center of photosystem Ⅰ. At this point incoming photons boost the energy of the electrons, and they are accepted by ferredoxin.  Ferredoxin is then reoxidized, and the coenzyme NADP+ is reduced to the NADPH.  The ATP generated previously and the NADPH then take part in the light independent reactions.</p><blockquote><p>光反应的光系统将光能转化成化学复合物ATP和NADPH。当光激活光系统Ⅱ的光反应中心时，通过一系列的氧化还原反应实现能量的传递。反应开始时，水被分解，氧被释放并提供电子。电子首先传递给质体醌，然后通过一系列载体形成的电子传递链。每传递4个电子，形成2个ATP。最后一个受体存在于光反应系统Ⅰ的反应中心里。此处光子激活电子，电子传递给铁氧还蛋白。铁氧还蛋白再氧化，并且辅酶NADP+还原成NADPH。早期产生的ATP和NADPH进入暗反应。</p></blockquote><p>The production of ATP from the transport of electrons excited by light energy down an electron transport chain is termed photophosphorylation.  The one-way flow of electrons through photosystems II and I is called noncyclic photophosphorylation; plants also derive additional ATP through cyclic photophosphorylation, in which some electrons are shunted back through the electron transport chain between photosystems Ⅱ and Ⅰ.</p><blockquote><p>由电子传递链偶连产生ATP的过程称为光合磷酸化。通过光合系统Ⅱ流经光合系统Ⅰ的电子路径称非循环式光合磷酸化；植物通过循环式光合磷酸化获得额外的ATP，一些电子在光合系统Ⅰ和Ⅱ之间的电子传递链中回流。</p></blockquote></li><li><p>The Light-Independent Reactions: Building Carbohydrates（暗反应：碳水化合物的形成）</p><p>In the light-independent reactions of photosynthesis, which are driven by ATP and NADPH, C02 is converted to carbohydrate.  The reactions are also known as the Calvin-Benson cycle.  Atmospheric CO2, is fixed as it reacts with ribulosebiphosphate (RuBP), a reaction that is catalyzed by the enzyme ribulosebiphosphate carboxylase. The reduction Of C02 to carbohydrate (fructose diphosphate) is completed via several more steps of the cycle.  Finally, RUBP is regenerated so that the cycle may continue.</p><blockquote><p>由ATP和NADPH驱动的暗反应中，二氧化碳转化成碳水化合物。即卡尔文循环。二磷酸核酮糖固定二氧化碳，由二磷酸核酮糖羧化酶催化。</p></blockquote></li><li><p>Oxygen: An Inhibitor of photosynthesis（氧：光合作用的抑制因子）</p><p>High levels of oxygen in plant cells can disrupt photosynthesis and can also cause photorespiration-an inefficient fun of the dark reactions in which O<sub>2</sub> is fixed rather than CO<sub>2</sub> and no carbohydrate is produced.</p><blockquote><p>植物细胞中高浓度的氧会扰乱光合作用，并导致光呼吸——暗反应的无效形式，在反应中消耗的是O<sub>2</sub>，而不是CO<sub>2</sub>，且没有有机物产生。</p></blockquote></li><li><p>Reprieve from Photorespiration: The C4 Pathway（避开光呼吸：C4循环途径）<br>Most plants are C3 plants; they experience decreased carbohydrate production under hot, dry conditions as a result of the effects of photorespiration.  Among C4 plants, however, special leaf anatomy and a unique biochemical pathway enable the plant to thrive in and conditions.  Thus C4 plants lessen photorespiration by carrying out photosynthesis only in cells that are insulated from high levels of CO2.  They also possess a novel mechanism for carbon fixation.</p><blockquote><p>大部分植物是碳3植物，在高温干旱条件下，由于光呼吸作用而使碳水化合物的合成降低。而在大多数的碳4植物中，由于叶脉的特殊构造和独特的化学路径使植物依然很茂盛。这是碳固定的一个新机制。</p></blockquote></li></ol><h2 id="第三章-Cellular-Reproduction-Mitosis-and-Meiosis"><a class="header-anchor" href="#第三章-Cellular-Reproduction-Mitosis-and-Meiosis"></a>第三章 Cellular Reproduction:  Mitosis and Meiosis</h2><ol><li><p>The Nucleus and Chromosomes（细胞核和染色体）<br>The cell nucleus is the main repository of genetic information.  Within the nucleus are the chromosomes tightly coiled strands of DNA and clusters of associated proteins.  Long stretches of the continuous DNA molecule wind around these clusters of proteins, or histones, forming beadlike complexes known as nucleosomes. More coiling and supercoiling produces a dense chromosome structure. Each long strand of DNA combines with histones and nonhistone proteins to make up the substance chromatin.</p><blockquote><p>细胞核是贮藏遗传信息的主要场所。DNA盘绕成螺旋线以及相关的成簇蛋白质。DNA螺旋线缠绕成簇的组蛋白形成珠链状的核小体。这些螺旋和超螺旋形成致密的染色体组结构。每个长链DNA与组蛋白和非组蛋白一起构成染色质物质。</p></blockquote><p>A pictorial display of an organism’s chromosomes in the coiled, condensed state is known as a karyotype.  Karyotype reveal that in most cells all but sex chromosomes are present as two copies, referred to as homologous pairs.  Non-sex chromosomes are called autosomes.  Organisms whose cells contain two sets of parental chromosomes are called diploid; those with cells containing a single set of parental chromosomes are called haploid.</p><blockquote><p>染色体致密的超螺旋状态我们称染色体组。除了性染色体外，大多数细胞的染色体组成对出现，称同源染色体对。非性染色体称常染色体。生物细胞含有两套父母本染色体的称二倍体；含有单套染色体的称单倍体。</p></blockquote></li><li><p>The Cell Cycle（细胞循环）<br>The cell cycle is a regular sequence in which the cell grows, prepares for division, and divides to form two daughter cells, each of which then repeats the cycle.  Such cycling in effect makes single-celled organisms immortal.  Many cells in multicellular organisms, including animal muscle and nerve cells, either slow the cycle or break out of it altogether.</p><blockquote><p>在细胞生长过程中，细胞循环遵循特定程序，分裂准备，分裂成2个子细胞，子细胞再循环。此循环使得单细胞永生。多细胞生物中的许多细胞，包括动物肌肉和神经细胞，要么降低循环速度，要么同时分裂。</p></blockquote><p>The normal cell cycle consists of four phases.  The first three include G1, the period of normal metabolism; S phase, during which normal synthesis of biological molecules continues, DNA is replicated, and histones are synthesized; and G2, a brief period of metabolism and additional growth.  Together the G1, S, and G2 phases are called interphase.  The fourth phase of the cell cycle is M phase, the period of mitosis, during which the replicated chromosomes condense and move and the cell divides.  It is believed that properties of the cell cytoplasm control the cell cycle, along with external stimulators and inhibitors such as chalones.</p><blockquote><p>正常细胞循环由4个时期组成。头三期包括G1,正常新陈代谢；S期,正常新陈代谢同时，DNA复制，组蛋白合成； G2 期，短期的新陈代谢和少许生长。G1, S, 和G2称分裂间期。最后是M期，有丝分裂期，复制的染色体组浓缩，移动并细胞分裂。据称是染色质控制了细胞循环，伴随外部激活因子和抑制因子如抑素。</p></blockquote></li><li><p>Mitosis: Partitioning the Hereditary Material（有丝分裂：遗传物质的分割）</p><p>Biologists divide the mitotic cycle into four phases.  At the beginning of prophase 前期 the chromosomes each consist of two highly condensed chromatids attached to each other at a centromere.  As prophase ends and metaphase 中期 begins, the condensed 浓缩的 chromosomes become associated with the spindle 纺锤体.  Eventually the chromosomes become arranged in a plane (called the metaphase plate) at a right angle to the spindle fibers.  Next, during anaphase 后期, the two  sister chromatids of each chromosome split, and one from each pair is drawn toward each pole of the cell.  During telophase末期 nuclear envelopes 包膜 begin to form around each set of chromosomes, and division of the cytoplasm takes place.</p><blockquote><p>生物学家将有丝分裂划分为4个阶段。分裂前期，高度浓缩的两个染色单体通过着丝粒连接在一起。在分裂前期后期和分裂中期前期，浓缩的染色体与纺锤体相连，最后以正确的角度排列在赤道板上。在分裂后期，两个姊妹单体分离，分别拽向细胞两极。在分裂末期，在每套染色体周围形成核膜，细胞质发生分裂。</p></blockquote><p>As mitosis proceeds, the spindle microtubules play a crucial role in ensuring that both paired and separated chromatids  染色单体 move in the right directions at the proper times.  Each half of the spindle forms as microtubules extend from each pole of a dividing cell to the region of the metaphase plate.  During prophase, other microtubules, the centromeric着丝粒fibers, extend outward from the spindle poles to structures on the chromosomes called kinetochores着丝粒.  During anaphase the fibers begin to shorten, and the chromatids begin to move apart.</p><blockquote><p>在有丝分裂过程中，是纺锤体微管确保了染色单体在适当时间以正确方向进行分离。纺锤体微管由两极向赤道板延伸。在分裂前期，其它微管，着丝粒纤维延伸到染色体的动粒。在分裂后期，纤维开始变短，染色单体分离。</p></blockquote><p>The spindle forms differently in plant and animal cells.  In animals it is associated with centriole 中心粒, while in plant and fungal 真菌 cells spindle formation is associated with reions called microtubule organizing centers.</p><blockquote><p>植物和动物细胞形成的纺锤体不同。动物细胞与中心粒相连，而在植物和真菌细胞中，纺锤体与微管组织中心的离子相连。</p></blockquote></li><li><p>Cytokinesis: Partitioning the Cytoplasm（胞质分裂：细胞质分离）</p><p>The division of the cell cytoplasm at the end of mitosis is called cytokinesis 细胞浆移动.  In animal cells it takes place as a ring of actin filaments contracts使缩短合同契约 around the cell equator赤道, pinching收聚 the cell in two.  In plant cells, which are bounded 有限制的 by a cell wall, cytokinesis involves the building of a new cell plate across the dividing cell at its equator.  Cell wall material is then deposited 存放堆积 in the region of the cell plate.</p><blockquote><p>在动物细胞中，环形肌动蛋白丝延赤道板收缩而使细胞一分为二。在植物细胞中，在赤道板形成新的细胞板。</p></blockquote></li><li><p>Meiosis: The Basis of Sexual Reproduction（减数分裂：有性生殖的基础）<br>Meiosis 减数 is a special form of cell division that takes place in the reproductive 生殖 organs that produce sex cells.  Like mitosis, it takes place after DNA replication has occurred and involves two sequential 连续的 nuclear divisions (meiosis I and meiosis Ⅱ).  These divisions result in four daughter cells, each with half the number of chromosomes of the parent cell.  The phenomenon of crossing over during meiosis results in exchanges of genetic information between chromosomes.  Hence因此, the homologous 同源的 chromosomes distributed 分布 to different progeny 后裔 cells are not identical同样的.</p><blockquote><p>减数分裂是性细胞分裂的特殊形式。如有丝分裂，它也是发生在DNA复制后并有连续的两个核分裂。产生4个子细胞，分别含有亲本一半的染色体数。</p></blockquote><p>As in mitosis two chromatids exist for each chromosome at the beginning of prophase 1. During this phase the homologous 同源 chromosomes undergo 经历sy-napsis联会 , or pairing, which is brought about by a bridging structure of proteins and RNA called the synaptonemal联会丝的 complex.  The homologous pairs stay together when they align 排列 on the metaphase 中 plate.  Unlike the anaphase of mitosis, however, during anaphase I the two chromatids of each chromosome stay joined at the centromere着丝点 and move together to one of the two poles of the cell.  It is this event that results in the halving 减半的 of the chromosome number in the four daughter cells that result from meiosis.</p><blockquote><p>正如在有丝分裂中一样，两个同源染色单体通过蛋白质和RNA桥配对形成联会复合体。与有丝分裂不同的是，每组染色体的两个染色单体连接在着丝点上并一起移向细胞两极的一级。由此而导致4个子细胞染色体数减半。</p></blockquote><p>During telophase末期 I nuclear envelopes enclose the chromosomes in nuclei, and in most species cytokinesis 细胞浆流动 (the first nuclear division) follows.  The second nuclear division begins with metaphase Ⅱ, in which the chromosomes in each daughter cell again align 排列on a metaphase plate.  The centromeres着丝粒 finally divide, and each sister chromatid moves to one of the poles of the spindle.  The next phase is telophase , followed again by cytokinesis.  The result of the entire process is four haploid cells in which parental chromosomes are randomly distributed.</p><blockquote><p>第二次核分裂开始于分裂中期，子细胞中染色体重新排列在赤道板上。着丝粒最终分离，每个姊妹染色单体分向两极。接着胞质分裂。产生4个单倍体，父母染色体随机分配。</p></blockquote></li><li><p>Asexual Versus Sexual Reproduction（无性生殖与有性生殖）</p><p>Mitosis and meiosis, respectively分别, make simple cell division and sexual reproduction possible.  Each means of passing on hereditary 遗传 information has advantages.  In asexual  无性的 reproduction the parent organism生物体 gives rise to offspring 后代that are genetic clones of the parent.  The advantages of this type of reproduction are that it preserves the parent’s successful genetic complement 遗传互补, requires little or no specialization of reproductive organs, and is more rapid than sexual reproduction.  A major disadvantage of the asexual mode is that a single catastrophic灾难的 event or disease may destroy an entire population of genetically identical organisms.  A prime benefit of sexual reproduction is that it provides genetic variability and a ready mechanism机制 for the elimination of deleterious mutations.  It also allows “new” gene forms to arise and spread through populations.</p><blockquote><p>有丝分裂和减数分裂在传递遗传信息过程中各有优势。体细胞的繁殖就是父母本的克隆，其优势是保留了父母本的成功遗传信息，不需要特殊器官，比性复制快的多。但一个简单灾难性事件或疾病都可能摧毁一个细胞群体。性复制的优势是它提供了遗传可变性和现存排除有害突变的机制。也可以产生新的基因并在种群中蔓延。</p></blockquote></li></ol><h2 id="第四章-Foundations-of-Genetics"><a class="header-anchor" href="#第四章-Foundations-of-Genetics"></a>第四章 Foundations of Genetics</h2><ol><li><p>Early Theories of inheritanee（早期遗传理论）</p><p>Early ideas of inheritance included Hippocrates’ theory of pangenesis and August Weismands germ plasm theory.  Based on experiments with mice, Weismann proposed that hereditary information in gametes transmitted traits to progeny.  Both of these early views incorporated the blending theory: they held that heritable traits of the two parents blend, so that the distinct characteristics of each are lost in offspring.</p><blockquote><p>遗传学的早期理论包括泛生说和种质理论。基于小鼠实验，维丝曼提出遗传信息储存在配子中并将遗传信息传递给后代。这两个早期观点合起来形成融合理论：子代拥有父母本混合的遗传特征，而不完全象亲代。</p></blockquote></li><li><p>Gregor Mendel and the Birth of Genetics  Gregor Mendel（和遗传学的诞生）</p><p>Gregor Mendel, an Augustinian monk in the monastery at Brunn, Austria, is known as the “father of genetics.” Having been exposed to theories of the particulate nature of matter while a university student and having a background in mathematics, Mendel carried out a series of carefully planned experiments that demonstrated the particulate nature of heredity.  His revolutionary ideas were neither understood nor accepted until many years after Mendel died.</p><blockquote><p>孟德尔，众所周知的遗传学之父，是一名修道士。当他还是大学生时就提出了物质的粒子属性。孟德尔进行了一系列周密安排的实验来证实遗传的颗粒性。直到他去世后，他的理论才被理解和接受。</p></blockquote></li><li><p>Mendel’s Classic Experiments   （Mendel的经典实验）</p><p>Mendel studied genetics through plant-breeding experiments with the garden pea, a plant species that is self-fertilizing and breeds true (each offspring is identical to the parent in the trait of interest).  To test the blending theory, he focused his research on seven distinct characters.  Each of these characters, such as seed color and plant height, present only two, clear-cut possibilities.  He also recorded the type and number of all progeny produced from each pair of parent pea plants, and followed the results of each cross for two generations.</p><blockquote><p>孟德尔通过豌豆实验研究遗传学，豌豆是自花授粉植物和纯品系。为验证融合理论，他的研究主要集中在7个特征上。例如，种子颜色，植株高度，这些特征只有两个明确的可能性。他记录了产生的每一个子代类型和数量，在杂交产生子2代。</p></blockquote><p>For each of the characters he studied, Mendel found that one trait was dominant while the other was recessive. In the second filial (F2) generation, the ratio of dominant to recessive was 3:1. Mendel deduced that this result was possible only if each individual possesses only two hereditary units, one from each parent. The units Mendel hypothesized are today known as alleles, alternative forms of genes. Genes are the basic units of heredity. An organism that inherits identical alleles for a trait from each parent is said to be homozygous for that trait; if different alleles for a trait are inherited, the organism is heterozygous for that trait.</p><blockquote><p>对于每个特征而言，要么显形，要么隐性。在子2代中显形与隐性比为3∶1。只有在每个个体仅拥有两个研究遗传单元，并每个单元来自一个亲代时，实验结果才成立。此遗传单元就是今天共识的等位基因。两个一样的等位基因决定一个特征，称纯合。相反，称杂合。</p></blockquote><p>When an organism is heterozygous for a trait, the resulting phenotype for that trait expresses only the dominant allele.Thus, the organism’s phenotype—its physical appearance and properties-differs from its genotype, which may include both a dominant and a recessive allele.  A pictorial representation of all possible combinations of a genetic cross is known as a Punnett square.</p><blockquote><p>当生物是杂合时，它的表型由显性基因决定。因此，生物的表型与基因型是不同的。旁纳特方格可以陈列所有可能的遗传组合。</p></blockquote><p>The results of Mendel’s experiments on dominant and recessive inheritance let to Mendel’s first law: the law of segregation.This law states that for a given trait an organism inherits one allele from each parent.  Together these alleles form the allele pair. When gametes are formed during meiosis, the two alleles become separated (halving of chromosome number).To gain evidence for his theory Mendel performed test crosses, mating plants of unknown genotype to plants that were homozygous recessive for the trait of interest.  The ratio of dominant phenotypes (if any) in the progeny makes clear whether the unknown genotype is heterozygous, homozygous dominant, or homozygous recessive.</p><blockquote><p>分离定律，生物只遗传父母本等位基因对的一个等位基因。减数分裂期形成配子时两个等位基因分离。为验证此理论，他做了测交实验，即基因型未知的植物与纯合的隐性基因植物杂交。子代显性表型可以明确测得杂合基因或纯合基因的基因型。</p></blockquote></li><li><p>Mendel’s Ideas and the Law of independent Assortment  （Mendel的想法和独立分配定律）</p><p>Mendel also performed dihybrid crosses, which enabled him to consider how two traits are inherited relative to one another.  This work let to the law of independent assortment, which states that the alleles of genes governing different characters are inherited independently.  An apparent exception to Mendel’s laws is incomplete dominance, a phenomenon in which offspring of a cross exhibit a phenotype that is intermediate between those of the parents.  However, incomplete dominance reflects the fact that both alleles for the trait in question exert an effect on the phenotype.  The alleles themselves remain separate.</p><blockquote><p>双因子杂合试验，两个特征是如何相互影响遗传的。试验结果产生独自分配定律，即等位基因独立遗传。特例是，不完全显性。子代的表型是父母本的中间类型。不完全显性说明了两个等位基因对表型都有影响。，等位基因会继续分离。</p></blockquote><p>Mendel presented his ideas in 1866 in a scientific paper published by the Brunn Society for Natural History.  Unfortunately, the meaning of his research was not understood by other scientists of the day.  His work was rediscovered in 1900 by Carl Correns and Hugo de Vries.</p><blockquote><p>1866年，孟德尔在自然史上发表了他的科学论文，陈诉了他的观点。不幸的是，他的研究不被当时科学家接受。在1900年，他的著作再被发现利用。</p></blockquote></li><li><p>Chromosomes and Mendelian Genetics（染色体和孟德尔遗传定律）</p><p>Soon after Mendel’s work was rediscovered, Walter Sutton and Theodor Boveri independently proposed that the hereditary units might be located on chromosomes.  Experiments to prove this hypothesis were carried out by Thomas Hunt Morgan and his students at Columbia University, in research on the sex chromosomes of fruit flies.  Morgan’s studies were also the first exploration of sex-linked traits.  It also led to the discovery in 1916 by Calvin Bridges of the phenomenon of nondisjunction, in which a chromosome pair fails to segregate during meiosis.</p><blockquote><p>孟德尔著作被再发现不久，Walter Sutton 和Theodor Boveri提出，遗传单位可能定位在染色体组上。伴性遗传又导致了不分离现象的发现，即在减数分裂中，染色体对不分离。</p></blockquote></li></ol><h2 id="第五章-Discovering-the-Chemical-Nature-of-the-Gene"><a class="header-anchor" href="#第五章-Discovering-the-Chemical-Nature-of-the-Gene"></a>第五章 Discovering the Chemical Nature of the Gene</h2><ol><li><p>Genes Code for Particular Proteins（特定蛋白质的基因编码）</p><p>The first scientist to investigate the question of how genes affect phenotype was Sir Archibald Garrod, whose studies of alkaptonuria implied a relationship between genes and enzymes.  Thirty years later Beadle and Ephrussi showed a relationship between particular genes and biosynthetic reactions responsible for eye color in fruit flies. Next, in a series of classic experiments on the effects of mutations in the bread mold Neurosporacrassa, Beadle and Tatum explored the one-gene-one-enzyme hypothesis-the idea that each gene codes for a particular enzyme.  Their work paved the way for other researchers to elucidate the precise ways in which enzymes affect complex metabolic <a href="http://pathways.In">pathways.In</a> 1949, in research on the role of hemoglobin in sickle cell anemia, Linus Pauling helped refine the one-gene-one-enzyme hypothesis into the one-gene-one-polypeptide hypothesis.</p><blockquote><p>Archibald Garrod是第一个研究基因是如何影响表型的科学家，他对尿黑酸症的研究揭示了基因与酶之间的关系。Beadle 和Ephrussi在三十年后对果蝇眼睛颜色的研究发现特殊基因与相关反应的生物合成有关。接着对面包发霉粗糙脉孢菌的突变试验得出一个基因一个酶的假说。他们的工作为其他工作者铺平了道路，即精确地阐明了酶影响了复杂的新陈代谢途径。在1949年，对镰刀状细胞贫血症的研究对一个基因一个酶的假说进一步上升为一个基因一个多肽。</p></blockquote></li><li><p>The Search for the Chemistry and Molecular Structure of nucleic Acids（核酸的化学和分子结构的研究）</p><p>Nuclei acid, originally isolated by Johann Miescher in 1871, was identified as a prime constituent of chromosomes through the use of the red-staining method developed by Feulgen in the early 1900s.  Frederick Griffith’s experiments with the R and S stains of pneumococci showed that an as yet unknown material from one set of bacterial could alter the physical traits of a second set.  In the 1940s the team of Avery, MacLeod, and McCarty showed that this unknown material was DNA.  At about the same time P.A. Levene discovered that DNA contained four nitrogenous bases, each of which was attached to a sugar molecule and a phosphate group-a combination Levene termed a nucleotide.</p><blockquote><p>在1871年，核酸最初是由Johann Miescher分离成功，并由Feulgen在1900年证实核酸是染色体组最基本的组成。Frederick Griffith对粗糙和光滑的肺炎球菌实验表明，不确定的某种物质可以从一组细菌转移到另一种细菌中。在1940年，确认该物质为DNA。四个碱基和磷酸分子分别连接在糖分子上，称核苷酸。</p></blockquote><p>Disagreement over whether DNA could carry complex genetic information was ended in the early 1950s by Martha Chase and Alfred Hershey, whose work with E. coli showed clearly that DNA, and not protein, is the bearer of genetic information.</p><blockquote><p>直到1950年，通过对大肠杆菌实验发现，遗传物质是DNA，而不是蛋白质。</p></blockquote><p>Each DNA nucleotide contains a five-carbon sugar, deoxyribose, attached to one of four bases: adenine, guanine, cytosine, or thymine.  Adenine and guanine molecules are double-ring structures called purines, while cytosine and thymine are single-ring structures called pyrimidines.  The molecule made up of a base plus a sugar is termed a nucleoside.  In each molecule of DNA a phosphate group links the five-carbon sugar of one nucleoside to the five-carbon sugar of the next nucleoside in the chain.  This phosphate bonding creates a sugar-phosphate backbone.</p><blockquote><p>每个核苷酸都含有一个五碳脱氧核糖，分别连接4个碱基，即：腺嘌呤，鸟嘌呤，胞嘧啶，胸腺嘧啶。碱基连接糖称核苷。磷酸键形成磷酸骨架。</p></blockquote><p>Chargaff’s rules describe the fact that (1) the amount of adenine is equal to the amount of thymine in DNA, with amount of cytosine equal to that of guanine, and (2) the ratios of A to T and of C to G vary with different species.</p><blockquote><p>（1）腺嘌呤与胸腺嘧啶，胞嘧啶与鸟嘌呤相等；（2）腺嘌呤与胸腺嘧啶，胞嘧啶与鸟嘌呤的比例随物种不同而不同。</p></blockquote></li><li><p>The Research Race for the Molecular Structure of  DNA  (DNA分子结构的研究实验 )</p><p>In the late 1940s and early 1950s, researchers looking for the structure of DNA drew upon Chargaff s insight, Levene’s ideas on DNA components, and two other lines of evidence.  One was the suggestion of Linus Pauling that DNA might have a helical structure held in place by hydrogen bonds, and the other was X-ray diffraction photos of DNA, showing a helical structure with distance between the coils, taken by Franklin and Wilkins.</p><blockquote><p>直到40年代末50年代初，研究者在寻求DNA结构过程中，确立了Chargaff 的观点和, Levene的组成理论以及其他两个线索。一个是Linus Pauling的假设，DNA可能具有螺旋结构，通过氢键连接。另一个是X-衍射图片，Franklin and Wilkins提供。</p></blockquote><p>Based on this information Watson and Crick proposed the double helix model of DNA-A twisted ladder-like molecule with two outer sugar phosphate chains and rungs formed by nucleotide pairs.  Paired nucleotides, which always occur as A-T or G-C, are linked by hydrogen bonds.  Watson and Crick also proposed that genetic information is encoded by the sequence of base pairs along the DNA molecule.</p><blockquote><p>基于这些信息，Watson 和 Crick提出了双螺旋结构模型，成对的核苷酸通过氢键相连，遗传信息就贮藏在碱基对中。</p></blockquote></li><li><p>How DNA Replicates  (DNA如何复制)</p><p>In their model of DNA structure and function, Watson and Crick hypothesized that DNA replicates itself by “unzipping” along the hydrogen bonds joining A to T and C to G. This process would produce two opposite halves that could then serve as templates for the construction of new, complementary strands.  This model of semiconservative replication conservative because each new molecule has one half of the former parent molecule-was later confirmed by the work of</p><blockquote><p>DNA进行复制是以拉链方式自我复制，产生的两个二分体分别为模板生成互补链，即半保留复制。并由Meselson和 Stahl验证。</p></blockquote><p>In E. coli DNA replication begins with the formation of a bubblelike structure on the circular chromosome that is produced by replication forks.  Studies of bacterial DNA replication have shown that a growing DNA chain lengthens only in the 5’ to 3’ direction (from the 5’ carbon of one sugar to the 3’ carbon of the next).  The leading strand is synthesized continuously, while the lagging strand is synthesized in short stretches known as Okazaki fragments.  The enzyme DNA polymerase links free nucleotides as they line up on the template formed by the original strand of the parent molecule.<br>In eukaryotes DNA replication follows the same general principles as in prokarotes. On the long DNA molecules replication proceeds (in two directions at once) from hundreds or thousands of points of origin.</p><blockquote><p>大肠杆菌复制开始时形成泡样复制叉，链生长方向由5′向3′端，前导链连续生成，后随链由冈崎片段组成，由DNA聚合酶催化。真核生物复制与原核生物复制相似，但有几百到几千个复制原点（原核一般只有一个复制原点）。</p></blockquote></li></ol><h2 id="第八章-Animal-Development"><a class="header-anchor" href="#第八章-Animal-Development"></a>第八章 Animal Development</h2><ol><li><p>Production of Sperm and Eggs（精子和卵子的产生）</p><p>In sexually reproducing organisms males and females produce sex cells, known as gametes.  These are swimming sperm in males and ova (eggs) in females.</p><blockquote><p>在性繁殖过程中，生物的雄性和雌性产生性细胞，称配子。雄性是能够游动的精子，雌性是卵子。</p></blockquote><p>The process of sperm production, spermatogenesis, takes place in testes.  The sperm originate in gonial cells (spermatogonia) in the walls of seminiferous tubules.  Spermatocytes produced by mitosis in spermatogonia divide meiotically to generate haploid spermatids.  The mature sperm has a tail, a nucleus containing haploid chromosomes, and a front end with an acrosome, the storage site for enzymes that will aid fertilization.</p><blockquote><p>精子产生过程，即精子发生在睾丸中。精子产生于输精管壁的性母细胞（精原细胞）。精原细胞经有丝分裂再减数分裂产生单倍体精子细胞，即精母细胞。成熟精子有尾部，单倍体染色体组，头部有顶体，内部储存酶类，有助于受精。</p></blockquote><p>Ova, which are produced during oogenesis, are generated in gonial cells (oogonia) of the female’s ovaries.  Oocytes then enter a stage of arrest in early meiosis.  At a species-specific later point, a final ripening (ovulation) and the first meiotic division occur.  A second meiotic division, followed by development of the embryo, takes place if the egg is fertilized.</p><blockquote><p>在卵子发生过程中，由卵巢中的性母细胞产生。卵母细胞进入减数分裂的抑制阶段。第一次减数分裂产生一个成熟卵。如果卵受精，那么第二次减数分裂伴随胚胎的发育。</p></blockquote><p>Eggs vary greatly in size from species to species and have complex structures.  Virtually all developing animal ova are surrounded by helper cells, either follicle cells or nurse cells.  Depending on the species, eggs also store varying amounts of yolk, a reservoir of nutrients produced by digestive-gland cells in the mother’s body.  Finally, follicle cells or cells of the maternal oviduct provide protective coatings for the egg, including albumen (egg white) and various types of outer membranes and shells.</p><blockquote><p>品种间卵的大小变化很大，并且有复杂的结构。实际上，所有发育过程中的卵都辅助细胞环绕，要么是滤泡细胞，要么是抚育细胞。依赖物种的不同而不同，卵黄贮备也不同，即由母体消化腺细胞产生的营养储备。最后，滤泡或母体输卵管细胞产生保护性的卵膜，包括清蛋白和各种外部膜及壳。</p></blockquote><p>Frog oocytes have served as model systems for studies of oocyte development.  During maturation they produce huge numbers of ribosomes through gene amplification.  Large quantities of mRNA may also be made and stored.</p><blockquote><p>蛙卵母细胞作为卵母细胞发育的研究系统模型。在成熟过程中，通过基因扩增产生大量的核糖体。同时也产生和储备了大量的mRNA。</p></blockquote></li><li><p>Fertilization: Initiating Development（受精：启动发育）</p><p>Fertilization unites male and female gametes and initiates development.  In some species fertilization is external; in others (including most terrestrial animals) it takes place internally.  The first contact of the sperm head with the egg’s jelly coat triggers the acrosome reaction, in which enzymes are released to digest a hole through the egg’s protective layers, and the plasma membrane of the sperm is brought into position to bind to the ovum’s surface.  After fusion of the egg and sperm plasma membranes, the haploid male nucleus with its chromosomes moves into the egg cytoplasm.  Fusion also triggers the egg’s final meiotic reduction divisions.  When sperm and egg nuclei unite, the two sets of chromosomes mingle to create a diploid set.  The fertilized egg is now a zygote.</p><blockquote><p>雌雄配子结合作用称受精作用，发育开始。某些物种中，是外部受孕；另一些物种，包括大部分陆生动物，是内部受孕。当精子和卵子的胶状膜发生接触时，触发了顶体反应。释放多种酶而将卵保护膜消化出一个洞。精子的原生质膜与卵子的表面连接起来。精卵原生质膜融合后，单倍体雄性核进入卵细胞质。融合也触发了最后的减数分裂。当精卵核结合时，两套染色体混合产生一二倍体，即受精卵。</p></blockquote><p>The egg’s cortical reaction serves as a barrier to the entry of more than one sperm.  Initially, there is a temporary change in the egg’s electrical state, and the egg cell is activated.  The final stage of the reaction, the rapid elevation of the fertilization membrane, prevents further sperm penetration.</p><blockquote><p>卵皮层阻止其他的精子进入，充当壁垒作用。开始时，卵电位发生暂时变化，卵细胞被激活。反应最后阶段，受精卵的膜快速隆起，阻止更多精子进入。</p></blockquote><p>In some species fertilization is not necessary.  Instead, parthenogenesis takes place: the egg is spontaneously activated and proceeds to normal embryonic development.</p><blockquote><p>对某些物种而言，受精不是必须的。孤雌生殖，即卵自发地被激活并进入正常的胚胎发育过程中。</p></blockquote></li><li><p>Cleavage: An Increase in Cell Number（分裂：细胞数量的增加）</p><p>Cleavage, the major developmental event immediately following fertilization, is a special form of cell division (mitosis).  Cleavage produces a blastula, a sheet of cells rounded into a sphere that in most species surrounds a cavity.  In the process, the single-celled zygote is divided into many small cells, and yolk, mRNA, ribosomes, and other materials arc distributed to each cell in precise ways.  The cells of the blastula, called blastomeres, also each receive a full diploid set of chromosomes.</p><blockquote><p>受精后，立即发生卵裂，细胞有丝分裂的特殊过程。卵裂产生一个囊胚，形成的细胞壁球形排列形成一个空腔。在这个过程中，单细胞的受精卵分裂成许多小细胞，卵黄，mRNA，核糖体和其他物质被精确分配到每个细胞中。这些囊胚细胞，称卵裂球，每个细胞都有一套二倍体染色体组。</p></blockquote><p>There are different patterns of cleavage in different species.  The amount of yolk present in the egg is a major factor in determining the pattern: in species having little yolk (such as mammals) the zygote cleaves completely through, forming cells that are roughly equivalent in size.  In frogs, in which the egg has somewhat more yolk, cleavage proceeds more rapidly in regions of the embryo having less yolk.  In bird eggs the yolk is so massive that cleavage divisions are restricted to a tiny area of cytoplasm.</p><blockquote><p>不同物种，卵裂方式不同。决定因素主要取决于卵黄的含量。含有少量卵黄的物种（例如哺乳动物），合子分裂得很彻底，子细胞大致平均分裂。蛙卵，卵黄稍微多点，在胚胎的卵黄较少区域发育更快些。鸟卵卵黄很大，卵裂被限制在细胞质很小区域内。</p></blockquote><p>In many species the precise distribution to blastomeres of molecular determinants in the cytoplasm is crucial to proper development of different cell types in the embryo.  In mammal and bird species the fate of cells is determined by the position of a cell late in cleavage.</p><blockquote><p>细胞质中分子遗传因素精确分配到卵裂球中，对许多物种而言，是发育成胚中不同类型细胞关键所在。对哺乳动物和鸟类而言，细胞的命运最终由细胞分裂后所处的位置决定的。</p></blockquote></li><li><p>Gastrulation: Rearrangement of Cells（原肠胚：细胞重排列）</p><p>The rearrangement of the blastula into a three-dimensional organism with inner, middle, and outer layers occurs during gastrulation.  The resulting gastrula consists of an outer ectoderm, an inner endoderm, and a mesoderm layer positioned between them.</p><blockquote><p>在原肠胚形成过程中，囊胚重新排列，形成包括内层，中层，外层的三围组织。最终原肠胚由一个外肠胚，内肠胚，和一个中肠胚构成。</p></blockquote><p>Each layer gives rise to specific tissues during embryonic development.  A variation in gastrulation, involving the movement of cells into endodermal and mesodermal positions through the thickened primitive streak, arose in reptiles and can still be seen in bird and mammalian embryos, lending support to the theory that birds and mammals evolved from reptiles.</p><blockquote><p>每个胚层产生特殊的胚胎组织。密实的原肠胚通过细胞运动进入内胚层和中胚层，爬虫，鸟，哺乳动物的胚胎都如此。因此提出这样的理论，鸟类和哺乳动物是由爬虫进化而来的。</p></blockquote></li><li><p>Organogenesis: Formation of Functional Tissues and Organs（器官发生：功能组织和器官的形成）</p><p>The organs and tissues of the embryo arise during organogenesis as cells inside the embryo and on its surface become specialized.  Organogenesis actually includes two closely linked processes, morphogenesis and differentiation.  During morphogenesis cells and cell populations change shape: an example is neurulation in vertebrate embryos, in which the edges of the flat neural plate fold upward and fuse, forming the beginnings of the hollow brain and spinal cord.  During differentiation cells mature so that they may perform separate functions.  This maturation may include taking on a function-related shape, such as the long, spindly shape of skeletal-muscle cells.  Cell differentiation also results in responsiveness-the ability of a cell to be regulated within the organism through the action of hormones, neurons, and other signals.</p><blockquote><p>胚经过内部细胞和表面细胞特化后，器官形成，发育成器官和组织。器官形成实质上包括两个联系紧密的过程，即形态发生和分化。在形态发生期间，细胞和细胞群体形状发生改变：例如，脊椎动物的神经胚，扁平神经板的边缘向上折叠并融合，是中空大脑和脊髓神经形成的开端。在分化期间，细胞成熟，执行各自功能。成熟包括功能相关的成型过程。例如，细长的骨骼肌肉细胞。细胞分化也产生应答能力，即细胞受生物体内激素，神经和其他信号的调控过程。</p></blockquote></li><li><p>Embryonic Coverings and Membranes（胚胎覆盖物和胎膜）</p><p>The embryos of land vertebrates are enclosed within four extraembryonic membranes that afford protection while still permitting the exchange of gases, nutrients, and other materials.</p><blockquote><p>脊椎动物的胚胎被4层膜包被，起保护作用，但仍能交换气体，营养和其他物质。</p></blockquote></li><li><p>Growth: Increase in Size（增长：规模增加）</p><p>Growth in embryos is largely due to an increase in the number of cells rather than to an increase in the size of individual cells.  In many species the extent of embryonic growth is limited by the availability of food (yolk).  In animals that develop entirely free of the maternal body, such as frogs and insects, the embryo give rise to a larval stage that can feed itself and later undergo metamorphosis to attain the adult stage.  In many species the most spectacular growth phase takes place during the juvenile and adolescent phases of the life cycle.  Actual growth generally stops once the organism reaches its typical adolescent phases of the life cycle.  Actual growth generally stops once the organism reaches its typical adult size, although replacement of dead cells may continue.</p><blockquote><p>胚的生长很大程度取决于细胞数量的增加而不是单个细胞大小的改变。在大多数物种中，胚的生长是受卵黄的量限制的。在动物细胞中，完全依赖于母体，例如蛙和昆虫，胚产生幼虫状态，后来经历变态而进入成年状态。在许多物种中，在少年和青春期，发生特别显著的生长。一旦细胞进入成年状态和成年大小，生长就停止了，尽管死细胞的替代不断发生。</p></blockquote><p>A special type of growth, regeneration of lost body parts, can take place in adults of some species.  Prior to such regeneration cells in stump tissue undergo dedifferentiation.  They lose their functional phenotype, divide rapidly, and generate a population of cells that will regenerate the lost part. Compensatory hypertrophy is a different, temporary growth response in which residual tissue increases in mass and cell number: cells undergo mitosis but do not dedifferentiate.</p><blockquote><p>一个特殊类型的生长，再生失去的部分躯体，发生在某些物种的成体中。在再生之前，残肢组织细胞经历了去分化过程。他们失去功能表型，快速分裂，产生细胞群来再生失去的部分。代偿式肥大是一个不同的，暂时的生长应答过程，残余组织在体积和细胞数量上增加：细胞经历了减数分裂，但没有去分化过程。</p></blockquote></li><li><p>Aging and Death: Final Developmental Processes（衰老与死亡：最后的发展过程）</p><p>Aging is an ongoing, time-dependent developmental process in which body parts deteriorate.  Proposed causes include the degeneration of collagen (the fibrous proteins of the connective tissues) and limits on the number of times cells can divide.  Other theories focus on a decline of the immune system or on the accumulation of lipofuscins (aging pigments).</p><blockquote><p>老化是一个持续过程，随时间发育，身体部分恶化。可能原因包括胶质的退化（纤维蛋白）和能分裂活细胞的限制。另外理论认为，免疫系统的免疫下降或脂褐素的堆积造成的。</p></blockquote></li></ol><h2 id="第一章"><a class="header-anchor" href="#第一章"></a>第一章</h2><ol><li>Polysome：多聚核糖体 → RNA and ribosomes：RNA和核糖体</li><li>Pinocytosis：胞饮 → cell drinking</li><li>Exocytosis：胞吐 → expel：排出</li><li>Plastid：质体 → in plants only：仅在植物体中</li><li>Golgi complex：高尔基体 → packaging：包装，打包</li><li>Flagella：鞭毛 → whiplike：鞭子似的，像鞭子的</li><li>Phagocytosis：吞噬 → engulfment：吞食</li><li>Lysosome：溶酶体 → baglike structure：像袋子一样的结构</li><li>Basal body：基体 → where flagella grow：鞭毛生长的地方</li><li>Chemotactic：趋化 → toward or away from a chemical stimulus：朝向或远离化学刺激</li><li>Nucleus：核 → control room：控制中心</li><li>Vacuole：液泡 → vacant：空着的</li><li>Ribosome：核糖体 → protein synthesis：蛋白质合成</li><li>Cytoskeleton：细胞骨架 → weblike：像网的</li><li>Mitochondrion：线粒体 → power generator：发电机</li></ol><hr><ol><li>❌The DNA of prokaryotic cells is concentrated in the nucleus. 原核细胞的DNA集中在细胞核内。</li><li>✔Ribosomes are derived from the nucleoli.核糖体来源于核仁。</li><li>❌Unlike other cell membranes, the nuclear envelope has no pores.与其他细胞膜不同，核膜没有孔。</li><li>✔The smooth endoplasmic reticulum is held in place by the cytoskeleton.光滑的内质网由细胞骨架固定。</li><li>✔Structural proteins are exportable.</li><li>✔The nuclear envelope is produced by the rough endoplasmic reticulum.核膜由粗面内质网产生。</li><li>✔Most cellular proteins are manufactured on ribosomes.大多数细胞蛋白质是由核糖体制造的。</li><li>✔White blood cells work by phagocytosis.白细胞通过吞噬作用起作用。</li><li>❌Prokaryotic cells have microbodies.原核细胞有微体。</li><li>✔Mitochondria are self-replicating.</li><li>✔Pinocytosis describes the intake of fluid into a cell by a vacuole.</li><li>❌Both prokaryotic and eukaryotic cells have a supporting cytoskeleton.</li><li>❌Carotenoids are colorless molecules.</li><li>❌Grana are surrounded by stoma.</li></ol><hr><ol><li><p>Most of the properties associated with processes of life are properties of __</p><p>a. the nucleus<br>b. DNA<br>c. the cytoplasm<br>d. endosymbionts 内共生体 ✔<br>e. none of the above</p></li><li><p>Ribosomes</p><p>a. are organelles involved in protein synthesis 参与蛋白质合成的细胞器 ✔<br>b. are the cell’s main energy source<br>c. are storage sites for starch<br>d. are involved in the breakdown of proteins<br>e. store genetic information in the form of DNA</p></li><li><p>Smooth endoplasmic reticulum (SER) __</p><p>a. lacks ribosomes<br>b. is active in fat and steroid synthesis<br>c. is involved in the oxidation of toxins<br>d. all of the above ✔<br>e. none of the above</p></li><li><p>Ribosomes are manufactured in __核糖体制造是在</p><p>a. cytoplasm<br>b. nucleoli 核仁 ✔<br>c. mitochondria<br>d. smooth endoplasmic reticulum<br>e. rough endoplasmic reticulum</p></li><li><p>Lysosomes contain __ 溶酶体包含</p><p>a. hydrolytic enzymes ✔<br>b. genetic material<br>c. stored fats<br>d. proteins<br>e. carbohydrates</p></li><li><p>The process of phagocytosis involves __吞噬的过程包括</p><p>a. vacuolar engulfing of particulate matter 颗粒物质的液泡吞噬 ✔<br>b. exocytosis<br>c. intake of water by a cell’s vacuole<br>d. expulsion of particulate matter from a cell<br>e. expulsion of water from a cell</p></li><li><p>Transformation of energy and storage of energy in the cell are the main function of __ 能量的转换和储存是主要功能对于</p><p>a. ribosomes<br>b. microbodies<br>c. contractile vacuoles<br>d. mitochondria 线粒体 ✔<br>e. smooth endoplasmic reticulum</p></li><li><p>In the mitochondria, enzymes involved in ATP generation are  __在线粒体中，参与ATP产生的酶是</p><p>a. located within the matrix<br>b. located on the cristae 位于嵴上 ✔<br>c. located on ribosomes in the matrix<br>d. dispersed throughout the cristae and matrix<br>e. associated with polysomes</p></li><li><p>Chromoplasts are a type of   __ 有色体是一种</p><p>a. pigment<br>b. storage bin<br>c. nutrient tank<br>d. plastid 质体 ✔<br>e. none of the above</p></li><li><p>An mRNA molecule and its associated ribosomes make up __ 一个信使rna分子及其相关的核糖体组成</p><p>a. a multisome<br>b. a polysome ✔<br>c. a lysosome<br>d. a monosome<br>e. none of the above</p></li><li><p>Leucoplasts are plastids that __ 白色体是一种质体</p><p>a. contain carotenoid<br>b. are involved in photosynthesis<br>c. serve as a storage site for starch, proteins, and oils  作为淀粉、蛋白质和油脂的储存场所 ✔<br>d. are responsible for plant pigmentation<br>e. are none of the above</p></li><li><p>Each individual cell is supported by a network of filaments and tubules known as __ 每个细胞都由一个由丝和小管组成的网络支撑</p><p>a. cytoplasm<br>b. a vacuole<br>c. an endoplasmic reticulum<br>d. a cytoskeleton 细胞骨架 ✔<br>e. a plasma membrane</p></li><li><p>In prokaryotic cells the DNA is __ 在原核细胞中DNA是</p><p>a. found in the nucleus<br>b. organized into a number of discrete chromosomes<br>c. condensed into an unbounded area called the nucleoid 凝聚成一个无界区域，称为类核 ✔<br>d. condensed into nucleoli<br>e. enclosed in a nuclear envelope</p></li><li><p>Amino acids are assembled into proteins in the cells __ 氨基酸在细胞中组装成蛋白质</p><p>a. in the nucleus<br>b. on ribosomes 在核糖体 ✔<br>c. in mitochondria<br>d. in lysosomes<br>e. in the Golgi complex</p></li><li><p>During protein synthesis a single mRNA molecule may be associated with several ribosomes to form __在蛋白质合成过程中，单个mRNA分子可能与几个核糖体结合形成</p><p>a. a gene<br>b. a lysosome<br>c. a polysome 多聚核糖体 ✔<br>d. smooth endoplasmic reticulum<br>e. rough endoplasmic reticulum</p></li><li><p>Export proteins are proteins destined for export from the cell or for inclusion in cell membranes. The can be identified by __</p><p>a. their secondary structure<br>b. a sequence of amino acids known as signal peptide 被称为信号肽的氨基酸序列 ✔<br>c. their association with a polysome<br>d. all of the above<br>e. none of the above</p></li><li><p>Proteins synthesized on endoplasmic reticulum are modified __ 内质网合成的蛋白质经过修饰</p><p>a. in vacuoles<br>b. in the cell membrane<br>c. in the Golgi complex ✔<br>d. in lysosomes<br>e. not at all after synthesis</p></li><li><p>An amoeba living in water whose tonicity is lower than that of its internal cytoplasm must deal with a constant infux of water into the cell. It expels this excess water by __ 生活在水中的变形虫的张力低于其内部细胞质的张力，因此必须不断地向细胞内注入水。它把多余的水排出</p><p>a. using excretory proteins<br>b. waterproofing its cell membrane with lipids<br>c. using a contractile vacuole 用一个可收缩的液泡 ✔<br>d. using phagocytosis<br>e. moving to an environment with lower tonicity</p></li><li><p>Hydrolytic enzymes in the cell digest food in the __ 细胞里的水解酶消化食物在</p><p>a. lysosome 溶酶体 ✔<br>b. Golgi complex<br>c. mitochondria<br>d. chloroplast<br>e. endoplasmic reticulum</p></li><li><p>An organelle isolated from an animal cell is found to contain large numbers of enzymes involved in energy transformation. This organelle is most likely to be __人们发现从动物细胞中分离出来的细胞器含有大量参与能量转换的酶。这个细胞器很可能是</p><p>a. a lysosome<br>b. a Golgi complex<br>c. a mitochondrion  线粒体 ✔<br>d. a chloroplast<br>e. a leucoplast</p></li></ol><hr><h2 id="第二章"><a class="header-anchor" href="#第二章"></a>第二章</h2><ol><li>C<sub>3</sub> plant→moist climates</li><li>pigment→absorbs</li><li>light reactions→water oxidized</li><li>thylakoid→surrounds a lumen</li><li>ground state→most stable</li><li>reaction center→a specific site</li><li>photorespiration→greenhouse effect</li><li>RuBP→electron acceptor for CO<sub>2</sub></li><li>Calvin Benson cycle→light-independent reactions</li><li>C<sub>4</sub> plant→dry climates</li><li>photon→wave and particle</li><li>chlorophyll→principal pigment</li><li>chloroplast→banana shape</li><li>carbon cycle→inefficient dark reaction</li><li>light- independent reactions→light optional</li></ol><hr><ol><li>❌Photosynthesis occurs in all living things.</li><li>✔Photon energy is inversely proportional to wavelength.</li><li>❌Chlorophyll b is not found in any prokaryote.</li><li>❌The reaction center in photosystem Ⅱ is P700.</li><li>✔Cyclic photophosphorylation produces additional ATP in plants.</li><li>❌The chemiosmotic theory applies to mitochondria but not to chloroplasts.</li><li>❌Light-dependent reactions take place in the chloroplast stroma.</li><li>✔The Calvin-Benson cycle may take place either in light or in the dark.</li><li>❌Light-independent reactions take place in thylakoid membrane.</li><li>✔C<sub>3</sub> plant grow slowly in hot, dry weather.</li><li>✔Chlorophyll a is the primary photosynthetic pigment in green plants.</li></ol><hr><ol><li><p>The process of photosynthesis can be considered as a series of reactions in which light energy from the sun is __ 光合作用的过程可以看作是来自太阳的光能的一系列反应</p><p>a. transformed into chemical energy 转化成化学能 ✔<br>b. not transformed in the plant<br>c. transformed into kinetic energy<br>d. transformed into potential energy<br>e. transformed by electrons into electric energy</p></li><li><p>In the first stage of photosynthesis water is __ 在光合作用的第一阶段，水是</p><p>a. oxidized 被氧化 ✔<br>b. phosphorylated<br>c. reduced<br>d. heated<br>e. none of the above</p></li><li><p>In the course of photosynthesis glucose molecules are formed from CO<sub>2</sub>  and H<sub>2</sub>O. This process __在光合作用过程中，CO2和H2O形成葡萄糖分子。这个过程</p><p>a. is exergonic<br>b. is endergonic 是吸能 ✔<br>c. requires no energy<br>d. liberates energy to the atmosphere<br>e. is none of the above</p></li><li><p>The splitting of water molecules during photosynthesis __光合作用水分子在光合作用中分解</p><p>a. occurs independently of light<br>b. is known as the Calvin-Benson cycle<br>c. takes place in the mitochondria<br>d. is light-dependent 是依赖光 ✔<br>e. only occurs in C<sub>4</sub> plant</p></li><li><p>The end products of the first stage of photosynthesis that drive the second stage are __ 驱动光合作用第一个阶段的最终产物是</p><p>a. ADP and NAD<br>b. ATP and NADPH ✔<br>c. H<sub>2</sub>O and ADP<br>d. CO<sub>2</sub><br>e. low-energy compounds</p></li><li><p>During the second stage of photosynthesis, __</p><p>a. CO<sub>2</sub> is oxidized to carbohydrate<br>b. O<sub>2</sub> is reduced<br>c. CO<sub>2</sub> is reduced✔<br>d. CO<sub>2</sub> is liberated into the atmosphere<br>e. carbohydrates are oxidized to release energy</p></li><li><p>The fattened stacks of saclike structures in the chloroplast are called grana. Each sac is known as __叶绿体中肥厚的囊状结构称为基粒。每个囊被称为</p><p>a. a lumen<br>b. a granum<br>c. a membrane<br>d. a thylakoid✔<br>e. a photoreactive center</p></li><li><p>The enzymes and cofactors that facilitate the light-dependent reactions of photosynthesis are embedded in the __酶和辅助因子促进光合作用依赖光的反应是嵌入在</p><p>a. stroma<br>b. lumen of the cytoplasm<br>c. thylakoid membrane 类囊体膜 ✔<br>d. cell wall<br>e. nuclear membrane</p></li><li><p>The distance a photon travels during a complete vibration is __</p><p>a. its particle property<br>b. its radiation<br>✔c. its wavelength<br>d. its strength<br>e. none of the above</p></li><li><p>Biological molecules can only capture light whose wavelength lies in __.</p><p>a. the high-energy part of the spectrum<br>b. the low-energy part of the spectrum<br>c. any part of the spectrum<br>✔d. the visible part of the spectrum<br>e. the gamma-ray spectrum</p></li><li><p>When a chlorophyll molecule absorbs light,  __.</p><p>a. all wavelengths are equally absorbed<br>b. green light is maximally absorbed<br>✔c. green light is not absorbed<br>d. red light is reflected<br>e. blue light is reflected</p></li><li><p>The last electron acceptor in electron transport is __.</p><p>a. O<sub>2</sub><br>✔b. P700<br>c. photosystem I<br>d. water<br>e. none of the above</p></li><li><p>The precise range of wavelengths active duling photosynthesis is known as __.</p><p>a. the electromagnetic spectrum<br>b. the absorption spectrum<br>c. the high-energy spectrum<br>d. the low-energy spectrum<br>✔e. the action spectrum</p></li><li><p>Pigment molecules aggregated together into an antenna complex __.</p><p>a. act together to gather light energy<br>b. transfer light energy down an electron transport system<br>c. are closely associated with reaction-center chlorophyll molecules<br>✔d. all of the above<br>e. none of the above</p></li><li><p>When a chlorophyll molecule absorbs a photon of light, __.</p><p>✔a. the outermost electron becomes excited and moves to a higher- energy orbital<br>b. it immediately donates an electron<br>c. all its electrons remain in the ground state<br>d. fuorescence is the first event to occur<br>e. the molecule donates all its electrons</p></li><li><p>Cyclic phosphorylation differs from noncyclic phosphorylation in that __.</p><p>a. only cyclic phosphorylation yields NADP<br>✔b. cyclic phosphorylation yields ATP while non-cyclic phosphorylation yields ATP and NADPH<br>c. cyclic phosphorylation yields ATP and non-cyclic phosphorylation yields only NADPH<br>d. only noncyclic phosphorylationyields ATP<br>e. none of the above; there is no difference in end product or in the processes</p></li><li><p>The Calvin-Benson cycle takes place in __.</p><p>a. the ribosomes<br>✔b. the inner plasma membrane<br>c. the cytoplasm<br>d. the stroma<br>e. none of the above</p></li><li><p>In the light-independent reactions of photosynthesis, the first electron acceptor for atmospheric CO<sub>2</sub> is __.</p><p>a. PGA<br>b. ATP<br>✔c. ribulose biphosphate<br>d. a carbohydrate subunit<br>e. a carboxylase</p></li><li><p>The process of photorespiration __.</p><p>a. occurs when oxygen levels are high<br>b. is an inefficient form of light-independent reactions of photosynthesis<br>C. results in the fixation of oxygen<br>d. is due in part to stomata closure on hot, dry, sunny days<br>✔e. is all of the above</p></li></ol><hr><h2 id="第三章"><a class="header-anchor" href="#第三章"></a>第三章</h2><ol><li>cytokinesis → division of cytoplasm</li><li>synapsis → crossing over</li><li>histone → positively charged protein</li><li>mitosis → cell division</li><li>cell cycle → sequence of cell growth and division</li><li>chalone → inhibit cell division</li><li>spindle → set of microtubules</li><li>chromatid → single chromosome copy</li><li>nucleosome → DNA + histones</li><li>diploid → two sets</li><li>meiosis → gamete production</li><li>cell plate → plant division</li><li>sex chromosome → X and Y</li><li>karyotype → chromosome display</li><li>haploid → one set</li></ol><hr><ol><li>❌Autosomes include X and Y chromosomes.常染色体包括X染色体和Y染色体</li><li>✔Cells enter G<sub>2</sub> at the end of the S phase. S期结束时，细胞进入G2。</li><li>❌Chalones promote cell division.抑素促进细胞分裂。</li><li>✔The nuclear envelope forms in telophase.核膜在末期形成。</li><li>❌Plant cells have the most prominent centrioles.植物细胞有最显著的中心粒。</li><li>✔Nuclear division may occur without cytokinesis.核分裂在没有胞质分裂的情况下也可以发生。</li><li>✔Homologous chromosome pair in synapsis.同源染色体在联会时组成一对</li><li>✔Chromosomes break at chiasmata.染色体在交叉处断裂。</li><li>❌Sexual organisms cannot be cloned.有性生物不能被克隆。</li><li>❌All daughter cells are haploid.所有子细胞都是单倍体。</li></ol><hr><ol><li><p>DNA is replicate during the __.DNA复制在</p><p>✔a. S phase<br>b. M phase<br>c. G<sub>2</sub> phase<br>d. G<sub>1</sub> phase<br>e. G<sub>0</sub> phase</p></li><li><p>Members of a chromosome pair collectively make up __.一对染色体共同组成的成员</p><p>a. a tetrad<br>b. chromatin<br>c. a homologous pair<br>✔d. a chromatid 一个染色单体<br>e. a nucleosome</p></li><li><p>Autosomes represent __.常染色体表示</p><p>a. all chromosomes found in a normal human cell<br>b. those chromosomes found in egg or sperm cells<br>✔c. all chromosomes other than the sex chromosomes 除性染色体外的所有染色体<br>d. chromosome pairs with unlike members<br>e. all homologous chromosomes</p></li><li><p>In a typical vertebrate the longest phase is __.在典型的脊椎动物中，最长的阶段是</p><p>a. S<br>b. M<br>C. G<sub>2</sub><br>✔d. G<sub>1</sub><br>e. none of the above</p></li><li><p>A normal diploid human cell contains __.一个正常的二倍体人类细胞包含</p><p>✔a.46 chromosomes<br>b.23 chromosomes<br>c.46 homologous pairs of chromosomes<br>d.20 chromosomes<br>e.20 pairs of chromosomes and 2 sex chromosomes</p></li><li><p>Male sex chromosomes can never be __.男性的性染色体永远不会</p><p>a. haploid<br>✔b. homologous 同源<br>c. diploid<br>d. analogous<br>e. duplicated</p></li><li><p>During G<sub>1</sub>, S, and G<sub>2</sub> phases, a cell is said to be in __.在G<sub>1</sub>、S和G<sub>2</sub>阶段，细胞被称为处于</p><p>a. the process of mitosis<br>b. the process of meiosis<br>c. metaphase<br>d. cytokinesis<br>✔e. interphase 分裂间期</p></li><li><p>It is possible for 2 meters of DNA to fit into a human cell 5 micrometers in diameter because __.2米长的DNA可以植入直径5微米的人体细胞，因为</p><p>a. DNA is broken into small fragments<br>✔b. DNA is wound around histones DNA缠绕在组蛋白周围<br>c. DNA is wound around nonhistone proteins<br>d. Chromosomes are composed of chromatids<br>e. Chromosomes are joined at the centromere</p></li><li><p>The association of a DNA molecule, histones, and nonhistone proteins is known as a __.DNA分子、组蛋白和非组蛋白的结合称为</p><p>a. nucleosome<br>b. chromosome<br>✔c. chromatin 染色质<br>d. chromatid<br>e. karyotype</p></li><li><p>The two daughter strands of a duplicated chromosome are each known as (a) __.复制染色体的两条子链分别称为</p><p>a. synapse pair<br>b. centromere<br>✔c. chromatid 染色单体<br>d. homologous chromosome<br>e. chiasmata</p></li><li><p>Chromosomes become visible during mitotic phase of __.染色体在有丝分裂期间可见</p><p>a. metaphase<br>b. anaphase<br>✔c. prophase 前期<br>d. synapsis<br>e. none of the above</p></li><li><p>Anaphase begins during mitosis when  后期开始于有丝分裂期间</p><p>a. chromosomes line up in the nuclear region of the cell<br>✔b. centromeres split and chromatids start to move apart 着丝点分裂，染色单体开始分离<br>c. synapsis occurs<br>d. crossing over occurs<br>e. prophase has been completed</p></li><li><p>A new nuclear envelope begins to form around each chromosome set during __.一个新的核膜开始在每条染色体周围形成</p><p>a. anaphase I<br>b. metaphase<br>c. prophase Ⅱ<br>d. cytokinesis<br>✔e. telophase 末期</p></li><li><p>In animal cells spindle formation is assoclated with __. 在动物细胞中纺锤形形成与</p><p>a. the nuclear membrane<br>b. nucleosomes<br>c. histone proteins<br>✔d. the centriole 中心粒<br>e. chromosomes</p></li><li><p>Haploid cells contain __.  单倍体细胞包含</p><p>a. the diploid chromosome number<br>✔b. one copy of each chromosome 每个染色体的一个拷贝<br>c. two copies of the sex chromosomes<br>d. twice the diploid chromosome number<br>e. pairs of homologous chromosomes</p></li><li><p>Meiosis results in__. 减数分裂的结果</p><p>a. no change in the chromosome number<br>b. a doubling of the chromosome number<br>✔c. a reduction in the chromosome number 染色体数目的减少<br>d. two interphase cells<br>e. four diploid cells</p></li><li><p>Crossing over occurs during __. 交叉发生在</p><p>a. G<sub>0</sub> phase<br>b. G<sub>1</sub> phase<br>✔c. synapsis 染色体联会<br>d. cytokinesis<br>e.Mphase</p></li><li><p>Cytokinesis is accomplished in animal cells by __. 动物细胞的胞质分裂是通过</p><p>✔a. a ring of actin filaments pinching the cell in two 将细胞夹成两半的肌动蛋白丝环<br>b. the formation of a cell plate<br>c. the formation of a new cell wall<br>d. the action of centrioles<br>e. the re formation of the nuclear membrane</p></li><li><p>During crossing over __. 在交叉时</p><p>a. chromosomes line up along the metaphase plate .<br>✔b. homologous chromosomes exchange corresponding pieces of genetic information 同源染色体交换相应的遗传信息片段<br>c. chromosomes move to opposite ends of the cell<br>d. the cell is in S phase<br>e. the cell is undergoing mitosis</p></li><li><p>The advantages of asexual reproduction include__.无性繁殖的优点包括</p><p>a. it is more rapid than sexual reproduction<br>b. it requires few specialized reproductive structures<br>c. it preserves the individual’s winning genetic make up<br>✔d. all of the above 上述全部<br>e. a and c</p></li></ol><h2 id="第四章"><a class="header-anchor" href="#第四章"></a>第四章</h2><ol><li><p>dominant 显性 → always expressed 总是表达</p></li><li><p>phenotype 表型 → appearance 外观</p></li><li><p>allele 等位基因 → alternative forms 替代形式</p></li><li><p>homozygous  纯合子 → similar 相似</p></li><li><p>recessive 隐性性状 → nondominant 非显性的</p></li><li><p>P1 → parental 亲本</p></li><li><p>dihybrid cross 双因子杂种杂交 → two characters</p></li><li><p>law of segregation 分离定律 → separate 分离</p></li><li><p>gene 基因 → basic units of heredity 遗传的基本单位</p></li><li><p>pangenesis 泛生论 → Hippocrates 希波克拉底</p></li><li><p>F2 → grandchildren</p></li><li><p>sex-linked 伴性的 → X or Y chromosome</p></li><li><p>heterozygote 杂合子 → different</p></li><li><p>genotype 基因型 → total alleles 总等位基因</p></li><li><p>germ plasm theory → Weismann 魏斯曼</p></li></ol><hr><ol><li>❌Germ plasm theory is the notion that each body part produces a“seed&quot; .种质理论的概念是，身体的每个部分产生一个“种子”。</li><li>✔Breeding true means offspring are identical with parents in certain traits.真正的繁殖是指后代在某些特性上与父母相同。</li><li>✔Alleles are simply alternate forms of genes.等位基因只是基因的另一种形式。</li><li>❌Snapdragon color is an example of blending inheritance.金鱼草颜色是混合继承的一个例子</li><li>✔An XO male may result from nondisjunction. XO雄性可能是不分离的结果。</li><li>❌Hippocrates fully rejected the idea of pangenesis.希波克拉底完全拒绝泛生学说。</li><li>✔Homozygous organisms produce only one type of gamete for a gene.纯合子的生物体一个基因只产生一种配子。</li><li>✔Test crosses helped establish the law of segregation.杂交试验有助于建立分离定律。</li><li>✔Sutton and Boveri developed the chromosome theory of heredity.萨顿和博韦里发展了遗传的染色体理论。</li><li>❌Mendel’s second law states that characters are inherited dependently.孟德尔第二定律指出，特性是独立继承的</li></ol><hr><ol><li><p>The notion that each part of the body of an organism produces a“seed”that then travels to the reproductive organs is called __.生物体身体的每个部分都产生一种“种子”，然后传播到生殖器官的概念被称为。</p><p>a. germ plasm theory<br>✔b. pangenesis 泛生论<br>c. law of independent assortment<br>d. law of segregation<br>e. heterozygosity</p></li><li><p>The germ plasm theory of heredity, which emphasized the role of parental germ cells in determining traits in offspring, was linked to a widespread belief in__.遗传的种质理论强调亲代生殖细胞在决定后代性状方面的作用，这与一种普遍的观念</p><p>✔a. blending 混合<br>b. vitalism<br>c. pangenesis<br>d. Mendelism<br>e. Herodotus</p></li><li><p>When true breeding plants are self-fertilized, they__.当真正的育种植物自我受精时，它们</p><p>a. produce heterozygous offspring<br>b. produce offspring that show a range ofphenotypes<br>✔c. produce offspring that are identical to the parent 产生与亲本完全相同的后代<br>d. produce offspring with dominant genotypes<br>e. produce offspring with recessive genotypes</p></li><li><p>Mendel’s experiments with peas had unique and important features, including the fact that __.孟德尔的豌豆实验具有独特而重要的特点，其中包括</p><p>a. he studied traits that offered only two alternative outcomes<br>b. he followed and recorded the type and number of all offspring<br>c. he followed the results of each cross for two generations<br>✔d. all of the above<br>e. he used the test cross procedure for two generations</p></li><li><p>A plant that is heterozygous for a particular trait __. 杂合子一种特殊性状的杂合子植物</p><p>a. carries identical alleles for that trait<br>✔b. carries different alleles for that trait 携带不同的等位基因<br>c. can be distinguished from a homozygous plant by its phenotype<br>d. shows incomplete dominance<br>e. is none of the above</p></li><li><p>In modern terms Mendel’s first law states that __.用现代术语来说，孟德尔第一定律表明</p><p>✔a. during meiosis alleles of a gene segregate out at random在减数分裂期间，一个基因的等位基因会随机分离出来<br>b. homologous chromosomes pair during meiosis<br>c. chromosomes move in a predetermined manner<br>d. recessive genes are only evident in the homozygous phenotype<br>e. dominant genes are only evident in the homozygous phenotype</p></li><li><p>Hereditary factors determining green seedcolor and yellow seed color are examples of __. 决定绿色种子颜色和黄色种子颜色的遗传因素，例如</p><p>a. incomplete dominance<br>✔b. different alleles of the same gene 同一基因的不同等位基因<br>c. sex linkage .<br>d. two genes<br>e. sex chromosomes</p></li><li><p>If P represents a dominant allele and p a recessive allele for the same trait, a homozygous recessive individual will have the following genotype:__.如果P为显性等位基因，p为隐性等位基因，则纯合隐性个体具有以下基因型</p><p>a. PP<br>b. Pp<br>c. pP<br>✔d. pp<br>e. none of the above</p></li><li><p>According to Mendel’s laws, in a cross involving an individual that is homozygous dominant for a trait and an individual that is homozygous recessive for the same trait, __.根据孟德尔定律，一个个体在某一性状上是纯合显性的，另一个个体在同一性状上是纯合隐性的</p><p>a. the recessive trait will be present in a 1:3 ratio in the F1 phenotypes<br>✔b. the recessive trait will not be present in the F1 phenotypes 隐性性状在F1表现型中不存在<br>c. the recessive trait will be present in the F1 phenotypes more often than the dominant trait<br>d. the recessive trait will be present three times more often than the dominant trait in the F1 phenotypes</p></li><li><p>Mendel’s law of independent assortment states that__.孟德尔自由组合定律说</p><p>a. monohybrid crosses will show segregation and independent assortment<br>b. the segregation of alleles of one gene depends on the segregation of all other alleles<br>c. test crosses always produce heterozygous offspring<br>✔d. alleles of different genes segregate at random and fertilization is random 不同基因的等位基因随机分离，受精是随机的<br>e. alleles segregate at meiosis</p></li><li><p>In a cross between a homozygous plant bearing round yellow seeds and a homozygous plant bearing wrinkled green seeds, all the offspring had round yellow seeds. If R represents the round allele and Y the yellow allele, the F1 genotype was__.在一株结黄色圆形种子的纯合子植株和一株结皱绿色种子的纯合子植株的杂交中，所有的后代都结黄色圆形种子。若R代表圆形等位基因，Y代表黄色等位基因，则F1基因型为</p><p>a. RRYY<br>b. RRyy<br>c. RRyY<br>✔d. RrYy<br>e. Rryy</p></li><li><p>The punnett square was used by Mendel to 庞尼特形被孟德尔用来</p><p>✔a. predict the probabilities of different allele combinations 预测不同等位基因组合的概率<br>b. record the results of his test crosses<br>c. develop the idea of the dihybrid cross<br>d. disprove pangenesis<br>e. none of the above</p></li><li><p>A dihybrid cross is a mating between two organisms 杂交是指两种生物交配</p><p>a. when at least one is heterozygous for two traits<br>✔b. when both are heterozygous for two traits 当两种性状都是杂合子时<br>c. when one is homozygous and one is heterozygous for a trait<br>d. when both are homozygous for a single trait</p></li><li><p>For some specific traits the phenotypes of offspring are intermediate between those of the parents’ traits. This is a case of 对于某些特定性状，后代的表现型介于父母的表现型之间。这是一个例子</p><p>a. blending<br>b. linkage<br>✔c. incomplete dominance 不完全显性<br>d. intermediate inheritance<br>e. none of the above</p></li><li><p>Sutton and Boveri proposed that Mendel’s hereditary factors were located on chromosome,in a theory known as Sutton和Boveri提出孟德尔的遗传因子位于染色体上，在一个被称为</p><p>a. pangenesis<br>b. germ plasm theory<br>✔c. chromosomal theory of inheritance 染色体遗传理论<br>d. independent assortment<br>e. blending theory of inheritance</p></li><li><p>Sex chromosomes were first discovered in 性染色体最早发现于</p><p>a. peas<br>b. Manx cats<br>c. frizzle chickens<br>✔d. fruit flies 果蝇<br>e. humans</p></li><li><p>Sex-linked traits are 位于性染色体的特征是</p><p>✔a. traits carried on sex chromosomes 性状由性染色体携带<br>b. traits only found in one sex<br>c. traits found in female fruit flies<br>d. traits carried only on the Y chromosome<br>e. none of the above</p></li><li><p>Nondisjunction describes. 不分离描述</p><p>a. the movement of chromosomes to opposite poles of the cell during anaphase<br>✔b. the failure of homologous chromosomes to segregate during mitosis or meiosis 在有丝分裂或减数分裂过程中同源染色体分离失败<br>c. the failure of two new daughter cells to separate after mitosis<br>d. the process of crossing over during meiosis<br>e. none of the above</p></li><li><p>In fruit fies the following genotypes will produce a female 在果蝇中，下列基因型将产生雌性</p><p>a. YY<br>b. YO<br>c.XY.<br>d. XO<br>✔e. XX</p></li><li><p>A gamete showing a new association of alleles that differs from the parental associations is known as 一个配子显示出不同于亲本配子的新的等位基因组合称为配子</p><p>✔a. a recombinant type 一种重组<br>b. a crossing-over type<br>c. an incomplete dominant<br>d. a heterozygote<br>e. a homozygote</p></li></ol><h2 id="第五章"><a class="header-anchor" href="#第五章"></a>第五章</h2><ol><li>Replication fork 复制叉 → start of DNA replication DNA复制的开始</li><li>cytosine  胞嘧啶 → a DNA base</li><li>Okazaki fragment 冈崎片段 → small piece of DNA</li><li>X-ray diffraction  X射线衍射 → photographic process</li><li>nucleoside 核苷 → a base plus a sugar 碱基加糖</li><li>semiconservative replication 半保留复制 → unwinding must occur 解旋必须发生</li><li>5’ to 3’ direction → DNA chain lengthens</li><li>Chargaf’s rules → A=T</li><li>base → ring structure composed of carbon and nitrogen 由碳和氮组成的环状结构</li><li>double helix 双螺旋 →  shape proposed by Watson and Crick</li></ol><hr><ol><li>✔Hershey and Chase showed that genes are composed of DNA.研究表明，基因是由DNA组成的。</li><li>✔Complementation test can be used to study metabolic pathways.互补试验可用于研究代谢途径</li><li>❌Feulgen staining works on cell walls.富尔根染色作用于细胞壁。</li><li>❌Robert Feulgen discovered nucleic acid.罗伯特·福尔根发现了核酸。</li><li>✔Phages are made only of DNA and a protein coat.噬菌体仅由DNA和蛋白质外壳组成。</li><li>✔Dispersive replication requires breakage.分散复制需要破坏。</li><li>❌Not all organisms exhibit semiconservative replication.不是所有的生物都表现出半保留复制。</li><li>❌Auxotrophs are mutant Neurospora.营养缺陷体是变异脉孢菌。</li><li>✔Virulent pneumonia bacteria secrete a capsule.强毒性肺炎细菌分泌一种胶囊。</li><li>❌Watson and Crick did not make use of X-ray diffraction data.沃森和克里克没有利用x射线衍射数据。</li><li>✔The sequence of bases on the DNA molecule carries the genetic information.DNA分子上的碱基序列携带着遗传信息。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IV. Multiple Choice</span><br><span class="line">1. a 2. c 3. b 4. a 5. b 6. d 7. c</span><br><span class="line">8. c 9. b 10. c 11. d 12. e 13. e 14. b</span><br><span class="line">15. e 16. b 17. d 18. d 19. e 20. b</span><br></pre></td></tr></table></figure><h2 id="第八章"><a class="header-anchor" href="#第八章"></a>第八章</h2><ol><li>yolk 卵黄  → food</li><li>amnion 羊膜  → cushions embryo 缓冲胚胎</li><li>regeneration 重生  → replacement of lost parts</li><li>parthenogenesis 单性生殖 → “virgin”birth</li><li>cleavage 卵裂 → divides a single-celled zygote into many small cells 将单细胞合子分成许多小细胞</li><li>zygote 受精卵 → fertilized egg</li><li>chorion 绒毛膜 → fuses with allantois</li><li>testis → homologous with ovaries</li><li>cortical reaction 皮质反应 →  prevents multiple fertilizations</li><li>ovum 卵 → gamete or egg</li><li>primitive streak 原条 → 与蛋黄有关</li><li>blastomere 分裂球 → individual blastula cells</li><li>allantois → trash dump</li><li>oviduct 输卵管 → egg tube</li><li>gonial cell → spermatogonia 精原细胞</li></ol><hr><ol><li>✔Sertoli cells are helper cells in sperm production.支持细胞是精子生产中的辅助细胞。</li><li>❌The sperm head contains a small number of mitochondria. 精子头部含有少量的线粒体。</li><li>✔Oogenesis may be arrested for years in some species.在某些物种中卵子发生可能被抑制数年</li><li>✔An ostrich egg can be considered a single cell.鸵鸟蛋可以被认为是一个单细胞。</li><li>❌Chromosomes in the “lamp brush” phase produce little mRNA.</li><li>✔The acrosome reaction is triggered by the egg’s jelly coat.顶体反应是由卵的胶膜触发的。</li><li>❌Prior to fertilization, the egg’s electrical charge is positive.在受精之前，卵子的电荷是正电荷。</li><li>✔Parthenogenesis produces only females.孤雌生殖只产生雌性。</li><li>✔The so-called “vegetable pole” contains the most yolk.所谓的“植物极”含有最多的蛋黄。</li><li>✔The gut cavity is derived from an archenteron.肠道由原肠演变而来。</li><li>❌A mphioxus eggs show a prominent primitive streak.斑马鱼的卵显示出明显的原始条纹。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IV. Multiple Choice</span><br><span class="line">1. c 2. a 3. e 4. c 5. d 6. b 7. d</span><br><span class="line">8. b 9. c 10. b 11. b 12. c 13. b 14. b</span><br><span class="line">15. c 16. d 17. d 18. e 19. c 20. d</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 生物学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专业英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组培资料</title>
      <link href="2020/12/25/%E7%94%9F%E7%89%A9%E5%AD%A6/%E7%BB%84%E5%9F%B9%E8%B5%84%E6%96%99/"/>
      <url>2020/12/25/%E7%94%9F%E7%89%A9%E5%AD%A6/%E7%BB%84%E5%9F%B9%E8%B5%84%E6%96%99/</url>
      
        <content type="html"><![CDATA[<h2 id="1-绪论"><a class="header-anchor" href="#1-绪论"></a>1 绪论</h2><h3 id="1、简述植物组织培养的理论依据？"><a class="header-anchor" href="#1、简述植物组织培养的理论依据？"></a>1、简述植物组织培养的理论依据？</h3><p>植物组织培养的理论依据是植物细胞的全能性。即植物每个细胞都携带有完整的全套遗传基因，并具有发育成完整植株的潜在能力。</p><h3 id="2、植物组织培养有哪些特点？"><a class="header-anchor" href="#2、植物组织培养有哪些特点？"></a>2、植物组织培养有哪些特点？</h3><ol><li>培养条件可以人为控制。组织培养采用的植物材料完全是在人为提供的培养基和小气候环境条件下进行生长，摆脱了大自然中四季、昼夜的变化以及灾害性气候的不利影响，且条件均一，对植物生长极为有利，便于稳定地进行周年培养生产。</li><li>生长周期短，繁殖率高。植物组织培养是由于人为控制培养条件，根据不同植物不同部位的不同要求而提供不同的培养条件，因此生长较快。另外，植株也比较小，往往20-30天为一个周期。</li><li>管理方便，利于工厂化生产和自动化控制。植物组织培养是在一定的场所和环境下，人为提供一定的温度、光照、湿度、营养、激素等条件，极利于高度集约化和高密度工厂化生产，也利于自动化控制生产。它是未来农业工厂化育苗的发展方向。它可以大大节省人力、物力及田间种植所需要的土地。</li></ol><h3 id="3、植物组织培养的分类？"><a class="header-anchor" href="#3、植物组织培养的分类？"></a>3、植物组织培养的分类？</h3><ol><li>按培养对象分为：植株培养；胚胎培养；器官培养；组织培养；细胞培养；原生质体培养；</li><li>按培养过程分：初代培养；继代培养；</li><li>根据再生途径分为：愈伤组织途径；芽增殖途径；原球茎途径；体胚发生途径；</li><li>根据培养基的物理状态：固体培养；液体培养。</li></ol><h3 id="4、植物组织培养主要应用于哪些方面？"><a class="header-anchor" href="#4、植物组织培养主要应用于哪些方面？"></a>4、植物组织培养主要应用于哪些方面？</h3><ol><li>快速繁殖  运用组织培养的途径，一个单株一年可以繁殖几万到几百万个植株；</li><li>种苗脱毒  针对病毒对农作物造成的严重危害，通过组织培养可以有效地培育出大量的无病毒种苗；</li><li>培育和创制新品种  利用组织培养可以使难度很大的远缘杂交取得成功，从而育成一些罕见的新物种；</li><li>大量生产次生代谢物质  通过植物细胞培养获得的生物碱、维生素、色素、抗生素以及抗肿瘤药物不下50多个大类，其中已有30多种次生物质的含量在人工培养时已达到或超过亲本植物的水平。植物细胞次生物质的研制与生产硕果累累，后来居上。</li><li>植物种质资源的离体保存  植物组织培养结合超低温保存技术，可以给植物种质保存带来一次大的飞跃。因为保存一个细胞就相当于保存一粒种子，但所占的空间仅为原来的几万分之一，而且在-193度的液氮中可以长时间保存，不像种子那样需要年年更新或经常更新。</li><li>人工种子  人工种子便于贮藏和运输，适合机械化播种；繁殖速度快，不受季节和环境限制，利于工厂化生产； 体细胞胚由无性繁殖体系产生，可以固定杂种优势。</li></ol><h2 id="2-组培的基本技术"><a class="header-anchor" href="#2-组培的基本技术"></a>2 组培的基本技术</h2><h3 id="1、论述植物生长调节物质在组织培养中的作用？-并列举常见的种类"><a class="header-anchor" href="#1、论述植物生长调节物质在组织培养中的作用？-并列举常见的种类"></a>1、论述植物生长调节物质在组织培养中的作用？ 并列举常见的种类</h3><p>植物生长物质是培养基中不可缺少的关键物质，用量虽少，但它们对外植体愈伤组织的诱导和根、芽等器官分化，起着重要和关键的调节作用。<br>常见的种类有：</p><ol><li>生长素类：主要被用于诱导愈伤组织形成，促进细胞脱分化；促进细胞伸长；诱导根的分化，促进生根。吲哚乙酸（IAA）、吲哚丁酸（IBA）、萘乙酸（NAA）、2,4-二氯苯氧乙酸（2,4-D）</li><li>细胞分裂素类：诱导芽的分化促进侧芽萌发生长；促进细胞分裂与扩大；抑制根的分化；抑制衰老，减少叶绿素分解，有保鲜效果。激动素（KT）、异戊烯基腺嘌呤（z-iP）、6-苄基腺嘌呤（BAP、6-BA）、玉米素（Zt）、TDZ</li><li>赤霉素（GA3）</li><li>脱落酸（ABA）</li></ol><h3 id="2、常用的培养基有哪些？说明其特点"><a class="header-anchor" href="#2、常用的培养基有哪些？说明其特点"></a>2、常用的培养基有哪些？说明其特点</h3><ol><li>MS培养基:1962年由 Murashige 和Skoog为培养烟草细胞而设计的。是目前应用最广泛的培养基。特点是无机盐离子浓度较高；</li><li>white 培养基:无机机盐浓度较低，适于生根培养；</li><li>N6培养基: KNO3 和(NH4) 2S04含量高，不含钼。广泛应用于禾谷类植物的花粉和花药培养；</li><li>B5培养基:主要特点是含有较低的铵盐，较高的硝酸盐和盐酸硫胺素。适宜双子叶植物特别是木本植物的培养；</li><li>M- -8P培养基:为原生质体培养而设计的。其特点是有机成分较复杂，它包括了所有的单糖和维生素。</li></ol><h3 id="3、接种后离体培养物对光、温、湿等环境条件的要求？"><a class="header-anchor" href="#3、接种后离体培养物对光、温、湿等环境条件的要求？"></a>3、接种后离体培养物对光、温、湿等环境条件的要求？</h3><ol><li>光照:愈伤组织的诱导不需光照或弱光，器官分化需要光照，一般12- 16h/d，光照度1000 - 50001x;</li><li>温度：一般25士2℃</li><li>湿度:培养室内的湿度要求保持70%一80%的相对湿度。</li></ol><h3 id="4、论述离体培养污染产生的原因及防治措施。"><a class="header-anchor" href="#4、论述离体培养污染产生的原因及防治措施。"></a>4、论述离体培养污染产生的原因及防治措施。</h3><p>污染：污染原因从病源分面主要有细菌和真菌和两大类。<br>产生原因：</p><ol><li>外植体材料消毒不彻底</li><li>培养基灭菌不彻底</li><li>操作环境不洁净</li><li>操作人员操作不规范、不熟练。</li></ol><p>防止措施：</p><ol><li>减少或防止材料带菌</li><li>外植体灭菌要彻底</li><li>培养基灭菌要彻底</li><li>玻璃器皿和金属器皿的灭菌要彻底</li><li>无菌室的消毒</li><li>操作人员一定要严格按照无菌操作的程序进行接种</li></ol><h3 id="5、植物组织培养技术主要包括哪些环节？"><a class="header-anchor" href="#5、植物组织培养技术主要包括哪些环节？"></a>5、植物组织培养技术主要包括哪些环节？</h3><ol><li>培养基的配制及灭菌</li><li>外植体的选择及灭菌</li><li>外植体的接种及培养</li><li>试管苗的驯化与移栽</li></ol><h3 id="6、无菌操作时应注意哪些事项？"><a class="header-anchor" href="#6、无菌操作时应注意哪些事项？"></a>6、无菌操作时应注意哪些事项？</h3><ol><li>在接种4h前用甲醛熏蒸接种室;</li><li>在接种前15-20min,打开超净工作台的风机以及台上的紫外灯;</li><li>接种员先洗净双手，在实验前换好专用实验服;</li><li>到超净台后，用酒精棉球擦拭双手，特别是指甲处。然后用70%酒精擦拭工作台面:</li><li>接种工具蘸95%酒精，灼烧;</li><li>接种时将试管斜着，使试管口在酒精灯火焰上转动，灼烧数秒钟。接完种后，将管口在火焰上再灼烧数秒钟。</li><li>接种时，接种员双手不能离开工作台，不能说话、走动和咳嗽等;</li><li>接种完毕后要清理干净并用酒精擦工作台。</li></ol><h3 id="7、在植物组织培养中，通过哪些途径可以得到完整的植株？"><a class="header-anchor" href="#7、在植物组织培养中，通过哪些途径可以得到完整的植株？"></a>7、在植物组织培养中，通过哪些途径可以得到完整的植株？</h3><ol><li><p>外植体→愈伤组织一根、芽→试管苗</p><p>①同时长芽和根    ②先长芽，再长根    ③先长根，再长芽</p></li><li><p>外植体→胚状体→试管苗</p></li><li><p>外植体→根、芽→试管苗。</p></li></ol><h2 id="3-基本原理"><a class="header-anchor" href="#3-基本原理"></a>3 基本原理</h2><h3 id="1、愈伤组织细胞的分化一般分几个时期？各有何特点？"><a class="header-anchor" href="#1、愈伤组织细胞的分化一般分几个时期？各有何特点？"></a>1、愈伤组织细胞的分化一般分几个时期？各有何特点？</h3><ol><li>诱导期：是细胞准备分裂的时期。细胞大小几不变，内部发生生理生化变化，迅速合成蛋白质和核酸。</li><li>分裂期：外层细胞分裂，中间细胞常不分裂，形成小芯。细胞分裂快，结构疏松，缺少结构，浅而透明。在原培养基上，细胞必分化，及时转移，其可无限制地进行细胞分裂，维持不分化状态。</li><li>分化期：细胞在形态和生理功能上的分化，出现形态和功能各异的细胞。</li></ol><h3 id="2、优良的愈伤组织必须具备哪4个特性？"><a class="header-anchor" href="#2、优良的愈伤组织必须具备哪4个特性？"></a>2、优良的愈伤组织必须具备哪4个特性？</h3><ol><li>高度的胚性或再分化能力，以便从这些愈伤组织得到再生植物。</li><li>容易散碎，以便用这些愈伤组织建立优良的悬浮系，并且在需要时能从中分离出全能性的原生质体</li><li>旺盛的自我增殖能力，以便用这些愈伤组织建立大规模的愈伤组织无性系</li><li>经过长期继代保存而不丧失胚性，便有可能对它们进行各种遗传操作。</li></ol><h3 id="3、愈伤组织的形态发生有哪些情况？"><a class="header-anchor" href="#3、愈伤组织的形态发生有哪些情况？"></a>3、愈伤组织的形态发生有哪些情况？</h3><ol><li><p>愈伤组织仅有根或芽器官的分别形成，即无根的芽或无芽的根；</p></li><li><p>先形成芽，再在芽伸长后，在其茎的基部长出根而形成小植株，多数植物属这种情况；</p></li><li><p>先产生根，再从根基部分化出芽而形成小植株。这种情况较难诱导芽的形成，尤其对于单子叶植物少见；</p></li><li><p>先在愈伤组织的邻近不同部位分别形成芽和根，然后两者结合起来形成一株小植株。</p><p>单子叶植物：与双子叶植物诱导发生过程类似，只是在形态上无鱼雷形胚等阶段，成熟体胚上有盾片、胚芽鞘和胚根等结构。</p></li></ol><h3 id="4、简述细胞脱分化过程。"><a class="header-anchor" href="#4、简述细胞脱分化过程。"></a>4、简述细胞脱分化过程。</h3><p>细胞的脱分化过程可分为3个阶段：</p><ol><li>第一阶段为启动阶段，表现为细胞质增生，并开始向细胞中央伸出细胞质丝，液泡蛋白体出现；</li><li>第二阶段为演变阶段，此时细胞核开始向中央移动，质体演变成原质体；</li><li>第三阶段是脱分化终结阶段，此时细胞回复到分生细胞状态，细胞分裂即将开始</li></ol><h3 id="5、胚状体发生途径与器官发生途径形成植株的区别"><a class="header-anchor" href="#5、胚状体发生途径与器官发生途径形成植株的区别"></a>5、胚状体发生途径与器官发生途径形成植株的区别:</h3><ol><li>胚状体具有两极性， 即在发育的早期阶段， 从其方向相反的两端 分化出茎端和根端;而不定芽和不定根<br>都为单向极性。</li><li>胚状体的维管组织与外植体的维管组织无解剖结构上的联系。而不定芽或不定根往往总是与愈伤组织的<br>维管组织相联系。</li><li>胚状体维管组织的分布是独立的“Y”字形。而不定芽的维管组织无此现象。</li></ol><h2 id="4-胚胎培养及离体授粉"><a class="header-anchor" href="#4-胚胎培养及离体授粉"></a>4 胚胎培养及离体授粉</h2><h3 id="1、胚培养的作用有哪些？"><a class="header-anchor" href="#1、胚培养的作用有哪些？"></a>1、胚培养的作用有哪些？</h3><ol><li>在远缘杂交育种中的应用，克服杂种胚不能正常发育</li><li>克服珠心胚的干扰，提高育种效率</li><li>缩短育种周期</li><li>测定休眠种子的萌发率</li><li>理论研究中的应用</li></ol><h3 id="2、简述离体授粉的程序。"><a class="header-anchor" href="#2、简述离体授粉的程序。"></a>2、简述离体授粉的程序。</h3><ol><li>确定开花、花药开裂及授粉时间</li><li>去雄后将花蕾套袋隔离</li><li>制备无菌子房或胚珠</li><li>制备无菌花粉</li><li>胚珠或子房的试管内授粉</li></ol><h3 id="3、胚胎培养的操作步骤。"><a class="header-anchor" href="#3、胚胎培养的操作步骤。"></a>3、胚胎培养的操作步骤。</h3><ol><li>取子房</li><li>常规表面消毒</li><li>解剖镜下，取胚珠、去珠被、取出完整幼胚</li><li>固体培养</li></ol><h3 id="4、幼胚的发育方式"><a class="header-anchor" href="#4、幼胚的发育方式"></a>4、幼胚的发育方式</h3><ol><li>胚性发育:继续进行正常的胚胎发育</li><li>早熟发育:迅速萌发成幼苗</li><li>产生愈伤组织:再分化形成多个胚状体或芽原基。</li></ol><h3 id="5、胚胎培养的意义"><a class="header-anchor" href="#5、胚胎培养的意义"></a>5、胚胎培养的意义</h3><ol><li>克服远缘杂种的不育性</li><li>使胚胎发育不完全的植株获得后代</li><li>缩短育种年限，提高育种效率</li></ol><h2 id="5-花药和花粉培养"><a class="header-anchor" href="#5-花药和花粉培养"></a>5 花药和花粉培养</h2><h3 id="1、-如何确定水稻单核靠边期的花粉？"><a class="header-anchor" href="#1、-如何确定水稻单核靠边期的花粉？"></a>1、 如何确定水稻单核靠边期的花粉？</h3><ol><li>在水稻中，在外部形态上可根据叶枕距为5-15cm，颖片淡黄绿色、雄蕊长度接近颖片长度的1/2这些条件鉴定。</li><li>利用这些外部标志，选择符合条件的花蕾，经镜检确定花粉发育的准确时期。</li><li>压片染色法是检测划分发育时期的简便有效方法，常用染色剂为醋酸洋红。</li></ol><h3 id="2、比较花粉培养与花药培养"><a class="header-anchor" href="#2、比较花粉培养与花药培养"></a>2、比较花粉培养与花药培养</h3><p>相同点：</p><ol><li>利用小孢子染色体数目的单倍性，培育出单倍体植株。</li><li>成苗途径相同，即有 胚状体成苗 和 愈伤组织再分化成苗两条途径。</li></ol><p>不同点：</p><ol><li>花药培养属于器官培养；而花粉培养属于细胞培养。</li><li>花粉培养可避免花药壁，花丝和药隔的等体细胞组织的干扰；可计数小孢子产胚率；可观察和更好调节控制雄核发育的全过程；花粉量大，具有单细胞，单倍性和较高的同步性。但技术更复杂。</li></ol><h3 id="3、简述花粉分离方法"><a class="header-anchor" href="#3、简述花粉分离方法"></a>3、简述花粉分离方法</h3><ol><li>自然散落法(漂浮培养散落小孢子收集法)将 花药接种在预处理液或液体培养基上，待花粉自动散落后，收集培养。</li><li>挤压法在烧杯或研钵中挤压花药，将花粉挤出后收集培养。</li><li>机械游离<ul><li>磁搅拌法  用磁力搅拌器搅拌培养液中的花药，使花粉游离出来;</li><li>超速旋切法通过搅拌器 中的高速旋转刀具破碎花蕾、穗子、花药，使小孢子游离出来</li></ul></li></ol><h2 id="6-细胞培养"><a class="header-anchor" href="#6-细胞培养"></a>6 细胞培养</h2><h3 id="1、如何得到单细胞无性系？"><a class="header-anchor" href="#1、如何得到单细胞无性系？"></a>1、如何得到单细胞无性系？</h3><p>在细胞培养中，常由分散性较好的愈伤组织或悬浮培养物来制备单细胞，也可以用机械法和酶解法从植物器官直接制备单细胞。<br>由分离的单细胞经看护培养法、微室培养法或平板培养法，即可得到单细胞无性系。</p><h3 id="2、单细胞培养有哪些方法？各有何含义及特点"><a class="header-anchor" href="#2、单细胞培养有哪些方法？各有何含义及特点"></a>2、单细胞培养有哪些方法？各有何含义及特点</h3><p>单细胞培养：看护培养；微室培养；平板培养</p><ol><li>看护培养法：指用一块活跃生长的愈伤组织块来看护单个细胞，并使其生长和增殖的方法。<br>特点：优点：①简便易行 ②效果好，易于成功。<br>缺点：不能在显微镜下直接观察细胞的生长过程。<br>用途：诱导形成单细胞系。</li><li>微室培养法：即将细胞培养在很少量的培养基中。<br>特点：优点：在培养过程中，可以连续进行显微观察一个细胞的生长、分裂和形成细胞团的全部过程<br>缺点：培养时间较短<br>用途：主要用来观察细胞生长、分裂、形成细胞团的过程。</li><li>平板培养法：把单细胞悬浮液与融化的琼脂培养基均匀混合，平铺一薄层在培养基底上的培养方法。<br>特点：优点：①可以定点观察;②分离单细胞系容易;<br>缺点：培养细胞气体交换不畅。<br>用途：分离单细胞无性系，研究其生理、生化、遗传上的差异而设计的一种单细胞培养技术。广泛应用于细胞、原生质体及融合产物的培养。</li></ol><h3 id="3、什么是植板率？小细胞团的计数方法有哪几种？"><a class="header-anchor" href="#3、什么是植板率？小细胞团的计数方法有哪几种？"></a>3、什么是植板率？小细胞团的计数方法有哪几种？</h3><p>植板率是指已形成细胞团的单细胞与接种总细胞数的百分数。<br>小细胞团计数方法:</p><ol><li>低倍显微镜直接计算;</li><li>细胞团显影法</li></ol><h3 id="4、什么是细胞悬浮培养？简述成批培养和连续培养的的特点？"><a class="header-anchor" href="#4、什么是细胞悬浮培养？简述成批培养和连续培养的的特点？"></a>4、什么是细胞悬浮培养？简述成批培养和连续培养的的特点？</h3><p>细胞悬浮培养:是使离体的植物细胞悬浮在液体培养基中进行的无菌培养。</p><ol><li>成批培养的特点:<ul><li>细胞生长在固定体积的培养基上，直至养分耗尽；</li><li>用搅拌的方法使细胞团和细胞均匀分布；</li><li>细胞数目呈现慢-快一慢一停止生长的变化，但必须更换新鲜培养基才能进行下一批培养。</li></ul></li><li>连续培养的特点:<ul><li>由于不断加入新鲜培养基，保证了养分的充分供应，不会出现悬浮培养物发生营养不足的现象；</li><li>可在培养期间使细胞保持在对数生长期中。细胞增殖速度快；</li><li>适于大规模工业化生产。</li></ul></li></ol><h3 id="5、细胞悬浮培养主要应用"><a class="header-anchor" href="#5、细胞悬浮培养主要应用"></a>5、细胞悬浮培养主要应用</h3><ol><li>植物有用物质的生产：在植物组织培养研究中，发现培养细胞中含有各种特殊的代谢产物。</li><li>诱发和筛选突变体：在细胞培养过程中会产生一些突变体，常采用不同培养基来进行选择，也就是把悬浮细胞培养于缺少某种营养物质或生长因子，或是添加某种抑制剂的培养基里，使突变细胞和正常细胞区别开来</li><li>原生质体培养和细胞分离：利用细胞悬浮培养方法，对细胞原生质进行分离，在适宜的培养基上进行培养，使之生成完整植株，或对原生体的生理特性进行观察研究。</li><li>食品生产：通过对许多食用植物培养组织的细胞团生产的研究。</li></ol><h2 id="7-原生质体培养和细胞融合"><a class="header-anchor" href="#7-原生质体培养和细胞融合"></a>7 原生质体培养和细胞融合</h2><h3 id="1、简述原生质体作为遗传操作和生理生化研究的材料有何特点？"><a class="header-anchor" href="#1、简述原生质体作为遗传操作和生理生化研究的材料有何特点？"></a>1、简述原生质体作为遗传操作和生理生化研究的材料有何特点？</h3><ol><li>没有细胞壁，有利于体细胞融合、体细胞杂交、基因转移和单细胞培养。</li><li>原生质体能比较容易摄取外来的遗传物质。</li></ol><h3 id="2、酶法分离原生质体时使用的酶的种类有哪些？"><a class="header-anchor" href="#2、酶法分离原生质体时使用的酶的种类有哪些？"></a>2、酶法分离原生质体时使用的酶的种类有哪些？</h3><p>常用的细胞壁降解酶种类：纤维素酶、半纤维素酶、果胶酶、果酸酶等。</p><h3 id="3、简述一步酶法分离原生质体的方法"><a class="header-anchor" href="#3、简述一步酶法分离原生质体的方法"></a>3、简述一步酶法分离原生质体的方法</h3><p>一步分离法:把一定量纤维素酶和果胶酶组成混合酶液，对材料进行一次性处理而分离出原生质体。处理温度25-30℃，处理的时间根据材料及酶浓度的不同而不同，可为2-24h。</p><h3 id="4、如何纯化分离的植物原生质体并鉴定其活力？"><a class="header-anchor" href="#4、如何纯化分离的植物原生质体并鉴定其活力？"></a>4、如何纯化分离的植物原生质体并鉴定其活力？</h3><ol><li>原生质体的纯化<ul><li>沉降法：应用原生质体的比重大于溶液的性质而使原生质体沉于底部。</li><li>漂浮法：应用渗透剂含量较高的洗涤液使原生质体漂浮于液体表面。</li><li>梯度离心法：选两种不同渗透浓度的溶液，其中一种溶液密度大于原生质体的密度，另一种溶液小于原生质体的密度。</li></ul></li><li>原生质体活力的测定<ul><li>形态识别:形态上完整，呈圆形，含有饱满的细胞质，颜色鲜艳的即为存活的原生质体。</li><li>染色识别<ol><li>0.1%酚番红或Evans蓝染色：有活力的不被染色，死亡的被染上色。</li><li>双醋酸盐荧光素(FDA)染色法：在荧光显微镜下有荧光的即为有活性的原生质体。</li></ol></li></ul></li></ol><h3 id="原生质体培养的方法有哪些？"><a class="header-anchor" href="#原生质体培养的方法有哪些？"></a>原生质体培养的方法有哪些？</h3><ol><li>液体浅层培养</li><li>平板法培养</li><li>微悬滴法培养</li><li>双层培养法</li><li>饲养层培养</li></ol><h3 id="6、原生质体融合有哪几种主要方法？"><a class="header-anchor" href="#6、原生质体融合有哪几种主要方法？"></a>6、原生质体融合有哪几种主要方法？</h3><ol><li>化学法诱导融合:硝酸盐溶液</li><li>PEG结合高钙-高pH诱导法:在无菌条件下混合双亲原生质体——滴加PEG溶液，摇匀，静置一—滴加高钙高pH溶液，摇匀，静置——滴加原生质体培养液洗涤数次——离心获得原生质体细胞团——筛选——再生杂合细胞。</li><li>电融合技术:将双亲原生质体悬浮溶液混合后插入微电极，接通一定的交变电场，原生质体极化后顺着电场排列成珠状，此时施与适当强度的电脉冲，使原生质体膜被击穿而发生融合。</li></ol><h2 id="8-植物离体快繁和人工种子"><a class="header-anchor" href="#8-植物离体快繁和人工种子"></a>8 植物离体快繁和人工种子</h2><h3 id="1、人工种子的优点。"><a class="header-anchor" href="#1、人工种子的优点。"></a>1、人工种子的优点。</h3><ol><li>使自然条件下不易结实或种子昂贵的材料能快速繁殖和保存；</li><li>繁殖速度快；</li><li>为基因工程技术应用于生产提供桥梁；</li><li>固定杂种优势；</li><li>提高植物抗逆性；</li><li>取代天然种子，节约粮食。</li></ol><ul><li>人工种子与试管苗相比，具有所用培养基量少、体积小、繁殖快、发芽成苗快、运输及保存方便的特点;</li><li>人工种子技术适用于难以保存的种质资源、遗传性状不稳定或育性不佳的珍稀林木繁殖;</li><li>人工种子可以克服营养繁殖造成的病毒积累，可以快速繁殖脱毒苗。</li></ul><h2 id="9-植物无病毒苗木培育"><a class="header-anchor" href="#9-植物无病毒苗木培育"></a>9 植物无病毒苗木培育</h2><h3 id="1、植物脱毒的主要方法有哪些？其主要原理是什么？"><a class="header-anchor" href="#1、植物脱毒的主要方法有哪些？其主要原理是什么？"></a>1、植物脱毒的主要方法有哪些？其主要原理是什么？</h3><ol><li>茎尖培养脱毒:病毒在植物体内的分布并不均匀，越靠近茎端的病毒的感染深度越低，生长点则几乎不含或含病毒很少</li><li>愈伤组织培养脱毒法:通过植物的器官和组织的培养，脱分化诱导产生愈伤组织，然后从愈伤组织再分化产生芽，长成小植株，可以得到无病毒苗</li><li>珠心胚培养脱毒:病毒一般不通过种子传播，由珠心细胞发育成的胚再生的植株是无毒的，并具有与母本相:同的遗传特性。</li><li>茎尖微体嫁接:将实生苗砧木在人工培养基上种植培育，再从成年无病树枝上切取0.4- -1.0mm茎尖，在砧木上进行试管 微体嫁接，以获得无病毒幼苗。</li><li>热处理脱毒:一些病毒对热不稳定，在高于常温的温度下(35-40C)，即钝化失活(6)化学处理脱毒:抑制或杀死病毒</li><li>化学处理脱毒：抑制或杀死病毒</li></ol><h3 id="2、说明微尖嫁接技术脱毒的程序"><a class="header-anchor" href="#2、说明微尖嫁接技术脱毒的程序"></a>2、说明微尖嫁接技术脱毒的程序</h3><p>微尖嫁接技术指在人工培养基上培养实生砧木，嫁接无病毒茎尖以培养脱毒苗的技术。<br>主要程序:无菌砧木培养——茎尖准备——嫁接——嫁接苗培养——移栽。</p><h3 id="3、目前鉴定脱毒苗的方法有哪些？各有何特点？"><a class="header-anchor" href="#3、目前鉴定脱毒苗的方法有哪些？各有何特点？"></a>3、目前鉴定脱毒苗的方法有哪些？各有何特点？</h3><ol><li>指示植物法:将一些对病毒反应敏感、症状特征显著的植物作为指示植物(又称鉴别寄主)，利用病毒在其他植物上产生的枯斑作为鉴别病毒种类的方法。这种方法条件简单，操作方便，为一种经济而有效的鉴定方法</li><li>抗血清鉴定法:用已知抗血清鉴定未知病毒的种类。这种方法特异性高，测定速度快。所以抗血清法成为植物病毒鉴定中最有用的方法之一。</li><li>电镜检查法:可以直接观察病毒，检查出有无病毒存在，了解病毒颗粒的大小、形状和结构，又可以鉴定病毒的种类。优点是方法先进、灵敏度高、能在植物粗提取液中定量测定病毒。但需一定的设备和技术。</li></ol><h3 id="4、简述植物无病毒原种长期保存的方法。"><a class="header-anchor" href="#4、简述植物无病毒原种长期保存的方法。"></a>4、简述植物无病毒原种长期保存的方法。</h3><ol><li>低温保存:将茎尖或小植株接种到培养基上，置低温(1-9℃)、低光照下保存。材料生长极缓慢，只需半年或一年更换一次培养基，又叫最小生长法。</li><li>冷冻保存(又叫超低温保存)，一般用液氮保存植物材料。在—169℃的低温下，植物材料新陈代谢活动基本停止，处于“生机停顿”状态。</li></ol><h3 id="5、植物脱毒的意义"><a class="header-anchor" href="#5、植物脱毒的意义"></a>5、植物脱毒的意义</h3><ol><li>能够有效地保持优良品种的特性</li><li>快速繁殖品种，使优良品种迅速应用</li><li>生产无病毒种苗，防止品种退化</li><li>节约耕地，提高农产品的商品率</li><li>便于运输</li></ol><h3 id="种质保存"><a class="header-anchor" href="#种质保存"></a>种质保存</h3><h3 id="1、低温保存和超低温保存技术冷冻的方法"><a class="header-anchor" href="#1、低温保存和超低温保存技术冷冻的方法"></a>1、低温保存和超低温保存技术冷冻的方法</h3><ul><li>快速冷冻法</li><li>冷冻前的预处理</li><li>解冻方法</li><li>重新培养</li></ul><h3 id="2、冷冻保存的应用前景"><a class="header-anchor" href="#2、冷冻保存的应用前景"></a>2、冷冻保存的应用前景</h3><ol><li>长期保存种质的遗传稳定性。</li><li>长期保存去病毒的种质。</li><li>保持稀有珍贵及濒危植物的种质资源。</li><li>保持不稳定性的培养物，如单倍体。</li><li>保持培养细胞形态发生的能力。</li><li>防止种质衰老。</li><li>延长花粉寿命，解决不同开花期和异地植物杂交上的困难。</li><li>冷冻解冻过程可筛选抗逆新品种。</li><li>便于国际间的种质交换。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 生物学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 植物组织培养 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组培PPT整理</title>
      <link href="2020/12/25/%E7%94%9F%E7%89%A9%E5%AD%A6/%E7%BB%84%E5%9F%B9PPT/"/>
      <url>2020/12/25/%E7%94%9F%E7%89%A9%E5%AD%A6/%E7%BB%84%E5%9F%B9PPT/</url>
      
        <content type="html"><![CDATA[<h2 id="第1章-组培绪论"><a class="header-anchor" href="#第1章-组培绪论"></a>第1章 组培绪论</h2><h3 id="一、植物组织培养的含义"><a class="header-anchor" href="#一、植物组织培养的含义"></a>一、植物组织培养的含义</h3><p>植物组织培养的含义：指在无菌条件下，将离体的植物器官、组织、细胞或原生质体，培养在人，工配制的培养基上，人为控制培养条<br>件，使其生长、分化、增殖，发育成完整植株或生产次生代谢物质的过程和技术。</p><p>植物组织培养的概念：</p><ul><li>狭义概念：由植物组织或器官培养产生愈伤组织，经过再分化进而培养成完整植株。</li><li>广义概念：人工培养植物体一部分(即外植体) 生成完整植株。</li></ul><p>愈伤组织（callus）：则指在人工培养基上由外植体长出来的一团无序生长的薄壁细胞。</p><p>愈伤组织的特征：细胞排列疏松而无规则，是一种高度液泡化的呈无定形状态的薄壁细胞。</p><p>外植体（explant）：从植物体分离并用于离体培养的材料</p><h3 id="二、植物组织培养的类型"><a class="header-anchor" href="#二、植物组织培养的类型"></a>二、植物组织培养的类型</h3><ol><li><p>根据培养基状态分类：固体培养、液体培养、半固体培养</p><p>液体培养又分成：静止培养、旋转培养、纸桥培养、振荡培养</p></li><li><p>根据外植体分类：植株培养、器官培养、组织培养、胚培养、细胞培养、原生质体培养</p><ul><li><p>组织培养：是对植物体的各部分组织进行培养，如茎尖分生组织﹑形成层﹑木质部﹑韧皮部﹑表皮组织﹑胚乳组织和薄壁组织等等；或对由植物器官培养产生的愈伤组织进行培养，二者均通过在分化诱导形成植株。</p></li><li><p>胚胎培养：对植物的胚及胚器官进行人工离体的无菌培养，使其发育成幼苗的技术，包括胚乳培养、胚珠培养、原胚培养、种胚培养。</p><blockquote><p>原胚 ：从植物受精卵开始分裂后，至其一部分组织经过次生分化成胚时止的这一部分称为原胚。</p><p>种胚包括胚乳、子叶、胚根、胚轴、胚芽。</p></blockquote></li><li><p>胚培养主要意义：克服杂种胚的败育,获得稀有杂种 ；获得单倍体和多倍体植株 ；快速繁殖良种,缩短育种周期</p></li><li><p>细胞培养：对植物的单个细胞或较小的细胞团进行离体培养的方法。常用的细胞培养材料有性细胞，叶肉细胞，根尖细胞等。方法有：看护培养、平板培养、悬浮培养、微室培养</p></li><li><p>原生质体培养：是用酶及物理方法除去细胞壁的原生质体的培养</p></li></ul></li><li><p>根据培养过程 ：初代培养、继代培养</p></li><li><p>根据培养基的作用： 诱导培养、增殖培养 、生根培养</p></li><li><p>根据培养目的：脱毒培养、微体快繁 、试管育种、试管嫁接</p></li><li><p>根据培养条件：光培养、暗培养</p></li></ol><p>初代/诱导培养：芽、茎段、叶片、花器等外植体在离体培养条件下诱导愈伤组织、侧芽或不定芽、胚状体过程。</p><p>继代培养/增殖培养：更换新鲜培养基来繁殖同种类型的材料（愈伤组织、芽）。</p><p>生根培养：将芽苗转接到生根培养基上培养成为完整植株的过程。</p><p>驯化移栽：组培苗经人工炼苗后移栽到驯化苗床上使之适应 露地或保护地条件的过程。</p><hr><p>各种组织培养类型有何主要的异同处？</p><p>相同点：无菌操作 、人工培养基上培养</p><p>不同点：外植体不同、成苗途径与培养方法不同</p><h3 id="三、植物组织培养的特点"><a class="header-anchor" href="#三、植物组织培养的特点"></a>三、植物组织培养的特点</h3><ol><li>离体培养条件可以人为加以控制</li><li>繁殖系数大，培养周期短</li><li>管理方便，有利于实现工厂化生产和自动化控制</li></ol><h3 id="四、植物组织培养的应用"><a class="header-anchor" href="#四、植物组织培养的应用"></a>四、植物组织培养的应用</h3><p>农业上的应用</p><ol><li><p>植物脱毒和离体快繁上的应用</p><p>a. 离体快繁技术不受季节等条件限制，生长周期短，能使不能或很难繁殖的植物进行繁殖</p><blockquote><p>离体繁殖手段：</p><p>通过茎尖茎段等产生大量腋芽<br>通过根叶等器官直接诱导产生不定芽<br>通过愈伤组织培养诱导产生不定芽</p></blockquote><p>b. 脱毒培养得到的少量无病毒苗。</p><blockquote><p>植物遭受各种病毒病的危害<br>无性繁殖方法使病毒病代代相传</p></blockquote></li><li><p>在植物育种上的应用</p><p>a. 倍性培养，缩短育种年限，杂种优势明显</p><blockquote><p>用花药培养单倍体植株；纯系的获得：单倍体育种，经染色体加倍获得纯合二倍体，缩短了育种年限</p></blockquote><p>b.   克服远缘杂交的不亲和性和不孕性（胚培养）</p><blockquote><p>胚培养：受精后障碍导致远缘杂交的植物不孕，采用胚的早期离体培养可以使杂种胚正常发育，产生远缘杂交后代，从而育成新物种。</p></blockquote><p>用原生质体进行个体细胞杂交和基因转移;</p><p>c. 利用组织培养进行突变体的筛选</p><p>d. 遗传转化即基因工程方法是改良植物抗病虫抗逆  性及品质等新的重要手段。</p></li><li><p>人工种子</p><blockquote><p>人工种子的概念：指植物离体培养中产生的胚状体或不定芽，被包裹在含有养分和保护功能的人工胚乳和种皮中，从而形成能发芽出苗颗粒体。</p></blockquote><p>人工种子省去了试管苗炼苗和移栽，实现直接播种于田间</p></li><li><p>工厂化育苗</p><blockquote><p>概念：以植物培养基为基础，将外植体接种在人工配制的培养基上，通过控制环境条件，使细胞脱分化﹑再分化成新的组织﹑器官，进而培育出与母株一样的批量幼苗的方法。</p></blockquote><p>繁殖快，整齐﹑一致，无病虫害，周期短，周年生产，性状稳定。</p></li></ol><hr><p>在次生代谢产物生产上的应用</p><p>利用组织或细胞的大规模培养，可以生产人类需要的一些天然有机化合物，如蛋白质﹑脂肪﹑糖类﹑香料﹑生物碱﹑药物及其他活性物质。</p><hr><p>在植物种质资源离体保存【重要要知道】</p><p>种质资源是农业生产的基础,通过抑制生长或超低温储存的方法离体保存植物种质，可节约人力、物力和土地,挽救濒危物种。</p><h3 id="五、植物激素"><a class="header-anchor" href="#五、植物激素"></a>五、植物激素</h3><p>【激素调控难点和重点、激素配比】</p><p>植物激素(plant hormone,或phytohormone)：是指植物体内合成的，对生长发育有显著调节作用的微量小分子有机物，它们在某些组织中产生，既可以在产生它的组织中，也可运输到其它组织中发挥作用 。</p><p>植物激素的特点：</p><ul><li>内生的:植物生命过程中正常代谢产物</li><li>低浓度下（通常小于1µmol/L)起作用</li><li>能转运的，由产生部位转移到其它部位 发生作用</li><li>作用效果与浓度相关</li></ul><p>植物生长调节剂（plant growth  regulator)：人工合成的具有植物激素活性的物质称为植物生长调节剂</p><p>萘乙酸(NAA)、2,4-D与IAA作用相当；激动素（KT）、 6-BA与CTK作用类似【这4个一定要知道、还有作用】</p><h3 id="生长素"><a class="header-anchor" href="#生长素"></a>生长素</h3><p>产生的部位：分生组织、主要有胚芽鞘、叶原基、嫩叶、发育中的种子。</p><p><strong>生长素种类</strong></p><ul><li><p>植物体内的：吲哚乙酸（IAA）及其衍生物外，还有苯乙酸（PAA）、吲哚丁酸(IBA)等。</p></li><li><p>人工合成的生长素类似物： α-萘乙酸（NAA）、 2,4-二氯苯氧乙酸（2,4-D）。属于植物生长调节剂。</p></li></ul><p>生理作用与生长素类似，但不容易被降解，因此效果稳定，在生产上有广泛的应用。</p><p><strong>生长素的生理效应</strong>【重点一定要知道】</p><ol><li><p>促进营养器官的伸长。特点：①双重作用；②不同器官对IAA浓度要求不同。（低浓度促进生长，高浓度抑制生长）</p></li><li><p>控制顶端优势</p><blockquote><p>顶端优势概念：植物的顶芽优先生长，而侧芽生长受到抑制的现象。</p><p>形成原因：顶芽产生的生长素向下运输，大量地积累在侧芽的部位</p></blockquote></li><li><p>影响花与果实的发育（外施生长素防止落花落果）</p></li><li><p>促进细胞分裂和器官建成</p></li><li><p>抑制离区的形成，延缓叶子脱落。</p></li></ol><p>生长素在生产中的应用</p><ol><li><p>无性繁殖中：促进插条生根﹑促进子房发育成果实，防止落花落果。（培育无子果实）</p></li><li><p><strong>组织培养中</strong>：促进根和茎的分化，IAA与CTK共同作用【重点一定要知道】</p><blockquote><p>CTK/IAA接近，不分化<br>CTK/IAA低，促进根分化<br>CTK/IAA高， 促进芽分化形成茎﹑叶</p></blockquote></li></ol><h3 id="赤霉素类（GAs）【考研之后会遇到，只是要了解一下】"><a class="header-anchor" href="#赤霉素类（GAs）【考研之后会遇到，只是要了解一下】"></a>赤霉素类（GAs）【考研之后会遇到，只是要了解一下】</h3><p>产生的部位：未成熟的种子﹑幼叶 ﹑幼根和幼芽等</p><p>赤霉素的生理效应：</p><ol><li>促进细胞和茎（茎间）的伸长<br>与生长素的不同之处：GA----整株植物的茎伸长，IAA—切断茎段的伸长</li><li>打破种子休眠，促进种子萌发</li><li>促进开花和增强坐果</li></ol><p>赤霉素在生产中的应用</p><ol><li>茎叶的生长：蔬菜牧草茶叶等植物的叶生长。</li><li>改变果实品质：番茄葡萄长大，提高产量。如：无核葡萄品质提高：有核葡萄开花后喷施GA，无核率升高，果皮变薄糖份增加，提前成熟。</li><li>针叶树开花</li><li>打破种子和芽的休眠</li></ol><h3 id="细胞分裂素【重点，要知道】"><a class="header-anchor" href="#细胞分裂素【重点，要知道】"></a>细胞分裂素【重点，要知道】</h3><p>产生的部位：根尖，嫩梢</p><p>细胞分裂素种类：</p><p>天然细胞分裂素分为两类：</p><ul><li>一类为游离态：玉米素、   玉米素核苷(zeatinriboside)、   二氢玉米素(dihydrozeatin)、   异戊烯基腺嘌呤(isopentenyla denine，iP)等。</li><li>另一类为结合态：异戊烯基腺苷(isopentenyl adenosine，iPA)、   甲硫基异戊烯基腺苷、甲硫基玉米素等。</li></ul><p>人工合成的细胞分裂素：</p><ul><li><strong>激动素(KT)</strong>；</li><li><strong>6-苄基腺嘌呤(6-benzyl adenine,6-BA)</strong>；</li><li>四氢吡喃苄基腺嘌呤(tetrahydropyranyl benzyladenine,又称多氯苯甲酸，简称PBA)等。</li></ul><p>细胞分裂素的生理效应</p><ol><li><p>促进细胞分裂和芽的发育：IAA存在+低浓度CTK→细胞分裂<br>与生长素的不同之处：IAA促进增殖的细胞继续长大，CTK促进细胞增殖</p></li><li><p>解除顶端优势：CTK同时促进顶芽和侧芽的生长发育</p><blockquote><p>真菌寄生—分泌CTK—破坏顶端优势</p><p>CTK/IAA比值在植物顶端优势控制中十分重要</p></blockquote></li><li><p>推迟衰老和促进营养物质移动。CTK可以促进RNA和蛋白质的合成，抑制降解，延缓了衰老的过程</p></li></ol><h3 id="脱落酸（ABA）【继续研究会遇到，了解】"><a class="header-anchor" href="#脱落酸（ABA）【继续研究会遇到，了解】"></a>脱落酸（ABA）【继续研究会遇到，了解】</h3><p>产生的部位：根冠，成熟叶片等</p><p>脱落酸的生理效应：</p><ul><li>促进器官脱落：ABA促进衰老，间接促进乙烯产生，促进脱落</li><li>抑制生长和加速衰老：生长：与IAA作用拮抗，IAA诱导H+分泌使细  胞壁松弛；ABA抑制H+分泌，抑制细胞壁酸化和伸长。衰老：与CTK作用拮抗</li><li>诱导种子休眠。ABA诱导休眠，CTK拮抗ABA作用，GA解除休眠，促进萌发。</li><li>调节气孔开闭，抗干旱的信号标记。ABA  逆境激素，ABA—气孔关闭—降低蒸腾作用</li></ul><h3 id="乙烯【了解一下】"><a class="header-anchor" href="#乙烯【了解一下】"></a>乙烯【了解一下】</h3><p>产生的部位：几乎各部位都能产生乙烯，植物受到伤害后，会使乙烯生产速率增加</p><p>乙烯的生理效应：</p><ul><li>乙烯与生殖生长：诱导凤梨等瓜类植物雌性开花果实催熟</li><li>诱导脱落：乙烯是诱导脱落的主要调节物，Eth, ABA促进脱落，IAA抑制脱落</li></ul><p>“三重反应”，乙烯的典型生理反应</p><p>引起黄化豌豆幼苗三重反应：</p><ol><li>上胚轴生长（高生长）受到抑制</li><li>侧向生长增加（加粗）</li><li>上胚轴的水平生长（偏上生长）</li></ol><hr><h3 id="总结【不知道就说不过去了】"><a class="header-anchor" href="#总结【不知道就说不过去了】"></a>总结【不知道就说不过去了】</h3><p>生长素：促进生长、 促进生根、发芽</p><p>赤霉素：促进细胞伸长、促进种子萌发、果实发育，解除种子休眠</p><p>细胞分裂素：促进细胞分裂，诱导芽的分化和防止植物衰老</p><p>脱落酸：抑制细胞分裂和种子萌发、促进叶、果实衰老脱落</p><p>乙    烯：促进果实的成熟和器官脱落</p><p>促进生长发育类：生长素、赤霉素、细胞分裂素</p><p>抑制生长发育类：脱落酸、乙烯</p><p>促进器官成熟：乙烯</p><p>植物激素间的相互作用，植物体的生命活动是多种激素相互作用共同协调完成的</p><p><img src="https://pic.downk.cc/item/5ff04eea3ffa7d37b3744182.png" alt="果实成熟过程中的各种激素作用"></p><p>激素的共同作用，植物的正常生理是各种激素共同调控的结果</p><h2 id="第2章-组培的基本技术"><a class="header-anchor" href="#第2章-组培的基本技术"></a>第2章 组培的基本技术</h2><h3 id="组培实验室的组成及其功能【要知道】"><a class="header-anchor" href="#组培实验室的组成及其功能【要知道】"></a>组培实验室的组成及其功能【要知道】</h3><p><img src="https://pic.downk.cc/item/5ff04fb13ffa7d37b374b263.png" alt="组培实验室的组成"></p><p>① 准备室（基本操作实验室）</p><p>功能：用于培养器皿的清洗、培养基的配制、分装和灭菌、试管苗的出瓶及整理等工作。</p><p>②（接种室）无菌操作室</p><p>功能：植物材料的消毒、接种以   及培养物的继代转接等。操作均需要在无菌条件下进行。主要设备：超净工作台</p><p>③ 无菌操作室的消毒</p><p>【必定是重点】在培养室和操作室中，一年中要定期进行一两次熏蒸，使用的药品是（甲醛和高锰酸钾）</p><p>接种工具：定期紫外线照射杀菌，或者75%酒精喷洒杀菌</p><p>小推车：高温消毒器</p><p>④ 培养室</p><p>功能：主要用于植物材料的培养。</p><p>主要设备：培养架</p><p>环境条件：要求室内洁净并能保持一定的温度、光照以及湿度以适合植物材料的生长和分化。</p><p>⑤ 温室</p><p>功能：驯化</p><p>试管苗炼苗，试管苗移栽</p><h3 id="基本仪器和设备"><a class="header-anchor" href="#基本仪器和设备"></a>基本仪器和设备</h3><p>天平、电子天平：精度高，称量快；放置地点选择干燥，平稳，无腐蚀药品</p><p>分析天平：精度为0.0001g，用来称取微量元素和植物生长调节物质及微量附加物</p><p>冰箱和冰柜：某些试剂，药品和母液需要低温保存；有些材料需要低温处理</p><p>烘箱：迅速干燥， 干热灭菌</p><p>恒温箱：原生质体或酶制剂的保存</p><p>培养箱</p><p>显微镜：</p><ul><li>双目体视显微镜：剥取茎尖，隔瓶观察内部植物组织生长情况</li><li>倒置显微镜：可从培养器皿的底部观察培养物，如液体培养物的观察</li><li>生物显微镜：观察花粉发育时期及培养过程种细胞核的变化等</li></ul><p>酸度计（或pH试纸）</p><p>蒸馏水器</p><p>微波炉</p><p>高压蒸汽灭菌锅：用于培养基、蒸馏水和接种器械的灭菌消毒</p><blockquote><p>工作原理：在密闭的蒸锅内，0.1MPa的压力下，锅内温度达121℃。在此蒸气温度下，可以很快杀死各种细菌及其高度耐热的芽孢。</p></blockquote><p>超净工作台</p><p>摇床</p><h3 id="培养器皿及实验用具"><a class="header-anchor" href="#培养器皿及实验用具"></a>培养器皿及实验用具</h3><p>镊子：摄取植物组织和分离茎尖，叶片表皮等</p><p>剪刀：用于试管内剪取茎段，进行继代培养的转接</p><p>解剖刀、接种针、搁物架、酒精灯、紫外杀菌灯</p><p>细菌过滤器：用于加热易分解，丧失活性的生化试剂的灭菌</p><p>紫外线杀菌灯：用于接种室，超净台，培养室等环境的杀菌</p><h3 id="培养基"><a class="header-anchor" href="#培养基"></a>培养基</h3><p>培养基：是植物组织培养中最主要的部分，是植物组织培养的物质基础</p><p><strong>培养基的成分</strong>【要知道，大量元素微量元素有哪些，单独配置】：</p><p>1 水（离子交换水，蒸馏水，重蒸馏水），原因：保持母液及培养基成分的准确性， 防止储存过程中发霉变质</p></br><p>2 无机成分：植物生长的必须元素，缺乏后其生长不正常</p><ul><li><p>大量元素化合物：浓度 &gt; 0.5mmol/L  N,P, K, Ga, Mg, S</p></li><li><p>微量元素化合物 ：浓度 &lt; 0.5mmol/L  B, Mn, Zn, Cu, Mo, Co, Cl, Fe</p><blockquote><p>铁盐容易发生沉淀，<strong>需要单独配制</strong>，一般与Na2EDTA相互配</p></blockquote></li></ul></br><p>3 有机成分：</p><ul><li><strong>糖类</strong>【功能要知道】：碳源及维持培养基一定的渗透压,蔗糖是最好的碳源，葡萄糖和果糖次之。</li><li>维生素类【了解一下】：以辅酶形式参与多项代谢活动，对生长和发育有促进作用</li><li><strong>氨基酸类</strong> 【氮源要知道】：蛋白质组成，优质有机氮源，促进细胞生长分化</li><li>肌醇：参与碳水化合物代谢磷脂代谢等生理活动，促进愈伤组织生长，胚状体及芽的形成</li></ul></br><p>4 天然有机添加物质【了解一下】：对增殖和分化有明显的促进作用，对难培养的材料有特殊的作用</p><ul><li>椰汁：对愈伤组织和细胞培养有促进作用</li><li>马铃薯汁：多用于壮苗的培养</li><li>香蕉泥（汁）：主要应用在兰花组织培养中</li><li>水解酪蛋白：蛋白质的主要成分</li><li>麦芽提取液：预热较稳定，培养困难时使用</li></ul><blockquote><p>弊端：成分差异将会影响实验的重复性</p></blockquote></br><p>5 植物生长调节物质：</p><p>5.1 生长素类 【一定要知道】：主要被用于诱导愈伤组织形成；诱导根的分化和促进细胞分裂，伸长生长。</p><p>【一定要知道】组织培养中常用的生长素：吲哆乙酸（IAA），2，4-二氯苯氧乙酸（2,4-D），吲哆丁酸（IBA），萘乙酸（NAA），它们的作用<strong>强弱顺序</strong>为<u>2,4-D</u>&gt;<u>NAA</u>&gt;<u>IBA</u>&gt;<u>IAA</u>。</p><p>培养基中<strong>常用浓度</strong>：0.1～10mg/L</p><p>2，4-D有强烈的愈伤组织诱导能力，但抑制芽的形成。</p><p>NAA广泛用于生根</p><p>5.2 细胞分裂素类</p><p>在组培中的作用：促进细胞分裂和分化，诱导胚状体和不定芽的形成，延缓组织的衰老和蛋白质的合成</p><p>用于芽的诱导和继代增殖培养</p><p>常用类型：<strong>6-BA，激动素（KT）</strong>，异戊烯基腺嘌呤（2-ip） ，噻重氮苯基脲（TDZ），玉米素（Zt）， 6-苄基腺嘌呤（BAP）</p><p>细胞分裂素中作用最强的是<u>TDZ</u>。</p><p>培养基中常用浓度： 0.1～10mg/L</p><p>5.3 赤霉素类【了解一下】</p><p>在组培中的作用：在组织培养中不常使用，主要促进幼苗茎的伸长生长，促进不定胚发育成小植株。组培中主要用GA<sub>3</sub></p><p>5.4 脱落酸（ABA）【了解一下】</p><p>在组培中的作用：对于体细胞胚的发生和发育起重要的作用，也常用于植物培养物及种质资源的保存</p><p>5.5 多效唑</p><p>在组培中的作用：多用于试管苗的壮苗，生根，提高抗逆性和栽培成活率。</p></br><p>6 培养基的pH值【一定要知道】</p><p>灭菌前pH值<strong>调控范围</strong>：pH=5.0～6.0</p><p>pH对培养基凝固的影响：<strong>高6.0会变硬，低于5.0凝固效果不好</strong></p><p>pH调节剂：HCl、NaOH</p></br><p>7 凝固剂—琼脂（一定要加热至溶解）【不用说也知道】</p><p>用量范围：0.4%～1.0%<br>影响琼脂凝固的因素：厂家的加工方式； 灭菌的时间，温度，PH值； 存放的时间</p></br><p>8 活性炭【功能了解一下】</p><ul><li>附培养基及培养物分泌物中的抑制物质</li><li>抑制外植体褐变</li><li>防止玻璃苗的产生</li><li>促进培养物生长和分化</li><li>促进生根</li></ul><p>缺点：会吸附培养基中的生长调节物</p></br><p>9 抗生素【要知道不耐热，要过滤灭菌】</p><p>防止外植体内生菌造成的污染</p><p><strong>不耐高温，需单独过滤灭菌</strong></p><h3 id="培养基的种类【要知道一下】"><a class="header-anchor" href="#培养基的种类【要知道一下】"></a>培养基的种类【要知道一下】</h3><p>根据培养基营养水平不同【差别要知道】</p><p>基本培养基：指只含有维持离体植物细胞基本生命活动所需的营养成分的培养基。通常包括水分、无机营养成分和有机营养成分，不包括激素和天然有机附加物。</p><p>完全培养基：指在基本培养基的基础上另外附加激素或天然有机附加物所组成的培养基。</p><hr><p>基本培养基的种类【要知道】</p><ol><li><p>高无机盐含量的培养基【不要到时候说，高无机盐含量的培养基是什么，大家都不知道啊】代表类型：MS培养基，ER培养基</p><blockquote><p>MS培养基：无机盐浓度高，高含量的氮、钾，尤其是硝酸盐，含有一定数量的铵盐，营养丰富，不需要添加更多的有机附加物</p><p>是植物组织培养中大多数植物都适用的培养基</p></blockquote></li><li><p>硝酸钾含量较高的培养基【代表也要知道】代表类型：B5，N6</p><blockquote><p>B5培养基：主要用于木本植物，十字花科植物；含有较低的铵盐；较高的硝酸盐和盐酸硫胺素（VB1）</p><p>N6培养基 ：适用于单子叶植物的花药培养；KNO<sub>3</sub>和（NH<sub>4</sub>）SO<sub>4</sub>含量高，不含钼</p></blockquote></li><li><p>中等无机盐含量的培养基代表类型：Miller(M)培养基1965，Nitsch(N)培养基1963，H培养基1967</p><blockquote><p>特点：大量元素为MS培养基的1/2，适合花药培养</p></blockquote></li><li><p>低等无机盐含量的培养基代表类型：White，WS</p><blockquote><p>特点：大量元素为MS培养基的1/4，适合生根培养<br>White培养基：无机盐浓度较低；使用广泛；在生根培养、胚胎培养中有良好的效果</p></blockquote></li></ol><hr><p>特征：不同种的植物对营养需求不同，同一种的不同部位对营养需求也不同，没有任何一种培养基适用于所有情况下的组织培养。</p><p>选择：要考虑外植体种类，器官类型及培养目的，有针对性的选择适宜的培养基</p><p>改良：建立一个新的实验体系，先由一种广泛使用的基本培养基开始，对培养基成分进行定性和定量的变动</p><h3 id="培养基的配制【一定要知道，计算题】"><a class="header-anchor" href="#培养基的配制【一定要知道，计算题】"></a>培养基的配制【一定要知道，计算题】</h3><p>1 贮备液（母液）的配制</p><blockquote><p>为什么要配制母液：方便；准确（有些成分量太小）</p></blockquote><p>母液配制注意的问题</p><ol><li>几种试剂混合配制时要按一定顺序将各种溶液混合。</li><li>在配制母液时应注意防止产生沉淀,如Ca<sup>2+</sup>和SO<sub>4</sub><sup>2+</sup> , Ca<sup>2+</sup>、Mg<sup>2+</sup>和PO<sub>4</sub><sup>2+</sup> 一起溶解后,会产生沉淀。</li><li>应采用纯度等级较高的分析纯或化学纯。</li><li>要用纯度较高的蒸馏水或去离子水。</li><li>母液一旦出现沉淀或有可见微生物的污染，应立即停止使用，重新配制。</li></ol><p>配制母液流程：计算、称量、加成分溶解、混合定容、测pH、贴标签、冰箱贮存</p><p>2 培养基的配制</p><p>基本培养基配方中物质划分组数的多少，即配制母液数的多少可根据实际情况而定，如MS培养基可以配制三液式、四液式、五液式等；</p><p>培养基的选择：因材料和种类而异，参考前人的研究，MS培养基最为基本，高浓度的N、K</p><p>MS培养基四液式为例</p><ul><li>大量元素母液（浓缩10倍）在配制1L培养培养基时，只取100ml</li><li>微量元素母液（浓缩100倍）在配制1L培养培养基时，只取10ml</li><li>铁盐母液（浓缩100倍）常用的铁盐（FeSO<sub>4</sub>·7H<sub>2</sub>O）不易被植物吸收利用，与EDTA单独配成螯合物母液</li><li>有机营养成分母液（浓缩100倍）</li></ul><p>培养基的配制流程【要了解一下】</p><p>准备→将水、母液和糖混合定容→调pH→加入琼脂→加热溶解→分装到已经清洗干燥的培养器皿中→封口→标记→高压蒸汽灭菌→冷却→凝固→接种</p><p>灭菌</p><p>灭菌操作对象：培养环境，培养基，外植体及接种工具灭菌等</p><p>物理灭菌：</p><ul><li>干热灭菌（如烘烤和灼烧）</li><li>湿热灭菌（如常压或高压蒸煮）</li><li>射线灭菌（如紫外线，超声波或微波处理）</li><li>过滤灭菌（如空气过滤和液体过滤）</li></ul><p>化学灭菌：</p><ul><li>浸泡灭菌（如外植体灭菌）</li><li>喷雾灭菌，熏蒸灭菌（培养室等场所喷雾或熏蒸）</li></ul><p>培养基的灭菌为例</p><p>高温高压蒸气灭菌</p><p>灭菌锅内添加适量水→加热→排尽冷空气→关闭放气阀→当压力表指针达 121°C，1.1~1.2kg/cm<sup>2</sup>，压力不要超过0.15MP →维持15-20分钟即可关闭电源，时间过长，培养基成分易变性失效</p><p>过滤灭菌</p><p>在高温高压下易分解的培养基和激素类</p><p>注意：灭菌方法和药剂要根据不同材料不同目的适当选用</p><hr><p>培养基的保存</p><p>灭菌后的培养基经冷却和凝固后即可使用检验灭菌效果。</p><p>检验方法：将培养基置于培养室中3天，若没有污染现象，说明灭菌可靠，可以使用。</p><ul><li>保存在低温条件下。常温下保存时要进行防尘和避光处理。</li><li>保存时间不可过长。</li></ul><hr><p>思考题：</p><ol><li>培养基中的主要成分有哪几类？</li><li>培养基中常添加的植物生长调节物质有哪两大类？各包括哪些常用种类？培养基中使用浓度范围？</li><li>培养基中经常加入的生长素类和细胞分裂素类物质各有何作用？这两类激素的使用规律如何？</li><li>母液配制流程？</li></ol><hr><p>外植体</p><p>外植体的种类选择</p><p>外植体：从植物体分离并用于离体培养的材料。</p><p>植物组织培养的理论基础：植物细胞的全能性</p><p>实现全能性的差异：</p><ul><li>同一植株各个不同部位的组织，器官有差异</li><li>生殖细胞＞体细胞</li><li>分生组织细胞＞分化细胞</li></ul><hr><p>选择优良的基因型 ：基因型是控制愈伤组织形态建成的关键。不同物种的外植体诱导的愈伤组织器官分化明显不同，如烟草、胡萝卜、苜蓿等较易发生器官分化，而禾本科（禾谷类）、豆类、棉花等的愈伤组织形态建成相对较难。同属不同种，甚至同一物种不同品种的愈伤组织器官分化的能力也不同。根据目的，选择优良的基因型，提高成功率外植体的增殖能力：植物组织细胞的脱分化能力，营养生长中心&gt;形成层&gt;薄壁细胞&gt;厚壁细胞&gt;退化细胞</p><p>外植体大小：胚胎培养或脱毒，外植体宜小； 若快速繁殖，外植体宜大；但过大杀菌不彻底，过小难以长活。一般在5~10mm为宜</p><p>选择外植体的季节和时间 ：在生长季节取材，较幼嫩的外植体培养容易；秋冬季取材需要处理，夏季，雨季取材不容易灭菌成功</p><p>外植体的生理状态和发育年龄：越幼嫩，年限越短的组织具有较高的形态发生能力；同株植物，较低部位外植体比上部的外植体容易启动，培养成功可能性大。</p><hr><p>外植体的消毒</p><p>原因：外植体多取材于田间，材料含微生物，不能直接培养</p><p>外植体的消毒原则：</p><ul><li>充分灭菌，但不能损伤外植体</li><li>不同外植体，灭菌要求不一样</li></ul><p>影响外植体消毒效果的因素：</p><ul><li>消毒剂种类</li><li>消毒剂使用浓度</li><li>消毒处理时间</li></ul><p>常用消毒剂</p><p>适用外植体、实验器皿、操作表面、皮肤等。几种常用消毒剂的效果比较</p><table><thead><tr><th>消 毒 剂</th><th>使用浓度(%)</th><th>消毒时间(min.)</th><th>效 果</th><th>残液去除难易</th></tr></thead><tbody><tr><td><strong>乙醇</strong></td><td>70~75</td><td>0.1~3</td><td>好</td><td>易</td></tr><tr><td>新洁尔灭</td><td>10~20</td><td>5~30</td><td>好</td><td>易</td></tr><tr><td><strong>氯化汞</strong></td><td>0.1~1</td><td>2~15</td><td>最好</td><td>最难</td></tr><tr><td>过氧化氢</td><td>10~12</td><td>5~15</td><td>较好</td><td>最易</td></tr><tr><td>抗菌素</td><td>4~50mgl-1</td><td>30~60</td><td>较好</td><td>较难</td></tr><tr><td><strong>次氯酸钙/钠</strong></td><td>10~20</td><td>5~30</td><td>好</td><td>易</td></tr></tbody></table><p>常用方法</p><ul><li>75%乙醇，表面杀菌，具湿润和杀菌作用，浸30秒</li><li>氯化汞（升汞），常用浓度0.1%处理5~10分钟，有残毒</li><li>次氯酸钠，浓度10-20%，时间15-30分钟，对植物无害</li></ul><p>外植体表面消毒操作前的准备工作：</p><ul><li>无菌水、漂洗瓶、切割用器皿（玻璃培养皿或不锈钢切割盘）和金属器具均经过高温高压灭菌并整齐摆放在超净工作台上。</li><li>消毒剂配制好并整齐摆放在超净工作台上。</li></ul><p>外植体表面消毒的一般过程：</p><p>外植体取材→预处理→无菌条件下，70%酒精表面消毒30s~60s→无菌条件下，消毒剂处理→无菌水充分漂洗3~5次→备用</p><hr><p>外植体灭菌</p><p>茎尖，茎段及叶片等的消毒：自来水较长时间的冲洗，用软毛刷刷洗，硬质材料用刀刮，然后冲洗，冲洗后可用肥皂，洗衣粉或吐温等进行洗涤．消毒时用70％的酒精浸泡数秒钟，用无菌水冲洗2~3次，然后用10%~20 ％的次氯酸钠溶液浸泡10~20分钟，若材料有毛最好在消毒液中加入几滴吐温 ，消毒后用无菌水冲洗3~4次。</p><p>果实及种子的消毒：用自来水冲洗10~20分钟，果实用20％次氯酸钠溶液浸泡10分钟，种子浸泡20~30分钟，对难消毒的可用0.1％升汞或1％~2％溴水消毒5分钟，再用无菌水冲洗3~4次。</p><p>花药的消毒：由于花药的外面有花萼，花瓣或颖片保护，通常处于无菌状态，只将花蕾或幼穗消毒，用70％酒精浸泡数秒钟后，用无菌水冲洗3~4次，再在漂白粉清液中浸泡10分钟，经无菌水冲洗3~4次，可接种。</p><p>根及地下部器官的消毒：用自来水洗→用毛刷刷洗→洗水纸吸干后→再用70％酒精消毒→用无菌水冲洗→用0.1％或0.2％升汞浸5~10分钟→然后用无菌水冲洗3次。</p><hr><p>培养过程中污染原因及对策</p><ul><li>污染的病原类型</li><li>污染发生原因</li><li>防污染对策</li></ul><p>污染：污染原因从病源方面主要有细菌和真菌两大类。</p><p>造成污染的病原菌主要包括外部污染菌和内源菌。</p><ul><li>外部污染菌：主要由外植体带菌或培养基灭菌不彻底以及操作人员操作不慎造成。</li><li>内源菌：外植体带菌引起的污染与外植体的种类、取材季节、部位、预处理及消毒方法等密切相关。</li></ul><p>原因：</p><ol><li>外植体材料消毒不彻底</li><li>培养基灭菌不彻底</li><li>操作环境不洁净</li><li>操作人员操作不规范、不熟练。</li></ol><p>预防措施：</p><ol><li>减少或防止材料带菌，取材时应选择嫩梢，新芽或胚作为外植体材料</li><li>外植体灭菌要彻底</li><li>培养基灭菌要彻底</li><li>玻璃器皿和金属器皿的灭菌要彻底</li><li>无菌室的消毒</li><li>操作人员一定要严格按照无菌操作的程序进行接种。</li></ol><hr><p>外植体的培养</p><p>外植体的接种</p><p>定义：是把经过表面消毒后的材料切碎或分离出器官将其转放到无菌培养基上的全过程。</p><p>整个操作过程要求在无菌条件下进行．污染主要是由细菌和工作人员引起的．因此要求工作人员在操作过程中遵守无菌操作规则。</p><p>外植体接种的无菌操作：</p><ol><li>进入接种室前，要用肥皂或洗手液洗手，去掉指甲中的污物。</li><li>接种室用70%酒精喷施，超净台用紫外灯照射20min</li><li>操作中要经常用70%酒精擦洗手。</li><li>把所要培养的材料、无菌水、70%的乙醇、镊子、剪刀、消毒液等放在消过毒的工作台上。</li><li>每次重新操作都要把工具在火焰上消毒。</li><li>必须在酒精灯火焰处进行操作，盖瓶盖或封口膜封盖前应将瓶口在火焰上烧一下，然后盖上。</li><li>转接后，写上培养基名、材料名、接种时间,然后移入培养室。</li></ol><p>外植体接种的具体步骤：切割外植体→培养瓶倾斜靠近酒精灯火焰→瓶盖外部在火焰上旋转灼烧数秒钟→旋开瓶盖，放在酒精灯旁边→瓶口在火焰上旋转灼烧数秒钟→用无菌镊子将外植体均匀放置在培养基上→瓶盖在火焰上灼烧两圈→盖紧瓶盖</p><p>整个接种操作应在近火焰处进行，且动作要迅速</p><p>防止操作带来的污染，接种过程中尽可能达到悬空要求</p><p>接种时不得用手接触瓶盖内壁或瓶口</p><p>瓶盖朝上放，接种完毕后立即盖好瓶口</p><p>接种完一瓶用火烧用具以防止交叉污染产生</p><p>接种茎段：注意形态学下端插入培养基内，而形态学上端露于空气中</p><blockquote><p>在形态学上，分生迅速，向上或者向下延伸的是上端; 分生缓慢，不延伸或者延伸很少的是下端。对于地上部分而言，树枝是形态学上端，而树干是形态学下端。 对于地下部分而言，根尖是形态学上端，根基是形态学下端。</p></blockquote><hr><p>愈伤组织培养(callus culture)</p><p>定义:  将外植体接种到人工培养基上，在激素作用下，进行愈伤组织诱导、生长和分化的培养过程。</p><p><strong>愈伤组织</strong>，在组织培养过程中，沿用了这一名称，实际上是指外植体在离体培养条件下，形成的一团没有分化、又能旺盛分裂的薄壁细胞团，是组织培养过程中经常出现的一种组织状态。</p><p>愈伤组织的继代培养</p><p>定义：培养物在培养基上生长一段时间以后，由于营养物质枯竭，水分散失，以及代谢产物的积累，必须转移到新鲜培养基上培养,这个过程叫做继代培养。</p><p>通过继代培养，可使愈伤组织无限期地保持在不分化的增殖状态。然而，如果让愈伤组织留在原培养基上继续培养而不继代，它们则不可避免地发生分化，产生新的结构。</p><p>愈伤组织保持与继代培养</p><p>愈伤组织保持时间：已诱导并建立起来的愈伤组织可以长期保存，如有报道大豆细胞系的愈伤组织在24℃和弱光下已保持15年。</p><p>愈伤组织生长周期：愈伤组织生长周期为2-3周。一般2-3周继代一次。</p><p>继代时应注意愈伤组织分割。</p><p>继代时间与植株再生能力及变异：以往研究认为继代时间长再生能力减弱甚至丧失，但目前多数研究认为长期继代培养的愈伤组织仍有再生能力。</p><hr><p>外植体的褐变</p><p>外植体褐变是指在接种后，其表面开始褐变，有时甚至会使整个培养基褐变的现象。</p><p>它的出现是由于植物组织中的多酚氧化酶（PPO）被激活，而使细胞的代谢发生变化所致。</p><p>在褐变过程中，会产生醌类物质，它们多呈棕褐色，当扩散到培养基后，就会抑制其他酶的活性，从而影响所接种外植体的培养。</p><p>褐变的主要原因：</p><ul><li>植物品种  在不同品种间的褐变现象不同。多酚氧化酶活性上的差异。因此，在培养过程中应该有所选择，对不同的品种分别进行处理。</li><li>生理状态  由于外植体的生理状态不同，所以在接种后褐变程度也有所不同。一般幼龄期的植物材料褐变程度较浅，成年的植株采收的外植体，由于含醌类物质较多，因此褐变较为严重。幼嫩的组织在接种后褐变程度并不明显，老熟的组织较为严重。</li><li>培养基成分  浓度过高的无机盐会使某些观赏植物的褐变程度增加，此外，细胞分裂素的水平过高也会刺激某些外植体的多酚氧化酶的活性，从而使褐变现象加深。</li><li>培养条件不当  如果光照过强、温度过高、培养时间过长等，均可使多酚氧化酶的活性提高，从而加速被培养的外植体的褐变程度。</li></ul><p>减轻褐变现象发生的方法</p><ul><li>选择合适的外植体  一般来说，最好选择生长处于旺盛的外植体，这样可以使褐变现象明显减轻。</li><li>合适的培养条件  无机盐成分、植物生长物质水平、适宜温度、及时继代培养均可以减轻材料的褐变现象。</li><li>使用抗氧化剂  在培养基中，使用半胱氨酸、抗坏血酸、PVP等抗氧化剂能够较为有效地避免或减轻很多外植体的褐变现象。另外，使用0.1%~0.5%的活性炭对防止褐变也有较为明显的效果。</li><li>连续转移  对容易褐变的材料可间隔12~24h的培养后，再转移到新的培养基上，这样经过连续处理7~10d后，褐变现象便会得到控制或大为减轻。</li></ul><hr><p>继代培养时材料的玻璃化</p><p>植物组织培养中，常会出现一些半透明状的畸形试管植物，培养物的嫩茎、叶片往往会呈半透明水渍状, 这类植物体被称为“玻璃苗”，这种现象称为玻璃化现象，又称过度水化现象。</p><p>因为出现玻璃化的嫩茎不宜诱导生根，因此，使繁殖系数大为降低。使试管苗生长缓慢、繁殖系数有所下降。玻璃化为试管苗的生理失调症。</p><p>在不同的种类、品种间，试管苗的玻璃化程度也有所差异。当培养基上细胞分裂素水平较高时，也容易出现玻璃化现象。在培养基中添加少量聚乙烯醇、脱落酸等物质，能够在一定程度上减轻玻璃化的现象发生。</p><p>呈现玻璃化的试管苗，其茎、叶表面无蜡质，体内的极性化合物水平较高，细胞持水力差，植株蒸腾作用强，无法进行正常移栽。这种情况主要是由于培养容器中空气湿度过高，透气性较差造成的，其具体解决的方法为：</p><ul><li>增加培养基中的溶质水平，以降低培养基的水势；</li><li>减少培养基中含氮化合物的用量；</li><li>增加光照；</li><li>增加容器通风，最好进行CO<sub>2</sub>施肥；</li><li>降低培养温度，进行变温培养，有助于减轻试管苗玻璃化的现象发生；</li><li>降低培养基中细胞分裂素含量，可以考虑加入适量脱落酸。</li></ul><hr><p>继代培养时材料的无性系变异</p><p>一个体细胞无性系在培养过程中出现的不同于原始无性系的表现称为体细胞无性系变异</p><p>分类：培养细胞的变异，愈伤组织的变异及再生植株的变异</p><p>应用前提：具有优良性状变异，代代遗传</p><hr><p>外植体的培养条件</p><ul><li>温度  20~30度</li><li>光照  12~16h  强度1000~5000lx</li><li>湿度  70%~80%</li><li>通气</li></ul><hr><p>思考题：</p><ol><li>选择外植体需要注意哪些方面</li><li>外植体污染原因？</li><li>污染的病原类型？</li><li>防污染对策？</li><li>常用消毒剂及外植体的消毒步骤？</li><li>继代培养定义？</li><li>何为外植体的褐变，减轻外植体褐变的方法？</li></ol><h2 id="第三章-组培基本理论"><a class="header-anchor" href="#第三章-组培基本理论"></a>第三章 组培基本理论</h2><ol><li>细胞全能性理论</li><li>根芽激素理论</li><li>组培苗的遗传稳定性</li></ol><h3 id="细胞全能性理论"><a class="header-anchor" href="#细胞全能性理论"></a>细胞全能性理论</h3><p>​       植物每一个具有完整细胞核的体细胞，都含有植物体的全部遗传信息，在适当条件下，具有发育成完整植株的潜在能力。</p><p>细胞全能性概述：</p><ol><li>细胞全能性的绝对性与相对性：<ul><li>不是所有基因型的所有细胞在任何条件下都具有良好的培养反应；</li><li>即使对于植物细胞而言，细胞全能性也并不意味着任何细胞均可以直接产生植物个体;</li></ul></li><li>动、植物细胞全能性的表现程度存在明显的差异。</li></ol><p>不是任何细胞均可以直接产生植物个体;</p><p>植物细胞按照分裂能力分为三类：</p><ol><li>周期性细胞：从一个周期进入另一个周期的周期细胞始终保持分裂能力，如茎尖、根尖及形成层细胞</li><li>终端分化细胞：永久失去分裂能力的细胞，如筛管、导管、气孔保卫细胞等特化细胞；</li><li>G<sub>0</sub>细胞：在通常情况下不分裂，但在受到外界刺激后可重新启动分裂的。表皮细胞及各种薄壁细胞。</li></ol><p>植物细胞全能性表现根据细胞类型不同从强到弱：营养生长中心 &gt; 形成层 &gt; 薄壁细胞 &gt; 厚壁细胞(木质化细胞) &gt; 特化细胞(筛管、导管细胞)</p><p>植物细胞全能性表达的条件：</p><ol><li>体细胞与完整植株分离，脱离完整植株的控制</li><li>创造理想的适于细胞生长和分化的环境（主要是激素的作用）</li></ol><p><img src="https://pic.downk.cc/item/5ff57d283ffa7d37b3a3253a.png" alt="细胞全能性的实现与利用"></p><p>细胞全能性的实现</p><p>细胞实现全能性的过程：通过脱分化和再分化两个阶段。</p><p>在大多数情况下，脱分化是细胞全能性表达的前提，再分化是细胞全能性表达的最终体现。</p><p>基本定义：</p><ul><li>分化（differentiation）：分化是指个体发育过程中，不同部位的细胞形态结构和生理功能发生改变，形成不同组织或器官。</li><li>脱分化（dedifferentiation）:已分化好的细胞在人工诱导条件下，恢复分生能力，回复到分生组织状态的过程。</li><li>再分化（redifferentiation）:脱分化后具有分生能力的细胞再经过与原来相同的分化过程，重新形成各类组织和器官的过程。</li></ul><hr><p>细胞脱分化</p><p>细胞生理与结构变化</p><p>细胞脱分化调控机理</p><p>细胞分裂与愈伤组织形成</p><p>细胞脱分化过程中生理和结构变化</p><p>培养条件下使一个已分化的细胞回复到原始无分化状态或分生细胞状态的过程就是细胞脱分化。<br>离体培养下，脱分化过程发生在第一次有丝分裂之前</p><p>薄壁细胞：细胞核较小，核位于细胞边缘，细胞中央有大的液泡，多聚核糖体数目较少，质体为分化程度较高的叶绿体、杂色体、白色体和淀粉体。</p><p>脱分化细胞：细胞质显著变浓，  大液泡消失，  核体积增加并逐渐移位至细胞中央，细胞器增加。</p><ul><li>中央大液泡 → 消失(出现蛋白体)</li><li>核小，位于边缘 → 体积增大，移至中央</li><li>叶绿体 → 原质体(基粒片层解体出芽)</li><li>细胞质密度低 → 内膜细胞器显著增加，胞质变浓</li><li>其中，液泡消失和叶绿体的转变是脱分化的重要特征。</li></ul><p>脱分化的过程</p><p>根据脱分化细胞过程中细胞结构发生变化的时空顺序，细胞的脱分化过程可分为3个阶段：</p><ul><li>第一阶段为启动阶段，表现为细胞质增生，并开始向细胞中央伸出细胞质丝，液泡蛋白体出现；、</li><li>第二阶段为演变阶段，此时细胞核开始向中央移动，质体演变成原质体；</li><li>第三阶段为脱分化终结期，细胞回复到分生细胞状态，细胞分裂即将开始。</li></ul><hr><p>细胞脱分化的调控机理</p><ul><li>细胞周期对脱分化的调控</li><li>激素诱导表达基因与细胞脱分化</li><li>细胞脱分化与染色体解凝聚</li><li>促分裂肽的发现及其对细胞脱分化的影响</li></ul><p>细胞周期与脱分化</p><ul><li>成熟细胞脱分化成为分生组织细胞，需要进入细胞周期。</li><li>植物分裂细胞从G<sub>1</sub>期到G<sub>2</sub>期脱离细胞周期进入分化。</li><li>同样分化细胞脱分化也从G<sub>1</sub>期到G<sub>2</sub>期进入细胞周期。</li><li>分化细胞能否脱分化进入细胞周期，取决于其分化程度和原初的生理状态 。</li></ul><p>植物激素与脱分化（关键）</p><ul><li>生长素类：IAA、NAA、2,4-D、IBA</li><li>细胞分裂素类：KT、6-BA、ZT、2ip</li><li>赤霉素类：GA3</li><li>脱落酸：ABA</li><li>乙烯：ACC</li></ul><p>促进生长发育类：生长素、赤霉素、细胞分裂素<br>抑制生长发育类：脱落酸、乙烯</p><p>植物激素诱导表达的一些基因，其产物启动了细胞的脱分化。</p><p>植物激素不直接作用于DNA，而是通过其受体蛋白的信号转导途径起作用。</p><p>脱分化结果</p><ul><li>细胞脱分化是细胞状态的改变，成功的脱分化绝大多数情况下导致细胞的分裂，通过分裂形成愈伤组织。</li><li>有些外植体的细胞脱分化以后直接形成胚性细胞进而形成体细胞胚。</li><li>在极少数情况下脱分化细胞会不经分裂直接分化形成其他类型的细胞。(转分化)</li></ul><hr><p>细胞脱分化与愈伤组织形成</p><ul><li>细胞脱分化是细胞状态的改变，但成功的脱分化必然会导致细胞分裂。</li><li>对于单个细胞而言，分化细胞启动分裂发生在细胞完全脱分化之后。</li><li>细胞初期分裂方式与外植体细胞类型有关，如果外植体细胞均为正常二倍体细胞，第一次分裂通常是有丝分裂，如果外植体含有高倍化细胞，脱分化的第一次分裂可能是无丝分裂。</li></ul><p>器官，组织培养时细胞分裂首先发生在伤口部位，形成愈伤组织</p><p>脱分化结果：细胞→具备了分裂能力→细胞不断增殖→愈伤组织的生长</p><p>流程：获取外植体 → 无菌接种 → 脱分化诱导愈伤组织的形成 → 扩大培养 → 再分化试管苗的形成 → 移栽</p><p>愈伤组织的产生原因：</p><ul><li>内因： 内源激素，材料被切伤后分泌的伤源激素</li><li>外因：外源生长调节剂，人为在培养基内加入激素</li></ul><p>愈伤组织的形成 分为诱导期、分裂期和分化期</p><p>诱导期（Induction）：是成熟组织在各种刺激因素的诱导下细胞内蛋白质及核酸的合成代谢迅速加强的过程。是愈伤组织形成起点，又叫启动期。</p><p>诱导愈伤组织的关键主要是培养条件，其中激素的成分和浓度是最重要的因素。</p><p>诱导期细胞内发生的变化：</p><ul><li>呼吸作用加强，如氧气的吸收增加</li><li>多聚核糖体不断增加，到有丝分裂前RNA含量可增加到300%</li><li>蛋白质合成加快（每个细胞的总增加量为200%）</li><li>与分裂有关的酶活性大大增强</li></ul><p>分裂期 （Cell division）：指外植体细胞经诱导脱分化，不断分裂、增生子细胞的过程。</p><p>分裂期细胞的主要表现：</p><ol><li>细胞的数目迅速增加。</li><li>每个细胞平均鲜重下降。</li><li>细胞体积小，内无大液泡。</li><li>细胞的核和核仁增大到最大。</li><li>细胞中RNA含量减少，而DNA含量保持不变。</li><li>随着细胞不断分裂和生长，细胞总干重、蛋白质和核酸量大大增加，新细胞壁合成极快。</li></ol><p>分裂期愈伤组织的共同特征：细胞分裂快，结构疏松，缺少有组织的结构，维持其不分化的状态，颜色浅而透明。</p><p>分化期（Differentiation）：指愈伤组织细胞停止分裂，细胞内发生一系列形态和生理上的变化，形成一些不同形态和功能的细胞的时期。</p><p>分化期细胞特点：</p><ol><li>细胞分裂部位和方向发生改变：分裂期的细胞分裂局限在组织的外缘，主要是平周分裂；分化期开始后，愈伤组织表层细胞的分裂逐渐减慢，直至停止；进而转向愈伤组织内部深处的局部地区的细胞开始分裂，使分裂面的方向改变了，出现了瘤状结构的外表和内部分化。</li><li>分生组织瘤状结构和维管组织形成：瘤状结构成团分散分布在愈伤组织块中。形成了维管组织，但不形成维管系统，而呈分散的节状和短束状结构，它可由木质部组成，也可由木质部、韧皮部乃至形成层组成，细胞分裂素对促进组织维管化有重要作用。</li><li>细胞的体积不再减小：愈伤组织分化时外植体细胞的大小发生十分明显的变化，生长的愈伤组织的细胞平均大小不再减小，至此以后，保持相对不变。</li><li>出现各种类型的细胞：如薄壁细胞、分生细胞、管胞、石细胞、纤维细胞、色素细胞、毛状细胞以及细胞丝状体等。</li><li>出现一定的形态特征：生长旺盛的愈伤组织一般呈奶黄色或白色，有光泽，也有淡绿色或绿色的，老化的愈伤组织多转变为黄色甚至褐色。</li></ol><blockquote><p>石细胞，是指一种具有支持作用的厚壁细胞，壁强烈地木质化次生加厚。由于壁特别厚，而壁上的纹孔则形成了管状的纹孔道。成熟后一般都失去原生质体。</p></blockquote><p>Callus 类型 根据愈伤质地划分为：</p><ul><li>Rhizogenic callus  生根的愈伤</li><li>Callus exuding sticky poly-saccharides 渗出粘性多糖的愈伤</li><li>Friable 易碎</li><li>Hard / lignified callus 坚实</li></ul><p>愈伤组织的类型：</p><ul><li>松脆型：含大量分生细胞，细胞分裂相当活跃，细胞排列松散次序，适用于悬浮培养的理想材料</li><li>坚实型：由高度液泡化细胞组成，泡间隙不发达，细胞排列紧密，含维管组织，易分化出芽和根</li></ul><p>愈伤组织类型可以转化：1mg/l   2,4-D 坚实型；10mg/l   2,4-D 松脆型</p><p>胚性愈伤组织又可分为致密型胚性愈伤组织和易碎型胚性愈伤组织。这两类胚性愈伤组织都能在分化培养基上再生完整植株。</p><p>两种愈伤组织间的转化关系</p><p>坚实型升高生长素浓度转化成松脆型</p><p>松脆型降低或去除生长素转化成松脆型</p><p>优良的愈伤组织通常具备以下4个特性中的2-3个特性：</p><ol><li>高度的胚性或再分化能力。</li><li>容易散碎，建立优良的悬浮系，并能分离出全能性原生质体。</li><li>旺盛的自我增殖能力。</li><li>经过长期继代保存而不丧失胚性，以便有可能对它们进行各种遗传操作。</li></ol><p>愈伤组织的器官发生顺序有四种情况：</p><ol><li>愈伤组织仅有根或芽器官的分别形成，即无根的芽或无芽的根；</li><li>先长芽，后长根，多数情况；</li><li>先长根，再从根的基部长芽。这种情况较难诱导芽的形成，尤其对于单子叶植物；</li><li>先在愈伤组织的邻近不同部位分别形成芽和根，然后两者结合起来形成一株植株。</li></ol><p>随堂测验：</p><ol><li><p>绝大多数培养植物再生植株时都先经过<strong>愈伤组织</strong>阶段。</p></li><li><p>愈伤组织形成大致经历<strong>诱导期</strong>、<strong>分裂期</strong>和<strong>分化期</strong>三个时期。</p></li><li><p>愈伤组织的形态发生方式主要有<strong>不定芽和不定根</strong>方式和<strong>胚状体</strong>方式。</p></li></ol><p>脱分化与愈伤组织的形成在性质上是不能等同的，脱分化是细胞生理状态的改变，而形成愈伤组织是离体培养中的一个阶段。</p><p>尽管细胞脱分化后进入细胞分裂的结果，在大多数情况下是形成愈伤组织，但绝不是说所有的细胞脱分化的结果都必然形成愈伤组织，许多试验表明，有些外植体的细胞脱分化以后直接形成胚性细胞进而形成体细胞胚。</p><p>愈伤组织内的细胞并不是均一脱分化的，即同一愈伤组织内的细胞之间其状态存在一定差异，特别是在组织器官培养时，往往出现部分细胞不完全脱分化的现象。</p><hr><p>胚状体（embroid）：离体培养条件下，没有经过受精过程，但是经过了胚胎发育过程所形成的胚状类似物，此现象无论在体细胞培养还是生殖细胞培养中均可以看到，因而统称为体细胞胚或胚状体。</p><ul><li>细胞的脱分化和再分化时离体培养过程中细胞全能性表现的基本过程</li><li>培养条件下，植物细胞通过再分化过程形成完整个体可以通过器官发生和体细胞胚发生两种途径来实现</li></ul>]]></content>
      
      
      <categories>
          
          <category> 生物学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 植物组织培养 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>遗传学复习整理</title>
      <link href="2020/12/25/%E7%94%9F%E7%89%A9%E5%AD%A6/%E9%81%97%E4%BC%A0%E5%AD%A6%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86_v202101041954/"/>
      <url>2020/12/25/%E7%94%9F%E7%89%A9%E5%AD%A6/%E9%81%97%E4%BC%A0%E5%AD%A6%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86_v202101041954/</url>
      
        <content type="html"><![CDATA[<blockquote><p>如文档内容有误，点击<a href="http://doc.halo123.top:3000/6t-ExVyDTK6f2kJ2e1hp3w?both">该链接</a>对文档进行修改，定时会同步到网站上<br>文档采用Markdown格式排版，可以参考<a href="https://halo123.top/2019/05/08/Markdown%E8%AF%AD%E6%B3%95/">该网站</a>进行简单学习，感谢参与整理的同学们</p></blockquote><h2 id="名词解释"><a class="header-anchor" href="#名词解释"></a>名词解释</h2><blockquote><p>有子列表内容的名词，是指不同来源解释。部分名词已注明来源，自己酌情选择</p></blockquote><ol><li><strong>转导</strong>：是指以噬菌体为媒介，将细菌的小片段染色体或基因从一个细菌转移到另一个细菌的过程。(P188)</li><li><strong>转化</strong>：是某一基因型的细胞从周围介质中吸收来自另一基因型的细胞的DNA而使它的基因型和表现型发生相应变化的现象。</li><li><strong>性导</strong>：利用F’因子进行细菌基因的转移叫做性导。（P183）</li><li><strong>异源多倍体</strong>：两个不相同的种杂交，它们的杂交再经过染色体加倍，就形成了异源多倍体。（P240）</li><li><strong>同源多倍体</strong>：<ul><li>染色体已经复制，而细胞质不分离，可形成同源多倍体（P238）</li><li>指增加的染色体组来自同一物种，一般由二倍体的染色体直接加倍产生的（<a href="https://baike.baidu.com/item/%E5%90%8C%E6%BA%90%E5%A4%9A%E5%80%8D%E4%BD%93/4719790?fr=aladdin">百度百科</a>）</li></ul></li><li><strong>重复</strong>：<ul><li>染色体增加了片段。（P220）</li><li>重复指的是除了正常的染色体组外，多了一些染色体部分，这种额外的染色体部分叫作重复片段。（P226）</li></ul></li><li><strong>缺失</strong>：染色体失去了片段。（P220）</li><li><strong>易位</strong>：<ul><li>非同源染色体间互相交换染色体片段，造成染色体间基因的重新排列。（P221）</li><li>一条染色体的一段搭到一条非同源染色体上去，叫做易位。（P226）</li></ul></li><li><strong>倒位</strong>：<ul><li>染色体片段发生180度的颠倒，造成染色体内基因的重新排列。（P220）</li><li>一个染色体片段断裂了，倒转180°，重新又搭上去了，这个现象叫作倒位。（P231）</li></ul></li><li><strong>缺体</strong>：是异源多倍体的特征，指有一对同源染色体成员全部丢失（2n-2）的生物个体，又称为零体。一般来源于单体（2n-1）的自交。</li><li><strong>三体</strong>：比正常的二倍体多了一条染色体的物种。</li><li><strong>非整倍体</strong>：增减一条或几条染色体，增减后的染色体数目不是整倍数，所以叫作非整倍体。(P244)</li><li><strong>罗伯逊易位</strong>：由着丝粒的融合或断裂引起的易位，使染色体数目减少或增加，是核型进化的一种形式。</li><li><strong>错义突变</strong>：DNA中碱基对替换，使mRNA的某一密码子改变，由它所编码的氨基酸不同。</li><li><strong>无义突变</strong>：碱基替换改变了mRNA上的一个密码子，成为3个终止密码子UAG、UAA和UGA中的任意一个时，就出现无义突变。</li><li><strong>中性突变</strong>：DNA一级结构的变化不影响蛋白质生物活性、不表现明显表型效应的突变称为中性突变。</li><li><strong>表现度</strong>：具有相同基因型的个体间基因表达的变化程度称为表现度。</li><li><strong>外显率</strong>：某一基因型个体显示预期表型的比例。</li><li><strong>表型模拟</strong>：指环境改变引起的表型改变，有时会类似某基因引起的表型变化。</li><li><strong>限性遗传</strong>：只在某一种性别表现的性状称为限性性状，限性性状的遗传行为称为限性遗传。控制限性性状的基因多数位于常染色体上，也有少部分位于性染色体上。</li><li><strong>位置效应</strong>：基因在染色体上位置不同对性状表现的作用也可能不同。</li><li><strong>剂量补偿</strong>：在XY性别决定的生物中，使性连锁基因在两种性别中有相等或近乎相等的有效剂量的遗传效应。</li><li><strong>顺反子</strong>：即结构基因，是决定一条多肽链合成的功能单位。</li><li><strong>遗传漂变</strong>：由于群体较小和偶然事件所造成的基因频率的不确定性变化现象被称为遗传漂变。或者说，非随机取样而引起的基因频率的改变称为遗传漂变。</li><li><strong>适合度</strong>：一般记作W，是指某一基因型跟其他基因型相比时，能够存活并留下子裔的相对能力。</li><li><strong>选择系数</strong>：一般记作s，s是在选择作用下降低的适合度，即s=1-W，或W=1-s。</li><li><strong>遗传平衡定律</strong>：一个群体在符合一定条件的情况下，群体中各个体的比例可从一代到另一代维持不变。</li><li><strong>遗传多态</strong>：同一群体中两种或两种以上变异类型并存的现象。</li><li><strong>基因转变</strong>：异源双链DNA分子错配的核苷酸对，在修复校正过程中发生的一个基因转变为它的等位基因的现象；指减数分裂过程中同源染色体联会时一个基因使相对位置上的基因发生相应的变化</li><li><strong>基因重排</strong>：将一个基因从远离启动子的地方移到距启动子很近的地方从而启动转录的方式。</li><li><strong>母性影响</strong>：有时候两种交配的结果并不相同，子代的表型受到母本基因型的影响，与母本的表型一样，这种现象叫做母性影响。</li><li><strong>图式形成</strong>：胚胎细胞形成不同组织、器官，构成有序空间结构的过程。</li><li><strong>细胞决定</strong>：指细胞在发生可识别的形态变化之前，就已受到约束而向特定方向分化，这时细胞内部已发生变化，确定了未来的发育命运。</li><li><strong>正向遗传学</strong>：研究突变表型以确定突变基因的遗传学研究方法。大规模随机诱变，产生发育异常的突变个体，然后再寻找突变的基因。</li><li><strong>反向遗传学</strong>：通过定点突变某基因，研究其表型来确定该基因的功能的遗传学研究方法。</li><li><strong>表观遗传学</strong>：<ul><li>是探讨在不发生DNA序列改变的情形下，由DNA甲基化、染色质结构状态等因素改变，使基因功能发生可遗传的变化并最终导致表型变异的遗传现象及本质，即研究非DNA序列变化的，可遗传的表达改变的科学。</li><li>所谓表观遗传学，指的是在DNA序列不改变的情况下，基因功能发生的可遗传的变异，最终可导致表型变化，包括DNA甲基化、组蛋白修饰、RNA介导的基因沉默等（P375）</li></ul></li><li><strong>QTL</strong>：数量性状基因座 (quantitative trait locus, QTL) 是控制数量性状的基因在基因组中的位置。</li></ol><h2 id="问答题"><a class="header-anchor" href="#问答题"></a>问答题</h2><h3 id="1、一野生型的雄果蝇与一个对白眼基因是纯合的雌果蝇杂交，子代中发现有一只雌果蝇具有白眼表型。你怎样决定这个结果是由于一个点突变引起的，还是由于缺失造成的？"><a class="header-anchor" href="#1、一野生型的雄果蝇与一个对白眼基因是纯合的雌果蝇杂交，子代中发现有一只雌果蝇具有白眼表型。你怎样决定这个结果是由于一个点突变引起的，还是由于缺失造成的？"></a>1、一野生型的雄果蝇与一个对白眼基因是纯合的雌果蝇杂交，子代中发现有一只雌果蝇具有白眼表型。你怎样决定这个结果是由于一个点突变引起的，还是由于缺失造成的？</h3><p>让这只雌蝇和正常雄蝇交配：</p><ol><li>若后代中雄蝇全白眼，雌蝇全红眼，且雌:雄为1:1，是点突变；</li><li>若后代中雄蝇为白眼，雌蝇为红眼，但雌:雄为2:1，则是由于缺失造成。<blockquote><p>红眼白眼是伴X隐性遗传，如果该雌蝇是缺失眼色基因的导致的白眼，那么后代雄蝇就会有一半没有眼色基因于是致死。</p></blockquote></li></ol><h3 id="2、从经典遗传学到分子遗传学，基因的概念有什么发展？现在对基因的概念是怎么样的？"><a class="header-anchor" href="#2、从经典遗传学到分子遗传学，基因的概念有什么发展？现在对基因的概念是怎么样的？"></a>2、从经典遗传学到分子遗传学，基因的概念有什么发展？现在对基因的概念是怎么样的？</h3><p>经典遗传学认为基因是一个最小单位，不能分割，既是重组单位，又是功能单位、突变单位，基因直线排列在染色体上，即“三位一体”概念。</p><p>生化和微生物学家先提出了“一个基因一个酶”的假说，后来随着蛋白质多聚体的研究，发展为“一个基因决定一条多肽链”。</p><p>从经典遗传学到分子遗传学基因概念的一个重要发展是:在经典遗传学中，只要突变能带来表型效应的遗传功能单位就被认定为基因，不管该遗传功能单位是否编码(转录)遗传信息，而分子遗传学基因的概念是只有编码(转录)信息的遗传功能单位才称其为基因。</p><p>分子遗传学提出了折叠基因、断裂基因和移动基因的概念，在1955年 Benzer 根据噬菌体突变的互补实验和重组实验结果，提出了基因是一个作用单位——顺反子，基因不再是最小的重组单位，突变单位，最小重组单位是重组子，最小突变单位是突变子，即顺反子内可以分成很多突变子和重组子，分子遗传学已阐明最小重组单位和最小突变的单位是碱基对。</p><h3 id="3、紫外线诱变的作用机制如何？它引起的DNA损伤的修复途径是什么？"><a class="header-anchor" href="#3、紫外线诱变的作用机制如何？它引起的DNA损伤的修复途径是什么？"></a>3、紫外线诱变的作用机制如何？它引起的DNA损伤的修复途径是什么？</h3><p>紫外线诱变的作用机制：</p><ol><li>紫外线有效波长为260nm，而这个波长正是DNA的吸收峰。</li><li>当DNA链经紫外线照射后，同一链上的两个邻接核苷酸会形成嘧啶二聚体，嘧啶二聚体会使双螺旋的两链间的键减弱，DNA结构发生局部变形，不能作为DNA复制的样板，新合成的链在二聚体的对面两旁留下缺口。</li></ol><p>修复途径：</p><ol><li>在损伤部位就地修复——光复活；</li><li>取代损伤部位——暗修复或切除修复；</li><li>越过损伤部位而进行修复——重组修复。</li></ol><h3 id="4、母性影响与细胞质遗传有什么不同？"><a class="header-anchor" href="#4、母性影响与细胞质遗传有什么不同？"></a>4、母性影响与细胞质遗传有什么不同？</h3><ol><li>母性影响是亲代核基因的某些产物或者某种因子积累在卵细胞的细胞质中，对子代某些性状的表现产生影响的现象。这种效应只能影响子代的性状，不能遗传。因此F1代表型受母亲的基因型控制，属于细胞核遗传体系；细胞质遗传是细胞质中的DNA或基因对遗传性状的决定作用。由于精卵结合时，精子的细胞质往往不进入受精卵中，因此，细胞质遗传性状只能通过母体或卵细胞传递给子代，子代总是表现为母本性状，属于细胞质遗传体系。</li><li>母性影响符合孟德尔遗传规律；细胞质遗传是非孟德尔式遗传。</li><li>母性遗传杂交后代有一定的分离比，只不过是要推迟一个世代而已；细胞质遗传杂交后代一般不出现一定的分离比。</li></ol><h3 id="5、在一牛群中，外貌正常的双亲产生一头矮生的雄犊。这种矮生究竟是由于突变的直接结果，是由于隐性矮生基因的“携带者”的偶尔交配后发生的分离，还是由于非遗传（环境）的影响？你怎么决定？"><a class="header-anchor" href="#5、在一牛群中，外貌正常的双亲产生一头矮生的雄犊。这种矮生究竟是由于突变的直接结果，是由于隐性矮生基因的“携带者”的偶尔交配后发生的分离，还是由于非遗传（环境）的影响？你怎么决定？"></a>5、在一牛群中，外貌正常的双亲产生一头矮生的雄犊。这种矮生究竟是由于突变的直接结果，是由于隐性矮生基因的“携带者”的偶尔交配后发生的分离，还是由于非遗传（环境）的影响？你怎么决定？</h3><p>可能的原因：</p><ol><li>外貌正常的双亲都是矮生基因的携带者，两者产生的矮生基因配子结合，成为纯合的矮生基因型。即Aa×Aa → 1AA（正常）：2Aa（正常）：1aa（矮生）；</li><li>由显性突变造成，这种突变可以直接传给后代，用这头矮牛与正常牛交配。其后代矮牛与正常牛呈1：1；</li><li>由于营养不良等环境因素造成。这种变异是不可遗传的，改变环境后，性状也会有改变。</li></ol><h3 id="5、生殖隔离的分类和机制。-P432"><a class="header-anchor" href="#5、生殖隔离的分类和机制。-P432"></a>5、生殖隔离的分类和机制。(P432)</h3><ol><li><p>受精前的生殖隔离</p><ul><li>季节隔离：两个种的生育季节不重叠，如发情期、交配季节不同。</li><li>心理隔离：指有求偶行为的动物，异性个体间缺乏引诱力，所以不相互交配，所以有些不同种虽然在实验室中可以人工授精产生杂种，但自然界中很少见。</li><li>受精隔离：指体内受精动物在交配受精后，体外受精动物在释放配子后，植物在花粉到达柱头后，在一系列反应中有某种不协调，使雌雄配子无法结合。</li></ul></li><li><p>受精后生殖隔离：</p><ul><li>F<sub>1</sub>合子形成以后，不能生存或者不能发育到性成熟阶段；</li><li>或使F<sub>1</sub>杂种不育，或使F<sub>2</sub>以后各代中带有杂种基因组合的个体不能生产或者不能发育，总之是影响种间杂种后代的个体发育过程。</li></ul><blockquote><p>杂种不活表现在个体发育阶段，在不同杂种组合中不同。杂种不育或是由于性腺形成不全，或是性腺内生殖细胞没有分化，或是减数分裂失败等等都可使杂种不育。</p></blockquote></li></ol><h3 id="6、新种是如何形成的-P433"><a class="header-anchor" href="#6、新种是如何形成的-P433"></a>6、新种是如何形成的(P433)</h3><ol><li>渐变式新种形成：一般先有地理隔离，各自通过不同的基因突变、染色体畸变或重组，在自然选择下，形成不同亚种，亚种一般在形态上已有一定差异，在进一步分化，有机会重新遇见时，已不能有基因交流，产生生殖隔离，成为不同种。</li><li>爆发式新种形成：主要见于植物，先是一个二倍体经长期分化，经过许多基因突变，染色体畸变，和极长的自然选择，形成新染色体组，然后具有不同染色体的个体相互杂交，子一代染色体加倍，形成异源染色体，再通过自然选择，逐渐适应环境。</li></ol><h3 id="7、用图解说明无籽西瓜制种的原理，无籽西瓜为什么没有种子？是否绝对没有种子？"><a class="header-anchor" href="#7、用图解说明无籽西瓜制种的原理，无籽西瓜为什么没有种子？是否绝对没有种子？"></a>7、用图解说明无籽西瓜制种的原理，无籽西瓜为什么没有种子？是否绝对没有种子？</h3><p><img src="https://pic.downk.cc/item/5fe980283ffa7d37b3a64c86.png" alt="无籽西瓜"></p><p>无籽西瓜是一个多元单倍体，在减数第一次分裂中期时没有可以配对的同源染色体，从而被随机分向两极，很难形成可育的配子。每一染色体分到一极的机会为1/2，从而所有色体都分到一极的机会是(1/2)<sup>n</sup>（n为每一染色体组的染色体数），产生可育配子的比例是(1/2)<sup>n</sup>，所以无籽西瓜也不是绝对无籽</p><h3 id="9、用现有科学事实，怎样正确理解在遗传中细胞核与细胞质之间的关系"><a class="header-anchor" href="#9、用现有科学事实，怎样正确理解在遗传中细胞核与细胞质之间的关系"></a>9、用现有科学事实，怎样正确理解在遗传中细胞核与细胞质之间的关系</h3><p>细胞质基因指的是细胞质内控制生物性状的遗传物质。<br>细胞核基因指的是细胞核内控制生物性状的遗传物质。</p><p>两者的主要区别：</p><ol><li>一是存在位置不同。质基因存在于细胞质的线粒体、叶绿体等结构上；核基因位于细胞核内染色体上。</li><li>二是存在方式不同。核基因在染色体上呈直线排列，与蛋白质结合。而含质基因的DNA不与蛋白质结合，而是呈双链环状等形状单独存在。</li></ol><p>两者的主要关系有：</p><ol><li>生物体中绝大部分性状是受核基因控制的，核基因是主要的遗传物质，而有些性状是受细胞质基因控制的。</li><li>细胞核遗传和细胞质遗传各自都有相对的独立性。质基因与核基因一样，可以自我复制、可以转录和翻译控制蛋白质的合成，也就是说都具有稳定性、连续性、变异性和独立性。</li><li>核遗传和质遗传相互影响，生物性状很多情况体现为核质互作。两者相互依存相互制约。</li></ol><h3 id="10、简述电离辐射引起的DNA的损伤及其修复"><a class="header-anchor" href="#10、简述电离辐射引起的DNA的损伤及其修复"></a>10、简述电离辐射引起的DNA的损伤及其修复</h3><p>损伤：</p><ol><li>直接作用</li><li>间接作用：通过水的电离所形成的自由基起作用。使DNA链双链或单链断裂，造成缺失、重复、易位和倒位。高剂量照射时，还能破坏碱基。</li></ol><p>修复：以大肠杆菌为例，通常认为大肠杆菌有3种修复过程，需要3种不同的修复酶系</p><ol><li>超快修复：单链断裂的极快修复过程。0℃时，2分钟内即可完成，可能是DNA连接酶的单独作用。</li><li>快修复：需要DNA聚合酶I的修复过程，室温下在缓冲液中迅速进行。超快修复后剩下的单链断裂有90%可被修复。</li><li>慢修复：快修复所不能修复的单链断裂，可由重组修复系统修复。</li></ol><h3 id="11、正反交在F-sub-1-sub-往往得出不同的结果。这可以由伴性遗传、细胞质遗传、母性影响。如果你得到这样的一种结果，怎样用实验方法来决定是属于那一种范畴？"><a class="header-anchor" href="#11、正反交在F-sub-1-sub-往往得出不同的结果。这可以由伴性遗传、细胞质遗传、母性影响。如果你得到这样的一种结果，怎样用实验方法来决定是属于那一种范畴？"></a>11、正反交在F<sub>1</sub>往往得出不同的结果。这可以由伴性遗传、细胞质遗传、母性影响。如果你得到这样的一种结果，怎样用实验方法来决定是属于那一种范畴？</h3><ol><li>如果亲本的不同表型在F<sub>1</sub>中都有表现，但正交F<sub>1</sub>表型像母亲，反交F<sub>1</sub>表型雄性像母亲，雌性像父亲,即F<sub>1</sub>表型有性别之分，可判断为伴性遗传。</li><li>如果正反交F<sub>1</sub>表型只与母亲一样，说明是细胞质遗传或母性影响。</li><li>如果让F<sub>1</sub>自交得F<sub>2</sub>，F<sub>2</sub>自交得F<sub>3</sub>，F<sub>2</sub>、F<sub>3</sub>只与母本一样，说明是细胞质遗传，如果F<sub>3</sub>中又出现了孟德尔分离比，即孟德尔分离比推迟一代出现，即可判断为母性影响。</li></ol><h3 id="12、在人类中，苯丙酮尿症突变基因的频率p＝1-100，问堂兄妹婚配时，孩子患这种病的概率是多少？就此病说明近亲婚配的危害。（10分）"><a class="header-anchor" href="#12、在人类中，苯丙酮尿症突变基因的频率p＝1-100，问堂兄妹婚配时，孩子患这种病的概率是多少？就此病说明近亲婚配的危害。（10分）"></a>12、在人类中，苯丙酮尿症突变基因的频率p＝1/100，问堂兄妹婚配时，孩子患这种病的概率是多少？就此病说明近亲婚配的危害。（10分）</h3><p>近交系数F=1/16</p><p>近亲婚配时的得病概率 P=(1/100)<sup>2</sup>(1-1/16)+(1/100)(1/16)=7×10<sup>-4</sup></p><p>非近亲婚配得病概率  P=(1/100)<sup>2</sup>=1×10<sup>-4</sup></p><p>相差7倍</p><h3 id="13、杂交水稻-“二区三系”制种方法及基本原理"><a class="header-anchor" href="#13、杂交水稻-“二区三系”制种方法及基本原理"></a>13、杂交水稻 “二区三系”制种方法及基本原理</h3><p>胞质基因和核内基因共同影响可育性状:</p><ol><li><p>细胞质，S为不育基因，N为可育基因;</p></li><li><p>胞核，r为不育基因，R为可育基因</p><blockquote><p>只要有N和R中任一个即可育。</p></blockquote></li></ol><p>三系：</p><ol><li>不育系S（r）；</li><li>保持系N（rr）;</li><li>恢复系，N（R）或S（RR）。</li></ol><p>隔离区1：繁殖不育系和保持系的隔离区，不育系和保持系交替种植；保持系自交，收获的种子仍为保持系；不育系靠保持系授粉，后代仍为不育系；从而一个隔离区两个品系繁育制种。</p><p>隔离区2：杂种制种隔离区，不育系和恢复系交替种植；恢复系自交，获得的种子仍为恢复系(纯繁);不育系靠恢复系授粉，收获的是可育的杂交种子(商品用杂交种子)。</p><h3 id="14、你怎样区别某一性状是常染色体遗传，还是伴性遗传的？举例说明。"><a class="header-anchor" href="#14、你怎样区别某一性状是常染色体遗传，还是伴性遗传的？举例说明。"></a>14、你怎样区别某一性状是常染色体遗传，还是伴性遗传的？举例说明。</h3><p>伴性遗传的正反交结果不同，与子代的性别有关。</p><ol><li>首先看该性状的遗传在后代的雌雄性别中是否不同;</li><li>然后再根据正反交结果是否一致，如果该性状的遗传在后代的雌雄性别中不同，正反交结果不一致，则该性状的遗传属于伴性遗传，否则属于常染色体遗传。</li></ol><h3 id="15、什么是分子遗传标记？常见的分子遗传标记有哪些？请举例说明其各自的优点和缺点。"><a class="header-anchor" href="#15、什么是分子遗传标记？常见的分子遗传标记有哪些？请举例说明其各自的优点和缺点。"></a>15、什么是分子遗传标记？常见的分子遗传标记有哪些？请举例说明其各自的优点和缺点。</h3><p>分子标记，是以个体间遗传物质内核苷酸序列变异为基础的遗传标记，是DNA水平遗传多态性的直接的反映。</p><p><strong>限制性片段长度多态分析技术(RFLP)</strong>：基因组DNA在限制性内切酶作用下，产生大小不等的DNA片段；它所代表的是基因组DNA酶切后产生的片段在长度上的差异，这种差异是由于突变增加或减少了某些内切酶位点造成的。</p><p>优点：</p><ol><li>标记的等位基因间是共显性的，不受杂交方式制约，即与显隐性基因无关;</li><li>检测结果不受环境因素影响;</li><li>标记的非等位基因之间无基因互作效应，即标记之间无干扰。</li></ol><p>缺点：</p><ol><li>主要是克隆可表现基因组DNA多态性的探针较为困难</li><li>实验操作较繁锁，检测周期长，成本费用也很高。</li></ol><p><strong>随机引物扩增多态性DNA技术分析(RAPD)</strong>：建立于PCR基础之上的，利用随机的脱氧核节酸序列作引物，对所研究的基因组DNA体外扩增，扩增产物经电泳分离染色后，来检测其多态性，这些扩增DNA片段多态性便反映了基因组相应区域的DNA多态性。</p><p>优点：</p><ol><li>RAPD扩增引物没有物种的限制;</li><li>RAPD扩增引物没有数量上限制;</li><li>简捷方便，可进行大量样品的筛选。</li></ol><p>缺点: RAPD标记是显性的，无法区分动物纯、杂合体，而且在分析中易产生非特异性。</p><p><strong>DNA指纹分析技术</strong>：以小卫星或微卫星DNA作探针，与多种限制性内切酶酶切片段杂交，所得个体特异性的杂交图谱，即为DNA指纹。</p><p>优点：</p><ol><li>具有高度特异性</li><li>遗传方式简明。遵循孟德尔遗传定律</li><li>具有高效性。</li></ol><p>缺点：由于卫星DNA不是单拷贝，难于跟踪分离群体中个体基因组中同源区域的分离。</p><p><strong>AFLP分析技术</strong>：将PCR与RFLP结合起来。基因组DNA先用限制性内切酶双酶切，再在两端连上特定的人工接头，根据接头和酶切位点的序列设计引物。</p><p>优点：无需了解DNA模板序列，产生的多态性较多。与RAPD比较，它的可重复性得到极大提高。它既有RFLP的可靠性，也具有RAPD的方便性，被认为是迄今为止最有效的分子标记。</p><h2 id="名词解释自测"><a class="header-anchor" href="#名词解释自测"></a>名词解释自测</h2><ol><li>转导：<u>是指以噬菌体为媒介，将细菌的小片段染色体或基因从一个细菌转移到另一个细菌的过程。</u></li><li>转化：<u>是某一基因型的细胞从周围介质中吸收来自另一基因型的细胞的DNA而使它的基因型和表现型发生相应变化的现象。</u></li><li>性导：<u>利用F’因子进行细菌基因的转移叫做性导。</u></li><li>异源多倍体：<u>两个不同的种杂交，它们的杂交再经过染色体加倍，就形成了异源多倍体。</u></li><li>同源多倍体：<u>染色体已经复制，而细胞质不分离（书本）/指增加的染色体组来自同一物种，一般由二倍体的染色体直接加倍产生的（百度）</u></li><li>重复：<u>染色体增加了片段。</u></li><li>缺失：<u>染色体失去了片段。</u></li><li>易位：<u>非同源染色体间互相交换染色体片段，造成染色体间基因的重新排列。</u></li><li>倒位：<u>染色体片段发生180度的颠倒，造成染色体内基因的重新排列。</u></li><li>缺体：<u>是异源多倍体的特征，只有一对同源染色体成员全部丢失（2n-2）的生物个体，又称为零体。一般来源于单体（2n-1）的自交。</u></li><li>三体：<u>比正常的二倍体多了一条染色体的物种。</u></li><li>非整倍体：<u>增减一条或几条染色体，增减后的染色体数目不是整倍数，所以叫作非整倍体。</u></li><li>罗伯逊易位：<u>由着丝粒的融合或断裂引起的易位，使染色体数目减少或增加，是核型进化的一种形式。</u></li><li>错义突变：<u>DNA中碱基对替换，使mRNA的某一密码子改变，由它所编码的氨基酸不同。</u></li><li>无义突变：<u>碱基替换改变了mRNA上的一个密码子，成为3个终止密码子UAG、UAA和UGA中的任意一个时，就出现无义突变。</u></li><li>中性突变：<u>DNA一级结构的变化不影响蛋白质生物活性、不表现明显表型效应的突变称为中性突变。</u></li><li>表现度：<u>具有相同基因型的个体间基因表达的变化程度称为表现度。</u></li><li>外显率：<u>某一基因型个体显示预期表型的比例。</u></li><li>表型模拟：<u>指环境改变引起的表型改变，有时会类似某基因引起的表型变化。</u></li><li>限性遗传：<u>只在某一种性别表现的性状称为限性性状，限性性状的遗传行为称为限性遗传。控制限性性状的基因多数位于常染色体上，也有少部分位于性染色体上。</u></li><li>位置效应：<u>基因在染色体上位置不同对性状表现的作用也可能不同。</u></li><li>剂量补偿：<u>在XY性别决定的生物中，使性连锁基因在两种性别中有相等或近乎相等的有效剂量的遗传效应。</u></li><li>顺反子：<u>即结构基因，是决定一条多肽链合成的功能单位。</u></li><li>遗传漂变：<u>由于群体较小和偶然事件所造成的基因频率的不确定性变化现象被称为遗传漂变。或者说，非随机取样而引起的基因频率的改变称为遗传漂变。</u></li><li>适合度：<u>一般记作W，是指某一基因型跟其他基因型相比时，能够存活并留下子裔的相对能力。</u></li><li>选择系数：<u>一般记作s，s是在选择作用下降低的适合度，即s=1-W，或W=1-s。</u></li><li>遗传平衡定律：<u>一个群体在符合一定条件的情况下，群体中各个体的比例可从一代到另一代维持不变。</u></li><li>遗传多态：<u>同一群体中两种或两种以上变异类型并存的现象。</u></li><li>基因转变：<u>异源双链DNA分子错配的核苷酸对，在修复校正过程中发生的一个基因转变为它的等位基因的现象。</u></li><li>基因重排：<u>将一个基因从远离启动子的地方移到距启动子很近的地方从而启动转录的方式。</u></li><li>母性影响：<u>有时候两种交配的结果并不相同，子代的表型受到母本基因型的影响，与母本的表型一样，这种现象叫做母性影响。</u></li><li>图式形成：<u>胚胎细胞形成不同组织、器官，构成有序空间结构的过程。</u></li><li>细胞决定：<u>指细胞在发生可识别的形态变化之前,就已受到约束而向特定方向分化,这时细胞内部已发生变化,确定了未来的发育命运。</u></li><li>正向遗传学：<u>研究突变表型以确定突变基因的遗传学研究方法。大规模随机诱变，产生发育异常的突变个体，然后再寻找突变的基因。</u></li><li>反向遗传学：<u>通过定点突变某基因，研究其表型来确定该基因的功能的遗传学研究方法。</u></li><li>表观遗传学：<u>是探讨在不发生DNA序列改变的情形下，由DNA甲基化、染色质结构状态等因素改变，使基因功能发生可遗传的变化并最终导致表型变异的遗传现象及本质，即研究非DNA序列变化的，可遗传的表达改变的科学。</u></li><li>QTL：<u>数量性状基因座 (quantitative trait locus, QTL) 控制数量性状的基因,是影响数量性状的一个染色体片段。</u></li></ol>]]></content>
      
      
      <categories>
          
          <category> 生物学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 遗传学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代分子生物学复习整理</title>
      <link href="2020/12/25/%E7%94%9F%E7%89%A9%E5%AD%A6/%E7%8E%B0%E4%BB%A3%E5%88%86%E5%AD%90%E7%94%9F%E7%89%A9%E5%AD%A6%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86_v2021151556/"/>
      <url>2020/12/25/%E7%94%9F%E7%89%A9%E5%AD%A6/%E7%8E%B0%E4%BB%A3%E5%88%86%E5%AD%90%E7%94%9F%E7%89%A9%E5%AD%A6%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86_v2021151556/</url>
      
        <content type="html"><![CDATA[<!-- > 如文章内容有误，点击[该链接](http://doc.halo123.top:3000/GceDChBvSGawSgvkIYJfGw?both)可对文档进行修改，定时会同步到网站上 --><blockquote><p>有什么问题可以发邮件反馈<a href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=zqKvoL_noruOqKG2o6_nouCtoaM">反馈地址</a> 感谢参与整理的同学们</p></blockquote><h2 id="名词解释"><a class="header-anchor" href="#名词解释"></a>名词解释</h2><blockquote><p>标⭐表示17-20年宁大真题出现过</p></blockquote><ol><li><strong><abbr title="碱基对">Base pair</abbr></strong>：是一对被氢键连接起来相互匹配的碱基(即A:T，G:C，A:U相互作用)，是形成DNA、RNA单体以及编码遗传信息的化学结构。</li><li><strong><abbr title="微卫星DNA">Microsatellite DNA</abbr></strong>：重复单位序列最短只有2~6bp，串联成簇，长度50~100bp，又称为短串联重复序列(Short Tandem Repeat STR)。广泛分布于基因组中。 其中富含A-T碱基对。⭐</li><li><strong><abbr title="复性">Renaturation</abbr></strong>：变性后成为单链的DNA，在适当条件下又能恢复成为双链DNA，这成为DNA复性或退火。</li><li><strong><abbr title="退火">Annealing</abbr></strong>：见上。</li><li><strong><abbr title="分子杂交">Molecular hybridization</abbr></strong>：不同的DNA片段之间，DNA片段与RNA片段之间，如果彼此间的核苷酸排列顺序互补也可以复性，形成新的双螺旋结构。这种按照互补碱基配对而使不完全互补的两条多核苷酸相互结合的过程称为分子杂交。</li><li><strong><abbr title="基因组">Genome</abbr></strong>：一个细胞或病毒所携带的全部遗传信息或整套基因，包括每一条染色体和所有亚细胞器的DNA序列信息。</li><li><strong><abbr title="增色效应">Hyperchromic effect</abbr></strong>：指因高分子结构的改变，而使摩尔吸光系数(molar extinction coefficient) ε 增大的现象，亦称高色效应。</li><li><strong><abbr title="解链温度">Tm(Melting temperature)</abbr></strong>：利用加热使溶液中50%的DNA分子成为单链所需温度称为解链温度。</li><li><strong><abbr title="DNA的半保留复制(P467、42)">Semi-conservative replication</abbr></strong>：在DNA复制过程中，每条链分别作为模板合成新链，产生互补的两条链。这样新形成的两个DNA分子与原来DNA分子的碱基顺序完全一样。因此，每个子代分子的一条链来自亲代DNA，另一条链则是新合成的，这种复制方式被称为DNA的半保留复制。⭐</li><li><strong><abbr title="DNA的半不连续复制(P467、45)">Semi-discontinuous replication</abbr></strong>：DNA复制过程中前导链的复制是连续的，而另一条链，即滞后链的复制是中断的、不连续的。</li><li><strong><abbr title="C值矛盾">C-value paradox</abbr></strong>：一种生物的单倍体基因组的DNA总量称为C值。生物的C值并不与生物复杂程度（或生物在进化上所处的地位）相关，这一现象称为C值悖论。⭐</li><li><strong><abbr title="遗传中心法则">Genetic central dogma</abbr></strong>：由克里克首次提出的遗传信息传递规律，该法则阐明了DNA复制，RNA转录以及翻译产生蛋白质在生命过程中的核心地位。⭐</li><li><strong><abbr title="Klenow片段">Klenow fragment</abbr></strong>：DNA聚合酶Ⅰ被蛋白酶切成两个片段，其中两个片段中分子量较大的一个称为Klenow片段，同时具有3’-5’核酸外切酶活性和DNA聚合酶活性既可以合成DNA链，又可以降解DNA，保证了DNA复制的准确性。Klenow片段是实验室合成DNA、进行分子生物学研究中常用的工具酶。⭐</li><li><strong>split \ <abbr title="断裂基因">interrupted gene</abbr></strong>：是真核生物的结构基因。由若干个编码序列和非编码序列互相间隔开但又连续镶嵌而成，去除非编码序列再连接后，可翻译出由连续氨基酸组成的完整蛋白质，这些基因称为断裂基因。</li><li><strong><abbr title="内含子">Intron</abbr></strong>：是一个基因中非编码DNA片段，它分开相邻的外显子，内含子是阻断基因线性表达的序列。</li><li><strong><abbr title="外显子">Exon</abbr></strong>：是真核生物基因的一部分，它在剪接（Splicing）后仍会被保存下来，并可在蛋白质生物合成过程中被表达为蛋白质。</li><li><strong><abbr title="重叠基因">Overlapping gene</abbr></strong>：具有部分共用核苷酸序列的基因，即同一段DNA携带了两种或两种以上不同蛋白质的编码信息。重叠的序列可以是调控基因，也可以是结构基因。常见于病毒和噬菌体基因组中。</li><li><strong><abbr title="质粒">Plasmid</abbr></strong>：细菌内染色体外的环状DNA分子。</li><li><strong><abbr title="单核苷酸多态性（P470、66）">SNP(Single nucleotide polymorphism)</abbr></strong>：指分散于基因组中的单个碱基的差异，包括单个碱基的缺失和插入，但更常见的是单个核苷酸的替换。</li><li><strong><abbr title="端粒酶">Telomerase</abbr></strong>：是由RNA和蛋白质组成的一种核糖核蛋白（RNP）复合体，具有逆转录酶活性，能利用自身携带的RNA链作为模板，用dDTP为原料，以逆转录方式催化互补于RNA模板的后随链DNA片段的合成。（或把DNA复制损失的端粒填补起来，把端粒修复延长，使得细胞分裂的次数增加。）</li><li><strong><abbr title="反转录">Reverse transcription</abbr></strong>：以mRNA为模板，在反转录酶的作用下合成cDNA的过程。</li><li><strong><abbr title="互补DNA">cDNA(Complementary DNA)</abbr></strong>：特指在体外经过逆转录后与RNA互补的DNA链。与基因组DNA不同，cDNA没有内含子而只有外显子的序列 。在遗传工程方面广为应用。</li><li><strong><abbr title="转座子">Transposon</abbr></strong>：能够在没有序列相关性的情况下独立插入基因组新位点上的一段DNA序列，是存在于染色体DNA上可自主复制和位移的基本单位。</li><li><strong><abbr title="重组修复">Recombination repairing</abbr></strong>：又被称为“复制后修复”，它发生在复制之后，机体细胞对在复制起始时尚未修复的DNA损伤部位可以先复制再修复，及先跳过该损伤部位，在新合成链中留下一个对应于损伤序列的缺口，该缺口由DNA重组来修复:先从同源DNA母链上将相应核苷酸序列片断一致子链缺口处，然后再用新合成序列补上母链空缺。大肠杆菌的rec基因编码主要的重组修复系统。</li><li><strong><abbr title="无义突变">Nonsense mutation</abbr></strong>：在DNA序列中任何导致编码氨基酸的三联密码子改变为终止密码子（UAG,UGA,UAA）的突变，它在蛋白质合成提前终止，合成无功能或无意义的多肽。</li><li><strong><abbr title="移码突变">Frameshift mutation</abbr></strong>：指一种突变，其结果可导致核苷酸序列与相对应蛋白质的氨基酸序列之间的正常关系发生改变。移码突变是由删去或插入一个核苷酸的“点突变”构成的，突变位点之前的密码子不发生改变，但突变位点以后的所有密码子都发生变化，编码的氨基酸出现错误。</li><li><strong><abbr title="翻译">Translation</abbr></strong>：指将mRNA链上的核苷酸从一个特定的起始位点开始，按每3个核苷酸代表一个氨基酸的原则，依次合成一条多肽链的过程。</li><li><strong><abbr title="遗传密码">Genetic code</abbr></strong>：mRNA上每3个核苷酸翻译成多肽链上的一个氨基酸，这3个核苷酸就称为一个密码子（三联子密码）。</li><li><strong><abbr title="SD序列(P468、138)">Shine-Dalgarno sequence</abbr></strong>：存在于原核生物起始密码子AUG上游7~12个核苷酸处的一种4~7个核苷酸的保守片段，它与16S-rRNA 3’端反向互补，所以可以将mRNA的AUG起始密码子置于核糖体的适当位置以便起始翻译作用。根据首次识别其功能意义的科学家命名。</li><li><strong><abbr title="开放阅读框">ORF</abbr></strong>：从mRNA链的起始密码子AUG开始到终止密码子为止的连续核苷酸密码所对应的基因序列称为可读框。</li><li><strong><abbr title="氨基酸活化（P135）">Amino acid activation</abbr></strong>：氨基酸必须在氨酰tRNA合成酶的作用下生成活化氨基酸——AA-tRNA，才能进入肽链。</li><li><strong><abbr title="分子伴侣(P471)">Molecular chaperon</abbr></strong>：它是细胞中一类能够识别并结合到不完全折叠或装配的蛋白质上以帮助这些多肽正确折叠、转运或防止他们聚集的蛋白质，其本身不参与最终产物的形成。</li><li><strong><abbr title="热激蛋白">Heat shock protein</abbr></strong>：是在从细菌到哺乳动物中广泛存在一类热应激蛋白质。当有机体暴露于高温的时候，就会由热激发合成此种蛋白，来保护有机体自身。许多热休克蛋白具有分子伴侣活性。</li><li><strong><abbr title="信号肽(P475)">Signal peptide</abbr></strong>：在起始密码子后有一段编码疏水性氨基酸序列的RNA区域，该氨基酸序列就被称为信号肽序列，它负责把蛋白质导引到细胞含不同膜结构的亚细胞器内。</li><li><strong><abbr title="限制性内切酶">Restriction enzyme</abbr></strong>：是可以识别并附着特定的脱氧核苷酸序列，并对每条链中特定部位的两个脱氧核糖核苷酸之间的磷酸二酯键进行切割的一类酶，简称限制酶。</li><li><strong><abbr title="2-DE,双向凝胶电泳">Two-Dimensional Electrophoresis</abbr></strong>：是一种依赖蛋白质的等电点和分子大小的性质，通过组合等电聚焦电泳和聚丙烯酰胺凝胶电泳，分离大量混合蛋白质组份的技术。</li><li><strong><abbr title="美国国家生物技术信息中心">NCBI</abbr></strong>：美国国家生物技术信息中心，NCBI设置有与生物技术和生物医学相关的一系列数据库，是生物信息学工具和服务的重要资源。 主要数据库包括DNA序列GenBank，和生物医学文献书目数据库PubMed。 ⭐</li><li><strong><abbr title="cDNA末端的快速扩增(P468)">RACE</abbr>(rapid amplification)</strong>：利用PCR技术在已知部分cDNA序列的基础上特异性克隆其5’端或3’端缺失的序列。⭐</li><li><strong><abbr title="基因组DNA文库">Genomic DNA library</abbr></strong>：是某一生物体全部或部分基因的集合。将某个生物的基因组DNA或cDNA片段与适当载体的体外重组后，转化宿主细胞，所得的菌落或噬菌体的集合即为该生物的基因文库。⭐</li><li><strong><abbr title="蛋白质组学">Proteomics</abbr></strong>：只在蛋白质组水平上研究蛋白质的特征，包括蛋白质的表达水平、翻译与修饰、蛋白与蛋白相互作用等，并由此获得关于疾病发生、发展及细胞代谢等过程的整体认识。⭐</li><li><strong><abbr title="重组DNA技术">Recombinant DNA technology</abbr></strong>：又称基因工程。据不同的DNA片段（如某个基因或基因的一部分）按照预先的设计定向连接起来，在特定的受体细胞中与载体同时复制并得到表达，产生影响受体细胞的新的遗传性状的技术。</li><li><strong><abbr title="绿色荧光蛋白">GFP</abbr></strong>：是一个由约238个氨基酸组成的蛋白质，从蓝光到紫外线都能使其激发，发出绿色萤光。⭐</li><li><strong><abbr title="基因芯片">Gene chip</abbr></strong>：是利用原位合成法或将已合成好的一系列寡核苷酸分子以预先设定的排列方式固定在固相支持介质表面，形成高密度寡核苷酸阵列，并于样品杂交。通过检测杂交信号的强度及分布来进行分析。⭐</li><li><strong><abbr title="基因表达">Gene expression</abbr></strong>：基因经过转录、翻译，产生具有特异生物学功能的蛋白质分子或RNA分子的过程。⭐</li><li><strong><abbr title="基因敲除">Gene knock-out</abbr></strong>：针对一个序列已知但功能未知的基因，从DNA水平上设计实验，彻底破坏该基因的功能或消除其表达机制，从而推测该基因的生物学功能。</li><li><strong><abbr title="核定位序列">NLS</abbr></strong>：蛋白质中的一个常见的结构域，通常为一短的氨基酸序列，它能与入核载体相互作用，将蛋白质运进细胞核内。</li><li><strong><abbr title="安慰诱导物">Gratuitous inducer</abbr></strong>：指得是与转录调控中实际诱导物相似的一类高效诱导物，能诱导酶的合成，但又不被所诱导的酶分解。</li><li><strong><abbr title="操纵子(P469)">Operon</abbr></strong>：是指原核生物中包括结构基因及其上游的启动基因、操纵基因以及其他转录翻译调控元件组成的DNA片段，是转录的功能单位。⭐</li><li><strong><abbr title="分解代谢阻遏作用">Catabolite repression</abbr></strong>：又称代谢物阻遏作用，是葡萄糖或代谢物或葡萄糖的降解产物对一个基因或操纵子的阻遏作用。</li><li><strong><abbr title="空间特异性">Spatial specificity</abbr></strong>：又称细胞或组织特异性（cell or tissue specificity）是指在个体生长过程中，某种基因产物按不同组织空间顺序出现。</li><li><strong><abbr title="时间特异性">Temporal specificity</abbr></strong>：即按功能需要，某一特定基因的表达严格按特定的时间顺序发生。</li><li><strong><abbr title="基因调控">Gene regulation</abbr></strong>：所有生物的遗传信息，都是以基因的形式储存在细胞内的DNA（或RNA）分子中，随着个体的发育，DNA分子能有序地将其所承载的遗传信息，通过密码子-反密码子系统，转变成蛋白质分子，执行各种生理生化功能。这个从DNA到蛋白质的过程被称为基因表达，对这个过程的调节就称为基因表达的调控。</li><li><strong><abbr title="弱化子">Attenuator</abbr></strong>：是指原核生物操纵子中能显著减弱甚至终止转录作用的一段核苷酸序列，该区域能形成不同的二级结构，利用原核生物转录与翻译的偶联机制对转录进行调节。</li><li><strong><abbr title="转录组">Transcriptome</abbr></strong>：广义上指某一生理条件下，细胞内所有转录产物的集合，包括信使RNA、核糖体RNA、转运RNA及非编码RNA；狭义上指所有mRNA的集合。</li><li><strong><abbr title="转录因子">Transcription factor</abbr></strong>：包括转录激活因子（transcriptional activator）和转录阻遏因子（ transcriptiona repressor）。这类调节蛋白能识别并结合转录起始点的上游序列或远端增强子元件，通过DNA-蛋白质相互作用而调节转录活性，并决定不同基因的时间、空间特异性表达。</li><li><strong><abbr title="管家基因">Housekeeping gene</abbr></strong>：在个体的所有细胞中持续表达的基因。</li><li><strong><abbr title="泛素">Ubiquitin</abbr></strong>：含有高度保守的76个氨基酸的序列，它以羧基基团连接到目标蛋白质的赖氨酸残基的ε位氨基上，其主要作用是起始蛋白质的降解。</li><li><strong><abbr title="基因家族">Gene family</abbr></strong>：真核细胞中许多相关的基因常按功能成套组合。⭐</li><li><strong><abbr title="表观遗传">Epigenetic</abbr></strong>：指在基因的DNA序列没有发生改变的情况下，基因功能发生了可遗传的变化，并最终导致了表型的变化。</li><li><strong><abbr title="原癌基因">Proto-oncogene</abbr></strong>：是指存在于生物正常细胞基因组中的癌基因。正常情况下，存在于基因组中的原癌基因处于低表达或不表达状态，并发挥重要的生理功能。但在某些条件下，如病毒感染、化学致癌物或辐射作用等，原癌基因可被异常激活，转变为癌基因，诱导细胞发生癌变。</li><li><strong><abbr title="肿瘤抑制基因">Tumor suppressor gene</abbr></strong>：俗称抗癌基因，是一类存在于正常细胞内可抑制细胞生长并具有潜在抑癌作用的基因。抑癌基因在控制细胞生长、增殖及分化过程中起着十分重要的负调节作用，它与原癌基因相互制约，维持正负调节信号的相对稳定。当这类基因在发生突变、缺失或失活时可引起细胞恶性转化而导致肿瘤的发生。</li><li><strong><abbr title="人免疫缺损病毒">HIV</abbr></strong>：俗称艾滋病毒（AIDS），是一种能生存于人的血液中并攻击人体免疫系统的病毒，主要攻击人体免疫系统中重要的T4淋巴细胞，大量吞噬、破坏T4淋巴细胞，从而使得整个人体免疫系统遭到破坏，最终因丧失对各种疾病的抵抗能力而死亡。</li><li><strong><abbr title="乙肝病毒">HBV</abbr></strong>：是引起乙型肝炎（简称乙肝）的病原体，嗜肝DNA病毒科中哺乳动物病毒属的一员。</li><li><strong><abbr title="人乳头瘤病毒">HPV</abbr></strong>：是一种属于乳多空病毒科的乳头瘤空泡病毒A属，是球形DNA病毒，能引起人体皮肤黏膜的鳞状上皮增殖。</li><li><strong><abbr title="CRISPR/Cas9">CRISPR/Cas9</abbr></strong>：CRISPR是存在于细菌中的一种基因，该类基因组中含有曾经攻击过该细菌的病毒的基因片段。细菌透过这些基因片段来侦测并抵抗相同病毒的攻击，并摧毁其DNA。这类基因组是细菌免疫系统的关键组成部分。透过这些基因组，人类可以准确且有效地编辑生命体内的部分基因，也就是CRISPR/Cas9基因编辑技术。Cas9是第一个被广泛应用的CRISPR核酸酶。</li><li><strong><abbr title="基因治疗">Gene therapy</abbr></strong>：基因治疗是将具有治疗价值的基因，即“治疗基因”装配于带有在人体细胞中表达所必备元件的载体中，导入人体细胞，通过靶基因的表达来治疗遗传疾病。基因治疗是从根本上治疗遗传病的唯一途径。目前科学界关注的主要问题是基因治疗的有效性、安全性和质量可控性。</li><li><strong><abbr title="表达序列标签">EST</abbr></strong>：从已建好的cDNA库中随机取出一个克隆，从5’末端或3’末端对插入的cDNA片段进行一轮单向自动测序，所获得的约60-500bp的一段cDNA序列。代表一个完整基因的一小部分。</li><li><strong><abbr title="转录">Transcription</abbr></strong>：是指拷贝出一条与DNA链序列完全相同（除了T→U之外）的RNA单链的过程，是基因表达的核心步骤。</li><li><strong><abbr title="启动子">Promoter</abbr></strong>：是一段位于结构基因5’端上游区的DNA序列，能活化RNA聚合酶，使之与模板DNA准确地相结合并具有转录起始的特异性，对于基因转录起始是所必需，是基因表达调控的上游顺式作用元件之一。</li><li><strong><abbr title="RNA剪接">RNA splicing</abbr></strong>：从mRNA前体分子中切除被称为内含子（intron）的非编码区，并使基因中被称为外显子（exon）的编码区拼接形成成熟mRNA的过程就称为RNA的剪接。⭐</li><li><strong><abbr title="RNA编辑">RNA editing</abbr></strong>：是某些RNA，特别是mRNA的一种加工方式，它导致了DNA所编码的遗传信息的改变，因为经过编辑的mRNA序列发生了不同于模板DNA的变化。</li><li><strong><abbr title="长链非编码RNA(P334)">LncRNA</abbr></strong>：是一类长度大于200bp的非编码RNA，其在转录沉默、转录激活、染色体修饰、核内运输等均具有重要的功能。⭐</li><li><strong><abbr title="反式作用因子">Transacting factor</abbr></strong>：是指能够结合在顺式作用元件上调控基因表达的蛋白质或者RNAs。</li><li><strong><abbr title="GT-AG法则">GT-AG law</abbr></strong>：前体RNA中参与内含子剪接的两个特殊位点，即在内含子和外显子交界处有两个相当短的保守序列:5’端为GT, 3’端为 AG,称为GT-AG规律。GT-AG规则主要适用于(或是全部)真核生物基因的剪接位点。</li><li><strong><abbr title="顺式作用元件(P474)">Cis-acting element</abbr></strong>：是指启动子和基因的调节序列。主要包括启动子（promoter）、增强子（enhancer）、沉默子（silencer）等。</li><li><strong><abbr title="增强子(P476、97)">Enhancer</abbr></strong>：能强化转录起始的序列，也称为强化子。它们不是启动子的一部分，但能增强或促进转录的起始。</li><li><strong><abbr title="质粒载体">Plasmid Vector</abbr></strong>：是在天然质粒的基础上为适应实验室操作而进行人工构建的质粒。通常带有一个或一个以上的选择性标记基因（如抗生素抗性基因）和一个人工合成的含有多个限制性内切酶识别位点的多克隆位点序列，并去掉了大部分非必需序列，使分子量尽可能减少，以便于基因工程操作。</li><li><strong><abbr title="引物">Primer</abbr></strong>：是指一段较短的单链RNA或DNA，它能与DNA的一条链配对提供游离的3-OH末端以作为DNA聚合酶合成脱氧核苷酸链的起始点。</li><li><strong><abbr title="转化">Transformation</abbr></strong>：是某一基因型的细胞从周围介质中吸收来自另一基因型的细胞的DNA而使它的基因型和表现型发生相应变化的现象。</li><li><strong><abbr title="聚合酶链式反应">PCR</abbr></strong>：是指通过模拟体内DNA复制方式在体外选择性地将DNA某个特定区域扩增出来的技术。</li><li><strong><abbr title="基因克隆">Gene cloning</abbr></strong>：在分子生物学上，人们把将外源DNA插入具有复制能力的载体DNA中，转入宿主细胞使之得以永久保存和复制这种过程称为基因克隆。</li><li><strong><abbr title="TATA区(P468、94)">TATA box</abbr></strong>：在真核生物基因中位于转录起始点上游-25～-30bp处的富含AT的保守区，是RNA聚合酶与启动子的结合位点，也称为Hogness区（Hogness box），类似于原核基因中的Pribnow区。</li><li><strong><abbr title="Pribnow区(P468、85)">Pribnow box</abbr></strong>：在启动子区有一个由5个核苷酸组成的共同序列，是RNA聚合酶的紧密结合点，称为Pribnow区，这个区的中央大约位于起始点上游10bp处，所以又称为-10区。</li><li><strong><abbr title="RNA干扰">RNAi</abbr></strong>：是利用双链小RNA高效、特异性降解细胞内同源mRNA，从而阻断体内靶基因表达，使细胞出现靶基因缺失的表型。⭐</li><li><strong><abbr title="C值">C value</abbr></strong>：一种生物的单倍体基因组的DNA总量称为C值。</li><li><strong><abbr title="CpG岛（P467）">CpG岛</abbr></strong>：真核生物中，成串出现在DNA上的CpG二核苷酸。5-甲基胞嘧啶主要出现在CpG序列、CpXpG、CCA/TGG和GATC中，在高等生物CpG二核苷酸序列中的C通常是甲基化的，极易自发脱氨，生成胸腺嘧啶，所以CpG二核苷酸序列出现的频率远远低于按核苷酸组成计算出的频率。</li></ol><h2 id="问答题"><a class="header-anchor" href="#问答题"></a>问答题</h2><h3 id="1、简述真核与原核细胞中翻译起始的主要区别（P136）"><a class="header-anchor" href="#1、简述真核与原核细胞中翻译起始的主要区别（P136）"></a>1、简述真核与原核细胞中翻译起始的主要区别（P136）</h3><ol><li><p>翻译起始复合物形成的过程不同</p><ul><li>真核生物：核蛋白体大小亚基分离；起始氨基酰-tRNA的结合； mRNA在小亚基定位结合；核蛋白体大亚基结合。</li><li>原核生物：核蛋白体大小亚基分离； mRNA在小亚基定位结合；起始氨基酰-tRNA的结合；核蛋白体大亚基结合。</li></ul></li><li><p>参与物质不同</p><ul><li>真核生物，核蛋白体是80S （40S＋60S）;</li><li>起始因子种类多；</li><li>起始tRNA的Met不需甲酰化；</li><li>mRNA无SD序列，5’帽子和3’poly A尾结构与mRNA在核蛋白体就位有关；</li><li>需要帽子结合蛋白复合物(eIF-4F)参与;</li></ul></li></ol><h3 id="2、简述遗传密码的特点（P120）"><a class="header-anchor" href="#2、简述遗传密码的特点（P120）"></a>2、简述遗传密码的特点（P120）</h3><ol><li>密码子的连续性</li><li>密码子的简并性</li><li>密码子的变偶（摆动）性</li><li>密码子的通用性和变异性</li><li>方向性</li></ol><h3 id="3、简述蛋白质合成后修饰方式"><a class="header-anchor" href="#3、简述蛋白质合成后修饰方式"></a>3、简述蛋白质合成后修饰方式</h3><ol><li>多肽链折叠为天然三级结构<br>在分子伴侣的作用下形成正确的折叠；在二硫键异构酶的作用下形成正确二硫键；在肽酰脯氨酸顺反异构酶的作用下形成正确肽键异构。</li><li>一级结构修饰<br>去除N端蛋氨酸残基；个别氨基酸的共价修饰，如糖基化，甲基化，磷酸化，羟基化，二硫键形成，亲脂性修饰等。</li><li>高级结构修饰<br>通过非共价键亚基聚合形成四级结构；与辅基结合形成完整的结合蛋白。</li></ol><h3 id="4、PCR-扩增的原理、PCR-扩增常用体系和程序"><a class="header-anchor" href="#4、PCR-扩增的原理、PCR-扩增常用体系和程序"></a>4、<abbr title="聚合酶链式反应">PCR</abbr> 扩增的原理、<abbr title="聚合酶链式反应">PCR</abbr> 扩增常用体系和程序</h3><p>原理：</p><p>首先将模板DNA（质粒、基因组DNA或mRNA反转录产生的cDNA）在临近沸点的温度下加热分离成单链DNA分子，然后DNA聚合酶在一对引物（一小段单链DNA）的引导下以单链DNA为模板并利用反应混合物中的4种脱氧核苷三磷酸（dNTP）合成新的DNA互补链。（P175）</p><blockquote><p>DNA聚合酶是一种天然产生的催化DNA（包括RNA）合成和修复的生物大分子。所有生物体基因组的准确复制都依赖于这类酶的活性。PCR反应中使用的DNA聚合酶不同于一般的聚合酶，它具有很强的耐高温性，在高温下数小时不丧失酶活性。<br>DNA聚合酶开始工作时先要产生一小段双链DNA来启动（“引导”）新链的合成，这一小段引导新链合成的DNA序列就被称为&quot;引物&quot;，引导DNA聚合酶特异性扩增目标基因片段。所以，通过设计特定基因两端的引物序列，即可实现对目标基因的扩增。</p></blockquote><p><abbr title="聚合酶链式反应">PCR</abbr> 扩增常用体系：</p><p>ddH<sub>2</sub>O<br><em>Taq</em> 缓冲液<br>dNTP Mix<br>Mg<sup>2+</sup><br><em>Taq</em> DNA聚合酶<br>引物<br>DNA模板</p><p>程序：</p><p>预变性：94℃，3min；<br>30~35个循环（变性：94℃，30s；退火：60℃，30s；延伸：72℃，30s）；<br>终延伸：72℃，8min。<br>结束保存：4℃</p><h3 id="5、简述乳糖操纵子调节机制"><a class="header-anchor" href="#5、简述乳糖操纵子调节机制"></a>5、简述乳糖操纵子调节机制</h3><ol><li>乳糖操纵子是由调节基因，启动子，操纵基因及Z/Y/A三个结构基因组成。</li><li>阻遏蛋白的负调控：无乳糖时，阻遏蛋白结合操纵基因，妨碍RNA聚合酶结合启动子，抑制结构基因转录。有乳糖时，乳糖（诱导剂）结合阻遏蛋白， 导致其不能封闭操纵基因，结构基因可以转录。</li><li>cAMP-CAP复合物的正调控：无葡萄糖时，cAMP浓度高，形成的cAMP-CAP复合物结合于CAP结合位点，增强启动子转录活性。有葡萄糖时，cAMP浓度低，cAMP-CAP复合物形成受阻，影响转录活性。</li><li>正、负调控机制相辅相成。cAMP-CAP复合物是转录必需的，同时阻遏蛋白进一步控制转录启动。综上，乳糖操纵子最强的表达条件是有乳糖无葡萄糖。</li></ol><h3 id="6、真核生物转录因子中DNA结合结构域类型有哪些？"><a class="header-anchor" href="#6、真核生物转录因子中DNA结合结构域类型有哪些？"></a>6、真核生物转录因子中DNA结合结构域类型有哪些？</h3><ol><li>螺旋转角螺旋</li><li>螺旋环螺旋</li><li>亮氨酸拉链</li><li>锌指结构</li></ol><h3 id="7、真核生物转录因子中激活结构域的特征有哪些？"><a class="header-anchor" href="#7、真核生物转录因子中激活结构域的特征有哪些？"></a>7、真核生物转录因子中激活结构域的特征有哪些？</h3><ol><li>富含酸性氨基酸</li><li>富含谷氨酰胺</li><li>富含脯氨酸</li></ol><h3 id="8、真核生物的基因表达调控水平主要包括哪些？"><a class="header-anchor" href="#8、真核生物的基因表达调控水平主要包括哪些？"></a>8、真核生物的基因表达调控水平主要包括哪些？</h3><ol><li>染色体、染色质水平上的调控</li><li>转录调控</li><li>转录后加工调控</li><li>翻译调控</li><li>翻译后加工的调控</li></ol><h3 id="9、一代测序技术和二代测序技术原理和特点"><a class="header-anchor" href="#9、一代测序技术和二代测序技术原理和特点"></a>9、一代测序技术和二代测序技术原理和特点</h3><ol><li>一代测序即Sanger测序是基于DNA合成的双脱氧终止技术。<br>其原理是在测序反应中加入待测样本作为模板，加入特异性引物，DNA聚合酶，dNTP及ddNTP，当双脱氧ddNTP取代常规脱氧核苷酸参入到合成后，就阻断了DNA的合成反应，因此将会产生不同长度的DNA片段混合物，通过电泳及自显影技术可直接读出DNA的顺序。<br>特点是测序反应的长度较短，一般不超过1000bp。</li><li>第二代测序技术是指对第一代测序技术的改进技术。<br>主要对测序流程中的样品准备，分子标记，化学反应试剂，及测序的平行化等方面进行了大量改进，包括Roche454焦磷酸测序，基于合成的循环阵列测序及ABI SOLiD基于连接的的测序等。<br>二代测序技术的特点是，大大提高了测序的自动化和平行化，大大降低了测序成本。</li></ol><h3 id="10、试分析分子生物学的发展趋势"><a class="header-anchor" href="#10、试分析分子生物学的发展趋势"></a>10、试分析分子生物学的发展趋势</h3><p>分子生物学是现代生物学的发展方向，分子生物学重点研究的领域包括</p><ol><li>生物大分子的结构和功能的研究；</li><li>真核生物基因及基因表达调控的研究；</li><li>分子神经生物学的研究；</li><li>医学分子生物学的研究；</li><li>植物分子生物学的研究；</li><li>分子进化的研究等。</li></ol><p>分子生物学带动了整个生物科学的全面发展。</p><h3 id="11、简述原核生物DNA复制过程中需要哪些酶和蛋白的参与，各具有何作用"><a class="header-anchor" href="#11、简述原核生物DNA复制过程中需要哪些酶和蛋白的参与，各具有何作用"></a>11、简述原核生物DNA复制过程中需要哪些酶和蛋白的参与，各具有何作用</h3><p>以大肠杆菌为例，原核生物DNA复制主要有一下酶和蛋白质参与。</p><ol><li>DNA拓扑异构酶：DNA拓扑异构酶的作用是，将解链过程中产生的正超螺旋消除，有利于解链进行；</li><li>DNA解链酶：DNA解链酶的作用是，断开DNA双螺旋中碱基之间的氢键；</li><li>单链DNA结合蛋白：单链DNA结合蛋白，与单链DNA结合，防止重新形成双链；</li><li>引发酶：引发酶的作用是合成一小段RNA引物，引导DNA聚合；</li><li>DNA聚合酶I/II/III：DNA聚合酶I的作用是既可以合成DNA，又可以水解DNA，确保DNA合成的准确性；DNA聚合酶II的作用是用来修复受损的DNA；DNA聚合酶III是原核生物合成DNA的主要酶；</li><li>DNA连接酶：DNA连接酶的作用是形成3’,5’磷酸二酯键将冈崎片段连接起来。</li></ol><h3 id="12、请写出6种以上RNA及其功能"><a class="header-anchor" href="#12、请写出6种以上RNA及其功能"></a>12、请写出6种以上RNA及其功能</h3><ol><li>rRNA  即核糖体RNA，是蛋白质合成的场所。</li><li>mRNA 即 信使RNA，是蛋白质合成的模板。</li><li>tRNA 即转运RNA，是蛋白质合成过程中运载氨基酸的工具</li><li>hnRNA 即核内不均一RNA，是mRNA的前体。</li><li>microRNA，即微小RNA，是参与转录后基因表达调控的小分子RNA</li><li>lncRNA, 即长链非编码RNA，可与DNA、蛋白质相互作用，可能具有多种生物学功能。</li></ol><h3 id="13、5’端帽子和polyA尾巴各有什么功能"><a class="header-anchor" href="#13、5’端帽子和polyA尾巴各有什么功能"></a>13、5’端帽子和polyA尾巴各有什么功能</h3><ol><li>帽子结构使mRNA免遭核酸酶的破坏，可能是蛋白质合成起始信号的一部分。</li><li>多聚A提高mRNA在细胞基质中的稳定性，也参与蛋白质合成的起始。</li></ol><h3 id="14、简述原核生物两种转录终止的机制（P89）"><a class="header-anchor" href="#14、简述原核生物两种转录终止的机制（P89）"></a>14、简述原核生物两种转录终止的机制（P89）</h3><p>RNA聚合酶在DNA模板上停顿下来不再前进，转录产物RNA链从转录复合物上脱落下来即转录终止。依据是否需要蛋白质因子的参与，原核生物转录终止分为：依赖ρ 因子的转录终止和不依赖ρ因子的转录终止。</p><ol><li>当新生成的RNA链因含有富含GC的反向重复序列而形成茎环结构时，RNA聚合酶移动减慢，造成高度延宕，茎环结构末端的一串U序列与DNA稳定性较差，从而使新生成的链释放出来。</li><li>当新生成的RNA链反向重复序列GC含量较少时，且茎环结构末端不含有一串U序列，此时转录的终止需要ρ因子的帮助，ρ因子由6个亚基组成的蛋白质，具有ATP酶和解旋酶的活性，能将RNA-DNA杂交双链解开，使RNA脱离模板，从而终止RNA转录。</li></ol><h3 id="15、简述原核生物与真核生物启动子的主要差别"><a class="header-anchor" href="#15、简述原核生物与真核生物启动子的主要差别"></a>15、简述原核生物与真核生物启动子的主要差别</h3><ol><li>原核生物：启动子拥有-10区和-35区，是RNA聚合酶的识别和结合位点；</li><li>真核生物：启动子在-25~-35区含有TATA box即核心启动子区，在-70~-80区含有CAAT box，另外还常含有GC区及增强区，需要多种转录调控因子。</li></ol><h2 id="名词解释自测"><a class="header-anchor" href="#名词解释自测"></a>名词解释自测</h2><ol><li><p><abbr title="碱基对">Base pair</abbr>(<u>碱基对</u>)：<u>是一对被氢键连接起来相互匹配的碱基(即A：T，G：C，A：U相互作用)，是形成DNA、RNA单体以及编码遗传信息的化学结构。</u></p></li><li><p><abbr title="微卫星DNA">Microsatellite DNA</abbr>(<u>微卫星DNA</u>)：<u>重复单位序列最短，只有2～6bp，串联成簇，长度50～100bp，又称为短串联重复序列（Short Tandem Repeat STR)。广泛分布于基因组中。 其中富含A-T碱基对。</u></p></li><li><p><abbr title="复性">Renaturation</abbr>(<u>复性</u>)：<u>变性后成为单链的DNA，在适当条件下又能恢复成为双链DNA，这成为DNA复性或退火。</u></p></li><li><p><abbr title="退火">Annealing</abbr>（<u>退火</u>）：<u>见上。</u></p></li><li><p><abbr title="分子杂交">Molecular hybridization</abbr>（<u>分子杂交</u>）：<u>不同的DNA片段之间，DNA片段与RNA片段之间，如果彼此间的核苷酸排列顺序互补也可以复性，形成新的双螺旋结构。这种按照互补碱基配对而使不完全互补的两条多核苷酸相互结合的过程称为分子杂交。</u></p></li><li><p><abbr title="基因组">Genome</abbr>（<u>基因组</u>）：<u>一个细胞或病毒所携带的全部遗传信息或整套基因，包括每一条染色体和所有亚细胞器的DNA序列信息。</u></p></li><li><p><abbr title="增色效应">Hyperchromic effect</abbr> (<u>增色效应</u>)：<u>指因高分子结构的改变，而使摩尔吸光系数(molar extinction coefficient) ε 增大的现象，亦称高色效应。</u></p></li><li><p>Tm（Melting temperature）（<u>解链温度</u>）：<u>利用加热使溶液中50%的DNA分子成为单链所需温度称为解链温度。</u></p></li><li><p><abbr title="DNA的半保留复制(P467、42)">Semi-conservative replication</abbr> （<u>半保留复制</u>）：<u>在DNA复制过程中，每条链分别作为模板合成新链，产生互补的两条链。这样新形成的两个DNA分子与原来DNA分子的碱基顺序完全一样。因此，每个子代分子的一条链来自亲代DNA，另一条链则是新合成的，这种复制方式被称为DNA的半保留复制。</u></p></li><li><p><abbr title="DNA的半不连续复制(P467、45)">Semi-discontinuous replication</abbr> （<u>半不连续复制</u>）：<u>DNA复制过程中前导链的复制是连续的，而另一条链，即滞后链的复制是中断的、不连续的。</u></p></li><li><p><abbr title="C值矛盾">C-value paradox</abbr>（<u>C值矛盾</u>）：<u>一种生物的单倍体基因组的DNA总量称为C值。生物的C值并不与生物复杂程度（或生物在进化上所处的地位）相关，这一现象称为C值悖论。</u></p></li><li><p><abbr title="遗传中心法则">Genetic central dogma</abbr>（<u>遗传中心法则</u>）：<u>由克里克首次提出的遗传信息传递规律，该法则阐明了DNA复制，RNA转录以及翻译产生蛋白质在生命过程中的核心地位。</u></p></li><li><p><abbr title="Klenow片段">Klenow fragment</abbr> （<u>Klenow片段</u>）：<u>原核生物DNA-pol经特异的蛋白水解酶形成的大片段，3’—5’核酸外切酶活性和DNA聚合酶活性 Klenow片段是实验室合成DNA，进行分子生物学研究中常用的工具酶。</u></p></li><li><p>split \ <abbr title="断裂基因">interrupted gene</abbr> （<u>断裂基因</u>）：<u>是真核生物的结构基因。由若干个编码序列和非编码序列互相间隔开但又连续镶嵌而成，去除非编码序列再连接后，可翻译出由连续氨基酸组成的完整蛋白质，这些基因称为断裂基因。</u></p></li><li><p><abbr title="内含子">Intron</abbr> （<u>内含子</u>）：<u>是一个基因中非编码DNA片段，它分开相邻的外显子，内含子是阻断基因线性表达的序列。</u></p></li><li><p><abbr title="外显子">Exon</abbr> （<u>外显子</u>）：<u>是真核生物基因的一部分，它在剪接（Splicing）后仍会被保存下来，并可在蛋白质生物合成过程中被表达为蛋白质。</u></p></li><li><p><abbr title="重叠基因">Overlapping gene</abbr> （<u>重叠基因</u>）：<u>具有部分共用核苷酸序列的基因，即同一段DNA携带了两种或两种以上不同蛋白质的编码信息。重叠的序列可以是调控基因，也可以是结构基因。常见于病毒和噬菌体基因组中。</u></p></li><li><p><abbr title="质粒">Plasmid</abbr> （<u>质粒</u>）：<u>细菌内染色体外的环状DNA分子。</u></p></li><li><p><abbr title="单核苷酸多态性（P470、66）">SNP(Single nucleotide polymorphism)</abbr> （<u>单核苷酸多态性</u>）：<u>只分散于基因组中的单个碱基的差异，包括单个碱基的缺失和插入，但更常见的是单个核苷酸的替换。</u></p></li><li><p><abbr title="端粒酶">Telomerase</abbr> （<u>端粒酶</u>）：<u>是由RNA和蛋白质组成的一种核糖核蛋白（RNP）复合体，具有逆转录酶活性，能利用自身携带的RNA链作为模板，用dDTP为原料，以逆转录方式催化互补于RNA模板的后随链DNA片段的合成。（或把DNA复制损失的端粒填补起来，把端粒修复延长，使得细胞分裂的次数增加。）</u></p></li><li><p><abbr title="反转录">Reverse transcription</abbr> （<u>反转录</u>）：<u>以mRNA为模板，在反转录酶的作用下合成cDNA的过程。</u></p></li><li><p>cDNA (Complementary DNA) （<u>互补DNA</u>）：<u>特指在体外经过逆转录后与RNA互补的DNA链。与基因组DNA不同，cDNA没有内含子而只有外显子的序列 。在遗传工程方面广为应用。</u></p></li><li><p><abbr title="转座子">Transposon</abbr> （<u>转座子</u>）：<u>能够在没有序列相关性的情况下独立插入基因组新位点上的一段DNA序列，是存在于染色体DNA上可自主复制和位移的基本单位。</u></p></li><li><p><abbr title="重组修复">Recombination repairing</abbr> （<u>重组修复</u>）：<u>又被称为“复制后修复”，它发生在复制之后，机体细胞对在复制起始时尚未修复的DNA损伤部位可以先复制再修复，及先跳过该损伤部位，在新合成链中留下一个对应于损伤序列的缺口，该缺口由DNA重组来修复:先从同源DNA母链上将相应核苷酸序列片断一致子链缺口处，然后再用新合成序列补上母链空缺。大肠杆菌的rec基因编码主要的重组修复系统。</u></p></li><li><p><abbr title="无义突变">Nonsense mutation</abbr> （<u>无义突变</u>）：<u>在DNA序列中任何导致编码氨基酸的三联密码子改变为终止密码子（UAG,UGA,UAA）的突变，它在蛋白质合成提前终止，合成无功能或无意义的多肽。</u></p></li><li><p><abbr title="移码突变">Frameshift mutation</abbr> （<u>移码突变</u>）：<u>指一种突变，其结果可导致核苷酸序列与相对应蛋白质的氨基酸序列之间的正常关系发生改变。移码突变是由山区或插入一个核苷酸的“点突变”构成的，突变位点之前的密码子不发生改变，但突变位点以后的所有密码子都发生变化，编码的氨基酸出现错误。</u></p></li><li><p><abbr title="翻译">Translation</abbr> (<u>翻译</u>)：<u>指将mRNA链上的核苷酸从一个特定的起始位点开始，按每3个核苷酸代表一个氨基酸的原则，依次合成一条多肽链的过程。</u></p></li><li><p><abbr title="遗传密码">Genetic code</abbr> （<u>遗传密码</u>）：<u>mRNA上每3个核苷酸翻译成多肽链上的一个氨基酸，这3个核苷酸就称为一个密码子（三联子密码）。</u></p></li><li><p><abbr title="SD序列(P468、138)">Shine-Dalgarno sequence</abbr> （<u>SD 序列</u>）：<u>存在于原核生物起始密码子AUG上游7<sub>12个核苷酸处的一种4</sub>7个核苷酸的保守片段，它与16S-rRNA 3’端反向互补，所以可以将mRNA的AUG起始密码子置于核糖体的适当位置以便起始翻译作用。根据首次识别其功能意义的科学家命名。</u></p></li><li><p><abbr title="开放阅读框">ORF</abbr> （<u>开放阅读框</u>）：<u>从mRNA链的起始密码子AUG开始到终止密码子为止的连续核苷酸密码所对应的基因序列称为可读框。</u></p></li><li><p><abbr title="氨基酸活化（P135）">Amino acid activation</abbr> (<u>氨基酸活化</u>)：<u>氨基酸必须在氨酰tRNA合成酶的作用下生成活化氨基酸——AA-tRNA</u></p></li><li><p><abbr title="分子伴侣(P471)">Molecular chaperon</abbr> （<u>分子伴侣</u>）：<u>它是细胞中一类能够识别并结合到不完全折叠或装配的蛋白质上以帮助这些多肽正确折叠、转运或防止他们聚集的蛋白质，其本身不参与最终产物的形成。</u></p></li><li><p><abbr title="热激蛋白">Heat shock protein</abbr> （<u>热激蛋白</u>）：<u>热休克蛋白 Heat Shock Proteins (HSPs)是在从细菌到哺乳动物中广泛存在一类热应激蛋白质。当有机体暴露于高温的时候，就会由热激发合成此种蛋白，来保护有机体自身。许多热休克蛋白具有分子伴侣活性。</u></p></li><li><p><abbr title="信号肽(P475)">Signal peptide</abbr> （<u>信号肽</u>）：<u>在起始密码子后有一段编码疏水性氨基酸序列的RNA区域，该氨基酸序列就被称为信号肽序列，它负责把蛋白质导引到细胞还不同膜结构的亚细胞器内。</u></p></li><li><p><abbr title="限制性内切酶">Restriction enzyme</abbr> （<u>限制性内切酶</u>）：<u>是可以识别并附着特定的脱氧核苷酸序列，并对每条链中特定部位的两个脱氧核糖核苷酸之间的磷酸二酯键进行切割的一类酶，简称限制酶。</u></p></li><li><p><abbr title="2-DE,双向凝胶电泳">Two-Dimensional Electrophoresis</abbr> （<u>2-DE,双向凝胶电泳</u>）：<u>是一种依赖蛋白质的等电点和分子大小的性质，通过组合等电聚焦电泳和聚丙烯酰胺凝胶电泳，分离大量混合蛋白质组份的技术。</u></p></li><li><p><abbr title="美国国家生物技术信息中心">NCBI</abbr> （<u>美国国家生物技术信息中心</u>）</p></li><li><p><abbr title="cDNA末端的快速扩增(P468)">RACE</abbr> （<u>末端快速扩增法</u>）：<u>利用PCR技术在已知部分cDNA序列的基础上特异性克隆其5’端或3’端缺失的序列。</u></p></li><li><p><abbr title="基因组DNA文库">Genomic DNA library</abbr> （<u>基因组DNA文库</u>）：<u>是某一生物体全部或部分基因的集合。将某个生物的基因组DNA或cDNA片段与适当载体的体外重组后，转化宿主细胞，所得的菌落或噬菌体的集合即为该生物的基因文库。</u></p></li><li><p><abbr title="蛋白质组学">Proteomics</abbr> （<u>蛋白质组学</u>）：<u>只在蛋白质组水平上研究蛋白质的特征，包括蛋白质的表达水平、翻译与修饰、蛋白与蛋白相互作用等，并由此获得关于疾病发生、发展及细胞代谢等过程的整体认识。</u></p></li><li><p><abbr title="重组DNA技术">Recombinant DNA technology</abbr> （<u>重组DNA技术</u>）：<u>又称基因工程。据不同的DNA片段（如某个基因或基因的一部分）按照预先的设计定向连接起来，在特定的受体细胞中与载体同时复制并得到表达，产生影响受体细胞的新的遗传性状的技术。</u></p></li><li><p><abbr title="绿色荧光蛋白">GFP</abbr> （<u>绿色荧光蛋白</u>）：<u>是一个由约238个氨基酸组成的蛋白质，从蓝光到紫外线都能使其激发，发出绿色萤光。</u></p></li><li><p><abbr title="基因芯片">Gene chip</abbr> （<u>基因芯片</u>）：<u>是利用原位合成法或将已合成好的一系列寡核苷酸分子以预先设定的排列方式固定在固相支持介质表面，形成高密度寡核苷酸阵列，并于样品杂交。通过检测杂交信号的强度及分布来进行分析。</u></p></li><li><p><abbr title="基因表达">Gene expression</abbr> （<u>基因表达</u>）：<u>基因经过转录、翻译，产生具有特异生物学功能的蛋白质分子或RNA分子的过程。</u></p></li><li><p><abbr title="基因敲除">Gene knock-out</abbr> （<u>基因敲除</u>）：<u>针对一个序列已知但功能未知的基因，从DNA水平上设计实验，彻底破坏该基因的功能或消除其表达机制，从而推测该基因的生物学功能。</u></p></li><li><p><abbr title="核定位序列">NLS</abbr>（<u>核定位序列</u>）：<u>蛋白质中的一个常见的结构域，通常为一短的氨基酸序列，它能与入核载体相互作用，将蛋白质运进细胞核内。</u></p></li><li><p><abbr title="安慰诱导物">Gratuitous inducer</abbr> （<u>安慰诱导物</u>）：<u>指是与转录调控中实际诱导物相似的一类高效诱导物，能诱导酶的合成，但又不被所诱导的酶分解。</u></p></li><li><p><abbr title="操纵子(P469)">Operon</abbr> （<u>操纵子</u>）：<u>是指原核生物中包括结构基因及其上游的启动基因、操纵基因以及其他转录翻译调控元件组成的DNA片段，是转录的功能单位。</u></p></li><li><p><abbr title="分解代谢阻遏作用">Catabolite repression</abbr> （<u>分解代谢阻遏作用</u>）：<u>又称代谢物阻遏作用，是葡萄糖或代谢物或葡萄糖的降解产物对一个基因或操纵子的阻遏作用。</u></p></li><li><p><abbr title="空间特异性">Spatial specificity</abbr> （<u>空间特异性</u>）：<u>又称细胞或组织特异性（cell or tissue specificity）是指在个体生长过程中，某种基因产物按不同组织空间顺序出现。</u></p></li><li><p><abbr title="时间特异性">Temporal specificity</abbr> （<u>时间特异性</u>）：<u>即按功能需要，某一特定基因的表达严格按特定的时间顺序发生。</u></p></li><li><p><abbr title="基因调控">Gene regulation</abbr> （<u>基因调控</u>）：<u>所有生物的遗传信息，都是以基因的形式储存在细胞内的DNA（或RNA）分子中，随着个体的发育，DNA分子能有序地将其所承载的遗传信息，通过密码子-反密码子系统，转变成蛋白质分子，执行各种生理生化功能。这个从DNA到蛋白质的过程被称为基因表达，对这个过程的调节就称为基因表达的调控。</u></p></li><li><p><abbr title="弱化子">Attenuator</abbr> （<u>弱化子</u>）：<u>是指原核生物操纵子中能显著减弱甚至终止转录作用的一段核苷酸序列，该区域能形成不同的二级结构，利用原核生物转录与翻译的偶联机制对转录进行调节。</u></p></li><li><p><abbr title="转录组">Transcriptome</abbr>（<u>转录组</u>）：<u>广义上指某一生理条件下，细胞内所有转录产物的集合，包括信使RNA、核糖体RNA、转运RNA及非编码RNA；狭义上指所有mRNA的集合。</u></p></li><li><p><abbr title="转录因子">Transcription factor</abbr>（<u>转录因子</u>）：<u>包括转录激活因子（transcriptional activator）和转录阻遏因子（ transcriptiona repressor）。这类调节蛋白能识别并结合转录起始点的上游序列或远端增强子元件，通过DNA-蛋白质相互作用而调节转录活性，并决定不同基因的时间、空间特异性表达。</u></p></li><li><p><abbr title="管家基因">Housekeeping gene</abbr>（<u>管家基因</u>）：<u>在个体的所有细胞中持续表达的基因。</u></p></li><li><p><abbr title="泛素">Ubiquitin</abbr> （<u>泛素</u>）：<u>含有高度保守的76个氨基酸的序列，它以羧基基团连接到目标蛋白质的赖氨酸残基的ε位氨基上，其主要作用是起始蛋白质的降解。</u></p></li><li><p><abbr title="基因家族">Gene family</abbr> （<u>基因家族</u>）：<u>真核细胞中许多相关的基因常按功能成套组合。</u></p></li><li><p><abbr title="表观遗传">Epigenetic</abbr>（<u>表观遗传</u>）：<u>指在基因的DNA序列没有发生改变的情况下，基因功能发生了可遗传的变化，并最终导致了表型的变化。</u></p></li><li><p><abbr title="原癌基因">Proto-oncogene</abbr>（<u>原癌基因</u>）：<u>原癌基因（细胞癌基因）是指存在于生物正常细胞基因组中的癌基因。正常情况下，存在于基因组中的原癌基因处于低表达或不表达状态，并发挥重要的生理功能。但在某些条件下，如病毒感染、化学致癌物或辐射作用等，原癌基因可被异常激活，转变为癌基因，诱导细胞发生癌变。</u></p></li><li><p><abbr title="肿瘤抑制基因">Tumor suppressor gene</abbr>（<u>肿瘤抑制基因</u>）：<u>俗称抗癌基因，是一类存在于正常细胞内可抑制细胞生长并具有潜在抑癌作用的基因。抑癌基因在控制细胞生长、增殖及分化过程中起着十分重要的负调节作用，它与原癌基因相互制约，维持正负调节信号的相对稳定。当这类基因在发生突变、缺失或失活时可引起细胞恶性转化而导致肿瘤的发生。</u></p></li><li><p><abbr title="人免疫缺损病毒">HIV</abbr>（<u>人免疫缺损病毒</u>）：<u>俗称艾滋病毒（AIDS），是一种能生存于人的血液中并攻击人体免疫系统的病毒，主要攻击人体免疫系统中重要的T4淋巴细胞，大量吞噬、破坏T4淋巴细胞，从而使得整个人体免疫系统遭到破坏，最终因丧失对各种疾病的抵抗能力而死亡。</u></p></li><li><p><abbr title="乙肝病毒">HBV</abbr>（<u>乙肝病毒</u>）：<u>是嗜肝DNA病毒科中哺乳动物病毒属的一员。</u></p></li><li><p><abbr title="人乳头瘤病毒">HPV</abbr>(<u>人乳头瘤病毒</u>)：<u>是一种属于乳多空病毒科的乳头瘤空泡病毒A属，是球形DNA病毒，能引起人体皮肤黏膜的鳞状上皮增殖。</u></p></li><li><p><abbr title="CRISPR/Cas9">CRISPR/Cas9</abbr>：<u>CRISPR是存在于细菌中的一种基因，该类基因组中含有曾经攻击过该细菌的病毒的基因片段。细菌透过这些基因片段来侦测并抵抗相同病毒的攻击，并摧毁其DNA。这类基因组是细菌免疫系统的关键组成部分。透过这些基因组，人类可以准确且有效地编辑生命体内的部分基因，也就是CRISPR/Cas9基因编辑技术。Cas9是第一个被广泛应用的CRISPR核酸酶。</u></p></li><li><p><abbr title="基因治疗">Gene therapy</abbr>（<u>基因治疗</u>）：<u>基因治疗是将具有治疗价值的基因，即“治疗基因”装配于带有在人体细胞中表达所必备元件的载体中，导入人体细胞，通过靶基因的表达来治疗遗传疾病。基因治疗是从根本上治疗遗传病的唯一途径。目前科学界关注的主要问题是基因治疗的有效性、安全性和质量可控性。</u></p></li><li><p><abbr title="表达序列标签">EST</abbr>（<u>表达序列标签</u>）：<u>从已建好的CDNA库中随机取出一个克隆，从5’末端或3’末端对插入的cDNA片段进行一轮单向自动测序，所获得的约60-500bp的一段cDNA序列。</u></p></li><li><p><abbr title="转录">Transcription</abbr> （<u>转录</u>）：<u>是指拷贝出一条与DNA链序列完全相同（除了T→U之外）的RNA单链的过程，是基因表达的核心步骤。</u></p></li><li><p><abbr title="启动子">Promoter</abbr> （<u>启动子</u>）：<u>是一段位于结构基因5’端上游区的DNA序列，能活化RNA聚合酶，使之与模板DNA准确地相结合并具有转录起始的特异性，对于基因转录起始是所必需，是基因表达调控的上游顺式作用元件之一。</u></p></li><li><p><abbr title="RNA剪接">RNA splicing</abbr> （<u>RNA剪接</u>）：<u>从mRNA前体分子中切除被称为内含子（intron）的非编码区，并使基因中被称为外显子（exon）的编码区拼接形成成熟mRNA的过程就称为RNA的剪接。</u></p></li><li><p><abbr title="RNA编辑">RNA editing</abbr> （<u>RNA编辑</u>）：<u>是某些RNA，特别是mRNA的一种加工方式，它导致了DNA所编码的遗传信息的改变，因为经过编辑的mRNA序列发生了不同于模板DNA的变化。</u></p></li><li><p><abbr title="长链非编码RNA(P334)">LncRNA</abbr> （<u>长链非编码RNA</u>）：<u>是一类长度大于200bp的非编码RNA，其在转录沉默、转录激活、染色体修饰、核内运输等均具有重要的功能。</u></p></li><li><p><abbr title="反式作用因子">Transacting factor</abbr> (<u>反式作用因子</u>)：<u>是指能够结合在顺式作用元件上调控基因表达的蛋白质或者RNAs。</u></p></li><li><p><abbr title="GT-AG法则">GT-AG law</abbr> ：<u>前体RNA中参与内含子剪接的两个特殊位点，即在内含子和外显子交界处有两个相当短的保守序列:5’端为GT, 3’端为 AG,称为GT-AG规律。GT-AG规则主要适用于(或是全部)真核生物基因的剪接位点。</u></p></li><li><p>Cisacting element （<u>顺式作用元件</u>）：<u>是指启动子和基因的调节序列。主要包括启动子（promoter）增强子（enhancer）沉默子（silencer）等。</u></p></li><li><p><abbr title="增强子(P476、97)">Enhancer</abbr> （<u>增强子</u>）：<u>能强化转录起始的序列，也称为强化子。它们不是启动子的一部分，但能增强或促进转录的起始。</u></p></li><li><p><abbr title="质粒载体">Plasmid Vector</abbr> （<u>质粒载体</u>）：<u>是在天然质粒的基础上为适应实验室操作而进行人工构建的质粒。通常带有一个或一个以上的选择性标记基因（如抗生素抗性基因）和一个人工合成的含有多个限制性内切酶识别位点的多克隆位点序列，并去掉了大部分非必需序列，使分子量尽可能减少，以便于基因工程操作。</u></p></li><li><p><abbr title="引物">Primer</abbr>（<u>引物</u>）：<u>是指一段较短的单链RNA或DNA，它能与DNA的一条链配对提供游离的3-OH末端以作为DNA聚合酶合成脱氧核苷酸链的起始点。</u></p></li><li><p><abbr title="转化">Transformation</abbr> （<u>转化</u>）：<u>是某一基因型的细胞从周围介质中吸收来自另一基因型的细胞的DNA而使它的基因型和表现型发生相应变化的现象。</u></p></li><li><p><abbr title="聚合酶链式反应">PCR</abbr>（<u>聚合酶链式反应</u>）：<u>是指两通过模拟体内DNA复制方式在体外选择性地将DNA某个特定区域扩增出来的技术。</u></p></li><li><p>Tm 值（<u>熔解温度</u>）：<u>见Tm解链温度。</u></p></li><li><p><abbr title="基因克隆">Gene cloning</abbr> （<u>基因克隆</u>）：<u>在分子生物学上，人们把将外源DNA插入具有复制能力的载体DNA中，转入宿主细胞使之得以永久保存和复制这种过程称为基因克隆。</u></p></li><li><p><abbr title="TATA区(P468、94)">TATA box</abbr>：<u>在真核生物基因中位于转录起始点上游-25～-30bp处的富含AT的保守区，是RNA聚合酶与启动子的结合位点，也称为Hogness区（Hogness box），类似于原核基因中的Pribnow区。</u></p></li><li><p><abbr title="Pribnow区(P468、85)">Pribnow box</abbr>：<u>在启动子区有一个由5个核苷酸组成的共同序列，是RNA聚合酶的紧密结合点，称为Pribnow区，这个区的中央大约位于起始点上游10bp处，所以又称为-10区。</u></p></li><li><p><abbr title="RNA干扰">RNAi</abbr> （<u>RNA干扰</u>）：<u>是利用双链小RNA高效、特异性降解细胞内同源mRNA，从而阻断体内靶基因表达，使细胞出现靶基因缺失的表型。</u></p></li><li><p><abbr title="C值">C value</abbr>（<u>C值</u>）：<u>一种生物的单倍体基因组的DNA总量称为C值。</u></p></li><li><p><abbr title="CpG岛（P467）">CpG岛</abbr>：<u>真核生物中，成串出现在DNA上的CpG二核苷酸。5-甲基胞嘧啶主要出现在CpG序列、CpXpG、CCA/TGG和GATC中，在高等生物CpG二核苷酸序列中的C通常是甲基化的，极易自发脱氨，生成胸腺嘧啶，所以CpG二核苷酸序列出现的频率远远低于按核苷酸组成计算出的频率。</u></p></li></ol><h2 id="问答题自测"><a class="header-anchor" href="#问答题自测"></a>问答题自测</h2><h3 id="1、简述真核与原核细胞中翻译起始的主要区别"><a class="header-anchor" href="#1、简述真核与原核细胞中翻译起始的主要区别"></a>1、简述真核与原核细胞中翻译起始的主要区别.</h3><ol><li><u>翻译起始复合物形成的过程不同</u><br><u>真核生物：核蛋白体大小亚基分离；起始氨基酰-tRNA的结合； mRNA在小亚基定位结合；核蛋白体大亚基结合。</u><br><u>原核生物：核蛋白体大小亚基分离； mRNA在小亚基定位结合；起始氨基酰-tRNA的结合；核蛋白体大亚基结合。</u></li><li><u>参与物质不同</u><br><u>真核生物，核蛋白体是80S （40S＋60S）;起始因子种类多；起始tRNA的Met不需甲酰化；</u><br><u>mRNA无SD序列，5’帽子和3’poly A尾结构与mRNA在核蛋白体就位有关；需要帽子结合蛋白复合物(eIF-4F)参与;</u></li></ol><h3 id="2、简述遗传密码的特点。"><a class="header-anchor" href="#2、简述遗传密码的特点。"></a>2、简述遗传密码的特点。</h3><ol><li><u>密码子的连续性</u></li><li><u>密码子的简并性</u></li><li><u>密码子的变偶（摆动）性</u></li><li><u>密码子的通用性和变异性</u></li><li><u>方向性</u></li></ol><h3 id="3、简述蛋白质合成后修饰方式。"><a class="header-anchor" href="#3、简述蛋白质合成后修饰方式。"></a>3、简述蛋白质合成后修饰方式。</h3><ol><li><u>多肽链折叠为天然三级结构</u><br><u>在分子伴侣的作用下形成正确的折叠；在二硫键异构酶的作用下形成正确二硫键；在肽酰脯氨酸顺反异构酶的作用下形成正确肽键异构。</u></li><li><u>一级结构修饰</u><br><u>去除N端蛋氨酸残基；个别氨基酸的共价修饰，如糖基化，甲基化，磷酸化，羟基化，二硫键形成，亲脂性修饰等。</u></li><li><u>高级结构修饰</u><br><u>通过非共价键亚基聚合形成四级结构；与辅基结合形成完整的结合蛋白。</u></li></ol><h3 id="4、PCR-扩增的原理、PCR-扩增常用体系和程序。"><a class="header-anchor" href="#4、PCR-扩增的原理、PCR-扩增常用体系和程序。"></a>4、<abbr title="聚合酶链式反应">PCR</abbr> 扩增的原理、<abbr title="聚合酶链式反应">PCR</abbr> 扩增常用体系和程序。</h3><h3 id="5、简述乳糖操纵子调节机制-v2"><a class="header-anchor" href="#5、简述乳糖操纵子调节机制-v2"></a>5、简述乳糖操纵子调节机制</h3><ol><li><u>乳糖操纵子是由调节基因，启动子，操纵基因及Z/Y/A三个结构基因组成。</u></li><li><u>阻遏蛋白的负调控：无乳糖时，阻遏蛋白结合操纵基因，妨碍RNA聚合酶结合启动子，抑制结构基因转录。有乳糖时，乳糖（诱导剂）结合阻遏蛋白， 导致其不能封闭操纵基因，结构基因可以转录。</u></li><li><u>cAMP-CAP复合物的正调控：无葡萄糖时，cAMP浓度高，形成的cAMP-CAP复合物结合于CAP结合位点，增强启动子转录活性。有葡萄糖时，cAMP浓度低，cAMP-CAP复合物形成受阻，影响转录活性。</u></li><li><u>正、负调控机制相辅相成。cAMP-CAP复合物是转录必需的，同时阻遏蛋白进一步控制转录启动。综上，乳糖操纵子最强的表达条件是有乳糖无葡萄糖。</u></li></ol><h3 id="6、真核生物转录因子中DNA结合结构域类型有哪些？-v2"><a class="header-anchor" href="#6、真核生物转录因子中DNA结合结构域类型有哪些？-v2"></a>6、真核生物转录因子中DNA结合结构域类型有哪些？</h3><ol><li><u>螺旋转角螺旋</u></li><li><u>螺旋环螺旋</u></li><li><u>亮氨酸拉链</u></li><li><u>锌指结构</u></li></ol><h3 id="7、真核生物转录因子中激活结构域的特征有哪些？-v2"><a class="header-anchor" href="#7、真核生物转录因子中激活结构域的特征有哪些？-v2"></a>7、真核生物转录因子中激活结构域的特征有哪些？</h3><ol><li><u>富含酸性氨基酸</u></li><li><u>富含谷氨酰胺</u></li><li><u>富含脯氨酸</u></li></ol><h3 id="8、真核生物的基因表达调控水平主要包括哪些？-v2"><a class="header-anchor" href="#8、真核生物的基因表达调控水平主要包括哪些？-v2"></a>8、真核生物的基因表达调控水平主要包括哪些？</h3><ol><li><u>染色体、染色质水平上的调控</u></li><li><u>转录调控</u></li><li><u>转录后加工调控</u></li><li><u>翻译调控</u></li><li><u>翻译后加工的调控</u></li></ol><h3 id="9、一代测序技术和二代测序技术原理和特点。"><a class="header-anchor" href="#9、一代测序技术和二代测序技术原理和特点。"></a>9、一代测序技术和二代测序技术原理和特点。</h3><ol><li><u>一代测序即Sanger测序是基于DNA合成的双脱氧终止技术。</u><br><u>其原理是在测序反应中加入待测样本作为模板，加入特异性引物，DNA聚合酶，dNTP及ddNTP，当双脱氧ddNTP取代常规脱氧核苷酸参入到合成后，就阻断了DNA的合成反应，因此将会产生不同长度的DNA片段混合物，通过电泳及自显影技术可直接读出DNA的顺序。</u><br><u>特点是测序反应的长度较短，一般不超过1000bp。</u></li><li><u>第二代测序技术是指对第一代测序技术的改进技术。</u><br><u>主要对测序流程中的样品准备，分子标记，化学反应试剂，及测序的平行化等方面进行了大量改进，包括Roche454焦磷酸测序，基于合成的循环阵列测序及ABI SOLiD基于连接的的测序等。</u><br><u>二代测序技术的特点是，大大提高了测序的自动化和平行化，大大降低了测序成本。</u></li></ol><h3 id="10、试分析分子生物学的发展趋势。"><a class="header-anchor" href="#10、试分析分子生物学的发展趋势。"></a>10、试分析分子生物学的发展趋势。</h3><p><u>分子生物学是现代生物学的发展方向，分子生物学重点研究的领域包括</u></p><ol><li><u>生物大分子的结构和功能的研究；</u></li><li><u>真核生物基因及基因表达调控的研究；</u></li><li><u>分子神经生物学的研究；</u></li><li><u>医学分子生物学的研究；</u></li><li><u>植物分子生物学的研究；</u></li><li><u>分子进化的研究等。</u></li></ol><p><u>分子生物学带动了整个生物科学的全面发展。</u></p><h3 id="11、简述原核生物DNA复制过程中需要哪些酶和蛋白的参与，各具有何作用。"><a class="header-anchor" href="#11、简述原核生物DNA复制过程中需要哪些酶和蛋白的参与，各具有何作用。"></a>11、简述原核生物DNA复制过程中需要哪些酶和蛋白的参与，各具有何作用。</h3><p><u>以大肠杆菌为例，原核生物DNA复制主要有一下酶和蛋白质参与。</u></p><ol><li><u>DNA拓扑异构酶：DNA拓扑异构酶的作用是，将解链过程中产生的正超螺旋消除，有利于解链进行；</u></li><li><u>DNA解链酶：DNA解链酶的作用是，断开DNA双螺旋中碱基之间的氢键；</u></li><li><u>单链DNA结合蛋白：单链DNA结合蛋白，与单链DNA结合，防止重新形成双链；</u></li><li><u>引发酶：引发酶的作用是合成一小段RNA引物，引导DNA聚合；</u></li><li><u>DNA聚合酶I/II/III：DNA聚合酶I的作用是既可以合成DNA，又可以水解DNA，确保DNA合成的准确性；DNA聚合酶II的作用是用来修复受损的DNA；DNA聚合酶III是原核生物合成DNA的主要酶；</u></li><li><u>DNA连接酶：DNA连接酶的作用是形成3’,5’磷酸二酯键将冈崎片段连接起来。</u></li></ol><h3 id="12、请写出6种以上RNA及其功能-v2"><a class="header-anchor" href="#12、请写出6种以上RNA及其功能-v2"></a>12、请写出6种以上RNA及其功能</h3><ol><li><u>rRNA  即核糖体RNA，是蛋白质合成的场所。</u></li><li><u>mRNA 即 信使RNA，是蛋白质合成的模板。</u></li><li><u>tRNA 即转运RNA,是蛋白质合成过程中运载氨基酸的工具</u></li><li><u>hnRNA 即核内不均一RNA，是m RNA的前体。</u></li><li><u>microRNA，即微小RNA，是参与转录后基因表达调控的小分子RNA</u></li><li><u>lncRNA, 即长链非编码RNA ,可与DNA、蛋白质相互作用，可能具有多种生物学功能。</u></li></ol><h3 id="13、5‘端帽子和polyA尾巴各有什么功能。"><a class="header-anchor" href="#13、5‘端帽子和polyA尾巴各有什么功能。"></a>13、5‘端帽子和polyA尾巴各有什么功能。</h3><ol><li><u>帽子结构使mRNA免遭核酸酶的破坏，可能是蛋白质合成起始信号的一部分。</u></li><li><u>多聚A提高mRNA在细胞基质中的稳定性，也参与蛋白质合成的起始。</u></li></ol><h3 id="14、简述原核生物两种转录终止的机制。"><a class="header-anchor" href="#14、简述原核生物两种转录终止的机制。"></a>14、简述原核生物两种转录终止的机制。</h3><ol><li><u>RNA聚合酶在DNA模板上停顿下来不再前进，转录产物RNA链从转录复合物上脱落下来即转录终止。</u></li><li><u>依据是否需要蛋白质因子的参与，原核生物转录终止分为：依赖ρ 因子的转录终止和不依赖ρ因子的转录终止。当新生成的RNA链因含有富含GC的反向重复序列而形成茎环结构时，RNA聚合酶移动减慢，造成高度延宕，茎环结构末端的一串U序列与DNA稳定性较差，从而使新生成的链释放出来。</u></li><li><u>当新生成的RNA链反向重复序列GC含量较少时，且茎环结构末端不含有一串U序列，此时转录的终止需要ρ因子的帮助，ρ因子由6个亚基组成的蛋白质，具有ATP酶和解旋酶的活性，能将RNA-DNA杂交双链解开，使RNA脱离模板，从而终止RNA转录。</u></li></ol><h3 id="15、简述原核生物与真核生物启动子的主要差别。"><a class="header-anchor" href="#15、简述原核生物与真核生物启动子的主要差别。"></a>15、简述原核生物与真核生物启动子的主要差别。</h3><ol><li><u>原核生物：启动子拥有-10区和-35区，是RNA聚合酶的识别和结合位点；</u></li><li><u>真核生物：启动子在-25~-35区含有TATA box即核心启动子区，在-70~-80区含有CAAT box，另外还常含有GC区及增强区，需要多种转录调控因子。</u></li></ol><h2 id="宁波大学2020年941分子生物学考研真题"><a class="header-anchor" href="#宁波大学2020年941分子生物学考研真题"></a>宁波大学2020年941分子生物学考研真题</h2><h3 id="名词解释（50分，每个5分）"><a class="header-anchor" href="#名词解释（50分，每个5分）"></a>名词解释（50分，每个5分）</h3><ol><li>degenerate primer 简并引物</li><li>chromosome walking 染色体步移</li><li>overlapping gene 重叠基因</li><li><abbr title="绿色荧光蛋白">GFP</abbr></li><li>proteomics 蛋白质组学</li><li>gene chip 基因芯片</li><li>lncRNA 长链非编码RNA</li><li><abbr title="操纵子(P469)">Operon</abbr> 操纵子</li><li>sequence alignment 序列对比</li><li><abbr title="DNA的半保留复制(P467、42)">Semi-conservative replication</abbr></li></ol><h3 id="问答题-v2"><a class="header-anchor" href="#问答题-v2"></a>问答题</h3><ol><li>简述原核生物DNA复制过程中需要哪些酶和蛋白的参与，各具有何作用？（10分）</li><li>简述基因工程的基本操作步骤及其应用意义。（10分）</li><li>一代测序技术和二代测序技术原理和特点。（10分）</li><li>如何确定提取RNA的质量好坏？（10分）</li><li>引物设计的要求有哪些？（15分）</li><li>目前知名的序列数据库有哪些？如何从数据库中获取一个已知基因的序列？（10分）</li></ol><h3 id="综合题"><a class="header-anchor" href="#综合题"></a>综合题</h3><ol><li>什么是基因克隆？基因克隆步骤包括哪些？其中一般PCR的体系和程序如何设置？（20分）</li><li>简述TA克隆的原理？怎样挑选阳性重组DNA？（15分）</li></ol><h2 id="宁波大学2019年941分子生物学考研真题"><a class="header-anchor" href="#宁波大学2019年941分子生物学考研真题"></a>宁波大学2019年941分子生物学考研真题</h2><h3 id="名词解释（40分，每个4分）"><a class="header-anchor" href="#名词解释（40分，每个4分）"></a>名词解释（40分，每个4分）</h3><ol><li><abbr title="基因表达">Gene expression</abbr></li><li><abbr title="RNA剪接">RNA splicing</abbr></li><li>probe 探针</li><li>Genetic engineering 基因工程</li><li>Repressor protein 阻遏蛋白</li><li><abbr title="微卫星DNA">Microsatellite DNA</abbr></li><li><abbr title="绿色荧光蛋白">GFP</abbr></li><li><abbr title="cDNA末端的快速扩增(P468)">RACE</abbr></li><li>nested <abbr title="聚合酶链式反应">PCR</abbr> 巢式PCR</li><li>multi <abbr title="基因家族">Gene family</abbr></li></ol><h3 id="问答题（60分，每个10分）"><a class="header-anchor" href="#问答题（60分，每个10分）"></a>问答题（60分，每个10分）</h3><ol><li>请写出6种以上RNA及其功能。</li><li>5’端帽子和polyA尾巴各有什么功能。</li><li>简述原核生物转录终止的两种主要机制。</li><li>简述原核生物与真核生物启动子的主要差别。</li><li>简述一代测序技术和二代测序技术原理和特点。</li><li>比较基因组、转录组、蛋白质组和代谢组的异同。</li></ol><h3 id="分析题（50分）"><a class="header-anchor" href="#分析题（50分）"></a>分析题（50分）</h3><p>略</p><h2 id="宁波大学2018年941分子生物学考研真题"><a class="header-anchor" href="#宁波大学2018年941分子生物学考研真题"></a>宁波大学2018年941分子生物学考研真题</h2><h3 id="名词解释（40分，每个4分）-v2"><a class="header-anchor" href="#名词解释（40分，每个4分）-v2"></a>名词解释（40分，每个4分）</h3><ol><li><abbr title="RNA剪接">RNA splicing</abbr></li><li>RNA interference (<abbr title="RNA干扰">RNAi</abbr>)</li><li>two-dimensional electrophoresis 双向电泳</li><li><abbr title="美国国家生物技术信息中心">NCBI</abbr></li><li><abbr title="cDNA末端的快速扩增(P468)">RACE</abbr></li><li>transcription factors 转录因子</li><li>satellite DNA 卫星DNA</li><li>polysome 卫星</li><li><abbr title="C值矛盾">C-value paradox</abbr></li><li><abbr title="启动子">Promoter</abbr></li></ol><h3 id="问答题（70分）"><a class="header-anchor" href="#问答题（70分）"></a>问答题（70分）</h3><ol><li>什么是蓝白斑筛选法？长出的白斑一定是转基因的吗？为什么？（10分）</li><li>什么是基因表达？可用哪些技术来检测一个基因是否表达？（10分）</li><li>简述DNA复制的回环模型。（10分）</li><li>试比较真核生物RNA聚合酶II识别的启动子与原核生物RNA聚合酶所识别的启动子的结构特点，各结构单元的功能是什么？（10分）</li><li>简述真核与原核细胞中翻译起始的主要区别。（10分）</li><li>简述原核生物转录终止的两种主要机制。（10分）</li><li>简述如何用Mega软件制作蛋白质进化树？（10分）</li></ol><h3 id="分析题（40分）"><a class="header-anchor" href="#分析题（40分）"></a>分析题（40分）</h3><p>略</p><h2 id="宁波大学2017年941分子生物学考研真题"><a class="header-anchor" href="#宁波大学2017年941分子生物学考研真题"></a>宁波大学2017年941分子生物学考研真题</h2><h3 id="名词解释（40分，每个4分）-v3"><a class="header-anchor" href="#名词解释（40分，每个4分）-v3"></a>名词解释（40分，每个4分）</h3><ol><li><abbr title="C值矛盾">C-value paradox</abbr></li><li>restriction enzyme 限制性内切酶</li><li><abbr title="遗传中心法则">Genetic central dogma</abbr></li><li><abbr title="基因组DNA文库">Genomic DNA library</abbr></li><li>transgene 转基因</li><li><abbr title="蛋白质组学">Proteomics</abbr></li><li>multiple <abbr title="聚合酶链式反应">PCR</abbr> 多重PCR</li><li><abbr title="基因芯片">Gene chip</abbr></li><li><abbr title="长链非编码RNA(P334)">LncRNA</abbr></li><li><abbr title="Klenow片段">Klenow fragment</abbr></li></ol><h3 id="问答题（70分）-v2"><a class="header-anchor" href="#问答题（70分）-v2"></a>问答题（70分）</h3><ol><li>什么是基因家族？基因家族有哪些类型？并各举一个例子。（10 分）</li><li>真核生物中 RNA 的 5’端帽子和 polyA 尾巴各有什么功能。（10 分）</li><li>简述色氨酸操纵子调节机制。（10 分）</li><li>试述β-半乳糖苷酶筛选（或蓝白斑筛选）的原理。（10 分）</li><li>简述 AMV 逆转录酶功能及应用。（10 分）</li><li>什么是基因表达？可用哪些技术来检测一个基因是否表达？（10 分）</li><li>简述核酸分子杂交基本原理。（10 分）</li></ol><h3 id="分析题（40分）-v2"><a class="header-anchor" href="#分析题（40分）-v2"></a>分析题（40分）</h3><p>略</p><blockquote><p>宁波大学2017-2020年海洋学院考研真题<a href="http://img.whl123456.top/%E5%AE%81%E6%B3%A2%E5%A4%A7%E5%AD%A6%E6%B5%B7%E6%B4%8B%E5%AD%A6%E9%99%A2%E8%80%83%E7%A0%94%E7%9C%9F%E9%A2%98.zip">链接</a><br>来源宁波大学<a href="http://graduate.nbu.edu.cn/2019/zs-list.jsp?urltype=tree.TreeTempUrl&amp;wbtreeid=1073">官网</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 生物学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分子生物学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC入门</title>
      <link href="2020/11/03/SpringMVC%E5%85%A5%E9%97%A8/"/>
      <url>2020/11/03/SpringMVC%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="快速入门"><a class="header-anchor" href="#快速入门"></a>快速入门</h2><p>本小节，我们会使用 <a href="https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web"><code>spring-boot-starter-web</code></a> 实现 SpringMVC 的自动化配置。然后实现用户的增删改查接口。接口列表如下：</p><table><thead><tr><th style="text-align:left">请求方法</th><th style="text-align:left">URL</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:left"><code>GET</code></td><td style="text-align:left"><code>/users</code></td><td style="text-align:left">查询用户列表</td></tr><tr><td style="text-align:left"><code>GET</code></td><td style="text-align:left"><code>/users/&#123;id&#125;</code></td><td style="text-align:left">获得指定用户编号的用户</td></tr><tr><td style="text-align:left"><code>POST</code></td><td style="text-align:left"><code>/users</code></td><td style="text-align:left">添加用户</td></tr><tr><td style="text-align:left"><code>PUT</code></td><td style="text-align:left"><code>/users/&#123;id&#125;</code></td><td style="text-align:left">更新指定用户编号的用户</td></tr><tr><td style="text-align:left"><code>DELETE</code></td><td style="text-align:left"><code>/users/&#123;id&#125;</code></td><td style="text-align:left">删除指定用户编号的用户</td></tr></tbody></table><h2 id="有关注解"><a class="header-anchor" href="#有关注解"></a>有关注解</h2><h3 id="Controller"><a class="header-anchor" href="#Controller"></a>@Controller</h3><p><a href="https://github.com/spring-projects/spring-framework/blob/master/spring-context/src/main/java/org/springframework/stereotype/Controller.java"><code>@Controller</code></a> 注解，添加在类上，表示这是控制器 Controller 对象。属性如下：</p><ul><li><code>name</code> 属性：该 Controller 对象的 Bean 名字。允许空。</li></ul><p><a href="https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/web/bind/annotation/RestController.java"><code>@RestController</code></a> 注解，添加在类上，是 <code>@Controller</code> 和 <a href="https://github.com/ndimiduk/spring-framework/blob/master/org.springframework.web/src/main/java/org/springframework/web/bind/annotation/ResponseBody.java"><code>@ResponseBody</code></a> 的组合注解，直接使用接口方法的返回结果，经过 JSON/XML 等序列化方式，最终返回。也就是说，无需使用 InternalResourceViewResolver 解析视图，返回 HTML 结果。</p><p>目前主流的架构，都是 <a href="https://blog.csdn.net/fuzhongmin05/article/details/81591072">前后端分离</a> 的架构，后端只需要提供 API 接口，仅仅返回数据。而视图部分的工作，全部交给前端来做。也因此，我们项目中 99.99% 使用 <code>@RestController</code> 注解。</p><h3 id="RequestMapping"><a class="header-anchor" href="#RequestMapping"></a>@RequestMapping</h3><p><a href="https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/web/bind/annotation/RequestMapping.java"><code>@RequestMapping</code></a> 注解，添加在类或方法上，标记该类/方法对应接口的配置信息。</p><p><code>@RequestMapping</code> 注解的<strong>常用属性</strong>，如下：</p><ul><li><code>path</code> 属性：接口路径。<code>[]</code> 数组，可以填写多个接口路径。</li><li><code>values</code> 属性：和 <code>path</code> 属性相同，是它的别名。</li><li><code>method</code> 属性：请求方法 <a href="https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/web/bind/annotation/RequestMethod.java">RequestMethod</a> ，可以填写 <code>GET</code>、<code>POST</code>、<code>POST</code>、<code>DELETE</code> 等等。<code>[]</code> 数组，可以填写多个请求方法。如果为空，表示匹配所有请求方法。</li></ul><p><code>@RequestMapping</code> 注解的<strong>不常用属性</strong>，如下：</p><ul><li><code>name</code> 属性：接口名。一般情况下，我们不填写。</li><li><code>params</code> 属性：请求参数需要包含值的<strong>参数名</strong>。可以填写多个参数名。如果为空，表示匹配所有请你求方法。</li><li><code>headers</code> 属性：和 <code>params</code> 类似，只是从参数名变成<strong>请求头</strong>。</li><li><code>consumes</code> 属性：和 <code>params</code> 类似，只是从参数名变成请求头的<strong>提交内容类型</strong>( <a href="https://juejin.im/post/5cb34fc06fb9a068a75d3555">Content-Type</a> )</li><li><code>produces</code> 属性：和 <code>params</code> 类似，只是从参数名变成请求头的( <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept">Accept</a> )<strong>可接受类型</strong>。</li></ul><p>考虑到让开发更加方便，Spring 给每种请求方法提供了对应的注解：</p><ul><li><a href="https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/web/bind/annotation/GetMapping.java"><code>@GetMapping</code></a> 注解：对应 <code>@GET</code> 请求方法的 <code>@RequestMapping</code> 注解。</li><li><a href="https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/web/bind/annotation/PostMapping.java"><code>@PostMapping</code></a> 注解：对应 <code>@POST</code> 请求方法的 <code>@RequestMapping</code> 注解。</li><li><a href="https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/web/bind/annotation/PutMapping.java"><code>@PutMapping</code></a> 注解：对应 <code>@PUT</code> 请求方法的 <code>@RequestMapping</code> 注解。</li><li><a href="https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/web/bind/annotation/DeleteMapping.java"><code>@DeleteMapping</code></a> 注解：对应 <code>@DELETE</code> 请求方法的 <code>@RequestMapping</code> 注解。</li><li>…</li></ul><h3 id="RequestParam"><a class="header-anchor" href="#RequestParam"></a>@RequestParam</h3><p><a href="https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/web/bind/annotation/RequestParam.java"><code>@RequestParam</code></a> 注解，添加在方法参数上，标记该方法参数对应的请求参数的信息。属性如下：</p><ul><li><code>name</code> 属性：对应的请求参数名。如果为空，则直接使用方法上的参数变量名。</li><li><code>value</code> 属性：和 <code>name</code> 属性相同，是它的别名。</li><li><code>required</code> 属性：参数是否必须传。默认为 <code>true</code> ，表示必传。</li><li><code>defaultValue</code> 属性：参数默认值。</li></ul><p><a href="https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/web/bind/annotation/PathVariable.java"><code>@PathVariable</code></a> 注解，添加在方法参数上，标记接口路径和方法参数的映射关系。具体的，我们在示例中来看。相比 <code>@RequestParam</code> 注解，少一个 <code>defaultValue</code> 属性。</p><h2 id="引入依赖"><a class="header-anchor" href="#引入依赖"></a>引入依赖</h2><p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-23/lab-springmvc-23-01/pom.xml"><code>pom.xml</code></a> 文件中，引入相关依赖。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="line">         xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1.3.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;lab-springmvc-23-01&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!-- 实现对 Spring MVC 的自动化配置 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 方便等会写单元测试 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><h2 id="创建Application"><a class="header-anchor" href="#创建Application"></a>创建Application</h2><p>创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-23/lab-springmvc-23-01/src/main/java/cn/iocoder/springboot/lab23/springmvc/Application.java"><code>Application.java</code></a> 类，配置 <code>@SpringBootApplication</code> 注解即可。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(HelloApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建UserController"><a class="header-anchor" href="#创建UserController"></a>创建UserController</h2><p>在controller包路径下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-23/lab-springmvc-23-01/src/main/java/cn/iocoder/springboot/lab23/springmvc/controller/UserController.java">UserController</a> 类。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询用户列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 用户列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;UserVO&gt; <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 查询列表</span></span><br><span class="line">        List&lt;UserVO&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        result.add(<span class="keyword">new</span> UserVO().setId(<span class="number">1</span>).setUsername(<span class="string">&quot;yudaoyuanma&quot;</span>));</span><br><span class="line">        result.add(<span class="keyword">new</span> UserVO().setId(<span class="number">2</span>).setUsername(<span class="string">&quot;woshiyutou&quot;</span>));</span><br><span class="line">        result.add(<span class="keyword">new</span> UserVO().setId(<span class="number">3</span>).setUsername(<span class="string">&quot;chifanshuijiao&quot;</span>));</span><br><span class="line">        <span class="comment">// 返回列表</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得指定用户编号的用户</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 用户编号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserVO <span class="title">get</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 查询并返回用户</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserVO().setId(id).setUsername(<span class="string">&quot;username:&quot;</span> + id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得指定用户编号的用户</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 用户编号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/v2/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserVO <span class="title">get2</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.get(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加用户</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> addDTO 添加用户信息 DTO</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 添加成功的用户编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">add</span><span class="params">(UserAddDTO addDTO)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 插入用户记录，返回编号</span></span><br><span class="line">        Integer returnId = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 返回用户编号</span></span><br><span class="line">        <span class="keyword">return</span> returnId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新指定用户编号的用户</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id        用户编号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> updateDTO 更新用户信息 DTO</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否修改成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">update</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id, UserUpdateDTO updateDTO)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将 id 设置到 updateDTO 中</span></span><br><span class="line">        updateDTO.setId(id);</span><br><span class="line">        <span class="comment">// 更新用户记录</span></span><br><span class="line">        Boolean success = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 返回更新是否成功</span></span><br><span class="line">        <span class="keyword">return</span> success;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除指定用户编号的用户</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 用户编号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否删除成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">delete</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 删除用户记录</span></span><br><span class="line">        Boolean success = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 返回是否更新成功</span></span><br><span class="line">        <span class="keyword">return</span> success;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat</title>
      <link href="2020/11/03/JavaEE-01-Tomcat/"/>
      <url>2020/11/03/JavaEE-01-Tomcat/</url>
      
        <content type="html"><![CDATA[<h2 id="Tomcat简介"><a class="header-anchor" href="#Tomcat简介"></a>Tomcat简介</h2><p>如果你学过html，css，你会知道你写的页面只能自己访问，别人不能远程访问你写的页面，Tomcat就是提供能够让别人访问自己写的页面的一个程序。</p><h2 id="安装Tomcat"><a class="header-anchor" href="#安装Tomcat"></a>安装Tomcat</h2><p>Tomcat<a href="http://tomcat.apache.org/">官网</a>下载</p><p>选择下载的版本、合适的镜像以及对于系统的压缩包</p><p><img src="http://img.whl123456.top/image/image-20201105115616266.png" alt="image-20201105115616266"></p><p>解压压缩包，得到以下目录</p><p><img src="http://img.whl123456.top/image/image-20201105115908271.png" alt="image-20201105115908271"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Tomcat-9.0</span><br><span class="line"> ├── bin               启动关闭的脚本文件</span><br><span class="line"> ├── conf              配置文件</span><br><span class="line"> ├── lib               依赖的Jar包</span><br><span class="line"> ├── logs              日志</span><br><span class="line"> ├── temp              临时文件</span><br><span class="line"> ├── webapps           网站资源   </span><br><span class="line"> ├── work              工作目录</span><br><span class="line"> ├── BUILDING.txt</span><br><span class="line"> ├── CONTRIBUTING.md</span><br><span class="line"> ├── LICENSE</span><br><span class="line"> ├── NOTICE</span><br><span class="line"> ├── README.md</span><br><span class="line"> ├── RELEASE-NOTES</span><br><span class="line"> └── RUNNING.txt</span><br></pre></td></tr></table></figure><h2 id="启动和关闭Tomcat"><a class="header-anchor" href="#启动和关闭Tomcat"></a>启动和关闭Tomcat</h2><p>打开bin文件夹的startup.bat文件，这时弹出黑窗口且不报错，表示启动成功，访问http://localhost:8080/可以看到Tomcat的欢迎页面。</p><p>关闭黑窗口或者点击bin文件夹下的shutdown.bat文件，</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot2</title>
      <link href="2020/10/29/Java-01-SpringBoot/"/>
      <url>2020/10/29/Java-01-SpringBoot/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringBoot实现RESTful风格Web应用"><a class="header-anchor" href="#SpringBoot实现RESTful风格Web应用"></a>SpringBoot实现RESTful风格Web应用</h2><p>REST（REpresentational State Transfer）全称是 Resource Representational State Transfer：通俗来讲就是：资源在网络中以某种表现形式进行状态转移。分解开来：</p><ul><li>Resource：资源，即数据（前面说过网络的核心）。比如 newsfeed，friends等；</li><li>Representational：某种表现形式，比如用JSON，XML，JPEG等；</li><li>State Transfer：状态变化。通过HTTP动词实现。</li></ul><p>URL定位资源，用HTTP动词（GET,POST,DELETE,DETC）描述操作。</p><h3 id="创建类BolgController"><a class="header-anchor" href="#创建类BolgController"></a>创建类BolgController</h3><p>在包controller中创建类BolgController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.restful.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/blog&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BolgController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">show</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> </span>&#123;</span><br><span class="line">        ModelAndView mav = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        mav.addObject(<span class="string">&quot;id&quot;</span>, id);</span><br><span class="line">        mav.setViewName(<span class="string">&quot;bolg&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/query&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">query</span><span class="params">(<span class="meta">@RequestParam(value = &quot;q&quot;, required = false)</span> String q)</span> </span>&#123;</span><br><span class="line">        ModelAndView mav = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        mav.addObject(<span class="string">&quot;q&quot;</span>, q);</span><br><span class="line">        mav.setViewName(<span class="string">&quot;query&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建文件-index-html"><a class="header-anchor" href="#创建文件-index-html"></a>创建文件 index.html</h3><p>在 resource/static 目录下创建文件 index.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/blog/21&quot;</span>&gt;</span>博客<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/blog/query?q=123456&gt;&quot;</span>&gt;</span>搜索<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="创建文件-bolg-html"><a class="header-anchor" href="#创建文件-bolg-html"></a>创建文件 bolg.html</h3><p>在 resource/templates 目录下创建文件 blog.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Getting Started: Serving Web Content<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=UTF-8&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;&#x27;博客编号:&#x27; + $&#123;id&#125; + &#x27;!&#x27;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="创建文件-query-html"><a class="header-anchor" href="#创建文件-query-html"></a>创建文件 query.html</h3><p>在 resource/templates 目录下创建文件 query.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Getting Started: Serving Web Content<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=UTF-8&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;&#x27;查询,&#x27; + $&#123;q&#125; + &#x27;!&#x27;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="运行程序"><a class="header-anchor" href="#运行程序"></a>运行程序</h3><p>运行程序后，在浏览器中输入 localhost:8080</p><p>![image-20201029185618289](E:\OneDrive - lanqilu\我的图片库\blogimg\Java-01-SpringBoot\image-20201029185618289.png)</p><p>点击博客或搜索显示如下页面</p><p>![image-20201029191916914](E:\OneDrive - lanqilu\我的图片库\blogimg\Java-01-SpringBoot\image-20201029191916914.png)</p><p>![image-20201029191930191](E:\OneDrive - lanqilu\我的图片库\blogimg\Java-01-SpringBoot\image-20201029191930191.png)</p><h2 id="带-Bootstrap-和-JQuery-的-Web-应用"><a class="header-anchor" href="#带-Bootstrap-和-JQuery-的-Web-应用"></a>带 Bootstrap 和 JQuery  的 Web 应用</h2><h3 id="添加依赖"><a class="header-anchor" href="#添加依赖"></a>添加依赖</h3><h2 id="接口文档-Swagger-入门"><a class="header-anchor" href="#接口文档-Swagger-入门"></a>接口文档 Swagger <a href="http://www.iocoder.cn/Spring-Boot/Swagger/">入门</a></h2><p>目前，大多数系统都采用前后端分离。在享受前后端分离的<a href="https://www.zhihu.com/question/28207685">好处</a>的同时，接口联调往往成为团队效率的瓶颈，甚至产生前后端的矛盾。简单归结来说，有几方面的原因：</p><ul><li>问题一，<strong>接口设计滞后。</strong> 后端团队往往不喜欢 API 接口设计先行，提前和前端沟通好接口。而在开发阶段的中后期，在后端提供 API 接口后，而这些接口和前端的预期有一些偏差，很容易就产生抱怨，特别是项目周期比较紧张的情况下。</li><li>问题二，<strong>接口不规范。</strong> 当团队里没有同意明确的接口规范时，又或者代码 Review 做的不是很好的情况下，千奇百怪、各式各样的 API 接口可能就产生了。前端在对接这样的 API 接口，苦不堪言，在一口 mmp 一嘴 fuck xxx 之中，调完接口。</li><li>问题三，<strong>接口文档更新不及时，或者遗忘更新。</strong> 因为后端 API 代码和 API 接口在两个地方，我们无法保证提交 API 代码的同时，及时更新文档。有的时候，我们甚至会遗忘更新 API 接口。随着时间的流逝，API 文档和 API 接口不一致的地方越来越多，前端会对 API 接口的信任度越来越低，然后不知道不觉之中，回到原始时代，直接问后端开发 API 是什么样的。</li></ul><p>对于<strong>问题一</strong>和<strong>问题二</strong>，更多是开发流程上的问题，所以不在本文的范围内。当然话痨的艿艿，还是要给点粗浅的建议，完全拦不住我啊。</p><ul><li><strong>接口设计先行</strong>。设计完成后，后端和前端进行简单沟通，看看是否能够满足诉求。</li><li><strong>统一的接口规范</strong>。一定要制定统一的接口规范文档，即使比较简陋，也能保证团队的 API 接口相对统一一致。😈 即使错，咱也错的一模一样，而不是千奇百怪。当然，接口规范是无法覆盖到所有的场景的，借助于“接口设计先行”，我们可以提前去 Review 每个接口的设计。</li></ul><p>对于<strong>问题三</strong>，就进入了本文的<strong>主角 Swagger</strong> 。通过在 API 接口上，添加相应的 Swagger 提供的注解，自动生成 API 文档。酱紫，API 接口和文档就在一起了，从此过上了幸福快乐的生活。</p><p>Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。</p><p>总体目标是使客户端和文件系统作为服务器以同样的速度来更新。文件的方法、参数和模型紧密集成到服务器端的代码，允许 API 来始终保持同步。Swagger 让部署管理和使用功能强大的 API 从未如此简单。</p><h3 id="引入依赖"><a class="header-anchor" href="#引入依赖"></a>引入依赖</h3><p>在 <code>pom.xml</code>文件中，引入相关依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 实现对 Spring MVC 的自动化配置 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">&lt;!-- 引入 Swagger 依赖 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">&lt;!-- 引入 Swagger UI 依赖，以实现 API 接口的 UI 界面 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="SwaggerConfiguration"><a class="header-anchor" href="#SwaggerConfiguration"></a>SwaggerConfiguration</h3><p>因为 Spring Boot 暂未提供 Swagger 内置的支持，所以我们需要自己定义配置类。</p><p>在 <code>*.apidoc.config</code> 包路径下，创建 SwaggerConfiguration 配置类，用于配置 Swagger 。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">createRestApi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 Docket 对象</span></span><br><span class="line">        <span class="comment">// 文档类型，使用 Swagger2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                <span class="comment">// 设置 API 信息</span></span><br><span class="line">                .apiInfo(<span class="keyword">this</span>.apiInfo())</span><br><span class="line">                <span class="comment">// 扫描 Controller 包路径，获得 API 接口</span></span><br><span class="line">                .select()</span><br><span class="line">            <span class="comment">// 注意改成自己的包名</span></span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.halo.apidoc.controller&quot;</span>))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                <span class="comment">// 构建出 Docket 对象</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 API 信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">apiInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">                .title(<span class="string">&quot;测试接口文档示例&quot;</span>)</span><br><span class="line">                .description(<span class="string">&quot;我是一段描述&quot;</span>)</span><br><span class="line">                <span class="comment">// 版本号</span></span><br><span class="line">                .version(<span class="string">&quot;1.0.0&quot;</span>)</span><br><span class="line">                <span class="comment">// 联系人</span></span><br><span class="line">                .contact(<span class="keyword">new</span> Contact(<span class="string">&quot;泷&quot;</span>, <span class="string">&quot;http://www.whl123456.top&quot;</span>, <span class="string">&quot;885240677@qq.com&quot;</span>))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在类上，添加 <a href="http://springfox.github.io/springfox/javadoc/2.5.0/index.html?springfox/documentation/swagger2/annotations/EnableSwagger2.html"><code>@EnableSwagger2</code></a> 注解， 标记项目启用 Swagger API 接口文档。</p><h3 id="Application"><a class="header-anchor" href="#Application"></a>Application</h3><p>创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-24/lab-24-apidoc-swagger/src/main/java/cn/iocoder/springboot/lab24/apidoc/Application.java"><code>Application.java</code></a> 类，配置 <code>@SpringBootApplication</code> 注解即可。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先暂时不启动项目。等我们添加好 Controller</p><h3 id="UserController"><a class="header-anchor" href="#UserController"></a>UserController</h3><p>在 <code>*.apidoc.controller</code> 包路径下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-24/lab-24-apidoc-swagger/src/main/java/cn/iocoder/springboot/lab24/apidoc/controller/TestController.java">UserController</a> 类，提供用户 API 接口。代码如下：</p><ul><li>相比我们之前使用 SpringMVC 来说，我们在类和接口上，额外增加了 Swagger 提供的注解。</li><li>从使用习惯上，我比较喜欢先添加 SpringMVC 的注解，再添加 Swagger 的注解。</li><li>因为已经使用了 Swagger 的注解，所以类和方法上的注释，一般可以删除了，除非有特殊诉求。</li><li>其中涉及到的 POJO 类，有 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-24/lab-24-apidoc-swagger/src/main/java/cn/iocoder/springboot/lab24/apidoc/dto/UserAddDTO.java">UserAddDTO</a>、<a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-24/lab-24-apidoc-swagger/src/main/java/cn/iocoder/springboot/lab24/apidoc/dto/UserUpdateDTO.java">UserUpdateDTO</a>、<a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-24/lab-24-apidoc-swagger/src/main/java/cn/iocoder/springboot/lab24/apidoc/vo/UserVO.java">UserVO</a> 。</li></ul><p>执行 Application 启动项目。然后浏览器访问 <code>http://127.0.0.1:8080/swagger-ui.html</code> 地址，就可以看到 Swagger 生成的 API 接口文档。如下图所示：</p><p>![Swagger-UI 示例](E:\OneDrive - lanqilu\我的图片库\blogimg\Java-01-SpringBoot\01.png)</p><p>至此，我们已经完成了 Swagger 的快速入门。不过考虑到胖友能够更好的使用，我们来一个一个注解了解。</p>]]></content>
      
      
      <categories>
          
          <category> Java框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thymeleaf</title>
      <link href="2020/10/29/Thymeleaf/"/>
      <url>2020/10/29/Thymeleaf/</url>
      
        <content type="html"><![CDATA[<h2 id="Thymeleaf-基础知识"><a class="header-anchor" href="#Thymeleaf-基础知识"></a>Thymeleaf 基础知识</h2><p>Thymeleaf 试一个模板引擎，以便显示由应用程序生成的数据或文本。它适合在Web应用程序中为HTML5提供服务，也可以处理任何XML文件。Thymeleaf具有开箱即用的特点：允许处理XML、HTML、JavaScript、CSS、普通文本等模板，每种模板都称为模板模式。</p><p>Thymeleaf 命名空间的被声明为 <code>th:*</code>属性，代码示例如下所示</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Thymeleaf的标准表达式"><a class="header-anchor" href="#Thymeleaf的标准表达式"></a>Thymeleaf的标准表达式</h2><p>Thymeleaf 的标准表达式主要包括以下8类</p><h3 id="简单表达式"><a class="header-anchor" href="#简单表达式"></a>简单表达式</h3><table><thead><tr><th style="text-align:center">语法</th><th style="text-align:center">名称</th><th style="text-align:center">描述</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>$&#123;…&#125;</code></td><td style="text-align:center">Variable Expressions</td><td style="text-align:center">变量表达式</td><td style="text-align:center">取出上下文变量的值</td></tr><tr><td style="text-align:center"><code>*&#123;…&#125;</code></td><td style="text-align:center">Selection Variable Expressions</td><td style="text-align:center">选择变量表达式</td><td style="text-align:center">取出选择的对象的属性值</td></tr><tr><td style="text-align:center"><code>#&#123;…&#125;</code></td><td style="text-align:center">Message Expressions</td><td style="text-align:center">消息表达式</td><td style="text-align:center">使文字消息国际化，I18N</td></tr><tr><td style="text-align:center"><code>@&#123;…&#125;</code></td><td style="text-align:center">Link URL Expressions</td><td style="text-align:center">链接表达式</td><td style="text-align:center">用于表示各种超链接地址</td></tr><tr><td style="text-align:center"><code>~&#123;…&#125;</code></td><td style="text-align:center">Fragment Expressions</td><td style="text-align:center">片段表达式</td><td style="text-align:center">引用一段公共的代码片段</td></tr></tbody></table><h3 id="字面量"><a class="header-anchor" href="#字面量"></a>字面量</h3><p>参考资料:《SpringBoot 开发实战》吴胜</p>]]></content>
      
      
      <categories>
          
          <category> JavaEE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thymeleaf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基本程序设计结构</title>
      <link href="2020/10/29/Java-01-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/"/>
      <url>2020/10/29/Java-01-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>参考资料：</p><ul><li>《Java核心技术 卷Ⅰ》（第11版）</li><li>《Java编程思想》（第4版）</li><li>《OnJava8》</li></ul><hr><h2 id="一个简单的Java程序"><a class="header-anchor" href="#一个简单的Java程序"></a>一个简单的Java程序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Java程序的入口方法，程序将从这里开始执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 向控制台打印一条语句，Java程序严格区分大小写</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello Word!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注释"><a class="header-anchor" href="#注释"></a>注释</h2><p>注释是使用自然语言编写的文本，供某一程序的人类读者阅读。Java 编译器会忽略注释。Java 支持三种注释。</p><p>第一种是单行注释，以 <code>//</code> 字符开始，直到行尾结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是注释...</span></span><br></pre></td></tr></table></figure><p>第二种是多行注释，以 <code>/*</code> 字符开始，不管有多少行，直到 <code>*/</code> 字符结束，一般用于多行注释。这种注释不能嵌套，即 <code>/* */</code> 中不能再有 <code>/* */</code>。编写多行注释时，程序员经常使用额外的 <code>*</code> 字符，突出注释的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这是注释</span></span><br><span class="line"><span class="comment"> * blablabla...</span></span><br><span class="line"><span class="comment"> * 这也是注释</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>第三种注释是第二种的一个特例。如果注释以 <code>/**</code> 开头，会被当成特殊的文档注释。和普通的多行注释一样，文档注释也以 <code>*/</code> 结尾，而且不能嵌套。如果你编写了一个 Java 类，希望让其他程序员使用，可以直接在源码中嵌入关于这个类和其中每个方法的文档。名为 javadoc 的程序会提取这些文档，经过处理后生成这个类的在线文档。文档注释中可以包含 HTML 标签和 javadoc 能理解的其他句法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可以用来自动创建文档的注释</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span> lanqilu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种特殊的多行注释需要写在类和方法的定义处，可以用于自动创建文档。</p><p>类文档标记</p><ul><li><code>@version 版本信息</code></li><li><code>@author 作者信息</code></li></ul><p>方法文档标记</p><ul><li><code>@param 参数名 说明</code></li><li><code>@return 说明</code></li><li><code>@exception 完整类名 说明</code></li><li><code>@deprecated</code></li></ul><p>Java程序对格式没有明确的要求，多几个空格或者回车不影响程序的正确性，但是我们要养成良好的编程习惯，注意遵守Java社区约定的编码格式。</p><h2 id="数据类型"><a class="header-anchor" href="#数据类型"></a>数据类型</h2><p>Java是一种强类型语言。这就意味着必须为每一个变量声明一种类型。</p><p>基本数据类型是CPU可以直接进行运算的类型。Java 支持八种基本数据类型，包括一种布尔类型、一种字符类型、四种整数类型和两种浮点数类型：</p><ul><li>整数类型：byte，short，int，long</li><li>浮点数类型：float，double</li><li>字符类型：char</li><li>布尔类型：boolean</li></ul><p>除了基本数据类型之外，Java 还支持称为引用类型的非基本数据类型：</p><ul><li>类（class）</li><li>接口（interface）</li><li>数组（array）</li></ul><blockquote><p>Java有一个能够表示任意精度的算术包，通常称为“大数”（big number）。虽然称为大数但它并不是一种基本Java类型，而是一个Java对象。</p></blockquote><h2 id="变量与常量"><a class="header-anchor" href="#变量与常量"></a>变量与常量</h2>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java后端学习路线</title>
      <link href="2020/10/25/%E5%90%8E%E7%AB%AF%E8%B7%AF%E7%BA%BF/"/>
      <url>2020/10/25/%E5%90%8E%E7%AB%AF%E8%B7%AF%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<p>对Java基础学习进行整理</p><hr><h2 id="Java基础"><a class="header-anchor" href="#Java基础"></a>Java基础</h2><h3 id="Java变量"><a class="header-anchor" href="#Java变量"></a>Java变量</h3><h3 id="Java操作符"><a class="header-anchor" href="#Java操作符"></a>Java操作符</h3><h3 id="Java控制流程"><a class="header-anchor" href="#Java控制流程"></a>Java控制流程</h3><h3 id="Java数组"><a class="header-anchor" href="#Java数组"></a>Java数组</h3><h3 id="Java类和对象"><a class="header-anchor" href="#Java类和对象"></a>Java类和对象</h3><h3 id="Java接口与继承"><a class="header-anchor" href="#Java接口与继承"></a>Java接口与继承</h3><h3 id="Java数字与字符串"><a class="header-anchor" href="#Java数字与字符串"></a>Java数字与字符串</h3><h3 id="Java日期"><a class="header-anchor" href="#Java日期"></a>Java日期</h3><h2 id="Java中级"><a class="header-anchor" href="#Java中级"></a>Java中级</h2><h3 id="Java集合"><a class="header-anchor" href="#Java集合"></a>Java集合</h3><h3 id="Java异常处理"><a class="header-anchor" href="#Java异常处理"></a>Java异常处理</h3><h3 id="Java泛型"><a class="header-anchor" href="#Java泛型"></a>Java泛型</h3><h3 id="Java函数式编程"><a class="header-anchor" href="#Java函数式编程"></a>Java函数式编程</h3><h3 id="Java-I-O系统"><a class="header-anchor" href="#Java-I-O系统"></a>Java I/O系统</h3><h3 id="Java多线程"><a class="header-anchor" href="#Java多线程"></a>Java多线程</h3><h3 id="Java网络编程"><a class="header-anchor" href="#Java网络编程"></a>Java网络编程</h3><h3 id="Java反射"><a class="header-anchor" href="#Java反射"></a>Java反射</h3><h3 id="Java注解"><a class="header-anchor" href="#Java注解"></a>Java注解</h3><h2 id="Java应用"><a class="header-anchor" href="#Java应用"></a>Java应用</h2><h3 id="Loga4j"><a class="header-anchor" href="#Loga4j"></a>Loga4j</h3><h3 id="Junit"><a class="header-anchor" href="#Junit"></a>Junit</h3><h3 id="Hutool"><a class="header-anchor" href="#Hutool"></a>Hutool</h3><h3 id="jsoup"><a class="header-anchor" href="#jsoup"></a>jsoup</h3><h3 id="Lombok"><a class="header-anchor" href="#Lombok"></a>Lombok</h3><h2 id="JavaWeb基础"><a class="header-anchor" href="#JavaWeb基础"></a>JavaWeb基础</h2><h3 id="HTML"><a class="header-anchor" href="#HTML"></a>HTML</h3><h3 id="CSS"><a class="header-anchor" href="#CSS"></a>CSS</h3><h3 id="JavaScript"><a class="header-anchor" href="#JavaScript"></a>JavaScript</h3><h3 id="HTML-DOM"><a class="header-anchor" href="#HTML-DOM"></a>HTML DOM</h3><h3 id="JSON"><a class="header-anchor" href="#JSON"></a>JSON</h3><h3 id="Ajax"><a class="header-anchor" href="#Ajax"></a>Ajax</h3><h3 id="Cookie、Session"><a class="header-anchor" href="#Cookie、Session"></a>Cookie、Session</h3><h3 id="JQuery"><a class="header-anchor" href="#JQuery"></a>JQuery</h3><h3 id="Vue-js"><a class="header-anchor" href="#Vue-js"></a>Vue.js</h3><h3 id="Node-js"><a class="header-anchor" href="#Node-js"></a>Node.js</h3><h3 id="BootStrap"><a class="header-anchor" href="#BootStrap"></a>BootStrap</h3><h3 id="webpack"><a class="header-anchor" href="#webpack"></a>webpack</h3><h3 id="chartjs"><a class="header-anchor" href="#chartjs"></a>chartjs</h3><h2 id="JavaEE"><a class="header-anchor" href="#JavaEE"></a>JavaEE</h2><h3 id="Tomcat"><a class="header-anchor" href="#Tomcat"></a>Tomcat</h3><h3 id="XML"><a class="header-anchor" href="#XML"></a>XML</h3><h3 id="Servlet"><a class="header-anchor" href="#Servlet"></a>Servlet</h3><h3 id="HTTP协议"><a class="header-anchor" href="#HTTP协议"></a>HTTP协议</h3><h3 id="Filter过滤器和监听器"><a class="header-anchor" href="#Filter过滤器和监听器"></a>Filter过滤器和监听器</h3><h3 id="JSP"><a class="header-anchor" href="#JSP"></a>JSP</h3><h3 id="MVC"><a class="header-anchor" href="#MVC"></a>MVC</h3><h3 id="Listener"><a class="header-anchor" href="#Listener"></a>Listener</h3><h3 id="Thymeleaf"><a class="header-anchor" href="#Thymeleaf"></a>Thymeleaf</h3><h3 id="Freemarker"><a class="header-anchor" href="#Freemarker"></a>Freemarker</h3><h3 id="前后端分离"><a class="header-anchor" href="#前后端分离"></a>前后端分离</h3><h2 id="工具基础"><a class="header-anchor" href="#工具基础"></a>工具基础</h2><h3 id="Git"><a class="header-anchor" href="#Git"></a>Git</h3><h3 id="Maven"><a class="header-anchor" href="#Maven"></a>Maven</h3><h3 id="Gradle"><a class="header-anchor" href="#Gradle"></a>Gradle</h3><h3 id="Intellij-IDEA"><a class="header-anchor" href="#Intellij-IDEA"></a>Intellij IDEA</h3><h3 id="Linux"><a class="header-anchor" href="#Linux"></a>Linux</h3><h3 id="Jenkins"><a class="header-anchor" href="#Jenkins"></a>Jenkins</h3><h3 id="设计模式"><a class="header-anchor" href="#设计模式"></a>设计模式</h3><h3 id="Nginx"><a class="header-anchor" href="#Nginx"></a>Nginx</h3><h3 id="WebSocket"><a class="header-anchor" href="#WebSocket"></a>WebSocket</h3><h3 id="QRCode"><a class="header-anchor" href="#QRCode"></a>QRCode</h3><h3 id="搜索引擎技术"><a class="header-anchor" href="#搜索引擎技术"></a>搜索引擎技术</h3><p>Lucene、Solr、ElasticSearch</p><h3 id="Quartz"><a class="header-anchor" href="#Quartz"></a>Quartz</h3><h3 id="Shiro"><a class="header-anchor" href="#Shiro"></a>Shiro</h3><h2 id="数据库"><a class="header-anchor" href="#数据库"></a>数据库</h2><h3 id="MySQL"><a class="header-anchor" href="#MySQL"></a>MySQL</h3><h3 id="JDBC"><a class="header-anchor" href="#JDBC"></a>JDBC</h3><h3 id="Redis"><a class="header-anchor" href="#Redis"></a>Redis</h3><h2 id="框架"><a class="header-anchor" href="#框架"></a>框架</h2><h3 id="Spring"><a class="header-anchor" href="#Spring"></a>Spring</h3><h3 id="SpringMVC"><a class="header-anchor" href="#SpringMVC"></a>SpringMVC</h3><h3 id="Mybatis"><a class="header-anchor" href="#Mybatis"></a>Mybatis</h3><h3 id="Mybatis-Plus"><a class="header-anchor" href="#Mybatis-Plus"></a>Mybatis-Plus</h3><h3 id="SSM"><a class="header-anchor" href="#SSM"></a>SSM</h3><h3 id="SpringBoot"><a class="header-anchor" href="#SpringBoot"></a>SpringBoot</h3><h3 id="Hibernate"><a class="header-anchor" href="#Hibernate"></a>Hibernate</h3><h3 id="Struts"><a class="header-anchor" href="#Struts"></a>Struts</h3><h3 id="MQ消息队列"><a class="header-anchor" href="#MQ消息队列"></a>MQ消息队列</h3><h3 id="RPC通信框架"><a class="header-anchor" href="#RPC通信框架"></a>RPC通信框架</h3><h3 id="Kafka"><a class="header-anchor" href="#Kafka"></a>Kafka</h3><h2 id="架构"><a class="header-anchor" href="#架构"></a>架构</h2><h3 id="Spring-Cloud"><a class="header-anchor" href="#Spring-Cloud"></a>Spring Cloud</h3><h3 id="dubbo"><a class="header-anchor" href="#dubbo"></a>dubbo</h3><h3 id="Docker"><a class="header-anchor" href="#Docker"></a>Docker</h3><h3 id="K8S"><a class="header-anchor" href="#K8S"></a>K8S</h3>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 学习路线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java函数式编程</title>
      <link href="2020/10/14/Java-05-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
      <url>2020/10/14/Java-05-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>函数式编程语言操纵代码片段就像操作数据一样容易。 虽然 Java 不是函数式语言，但 Java 8 Lambda 表达式和方法引用 (Method References) 允许你以函数式编程。</p><hr><p>在计算机时代早期，内存是稀缺和昂贵的。几乎每个人都用汇编语言编程。人们虽然知道编译器，但编译器生成的代码很低效，比手工编码的汇编程序多很多字节，仅仅想到这一点，人们还是选择汇编语言。</p><p>通常，为了使程序能在有限的内存上运行，在程序运行时，程序员通过修改内存中的代码，使程序可以执行不同的操作，用这种方式来节省代码空间。这种技术被称为<strong>自修改代码</strong> （self-modifying code）。只要程序小到几个人就能够维护所有棘手和难懂的汇编代码，你就能让程序运行起来。</p><p>随着内存和处理器变得更便宜、更快。C 语言出现并被大多数汇编程序员认为更“高级”。人们发现使用 C 可以显著提高生产力。同时，使用 C 创建自修改代码仍然不难。</p><p>随着硬件越来越便宜，程序的规模和复杂性都在增长。这一切只是让程序工作变得困难。我们想方设法使代码更加一致和易懂。使用纯粹的自修改代码造成的结果就是：我们很难确定程序在做什么。它也难以测试：除非你想一点点测试输出，代码转换和修改等等过程？</p><p>然而，使用代码以某种方式操纵其他代码的想法也很有趣，只要能保证它更安全。从代码创建，维护和可靠性的角度来看，这个想法非常吸引人。我们不用从头开始编写大量代码，而是从易于理解、充分测试及可靠的现有小块开始，最后将它们组合在一起以创建新代码。难道这不会让我们更有效率，同时创造更健壮的代码吗？</p><p>这就是<strong>函数式编程</strong>（FP）的意义所在。通过合并现有代码来生成新功能而不是从头开始编写所有内容，我们可以更快地获得更可靠的代码。至少在某些情况下，这套理论似乎很有用。在这一过程中，函数式语言已经产生了优雅的语法，这些语法对于非函数式语言也适用。</p><p>你也可以这样想：</p><p>OO（object oriented，面向对象）是抽象数据，FP（functional programming，函数式编程）是抽象行为。</p><p>纯粹的函数式语言在安全性方面更进一步。它强加了额外的约束，即所有数据必须是不可变的：设置一次，永不改变。将值传递给函数，该函数然后生成新值但从不修改自身外部的任何东西（包括其参数或该函数范围之外的元素）。当强制执行此操作时，你知道任何错误都不是由所谓的副作用引起的，因为该函数仅创建并返回结果，而不是其他任何错误。</p><p>更好的是，“不可变对象和无副作用”范式解决了并发编程中最基本和最棘手的问题之一（当程序的某些部分同时在多个处理器上运行时）。这是可变共享状态的问题，这意味着代码的不同部分（在不同的处理器上运行）可以尝试同时修改同一块内存（谁赢了？没人知道）。如果函数永远不会修改现有值但只生成新值，则不会对内存产生争用，这是纯函数式语言的定义。 因此，经常提出纯函数式语言作为并行编程的解决方案（还有其他可行的解决方案）。</p><p>需要提醒大家的是，函数式语言背后有很多动机，这意味着描述它们可能会有些混淆。它通常取决于各种观点：为“并行编程”，“代码可靠性”和“代码创建和库复用”。 关于函数式编程能高效创建更健壮的代码这一观点仍存在部分争议。虽然已有一些好的范例，但还不足以证明纯函数式语言就是解决编程问题的最佳方法。</p><p>FP 思想值得融入非 FP 语言，如 Python。Java 8 也从中吸收并支持了 FP。我们将在此章探讨。</p><h2 id="新旧对比"><a class="header-anchor" href="#新旧对比"></a>新旧对比</h2><p>通常，传递给方法的数据不同，结果不同。如果我们希望方法在调用时行为不同，该怎么做呢？结论是：只要能将代码传递给方法，我们就可以控制它的行为。此前，我们通过在方法中创建包含所需行为的对象，然后将该对象传递给我们想要控制的方法来完成此操作。下面我们用传统形式和 Java 8 的方法引用、Lambda 表达式分别演示。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// functional/Strategize.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">approach</span><span class="params">(String msg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Soft</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">approach</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> msg.toLowerCase() + <span class="string">&quot;?&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Unrelated</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> String <span class="title">twice</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> msg + <span class="string">&quot; &quot;</span> + msg;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Strategize</span> </span>&#123;</span><br><span class="line">  Strategy strategy;</span><br><span class="line">  String msg;</span><br><span class="line">  Strategize(String msg) &#123;</span><br><span class="line">    strategy = <span class="keyword">new</span> Soft(); <span class="comment">// [1]</span></span><br><span class="line">    <span class="keyword">this</span>.msg = msg;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">communicate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(strategy.approach(msg));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">changeStrategy</span><span class="params">(Strategy strategy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Strategy[] strategies = &#123;</span><br><span class="line">      <span class="keyword">new</span> Strategy() &#123; <span class="comment">// [2]</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">approach</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> msg.toUpperCase() + <span class="string">&quot;!&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      msg -&gt; msg.substring(<span class="number">0</span>, <span class="number">5</span>), <span class="comment">// [3]</span></span><br><span class="line">      Unrelated::twice <span class="comment">// [4]</span></span><br><span class="line">    &#125;;</span><br><span class="line">    Strategize s = <span class="keyword">new</span> Strategize(<span class="string">&quot;Hello there&quot;</span>);</span><br><span class="line">    s.communicate();</span><br><span class="line">    <span class="keyword">for</span>(Strategy newStrategy : strategies) &#123;</span><br><span class="line">      s.changeStrategy(newStrategy); <span class="comment">// [5]</span></span><br><span class="line">      s.communicate(); <span class="comment">// [6]</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output</span></span><br><span class="line"><span class="comment">hello there?</span></span><br><span class="line"><span class="comment">HELLO THERE!</span></span><br><span class="line"><span class="comment">Hello</span></span><br><span class="line"><span class="comment">Hello there Hello there</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>TODO ：对于程序的执行顺序有些不清楚。2020年10月14日</p><p><strong>Strategy</strong> 接口提供了单一的 <code>approach()</code> 方法来承载函数式功能。通过创建不同的 <strong>Strategy</strong> 对象，我们可以创建不同的行为。</p><p>我们一般通过创建一个实现<strong>Strategy</strong>接口的类来实现这种行为，正如在<strong>Soft</strong>里所做的。</p><ul><li><strong>[1]</strong> 在 <strong>Strategize</strong> 中，你可以看到 <strong>Soft</strong> 作为默认策略，在构造函数中赋值。</li><li><strong>[2]</strong> 一种较为简洁且更加自然的方法是创建一个<strong>匿名内部类</strong>。即便如此，仍有相当数量的冗余代码。你总需要仔细观察后才会发现：“哦，我明白了，原来这里使用了匿名内部类。”</li><li><strong>[3]</strong> Java 8 的 Lambda 表达式，其参数和函数体被箭头 <code>-&gt;</code> 分隔开。箭头右侧是从 Lambda 返回的表达式。它与单独定义类和采用匿名内部类是等价的，但代码少得多。</li><li><strong>[4]</strong> Java 8 的<strong>方法引用</strong>，它以 <code>::</code> 为特征。 <code>::</code> 的左边是类或对象的名称， <code>::</code> 的右边是方法的名称，但是没有参数列表。</li><li><strong>[5]</strong> 在使用默认的 <strong>Soft</strong> 策略之后，我们逐步遍历数组中的所有 <strong>Strategy</strong>，并通过调用 <code>changeStrategy()</code> 方法将每个 <strong>Strategy</strong> 传入变量 <code>s</code> 中。</li><li><strong>[6]</strong> 现在，每次调用 <code>communicate()</code> 都会产生不同的行为，具体取决于此刻正在使用的策略<strong>代码对象</strong>。我们传递的是行为，而并不仅仅是数据。</li></ul><p>在 Java 8 之前，我们能够通过 <strong>[1]</strong> 和 <strong>[2]</strong> 的方式传递功能。然而，这种语法的读写非常笨拙，并且我们别无选择。方法引用和 Lambda 表达式的出现让我们可以在需要时<strong>传递功能</strong>，而不是仅在必要时才这么做。</p><h2 id="Lambda表达式"><a class="header-anchor" href="#Lambda表达式"></a>Lambda表达式</h2><p>Lambda 表达式是使用<strong>最小可能</strong>语法编写的函数定义：</p><ol><li>Lambda 表达式产生函数，而不是类。 在 JVM（Java Virtual Machine，Java 虚拟机）上，一切都是一个类，因此在幕后执行各种操作使 Lambda 看起来像函数 —— 但作为程序员，你可以高兴地假装它们“只是函数”。</li><li>Lambda 语法尽可能少，这正是为了使 Lambda 易于编写和使用。</li></ol><p>我们在 <strong>Strategize.java</strong> 中看到了一个 Lambda 表达式，但还有其他语法变体：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// functional/LambdaExpressions.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Description</span> </span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">brief</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Body</span> </span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">detailed</span><span class="params">(String head)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Multi</span> </span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">twoArg</span><span class="params">(String head, Double d)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaExpressions</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> Body bod = h -&gt; h + <span class="string">&quot; No Parens!&quot;</span>; <span class="comment">// [1]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> Body bod2 = (h) -&gt; h + <span class="string">&quot; More details&quot;</span>; <span class="comment">// [2]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> Description desc = () -&gt; <span class="string">&quot;Short info&quot;</span>; <span class="comment">// [3]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> Multi mult = (h, n) -&gt; h + n; <span class="comment">// [4]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> Description moreLines = () -&gt; &#123; <span class="comment">// [5]</span></span><br><span class="line">    System.out.println(<span class="string">&quot;moreLines()&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;from moreLines()&quot;</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(bod.detailed(<span class="string">&quot;Oh!&quot;</span>));</span><br><span class="line">    System.out.println(bod2.detailed(<span class="string">&quot;Hi!&quot;</span>));</span><br><span class="line">    System.out.println(desc.brief());</span><br><span class="line">    System.out.println(mult.twoArg(<span class="string">&quot;Pi! &quot;</span>, <span class="number">3.14159</span>));</span><br><span class="line">    System.out.println(moreLines.brief());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们从三个接口开始，每个接口都有一个单独的方法（很快就会理解它的重要性）。但是，每个方法都有不同数量的参数，以便演示 Lambda 表达式语法。</p><p>任何 Lambda 表达式的基本语法是：</p><ol><li>参数。</li><li>接着 <code>-&gt;</code>，可视为“产出”。</li><li><code>-&gt;</code> 之后的内容都是方法体。<ul><li><strong>[1]</strong> 当只用一个参数，可以不需要括号 <code>()</code>。 然而，这是一个特例。</li><li><strong>[2]</strong> 正常情况使用括号 <code>()</code> 包裹参数。 为了保持一致性，也可以使用括号 <code>()</code> 包裹单个参数，虽然这种情况并不常见。</li><li><strong>[3]</strong> 如果没有参数，则必须使用括号 <code>()</code> 表示空参数列表。</li><li><strong>[4]</strong> 对于多个参数，将参数列表放在括号 <code>()</code> 中。</li></ul></li></ol><p>到目前为止，所有 Lambda 表达式方法体都是单行。 该表达式的结果自动成为 Lambda 表达式的返回值，在此处使用 <strong>return</strong> 关键字是非法的。 这是 Lambda 表达式简化相应语法的另一种方式。</p><p><strong>[5]</strong> 如果在 Lambda 表达式中确实需要多行，则必须将这些行放在花括号中。 在这种情况下，就需要使用 <strong>return</strong>。</p><p>Lambda 表达式通常比<strong>匿名内部类</strong>产生更易读的代码，因此我们将在本书中尽可能使用它们。</p><h2 id="递归"><a class="header-anchor" href="#递归"></a>递归</h2><p>递归函数是一个自我调用的函数。可以编写递归的 Lambda 表达式，但需要注意：递归方法必须是实例变量或静态变量，否则会出现编译时错误。 我们将为每个案例创建一个示例。</p><p>这两个示例都需要一个接受 <strong>int</strong> 型参数并生成 <strong>int</strong> 的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// functional/IntCall.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IntCall</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">call</span><span class="params">(<span class="keyword">int</span> arg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整数 n 的阶乘将所有小于或等于 n 的正整数相乘。 阶乘函数是一个常见的递归示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// functional/RecursiveFactorial.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursiveFactorial</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> IntCall fact;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    fact = n -&gt; n == <span class="number">0</span> ? <span class="number">1</span> : n * fact.call(n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">      System.out.println(fact.call(i));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output </span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">24</span></span><br><span class="line"><span class="comment">120</span></span><br><span class="line"><span class="comment">720</span></span><br><span class="line"><span class="comment">5040</span></span><br><span class="line"><span class="comment">40320</span></span><br><span class="line"><span class="comment">362880</span></span><br><span class="line"><span class="comment">3628800</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>这里，<code>fact</code> 是一个静态变量。 注意使用三元 <strong>if-else</strong>。 递归函数将一直调用自己，直到 <code>i == 0</code>。所有递归函数都有“停止条件”，否则将无限递归并产生异常。</p><p>我们可以将 <code>Fibonacci</code> 序列用递归的 Lambda 表达式来实现，这次使用实例变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// functional/RecursiveFibonacci.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursiveFibonacci</span> </span>&#123;</span><br><span class="line">    IntCall fib;</span><br><span class="line"></span><br><span class="line">    RecursiveFibonacci() &#123;</span><br><span class="line">        fib = n -&gt; n == <span class="number">0</span> ? <span class="number">0</span> :</span><br><span class="line">                n == <span class="number">1</span> ? <span class="number">1</span> :</span><br><span class="line">                        fib.call(n - <span class="number">1</span>) + fib.call(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fib.call(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RecursiveFibonacci rf = <span class="keyword">new</span> RecursiveFibonacci();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(rf.fibonacci(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output </span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">13</span></span><br><span class="line"><span class="comment">21</span></span><br><span class="line"><span class="comment">34</span></span><br><span class="line"><span class="comment">55 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>将 <code>Fibonacci</code> 序列中的最后两个元素求和来产生下一个元素。</p><h2 id="方法引用"><a class="header-anchor" href="#方法引用"></a>方法引用</h2><p>Java 8 方法引用没有历史包袱。方法引用组成：类名或对象名，后面跟 <code>::</code> ，然后跟方法名称。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// functional/MethodReferences.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Callable</span> </span>&#123; <span class="comment">// [1]</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Describe</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(String msg)</span> </span>&#123; <span class="comment">// [2]</span></span><br><span class="line">    System.out.println(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodReferences</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(String name)</span> </span>&#123; <span class="comment">// [3]</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Hello, &quot;</span> + name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Description</span> </span>&#123;</span><br><span class="line">    String about;</span><br><span class="line">    Description(String desc) &#123; about = desc; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">help</span><span class="params">(String msg)</span> </span>&#123; <span class="comment">// [4]</span></span><br><span class="line">      System.out.println(about + <span class="string">&quot; &quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Helper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assist</span><span class="params">(String msg)</span> </span>&#123; <span class="comment">// [5]</span></span><br><span class="line">      System.out.println(msg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Describe d = <span class="keyword">new</span> Describe();</span><br><span class="line">    Callable c = d::show; <span class="comment">// [6]</span></span><br><span class="line">    c.call(<span class="string">&quot;call()&quot;</span>); <span class="comment">// [7]</span></span><br><span class="line"></span><br><span class="line">    c = MethodReferences::hello; <span class="comment">// [8]</span></span><br><span class="line">    c.call(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line"></span><br><span class="line">    c = <span class="keyword">new</span> Description(<span class="string">&quot;valuable&quot;</span>)::help; <span class="comment">// [9]</span></span><br><span class="line">    c.call(<span class="string">&quot;information&quot;</span>);</span><br><span class="line"></span><br><span class="line">    c = Helper::assist; <span class="comment">// [10]</span></span><br><span class="line">    c.call(<span class="string">&quot;Help!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>[1]</strong> 我们从单一方法接口开始（同样，你很快就会了解到这一点的重要性）。</p><p><strong>[2]</strong> <code>show()</code> 的签名（参数类型和返回类型）符合 <strong>Callable</strong> 的 <code>call()</code> 的签名。</p><p><strong>[3]</strong> <code>hello()</code> 也符合 <code>call()</code> 的签名。</p><p><strong>[4]</strong> <code>help()</code> 也符合，它是静态内部类中的非静态方法。</p><p><strong>[5]</strong> <code>assist()</code> 是静态内部类中的静态方法。</p><p><strong>[6]</strong> 我们将 <strong>Describe</strong> 对象的方法引用赋值给 <strong>Callable</strong> ，它没有 <code>show()</code> 方法，而是 <code>call()</code> 方法。 但是，Java 似乎接受用这个看似奇怪的赋值，因为方法引用符合 <strong>Callable</strong> 的 <code>call()</code> 方法的签名。</p><p><strong>[7]</strong> 我们现在可以通过调用 <code>call()</code> 来调用 <code>show()</code>，因为 Java 将 <code>call()</code> 映射到 <code>show()</code>。</p><p><strong>[8]</strong> 这是一个<strong>静态</strong>方法引用。</p><p><strong>[9]</strong> 这是 <strong>[6]</strong> 的另一个版本：对已实例化对象的方法的引用，有时称为<em>绑定方法引用</em>。</p><p><strong>[10]</strong> 最后，获取静态内部类中静态方法的引用与 <strong>[8]</strong> 中通过外部类引用相似。</p><p>上例只是简短的介绍，我们很快就能看到方法引用的所有不同形式。</p><p>TODO ：此章较难之后继续研究。2020年10月16日</p>]]></content>
      
      
      <categories>
          
          <category> 函数式编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合</title>
      <link href="2020/10/12/Java-01-%E9%9B%86%E5%90%88-Achieve/"/>
      <url>2020/10/12/Java-01-%E9%9B%86%E5%90%88-Achieve/</url>
      
        <content type="html"><![CDATA[<p>了解有关Java集合类库的基本知识，以及对典型用法的重点介绍</p><p>参考资料:《OnJava8》</p><hr><blockquote><p>如果一个程序只包含固定数量的且其生命期都是已知的对象，那么这是一个非常简单程序。</p></blockquote><p>通常，程序总是根据运行时才知道的某些条件去创建新对象。在此之前，不会知道所需对象的数量，甚至不知道确切的类型。为解决这个普遍的编程问题，需要在任意时刻和任意位创建任意数量的对象。所以，就不能依靠创建命名的引用来持有每一个对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyType aReference;</span><br></pre></td></tr></table></figure><p>因为你不知道实际上会需要多少这样的引用。</p><p>大多数语言都提供某种方法来解决这个基本问题。Java有多种方式进行对象的引用。例如前面曾经学习过的数组，它是编译器支持的类型。数组是保存一组对象的最有效的方式，如果你想保存一组基本类型数据，也推荐使用这种方式。但是数组具有固定的尺寸而在更一般的情况中，你在写程序时并不知道将需要多少个对象，或者是否需要更复杂的方式来存储对象，因此数组尺寸固定这一限制显得过于受限了。</p><p>Java 实用类库还提供了一套相当完整的容器类来解决这个问题，其中基本的类型是<strong>List</strong>、<strong>Set</strong>、 <strong>Queue</strong>和<strong>Map</strong>。这些对象类型也称为集合类，集合提供了完善的方法来保存对象，你可以使用这些工具来解决数量惊人的问题。</p><p>集合还有其他一些特性。例如，<strong>Set</strong>对于每个值都只保存一个对象，<strong>Map</strong>是允许你将某些对象与其他一些对象关联起来的关联数组，Java 集合类都可以自动地调整自己的尺寸。因此，与数组不同，在编程时，你可以将任意数量的对象放置到集合中，并且不需要担心集合应该设置为多大。</p><p>即使在Java中没有直接的关键字支持，集合类仍旧是可以显著增强你的编程能力的基本工具。</p><h2 id="泛型和类型安全的集合"><a class="header-anchor" href="#泛型和类型安全的集合"></a>泛型和类型安全的集合</h2><p>使用 Java 5之前的集合的一个主要问题就是编译器允许你向集合中插入不正确的类型。例如，考虑一个 Apple对象的集合，我们使用最基本最可靠的集合 <strong>ArrayList</strong>。现在，你可以把<strong>ArrayList</strong>当作“可以自动扩充自身尺寸的数组”来看待。使用 <strong>ArrayList</strong>相当简单：创建一个实例，用<code>add()</code>插入对象；然后用<code>get()</code>访问这些对象，此时需要使用索引，就像数组一样，但是不需要方括号。 <strong>ArrayList</strong>还有一个 <code>size()</code>方法，使你可以知道已经有多少元素添加了进来，从而不会不小心因索引越界而引发错误。</p><p>在本例中， <strong>Apple</strong>和 <strong>Orange</strong>都放置在了集合中，然后将它们取出。正常情况下，Java编译器会报告警告信息，因为这个示例没有使用泛型。在这里，我们使用特定的注解来抑制了警告信息。注解以“@”符号开头，可以接受参数，这里的<code>@SuppressWarnings</code>注解及其参数表示只抑制“unchecked（不受检查的异常）”类型的警告信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/ApplesAndOrangesWithoutGenerics.java</span></span><br><span class="line"><span class="comment">// Simple collection use (suppressing compiler warnings)</span></span><br><span class="line"><span class="comment">// &#123;ThrowsException&#125;</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id = counter++;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">id</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> id; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplesAndOrangesWithoutGenerics</span> </span>&#123;</span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ArrayList apples = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">      apples.add(<span class="keyword">new</span> Apple());</span><br><span class="line">    <span class="comment">// No problem adding an Orange to apples:</span></span><br><span class="line">    apples.add(<span class="keyword">new</span> Orange());</span><br><span class="line">    <span class="keyword">for</span>(Object apple : apples) &#123;</span><br><span class="line">      ((Apple) apple).id();</span><br><span class="line">      <span class="comment">// Orange is detected only at run time</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">___[ Error Output ]___</span></span><br><span class="line"><span class="comment">Exception in thread &quot;main&quot;</span></span><br><span class="line"><span class="comment">java.lang.ClassCastException: Orange cannot be cast to</span></span><br><span class="line"><span class="comment">Apple</span></span><br><span class="line"><span class="comment">        at ApplesAndOrangesWithoutGenerics.main(ApplesA</span></span><br><span class="line"><span class="comment">ndOrangesWithoutGenerics.java:23)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>Apple</strong> 和 <strong>Orange</strong> 是截然不同的，它们除了都是 <strong>Object</strong> 之外没有任何共同点（如果一个类没有显式地声明继承自哪个类，那么它就自动继承自 <strong>Object</strong>）。因为 <strong>ArrayList</strong> 保存的是 <strong>Object</strong> ，所以不仅可以通过 <strong>ArrayList</strong> 的 <code>add()</code> 方法将 <strong>Apple</strong> 对象放入这个集合，而且可以放入 <strong>Orange</strong> 对象，这无论在编译期还是运行时都不会有问题。当使用 <strong>ArrayList</strong> 的 <code>get()</code> 方法来取出你认为是 <strong>Apple</strong> 的对象时，得到的只是 <strong>Object</strong> 引用，必须将其转型为 <strong>Apple</strong>。然后需要将整个表达式用括号括起来，以便在调用 <strong>Apple</strong> 的 <code>id()</code> 方法之前，强制执行转型。否则，将会产生语法错误。</p><p>在运行时，当尝试将 <strong>Orange</strong> 对象转为 <strong>Apple</strong> 时，会出现输出中显示的错误。</p><p>Java 泛型来创建类可能很复杂。但是，使用预先定义的泛型类却相当简单。例如，要定义一个用于保存 <strong>Apple</strong> 对象的 <strong>ArrayList</strong> ，只需要使用 <strong>ArrayList&lt;Apple&gt;</strong> 来代替 <strong>ArrayList</strong> 。尖括号括起来的是<em>类型参数</em>（可能会有多个），它指定了这个集合实例可以保存的类型。</p><p>通过使用泛型，就可以在编译期防止将错误类型的对象放置到集合中。下面还是这个示例，但是使用了泛型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/ApplesAndOrangesWithGenerics.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplesAndOrangesWithGenerics</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Apple&gt; apples = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">      apples.add(<span class="keyword">new</span> Apple());</span><br><span class="line">    <span class="comment">// Compile-time error:</span></span><br><span class="line">    <span class="comment">// apples.add(new Orange());</span></span><br><span class="line">    <span class="keyword">for</span>(Apple apple : apples) &#123;</span><br><span class="line">      System.out.println(apple.id());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在 <strong>apples</strong> 定义的右侧，可以看到 <code>new ArrayList&lt;&gt;()</code> 。这有时被称为“菱形语法”（diamond syntax）。在 Java 7 之前，必须要在两端都进行类型声明，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Apple&gt; apples = <span class="keyword">new</span> ArrayList&lt;Apple&gt;();</span><br></pre></td></tr></table></figure><p>随着类型变得越来越复杂，这种重复产生的代码非常混乱且难以阅读。程序员发现所有类型信息都可以从左侧获得，因此，编译器没有理由强迫右侧再重复这些。虽然<em>类型推断</em>（type inference）只是个很小的请求，Java 语言团队仍然欣然接受并进行了改进。</p><p>有了 <strong>ArrayList</strong> 声明中的类型指定，编译器会阻止将 <strong>Orange</strong> 放入 <strong>apples</strong> ，因此，这会成为一个编译期错误而不是运行时错误。</p><p>使用泛型，从 <strong>List</strong> 中获取元素不需要强制类型转换。因为 <strong>List</strong> 知道它持有什么类型，因此当调用 <code>get()</code> 时，它会替你执行转型。因此，使用泛型，你不仅知道编译器将检查放入集合的对象类型，而且在使用集合中的对象时也可以获得更清晰的语法。</p><p>当指定了某个类型为泛型参数时，并不仅限于只能将确切类型的对象放入集合中。向上转型也可以像作用于其他类型一样作用于泛型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/GenericsAndUpcasting.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GrannySmith</span> <span class="keyword">extends</span> <span class="title">Apple</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gala</span> <span class="keyword">extends</span> <span class="title">Apple</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fuji</span> <span class="keyword">extends</span> <span class="title">Apple</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Braeburn</span> <span class="keyword">extends</span> <span class="title">Apple</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsAndUpcasting</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Apple&gt; apples = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    apples.add(<span class="keyword">new</span> GrannySmith());</span><br><span class="line">    apples.add(<span class="keyword">new</span> Gala());</span><br><span class="line">    apples.add(<span class="keyword">new</span> Fuji());</span><br><span class="line">    apples.add(<span class="keyword">new</span> Braeburn());</span><br><span class="line">    <span class="keyword">for</span>(Apple apple : apples)</span><br><span class="line">      System.out.println(apple);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">GrannySmith@15db9742</span></span><br><span class="line"><span class="comment">Gala@6d06d69c</span></span><br><span class="line"><span class="comment">Fuji@7852e922</span></span><br><span class="line"><span class="comment">Braeburn@4e25154f</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>因此，可以将 <strong>Apple</strong> 的子类型添加到被指定为保存 <strong>Apple</strong> 对象的集合中。</p><p>程序的输出是从 <strong>Object</strong> 默认的 <code>toString()</code> 方法产生的，该方法打印类名，后边跟着对象的散列码的无符号十六进制表示（这个散列码是通过 <code>hashCode()</code> 方法产生的）。</p><h2 id="基本概念"><a class="header-anchor" href="#基本概念"></a>基本概念</h2><p>Java集合类库采用“持有对象”（holding objects）的思想，并将其分为两个不同的概念，表示为类库的基本接口：</p><ol><li><strong>集合（Collection）</strong> ：一个独立元素的序列，这些元素都服从一条或多条规则。<strong>List</strong> 必须以插入的顺序保存元素， <strong>Set</strong> 不能包含重复元素， <strong>Queue</strong> 按照<em>排队规则</em>来确定对象产生的顺序（通常与它们被插入的顺序相同）。</li><li><strong>映射（Map）</strong> ： 一组成对的“键值对”对象，允许使用键来查找值。 <strong>ArrayList</strong> 使用数字来查找对象，因此在某种意义上讲，它是将数字和对象关联在一起。 <strong>map</strong> 允许我们使用一个对象来查找另一个对象，它也被称作<em>关联数组</em>（associative array），因为它将对象和其它对象关联在一起；或者称作<em>字典</em>（dictionary），因为可以使用一个键对象来查找值对象，就像在字典中使用单词查找定义一样。 <strong>Map</strong> 是强大的编程工具。</li></ol><p>尽管并非总是可行，但在理想情况下，你编写的大部分代码都在与这些接口打交道，并且唯一需要指定所使用的精确类型的地方就是在创建的时候。因此，可以像下面这样创建一个 <strong>List</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Apple&gt; apples = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>请注意， <strong>ArrayList</strong> 已经被向上转型为了 <strong>List</strong> ，这与之前示例中的处理方式正好相反。使用接口的目的是，如果想要改变具体实现，只需在创建时修改它就行了，就像下面这样：</p><p>TODO ： 暂不理解“使用接口的目的是，如果想要改变具体实现，只需在创建时修改它就行了”这句话的意义。2020年10月12日</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Apple&gt; apples = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>因此，应该创建一个具体类的对象，将其向上转型为对应的接口，然后在其余代码中都是用这个接口。</p><p>这种方式并非总是有效的，因为某些具体类有额外的功能。例如， <strong>LinkedList</strong> 具有 <strong>List</strong> 接口中未包含的额外方法，而 <strong>TreeMap</strong> 也具有在 <strong>Map</strong> 接口中未包含的方法。如果需要使用这些方法，就不能将它们向上转型为更通用的接口。</p><p><strong>Collection</strong> 接口概括了序列的概念——一种存放一组对象的方式。下面是个简单的示例，用 <strong>Integer</strong> 对象填充了一个 <strong>Collection</strong> （这里用 <strong>ArrayList</strong> 表示），然后打印集合中的每个元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/SimpleCollection.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleCollection</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Collection&lt;Integer&gt; c = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">      c.add(i); <span class="comment">// Autoboxing</span></span><br><span class="line">    <span class="keyword">for</span>(Integer i : c)</span><br><span class="line">      System.out.print(i + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">0, 1, 2, 3, 4, 5, 6, 7, 8, 9,</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这个例子仅使用了 <strong>Collection</strong> 中的方法（即 <code>add()</code> ），所以使用任何继承自 <strong>Collection</strong> 的类的对象都可以正常工作。但是 <strong>ArrayList</strong> 是最基本的序列类型。</p><p><code>add()</code> 方法的名称就表明它是在 <strong>Collection</strong> 中添加一个新元素。但是，文档中非常详细地叙述到 <code>add()</code> “要确保这个 <strong>Collection</strong> 包含指定的元素。”这是因为考虑到了 <strong>Set</strong> 的含义，因为在 <strong>Set</strong>中，只有当元素不存在时才会添加元素。在使用 <strong>ArrayList</strong> ，或任何其他类型的 <strong>List</strong> 时，<code>add()</code> 总是表示“把它放进去”，因为 <strong>List</strong> 不关心是否存在重复元素。</p><p>TODO ：不理解“要确保这个 <strong>Collection</strong> 包含指定的元素。”的必要。2020年10月12日</p><p>可以使用 <em>for-in</em> 语法来遍历所有的 <strong>Collection</strong> ，就像这里所展示的那样。在本章的后续部分，还将学习到一个更灵活的概念，<em>迭代器</em>。</p><h2 id="添加元素组"><a class="header-anchor" href="#添加元素组"></a>添加元素组</h2><p>TODO ：此小节不理解。2020年10月12日</p><p>在 <strong>java.util</strong> 包中的 <strong>Arrays</strong> 和 <strong>Collections</strong> 类中都有很多实用的方法，可以在一个 <strong>Collection</strong> 中添加一组元素。</p><p><code>Arrays.asList()</code> 方法接受一个数组或是逗号分隔的元素列表（使用可变参数），并将其转换为 <strong>List</strong> 对象。 <code>Collections.addAll()</code> 方法接受一个 <strong>Collection</strong> 对象，以及一个数组或是一个逗号分隔的列表，将其中元素添加到 <strong>Collection</strong> 中。下边的示例展示了这两个方法，以及更通用的 、所有 <strong>Collection</strong> 类型都包含的<code>addAll()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/AddingGroups.java</span></span><br><span class="line"><span class="comment">// Adding groups of elements to Collection objects</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddingGroups</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Collection&lt;Integer&gt; collection =</span><br><span class="line">      <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">    Integer[] moreInts = &#123; <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    collection.addAll(Arrays.asList(moreInts));</span><br><span class="line">    <span class="comment">// Runs significantly faster, but you can&#x27;t</span></span><br><span class="line">    <span class="comment">// construct a Collection this way:</span></span><br><span class="line">    Collections.addAll(collection, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>);</span><br><span class="line">    Collections.addAll(collection, moreInts);</span><br><span class="line">    <span class="comment">// Produces a list &quot;backed by&quot; an array:</span></span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>);</span><br><span class="line">    list.set(<span class="number">1</span>, <span class="number">99</span>); <span class="comment">// OK -- modify an element</span></span><br><span class="line">    <span class="comment">// list.add(21); // Runtime error; the underlying</span></span><br><span class="line">                     <span class="comment">// array cannot be resized.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Collection</strong> 的构造器可以接受另一个 <strong>Collection</strong>，用它来将自身初始化。因此，可以使用 <code>Arrays.asList()</code> 来为这个构造器产生输入。但是， <code>Collections.addAll()</code> 运行得更快，而且很容易构建一个不包含元素的 <strong>Collection</strong> ，然后调用 <code>Collections.addAll()</code> ，因此这是首选方式。</p><p><code>Collection.addAll()</code> 方法只能接受另一个 <strong>Collection</strong> 作为参数，因此它没有 <code>Arrays.asList()</code> 或 <code>Collections.addAll()</code> 灵活。这两个方法都使用可变参数列表。</p><p>也可以直接使用 <code>Arrays.asList()</code> 的输出作为一个 <strong>List</strong> ，但是这里的底层实现是数组，没法调整大小。如果尝试在这个 <strong>List</strong> 上调用 <code>add()</code> 或 <code>remove()</code>，由于这两个方法会尝试修改数组大小，所以会在运行时得到“Unsupported Operation（不支持的操作）”错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/AsListInference.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Snow</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Powder</span> <span class="keyword">extends</span> <span class="title">Snow</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Light</span> <span class="keyword">extends</span> <span class="title">Powder</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Heavy</span> <span class="keyword">extends</span> <span class="title">Powder</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Crusty</span> <span class="keyword">extends</span> <span class="title">Snow</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Slush</span> <span class="keyword">extends</span> <span class="title">Snow</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsListInference</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Snow&gt; snow1 = Arrays.asList(</span><br><span class="line">      <span class="keyword">new</span> Crusty(), <span class="keyword">new</span> Slush(), <span class="keyword">new</span> Powder());</span><br><span class="line">    <span class="comment">//- snow1.add(new Heavy()); // Exception</span></span><br><span class="line"></span><br><span class="line">    List&lt;Snow&gt; snow2 = Arrays.asList(</span><br><span class="line">      <span class="keyword">new</span> Light(), <span class="keyword">new</span> Heavy());</span><br><span class="line">    <span class="comment">//- snow2.add(new Slush()); // Exception</span></span><br><span class="line"></span><br><span class="line">    List&lt;Snow&gt; snow3 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Collections.addAll(snow3,</span><br><span class="line">      <span class="keyword">new</span> Light(), <span class="keyword">new</span> Heavy(), <span class="keyword">new</span> Powder());</span><br><span class="line">    snow3.add(<span class="keyword">new</span> Crusty());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hint with explicit type argument specification:</span></span><br><span class="line">    List&lt;Snow&gt; snow4 = Arrays.&lt;Snow&gt;asList(</span><br><span class="line">       <span class="keyword">new</span> Light(), <span class="keyword">new</span> Heavy(), <span class="keyword">new</span> Slush());</span><br><span class="line">    <span class="comment">//- snow4.add(new Powder()); // Exception</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <strong>snow4</strong> 中，注意 <code>Arrays.asList()</code> 中间的“暗示”（即 <code>&lt;Snow&gt;</code> ），告诉编译器 <code>Arrays.asList()</code> 生成的结果 <strong>List</strong> 类型的实际目标类型是什么。这称为<em>显式类型参数说明</em>（explicit type argument specification）。</p><h2 id="集合的打印"><a class="header-anchor" href="#集合的打印"></a>集合的打印</h2><p>必须使用 <code>Arrays.toString()</code> 来生成数组的可打印形式。但是打印集合无需任何帮助。下面是一个例子，这个例子中也介绍了基本的Java集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/PrintingCollections.java</span></span><br><span class="line"><span class="comment">// Collections print themselves automatically</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintingCollections</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Collection <span class="title">fill</span><span class="params">(Collection&lt;String&gt; collection)</span> </span>&#123;</span><br><span class="line">    collection.add(<span class="string">&quot;rat&quot;</span>);</span><br><span class="line">    collection.add(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">    collection.add(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">    collection.add(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> collection;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Map <span class="title">fill</span><span class="params">(Map&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class="line">    map.put(<span class="string">&quot;rat&quot;</span>, <span class="string">&quot;Fuzzy&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;cat&quot;</span>, <span class="string">&quot;Rags&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;dog&quot;</span>, <span class="string">&quot;Bosco&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;dog&quot;</span>, <span class="string">&quot;Spot&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(fill(<span class="keyword">new</span> ArrayList&lt;&gt;()));</span><br><span class="line">    System.out.println(fill(<span class="keyword">new</span> LinkedList&lt;&gt;()));</span><br><span class="line">    System.out.println(fill(<span class="keyword">new</span> HashSet&lt;&gt;()));</span><br><span class="line">    System.out.println(fill(<span class="keyword">new</span> TreeSet&lt;&gt;()));</span><br><span class="line">    System.out.println(fill(<span class="keyword">new</span> LinkedHashSet&lt;&gt;()));</span><br><span class="line">    System.out.println(fill(<span class="keyword">new</span> HashMap&lt;&gt;()));</span><br><span class="line">    System.out.println(fill(<span class="keyword">new</span> TreeMap&lt;&gt;()));</span><br><span class="line">    System.out.println(fill(<span class="keyword">new</span> LinkedHashMap&lt;&gt;()));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[rat, cat, dog, dog]</span></span><br><span class="line"><span class="comment">[rat, cat, dog, dog]</span></span><br><span class="line"><span class="comment">[rat, cat, dog]</span></span><br><span class="line"><span class="comment">[cat, dog, rat]</span></span><br><span class="line"><span class="comment">[rat, cat, dog]</span></span><br><span class="line"><span class="comment">&#123;rat=Fuzzy, cat=Rags, dog=Spot&#125;</span></span><br><span class="line"><span class="comment">&#123;cat=Rags, dog=Spot, rat=Fuzzy&#125;</span></span><br><span class="line"><span class="comment">&#123;rat=Fuzzy, cat=Rags, dog=Spot&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这显示了Java集合库中的两个主要类型。它们的区别在于集合中的每个“槽”（slot）保存的元素个数。 <strong>Collection</strong> 类型在每个槽中只能保存一个元素。此类集合包括： <strong>List</strong> ，它以特定的顺序保存一组元素； <strong>Set</strong> ，其中元素不允许重复； <strong>Queue</strong> ，只能在集合一端插入对象，并从另一端移除对象（就本例而言，这只是查看序列的另一种方式，因此并没有显示它）。 <strong>Map</strong> 在每个槽中存放了两个元素，即键和与之关联的值。</p><p>默认的打印行为，使用集合提供的 <code>toString()</code> 方法即可生成可读性很好的结果。 <strong>Collection</strong> 打印出的内容用方括号括住，每个元素由逗号分隔。 <strong>Map</strong> 则由大括号括住，每个键和值用等号连接（键在左侧，值在右侧）。</p><p>第一个 <code>fill()</code> 方法适用于所有类型的 <strong>Collection</strong> ，这些类型都实现了 <code>add()</code> 方法以添加新元素。</p><p><strong>ArrayList</strong> 和 <strong>LinkedList</strong> 都是 <strong>List</strong> 的类型，从输出中可以看出，它们都按插入顺序保存元素。两者之间的区别不仅在于执行某些类型的操作时的性能，而且 <strong>LinkedList</strong> 包含的操作多于 <strong>ArrayList</strong> 。本章后面将对这些内容进行更全面的探讨。</p><p><strong>HashSet</strong> ， <strong>TreeSet</strong> 和 <strong>LinkedHashSet</strong> 是 <strong>Set</strong> 的类型。从输出中可以看到， <strong>Set</strong> 仅保存每个相同项中的一个，并且不同的 <strong>Set</strong> 实现存储元素的方式也不同。 <strong>HashSet</strong> 使用相当复杂的方法存储元素。现在只需要知道，这种技术是检索元素的最快方法，因此，存储顺序看上去没有什么意义（通常只关心某事物是否是 <strong>Set</strong> 的成员，而存储顺序并不重要）。如果存储顺序很重要，则可以使用 <strong>TreeSet</strong> ，它将按比较结果的升序保存对象）或 <strong>LinkedHashSet</strong> ，它按照被添加的先后顺序保存对象。</p><p><strong>Map</strong> （也称为关联数组）使用键来查找对象，就像一个简单的数据库。所关联的对象称为值。 假设有一个 <strong>Map</strong> 将美国州名与它们的首府联系在一起，如果想要俄亥俄州（Ohio）的首府，可以用“Ohio”作为键来查找，几乎就像使用数组下标一样。正是由于这种行为，对于每个键， <strong>Map</strong> 只存储一次。</p><p><code>Map.put(key, value)</code> 添加一个所想要添加的值并将它与一个键（用来查找值）相关联。 <code>Map.get(key)</code> 生成与该键相关联的值。上面的示例仅添加键值对，并没有执行查找。这将在稍后展示。</p><p>请注意，这里没有指定（或考虑） <strong>Map</strong> 的大小，因为它会自动调整大小。 此外， <strong>Map</strong> 还知道如何打印自己，它会显示相关联的键和值。</p><p>本例使用了 <strong>Map</strong> 的三种基本风格： <strong>HashMap</strong> ， <strong>TreeMap</strong> 和 <strong>LinkedHashMap</strong> 。</p><p>键和值保存在 <strong>HashMap</strong> 中的顺序不是插入顺序，因为 <strong>HashMap</strong> 实现使用了非常快速的算法来控制顺序。 <strong>TreeMap</strong> 通过比较结果的升序来保存键， <strong>LinkedHashMap</strong> 在保持 <strong>HashMap</strong> 查找速度的同时按键的插入顺序保存键。</p><h2 id="列表List"><a class="header-anchor" href="#列表List"></a>列表List</h2><p><strong>List</strong>承诺将元素保存在特定的序列中。 <strong>List</strong> 接口在 <strong>Collection</strong> 的基础上添加了许多方法，允许在 <strong>List</strong> 的中间插入和删除元素。</p><p>有两种类型的 <strong>List</strong> ：</p><ul><li>基本的 <strong>ArrayList</strong> ，擅长随机访问元素，但在 <strong>List</strong> 中间插入和删除元素时速度较慢。</li><li><strong>LinkedList</strong> ，它通过代价较低的在 <strong>List</strong> 中间进行的插入和删除操作，提供了优化的顺序访问。 <strong>LinkedList</strong> 对于随机访问来说相对较慢，但它具有比 <strong>ArrayList</strong> 更大的特征集。</li></ul><p>TODO ：特征集？2020年10月12日</p><p>下面的示例导入 <strong>typeinfo.pets</strong> ，超前使用了类型信息一章中的类库。这个类库包含了 <strong>Pet</strong> 类层次结构，以及用于随机生成 <strong>Pet</strong> 对象的一些工具类。此时不需要了解完整的详细信息，只需要知道两点：</p><ol><li>有一个 <strong>Pet</strong> 类，以及 <strong>Pet</strong> 的各种子类型。</li><li>静态的 <code>Pets.arrayList()</code> 方法返回一个填充了随机选取的 <strong>Pet</strong> 对象的 <strong>ArrayList</strong>：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/ListFeatures.java</span></span><br><span class="line"><span class="keyword">import</span> typeinfo.pets.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListFeatures</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    List&lt;Pet&gt; pets = Pets.list(<span class="number">7</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;1: &quot;</span> + pets);</span><br><span class="line">    Hamster h = <span class="keyword">new</span> Hamster();</span><br><span class="line">    pets.add(h); <span class="comment">// Automatically resizes</span></span><br><span class="line">    System.out.println(<span class="string">&quot;2: &quot;</span> + pets);</span><br><span class="line">    System.out.println(<span class="string">&quot;3: &quot;</span> + pets.contains(h));</span><br><span class="line">    pets.remove(h); <span class="comment">// Remove by object</span></span><br><span class="line">    Pet p = pets.get(<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;4: &quot;</span> +  p + <span class="string">&quot; &quot;</span> + pets.indexOf(p));</span><br><span class="line">    Pet cymric = <span class="keyword">new</span> Cymric();</span><br><span class="line">    System.out.println(<span class="string">&quot;5: &quot;</span> + pets.indexOf(cymric));</span><br><span class="line">    System.out.println(<span class="string">&quot;6: &quot;</span> + pets.remove(cymric));</span><br><span class="line">    <span class="comment">// Must be the exact object:</span></span><br><span class="line">    System.out.println(<span class="string">&quot;7: &quot;</span> + pets.remove(p));</span><br><span class="line">    System.out.println(<span class="string">&quot;8: &quot;</span> + pets);</span><br><span class="line">    pets.add(<span class="number">3</span>, <span class="keyword">new</span> Mouse()); <span class="comment">// Insert at an index</span></span><br><span class="line">    System.out.println(<span class="string">&quot;9: &quot;</span> + pets);</span><br><span class="line">    List&lt;Pet&gt; sub = pets.subList(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;subList: &quot;</span> + sub);</span><br><span class="line">    System.out.println(<span class="string">&quot;10: &quot;</span> + pets.containsAll(sub));</span><br><span class="line">    Collections.sort(sub); <span class="comment">// In-place sort</span></span><br><span class="line">    System.out.println(<span class="string">&quot;sorted subList: &quot;</span> + sub);</span><br><span class="line">    <span class="comment">// Order is not important in containsAll():</span></span><br><span class="line">    System.out.println(<span class="string">&quot;11: &quot;</span> + pets.containsAll(sub));</span><br><span class="line">    Collections.shuffle(sub, rand); <span class="comment">// Mix it up</span></span><br><span class="line">    System.out.println(<span class="string">&quot;shuffled subList: &quot;</span> + sub);</span><br><span class="line">    System.out.println(<span class="string">&quot;12: &quot;</span> + pets.containsAll(sub));</span><br><span class="line">    List&lt;Pet&gt; copy = <span class="keyword">new</span> ArrayList&lt;&gt;(pets);</span><br><span class="line">    sub = Arrays.asList(pets.get(<span class="number">1</span>), pets.get(<span class="number">4</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;sub: &quot;</span> + sub);</span><br><span class="line">    copy.retainAll(sub);</span><br><span class="line">    System.out.println(<span class="string">&quot;13: &quot;</span> + copy);</span><br><span class="line">    copy = <span class="keyword">new</span> ArrayList&lt;&gt;(pets); <span class="comment">// Get a fresh copy</span></span><br><span class="line">    copy.remove(<span class="number">2</span>); <span class="comment">// Remove by index</span></span><br><span class="line">    System.out.println(<span class="string">&quot;14: &quot;</span> + copy);</span><br><span class="line">    copy.removeAll(sub); <span class="comment">// Only removes exact objects</span></span><br><span class="line">    System.out.println(<span class="string">&quot;15: &quot;</span> + copy);</span><br><span class="line">    copy.set(<span class="number">1</span>, <span class="keyword">new</span> Mouse()); <span class="comment">// Replace an element</span></span><br><span class="line">    System.out.println(<span class="string">&quot;16: &quot;</span> + copy);</span><br><span class="line">    copy.addAll(<span class="number">2</span>, sub); <span class="comment">// Insert a list in the middle</span></span><br><span class="line">    System.out.println(<span class="string">&quot;17: &quot;</span> + copy);</span><br><span class="line">    System.out.println(<span class="string">&quot;18: &quot;</span> + pets.isEmpty());</span><br><span class="line">    pets.clear(); <span class="comment">// Remove all elements</span></span><br><span class="line">    System.out.println(<span class="string">&quot;19: &quot;</span> + pets);</span><br><span class="line">    System.out.println(<span class="string">&quot;20: &quot;</span> + pets.isEmpty());</span><br><span class="line">    pets.addAll(Pets.list(<span class="number">4</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;21: &quot;</span> + pets);</span><br><span class="line">    Object[] o = pets.toArray();</span><br><span class="line">    System.out.println(<span class="string">&quot;22: &quot;</span> + o[<span class="number">3</span>]);</span><br><span class="line">    Pet[] pa = pets.toArray(<span class="keyword">new</span> Pet[<span class="number">0</span>]);</span><br><span class="line">    System.out.println(<span class="string">&quot;23: &quot;</span> + pa[<span class="number">3</span>].id());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">1: [Rat, Manx, Cymric, Mutt, Pug, Cymric, Pug]</span></span><br><span class="line"><span class="comment">2: [Rat, Manx, Cymric, Mutt, Pug, Cymric, Pug, Hamster]</span></span><br><span class="line"><span class="comment">3: true</span></span><br><span class="line"><span class="comment">4: Cymric 2</span></span><br><span class="line"><span class="comment">5: -1</span></span><br><span class="line"><span class="comment">6: false</span></span><br><span class="line"><span class="comment">7: true</span></span><br><span class="line"><span class="comment">8: [Rat, Manx, Mutt, Pug, Cymric, Pug]</span></span><br><span class="line"><span class="comment">9: [Rat, Manx, Mutt, Mouse, Pug, Cymric, Pug]</span></span><br><span class="line"><span class="comment">subList: [Manx, Mutt, Mouse]</span></span><br><span class="line"><span class="comment">10: true</span></span><br><span class="line"><span class="comment">sorted subList: [Manx, Mouse, Mutt]</span></span><br><span class="line"><span class="comment">11: true</span></span><br><span class="line"><span class="comment">shuffled subList: [Mouse, Manx, Mutt]</span></span><br><span class="line"><span class="comment">12: true</span></span><br><span class="line"><span class="comment">sub: [Mouse, Pug]</span></span><br><span class="line"><span class="comment">13: [Mouse, Pug]</span></span><br><span class="line"><span class="comment">14: [Rat, Mouse, Mutt, Pug, Cymric, Pug]</span></span><br><span class="line"><span class="comment">15: [Rat, Mutt, Cymric, Pug]</span></span><br><span class="line"><span class="comment">16: [Rat, Mouse, Cymric, Pug]</span></span><br><span class="line"><span class="comment">17: [Rat, Mouse, Mouse, Pug, Cymric, Pug]</span></span><br><span class="line"><span class="comment">18: false</span></span><br><span class="line"><span class="comment">19: []</span></span><br><span class="line"><span class="comment">20: true</span></span><br><span class="line"><span class="comment">21: [Manx, Cymric, Rat, EgyptianMau]</span></span><br><span class="line"><span class="comment">22: EgyptianMau</span></span><br><span class="line"><span class="comment">23: 14</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>打印行都编了号，因此可从输出追溯到源代码。 第 1 行输出展示了原始的由 <strong>Pet</strong> 组成的 <strong>List</strong> 。 与数组不同， <strong>List</strong> 可以在创建后添加或删除元素，并自行调整大小。这正是它的重要价值：一种可修改的序列。在第 2 行输出中可以看到添加一个 <strong>Hamster</strong> 的结果，该对象将被追加到列表的末尾。</p><p>可以使用 <code>contains()</code> 方法确定对象是否在列表中。如果要删除一个对象，可以将该对象的引用传递给 <code>remove()</code> 方法。同样，如果有一个对象的引用，可以使用 <code>indexOf()</code> 在 <strong>List</strong> 中找到该对象所在位置的下标号，如第 4 行输出所示中所示。</p><p>当确定元素是否是属于某个 <strong>List</strong> ，寻找某个元素的索引，以及通过引用从 <strong>List</strong> 中删除元素时，都会用到 <code>equals()</code> 方法（根类 <strong>Object</strong> 的一个方法）。每个 <strong>Pet</strong> 被定义为一个唯一的对象，所以即使列表中已经有两个 <strong>Cymrics</strong> ，如果再创建一个新的 <strong>Cymric</strong> 对象并将其传递给 <code>indexOf()</code> 方法，结果仍为 <strong>-1</strong> （表示未找到），并且尝试调用 <code>remove()</code> 方法来删除这个对象将返回 <strong>false</strong> 。对于其他类， <code>equals()</code> 的定义可能有所不同。例如，如果两个 <strong>String</strong> 的内容相同，则这两个 <strong>String</strong> 相等。因此，为了防止出现意外，请务必注意 <strong>List</strong> 行为会根据 <code>equals()</code> 行为而发生变化。</p><p>第 7、8 行输出展示了删除与 <strong>List</strong> 中的对象完全匹配的对象是成功的。</p><p>可以在 <strong>List</strong> 的中间插入一个元素，就像在第 9 行输出和它之前的代码那样。但这会带来一个问题：对于 <strong>LinkedList</strong> ，在列表中间插入和删除都是廉价操作（在本例中，除了对列表中间进行的真正的随机访问），但对于 <strong>ArrayList</strong> ，这可是代价高昂的操作。这是否意味着永远不应该在 <strong>ArrayList</strong> 的中间插入元素，并最好是转换为 <strong>LinkedList</strong> ？不，它只是意味着你应该意识到这个问题，如果你开始在某个 <strong>ArrayList</strong> 中间执行很多插入操作，并且程序开始变慢，那么你应该看看你的 <strong>List</strong> 实现有可能就是罪魁祸首（发现此类瓶颈的最佳方式是使用分析器 profiler）。优化是一个很棘手的问题，最好的策略就是置之不顾，直到发现必须要去担心它了（尽管去理解这些问题总是一个很好的主意）。</p><p><code>subList()</code> 方法可以轻松地从更大的列表中创建切片，当将切片结果传递给原来这个较大的列表的 <code>containsAll()</code> 方法时，很自然地会得到 <strong>true</strong>。请注意，顺序并不重要，在第 11、12 行输出中可以看到，在 <strong>sub</strong> 上调用直观命名的 <code>Collections.sort()</code> 和 <code>Collections.shuffle()</code> 方法，不会影响 <code>containsAll()</code> 的结果。 <code>subList()</code> 所产生的列表的幕后支持就是原始列表。因此，对所返回列表的更改都将会反映在原始列表中，反之亦然。</p><p><code>retainAll()</code> 方法实际上是一个“集合交集”操作，在本例中，它保留了同时在 <strong>copy</strong> 和 <strong>sub</strong> 中的所有元素。请再次注意，所产生的结果行为依赖于 <code>equals()</code> 方法。</p><p>第 14 行输出展示了使用索引号来删除元素的结果，与通过对象引用来删除元素相比，它显得更加直观，因为在使用索引时，不必担心 <code>equals()</code> 的行为。</p><p><code>removeAll()</code> 方法也是基于 <code>equals()</code> 方法运行的。 顾名思义，它会从 <strong>List</strong> 中删除在参数 <strong>List</strong> 中的所有元素。</p><p><code>set()</code> 方法的命名显得很不合时宜，因为它与 <strong>Set</strong> 类存在潜在的冲突。在这里使用“replace”可能更适合，因为它的功能是用第二个参数替换索引处的元素（第一个参数）。</p><p>第 17 行输出表明，对于 <strong>List</strong> ，有一个重载的 <code>addAll()</code> 方法可以将新列表插入到原始列表的中间位置，而不是仅能用 <strong>Collection</strong> 的 <code>addAll()</code> 方法将其追加到列表的末尾。</p><p>第 18 - 20 行输出展示了 <code>isEmpty()</code> 和 <code>clear()</code> 方法的效果。</p><p>第 22、23 行输出展示了如何使用 <code>toArray()</code> 方法将任意的 <strong>Collection</strong> 转换为数组。这是一个重载方法，其无参版本返回一个 <strong>Object</strong> 数组，但是如果将目标类型的数组传递给这个重载版本，那么它会生成一个指定类型的数组（假设它通过了类型检查）。如果参数数组太小而无法容纳 <strong>List</strong> 中的所有元素（就像本例一样），则 <code>toArray()</code> 会创建一个具有合适尺寸的新数组。 <strong>Pet</strong> 对象有一个 <code>id()</code> 方法，可以在所产生的数组中的对象上调用这个方法。</p><h2 id="迭代器Iterators"><a class="header-anchor" href="#迭代器Iterators"></a>迭代器Iterators</h2><p>在任何集合中，都必须有某种方式可以插入元素并再次获取它们。毕竟，保存事物是集合最基本的工作。对于 <strong>List</strong> ， <code>add()</code> 是插入元素的一种方式， <code>get()</code> 是获取元素的一种方式。</p><p>如果从更高层次的角度考虑，会发现这里有个缺点：要使用集合，必须对集合的确切类型编程。这一开始可能看起来不是很糟糕，但是考虑下面的情况：如果原本是对 <strong>List</strong> 编码的，但是后来发现如果能够将相同的代码应用于 <strong>Set</strong> 会更方便，此时应该怎么做？或者假设想从一开始就编写一段通用代码，它不知道或不关心它正在使用什么类型的集合，因此它可以用于不同类型的集合，那么如何才能不重写代码就可以应用于不同类型的集合？</p><p>迭代器（也是一种设计模式）的概念实现了这种抽象。迭代器是一个对象，它在一个序列中移动并选择该序列中的每个对象，而客户端程序员不知道或不关心该序列的底层结构。另外，迭代器通常被称为轻量级对象（lightweight object）：创建它的代价小。因此，经常可以看到一些对迭代器有些奇怪的约束。例如，Java 的 <strong>Iterator</strong> 只能单向移动。这个 <strong>Iterator</strong> 只能用来：</p><ol><li>使用 <code>iterator()</code> 方法要求集合返回一个 <strong>Iterator</strong>。 <strong>Iterator</strong> 将准备好返回序列中的第一个元素。</li><li>使用 <code>next()</code> 方法获得序列中的下一个元素。</li><li>使用 <code>hasNext()</code> 方法检查序列中是否还有元素。</li><li>使用 <code>remove()</code> 方法将迭代器最近返回的那个元素删除。</li></ol><p>为了观察它的工作方式，这里再次使用 <strong>Pet</strong> 工具：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/SimpleIteration.java</span></span><br><span class="line"><span class="keyword">import</span> typeinfo.pets.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleIteration</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Pet&gt; pets = Pets.list(<span class="number">12</span>);</span><br><span class="line">    Iterator&lt;Pet&gt; it = pets.iterator();</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">      Pet p = it.next();</span><br><span class="line">      System.out.print(p.id() + <span class="string">&quot;:&quot;</span> + p + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="comment">// A simpler approach, when possible:</span></span><br><span class="line">    <span class="keyword">for</span>(Pet p : pets)</span><br><span class="line">      System.out.print(p.id() + <span class="string">&quot;:&quot;</span> + p + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="comment">// An Iterator can also remove elements:</span></span><br><span class="line">    it = pets.iterator();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">      it.next();</span><br><span class="line">      it.remove();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(pets);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 8:Cymric 9:Rat 10:EgyptianMau 11:Hamster</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 8:Cymric 9:Rat 10:EgyptianMau 11:Hamster</span></span><br><span class="line"><span class="comment">[Pug, Manx, Cymric, Rat, EgyptianMau, Hamster]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>有了 <strong>Iterator</strong> ，就不必再为集合中元素的数量操心了。这是由 <code>hasNext()</code> 和 <code>next()</code> 关心的事情。</p><p>如果只是想向前遍历 <strong>List</strong> ，并不打算修改 <strong>List</strong> 对象本身，那么使用 for-in 语法更加简洁。</p><p><strong>Iterator</strong> 还可以删除由 <code>next()</code> 生成的最后一个元素，这意味着在调用 <code>remove()</code> 之前必须先调用 <code>next()</code> 。[^4]</p><p>在集合中的每个对象上执行操作，这种思想十分强大，并且贯穿于本书。</p><p>现在考虑创建一个 <code>display()</code> 方法，它不必知晓集合的确切类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/CrossCollectionIteration.java</span></span><br><span class="line"><span class="keyword">import</span> typeinfo.pets.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CrossCollectionIteration</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(Iterator&lt;Pet&gt; it)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">      Pet p = it.next();</span><br><span class="line">      System.out.print(p.id() + <span class="string">&quot;:&quot;</span> + p + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Pet&gt; pets = Pets.list(<span class="number">8</span>);</span><br><span class="line">    LinkedList&lt;Pet&gt; petsLL = <span class="keyword">new</span> LinkedList&lt;&gt;(pets);</span><br><span class="line">    HashSet&lt;Pet&gt; petsHS = <span class="keyword">new</span> HashSet&lt;&gt;(pets);</span><br><span class="line">    TreeSet&lt;Pet&gt; petsTS = <span class="keyword">new</span> TreeSet&lt;&gt;(pets);</span><br><span class="line">    display(pets.iterator());</span><br><span class="line">    display(petsLL.iterator());</span><br><span class="line">    display(petsHS.iterator());</span><br><span class="line">    display(petsTS.iterator());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx</span></span><br><span class="line"><span class="comment">5:Cymric 2:Cymric 7:Manx 1:Manx 3:Mutt 6:Pug 4:Pug 0:Rat</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>display()</code> 方法不包含任何有关它所遍历的序列的类型信息。这也展示了 <strong>Iterator</strong> 的真正威力：能够将遍历序列的操作与该序列的底层结构分离。出于这个原因，我们有时会说：迭代器统一了对集合的访问方式。</p><p>我们可以使用 <strong>Iterable</strong> 接口生成上一个示例的更简洁版本，该接口描述了“可以产生 <strong>Iterator</strong> 的任何东西”：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/CrossCollectionIteration2.java</span></span><br><span class="line"><span class="keyword">import</span> typeinfo.pets.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CrossCollectionIteration2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(Iterable&lt;Pet&gt; ip)</span> </span>&#123;</span><br><span class="line">    Iterator&lt;Pet&gt; it = ip.iterator();</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">      Pet p = it.next();</span><br><span class="line">      System.out.print(p.id() + <span class="string">&quot;:&quot;</span> + p + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Pet&gt; pets = Pets.list(<span class="number">8</span>);</span><br><span class="line">    LinkedList&lt;Pet&gt; petsLL = <span class="keyword">new</span> LinkedList&lt;&gt;(pets);</span><br><span class="line">    HashSet&lt;Pet&gt; petsHS = <span class="keyword">new</span> HashSet&lt;&gt;(pets);</span><br><span class="line">    TreeSet&lt;Pet&gt; petsTS = <span class="keyword">new</span> TreeSet&lt;&gt;(pets);</span><br><span class="line">    display(pets);</span><br><span class="line">    display(petsLL);</span><br><span class="line">    display(petsHS);</span><br><span class="line">    display(petsTS);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx </span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx </span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx </span></span><br><span class="line"><span class="comment">5:Cymric 2:Cymric 7:Manx 1:Manx 3:Mutt 6:Pug 4:Pug 0:Rat </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这里所有的类都是 <strong>Iterable</strong> ，所以现在对 <code>display()</code> 的调用显然更简单。</p><h2 id="ListIterator"><a class="header-anchor" href="#ListIterator"></a>ListIterator</h2><p><strong>ListIterator</strong> 是一个更强大的 <strong>Iterator</strong> 子类型，它只能由各种 <strong>List</strong> 类生成。 <strong>Iterator</strong> 只能向前移动，而 <strong>ListIterator</strong> 可以双向移动。它可以生成迭代器在列表中指向位置的后一个和前一个元素的索引，并且可以使用 <code>set()</code> 方法替换它访问过的最近一个元素。可以通过调用 <code>listIterator()</code> 方法来生成指向 <strong>List</strong> 开头处的 <strong>ListIterator</strong> ，还可以通过调用 <code>listIterator(n)</code> 创建一个一开始就指向列表索引号为 <strong>n</strong> 的元素处的 <strong>ListIterator</strong> 。 下面的示例演示了所有这些能力：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/ListIteration.java</span></span><br><span class="line"><span class="keyword">import</span> typeinfo.pets.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListIteration</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Pet&gt; pets = Pets.list(<span class="number">8</span>);</span><br><span class="line">    ListIterator&lt;Pet&gt; it = pets.listIterator();</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext())</span><br><span class="line">      System.out.print(it.next() +</span><br><span class="line">        <span class="string">&quot;, &quot;</span> + it.nextIndex() +</span><br><span class="line">        <span class="string">&quot;, &quot;</span> + it.previousIndex() + <span class="string">&quot;; &quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="comment">// Backwards:</span></span><br><span class="line">    <span class="keyword">while</span>(it.hasPrevious())</span><br><span class="line">      System.out.print(it.previous().id() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">    System.out.println(pets);</span><br><span class="line">    it = pets.listIterator(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">      it.next();</span><br><span class="line">      it.set(Pets.get());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(pets);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Rat, 1, 0; Manx, 2, 1; Cymric, 3, 2; Mutt, 4, 3; Pug, 5, 4; Cymric, 6, 5; Pug, 7, 6; Manx, 8, 7; </span></span><br><span class="line"><span class="comment">7 6 5 4 3 2 1 0 </span></span><br><span class="line"><span class="comment">[Rat, Manx, Cymric, Mutt, Pug, Cymric, Pug, Manx]</span></span><br><span class="line"><span class="comment">[Rat, Manx, Cymric, Cymric, Rat, EgyptianMau, Hamster, EgyptianMau]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>Pets.get()</code> 方法用来从位置 3 开始替换 <strong>List</strong> 中的所有 Pet 对象。</p><h2 id="链表LinkedList"><a class="header-anchor" href="#链表LinkedList"></a>链表LinkedList</h2><p><strong>LinkedList</strong> 也像 <strong>ArrayList</strong> 一样实现了基本的 <strong>List</strong> 接口，但它在 <strong>List</strong> 中间执行插入和删除操作时比 <strong>ArrayList</strong> 更高效。然而,它在随机访问操作效率方面却要逊色一些。</p><p><strong>LinkedList 还添加了一些方法，使其可以被用作栈、队列或双端队列（deque）</strong> 。在这些方法中，有些彼此之间可能只是名称有些差异，或者只存在些许差异，以使得这些名字在特定用法的上下文环境中更加适用（特别是在 <strong>Queue</strong> 中）。例如：</p><ul><li><code>getFirst()</code> 和 <code>element()</code> 是相同的，它们都返回列表的头部（第一个元素）而并不删除它，如果 <strong>List</strong> 为空，则抛出 <strong>NoSuchElementException</strong> 异常。 <code>peek()</code> 方法与这两个方法只是稍有差异，它在列表为空时返回 <strong>null</strong> 。</li><li><code>removeFirst()</code> 和 <code>remove()</code> 也是相同的，它们删除并返回列表的头部元素，并在列表为空时抛出 <strong>NoSuchElementException</strong> 异常。 <code>poll()</code> 稍有差异，它在列表为空时返回 <strong>null</strong> 。</li><li><code>addFirst()</code> 在列表的开头插入一个元素。</li><li><code>offer()</code> 与 <code>add()</code> 和 <code>addLast()</code> 相同。 它们都在列表的尾部（末尾）添加一个元素。</li><li><code>removeLast()</code> 删除并返回列表的最后一个元素。</li></ul><p>下面的示例展示了这些功能之间基本的相似性和差异性。它并不是重复执行 <strong>ListFeatures.java</strong> 中所示的行为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/LinkedListFeatures.java</span></span><br><span class="line"><span class="keyword">import</span> typeinfo.pets.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListFeatures</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Pet&gt; pets = <span class="keyword">new</span> LinkedList&lt;&gt;(Pets.list(<span class="number">5</span>));</span><br><span class="line">        System.out.println(pets);</span><br><span class="line">        <span class="comment">// Identical:</span></span><br><span class="line">        System.out.println(<span class="string">&quot;pets.getFirst(): &quot;</span> + pets.getFirst());</span><br><span class="line">        System.out.println(<span class="string">&quot;pets.element(): &quot;</span> + pets.element());</span><br><span class="line">        <span class="comment">// Only differs in empty-list behavior:</span></span><br><span class="line">        System.out.println(<span class="string">&quot;pets.peek(): &quot;</span> + pets.peek());</span><br><span class="line">        <span class="comment">// Identical; remove and return the first element:</span></span><br><span class="line">        System.out.println(<span class="string">&quot;pets.remove(): &quot;</span> + pets.remove());</span><br><span class="line">        System.out.println(<span class="string">&quot;pets.removeFirst(): &quot;</span> + pets.removeFirst());</span><br><span class="line">        <span class="comment">// Only differs in empty-list behavior:</span></span><br><span class="line">        System.out.println(<span class="string">&quot;pets.poll(): &quot;</span> + pets.poll());</span><br><span class="line">        System.out.println(pets);</span><br><span class="line">        pets.addFirst(<span class="keyword">new</span> Rat());</span><br><span class="line">        System.out.println(<span class="string">&quot;After addFirst(): &quot;</span> + pets);</span><br><span class="line">        pets.offer(Pets.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;After offer(): &quot;</span> + pets);</span><br><span class="line">        pets.add(Pets.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;After add(): &quot;</span> + pets);</span><br><span class="line">        pets.addLast(<span class="keyword">new</span> Hamster());</span><br><span class="line">        System.out.println(<span class="string">&quot;After addLast(): &quot;</span> + pets);</span><br><span class="line">        System.out.println(<span class="string">&quot;pets.removeLast(): &quot;</span> + pets.removeLast());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[Rat, Manx, Cymric, Mutt, Pug]</span></span><br><span class="line"><span class="comment">pets.getFirst(): Rat</span></span><br><span class="line"><span class="comment">pets.element(): Rat</span></span><br><span class="line"><span class="comment">pets.peek(): Rat</span></span><br><span class="line"><span class="comment">pets.remove(): Rat</span></span><br><span class="line"><span class="comment">pets.removeFirst(): Manx</span></span><br><span class="line"><span class="comment">pets.poll(): Cymric</span></span><br><span class="line"><span class="comment">[Mutt, Pug]</span></span><br><span class="line"><span class="comment">After addFirst(): [Rat, Mutt, Pug]</span></span><br><span class="line"><span class="comment">After offer(): [Rat, Mutt, Pug, Cymric]</span></span><br><span class="line"><span class="comment">After add(): [Rat, Mutt, Pug, Cymric, Pug]</span></span><br><span class="line"><span class="comment">After addLast(): [Rat, Mutt, Pug, Cymric, Pug, Hamster]</span></span><br><span class="line"><span class="comment">pets.removeLast(): Hamster</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>Pets.list()</code> 的结果被传递给 <strong>LinkedList</strong> 的构造器，以便使用它来填充 <strong>LinkedList</strong> 。如果查看 <strong>Queue</strong> 接口就会发现，它在 <strong>LinkedList</strong> 的基础上添加了 <code>element()</code> ， <code>offer()</code> ， <code>peek()</code> ， <code>poll()</code> 和 <code>remove()</code> 方法，以使其可以成为一个 <strong>Queue</strong> 的实现。</p><h2 id="堆栈Stack"><a class="header-anchor" href="#堆栈Stack"></a>堆栈Stack</h2><p>堆栈是“后进先出”（LIFO）集合。它有时被称为叠加栈（pushdown stack），因为最后“压入”（push）栈的元素，第一个被“弹出”（pop）栈。经常用来类比栈的事物是带有弹簧支架的自助餐厅托盘。最后装入的托盘总是最先拿出来使用的。</p><p>Java 1.0 中附带了一个 <strong>Stack</strong> 类，结果设计得很糟糕（为了向后兼容，我们永远坚持 Java 中的旧设计错误）。Java 6 添加了 <strong>ArrayDeque</strong> ，其中包含直接实现堆栈功能的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/StackTest.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Deque&lt;String&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : <span class="string">&quot;My dog has fleas&quot;</span>.split(<span class="string">&quot; &quot;</span>)) &#123;</span><br><span class="line">            stack.push(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            System.out.print(stack.pop() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">fleas has dog My</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>即使它是作为一个堆栈在使用，我们仍然必须将其声明为 <strong>Deque</strong> 。有时一个名为 <strong>Stack</strong> 的类更能把事情讲清楚：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/Stack.java</span></span><br><span class="line"><span class="comment">// A Stack class built with an ArrayDeque</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Deque&lt;T&gt; storage = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T v)</span> </span>&#123; storage.push(v); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">peek</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> storage.peek(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> storage.pop(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> storage.isEmpty(); &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> storage.toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里引入了使用泛型的类定义的最简单的可能示例。类名称后面的 告诉编译器这是一个参数化类型，而其中的类型参数 <strong>T</strong> 会在使用类时被实际类型替换。基本上，这个类是在声明“我们在定义一个可以持有 <strong>T</strong> 类型对象的 <strong>Stack</strong> 。” <strong>Stack</strong> 是使用 <strong>ArrayDeque</strong> 实现的，而 <strong>ArrayDeque</strong> 也被告知它将持有 <strong>T</strong> 类型对象。注意， <code>push()</code> 接受类型为 <strong>T</strong> 的对象，而 <code>peek()</code> 和 <code>pop()</code> 返回类型为 <strong>T</strong> 的对象。 <code>peek()</code> 方法将返回栈顶元素，但并不将其从栈顶删除，而 <code>pop()</code> 删除并返回顶部元素。</p><p>如果只需要栈的行为，那么使用继承是不合适的，因为这将产生一个具有 <strong>ArrayDeque</strong> 的其它所有方法的类（<strong>Java 1.0</strong> 设计者在创建 <strong>java.util.Stack</strong> 时，就犯了这个错误）。使用组合，可以选择要公开的方法以及如何命名它们。</p><p>下面将使用 <strong>StackTest.java</strong> 中的相同代码来演示这个新的 <strong>Stack</strong> 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/StackTest2.java</span></span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : <span class="string">&quot;My dog has fleas&quot;</span>.split(<span class="string">&quot; &quot;</span>)) &#123;</span><br><span class="line">            stack.push(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            System.out.print(stack.pop() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">fleas has dog My</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>如果想在自己的代码中使用这个 <strong>Stack</strong> 类，当在创建其实例时，就需要完整指定包名，或者更改这个类的名称；否则，就有可能会与 <strong>java.util</strong> 包中的 <strong>Stack</strong> 发生冲突。例如，如果我们在上面的例子中导入 <strong>java.util.</strong>*，那么就必须使用包名来防止冲突：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/StackCollision.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackCollision</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    onjava.Stack&lt;String&gt; stack = <span class="keyword">new</span> onjava.Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(String s : <span class="string">&quot;My dog has fleas&quot;</span>.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">      stack.push(s);</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())</span><br><span class="line">      System.out.print(stack.pop() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">    java.util.Stack&lt;String&gt; stack2 =</span><br><span class="line">      <span class="keyword">new</span> java.util.Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(String s : <span class="string">&quot;My dog has fleas&quot;</span>.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">      stack2.push(s);</span><br><span class="line">    <span class="keyword">while</span>(!stack2.empty())</span><br><span class="line">      System.out.print(stack2.pop() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">fleas has dog My</span></span><br><span class="line"><span class="comment">fleas has dog My</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>尽管已经有了 <strong>java.util.Stack</strong> ，但是 <strong>ArrayDeque</strong> 可以产生更好的 <strong>Stack</strong> ，因此更可取。</p><p>还可以使用显式导入来控制对“首选” <strong>Stack</strong> 实现的选择：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> onjava.Stack;</span><br></pre></td></tr></table></figure><p>现在,任何对 <strong>Stack</strong> 的引用都将选择 <strong>onjava</strong> 版本，而在选择 <strong>java.util.Stack</strong> 时，必须使用全限定名称（full qualification）。</p><h2 id="集合Set"><a class="header-anchor" href="#集合Set"></a>集合Set</h2><p><strong>Set</strong> 不保存重复的元素。 如果试图将相同对象的多个实例添加到 <strong>Set</strong> 中，那么它会阻止这种重复行为。 <strong>Set</strong> 最常见的用途是测试归属性，可以很轻松地询问某个对象是否在一个 <strong>Set</strong> 中。因此，查找通常是 <strong>Set</strong> 最重要的操作，因此通常会选择 <strong>HashSet</strong> 实现，该实现针对快速查找进行了优化。</p><p><strong>Set</strong> 具有与 <strong>Collection</strong> 相同的接口，因此没有任何额外的功能，不像前面两种不同类型的 <strong>List</strong> 那样。实际上， <strong>Set</strong> 就是一个 <strong>Collection</strong> ，只是行为不同。（这是继承和多态思想的典型应用：表现不同的行为。）<strong>Set</strong> 根据对象的“值”确定归属性。</p><p>下面是使用存放 <strong>Integer</strong> 对象的 <strong>HashSet</strong> 的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/SetOfInteger.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SetOfInteger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">        Set&lt;Integer&gt; intset = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            intset.add(rand.nextInt(<span class="number">30</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(intset);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,</span></span><br><span class="line"><span class="comment">16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在 0 到 29 之间的 10000 个随机整数被添加到 <strong>Set</strong> 中，因此可以想象每个值都重复了很多次。但是从结果中可以看到，每一个数只有一个实例出现在结果中。</p><p>早期 Java 版本中的 <strong>HashSet</strong> 产生的输出没有可辨别的顺序。这是因为出于对速度的追求， <strong>HashSet</strong> 使用了散列。由 <strong>HashSet</strong> 维护的顺序与 <strong>TreeSet</strong> 或 <strong>LinkedHashSet</strong> 不同，因为它们的实现具有不同的元素存储方式。 <strong>TreeSet</strong> 将元素存储在红-黑树数据结构中，而 <strong>HashSet</strong> 使用散列函数。 <strong>LinkedHashSet</strong> 因为查询速度的原因也使用了散列，但是看起来使用了链表来维护元素的插入顺序。看起来散列算法好像已经改变了，现在 <strong>Integer</strong> 按顺序排序。但是，您不应该依赖此行为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/SetOfString.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SetOfString</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; colors = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">      colors.add(<span class="string">&quot;Yellow&quot;</span>);</span><br><span class="line">      colors.add(<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line">      colors.add(<span class="string">&quot;Red&quot;</span>);</span><br><span class="line">      colors.add(<span class="string">&quot;Red&quot;</span>);</span><br><span class="line">      colors.add(<span class="string">&quot;Orange&quot;</span>);</span><br><span class="line">      colors.add(<span class="string">&quot;Yellow&quot;</span>);</span><br><span class="line">      colors.add(<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line">      colors.add(<span class="string">&quot;Purple&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(colors);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[Red, Yellow, Blue, Purple, Orange]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>String</strong> 对象似乎没有排序。要对结果进行排序，一种方法是使用 <strong>TreeSet</strong> 而不是 <strong>HashSet</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/SortedSetOfString.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortedSetOfString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; colors = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            colors.add(<span class="string">&quot;Yellow&quot;</span>);</span><br><span class="line">            colors.add(<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line">            colors.add(<span class="string">&quot;Red&quot;</span>);</span><br><span class="line">            colors.add(<span class="string">&quot;Red&quot;</span>);</span><br><span class="line">            colors.add(<span class="string">&quot;Orange&quot;</span>);</span><br><span class="line">            colors.add(<span class="string">&quot;Yellow&quot;</span>);</span><br><span class="line">            colors.add(<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line">            colors.add(<span class="string">&quot;Purple&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(colors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[Blue, Orange, Purple, Red, Yellow]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>最常见的操作之一是使用 <code>contains()</code> 测试成员归属性，但也有一些其它操作，这可能会让你想起在小学学过的维恩图：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/SetOperations.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SetOperations</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; set1 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Collections.addAll(set1, <span class="string">&quot;A B C D E F G H I J K L&quot;</span>.split(<span class="string">&quot; &quot;</span>));</span><br><span class="line">        set1.add(<span class="string">&quot;M&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;H: &quot;</span> + set1.contains(<span class="string">&quot;H&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;N: &quot;</span> + set1.contains(<span class="string">&quot;N&quot;</span>));</span><br><span class="line">        Set&lt;String&gt; set2 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Collections.addAll(set2, <span class="string">&quot;H I J K L&quot;</span>.split(<span class="string">&quot; &quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;set2 in set1: &quot;</span> + set1.containsAll(set2));</span><br><span class="line">        set1.remove(<span class="string">&quot;H&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;set1: &quot;</span> + set1);</span><br><span class="line">        System.out.println(<span class="string">&quot;set2 in set1: &quot;</span> + set1.containsAll(set2));</span><br><span class="line">        set1.removeAll(set2);</span><br><span class="line">        System.out.println(<span class="string">&quot;set2 removed from set1: &quot;</span> + set1);</span><br><span class="line">        Collections.addAll(set1, <span class="string">&quot;X Y Z&quot;</span>.split(<span class="string">&quot; &quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;&#x27;X Y Z&#x27; added to set1: &quot;</span> + set1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">H: true</span></span><br><span class="line"><span class="comment">N: false</span></span><br><span class="line"><span class="comment">set2 in set1: true</span></span><br><span class="line"><span class="comment">set1: [A, B, C, D, E, F, G, I, J, K, L, M]</span></span><br><span class="line"><span class="comment">set2 in set1: false</span></span><br><span class="line"><span class="comment">set2 removed from set1: [A, B, C, D, E, F, G, M]</span></span><br><span class="line"><span class="comment">&#x27;X Y Z&#x27; added to set1: [A, B, C, D, E, F, G, M, X, Y, Z]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这些方法名都是自解释的，JDK 文档中还有一些其它的方法。</p><p>能够产生每个元素都唯一的列表是相当有用的功能。例如，假设想要列出上面的 <strong>SetOperations.java</strong> 文件中的所有单词，通过使用本书后面介绍的 <code>java.nio.file.Files.readAllLines()</code> 方法，可以打开一个文件，并将其作为一个 <strong>List&lt;String&gt;</strong> 读取，每个 <strong>String</strong> 都是输入文件中的一行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/UniqueWords.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UniqueWords</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List&lt;String&gt; lines = Files.readAllLines(Paths.get(<span class="string">&quot;SetOperations.java&quot;</span>));</span><br><span class="line">        Set&lt;String&gt; words = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String line : lines) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String word : line.split(<span class="string">&quot;\\W+&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word.trim().length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    words.add(word);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(words);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[A, B, C, Collections, D, E, F, G, H, HashSet, I, J, K,</span></span><br><span class="line"><span class="comment">L, M, N, Output, Set, SetOperations, String, System, X,</span></span><br><span class="line"><span class="comment">Y, Z, add, addAll, added, args, class, collections,</span></span><br><span class="line"><span class="comment">contains, containsAll, false, from, import, in, java,</span></span><br><span class="line"><span class="comment">main, new, out, println, public, remove, removeAll,</span></span><br><span class="line"><span class="comment">removed, set1, set2, split, static, to, true, util,</span></span><br><span class="line"><span class="comment">void]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>我们逐步浏览文件中的每一行，并使用 <code>String.split()</code> 将其分解为单词，这里使用正则表达式 <strong>\\ W +</strong> ，这意味着它会依据一个或多个（即 <strong>+</strong> ）非单词字母来拆分字符串。每个结果单词都会添加到 <strong>Set words</strong> 中。因为它是 <strong>TreeSet</strong> ，所以对结果进行排序。这里，排序是按字典顺序（lexicographically）完成的，因此大写和小写字母位于不同的组中。如果想按字母顺序（alphabetically）对其进行排序，可以向 <strong>TreeSet</strong> 构造器传入 <strong>String.CASE_INSENSITIVE_ORDER</strong> 比较器（比较器是一个建立排序顺序的对象）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/UniqueWordsAlphabetic.java</span></span><br><span class="line"><span class="comment">// Producing an alphabetic listing</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UniqueWordsAlphabetic</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List&lt;String&gt; lines = Files.readAllLines(Paths.get(<span class="string">&quot;SetOperations.java&quot;</span>));</span><br><span class="line">        Set&lt;String&gt; words = <span class="keyword">new</span> TreeSet&lt;&gt;(String.CASE_INSENSITIVE_ORDER);</span><br><span class="line">        <span class="keyword">for</span> (String line : lines) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String word : line.split(<span class="string">&quot;\\W+&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word.trim().length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    words.add(word);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(words);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[A, add, addAll, added, args, B, C, class, collections,</span></span><br><span class="line"><span class="comment">contains, containsAll, D, E, F, false, from, G, H,</span></span><br><span class="line"><span class="comment">HashSet, I, import, in, J, java, K, L, M, main, N, new,</span></span><br><span class="line"><span class="comment">out, Output, println, public, remove, removeAll,</span></span><br><span class="line"><span class="comment">removed, Set, set1, set2, SetOperations, split, static,</span></span><br><span class="line"><span class="comment">String, System, to, true, util, void, X, Y, Z]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="映射Map"><a class="header-anchor" href="#映射Map"></a>映射Map</h2><p>将对象映射到其他对象的能力是解决编程问题的有效方法。例如，考虑一个程序，它被用来检查 Java 的 <strong>Random</strong> 类的随机性。理想情况下， <strong>Random</strong> 会产生完美的数字分布，但为了测试这一点，则需要生成大量的随机数，并计算落在各种范围内的数字个数。 <strong>Map</strong> 可以很容易地解决这个问题。在本例中，键是 <strong>Random</strong> 生成的数字，而值是该数字出现的次数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/Statistics.java</span></span><br><span class="line"><span class="comment">// Simple demonstration of HashMap</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Statistics</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    Map&lt;Integer, Integer&gt; m = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">      <span class="comment">// Produce a number between 0 and 20:</span></span><br><span class="line">      <span class="keyword">int</span> r = rand.nextInt(<span class="number">20</span>);</span><br><span class="line">      Integer freq = m.get(r); <span class="comment">// [1]</span></span><br><span class="line">      m.put(r, freq == <span class="keyword">null</span> ? <span class="number">1</span> : freq + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(m);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">&#123;0=481, 1=502, 2=489, 3=508, 4=481, 5=503, 6=519,</span></span><br><span class="line"><span class="comment">7=471, 8=468, 9=549, 10=513, 11=531, 12=521, 13=506,</span></span><br><span class="line"><span class="comment">14=477, 15=497, 16=533, 17=509, 18=478, 19=464&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>**[1]**自动包装机制将随机生成的 <strong>int</strong> 转换为可以与 <strong>HashMap</strong> 一起使用的 <strong>Integer</strong> 引用（不能使用基本类型的集合）。如果键不在集合中，则 <code>get()</code> 返回 <strong>null</strong> （这意味着该数字第一次出现）。否则， <code>get()</code> 会为键生成与之关联的 <strong>Integer</strong> 值，然后该值被递增（自动包装机制再次简化了表达式，但实际上确实发生了对 <strong>Integer</strong> 的装箱和拆箱）。</p><p>接下来的示例将使用一个 <strong>String</strong> 描述来查找 <strong>Pet</strong> 对象。它还展示了通过使用 <code>containsKey()</code> 和 <code>containsValue()</code> 方法去测试一个 <strong>Map</strong> ，以查看它是否包含某个键或某个值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/PetMap.java</span></span><br><span class="line"><span class="keyword">import</span> typeinfo.pets.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PetMap</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Pet&gt; petMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    petMap.put(<span class="string">&quot;My Cat&quot;</span>, <span class="keyword">new</span> Cat(<span class="string">&quot;Molly&quot;</span>));</span><br><span class="line">    petMap.put(<span class="string">&quot;My Dog&quot;</span>, <span class="keyword">new</span> Dog(<span class="string">&quot;Ginger&quot;</span>));</span><br><span class="line">    petMap.put(<span class="string">&quot;My Hamster&quot;</span>, <span class="keyword">new</span> Hamster(<span class="string">&quot;Bosco&quot;</span>));</span><br><span class="line">    System.out.println(petMap);</span><br><span class="line">    Pet dog = petMap.get(<span class="string">&quot;My Dog&quot;</span>);</span><br><span class="line">    System.out.println(dog);</span><br><span class="line">    System.out.println(petMap.containsKey(<span class="string">&quot;My Dog&quot;</span>));</span><br><span class="line">    System.out.println(petMap.containsValue(dog));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">&#123;My Dog=Dog Ginger, My Cat=Cat Molly, My Hamster=Hamster Bosco&#125;</span></span><br><span class="line"><span class="comment">Dog Ginger</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>Map</strong> 与数组和其他的 <strong>Collection</strong> 一样，可以轻松地扩展到多个维度，只需要创建一个值为 <strong>Map</strong> 的 <strong>Map</strong>（这些 <strong>Map</strong> 的值可以是其他集合，甚至是其他 <strong>Map</strong>）。因此，能够很容易地将集合组合起来以快速生成强大的数据结构。例如，假设你正在追踪有多个宠物的人，只需要一个 <strong>Map&lt;Person, List&lt;Pet&gt;&gt;</strong> 即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/MapOfList.java</span></span><br><span class="line"><span class="comment">// &#123;java collections.MapOfList&#125;</span></span><br><span class="line"><span class="keyword">package</span> collections;</span><br><span class="line"><span class="keyword">import</span> typeinfo.pets.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapOfList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Person, List&lt;? extends Pet&gt;&gt; petPeople = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        petPeople.put(<span class="keyword">new</span> Person(<span class="string">&quot;Dawn&quot;</span>),</span><br><span class="line">                Arrays.asList(</span><br><span class="line">                        <span class="keyword">new</span> Cymric(<span class="string">&quot;Molly&quot;</span>),</span><br><span class="line">                        <span class="keyword">new</span> Mutt(<span class="string">&quot;Spot&quot;</span>)));</span><br><span class="line">        petPeople.put(<span class="keyword">new</span> Person(<span class="string">&quot;Kate&quot;</span>),</span><br><span class="line">                Arrays.asList(</span><br><span class="line">                        <span class="keyword">new</span> Cat(<span class="string">&quot;Shackleton&quot;</span>),</span><br><span class="line">                        <span class="keyword">new</span> Cat(<span class="string">&quot;Elsie May&quot;</span>),</span><br><span class="line">                        <span class="keyword">new</span> Dog(<span class="string">&quot;Margrett&quot;</span>)));</span><br><span class="line">        petPeople.put(<span class="keyword">new</span> Person(<span class="string">&quot;Marilyn&quot;</span>),</span><br><span class="line">                Arrays.asList(</span><br><span class="line">                        <span class="keyword">new</span> Pug(<span class="string">&quot;Louie aka Louis Snorkelstein Dupree&quot;</span>),</span><br><span class="line">                        <span class="keyword">new</span> Cat(<span class="string">&quot;Stanford&quot;</span>),</span><br><span class="line">                        <span class="keyword">new</span> Cat(<span class="string">&quot;Pinkola&quot;</span>)));</span><br><span class="line">        petPeople.put(<span class="keyword">new</span> Person(<span class="string">&quot;Luke&quot;</span>),</span><br><span class="line">                Arrays.asList(</span><br><span class="line">                        <span class="keyword">new</span> Rat(<span class="string">&quot;Fuzzy&quot;</span>),</span><br><span class="line">                        <span class="keyword">new</span> Rat(<span class="string">&quot;Fizzy&quot;</span>)));</span><br><span class="line">        petPeople.put(<span class="keyword">new</span> Person(<span class="string">&quot;Isaac&quot;</span>),</span><br><span class="line">                Arrays.asList(<span class="keyword">new</span> Rat(<span class="string">&quot;Freckly&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;People: &quot;</span> + petPeople.keySet());</span><br><span class="line">        System.out.println(<span class="string">&quot;Pets: &quot;</span> + petPeople.values());</span><br><span class="line">        <span class="keyword">for</span> (Person person : petPeople.keySet()) &#123;</span><br><span class="line">            System.out.println(person + <span class="string">&quot; has:&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (Pet pet : petPeople.get(person)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;    &quot;</span> + pet);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">People: [Person Dawn, Person Kate, Person Isaac, Person Marilyn, Person Luke]</span></span><br><span class="line"><span class="comment">Pets: [[Cymric Molly, Mutt Spot], [Cat Shackleton, Cat Elsie May, Dog Margrett], [Rat Freckly], [Pug Louie aka Louis Snorkelstein Dupree, Cat Stanford, Cat Pinkola],[Rat Fuzzy, Rat Fizzy]]</span></span><br><span class="line"><span class="comment">Person Dawn has:</span></span><br><span class="line"><span class="comment">    Cymric Molly</span></span><br><span class="line"><span class="comment">    Mutt Spot</span></span><br><span class="line"><span class="comment">Person Kate has:</span></span><br><span class="line"><span class="comment">    Cat Shackleton</span></span><br><span class="line"><span class="comment">    Cat Elsie May</span></span><br><span class="line"><span class="comment">    Dog Margrett</span></span><br><span class="line"><span class="comment">Person Isaac has:</span></span><br><span class="line"><span class="comment">    Rat Freckly</span></span><br><span class="line"><span class="comment">Person Marilyn has:</span></span><br><span class="line"><span class="comment">    Pug Louie aka Louis Snorkelstein Dupree</span></span><br><span class="line"><span class="comment">    Cat Stanford</span></span><br><span class="line"><span class="comment">    Cat Pinkola</span></span><br><span class="line"><span class="comment">Person Luke has:</span></span><br><span class="line"><span class="comment">    Rat Fuzzy</span></span><br><span class="line"><span class="comment">    Rat Fizzy</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>Map</strong> 可以返回由其键组成的 <strong>Set</strong> ，由其值组成的 <strong>Collection</strong> ，或者其键值对的 <strong>Set</strong> 。 <code>keySet()</code> 方法生成由在 <strong>petPeople</strong> 中的所有键组成的 <strong>Set</strong> ，它在 for-in 语句中被用来遍历该 <strong>Map</strong> 。</p><h2 id="队列Queue"><a class="header-anchor" href="#队列Queue"></a>队列Queue</h2><p>队列是一个典型的“先进先出”（FIFO）集合。 即从集合的一端放入事物，再从另一端去获取它们，事物放入集合的顺序和被取出的顺序是相同的。队列通常被当做一种可靠的将对象从程序的某个区域传输到另一个区域的途径。队列在并发编程中尤为重要，因为它们可以安全地将对象从一个任务传输到另一个任务。</p><p><strong>LinkedList</strong> 实现了 <strong>Queue</strong> 接口，并且提供了一些方法以支持队列行为，因此 <strong>LinkedList</strong> 可以用作 <strong>Queue</strong> 的一种实现。 通过将 <strong>LinkedList</strong> 向上转换为 <strong>Queue</strong> ，下面的示例使用了在 <strong>Queue</strong> 接口中与 <strong>Queue</strong> 相关(Queue-specific)的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/QueueDemo.java</span></span><br><span class="line"><span class="comment">// Upcasting to a Queue from a LinkedList</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printQ</span><span class="params">(Queue queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.peek() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(queue.remove() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            queue.offer(rand.nextInt(i + <span class="number">10</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        printQ(queue);</span><br><span class="line">        Queue&lt;Character&gt; qc = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : <span class="string">&quot;Brontosaurus&quot;</span>.toCharArray()) &#123;</span><br><span class="line">            qc.offer(c);</span><br><span class="line">        &#125;</span><br><span class="line">        printQ(qc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">8 1 1 1 5 14 3 1 0 1</span></span><br><span class="line"><span class="comment">B r o n t o s a u r u s</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>offer()</code> 是与 <strong>Queue</strong> 相关的方法之一，它在允许的情况下，在队列的尾部插入一个元素，或者返回 <strong>false</strong> 。 <code>peek()</code> 和 <code>element()</code> 都返回队头元素而不删除它，但是如果队列为空，则 <code>element()</code> 抛出 <strong>NoSuchElementException</strong> ，而 <code>peek()</code> 返回 <strong>null</strong> 。 <code>poll()</code> 和 <code>remove()</code> 都删除并返回队头元素，但如果队列为空，<code>poll()</code> 返回 <strong>null</strong> ，而 <code>remove()</code> 抛出 <strong>NoSuchElementException</strong> 。</p><p>自动包装机制会自动将 <code>nextInt()</code> 的 <strong>int</strong> 结果转换为 <strong>queue</strong> 所需的 <strong>Integer</strong> 对象，并将 <strong>char c</strong> 转换为 <strong>qc</strong> 所需的 <strong>Character</strong> 对象。 <strong>Queue</strong> 接口窄化了对 <strong>LinkedList</strong> 方法的访问权限，因此只有适当的方法才能使用，因此能够访问到的 <strong>LinkedList</strong> 的方法会变少（这里实际上可以将 <strong>Queue</strong> 强制转换回 <strong>LinkedList</strong> ，但至少我们不鼓励这样做）。</p><p>TODO ：不了解自动包装机制。2020年10月13日</p><p>与 <strong>Queue</strong> 相关的方法提供了完整而独立的功能。 也就是说，对于 <strong>Queue</strong> 所继承的 <strong>Collection</strong> ，在不需要使用它的任何方法的情况下，就可以拥有一个可用的 <strong>Queue</strong> 。</p><h2 id="优先级队列PriorityQueue"><a class="header-anchor" href="#优先级队列PriorityQueue"></a>优先级队列PriorityQueue</h2><p>先进先出（FIFO）描述了最典型的队列规则（queuing discipline）。队列规则是指在给定队列中的一组元素的情况下，确定下一个弹出队列的元素的规则。先进先出声明的是下一个弹出的元素应该是等待时间最长的元素。</p><p>优先级队列声明下一个弹出的元素是最需要的元素（具有最高的优先级）。例如，在机场，当飞机临近起飞时，这架飞机的乘客可以在办理登机手续时排到队头。如果构建了一个消息传递系统，某些消息比其他消息更重要，应该尽快处理，而不管它们何时到达。在Java 5 中添加了 <strong>PriorityQueue</strong> ，以便自动实现这种行为。</p><p>当在 <strong>PriorityQueue</strong> 上调用 <code>offer()</code> 方法来插入一个对象时，该对象会在队列中被排序。默认的排序使用队列中对象的自然顺序（natural order），但是可以通过提供自己的 <strong>Comparator</strong> 来修改这个顺序。 <strong>PriorityQueue</strong> 确保在调用 <code>peek()</code> ， <code>poll()</code> 或 <code>remove()</code> 方法时，获得的元素将是队列中优先级最高的元素。</p><p>让 <strong>PriorityQueue</strong> 与 <strong>Integer</strong> ， <strong>String</strong> 和 <strong>Character</strong> 这样的内置类型一起工作易如反掌。在下面的示例中，第一组值与前一个示例中的随机值相同，可以看到它们从 <strong>PriorityQueue</strong> 中弹出的顺序与前一个示例不同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/PriorityQueueDemo.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            priorityQueue.offer(rand.nextInt(i + <span class="number">10</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        QueueDemo.printQ(priorityQueue);</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; ints = Arrays.asList(<span class="number">25</span>, <span class="number">22</span>, <span class="number">20</span>, <span class="number">18</span>, <span class="number">14</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">14</span>, <span class="number">18</span>, <span class="number">21</span>, <span class="number">23</span>, <span class="number">25</span>);</span><br><span class="line">        priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(ints);</span><br><span class="line">        QueueDemo.printQ(priorityQueue);</span><br><span class="line">        priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(ints.size(), Collections.reverseOrder());</span><br><span class="line">        priorityQueue.addAll(ints);</span><br><span class="line">        QueueDemo.printQ(priorityQueue);</span><br><span class="line"></span><br><span class="line">        String fact = <span class="string">&quot;EDUCATION SHOULD ESCHEW OBFUSCATION&quot;</span>;</span><br><span class="line">        List&lt;String&gt; strings = Arrays.asList(fact.split(<span class="string">&quot;&quot;</span>));</span><br><span class="line">        PriorityQueue&lt;String&gt; stringPQ = <span class="keyword">new</span> PriorityQueue&lt;&gt;(strings);</span><br><span class="line">        QueueDemo.printQ(stringPQ);</span><br><span class="line">        stringPQ = <span class="keyword">new</span> PriorityQueue&lt;&gt;(strings.size(), Collections.reverseOrder());</span><br><span class="line">        stringPQ.addAll(strings);</span><br><span class="line">        QueueDemo.printQ(stringPQ);</span><br><span class="line"></span><br><span class="line">        Set&lt;Character&gt; charSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : fact.toCharArray()) &#123;</span><br><span class="line">            charSet.add(c); <span class="comment">// Autoboxing</span></span><br><span class="line">        &#125;</span><br><span class="line">        PriorityQueue&lt;Character&gt; characterPQ = <span class="keyword">new</span> PriorityQueue&lt;&gt;(charSet);</span><br><span class="line">        QueueDemo.printQ(characterPQ);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">0 1 1 1 1 1 3 5 8 14 </span></span><br><span class="line"><span class="comment">1 1 2 3 3 9 9 14 14 18 18 20 21 22 23 25 25 </span></span><br><span class="line"><span class="comment">25 25 23 22 21 20 18 18 14 14 9 9 3 3 2 1 1 </span></span><br><span class="line"><span class="comment">      A A B C C C D D E E E F H H I I L N N O O O O S S S T T U U U W </span></span><br><span class="line"><span class="comment">W U U U T T S S S O O O O N N L I I H H F E E E D D C C C B A A       </span></span><br><span class="line"><span class="comment">  A B C D E F H I L N O S T U W </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>PriorityQueue</strong> 是允许重复的，最小的值具有最高的优先级（如果是 <strong>String</strong> ，空格也可以算作值，并且比字母的优先级高）。为了展示如何通过提供自己的 <strong>Comparator</strong> 对象来改变顺序，第三个对 <strong>PriorityQueue&lt;Integer&gt;</strong> 构造器的调用，和第二个对 <strong>PriorityQueue&lt;String&gt;</strong> 的调用使用了由 <code>Collections.reverseOrder()</code> （Java 5 中新添加的）产生的反序的 <strong>Comparator</strong> 。</p><p>最后一部分添加了一个 <strong>HashSet</strong> 来消除重复的 <strong>Character</strong>。</p><p><strong>Integer</strong> ， <strong>String</strong> 和 <strong>Character</strong> 可以与 <strong>PriorityQueue</strong> 一起使用，因为这些类已经内置了自然排序。如果想在 <strong>PriorityQueue</strong> 中使用自己的类，则必须包含额外的功能以产生自然排序，或者必须提供自己的 <strong>Comparator</strong> 。</p><h2 id="集合与迭代器"><a class="header-anchor" href="#集合与迭代器"></a>集合与迭代器</h2><p>TODO ：本节有许多问题不理解，需要巩固。2020年10月13日</p><p><strong>Collection</strong> 是所有序列集合共有的根接口。它可能会被认为是一种“附属接口”（incidental interface），即因为要表示其他若干个接口的共性而出现的接口。此外，<strong>java.util.AbstractCollection</strong> 类提供了 <strong>Collection</strong> 的默认实现，使得你可以创建 <strong>AbstractCollection</strong> 的子类型，而其中没有不必要的代码重复。</p><p>使用接口描述的一个理由是它可以使我们创建更通用的代码。通过针对接口而非具体实现来编写代码，我们的代码可以应用于更多类型的对象。因此，如果所编写的方法接受一个 <strong>Collection</strong> ，那么该方法可以应用于任何实现了 <strong>Collection</strong> 的类——这也就使得一个新类可以选择去实现 <strong>Collection</strong> 接口，以便该方法可以使用它。标准 C++ 类库中的集合并没有共同的基类——集合之间的所有共性都是通过迭代器实现的。在 Java 中，遵循 C++ 的方式看起来似乎很明智，即用迭代器而不是 <strong>Collection</strong> 来表示集合之间的共性。但是，这两种方法绑定在了一起，因为实现 <strong>Collection</strong> 就意味着需要提供 <code>iterator()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/InterfaceVsIterator.java</span></span><br><span class="line"><span class="keyword">import</span> typeinfo.pets.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterfaceVsIterator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(Iterator&lt;Pet&gt; it)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            Pet p = it.next();</span><br><span class="line">            System.out.print(p.id() + <span class="string">&quot;:&quot;</span> + p + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(Collection&lt;Pet&gt; pets)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Pet p : pets) &#123;</span><br><span class="line">            System.out.print(p.id() + <span class="string">&quot;:&quot;</span> + p + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Pet&gt; petList = Pets.list(<span class="number">8</span>);</span><br><span class="line">        Set&lt;Pet&gt; petSet = <span class="keyword">new</span> HashSet&lt;&gt;(petList);</span><br><span class="line">        Map&lt;String, Pet&gt; petMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        String[] names = (<span class="string">&quot;Ralph, Eric, Robin, Lacey, &quot;</span> + <span class="string">&quot;Britney, Sam, Spot, Fluffy&quot;</span>).split(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; names.length; i++) &#123;</span><br><span class="line">            petMap.put(names[i], petList.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        display(petList);</span><br><span class="line">        display(petSet);</span><br><span class="line">        display(petList.iterator());</span><br><span class="line">        display(petSet.iterator());</span><br><span class="line">        System.out.println(petMap);</span><br><span class="line">        System.out.println(petMap.keySet());</span><br><span class="line">        display(petMap.values());</span><br><span class="line">        display(petMap.values().iterator());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx </span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx </span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx </span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx </span></span><br><span class="line"><span class="comment">&#123;Ralph=Rat, Eric=Manx, Robin=Cymric, Lacey=Mutt, Britney=Pug, Sam=Cymric, Spot=Pug, Fluffy=Manx&#125;</span></span><br><span class="line"><span class="comment">[Ralph, Eric, Robin, Lacey, Britney, Sam, Spot, Fluffy]</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx </span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>两个版本的 <code>display()</code> 方法都可以使用 <strong>Map</strong> 或 <strong>Collection</strong> 的子类型来工作。 而且<strong>Collection</strong> 接口和 <strong>Iterator</strong> 都将 <code>display()</code> 方法与低层集合的特定实现解耦。</p><p>在本例中，这两种方式都可以奏效。事实上， <strong>Collection</strong> 要更方便一点，因为它是 <strong>Iterable</strong> 类型，因此在 <code>display(Collection)</code> 的实现中可以使用 for-in 构造，这使得代码更加清晰。</p><p>当需要实现一个不是 <strong>Collection</strong> 的外部类时，由于让它去实现 <strong>Collection</strong> 接口可能非常困难或麻烦，因此使用 <strong>Iterator</strong> 就会变得非常吸引人。例如，如果我们通过继承一个持有 <strong>Pet</strong> 对象的类来创建一个 <strong>Collection</strong> 的实现，那么我们必须实现 <strong>Collection</strong> 所有的方法，即使我们不在 <code>display()</code> 方法中使用它们，也必须这样做。虽然这可以通过继承 <strong>AbstractCollection</strong> 而很容易地实现，但是无论如何还是要被强制去实现 <code>iterator()</code> 和 <code>size()</code> 方法，这些方法 <strong>AbstractCollection</strong> 没有实现，但是 <strong>AbstractCollection</strong> 中的其它方法会用到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/CollectionSequence.java</span></span><br><span class="line"><span class="keyword">import</span> typeinfo.pets.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionSequence</span> <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">Pet</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Pet[] pets = Pets.array(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pets.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;Pet&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;Pet&gt;() &#123; <span class="comment">// [1]</span></span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> index &lt; pets.length;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Pet <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> pets[index++];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123; <span class="comment">// Not implemented</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CollectionSequence c = <span class="keyword">new</span> CollectionSequence();</span><br><span class="line">        InterfaceVsIterator.display(c);</span><br><span class="line">        InterfaceVsIterator.display(c.iterator());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx </span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>remove()</code> 方法是一个“可选操作”。 这里可以不必实现它，如果你调用它，它将抛出异常。</p><p><strong>[1]</strong> 你可能会认为，因为 <code>iterator()</code> 返回 <strong>Iterator&lt;Pet&gt;</strong> ，匿名内部类定义可以使用菱形语法，Java可以推断出类型。但这不起作用，类型推断仍然非常有限。</p><p>这个例子表明，如果实现了 <strong>Collection</strong> ，就必须实现 <code>iterator()</code> ，并且只拿实现 <code>iterator()</code> 与继承 <strong>AbstractCollection</strong> 相比，花费的代价只有略微减少。但是，如果类已经继承了其他的类，那么就不能再继承 <strong>AbstractCollection</strong> 了。在这种情况下，要实现 <strong>Collection</strong> ，就必须实现该接口中的所有方法。此时，继承并提供创建迭代器的能力要容易得多：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/NonCollectionSequence.java</span></span><br><span class="line"><span class="keyword">import</span> typeinfo.pets.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PetSequence</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> Pet[] pets = Pets.array(<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NonCollectionSequence</span> <span class="keyword">extends</span> <span class="title">PetSequence</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Iterator&lt;Pet&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;Pet&gt;() &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index &lt; pets.length;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Pet <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> pets[index++]; &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123; <span class="comment">// Not implemented</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    NonCollectionSequence nc =</span><br><span class="line">      <span class="keyword">new</span> NonCollectionSequence();</span><br><span class="line">    InterfaceVsIterator.display(nc.iterator());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug</span></span><br><span class="line"><span class="comment">7:Manx</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>生成 <strong>Iterator</strong> 是将序列与消费该序列的方法连接在一起耦合度最小的方式，并且与实现 <strong>Collection</strong> 相比，它在序列类上所施加的约束也少得多。</p><h2 id="for-in和迭代器"><a class="header-anchor" href="#for-in和迭代器"></a>for-in和迭代器</h2><p>到目前为止，for-in 语法主要用于数组，但它也适用于任何 <strong>Collection</strong> 对象。实际上在使用 <strong>ArrayList</strong> 时，已经看到了一些使用它的示例，下面是一个更通用的证明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/ForInCollections.java</span></span><br><span class="line"><span class="comment">// All collections work with for-in</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForInCollections</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection&lt;String&gt; cs = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Collections.addAll(cs, <span class="string">&quot;Take the long way home&quot;</span>.split(<span class="string">&quot; &quot;</span>));</span><br><span class="line">        <span class="keyword">for</span> (String s : cs) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;&#x27;&quot;</span> + s + <span class="string">&quot;&#x27; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">&#x27;Take&#x27; &#x27;the&#x27; &#x27;long&#x27; &#x27;way&#x27; &#x27;home&#x27;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>由于 <strong>cs</strong> 是一个 <strong>Collection</strong> ，因此该代码展示了使用 for-in 是所有 <strong>Collection</strong> 对象的特征。</p><p>这样做的原因是 Java 5 引入了一个名为 <strong>Iterable</strong> 的接口，该接口包含一个能够生成 <strong>Iterator</strong> 的 <code>iterator()</code> 方法。for-in 使用此 <strong>Iterable</strong> 接口来遍历序列。因此，如果创建了任何实现了 <strong>Iterable</strong> 的类，都可以将它用于 for-in 语句中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/IterableClass.java</span></span><br><span class="line"><span class="comment">// Anything Iterable works with for-in</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IterableClass</span> <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String[] words = (<span class="string">&quot;And that is how &quot;</span> +</span><br><span class="line">            <span class="string">&quot;we know the Earth to be banana-shaped.&quot;</span></span><br><span class="line">    ).split(<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;String&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;String&gt;() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> index &lt; words.length;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> words[index++];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123; <span class="comment">// Not implemented</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String s : <span class="keyword">new</span> IterableClass()) &#123;</span><br><span class="line">            System.out.print(s + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">And that is how we know the Earth to be banana-shaped.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>iterator()</code> 返回的是实现了 <strong>Iterator&lt;String&gt;</strong> 的匿名内部类的实例，该匿名内部类可以遍历数组中的每个单词。在主方法中，可以看到 <strong>IterableClass</strong> 确实可以用于 for-in 语句。</p><p>在 Java 5 中，许多类都是 <strong>Iterable</strong> ，主要包括所有的 <strong>Collection</strong> 类（但不包括各种 <strong>Maps</strong> ）。 例如，下面的代码可以显示所有的操作系统环境变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/EnvironmentVariables.java</span></span><br><span class="line"><span class="comment">// &#123;VisuallyInspectOutput&#125;</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnvironmentVariables</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Map.Entry entry: System.getenv().entrySet()) &#123;</span><br><span class="line">      System.out.println(entry.getKey() + <span class="string">&quot;: &quot;</span> +</span><br><span class="line">        entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TODO ：未学完。2020年10月13日</p><h2 id="小结"><a class="header-anchor" href="#小结"></a>小结</h2><p>Java 提供了许多保存对象的方法：</p><ol><li>数组将数字索引与对象相关联。它保存类型明确的对象，因此在查找对象时不必对结果做类型转换。它可以是多维的，可以保存基本类型的数据。虽然可以在运行时创建数组，但是一旦创建数组，就无法更改数组的大小。</li><li><strong>Collection</strong> 保存单一的元素，而 <strong>Map</strong> 包含相关联的键值对。使用 Java 泛型，可以指定集合中保存的对象的类型，因此不能将错误类型的对象放入集合中，并且在从集合中获取元素时，不必进行类型转换。各种 <strong>Collection</strong> 和各种 <strong>Map</strong> 都可以在你向其中添加更多的元素时，自动调整其尺寸大小。集合不能保存基本类型，但自动装箱机制会负责执行基本类型和集合中保存的包装类型之间的双向转换。</li><li>像数组一样， <strong>List</strong> 也将数字索引与对象相关联，因此，数组和 <strong>List</strong> 都是有序集合。</li><li>如果要执行大量的随机访问，则使用 <strong>ArrayList</strong> ，如果要经常从表中间插入或删除元素，则应该使用 <strong>LinkedList</strong> 。</li><li>队列和堆栈的行为是通过 <strong>LinkedList</strong> 提供的。</li><li><strong>Map</strong> 是一种将对象（而非数字）与对象相关联的设计。 <strong>HashMap</strong> 专为快速访问而设计，而 <strong>TreeMap</strong> 保持键始终处于排序状态，所以没有 <strong>HashMap</strong> 快。 <strong>LinkedHashMap</strong> 按插入顺序保存其元素，但使用散列提供快速访问的能力。</li><li><strong>Set</strong> 不接受重复元素。 <strong>HashSet</strong> 提供最快的查询速度，而 <strong>TreeSet</strong> 保持元素处于排序状态。 <strong>LinkedHashSet</strong> 按插入顺序保存其元素，但使用散列提供快速访问的能力。</li><li>不要在新代码中使用遗留类 <strong>Vector</strong> ，<strong>Hashtable</strong> 和 <strong>Stack</strong> 。</li></ol><p>Java 集合框架简图，黄色为接口，绿色为抽象类，蓝色为具体类。虚线箭头表示实现关系，实线箭头表示继承关系。</p><p>![collection](E:\OneDrive - lanqilu\我的图片库\blogimg\Java持有对象\collection.png)![map](E:\OneDrive - lanqilu\我的图片库\blogimg\Java持有对象\map.png)</p><h3 id="简单集合分类"><a class="header-anchor" href="#简单集合分类"></a>简单集合分类</h3><p>可以看到，实际上只有四个基本的集合组件： <strong>Map</strong> ， <strong>List</strong> ， <strong>Set</strong> 和 <strong>Queue</strong> ，它们各有两到三个实现版本（<strong>Queue</strong> 的 <strong>java.util.concurrent</strong> 实现未包含在此图中）。最常使用的集合用黑色粗线线框表示。</p><p>虚线框表示接口，实线框表示普通的（具体的）类。带有空心箭头的虚线表示特定的类实现了一个接口。实心箭头表示某个类可以生成箭头指向的类的对象。例如，任何 <strong>Collection</strong> 都可以生成 <strong>Iterator</strong> ， <strong>List</strong> 可以生成 <strong>ListIterator</strong> （也能生成普通的 <strong>Iterator</strong> ，因为 <strong>List</strong> 继承自 <strong>Collection</strong> ）。</p><p>下面的示例展示了各种不同的类在方法上的差异。程序的输出还展示了在每个类或接口中所实现的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/CollectionDifferences.java</span></span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionDifferences</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    CollectionMethodDifferences.main(args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除 <strong>TreeSet</strong> 之外的所有 <strong>Set</strong> 都具有与 <strong>Collection</strong> 完全相同的接口。<strong>List</strong> 和 <strong>Collection</strong> 存在着明显的不同，尽管 <strong>List</strong> 所要求的方法都在 <strong>Collection</strong> 中。另一方面，在 <strong>Queue</strong> 接口中的方法是独立的，在创建具有 <strong>Queue</strong> 功能的实现时，不需要使用 <strong>Collection</strong> 方法。最后， <strong>Map</strong> 和 <strong>Collection</strong> 之间唯一的交集是 <strong>Map</strong> 可以使用 <code>entrySet()</code> 和 <code>values()</code> 方法来产生 <strong>Collection</strong> 。</p><p>请注意，标记接口 <strong>java.util.RandomAccess</strong> 附加到了 <strong>ArrayList</strong> 上，但不附加到 <strong>LinkedList</strong> 上。这为根据特定 <strong>List</strong> 动态改变其行为的算法提供了信息。</p><p>从面向对象的继承层次结构来看，这种组织结构确实有些奇怪。但是，当了解了 <strong>java.util</strong> 中更多的有关集合的内容后，就会发现除了继承结构有点奇怪外，还有更多的问题。集合类库一直以来都是设计难题——解决这些问题涉及到要去满足经常彼此之间互为牵制的各方面需求。所以要做好准备，在各处做出妥协。</p><p>尽管存在这些问题，但 Java 集合仍是在日常工作中使用的基本工具，它可以使程序更简洁、更强大、更有效。你可能需要一段时间才能熟悉集合类库的某些方面，但我想你很快就会找到自己的路子，来获得和使用这个类库中的类。</p>]]></content>
      
      
      <categories>
          
          <category> Java中级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java类型系统</title>
      <link href="2020/08/08/Java-03-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/"/>
      <url>2020/08/08/Java-03-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>本文以基于类的面向对象编程为基础，介绍高效使用 Java 静态类型系统所需知道的其他概念。</p><hr><p>静态类型语言的变量类型是确定的，如果把不兼容类型的值赋给变量，会导致编译时错误。Java 是一种静态类型语言。只在运行时检查类型兼容性的语言叫作动态类型语言，JavaScript 便是一种动态类型语言。</p><p>Java 的类型系统不仅涉及类和基本类型，还涉及与类的基本概念相关的其他引用类型，但这些引用类型有些不同，javac 或 JVM 往往会使用特殊的方式处理。</p><p>我们已经介绍了数组和类，它们是使用最广泛的两种 Java 引用类型。本章先介绍另一种重要的引用类型——接口。然后介绍 Java 的泛型，泛型在 Java 的类型系统中扮演着重要角色。掌握这些知识后，我们再介绍 Java 中编译时和运行时类型之间的区别。</p><p>为了完整介绍 Java 的引用类型，我们要介绍两种特殊的类和接口——枚举和注解。本章最后介绍嵌套类型和 Java 8 引入的 lambda 表达式。</p><h2 id="接口"><a class="header-anchor" href="#接口"></a>接口</h2><p>一个 Java 类只能继承一个类。这对我们要编写的面向对象程序来说是个相当严格的限制。Java 的设计者知道这一点，但他们也是为了确保Java 实现面向对象编程的方式比其他语言（例如 C++）简单。他们选择的方式是提出接口这个概念。和类一样，接口定义一种新的引用类型。如“接口”这个名称所示，接口的作用只是描绘 API，因此，接口提供类型的描述信息，以及实现这个 API 的类应该提供的方法（和签名）。</p><p>一般来说，Java 的接口不为它描述的方法提供实现代码。这些方法是强制要实现的——想实现接口的类必须实现这些方法。</p><p>不过，接口可能想把 API 中的某些方法标记为可选，如果实现接口的类不想实现就不用实现。这种机制通过 <code>default</code> 关键字实现，接口必须为可选的方法提供默认实现，未实现这些方法的类会使用默认实现。</p><blockquote><p>接口中的可选方法是 Java 8 的新功能，之前的版本中没有。</p></blockquote><p>接口不能直接实例化，也不能创建这种接口类型的成员。接口必须通过类实现，而且类要提供所需的方法主体。这个类的实例既属于这个类定义的类型，也属于这个接口定义的类型。不属于同一个类或超类的对象，通过实现同一个接口，也能属于同一种类型。</p><h3 id="定义接口"><a class="header-anchor" href="#定义接口"></a>定义接口</h3><p>定义接口的方式和定义类差不多，不过所有（非默认的）方法都是抽象方法，而且关键字<code>class</code> 要换成 <code>interface</code>。例如，下述代码定义了一个名为 <code>Centered</code> 的接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface Centered &#123; </span><br><span class="line">  void setCenter(double x, double y); </span><br><span class="line">  double getCenterX(); </span><br><span class="line">  double getCenterY(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口的成员有些限制：</p><ul><li>接口中所有强制方法都隐式使用 <code>abstract</code> 声明，不能有方法主体，要使用分号。可以使用 <code>abstract</code> 修饰符，但一般习惯省略。</li><li>接口定义公开的 API。接口中的所有成员都隐式使用 <code>public</code> 声明，而且习惯省略不必要的 <code>public</code> 修饰符。如果在接口中使用 <code>protected</code> 或 <code>private</code> 定义方法，会导致编译时错误。</li><li>接口不能定义任何实例字段。字段是实现细节，而接口是规格不是实现。在接口中只能定义同时使用 <code>static</code> 和 <code>final</code> 声明的常量。</li><li>接口不能实例化，因此不定义构造方法。</li><li>接口中可以包含嵌套类型。嵌套类型隐式使用 <code>public</code> 和 <code>static</code> 声明。</li><li>从 Java 8 开始，接口中可以包含静态方法。</li></ul><h3 id="扩展接口"><a class="header-anchor" href="#扩展接口"></a>扩展接口</h3><p>接口可以扩展其他接口，而且和类的定义一样，接口的定义可以包含一个 <code>extends</code> 子句。接口扩展另一个接口时，会继承父接口中的所有方法和常量，而且可以定义新方法和常量。不过，和类不同的是，接口的 <code>extends</code> 子句可以包含<strong>多个</strong>父接口。例如，下述接口扩展了其他接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Positionable</span> <span class="keyword">extends</span> <span class="title">Centered</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setUpperRightCorner</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>; </span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">getUpperRightX</span><span class="params">()</span></span>; </span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">getUpperRightY</span><span class="params">()</span></span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Transformable</span> <span class="keyword">extends</span> <span class="title">Scalable</span>, <span class="title">Translatable</span>, <span class="title">Rotatable</span> </span>&#123;&#125; </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SuperShape</span> <span class="keyword">extends</span> <span class="title">Positionable</span>, <span class="title">Transformable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>扩展多个接口的接口，会继承每个父接口中的所有方法和常量，而且可以定义属于自己的方法和常量。实现这个接口的类必须实现这个接口直接定义的抽象方法，以及从所有父接口中继承的全部抽象方法。</p><h3 id="实现接口"><a class="header-anchor" href="#实现接口"></a>实现接口</h3><p>类使用 <code>extends</code> 指定超类，类似地，类使用 <code>implements</code> 列出它支持的一个或多个接口。<code>implements</code> 是一个 Java 关键字，可以出现在类声明中，但要放在 <code>extends</code> 子句后面。<code>implements</code> 关键字后面是这个类要实现的一组接口，接口之间使用逗号分隔。</p><p>类在 <code>implements</code> 子句中声明接口时，表明这个类要为接口中的每个强制方法提供实现（即主体）。如果实现接口的类没有为接口中的每个强制方法提供实现，那么这个类从接口中继承未实现的抽象方法，而且这个类本身必须使用 <code>abstract</code> 声明。如果类实现多个接口，必须实现每个接口中的所有强制方法（否则这个类要使用 <code>abstract</code> 声明）。</p><p>下述代码展示了如何定义 <code>CenteredRectangle</code> 类，这个类扩展第定义的 <code>Rectangle</code> 类，而且实现 <code>Centered</code> 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CenteredRectangle</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Centered</span> </span>&#123; </span><br><span class="line">  <span class="comment">// 新实例字段 </span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> cx, cy; </span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 构造方法 </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CenteredRectangle</span><span class="params">(<span class="keyword">double</span> cx, <span class="keyword">double</span> cy, <span class="keyword">double</span> w, <span class="keyword">double</span> h)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">super</span>(w, h); </span><br><span class="line">    <span class="keyword">this</span>.cx = cx; </span><br><span class="line">    <span class="keyword">this</span>.cy = cy; </span><br><span class="line">  &#125; </span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 继承了Rectangle类中的所有方法 </span></span><br><span class="line">  <span class="comment">// 但要为Centered接口中的所有方法提供实现 </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCenter</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123; cx = x; cy = y; &#125; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getCenterX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> cx; &#125; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getCenterY</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> cy; &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设我们按照 <code>CenteredRectangle</code> 类的实现方式实现了 <code>CenteredCircle</code> 和 <code>CenteredSquare</code>类。每个类都扩展 <code>Shape</code> 类，所以如前所示，这些类的实例都可以当成 <code>Shape</code> 类的实例。因为每个类都实现了 <code>Centered</code> 接口，所以这些实例还可以当成 <code>Centered</code> 类型的实例。下述代码演示了对象既可以作为类类型的成员，也可以作为接口类型的成员：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Shape[] shapes = <span class="keyword">new</span> Shape[<span class="number">3</span>];     <span class="comment">// 创建一个数组，保存形状对象 </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 创建一些Centered类型的形状，存储在这个Shape[]类型的数组中 </span></span><br><span class="line"><span class="comment">// 不用校正，因为都是放大转换 </span></span><br><span class="line">shapes[<span class="number">0</span>] = <span class="keyword">new</span> CenteredCircle(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>); </span><br><span class="line">shapes[<span class="number">1</span>] = <span class="keyword">new</span> CenteredSquare(<span class="number">2.5</span>, <span class="number">2</span>, <span class="number">3</span>); </span><br><span class="line">shapes[<span class="number">2</span>] = <span class="keyword">new</span> CenteredRectangle(<span class="number">2.3</span>, <span class="number">4.5</span>, <span class="number">3</span>, <span class="number">4</span>); </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 计算这些形状的平均面积 </span></span><br><span class="line"><span class="comment">// 以及到原点的平均距离 </span></span><br><span class="line"><span class="keyword">double</span> totalArea = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">double</span> totalDistance = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; shapes.length; i++) &#123; </span><br><span class="line">  totalArea += shapes[i].area();   <span class="comment">// 计算这些形状的面积 </span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 注意，一般来说，使用instanceof判断对象的运行时类型经常表明设计有问题 </span></span><br><span class="line">  <span class="keyword">if</span> (shapes[i] <span class="keyword">instanceof</span> Centered) &#123; <span class="comment">// 形状属于Centered类型 </span></span><br><span class="line">    <span class="comment">// 注意，把Shape类型转换成Centered类型要校正 </span></span><br><span class="line">    <span class="comment">// （不过，把CenteredSquare类型转换成Centered类型不用校正） </span></span><br><span class="line">    Centered c = (Centered) shapes[i]; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">double</span> cx = c.getCenterX();    <span class="comment">// 获取中心点的坐标 </span></span><br><span class="line">    <span class="keyword">double</span> cy = c.getCenterY();    <span class="comment">// 计算到原点的距离 </span></span><br><span class="line">    totalDistance += Math.sqrt(cx*cx + cy*cy);</span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">System.out.println(<span class="string">&quot;Average area: &quot;</span> + totalArea/shapes.length); </span><br><span class="line">System.out.println(<span class="string">&quot;Average distance: &quot;</span> + totalDistance/shapes.length);</span><br></pre></td></tr></table></figure><blockquote><p>在 Java 中，接口和类一样，也是数据类型。如果一个类实现了一个接口，那么这个类的实例可以赋值给这个接口类型的变量。</p></blockquote><p>看过这个示例之后，别错误地认为必须先把 <code>CenteredRectangle</code> 对象赋值给 <code>Centered</code> 类型的变量才能调用 <code>setCenter()</code> 方法，或者要先赋值给 <code>Shape</code> 类型的变量才能调用 <code>area()</code>方法。<code>CenteredRectangle</code> 类定义了 <code>setCenter()</code> 方法，而且从超类 <code>Rectangle</code> 中继承了<code>area()</code> 方法，所以始终可以调用这两个方法。</p><h3 id="实现多个接口"><a class="header-anchor" href="#实现多个接口"></a>实现多个接口</h3><p>假设我们不仅想通过中心点摆放形状对象，也想通过右上角摆放形状对象，而且还想放大和缩小形状。还记得吗？虽然一个类只能扩展一个超类，但可以实现任意多个接口。假设我们已经定义好了合适的 <code>UpperRightCornered</code> 和 <code>Scalable</code> 接口，那么可以按照下述方式声明类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperDuperSquare</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span></span><br><span class="line"><span class="class">  <span class="keyword">implements</span> <span class="title">Centered</span>, <span class="title">UpperRightCornered</span>, <span class="title">Scalable</span> </span>&#123; </span><br><span class="line">  <span class="comment">// 类的成员省略了 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个类实现多个接口只是表明这个类要实现所有接口中的全部抽象方法（即强制方法）。</p><h3 id="默认方法"><a class="header-anchor" href="#默认方法"></a>默认方法</h3><p>Java 8 出现后，接口中的方法可以包含实现了。本节介绍这种方法——在接口描述的 API中通过可选的方法表示，一般叫作默认方法。首先说明为什么需要这种默认机制。</p><h4 id="向后兼容性"><a class="header-anchor" href="#向后兼容性"></a>向后兼容性</h4><p>Java 平台始终关注向后兼容性。这意味着，为前一版平台编写（或者已经编译）的代码在最新版平台中必须能继续使用。这个原则让开发团队坚信，升级 JDK 或 JRE 后不会破坏之前能正常运行的应用。</p><p>向后兼容性是 Java 平台的一大优势，但是为此，Java 平台有诸多约束。其中一个约束是，新发布的接口不能添加新的强制方法。</p><p>例如，假设我们要升级 <code>Positionable</code> 接口，添加获取和设定左下角顶点的功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Positionable</span> <span class="keyword">extends</span> <span class="title">Centered</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setUpperRightCorner</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>; </span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">getUpperRightX</span><span class="params">()</span></span>; </span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">getUpperRightY</span><span class="params">()</span></span>; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setLowerLeftCorner</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>; </span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">getLowerLeftX</span><span class="params">()</span></span>; </span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">getLowerLeftY</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新定义接口之后，如果尝试在为旧接口编写的代码中使用这个新接口，不会成功，因为现有的代码中没有 <code>setLowerLeftCorner()</code>、<code>getLowerLeftX()</code> 和 <code>getLowerLeftY()</code> 这三个强制方法。</p><blockquote><p>在你的代码中可以轻易地看到效果。编译一个依赖接口的类文件，在接口中添加一个新的强制方法，然后使用新版接口和旧的类文件尝试运行程序。你会看到程序崩溃，抛出 <code>NoClassDefError</code> 异常。</p></blockquote><p>Java 8 的设计者注意到了这个缺陷，因为设计者的目标之一是升级 Java 核心中的集合库，引入使用 lambda 表达式的方法。</p><p>若想解决这个问题，需要一种新机制。这种机制必须要允许向接口中添加可选的新方法，而不破坏向后兼容性。</p><h4 id="实现默认方法"><a class="header-anchor" href="#实现默认方法"></a>实现默认方法</h4><p>在接口中添加新方法而不破坏向后兼容性，这需要为接口的旧实现提供一些新实现，以便接口能继续使用。这个机制是默认方法，在 JDK 8 中首次添加到 Java 平台。</p><blockquote><p>默认方法（有时也叫可选方法）可以添加到任何接口中。默认方法必须包含实现，即默认实现，写在接口定义中。</p></blockquote><p>默认方法的基本行为如下：</p><ul><li>实现接口的类可以（但不是必须）实现默认方法；</li><li>如果实现接口的类实现了默认方法，那么使用这个类中的实现；</li><li>如果找不到其他实现，就使用默认实现。</li></ul><p><code>sort()</code> 方法是默认方法的一例，JDK 8 把它添加到 <code>java.util.List</code> 接口中，定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; </span>&#123; </span><br><span class="line">  <span class="comment">// 省略了其他成员 </span></span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123; </span><br><span class="line">    Collections.&lt;E&gt;sort(<span class="keyword">this</span>, c); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，从 Java 8 开始，实现 List 接口的对象都有一个名为 <code>sort()</code> 的实例方法，使用合适的 <code>Comparator</code> 排序列表。因为返回类型是 <code>void</code>，所以我们猜测这是就地排序，而事实确实如此。</p><h3 id="标记接口"><a class="header-anchor" href="#标记接口"></a>标记接口</h3><p>有时，定义全空的接口很有用。类实现这种接口时只需在 <code>implements</code> 子句中列出这个接口，而不用实现任何方法。此时，这个类的任何实例都是这个接口的有效实例。Java 代码可以使用 <code>instanceof</code> 运算符检查实例是否属于这个接口，因此这种技术是为对象提供额外信息的有力方式。</p><p><code>java.io.Serializable</code> 接口就是一种标记接口。实现 <code>Serializable</code> 接口的类告诉<code>ObjectOutputStream</code> 类，这个类的实例可以安全地序列化。<code>java.util.RandomAccess</code> 也是标记接口：<code>java.util.List</code> 接口实现了这个接口，表明这个接口能快速随机访问列表中的元素。例如，<code>ArrayList</code> 类实现了 <code>RandomAccess</code> 接口，而 <code>LinkedList</code> 类没实现。注重随机访问操作性能的算法可以使用下述方式测试 <code>RandomAccess</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 排序任意长度的列表元素之前，我们或许想确认列表是否支持快速随机访问 </span></span><br><span class="line"><span class="comment">// 如果不支持，先创建一个支持随机访问的副本再排序，速度可能更快 </span></span><br><span class="line"><span class="comment">// 注意，使用java.util.Collections.sort()时不必这么做 </span></span><br><span class="line">List l = ...; <span class="comment">// 随意一个列表 </span></span><br><span class="line"><span class="keyword">if</span> (l.size() &gt; <span class="number">2</span> &amp;&amp; !(l <span class="keyword">instanceof</span> RandomAccess)) l = <span class="keyword">new</span> ArrayList(l);  </span><br><span class="line">sortListInPlace(l);</span><br></pre></td></tr></table></figure><p>后面会看到，Java 的类型系统和类型的名称联系紧密，这种方式叫作名义类型（nominal typing）。标记接口是个很好的例子，因为它除了名称什么都没有。</p><h2 id="Java泛型"><a class="header-anchor" href="#Java泛型"></a>Java泛型</h2><p>Java 平台的一大优势是它提供的标准库。标准库提供了大量有用的功能，特别是实现了健壮的通用数据结构。这些实现使用起来相当简单，而且文档编写良好。虽然这些库一直很有用，但在早期版本中有相当大的不足——数据结构（经常叫作容器）完全隐藏了存储其中的数据类型。</p><blockquote><p>数据隐藏和封装是面向对象编程的重要原则，但在这种情况下，容器的不透明会为开发者带来很多问题。</p></blockquote><h3 id="介绍泛型"><a class="header-anchor" href="#介绍泛型"></a>介绍泛型</h3><p>如果想构建一个由 Shape 实例组成的集合，可以把这个集合保存在一个 List 对象中，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List shapes = <span class="keyword">new</span> ArrayList(); <span class="comment">// 创建一个List对象，保存形状 </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 指定中心点，创建一些形状，保存在这个列表中 </span></span><br><span class="line">shapes.add(<span class="keyword">new</span> CenteredCircle(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>)); </span><br><span class="line"><span class="comment">// 这是合法的Java代码，但不是好的设计方式 </span></span><br><span class="line">shapes.add(<span class="keyword">new</span> CenteredSquare(<span class="number">2.5</span>, <span class="number">2</span>, <span class="number">3</span>)); </span><br><span class="line"> </span><br><span class="line"><span class="comment">// List.get()返回Object对象，所以要想得到CenteredCircle对象，必须校正 </span></span><br><span class="line">CenteredCircle c = (CentredCircle)shapes.get(<span class="number">0</span>); </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 下面这行代码会导致运行时失败 </span></span><br><span class="line">CenteredCircle c = (CentredCircle)shapes.get(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>上述代码有个问题，为了取回有用的形状对象形式，必须校正，因为 List 不知道其中的对象是什么类型。不仅如此，其实可以把不同类型的对象放在同一个容器中，一切都能正常运行，但是如果做了不合法的校正，程序就会崩溃。</p><p>我们真正需要的是一种知道所含元素类型的 List。这样，如果把不合法的参数传给 List 的方法，javac 就能检测到，导致编译出错，而不用等到运行时才发现问题。</p><p>为了解决这个问题，Java 提供了一种句法，指明某种类型是一个容器，这个容器中保存着其他引用类型的实例。容器中保存的负载类型（payload type）在尖括号中指定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个由CenteredCircle对象组成的List </span></span><br><span class="line">List&lt;CenteredCircle&gt; shapes = <span class="keyword">new</span> ArrayList&lt;CenteredCircle&gt;(); </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 指定中心点，创建一些形状，保存在这个列表中 </span></span><br><span class="line">shapes.add(<span class="keyword">new</span> CenteredCircle(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>)); </span><br><span class="line"> <span class="comment">// 下面这行代码会导致编译出错 </span></span><br><span class="line">shapes.add(<span class="keyword">new</span> CenteredSquare(<span class="number">2.5</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// List&lt;CenteredCircle&gt;.get()返回一个CenteredCircle对象，无需校正 </span></span><br><span class="line">CenteredCircle c = shapes.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>这种句法能让编译器捕获大量不安全的代码，根本不能靠近运行时。当然，这正是静态类型系统的关键所在——使用编译时信息协助排除大量运行时问题。</p><p>容器类型一般叫作泛型（generic type），使用下述方式声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">box</span><span class="params">(T t)</span></span>; </span><br><span class="line">  <span class="function">T <span class="title">unbox</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码表明，<code>Box</code> 接口是通用结构，可以保存任意类型的负载。这不是一个完整的接口，更像是一系列接口的通用描述，每个接口对应的类型都能用在 <code>T</code> 的位置上。</p><h3 id="泛型和类型参数"><a class="header-anchor" href="#泛型和类型参数"></a>泛型和类型参数</h3><p>我们已经知道如何使用泛型增强程序的安全性——使用编译时信息避免简单的类型错误。本节深入介绍泛型的特性。</p><p><code>&lt;T&gt;</code> 句法有个专门的名称——类型参数（type parameter）。因此，泛型还有一个名称——参数化类型（parameterized type）。这表明，容器类型（例如 <code>List</code>）由其他类型（负载类型）参数化。把类型写为 <code>Map&lt;String, Integer&gt;</code> 时，我们就为类型参数指定了具体的值。</p><p>定义有参数的类型时，要使用一种不对类型参数做任何假设的方式指定具体的值。所以<code>List</code> 类型使用通用的方式 <code>List&lt;E&gt;</code> 声明，而且自始至终都使用类型参数 <code>E</code> 作占位符，代表程序员使用 <code>List</code> 数据结构时负载的真实类型。</p><p>类型参数可以在方法的签名和主体中使用，就像是真正的类型一样，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>; </span><br><span class="line">  <span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>; </span><br><span class="line">  <span class="comment">// 其他方法省略了 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，类型参数 E 既可以作为返回类型的参数，也可以作为方法参数类型的参数。我们不假设负载类型有任何具体的特性，只对一致性做了基本假设，即存入的类型和后来取回的类型一致。</p><h3 id="菱形句法"><a class="header-anchor" href="#菱形句法"></a>菱形句法</h3><p>创建泛型的实例时，赋值语句的右侧会重复类型参数的值。一般情况下，这个信息是不必要的，因为编译器能推导出类型参数的值。在 Java 的现代版本中，可以使用菱形句法省略重复的类型值。</p><p>下面通过一个示例说明如何使用菱形句法，这个例子改自之前的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用菱形句法创建一个由CenteredCircle对象组成的List </span></span><br><span class="line">List&lt;CenteredCircle&gt; shapes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>对这种冗长的赋值语句来说，这是个小改进，能少输入几个字符。本章末尾介绍 lambda 表达式时会再次讨论类型推导。</p><h3 id="类型擦除"><a class="header-anchor" href="#类型擦除"></a>类型擦除</h3><p>Java 平台十分看重向后兼容性。Java 5 添加的泛型又是一个会导致向后兼容性问题的新语言特性。</p><p>问题的关键是，如何让类型系统既能使用旧的非泛型集合类又能使用新的泛型集合类。设计者选择的解决方式是使用校正：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List someThings = getSomeThings(); </span><br><span class="line"><span class="comment">// 这种校正不安全，但我们知道someThings的内容确实是字符串 </span></span><br><span class="line">List&lt;String&gt; myStrings = (List&lt;String&gt;)someThings;</span><br></pre></td></tr></table></figure><p>上述代码表明，作为类型，<code>List</code> 和 <code>List&lt;String&gt;</code> 是兼容的，至少在某种程度上是兼容的。Java 通过类型擦除实现这种兼容性。这表明，泛型的类型参数只在编译时可见——javac会去掉类型参数，而且在字节码中不体现出来。</p><p>非泛型的 List 一般叫作原始类型（raw type）。就算现在有泛型了，Java 也完全能处理类型的原始形式。不过，这么做几乎就表明代码的质量不高。</p><p>类型擦除机制扩大了 javac 和 JVM 使用的类型系统之间的区别。</p><p>类型擦除还能禁止使用某些其他定义方式，如果没有这个机制，代码看起来是合法的。在下述代码中，我们想使用两个稍微不同的数据结构计算订单数量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不会编译 </span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">OrderCounter</span> </span>&#123; </span><br><span class="line">  <span class="comment">// 把名称映射到由订单号组成的列表上 </span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">totalOrders</span><span class="params">(Map&lt;String, List&lt;String&gt;&gt; orders)</span></span>; </span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 把名称映射到目前已下订单的总数上 </span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">totalOrders</span><span class="params">(Map&lt;String, Integer&gt; orders)</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="枚举和注解"><a class="header-anchor" href="#枚举和注解"></a>枚举和注解</h2><p>Java 有两种特殊形式的类和接口，在类型系统中扮演着特定的角色。这两种类型是枚举类型（enumerated type）和注解类型（annotation type），一般直接称为枚举和注解。</p><h3 id="枚举"><a class="header-anchor" href="#枚举"></a>枚举</h3><p>枚举是类的变种，功能有限，而且允许使用的值很少。</p><blockquote><p>类的对象只有有限个，确定的。如果枚举只有一个对象，则可以作为一种单例模式的实现方式。</p></blockquote><p>例如，假设我们想定义一个类型，表示三原色红绿蓝，而且希望这个类型只有这三个可以使用的值。我们可以使用 <code>enum</code> 关键字定义这个类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">PrimaryColor</span> </span>&#123; </span><br><span class="line">  <span class="comment">// 实例列表末尾的分号是可选的 </span></span><br><span class="line">  RED, GREEN, BLUE </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PrimaryColor 类型的实例可以按照静态字段的方式引用：<code>PrimaryColor.RED</code>、<code>PrimaryColor.GREEN</code> 和 <code>PrimaryColor.BLUE</code>。</p><p>例如，假设我们要定义一个枚举，包含前几个正多边形（等边等角的形状），而且想为这些形状指定一些属性（在方法中指定）。我们可以使用接收一个参数的枚举实现这个需求，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">RegularPolygon</span> </span>&#123; </span><br><span class="line">  <span class="comment">// 有参数的枚举必须使用分号 </span></span><br><span class="line">  TRIANGLE(<span class="number">3</span>), SQUARE(<span class="number">4</span>), PENTAGON(<span class="number">5</span>), HEXAGON(<span class="number">6</span>); </span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> Shape shape; </span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> shape; </span><br><span class="line">  &#125; </span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">RegularPolygon</span><span class="params">(<span class="keyword">int</span> sides)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">switch</span> (sides) &#123; </span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>: </span><br><span class="line">        <span class="comment">// 假设这些形状的构造方法接收的参数是边长和角度 </span></span><br><span class="line">        shape = <span class="keyword">new</span> Triangle(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">60</span>,<span class="number">60</span>,<span class="number">60</span>); </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>: </span><br><span class="line">        shape = <span class="keyword">new</span> Rectangle(<span class="number">1</span>,<span class="number">1</span>); </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>: </span><br><span class="line">        shape = <span class="keyword">new</span> Pentagon(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">108</span>,<span class="number">108</span>,<span class="number">108</span>,<span class="number">108</span>,<span class="number">108</span>); </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">      <span class="keyword">case</span> <span class="number">6</span>: </span><br><span class="line">        shape = <span class="keyword">new</span> Hexagon(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">120</span>,<span class="number">120</span>,<span class="number">120</span>,<span class="number">120</span>,<span class="number">120</span>,<span class="number">120</span>); </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数（在这个例子中只有一个参数）传入构造方法，创建单个枚举实例。因为枚举实例由Java 运行时创建，而且在外部不能实例化，所以把构造方法声明为私有方法。</p><p>枚举有些特殊的特性：</p><ul><li>都（隐式）扩展 java.lang.Enum 类；</li><li>不能泛型化；</li><li>可以实现接口；</li><li>不能被扩展；</li><li>如果枚举中的所有值都有实现主体，那么只能定义为抽象方法；</li><li>只能有一个私有（或使用默认访问权限）的构造方法。</li></ul><blockquote><p>当需要定义一组常量时，强烈建议使用枚举类</p></blockquote><h3 id="Enum类的主要方法"><a class="header-anchor" href="#Enum类的主要方法"></a>Enum类的主要方法</h3><p><code>values()</code>方法：返回枚举类型的对象数组。可以遍历所有的枚举值。</p><p><code>valueOf(String objName)</code>：把一个字符串转换为对应的枚举对象</p><h3 id="注解"><a class="header-anchor" href="#注解"></a>注解</h3><p>注解是一种特殊的接口。如名称所示，其作用是注解 Java 程序的某个部分。</p><p>注解能为编译器和集成开发环境（Integrated Development Environment，IDE）提供有用的提示。如果开发者把方法的名称拼写错了，而这个方法本来是要覆盖超类的方法，那么，在这个名称拼错的方法上使用 @Override 注解，可以提醒编译器什么地方出错了。</p><p>注解不能改变程序的语义，只能提供可选的元信息。严格说来，这意味着注解不能影响程序的执行，只能为编译器和其他预执行阶段提供信息。</p><p>Java 平 台 在 java.lang 中 定 义 了 为 数 不 多 的 基 本 注 解。 一 开 始 只 支 持 <code>@Override</code>、 <code>@Deprecated</code> 和 <code>@SuppressWarnings</code>，这三个注解的作用分别是：注明方法是覆盖的，注明方法废弃了，以及静默编译器生成的警告。</p><p>后来，Java 7 增加了 <code>@SafeVarargs</code>（为变长参数方法提供增强的警告静默功能），Java 8 增加了 <code>@FunctionalInterface</code>。<code>@FunctionalInterface</code> 表示接口可以用作 lambda 表达式的目标。这是个很有用的标记注解，但不是必须使用的，后文会介绍。</p><p>和普通的接口相比，注解有些特殊的特性：</p><ul><li>都（隐式）扩展 <code>java.lang.annotation.Annotation</code> 接口；</li><li>不能泛型化；</li><li>不能扩展其他接口；</li><li>只能定义没有参数的方法；</li><li>不能定义会抛出异常的方法；</li><li>方法的返回类型有限制；</li><li>方法可以有一个默认返回值。</li></ul><h2 id="嵌套类型"><a class="header-anchor" href="#嵌套类型"></a>嵌套类型</h2><h2 id="lambda表达式"><a class="header-anchor" href="#lambda表达式"></a>lambda表达式</h2>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="2020/07/10/Redis/"/>
      <url>2020/07/10/Redis/</url>
      
        <content type="html"><![CDATA[<p>Redis学习记录</p><hr><p>Redis 是当前互联网世界最为流行的 NoSQL ( Not Only SQL) 。 NoSQL 在互联网系统中的作用很大，因为它可以在很大程度上提高互联网系统的性能 。它具备一定持久层的功能，也可以作为一种缓存工具。对于 NoSQL 数据库而言，作为持久层，它存储的数据是半结构化的，这就意味着计算机在读入内存中有更少的规则，读入速度更快。对于那些结构化、多范式规则的数据库系统而言 ， 它更具性能优势。作为缓存，它可以支持大数据存入内存中，只要命中率高，它就能快速响应，因为在内存中的数据读／写 比数据库读／写磁盘的速度快几十到上百倍。</p><p>当前 Redis 已经成为了主要的 NoSQL 工具，其原因如下：</p><ul><li><p>响应快速：Redis 响应非常快，每秒可以执行大约 110 000 个写入操作 ，或者 81 000 个读操作，其速度远超数据库 。 如果存入一些常用的数据，就能有效提高系统的性能。</p></li><li><p>支持 6 种数据类型：它们是字符串 、哈希结构、列表、集合、可排序集合和基数 。比如对于字符串可以存入一些 Java 基础数据类型，哈希可以存储对象，列表可以存储 List 对象等 。 这使得在应用中很容易根据自己的需要选择存储的数据类型，方便开发。对于 Redis 而言，虽然只有 6 种数据类型 ，但是有两大好处 ：一方面可以满足存储各种数据结构体的需要；另外一方面数据类型少，使得规则就少，需要的判断和逻辑就少，这样读／写的速度就更快。</p></li><li><p>操作都是原子的：所有Redis 的操作都是原子的，从而确保当两个客户同时访问Redis 服务器时，得到的是更新后的值（最新值）。在需要高并发的场合可以考虑、使用 Redis 的事务，处理一些需要锁的业务。</p><blockquote><p>原子操作是不可分割的，在执行完毕之前不会被任何其它任务或事件中断。</p></blockquote></li><li><p>MultiUtility工具：Redis 可以在如缓存、消息传递队列中使用（ Redis 支持“发布＋订阅”的消息模式），在应用程序如 Web 应用程序会话、网站页面点击数等任何短暂的数据中使用。</p></li></ul><p>一方面，使用 NoSQL 从数据库中读取数据进行缓存，就可以从内存中读取数据了 ，而不像数据库一样读磁盘。现实是读操作远比写操作要多得多，所以缓存很多常用的数据，提高其命中率有助于整体性能的提高，并且能减缓数据库的压力，对互联网系统架构是十分有利的。</p><p>另 一方面，它也能满足互联网高并发需要高速处理数据的场合，比如抢红包 、商品秒杀等场景，这些场合需要高速处理，并保证并发数据安全和一致性。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring MVC</title>
      <link href="2020/07/10/SpringMVC/"/>
      <url>2020/07/10/SpringMVC/</url>
      
        <content type="html"><![CDATA[<p>长期以来 Struts2 与 Spring 的结合一直存在很多的问题，比如兼容性和类臃肿。加之近年来 Struts2 漏洞问题频发，导致使用率大减。与此同时，生于 Spring Web 项目的 MVC (Model View Controller ）框架走到了我们的面前，Spring MVC 结构层次清晰，类比较简单，并且与 Spring 的核心 IoC 和 AOP 无缝对接，成为了互联网时代的主流框架。</p><p>MVC 模式把应用程序（输入逻辑、业务逻辑和 UI 逻辑）分成不同的方面，同时提供这些元素之间的松耦合。</p><ul><li>Model （模型），封装了应用程序的数据和由它们组成的 POJO 。</li><li>View （视图） ，负责把模型数据渲染到视图上，将数据以一定的形式展现给用户。</li><li>Controller （控制器），负责处理用户请求，并建立适当的模型把它传递给视图渲染。</li></ul><p>在 Spring MVC 中还可以定义逻辑视图，通过其提供的视图解析器就能够很方便地找到对应的视图进行渲染，或者使用其消息转换的功能，比如在 <code>Controller</code> 的方法内加入注解<code>@ResponseBody</code> 后，Spring MVC 就可以通过其消息转换系统，将数据转换为 JSON，提供给前端 Ajax 请求使用。</p><p>Spring MVC 中的重点在于它的流程和一些重要的注解，包括控制器、视图解析器、视图等重要内容。</p><h2 id="注解"><a class="header-anchor" href="#注解"></a>注解</h2><blockquote><p>参考<a href="http://www.iocoder.cn/Spring-Boot/SpringMVC/?self">文档</a></p></blockquote><h3 id="Controller"><a class="header-anchor" href="#Controller"></a><code>@Controller</code></h3><p><a href="https://github.com/spring-projects/spring-framework/blob/master/spring-context/src/main/java/org/springframework/stereotype/Controller.java"><code>@Controller</code></a> 注解，添加在类上，表示这是控制器 Controller 对象。属性如下：</p><ul><li><code>name</code> 属性：该 Controller 对象的 Bean 名字。允许空。</li></ul><p><a href="https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/web/bind/annotation/RestController.java"><code>@RestController</code></a> 注解，添加在类上，是 <code>@Controller</code> 和 <a href="https://github.com/ndimiduk/spring-framework/blob/master/org.springframework.web/src/main/java/org/springframework/web/bind/annotation/ResponseBody.java"><code>@ResponseBody</code></a> 的组合注解，直接使用接口方法的返回结果，经过 JSON/XML 等序列化方式，最终返回。也就是说，无需使用 InternalResourceViewResolver 解析视图，返回 HTML 结果。</p><p>目前主流的架构，都是 <a href="https://blog.csdn.net/fuzhongmin05/article/details/81591072">前后端分离</a> 的架构，后端只需要提供 API 接口，仅仅返回数据。而视图部分的工作，全部交给前端来做。也因此，我们项目中 99.99% 使用 <code>@RestController</code> 注解。</p><h3 id="RequestMapping"><a class="header-anchor" href="#RequestMapping"></a><code>@RequestMapping</code></h3><p><a href="https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/web/bind/annotation/RequestMapping.java"><code>@RequestMapping</code></a> 注解，添加在类或方法上，标记该类/方法对应接口的配置信息。</p><p><code>@RequestMapping</code> 注解的<strong>常用属性</strong>，如下：</p><ul><li><code>path</code> 属性：接口路径。<code>[]</code> 数组，可以填写多个接口路径。</li><li><code>values</code> 属性：和 <code>path</code> 属性相同，是它的别名。</li><li><code>method</code> 属性：请求方法 <a href="https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/web/bind/annotation/RequestMethod.java">RequestMethod</a> ，可以填写 <code>GET</code>、<code>POST</code>、<code>POST</code>、<code>DELETE</code> 等等。<code>[]</code> 数组，可以填写多个请求方法。如果为空，表示匹配所有请求方法。</li></ul><p><code>@RequestMapping</code> 注解的<strong>不常用属性</strong>，如下：</p><ul><li><code>name</code> 属性：接口名。一般情况下，我们不填写。</li><li><code>params</code> 属性：请求参数需要包含值的<strong>参数名</strong>。可以填写多个参数名。如果为空，表示匹配所有请你求方法。</li><li><code>headers</code> 属性：和 <code>params</code> 类似，只是从参数名变成<strong>请求头</strong>。</li><li><code>consumes</code> 属性：和 <code>params</code> 类似，只是从参数名变成请求头的<strong>提交内容类型</strong>( <a href="https://juejin.im/post/5cb34fc06fb9a068a75d3555">Content-Type</a> )</li><li><code>produces</code> 属性：和 <code>params</code> 类似，只是从参数名变成请求头的( <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept">Accept</a> )<strong>可接受类型</strong>。</li></ul><p>考虑到让开发更加方便，Spring 给每种请求方法提供了对应的注解：</p><ul><li><a href="https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/web/bind/annotation/GetMapping.java"><code>@GetMapping</code></a> 注解：对应 <code>@GET</code> 请求方法的 <code>@RequestMapping</code> 注解。</li><li><a href="https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/web/bind/annotation/PostMapping.java"><code>@PostMapping</code></a> 注解：对应 <code>@POST</code> 请求方法的 <code>@RequestMapping</code> 注解。</li><li><a href="https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/web/bind/annotation/PutMapping.java"><code>@PutMapping</code></a> 注解：对应 <code>@PUT</code> 请求方法的 <code>@RequestMapping</code> 注解。</li><li><a href="https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/web/bind/annotation/DeleteMapping.java"><code>@DeleteMapping</code></a> 注解：对应 <code>@DELETE</code> 请求方法的 <code>@RequestMapping</code> 注解。</li><li>还有其它几个，就不一一列举了。</li></ul><h3 id="RequestParam"><a class="header-anchor" href="#RequestParam"></a><code>@RequestParam</code></h3><p><a href="https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/web/bind/annotation/RequestParam.java"><code>@RequestParam</code></a> 注解，添加在方法参数上，标记该方法参数对应的请求参数的信息。属性如下：</p><ul><li><code>name</code> 属性：对应的请求参数名。如果为空，则直接使用方法上的参数变量名。</li><li><code>value</code> 属性：和 <code>name</code> 属性相同，是它的别名。</li><li><code>required</code> 属性：参数是否必须传。默认为 <code>true</code> ，表示必传。</li><li><code>defaultValue</code> 属性：参数默认值。</li></ul><p><a href="https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/web/bind/annotation/PathVariable.java"><code>@PathVariable</code></a> 注解，添加在方法参数上，标记接口路径和方法参数的映射关系。具体的，我们在示例中来看。相比 <code>@RequestParam</code> 注解，少一个 <code>defaultValue</code> 属性。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis</title>
      <link href="2020/07/10/MyBatis/"/>
      <url>2020/07/10/MyBatis/</url>
      
        <content type="html"><![CDATA[<p>参考《Java EE互联网轻量级框架整合开发》、MyBatis官方文档</p><hr><h2 id="MyBatis概述"><a class="header-anchor" href="#MyBatis概述"></a>MyBatis概述</h2><h3 id="什么是MyBatis"><a class="header-anchor" href="#什么是MyBatis"></a>什么是MyBatis</h3><p>MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p><p>MyBatis 的前身是 Apache 的开源项目iBatis，是一个基于 Java 的持久层框架。MyBatis 的优势在于灵活，它几乎可以代替 JDBC ，同时提供了接口编程。目前 MyBatis 的数据访问层 DAO (Data Access Objects）是不需要实现类的，它只需要一个接口和 XML（或者注解）。MyBatis 提供自动映射、动态 SQL、级联、缓存、注解、代码和 SQL 分离等特性，使用方便，同时也可以对 SQL 进行优化。因为其具有封装少、映射多样化、支持存储过程、可以进行 SQL 优化等特点，使得它取代了 Hibernate 成为了 Java 互联网中首选的持久框架。</p><p>Hibernate 作为一种十分流行的框架，它有其无可替代的优势，这里我们有必要讨论一下它和 MyBatis 的区别。由于 MyBatis 和 Hibernate 都是持久层框架，都会涉及数据库，所以首先定义一个数据库表一一角色表（t_role）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ID--&gt;int(12)</span><br><span class="line">roleName--&gt;varchar(60)</span><br><span class="line">note--&gt;varchar(1024)</span><br></pre></td></tr></table></figure><p>根据这个角色表，我们可以用一个 POJO (Plain Ordinary Java Object ）和这张表定义的字段对应起来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.learn.chapterl.pojo;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Role</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String roleName;</span><br><span class="line">    <span class="keyword">private</span> String note;</span><br><span class="line">    <span class="comment">/** setter and getter **/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论是 MyBatis 还是 Hibernate 都是依靠某种方法，将数据库的表和 POJO 映射起来的，这样程序员就可以操作 POJO 来完成相关的逻辑了。</p><h3 id="Hibernate-简介"><a class="header-anchor" href="#Hibernate-简介"></a>Hibernate 简介</h3><p>要将POJO和数据库映射起来需要给这些框架提供映射规则 ，所以下一步要提供映射的规则。</p><p>在 MyBatis 或者 Hibernate 中可以通过 XML 或者注解提供映射规则， 这里讨论的是XML方式，因为在 MyBatis 中注解方式会受到一定的限制，所以 MyBatis 通常使用 XML方式实现映射关系。</p><p>我们把 POJO 对象和数据库表相互映射的框架称为对象关系映射（ Object Relational Mapping, ORM，或O/RM，或 O/R mapping ）框架。无论 MyBatis 或者 Hibernate 都可以称为 ORM 框架 ，只是 Hibernate 的设计理念是完全面向 POJO 的，而 MyBatis 则不是。Hibernate 基本不再需要编写 SQL 就可以通过映射关系来操作数据库，是一种全表映射的体现：而 MyBatis 则不同，它需要我们提供 SQL 去运行。</p><p>Hibernate 是将 POJO 和数据库表对应的映射文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">”com.learn.chapterl.pojo.Role”</span> <span class="attr">table</span>=<span class="string">&quot;t_role&quot;</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">”id”</span> <span class="attr">type</span>=<span class="string">”java.lang.Integer”</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">”id”/</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;identity&quot;</span> /&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>＝”<span class="attr">roleName</span>” <span class="attr">type</span>＝”<span class="attr">string</span>” &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">&quot;role_name&quot;</span> <span class="attr">length</span>=<span class="string">&quot;60&quot;</span> <span class="attr">not-null</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;note&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">&quot;note&quot;</span> <span class="attr">length</span>=<span class="string">&quot;512&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>首先，对 POJO 和表 t_role 进行了映射配置，把两者映射起来了。然后，对 POJO 进行操作，从而影响t_role 表的数据，比如对其增、删、查、改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Hibernate 通过 Session 操作数据库数据</span></span><br><span class="line">Session session = <span class="keyword">null</span>;</span><br><span class="line">Transaction tx = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//打开 Session</span></span><br><span class="line">    session = HibernateUtil.getSessionFactory().openSession();</span><br><span class="line">    <span class="comment">//事务</span></span><br><span class="line">    tx = session.beginTransaction();</span><br><span class="line">    <span class="comment">//POJO</span></span><br><span class="line">    Role role = <span class="keyword">new</span> Role();</span><br><span class="line">    role.setId(<span class="number">1</span>);</span><br><span class="line">    rold.setRoleName(<span class="string">&quot;rolename1&quot;</span>);</span><br><span class="line">    role.setNote(<span class="string">&quot;note1&quot;</span>);</span><br><span class="line">    session.save(role);<span class="comment">//保存</span></span><br><span class="line">    Role role2 = (Role) session.get(Role.class, <span class="number">1</span>);<span class="comment">//查询</span></span><br><span class="line">    role2.setNote(<span class="string">&quot;修改备注&quot;</span>);</span><br><span class="line">    session.updata(role2);<span class="comment">//更新</span></span><br><span class="line">    System.err.println(role2.getRoleName());</span><br><span class="line">    session.delete(role2);<span class="comment">//删除</span></span><br><span class="line">    tx.commit();<span class="comment">//提交事务</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex)&#123;</span><br><span class="line">    <span class="keyword">if</span> (tx != <span class="keyword">null</span> &amp;&amp; tx.isActive())&#123;</span><br><span class="line">        tx.rollback()<span class="comment">//回滚事务</span></span><br><span class="line">    &#125;</span><br><span class="line">    ex.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (session != <span class="keyword">null</span> &amp;&amp; session.isOpen())&#123;</span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们没有看到 SQL ，那是因为 Hibernate 会根据映射关系来生成对应的 SQL，程序员不用精通 SQL，只要懂得操作 POJO 就能够操作对应数据库的表了。这在管理系统时代是十分有利的 。因为对于管理系统而言，首先在于实现业务逻辑，然后才是性能，所以 Hibernate 成为了那个时代的主流持久框架。</p><h3 id="MyBatis简介"><a class="header-anchor" href="#MyBatis简介"></a>MyBatis简介</h3><p>在移动互联网时代，MyBatis 成为了目前互联网 Java 持久框架的首选，与 Hibernate 消除 SQL 不同，MyBatis 不屏蔽 SQL。不屏蔽 SQL 的优势在于，程序员可以自己制定 SQL规则，无须 Hibernate 自动生成规则，这样能够更加精确地定义 SQL ，从而优化性能 。它更符合移动互联网高并发、大数据、高性能 、 高响应的要求。</p><p>与 Hibernate 一样 ，MyBatis 也需要一个映射文件把 POJO 和数据库的表对应起来。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.learn.chapterl.mapper.RoleMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;roleMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.learn.chapterl.pojo.Role&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;roleName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;role_name&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;note&quot;</span> <span class="attr">column</span>=<span class="string">&quot;note&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span> </span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getRole&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;roleMap&quot;</span>&gt;</span></span><br><span class="line">        select id, role_name, note from t_role where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span> </span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span> =<span class="string">&quot;deleteRole&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">    delete from t_role where id = #&#123;id&#125; </span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span> </span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span> =<span class="string">&quot;insertRole&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.learn.chapterl.pojo.Role&quot;</span>&gt;</span></span><br><span class="line">    insert into t_role(role_name, note) values(#&#123;roleName&#125;, #&#123;note&#125;) </span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span> </span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateRole&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.learn.chapterl.pojo.Role&quot;</span> &gt;</span></span><br><span class="line">        update t_role set </span><br><span class="line">        role name= #&#123;roleName&#125;, </span><br><span class="line">        note = #&#123;note&#125; </span><br><span class="line">        where id = #&#123;id&#125; </span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里的 <code>resultMap</code> 元素用于定义映射规则 ，而实际上 MyBatis 在满足一定的规则下，完成自动映射，而增、删、查、改对应着 insert 、delete 、select、update 四个元素，十分明了 。</p><blockquote><p>注意，<code>mapper</code> 元素中的 <code>namespace</code> 属性，它要和一个接口的全限定名保持一致 ，而里面的 SQL 的 <code>id</code> 也需要和接口定义的方法完全保持一致</p></blockquote><p>定义 MyBatis 映射文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.learn.chapterl.mapper;</span><br><span class="line"><span class="keyword">import</span> com.learn.chapterl.pojo.Role;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RoleMapper</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Role <span class="title">getRole</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deletRole</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertRole</span><span class="params">(Role role)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateRole</span><span class="params">(Role role)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对角色类的增、删、 查 、 改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">SqlSession sqlSession = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">    sqlSession = MyBatisUtil.getSqlSession();</span><br><span class="line">    RoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class); </span><br><span class="line">    Role role = roleMapper.getRole(<span class="number">1</span>);<span class="comment">//查询</span></span><br><span class="line">    System.err.println(role.getRoleName()); </span><br><span class="line">    role.setRoleName(<span class="string">&quot;update role name&quot;</span>); </span><br><span class="line">    roleMapper.updateRole(role);<span class="comment">//更新</span></span><br><span class="line">    Role role2 = <span class="keyword">new</span> Role(); </span><br><span class="line">    role2.setNote(<span class="string">&quot;note2&quot;</span>); </span><br><span class="line">    role2.setRoleName(<span class="string">&quot;role2&quot;</span>); </span><br><span class="line">    roleMapper.insertRole(role); <span class="comment">//插入</span></span><br><span class="line">    roleMapper.deleteRole(S); <span class="comment">//删除</span></span><br><span class="line">    sqlSession.commit(); <span class="comment">//提交事务</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123; </span><br><span class="line">ex.printStackTrace();</span><br><span class="line">    <span class="keyword">if</span> (sqlSession != <span class="keyword">null</span>) &#123; </span><br><span class="line">    sqlSession.rollback();<span class="comment">//回滚事务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span>&#123;<span class="comment">//关闭连接</span></span><br><span class="line">    <span class="keyword">if</span> (sqlSession ! = <span class="keyword">null</span>) &#123; </span><br><span class="line">    sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>显然 MyBatis 在业务逻辑上和 Hibernate 是大同小异的。其区别在于，MyBatis 需要提供接口和 SQL ，这意味着它的工作量会 比 Hibernate 大，但是由于自定义 SQL 、 映射关系，所以其灵活性、可优化性就超过了 Hibernate 。互联网可优化性、灵活性是十分重要 的，因为一条 SQL 的性能可能相差十几倍到几十倍，这对于互联网系统是十分重要的 。</p><h3 id="Hibernate-和-MyBatis-的区别"><a class="header-anchor" href="#Hibernate-和-MyBatis-的区别"></a>Hibernate 和 MyBatis 的区别</h3><p>Hibernate 和 MyBatis 的增、删、查、改，对于业务逻辑层来说大同小异，对于映射层而言 Hibernate 的配置不需要接口和 SQL ，相反 MyBatis 是需要的。</p><p>对于 Hibernate 而言 ，不需要编写大量的 SQL，就可以完全映射，同时提供了日志、缓存、级联（级联比 MyBatis 强大）等特性， 此外还提供 HQL (Hibernate Query Language ）对 POJO 进行操作，使用十分方便，但是它也有致命的缺陷。</p><p>由于无须 SQL ，当多表关联超过 3 个的时候，通过 Hibernate 的级联会造成太多性能的丢失 ，又或者我现在访问 一个财务的表，然后它会关联财产信息表，财产又分为机械、原料等，显然机械和原料的字段是不一样的，这样关联字段只能根据特定的条件变化而变化，而 Hibernate 无法支持这样的变化 。 遇到存储过程， Hibernate 只能作罢。更为关键的是性能，在管理系统的时代，对于性能的要求不是那么苛刻，但是在互联网时代性能就是系统的根本，响应过慢就会丧失客户，试想一下谁会去用一个经常需要等待超过10 秒以上的应用呢？</p><p>以上的问题 MyBatis 都可以解决，MyBatis 可以自由书写 SQL、支持动态 SQL、处理列表、动态生成表名、支持存储过程。这样就可 以灵活地定义查询语句 ，满足各类需求和性能优化的需要，这些在互联网系统中是十分重要 的。</p><p>但 MyBatis 也有缺陷 。</p><ul><li><p>首先，它要编写 SQL 和映射规则，其工作量稍微大于 Hibernate 。</p></li><li><p>其次，它支持的工具也很有限，不能像 Hibernate 那样有许多的插件可以帮助生成映射代码和关联关系，而即使使用生成工具，往往也需要开发者进一步简化，MyBatis 通过手工编码，工作量相对大些。</p></li></ul><p>所以对于性能要求不太苛刻 的系统，比如管理系统、ERP 等推荐使用 Hibernate；而对于性能要求高、响应快、灵活的系统则推荐使用 MyBatis 。</p><h2 id="获取MyBatis"><a class="header-anchor" href="#获取MyBatis"></a>获取MyBatis</h2><h3 id="GitHub"><a class="header-anchor" href="#GitHub"></a>GitHub</h3><p>GitHub<a href="https://github.com/mybatis/mybatis-3">地址</a></p><p><strong>MyBatis SQL Mapper Framework for Java</strong></p><p>The MyBatis SQL mapper framework makes it easier to use a relational database with object-oriented applications. MyBatis couples objects with stored procedures or SQL statements using a XML descriptor or annotations. Simplicity is the biggest advantage of the MyBatis data mapper over object relational mapping tools.</p><p>是一个Maven项目，点击Releases，选择版本即可下载</p><h3 id="Maven仓库"><a class="header-anchor" href="#Maven仓库"></a>Maven仓库</h3><p>Maven仓库<a href="https://mvnrepository.com/artifact/org.mybatis/mybatis">地址</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="HelloMyBatis"><a class="header-anchor" href="#HelloMyBatis"></a>HelloMyBatis</h2><h3 id="搭建环境"><a class="header-anchor" href="#搭建环境"></a>搭建环境</h3><p>1、创建数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE &#96;mybatis&#96;;</span><br><span class="line">USE &#96;mybatis&#96;;</span><br><span class="line"></span><br><span class="line">SET NAMES utf8mb4;</span><br><span class="line">SET FOREIGN_KEY_CHECKS &#x3D; 0;</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line">-- Table structure for user</span><br><span class="line">-- ----------------------------</span><br><span class="line">DROP TABLE IF EXISTS &#96;user&#96;;</span><br><span class="line">CREATE TABLE &#96;user&#96;  (</span><br><span class="line">  &#96;id&#96; int(0) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;name&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  &#96;pwd&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;) USING BTREE</span><br><span class="line">) ENGINE &#x3D; InnoDB CHARACTER SET &#x3D; utf8 COLLATE &#x3D; utf8_general_ci ROW_FORMAT &#x3D; Dynamic;</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line">-- Records of user</span><br><span class="line">-- ----------------------------</span><br><span class="line">INSERT INTO &#96;user&#96; VALUES (1, &#39;张三&#39;, &#39;123456&#39;);</span><br><span class="line">INSERT INTO &#96;user&#96; VALUES (2, &#39;李四&#39;, &#39;123456&#39;);</span><br><span class="line">INSERT INTO &#96;user&#96; VALUES (3, &#39;王五&#39;, &#39;123456&#39;);</span><br><span class="line"></span><br><span class="line">SET FOREIGN_KEY_CHECKS &#x3D; 1;</span><br></pre></td></tr></table></figure><p>2、新建Maven项目</p><p>在IDEA中创建普通的Maven项目，并在pom.xml中导入以下三个依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--mysql依赖--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--mybatis--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--junit--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="创建模块"><a class="header-anchor" href="#创建模块"></a>创建模块</h3><p>在父模块下创建mybatis-01的Maven子模块</p><p>1、编写mybatis的核心配置文件</p><p>在mybatis-01模块中的src-&gt;main-&gt;resources中创建mybatis-config.xml文件，导入以下内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--核心配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--事物管理--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=false<span class="symbol">&amp;amp;</span>useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=UTF-8&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>并将<code>property</code>中的<code>value</code>进行修改</p><p>2、编写MyBatis工具类</p><p>每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先配置的 Configuration 实例来构建出 SqlSessionFactory 实例。既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 官方文档</span></span><br><span class="line">String resource = <span class="string">&quot;org/mybatis/example/mybatis-config.xml&quot;</span>;</span><br><span class="line">InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提升作用域</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 获取sqlSessionFactory对象</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String resource = <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">            InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">            SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSqlSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory.openSession();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写代码"><a class="header-anchor" href="#编写代码"></a>编写代码</h3><p>1、创建pojo包并创建User.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 变量名与数据库要对应</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String pwd;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*** setter and getter ***/</span></span><br><span class="line">    <span class="comment">/*** Constructor ***/</span></span><br><span class="line">    <span class="comment">/*** toString ***/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、 在dao包中创建接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取用户列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、创建UserMapper.xml文件</p>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="2020/07/07/MySQL/"/>
      <url>2020/07/07/MySQL/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考书籍《SQL必知必会》第4版 Ben Forta 著</p></blockquote><h2 id="数据库简介"><a class="header-anchor" href="#数据库简介"></a>数据库简介</h2><h3 id="数据库（DB，Data-Base）"><a class="header-anchor" href="#数据库（DB，Data-Base）"></a>数据库（DB，Data Base）</h3><p>保存有组织的数据的容器（通常是一个文件或一组文件）。</p><p>表（table） ：某种特定类型数据的结构化清单。存储在表中的数据是同一种类型的数据或清单。</p><p>列（column） ：表中的一个字段。所有表都是由一个或多个列组成的。</p><p>行（row） ：表中的一个记录。表中的数据是按行存储的，所保存的每个记录存储在自己的行内。</p><blockquote><p>如果将表想象为网格，网格中垂直的列为表列，水平行为表行。</p></blockquote><p>主键（primary key）：一列（或一组列），其值能够<strong>唯一标识</strong>表中每一行。顾客表可以使用顾客编号，而订单表可以使用订单ID。雇员表可以使用雇员ID 或雇员社会安全号。</p><p>表中的任何列都可以作为主键，只要它满足以下条件：</p><ul><li>任意两行都不具有相同的主键值；</li><li>每一行都必须具有一个主键值（主键列不允许NULL 值）；</li><li>主键列中的值不允许修改或更新；</li><li>主键值不能重用（如果某行从表中删除，它的主键不能赋给以后的新行）。</li></ul><blockquote><p>主键通常定义在表的一列上，但并不是必需这么做，也可以一起使用多个列作为主键。</p><p>在使用多列作为主键时，上述条件必须应用到所有列，所有列值的组合必须是唯一的（但单个列的值可以不唯一）。</p></blockquote><p>分为关系型数据库和非关系型数据库</p><ul><li><a href="https://baike.baidu.com/item/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/8999831">关系型数据库</a>：SQL（Structured Query Language）指采用了<a href="https://baike.baidu.com/item/%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B/3189329">关系模型</a>来组织数据的数据库，其以行和列的形式存储数据，以便于用户理解，关系型数据库这一系列的行和列被称为表，一组表组成了<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93/103728">数据库</a>。</li><li><a href="https://baike.baidu.com/item/NoSQL/8828247?fromtitle=%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93&amp;fromid=6376860&amp;fr=aladdin">非关系型数据库</a>：NoSQL（Not Only SQL），对象存储，通过对象的属性来决定。</li></ul><h3 id="数据库管理系统（DBMS，Database-Management-System）"><a class="header-anchor" href="#数据库管理系统（DBMS，Database-Management-System）"></a>数据库管理系统（DBMS，Database Management System）</h3><p>数据库管理软件，科学有效的管理数据。MySQL是一种DBMS，即它是一种数据库软件。</p><h3 id="MySQL"><a class="header-anchor" href="#MySQL"></a>MySQL</h3><p>优点：</p><ul><li>成本，MySQL是开放源代码的，一般可以免费使用（甚至可以免费修改）。</li><li>性能，MySQL执行很快（非常快）。</li><li>可信赖，某些非常重要和声望很高的公司、站点使用MySQL， 这些公司和站点都用MySQL来处理自己的重要数据。</li><li>简单，MySQL很容易安装和使用。</li></ul><p>5.7版本稳定</p><h2 id="MySQL的安装"><a class="header-anchor" href="#MySQL的安装"></a>MySQL的安装</h2><h3 id="Windows下的安装"><a class="header-anchor" href="#Windows下的安装"></a>Windows下的安装</h3><p>官网<a href="https://dev.mysql.com/downloads/mysql/">下载地址</a>，选择下载ZIP Archive</p><img src="http://img.whl123456.top/image/MySQL官网下载.png" alt="MySQL官网下载" style="zoom:50%;" /><ol><li><p>压缩包下载完成后解压到自己指定的文件夹中</p></li><li><p>编辑环境变量，将MySQL下的bin目录添加到Path</p></li><li><p>在<code>D:\安装路径\mysql-8.0.20</code>下新建<code>my.ini</code>配置文件</p></li><li><p>编辑<code>my.ini</code>文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[mysql]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置mysql客户端默认字符集</span></span><br><span class="line">default-character-set=utf8 </span><br><span class="line">[mysqld]</span><br><span class="line"><span class="meta">#</span><span class="bash">设置3306端口</span></span><br><span class="line">port = 3306 </span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置mysql的安装目录</span></span><br><span class="line">basedir=D:\Develop\MySQL\mysql-8.0.20</span><br><span class="line"><span class="meta">#</span><span class="bash"> 允许最大连接数</span></span><br><span class="line">max_connections=200</span><br><span class="line"><span class="meta">#</span><span class="bash"> 服务端使用的字符集默认为8比特编码的latin1字符集</span></span><br><span class="line">character-set-server=utf8</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建新表时将使用的默认存储引擎</span></span><br><span class="line">default-storage-engine=INNODB</span><br></pre></td></tr></table></figure><blockquote><p>路径选择自己安装目录，<code>data</code>目录不要自己创建，参考<a href="https://www.jb51.net/article/172172.htm">文章</a></p></blockquote></li><li><p>安装MySQL服务：在<strong>管理员模式</strong>下启动命令行终端（cmd），执行<code>mysqld -install</code>命令，安装成功则显示<code>Service successfully installed.</code></p></li><li><p>初始化数据库文件：再输入<code>mysqld --initialize-insecure --user=mysql</code>，等待一会不报错且在安装目录中生成<code>data</code>文件则表示成功</p></li><li><p>启动MySQL：键入<code>net start mysql</code>启动服务，显示<code>MySQL服务已启动成功</code></p></li><li><p>进入MySQL管理界面：在启动成功MySQL服务后，输入命令<code>mysql -u root -p</code>，Enter password：时直接回车</p></li><li><p>设置用户和密码：进入SQL命令行后输入。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update mysql.user set authentication_string=MD5(&#x27;123456&#x27;) where User=&#x27;root&#x27; and Host=&#x27;locahost&#x27;;</span><br></pre></td></tr></table></figure><blockquote><p>在 MySQL5.7 中<code>user</code>表的<code>password</code>已换成了<code>authentication_string</code>。</p><p><code>password()</code>加密函数已经在 8.0.11 中移除了，可以使用<code>MD5()</code>函数代替。</p></blockquote></li><li><p>刷新权限：<code>FLUSH PRIVILEGES;</code></p></li><li><p>重启MySQL：退出MySQL命令行，输入<code>quit</code>，再在命令行中输入<code>net stop mysql</code>关闭MySQL之后启动<code>net start mysql</code></p></li></ol><h2 id="使用Navicat进行可视化操作"><a class="header-anchor" href="#使用Navicat进行可视化操作"></a>使用Navicat进行可视化操作</h2><p>连接号Navicat后，选择新建查询，输入SQL建表语句进行创建一个school表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE `school` <span class="type">CHARACTER</span> </span><br><span class="line"><span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci;</span><br></pre></td></tr></table></figure><p><img src="http://img.whl123456.top/image/Navicat%E5%88%9B%E5%BB%BA%E8%A1%A8.png" alt="Navicat创建表"></p><p><img src="http://img.whl123456.top/image/Navicat%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9C%E8%A1%A8.png" alt="Navicat可视化操作表"></p><h2 id="SQL语句"><a class="header-anchor" href="#SQL语句"></a>SQL语句</h2><ol><li><p>查看当前所有数据库：<code>SHOW DATABASES;</code></p></li><li><p>打开指定的库：<code>USE 库名;</code></p></li><li><p>查看当前的所有表：<code>SHOW TABLES;</code></p></li><li><p>查看其他库的所有表：<code>SHOW TABLES FROM 库名;</code></p></li><li><p>创建表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">列名 列类型,</span><br><span class="line">列名 列类型,</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>查看表结构：<code>DESC 表名;</code></p></li><li><p>查看数据库版本：</p><ul><li>登录到MySQL<code>SELECT VERSION();</code></li><li>没有登录MySQL命令行中<code>mysql -V</code></li></ul></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> DATABASES; <span class="comment">--查看所有的数据库</span></span><br><span class="line">USE 数据库名 <span class="comment">--切换数据库</span></span><br><span class="line"><span class="keyword">SHOW</span> TABLES; <span class="comment">--查看数据库中所有的表</span></span><br><span class="line"><span class="keyword">DESCRIBE</span> 表名; <span class="comment">--显示表中信息</span></span><br><span class="line"><span class="keyword">CREATE</span> DATABASES 数据库名; <span class="comment">--创建数据库</span></span><br></pre></td></tr></table></figure><h3 id="语法规范"><a class="header-anchor" href="#语法规范"></a>语法规范</h3><p><strong>SQL</strong>（Structured Query Language）结构化查询语言的缩写。</p><ol><li>不区分大小写，建议关键字大写，表名、列名小写</li><li>多条SQL 语句必须以分号（;）分隔。每条命令建议用分号结尾</li><li>每条命令根据需要进行缩进和换行</li><li>注释<ul><li>单行注释1：#单行注释（这种形式很少得到支持）</li><li>单行注释2：-- 单行注释</li><li>多行注释：/*多行注释*/</li></ul></li></ol><p>关键字（keyword）：作为SQL 组成部分的保留字。关键字不能用作表或列的名字。</p><h3 id="检索数据"><a class="header-anchor" href="#检索数据"></a>检索数据</h3><h4 id="SELECT-语句"><a class="header-anchor" href="#SELECT-语句"></a><code>SELECT</code> 语句</h4><p>最经常使用的SQL 语句大概就是 <code>SELECT</code> 语句了。它的用途是从一个或多个表中检索信息。</p><h4 id="检索单个列"><a class="header-anchor" href="#检索单个列"></a>检索单个列</h4><p>利用<code>SELECT</code>语句从Products 表中检索一个名为prod_name的列。所需的列名写在<code>SELECT</code>关键字之后，用<code>FROM</code> 关键字指出从哪个表中检索数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name <span class="keyword">FROM</span> Products; </span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">prod_name </span></span><br><span class="line"><span class="comment">-------------------</span></span><br><span class="line"><span class="comment">Fish bean bag toy</span></span><br><span class="line"><span class="comment">Bird bean bag toy</span></span><br><span class="line"><span class="comment">Rabbit bean bag toy</span></span><br><span class="line"><span class="comment">8 inch teddy bear</span></span><br><span class="line"><span class="comment">12 inch teddy bear</span></span><br><span class="line"><span class="comment">18 inch teddy bear</span></span><br><span class="line"><span class="comment">Raggedy Ann</span></span><br><span class="line"><span class="comment">King doll</span></span><br><span class="line"><span class="comment">Queen doll</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="检索多个列"><a class="header-anchor" href="#检索多个列"></a>检索多个列</h4><p>要想从一个表中检索多个列，仍然使用相同的<code>SELECT</code> 语句。唯一的不同是必须在<code>SELECT</code> 关键字后给出多个列名，列名之间必须以逗号分隔。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_name, prod_price </span><br><span class="line"><span class="keyword">FROM</span> Products;</span><br></pre></td></tr></table></figure><p>与前一个例子一样，这条语句使用 <code>SELECT</code> 语句从表 Products 中选择数据。在这个例子中，指定了 3 个列名，列名之间用逗号分隔。此语句的输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">prod_id       prod_name                prod_price </span><br><span class="line">---------     --------------------     ----------</span><br><span class="line">BNBG01        Fish bean bag toy        3.4900 </span><br><span class="line">BNBG02        Bird bean bag toy        3.4900 </span><br><span class="line">BNBG03        Rabbit bean bag toy      3.4900 </span><br><span class="line">BR01          8 inch teddy bear        5.9900 </span><br><span class="line">BR02          12 inch teddy bear       8.9900 </span><br><span class="line">BR03          18 inch teddy bear       11.9900 </span><br><span class="line">RGAN01        Raggedy Ann              4.9900 </span><br><span class="line">RYL01         King doll                9.4900 </span><br><span class="line">RYL02         Queen dool               9.4900</span><br></pre></td></tr></table></figure><h4 id="检索所有列"><a class="header-anchor" href="#检索所有列"></a>检索所有列</h4><p>除了指定所需的列外（如上所述，一个或多个列），<code>SELECT</code> 语句还可以检索所有的列而不必逐个列出它们。在实际列名的位置使用星号（<code>*</code>）通配符可以做到这点，如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM Products;</span><br></pre></td></tr></table></figure><blockquote><p>一般而言，除非你确实需要表中的每一列，否则最好别使用<code>*</code>通配符。虽然使用通配符能让你自己省事，不用明确列出所需列，但检索不需要的列通常会降低检索和应用程序的性能。</p><p>使用通配符有一个大优点。由于不明确指定列名（因为星号检索每一列），所以能检索出名字未知的列。</p></blockquote><h4 id="检索不同的值"><a class="header-anchor" href="#检索不同的值"></a>检索不同的值</h4><p>使用 DISTINCT 关键字，它指示数据库只返回不同的值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> vend_id </span><br><span class="line"><span class="keyword">FROM</span> Products;</span><br></pre></td></tr></table></figure><p><code>SELECT DISTINCT vend_id</code> 告诉 DBMS 只返回不同（具有唯一性）的vend_id 行，所以正如下面的输出，只有 3 行。如果使用 <code>DISTINCT</code> 关键字，它必须直接放在列名的前面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vend_id </span><br><span class="line">----------</span><br><span class="line">BRS01</span><br><span class="line">DLL01</span><br><span class="line">FNG01</span><br></pre></td></tr></table></figure><blockquote><p><code>DISTINCT</code> 关键字作用于所有的列，不仅仅是跟在其后的那一列。例如，你指定 <code>SELECT DISTINCT vend_id, prod_price</code>，除非指定的两列完全相同，否则所有的行都会被检索出来</p></blockquote><h4 id="限制结果"><a class="header-anchor" href="#限制结果"></a>限制结果</h4><p>SELECT 语句返回指定表中所有匹配的行，很可能是每一行。如果你只想返回第一行或者一定数量的行，该怎么办呢？这是可行的，然而遗憾的是，各种数据库中的这一 SQL 实现并不相同。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name </span><br><span class="line"><span class="keyword">FROM</span> Products;</span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">prod_name </span></span><br><span class="line"><span class="comment">-------------------</span></span><br><span class="line"><span class="comment">Fish bean bag toy</span></span><br><span class="line"><span class="comment">Bird bean bag toy</span></span><br><span class="line"><span class="comment">Rabbit bean bag toy</span></span><br><span class="line"><span class="comment">8 inch teddy bear</span></span><br><span class="line"><span class="comment">12 inch teddy bear</span></span><br><span class="line"><span class="comment">18 inch teddy bear</span></span><br><span class="line"><span class="comment">Raggedy Ann</span></span><br><span class="line"><span class="comment">King doll</span></span><br><span class="line"><span class="comment">Queen doll</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>如果使用 MySQL、MariaDB、PostgreSQL 或者 SQLite，需要使用 <code>LIMIT</code> 子句，像这样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name </span><br><span class="line"><span class="keyword">FROM</span> Products </span><br><span class="line">LIMIT <span class="number">5</span>;</span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">prod_name </span></span><br><span class="line"><span class="comment">-------------------</span></span><br><span class="line"><span class="comment">Fish bean bag toy</span></span><br><span class="line"><span class="comment">Bird bean bag toy</span></span><br><span class="line"><span class="comment">Rabbit bean bag toy</span></span><br><span class="line"><span class="comment">8 inch teddy bear</span></span><br><span class="line"><span class="comment">12 inch teddy bear</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>上述代码使用 SELECT 语句来检索单独的一列数据。LIMIT 5 指示 MySQL等 DBMS 返回不超过 5 行的数据。</p><p>为了得到后面的 5 行数据，需要指定从哪儿开始以及检索的行数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name </span><br><span class="line"><span class="keyword">FROM</span> Products </span><br><span class="line">LIMIT <span class="number">5</span> <span class="keyword">OFFSET</span> <span class="number">5</span>;</span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">prod_name </span></span><br><span class="line"><span class="comment">-------------------</span></span><br><span class="line"><span class="comment">18 inch teddy bear</span></span><br><span class="line"><span class="comment">Raggedy Ann</span></span><br><span class="line"><span class="comment">King doll</span></span><br><span class="line"><span class="comment">Queen doll</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>LIMIT 5 OFFSET 5</code> 指示 MySQL 等 DBMS 返回从第 5 行起的 5 行数据。第一个数字是检索的行数，第二个数字是指从哪儿开始（从0开始计数）。</p><p>Products 表中只有 9 种产品，所以只返回了 4 行数据。</p><h3 id="排序检索数据"><a class="header-anchor" href="#排序检索数据"></a>排序检索数据</h3><p>如何使用 <code>SELECT</code> 语句的 <code>ORDER BY</code> 子句，根据需要排序检索出的数据。</p><h4 id="排序数据"><a class="header-anchor" href="#排序数据"></a>排序数据</h4><p>SQL 语句返回某个数据库表的单个列。但其输出，并没有特定的顺序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name </span><br><span class="line"><span class="keyword">FROM</span> Products;</span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">prod_name </span></span><br><span class="line"><span class="comment">-------------------</span></span><br><span class="line"><span class="comment">Fish bean bag toy</span></span><br><span class="line"><span class="comment">Bird bean bag toy</span></span><br><span class="line"><span class="comment">Rabbit bean bag toy</span></span><br><span class="line"><span class="comment">8 inch teddy bear</span></span><br><span class="line"><span class="comment">12 inch teddy bear</span></span><br><span class="line"><span class="comment">18 inch teddy bear</span></span><br><span class="line"><span class="comment">Raggedy Ann</span></span><br><span class="line"><span class="comment">King doll</span></span><br><span class="line"><span class="comment">Queen doll</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>其实，检索出的数据并不是随机显示的。如果不排序，数据一般将以它在底层表中出现的顺序显示，这有可能是数据最初添加到表中的顺序。但是，如果数据随后进行过更新或删除，那么这个顺序将会受到 DBMS 重用回收存储空间的方式的影响。因此，如果不明确控制的话，则最终的结果不能（也不应该）依赖该排序顺序。关系数据库设计理论认为，如果不明确规定排序顺序，则不应该假定检索出的数据的顺序有任何意义。</p><blockquote><p>子句：SQL 语句由子句构成，有些子句是必需的，有些则是可选的。一个子句通常由一个关键字加上所提供的数据组成。子句的例子如 <code>SELECT</code> 语句的 <code>FROM</code> 子句。</p></blockquote><p>为了明确地排序用 <code>SELECT</code> 语句检索出的数据，可使用 <code>ORDER BY</code> 子句。<code>ORDER BY</code> 子句取一个或多个列的名字，据此对输出进行排序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name </span><br><span class="line"><span class="keyword">FROM</span> Products </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">prod_name </span></span><br><span class="line"><span class="comment">-------------------</span></span><br><span class="line"><span class="comment">12 inch teddy bear</span></span><br><span class="line"><span class="comment">18 inch teddy bear</span></span><br><span class="line"><span class="comment">8 inch teddy bear</span></span><br><span class="line"><span class="comment">Bird bean bag toy</span></span><br><span class="line"><span class="comment">Fish bean bag toy</span></span><br><span class="line"><span class="comment">King doll</span></span><br><span class="line"><span class="comment">Queen doll</span></span><br><span class="line"><span class="comment">Rabbit bean bag toy</span></span><br><span class="line"><span class="comment">Raggedy Ann</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：在指定一条 <code>ORDER BY</code> 子句时，应该<strong>保证它是 <code>SELECT</code> 语句中最后一条子句</strong>。如果它不是最后的子句，将会出现错误消息</p></blockquote><h4 id="按多个列排序"><a class="header-anchor" href="#按多个列排序"></a>按多个列排序</h4><p>经常需要按不止一个列进行数据排序。例如，如果要显示雇员名单，可能希望按姓和名排序（首先按姓排序，然后在每个姓中再按名排序）。如果多个雇员有相同的姓，这样做很有用。</p><p>要按多个列排序，简单指定列名，列名之间用逗号分开即可（就像选择多个列时那样）。</p><p>下面的代码检索 3 个列，并按其中两个列对结果进行排序——首先按价格，然后按名称排序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_price, prod_name </span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_price, prod_name;</span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">prod_id     prod_price     prod_name </span></span><br><span class="line"><span class="comment">-------     ----------     -------------------- </span></span><br><span class="line"><span class="comment">BNBG02      3.4900         Bird bean bag toy </span></span><br><span class="line"><span class="comment">BNBG01      3.4900         Fish bean bag toy </span></span><br><span class="line"><span class="comment">BNBG03      3.4900         Rabbit bean bag toy </span></span><br><span class="line"><span class="comment">RGAN01      4.9900         Raggedy Ann </span></span><br><span class="line"><span class="comment">BR01        5.9900         8 inch teddy bear </span></span><br><span class="line"><span class="comment">BR02        8.9900         12 inch teddy bear </span></span><br><span class="line"><span class="comment">RYL01       9.4900         King doll </span></span><br><span class="line"><span class="comment">RYL02       9.4900         Queen doll </span></span><br><span class="line"><span class="comment">BR03        11.9900        18 inch teddy bear</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>上述例子中的输出，仅在多个行具有相同的 <code>prod_price</code> 值时才对产品按 <code>prod_name</code> 进行排序。如果 <code>prod_price</code> 列中所有的值都是唯一的，则不会按 <code>prod_name</code> 排序。</p><h4 id="按列位置排序"><a class="header-anchor" href="#按列位置排序"></a>按列位置排序</h4><p>除了能用列名指出排序顺序外，<code>ORDER BY</code> 还支持按相对列位置进行排序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_price, prod_name </span><br><span class="line"><span class="keyword">FROM</span> Products </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="number">2</span>, <span class="number">3</span>;</span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">prod_id     prod_price     prod_name </span></span><br><span class="line"><span class="comment">-------     ----------     -------------------- </span></span><br><span class="line"><span class="comment">BNBG02      3.4900         Bird bean bag toy </span></span><br><span class="line"><span class="comment">BNBG01      3.4900         Fish bean bag toy </span></span><br><span class="line"><span class="comment">BNBG03      3.4900         Rabbit bean bag toy </span></span><br><span class="line"><span class="comment">RGAN01      4.9900         Raggedy Ann </span></span><br><span class="line"><span class="comment">BR01        5.9900         8 inch teddy bear </span></span><br><span class="line"><span class="comment">BR02        8.9900         12 inch teddy bear </span></span><br><span class="line"><span class="comment">RYL01       9.4900         King doll </span></span><br><span class="line"><span class="comment">RYL02       9.4900         Queen doll </span></span><br><span class="line"><span class="comment">BR03        11.9900        18 inch teddy bear</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>ORDER BY 2</code>表示按 <code>SELECT</code> 清单中的第二个列 <code>prod_price</code> 进行排序。<code>ORDER BY 2，3</code> 表示先按 <code>prod_price</code>，再按 <code>prod_name</code> 进行排序。</p><p>这一技术的主要好处在于不用重新输入列名。但它也有缺点。</p><ul><li>首先，不明确给出列名有可能造成错用列名排序。</li><li>其次，在对 <code>SELECT</code> 清单进行更改时容易错误地对数据进行排序（忘记对 <code>ORDER BY</code> 子句做相应的改动）。</li><li>最后，如果进行排序的列不在 <code>SELECT</code> 清单中，显然不能使用这项技术。如果有必要，可以混合使用实际列名和相对列位置。</li></ul><h4 id="指定排序方向"><a class="header-anchor" href="#指定排序方向"></a>指定排序方向</h4><p>数据排序不限于升序排序（从 A 到 Z），这只是默认的排序顺序。还可以使用 <code>ORDER BY</code> 子句进行降序（从 Z 到 A）排序。为了进行降序排序，必须指定 <code>DESC</code> 关键字。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_price, prod_name </span><br><span class="line"><span class="keyword">FROM</span> Products </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_price <span class="keyword">DESC</span>;</span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">prod_id     prod_price     prod_name </span></span><br><span class="line"><span class="comment">-------     ----------     -------------------- </span></span><br><span class="line"><span class="comment">BR03        11.9900        18 inch teddy bear </span></span><br><span class="line"><span class="comment">RYL01       9.4900         King doll </span></span><br><span class="line"><span class="comment">RYL02       9.4900         Queen doll </span></span><br><span class="line"><span class="comment">BR02        8.9900         12 inch teddy bear </span></span><br><span class="line"><span class="comment">BR01        5.9900         8 inch teddy bear </span></span><br><span class="line"><span class="comment">RGAN01      4.9900         Raggedy Ann </span></span><br><span class="line"><span class="comment">BNBG01      3.4900         Fish bean bag toy </span></span><br><span class="line"><span class="comment">BNBG02      3.4900         Bird bean bag toy </span></span><br><span class="line"><span class="comment">BNBG03      3.4900         Rabbit bean bag toy</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_price, prod_name </span><br><span class="line"><span class="keyword">FROM</span> Products </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_price <span class="keyword">DESC</span>, prod_name;</span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">prod_id     prod_price     prod_name </span></span><br><span class="line"><span class="comment">-------     ----------     -------------------- </span></span><br><span class="line"><span class="comment">BR03        11.9900        18 inch teddy bear </span></span><br><span class="line"><span class="comment">RYL01       9.4900         King doll </span></span><br><span class="line"><span class="comment">RYL02       9.4900         Queen doll </span></span><br><span class="line"><span class="comment">BR02        8.9900         12 inch teddy bear</span></span><br><span class="line"><span class="comment">BR01        5.9900         8 inch teddy bear </span></span><br><span class="line"><span class="comment">RGAN01      4.9900         Raggedy Ann </span></span><br><span class="line"><span class="comment">BNBG02      3.4900         Bird bean bag toy </span></span><br><span class="line"><span class="comment">BNBG01      3.4900         Fish bean bag toy </span></span><br><span class="line"><span class="comment">BNBG03      3.4900         Rabbit bean bag toy</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>DESC</code> 关键字只应用到直接位于其前面的列名。在上例中，只对 <code>prod_price</code>列指定 DESC，对 <code>prod_name</code> 列不指定。因此，<code>prod_price</code> 列以降序排序，而 <code>prod_name</code> 列（在每个价格内）仍然按标准的升序排序。</p><p>如果想在多个列上进行降序排序，必须对每一列指定 <code>DESC</code> 关键字。</p><p>请注意，<code>DESC</code> 是 <code>DESCENDING</code> 的缩写，这两个关键字都可以使用。与 <code>DESC</code>相对的是 <code>ASC</code>（或 <code>ASCENDING</code>），在升序排序时可以指定它。但实际上，<code>ASC</code> 没有多大用处，因为升序是默认的（如果既不指定 <code>ASC</code> 也不指定<code>DESC</code>，则假定为 <code>ASC</code>）。</p><h3 id="过滤数据"><a class="header-anchor" href="#过滤数据"></a>过滤数据</h3><p>如何使用 <code>SELECT</code> 语句的 <code>WHERE</code> 子句指定搜索条件</p><h4 id="使用-WHERE-子句"><a class="header-anchor" href="#使用-WHERE-子句"></a>使用 <code>WHERE</code> 子句</h4><p>数据库表一般包含大量的数据，很少需要检索表中的所有行。通常只会根据特定操作或报告的需要提取表数据的子集。只检索所需数据需要指定搜索条件（search criteria），搜索条件也称为过滤条件（filter condition）。</p><p>在 <code>SELECT</code> 语句中，数据根据 <code>WHERE</code> 子句中指定的搜索条件进行过滤。<code>WHERE</code> 子句在表名（<code>FROM</code> 子句）之后给出</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, prod_price </span><br><span class="line"><span class="keyword">FROM</span> Products </span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="operator">=</span> <span class="number">3.49</span>;</span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">prod_name               prod_price</span></span><br><span class="line"><span class="comment">-------------------     ---------- </span></span><br><span class="line"><span class="comment">Fish bean bag toy       3.49 </span></span><br><span class="line"><span class="comment">Bird bean bag toy       3.49 </span></span><br><span class="line"><span class="comment">Rabbit bean bag toy     3.49</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>检查这一列的值是否为指定值，据此过滤数据。不过，SQL 不止能测试等于，还能做更多的事情。</p><blockquote><p>在同时使用 <code>ORDER BY</code> 和 <code>WHERE</code> 子句时，应该让 <code>ORDER BY</code> 位于<code>WHERE</code> 之后，否则将会产生错误</p></blockquote><h4 id="WHERE-子句操作符"><a class="header-anchor" href="#WHERE-子句操作符"></a><code>WHERE</code> 子句操作符</h4><table><thead><tr><th>操作符</th><th>说明</th><th>操作符</th><th>说明</th></tr></thead><tbody><tr><td>=</td><td>等于</td><td>&gt;</td><td>大于</td></tr><tr><td>&lt;&gt;</td><td>不等于</td><td>&gt;=</td><td>大于等于</td></tr><tr><td>!=</td><td>不等于</td><td>!&gt;</td><td>不大于</td></tr><tr><td>&lt;</td><td>小于</td><td>BETEEN</td><td>在指定的两个值之间</td></tr><tr><td>&lt;=</td><td>小于等于</td><td>IS NULL</td><td>为NULL值</td></tr><tr><td>!&lt;</td><td>不小于</td><td></td><td></td></tr></tbody></table><h4 id="检查单个值"><a class="header-anchor" href="#检查单个值"></a>检查单个值</h4><p>列出所有价格小于 10 美元的产品</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, prod_price </span><br><span class="line"><span class="keyword">FROM</span> Products </span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="operator">&lt;</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">/*输出结果</span></span><br><span class="line"><span class="comment">prod_name               prod_price </span></span><br><span class="line"><span class="comment">-------------------     ---------- </span></span><br><span class="line"><span class="comment">Fish bean bag toy       3.49 </span></span><br><span class="line"><span class="comment">Bird bean bag toy       3.49 </span></span><br><span class="line"><span class="comment">Rabbit bean bag toy     3.49 </span></span><br><span class="line"><span class="comment">8 inch teddy bear       5.99 </span></span><br><span class="line"><span class="comment">12 inch teddy bear      8.99 </span></span><br><span class="line"><span class="comment">Raggedy Ann             4.99 </span></span><br><span class="line"><span class="comment">King doll               9.49 </span></span><br><span class="line"><span class="comment">Queen doll              9.49</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="不匹配检查"><a class="header-anchor" href="#不匹配检查"></a>不匹配检查</h4><p>列出所有不是供应商 DLL01 制造的产品</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id, prod_name </span><br><span class="line"><span class="keyword">FROM</span> Products </span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="operator">&lt;&gt;</span> <span class="string">&#x27;DLL01&#x27;</span>;</span><br><span class="line"><span class="comment">/*输出结果</span></span><br><span class="line"><span class="comment">vend_id        prod_name </span></span><br><span class="line"><span class="comment">----------     ------------------ </span></span><br><span class="line"><span class="comment">BRS01          8 inch teddy bear</span></span><br><span class="line"><span class="comment">BRS01          12 inch teddy bear </span></span><br><span class="line"><span class="comment">BRS01          18 inch teddy bear </span></span><br><span class="line"><span class="comment">FNG01          King doll </span></span><br><span class="line"><span class="comment">FNG01          Queen doll</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="范围值检查"><a class="header-anchor" href="#范围值检查"></a>范围值检查</h4><p>要检查某个范围的值，可以使用 <code>BETWEEN</code> 操作符。其语法与其他 <code>WHERE</code>子句的操作符稍有不同，因为它需要两个值，即范围的开始值和结束值。例如，<code>BETWEEN</code> 操作符可用来检索价格在 5 美元和 10 美元之间的所有产品，或在指定的开始日期和结束日期之间的所有日期。</p><p>检索价格在 5 美元和 10美元之间的所有产品</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, prod_price </span><br><span class="line"><span class="keyword">FROM</span> Products </span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="keyword">BETWEEN</span> <span class="number">5</span> <span class="keyword">AND</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">/*输出结果</span></span><br><span class="line"><span class="comment">prod_name               prod_price </span></span><br><span class="line"><span class="comment">-------------------     ---------- </span></span><br><span class="line"><span class="comment">8 inch teddy bear       5.99 </span></span><br><span class="line"><span class="comment">12 inch teddy bear      8.99 </span></span><br><span class="line"><span class="comment">King doll               9.49 </span></span><br><span class="line"><span class="comment">Queen doll              9.49</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在使用 BETWEEN 时，必须指定两个值——所需范围的低端值和高端值。这两个值必须用 AND 关键字分隔。BETWEEN 匹配范围中所有的值，<strong>包括</strong>指定的开始值和结束值。</p><h4 id="空值检查"><a class="header-anchor" href="#空值检查"></a>空值检查</h4><p>在创建表时，表设计人员可以指定其中的列能否不包含值。在一个列不包含值时，称其包含空值 NULL。</p><blockquote><p>NULL ：无值（no value），它与字段包含 0、空字符串或仅仅包含空格不同。</p></blockquote><p>确定值是否为 NULL，不能简单地检查是否= NULL。<code>SELECT</code> 语句有一个特殊的 <code>WHERE</code> 子句，可用来检查具有 NULL 值的列。这个 <code>WHERE</code> 子句就是 <code>IS NULL</code> 子句。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> Products </span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="comment">/*输出结果</span></span><br><span class="line"><span class="comment">prod_name</span></span><br><span class="line"><span class="comment">-------------------</span></span><br><span class="line"><span class="comment">N/A</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name </span><br><span class="line"><span class="keyword">FROM</span> CUSTOMERS </span><br><span class="line"><span class="keyword">WHERE</span> cust_email <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="comment">/*输出结果</span></span><br><span class="line"><span class="comment">cust_name </span></span><br><span class="line"><span class="comment">---------- </span></span><br><span class="line"><span class="comment">Kids Place </span></span><br><span class="line"><span class="comment">The Toy Store</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><blockquote><p>通过过滤选择不包含指定值的所有行时，你可能希望返回含 NULL 值的行。但是这做不到。因为未知（unknown）有特殊的含义，数据库不知道它们是否匹配，所以在进行匹配过滤或非匹配过滤时，不会返回这些结果。</p><p>过滤数据时，一定要验证被过滤列中含 NULL 的行确实出现在返回的数据中。</p></blockquote><h3 id="高级数据过滤"><a class="header-anchor" href="#高级数据过滤"></a>高级数据过滤</h3><p>如何组合 WHERE 子句以建立功能更强、更高级的搜索条件，以及学习如何使用 NOT 和 IN 操作符</p><h4 id="组合-WHERE-子句"><a class="header-anchor" href="#组合-WHERE-子句"></a>组合 <code>WHERE</code> 子句</h4><h5 id="AND操作符"><a class="header-anchor" href="#AND操作符"></a><code>AND</code>操作符</h5><p>要通过不止一个列进行过滤，可以使用 AND 操作符给 WHERE 子句附加条件。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_price, prod_name</span><br><span class="line"><span class="keyword">FROM</span> Products </span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="operator">=</span> <span class="string">&#x27;DLL01&#x27;</span> <span class="keyword">AND</span> prod_price <span class="operator">&lt;=</span> <span class="number">4</span>;</span><br><span class="line"><span class="comment">/*输出结果</span></span><br><span class="line"><span class="comment">prod_id     prod_price   prod_name </span></span><br><span class="line"><span class="comment">-------     ----------   -------------------- </span></span><br><span class="line"><span class="comment">BNBG02      3.49         Bird bean bag toy </span></span><br><span class="line"><span class="comment">BNBG01      3.49         Fish bean bag toy </span></span><br><span class="line"><span class="comment">BNBG03      3.49         Rabbit bean bag toy</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>AND</code> 指示 DBMS 只返回满足所有给定条件的行。</p><h5 id="OR操作符"><a class="header-anchor" href="#OR操作符"></a><code>OR</code>操作符</h5><p><code>OR</code> 操作符与 <code>AND</code> 操作符正好相反，它指示 DBMS 检索匹配任一条件的行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, prod_price </span><br><span class="line"><span class="keyword">FROM</span> Products </span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="operator">=</span> <span class="string">&#x27;DLL01&#x27;</span> <span class="keyword">OR</span> vend_id <span class="operator">=</span> <span class="string">&#x27;BRS01&#x27;</span>;</span><br><span class="line"><span class="comment">/*输出结果</span></span><br><span class="line"><span class="comment">prod_name               prod_price </span></span><br><span class="line"><span class="comment">-------------------     ---------- </span></span><br><span class="line"><span class="comment">8 inch teddy bear    5.99</span></span><br><span class="line"><span class="comment">12 inch teddy bear    8.99</span></span><br><span class="line"><span class="comment">18 inch teddy bear    11.99</span></span><br><span class="line"><span class="comment">Fish bean bag toy    3.49</span></span><br><span class="line"><span class="comment">Bird bean bag toy    3.49</span></span><br><span class="line"><span class="comment">Rabbit bean bag toy  3.49</span></span><br><span class="line"><span class="comment">Raggedy Ann            4.99</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="求值顺序"><a class="header-anchor" href="#求值顺序"></a>求值顺序</h5><p>WHERE 子句可以包含任意数目的 <code>AND</code> 和 <code>OR</code> 操作符。允许两者结合以进行复杂、高级的过滤。</p><p>SQL（像多数语言一样）在处理 <code>OR</code> 操作符前，优先处理 <code>AND</code> 操作符。圆括号具有比 AND 或 OR 操作符更高的求值顺序</p><h4 id="IN-操作符"><a class="header-anchor" href="#IN-操作符"></a><code>IN</code> 操作符</h4><p><code>IN</code> 操作符用来指定条件范围，范围中的每个条件都可以进行匹配。<code>IN</code> 取一组由逗号分隔、括在圆括号中的合法值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, prod_price </span><br><span class="line"><span class="keyword">FROM</span> Products </span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="keyword">IN</span> ( <span class="string">&#x27;DLL01&#x27;</span>, <span class="string">&#x27;BRS01&#x27;</span> ) </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br><span class="line"><span class="comment">/*输出结果</span></span><br><span class="line"><span class="comment">prod_name               prod_price </span></span><br><span class="line"><span class="comment">-------------------     ---------- </span></span><br><span class="line"><span class="comment">12 inch teddy bear      8.99</span></span><br><span class="line"><span class="comment">18 inch teddy bear      11.99</span></span><br><span class="line"><span class="comment">8 inch teddy bear       5.99</span></span><br><span class="line"><span class="comment">Bird bean bag toy       3.49</span></span><br><span class="line"><span class="comment">Fish bean bag toy       3.49</span></span><br><span class="line"><span class="comment">Rabbit bean bag toy     3.49</span></span><br><span class="line"><span class="comment">Raggedy Ann             4.99</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>此 <code>SELECT</code> 语句检索由供应商 DLL01 和 BRS01 制造的所有产品。<code>IN</code> 操作符后跟由逗号分隔的合法值，这些值必须括在圆括号中。</p><p>同样的<code>OR</code>操作符也可以实现</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, prod_price </span><br><span class="line"><span class="keyword">FROM</span> Products </span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="operator">=</span> <span class="string">&#x27;DLL01&#x27;</span> <span class="keyword">OR</span> vend_id <span class="operator">=</span> <span class="string">&#x27;BRS01&#x27;</span> </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br><span class="line"><span class="comment">/*输出结果</span></span><br><span class="line"><span class="comment">prod_name               prod_price </span></span><br><span class="line"><span class="comment">-------------------     ---------- </span></span><br><span class="line"><span class="comment">12 inch teddy bear      8.99</span></span><br><span class="line"><span class="comment">18 inch teddy bear      11.99</span></span><br><span class="line"><span class="comment">8 inch teddy bear       5.99</span></span><br><span class="line"><span class="comment">Bird bean bag toy       3.49</span></span><br><span class="line"><span class="comment">Fish bean bag toy       3.49</span></span><br><span class="line"><span class="comment">Rabbit bean bag toy     3.49</span></span><br><span class="line"><span class="comment">Raggedy Ann             4.99</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>为什么要使用 <code>IN</code> 操作符？其优点如下。</p><ul><li>在有很多合法选项时，<code>IN</code> 操作符的语法更清楚，更直观。</li><li>在与其他 <code>AND</code> 和 <code>OR</code> 操作符组合使用 <code>IN</code> 时，求值顺序更容易管理。</li><li><code>IN</code> 操作符一般比一组 <code>OR</code> 操作符执行得更快（在上面这个合法选项很少的例子中，你看不出性能差异）。</li><li><code>IN</code> 的最大优点是可以包含其他 <code>SELECT</code> 语句，能够更动态地建立<code>WHERE</code> 子句。</li></ul><h4 id="NOT-操作符"><a class="header-anchor" href="#NOT-操作符"></a><code>NOT</code> 操作符</h4><p><code>WHERE</code> 子句中的 <code>NOT</code> 操作符有且只有一个功能，那就是否定其后所跟的任何条件。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name </span><br><span class="line"><span class="keyword">FROM</span> Products </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> vend_id <span class="operator">=</span> <span class="string">&#x27;DLL01&#x27;</span> </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br><span class="line"><span class="comment">/*输出结果</span></span><br><span class="line"><span class="comment">prod_name </span></span><br><span class="line"><span class="comment">------------------ </span></span><br><span class="line"><span class="comment">12 inch teddy bear </span></span><br><span class="line"><span class="comment">18 inch teddy bear </span></span><br><span class="line"><span class="comment">8 inch teddy bear </span></span><br><span class="line"><span class="comment">King doll </span></span><br><span class="line"><span class="comment">Queen doll</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>NOT</code> 否定跟在其后的条件匹配非 DLL01 之外的所有东西</p><blockquote><p>同样也可以使用<code>&lt;&gt;</code>操作符来完成</p><p>对于简单的 <code>WHERE</code> 子句，使用 <code>NOT</code> 确实没有什么优势。但在更复杂的子句中，<code>NOT</code> 是非常有用的。例如，在与 <code>IN</code> 操作符联合使用时，<code>NOT</code> 可以非常简单地找出与条件列表不匹配的行。</p></blockquote><h3 id="用通配符进行过滤"><a class="header-anchor" href="#用通配符进行过滤"></a>用通配符进行过滤</h3><h4 id="LIKE-操作符"><a class="header-anchor" href="#LIKE-操作符"></a><code>LIKE</code> 操作符</h4><p>通配符：用来匹配值的一部分的特殊字符。</p><p>搜索模式：由字面值、通配符或两者组合构成的搜索条件。</p><p>通配符本身实际上是 SQL 的 <code>WHERE</code> 子句中有特殊含义的字符，SQL 支持几种通配符。为在搜索子句中使用通配符，必须使用 LIKE 操作符。<code>LIKE</code>指示 DBMS，后跟的搜索模式利用通配符匹配而不是简单的相等匹配进行比较。</p><p>通配符搜索只能用于文本字段（字符串），非文本数据类型字段不能使用通配符搜索。</p><h5 id="百分号（-）通配符"><a class="header-anchor" href="#百分号（-）通配符"></a>百分号（<code>%</code>）通配符</h5><p>最常使用的通配符是百分号（<code>%</code>）。在搜索串中，<code>%</code>表示任何字符出现任意次数。</p><p>找出所有以词 Fish 起头的产品</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_name  </span><br><span class="line"><span class="keyword">FROM</span> Products  </span><br><span class="line"><span class="keyword">WHERE</span> prod_name <span class="keyword">LIKE</span> <span class="string">&#x27;Fish%&#x27;</span>;</span><br><span class="line"><span class="comment">/*输出结果</span></span><br><span class="line"><span class="comment">prod_id     prod_name  </span></span><br><span class="line"><span class="comment">-------     ------------------    </span></span><br><span class="line"><span class="comment">BNBG01      Fish bean bag toy</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>%</code>告诉 DBMS 接受 Fish 之后的任意字符，不管它有多少字符</p><blockquote><p>区分大小写：根据 DBMS 的不同及其配置，搜索可以是区分大小写的。如果区分大小写，则’fish%'与 Fish bean bag toy 就不匹配。MySQL默认不区分大小写</p></blockquote><p>通配符可在搜索模式中的任意位置使用，并且可以使用多个通配符。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_name  </span><br><span class="line"><span class="keyword">FROM</span> Products  </span><br><span class="line"><span class="keyword">WHERE</span> prod_name <span class="keyword">LIKE</span> <span class="string">&#x27;%bean bag%&#x27;</span>;</span><br><span class="line"><span class="comment">/*输出结果</span></span><br><span class="line"><span class="comment">prod_id      prod_name </span></span><br><span class="line"><span class="comment">--------     --------------------  </span></span><br><span class="line"><span class="comment">BNBG01       Fish bean bag toy  </span></span><br><span class="line"><span class="comment">BNBG02       Bird bean bag toy  </span></span><br><span class="line"><span class="comment">BNBG03       Rabbit bean bag toy</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>搜索模式<code>%bean bag%</code>表示匹配任何位置上包含文本 bean bag 的值，不论它之前或之后出现什么字符。</p><p>通配符也可以出现在搜索模式字符之间。</p><blockquote><p>需要特别注意，除了能匹配一个或多个字符外，<code>%</code>还能匹配 0 个字符。<code>%</code>代表搜索模式中给定位置的 0 个、1 个或多个字符。</p></blockquote><blockquote><p>通配符<code>%</code>看起来像是可以匹配任何东西，但有个例外，这就是 <code>NULL</code>。</p></blockquote><h5 id="下划线（-）通配符"><a class="header-anchor" href="#下划线（-）通配符"></a>下划线（<code>_</code>）通配符</h5><p>另一个有用的通配符是下划线（<code>_</code>）。下划线的用途与<code>%</code>一样，但它只匹配单个字符，而不是多个字符。</p><h4 id="使用通配符的技巧"><a class="header-anchor" href="#使用通配符的技巧"></a>使用通配符的技巧</h4><p>通配符搜索的处理一般要比前面讨论的其他搜索所花时间更长。</p><ul><li>不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。</li><li>在确实需要使用通配符时，也尽量不要把它们用在搜索模式的开始处。把通配符置于开始处，搜索起来是最慢的。</li><li>仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据。</li></ul><h3 id="用正则表达式进行搜索"><a class="header-anchor" href="#用正则表达式进行搜索"></a>用正则表达式进行搜索</h3><p>正则表达式是用来匹配文本的特殊的串（字符集合）</p><p>MySQL用<code>WHERE</code>子句对正则表达式提供了初步的支持，允许你指定正则表达式，过滤<code>SELECT</code>检索出的数据。</p><h4 id="基本字符匹配"><a class="header-anchor" href="#基本字符匹配"></a>基本字符匹配</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name REGEXP <span class="string">&#x27;12&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br><span class="line"><span class="comment">/*输出结果</span></span><br><span class="line"><span class="comment">prod_name</span></span><br><span class="line"><span class="comment">-------=</span></span><br><span class="line"><span class="comment">12 inch teddy bear</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>除关键字<code>LIKE</code>被<code>REGEXP</code>替代外，这条语句看上去非常像使用<code>LIKE</code>的语句。</p><p>它告诉MySQL：<code>REGEXP</code>后所跟的东西作为正则表达式处理。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name REGEXP <span class="string">&#x27;1. inch teddy bear&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br><span class="line"><span class="comment">/*输出结果</span></span><br><span class="line"><span class="comment">prod_name</span></span><br><span class="line"><span class="comment">-------=</span></span><br><span class="line"><span class="comment">12 inch teddy bear</span></span><br><span class="line"><span class="comment">18 inch teddy bear</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>.</code>是正则表达式语言中一个特殊的字符，它表示匹配任意一个字符</p><h4 id="进行OR匹配"><a class="header-anchor" href="#进行OR匹配"></a>进行OR匹配</h4><p>为搜索两个串之一（或者为这个串，或者为另一个串），使用<code>|</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name REGEXP <span class="string">&#x27;12|18&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br><span class="line"><span class="comment">/*输出结果</span></span><br><span class="line"><span class="comment">prod_name</span></span><br><span class="line"><span class="comment">-------=</span></span><br><span class="line"><span class="comment">12 inch teddy bear</span></span><br><span class="line"><span class="comment">18 inch teddy bear</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>使用|从功能上类似于在<code>SELECT</code>语句中使用<code>OR</code>语句，多个OR条件可并入单个正则表达式。</p><h4 id="匹配几个字符之一"><a class="header-anchor" href="#匹配几个字符之一"></a>匹配几个字符之一</h4><p>匹配任何单一字符。但是，如果你只想匹配特定的字符，怎么办？可通过指定一组用<code>[]</code>括起来的字符来完成，如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name REGEXP <span class="string">&#x27;[128] inch&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br><span class="line"><span class="comment">/*输出结果</span></span><br><span class="line"><span class="comment">prod_name</span></span><br><span class="line"><span class="comment">-------=</span></span><br><span class="line"><span class="comment">12 inch teddy bear</span></span><br><span class="line"><span class="comment">18 inch teddy bear</span></span><br><span class="line"><span class="comment">8 inch teddy bear</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>[128]</code>定义一组字符，的意思是匹配包含1或2或8</p><h4 id="匹配范围"><a class="header-anchor" href="#匹配范围"></a>匹配范围</h4><p>集合可用来定义要匹配的一个或多个字符，如<code>[0-9]</code>、<code>[a-z]</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name REGEXP <span class="string">&#x27;[1-7] inch&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br><span class="line"><span class="comment">/*输出结果</span></span><br><span class="line"><span class="comment">prod_name</span></span><br><span class="line"><span class="comment">--------</span></span><br><span class="line"><span class="comment">12 inch teddy bear</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="匹配特殊字符"><a class="header-anchor" href="#匹配特殊字符"></a>匹配特殊字符</h4><p>正则表达式使用中会占据一些字符，例如<code>.</code>、<code>|</code>等，如果要匹配这些字符则需要转义使用<code>\\</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_name</span><br><span class="line"><span class="keyword">FROM</span> vendors</span><br><span class="line"><span class="keyword">WHERE</span> vend_name REGEXP <span class="string">&#x27;\\.&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name;</span><br><span class="line"><span class="comment">/*输出结果</span></span><br><span class="line"><span class="comment">vend_name</span></span><br><span class="line"><span class="comment">--------</span></span><br><span class="line"><span class="comment">Doll House Inc.</span></span><br><span class="line"><span class="comment">Furball Inc.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>\\</code>也用来引用元字符（具有特殊含义的字符）</p><table><thead><tr><th>字符</th><th>说明</th></tr></thead><tbody><tr><td><code>\\f</code></td><td>换页</td></tr><tr><td><code>\\n</code></td><td>换行</td></tr><tr><td><code>\\r</code></td><td>回车</td></tr><tr><td><code>\\t</code></td><td>制表</td></tr><tr><td><code>\\v</code></td><td>纵向制表</td></tr><tr><td><code>\\\</code></td><td>反斜杠（<code>\</code>）字符本身</td></tr></tbody></table><h4 id="匹配字符类"><a class="header-anchor" href="#匹配字符类"></a>匹配字符类</h4><p>存在找出你自己经常使用的数字、所有字母字符或所有数字字母字符等的匹配。为更方便工作，可以使用预定义的字符集，称为字符类</p><table><thead><tr><th>类</th><th>说明</th></tr></thead><tbody><tr><td><code>[:alnum:]</code></td><td>任意字母和数字（同<code>[a-zA-Z0-9]</code>）</td></tr><tr><td><code>[:alpha:]</code></td><td>任意字符（同<code>[a-zA-Z]</code>）</td></tr><tr><td><code>[:blank:]</code></td><td>空格和制表（同<code>[\\t]</code>）</td></tr><tr><td><code>[:cntrl:]</code></td><td>ASCII控制字符（ASCII 0到31和127）</td></tr><tr><td><code>[:digit:]</code></td><td>任意数字（同<code>[0-9]</code>）</td></tr><tr><td><code>[:graph:]</code></td><td>与<code>[:print:]</code>相同，但不包括空格</td></tr><tr><td><code>[:lower:]</code></td><td>任意小写字母（同<code>[a-z]</code>）</td></tr><tr><td><code>[:print:]</code></td><td>任意可打印字符</td></tr><tr><td><code>[:punct:]</code></td><td>既不在<code>[:alnum:]</code>又不在<code>[:cntrl:]</code>中的任意字符</td></tr><tr><td><code>[:space:]</code></td><td>包括空格在内的任意空白字符（同<code>[\\f\\n\\r\\t\\v]</code>）</td></tr><tr><td><code>[:upper:]</code></td><td>任意大写字母（同<code>[A-Z]</code>）</td></tr><tr><td><code>[:xdigit:]</code></td><td>任意十六进制数字（同<code>[a-fA-F0-9]</code>）</td></tr></tbody></table><h4 id="匹配多个实例"><a class="header-anchor" href="#匹配多个实例"></a>匹配多个实例</h4><p>你可能需要寻找所有的数，不管数中包含多少数字，或者你可能想寻找一个单词并且还能够适应一个尾随的s（如果存在），等等。</p><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td><code>*</code></td><td>0个或多个匹配</td></tr><tr><td><code>+</code></td><td>1个或多个匹配（等于<code>&#123;1,&#125;</code>）</td></tr><tr><td><code>？</code></td><td>0个或1个匹配（等于<code>&#123;0,1&#125;</code>）</td></tr><tr><td><code>&#123;n&#125;</code></td><td>指定数目的匹配</td></tr><tr><td><code>&#123;n,&#125;</code></td><td>不少于指定数目的匹配</td></tr><tr><td><code>&#123;n,m&#125;</code></td><td>匹配数目的范围（m不超过255）</td></tr></tbody></table><h4 id="定位符"><a class="header-anchor" href="#定位符"></a>定位符</h4><p>匹配特定位置的文本</p><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td><code>^</code></td><td>文本的开始</td></tr><tr><td><code>$</code></td><td>文本的结尾</td></tr><tr><td><code>[[:&lt;:]]</code></td><td>词的开始</td></tr><tr><td><code>[[:&gt;:]]</code></td><td>词的结尾</td></tr></tbody></table><h3 id="数据库定义语言（DDL）"><a class="header-anchor" href="#数据库定义语言（DDL）"></a>数据库定义语言（DDL）</h3><h4 id="操作数据库"><a class="header-anchor" href="#操作数据库"></a>操作数据库</h4><p>CRUD：增(Create)查(Retrieve)改(Update)删(Delete)</p><h5 id="查-Retrieve"><a class="header-anchor" href="#查-Retrieve"></a>查(Retrieve)</h5><p><code>SHOW DATABASES;</code>查询所有数据库的名称</p><p><code>SHOW CREATE DATABASE &lt;数据库名称&gt;;</code>查询某个数据库的字符集(查询某个数据库的创建语句)</p><h5 id="增-Create"><a class="header-anchor" href="#增-Create"></a>增(Create)</h5><p><code>CREATE DATABASE &lt;数据库名称&gt;;</code>创建数据库</p><p><code>CREATE DATABASE IF NOT EXISTS &lt;数据库名称&gt;;</code>创建前先进行判断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE IF NOT EXISTS &lt;数据库名称&gt; CHARACTER SET &lt;字符集&gt;;-- 创建指定字符集数据库</span><br></pre></td></tr></table></figure><h5 id="改-Update"><a class="header-anchor" href="#改-Update"></a>改(Update)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER DATABASE &lt;数据库名称&gt; CHARACTER SET utf8;</span><br></pre></td></tr></table></figure><h5 id="删-Delete"><a class="header-anchor" href="#删-Delete"></a>删(Delete)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP DATABASE IF EXISTS &lt;数据库名称&gt;;</span><br></pre></td></tr></table></figure><h4 id="操作表"><a class="header-anchor" href="#操作表"></a>操作表</h4><h3 id="数据库操作语言（DML）"><a class="header-anchor" href="#数据库操作语言（DML）"></a>数据库操作语言（DML）</h3><h3 id="数据库查询语言（DQL）"><a class="header-anchor" href="#数据库查询语言（DQL）"></a>数据库查询语言（DQL）</h3><p>查询表中的数据</p><h4 id="基础查询"><a class="header-anchor" href="#基础查询"></a>基础查询</h4><p>语法：<code>SELECT 查询列表 FROM 表名;</code></p><blockquote><p>可以查询表中的字段、常量值、表达式、函数</p><p>查询结果是一个虚拟的表格</p></blockquote><p><strong>查询表中的单个字段</strong></p><p>实例<code>SELECT last_name FROM employees;</code></p><p><strong>查询表中的多个字段</strong></p><p>实例<code>SELECT last_name,salary,email FROM employees;</code></p><p><strong>查询表中的所有字段</strong></p><p><code>SELECT * FROM employees;</code></p><h3 id="数据库控制语言（DCL）"><a class="header-anchor" href="#数据库控制语言（DCL）"></a>数据库控制语言（DCL）</h3><h2 id="示例数据"><a class="header-anchor" href="#示例数据"></a>示例数据</h2><p>建表语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- -----------------------------------------</span></span><br><span class="line"><span class="comment">-- Sams Teach Yourself SQL in 10 Minutes</span></span><br><span class="line"><span class="comment">-- http://forta.com/books/0672336073/</span></span><br><span class="line"><span class="comment">-- Example table creation scripts for MySQL.</span></span><br><span class="line"><span class="comment">-- -----------------------------------------</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------</span></span><br><span class="line"><span class="comment">-- Create Customers table</span></span><br><span class="line"><span class="comment">-- ----------------------</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Customers</span><br><span class="line">(</span><br><span class="line">  cust_id      <span class="type">char</span>(<span class="number">10</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">  cust_name    <span class="type">char</span>(<span class="number">50</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">  cust_address <span class="type">char</span>(<span class="number">50</span>)  <span class="keyword">NULL</span> ,</span><br><span class="line">  cust_city    <span class="type">char</span>(<span class="number">50</span>)  <span class="keyword">NULL</span> ,</span><br><span class="line">  cust_state   <span class="type">char</span>(<span class="number">5</span>)   <span class="keyword">NULL</span> ,</span><br><span class="line">  cust_zip     <span class="type">char</span>(<span class="number">10</span>)  <span class="keyword">NULL</span> ,</span><br><span class="line">  cust_country <span class="type">char</span>(<span class="number">50</span>)  <span class="keyword">NULL</span> ,</span><br><span class="line">  cust_contact <span class="type">char</span>(<span class="number">50</span>)  <span class="keyword">NULL</span> ,</span><br><span class="line">  cust_email   <span class="type">char</span>(<span class="number">255</span>) <span class="keyword">NULL</span> </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- -----------------------</span></span><br><span class="line"><span class="comment">-- Create OrderItems table</span></span><br><span class="line"><span class="comment">-- -----------------------</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> OrderItems</span><br><span class="line">(</span><br><span class="line">  order_num  <span class="type">int</span>          <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">  order_item <span class="type">int</span>          <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">  prod_id    <span class="type">char</span>(<span class="number">10</span>)     <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">  quantity   <span class="type">int</span>          <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">  item_price <span class="type">decimal</span>(<span class="number">8</span>,<span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- -------------------</span></span><br><span class="line"><span class="comment">-- Create Orders table</span></span><br><span class="line"><span class="comment">-- -------------------</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Orders</span><br><span class="line">(</span><br><span class="line">  order_num  <span class="type">int</span>      <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">  order_date datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">  cust_id    <span class="type">char</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ---------------------</span></span><br><span class="line"><span class="comment">-- Create Products table</span></span><br><span class="line"><span class="comment">-- ---------------------</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Products</span><br><span class="line">(</span><br><span class="line">  prod_id    <span class="type">char</span>(<span class="number">10</span>)      <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">  vend_id    <span class="type">char</span>(<span class="number">10</span>)      <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">  prod_name  <span class="type">char</span>(<span class="number">255</span>)     <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">  prod_price <span class="type">decimal</span>(<span class="number">8</span>,<span class="number">2</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">  prod_desc  text          <span class="keyword">NULL</span> </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- --------------------</span></span><br><span class="line"><span class="comment">-- Create Vendors table</span></span><br><span class="line"><span class="comment">-- --------------------</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Vendors</span><br><span class="line">(</span><br><span class="line">  vend_id      <span class="type">char</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">  vend_name    <span class="type">char</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">  vend_address <span class="type">char</span>(<span class="number">50</span>) <span class="keyword">NULL</span> ,</span><br><span class="line">  vend_city    <span class="type">char</span>(<span class="number">50</span>) <span class="keyword">NULL</span> ,</span><br><span class="line">  vend_state   <span class="type">char</span>(<span class="number">5</span>)  <span class="keyword">NULL</span> ,</span><br><span class="line">  vend_zip     <span class="type">char</span>(<span class="number">10</span>) <span class="keyword">NULL</span> ,</span><br><span class="line">  vend_country <span class="type">char</span>(<span class="number">50</span>) <span class="keyword">NULL</span> </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- -------------------</span></span><br><span class="line"><span class="comment">-- Define primary keys</span></span><br><span class="line"><span class="comment">-- -------------------</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Customers <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY (cust_id);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> OrderItems <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY (order_num, order_item);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Orders <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY (order_num);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Products <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY (prod_id);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Vendors <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY (vend_id);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- -------------------</span></span><br><span class="line"><span class="comment">-- Define foreign keys</span></span><br><span class="line"><span class="comment">-- -------------------</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> OrderItems <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> FK_OrderItems_Orders <span class="keyword">FOREIGN</span> KEY (order_num) <span class="keyword">REFERENCES</span> Orders (order_num);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> OrderItems <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> FK_OrderItems_Products <span class="keyword">FOREIGN</span> KEY (prod_id) <span class="keyword">REFERENCES</span> Products (prod_id);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Orders <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> FK_Orders_Customers <span class="keyword">FOREIGN</span> KEY (cust_id) <span class="keyword">REFERENCES</span> Customers (cust_id);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Products <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> FK_Products_Vendors <span class="keyword">FOREIGN</span> KEY (vend_id) <span class="keyword">REFERENCES</span> Vendors (vend_id);</span><br></pre></td></tr></table></figure><p>具体数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- -------------------------------------------</span></span><br><span class="line"><span class="comment">-- Sams Teach Yourself SQL in 10 Minutes</span></span><br><span class="line"><span class="comment">-- http://forta.com/books/0672336073/</span></span><br><span class="line"><span class="comment">-- Example table population scripts for MySQL.</span></span><br><span class="line"><span class="comment">-- -------------------------------------------</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- ------------------------</span></span><br><span class="line"><span class="comment">-- Populate Customers table</span></span><br><span class="line"><span class="comment">-- ------------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Customers(cust_id, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact, cust_email)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;1000000001&#x27;</span>, <span class="string">&#x27;Village Toys&#x27;</span>, <span class="string">&#x27;200 Maple Lane&#x27;</span>, <span class="string">&#x27;Detroit&#x27;</span>, <span class="string">&#x27;MI&#x27;</span>, <span class="string">&#x27;44444&#x27;</span>, <span class="string">&#x27;USA&#x27;</span>, <span class="string">&#x27;John Smith&#x27;</span>, <span class="string">&#x27;sales@villagetoys.com&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Customers(cust_id, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;1000000002&#x27;</span>, <span class="string">&#x27;Kids Place&#x27;</span>, <span class="string">&#x27;333 South Lake Drive&#x27;</span>, <span class="string">&#x27;Columbus&#x27;</span>, <span class="string">&#x27;OH&#x27;</span>, <span class="string">&#x27;43333&#x27;</span>, <span class="string">&#x27;USA&#x27;</span>, <span class="string">&#x27;Michelle Green&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Customers(cust_id, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact, cust_email)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;1000000003&#x27;</span>, <span class="string">&#x27;Fun4All&#x27;</span>, <span class="string">&#x27;1 Sunny Place&#x27;</span>, <span class="string">&#x27;Muncie&#x27;</span>, <span class="string">&#x27;IN&#x27;</span>, <span class="string">&#x27;42222&#x27;</span>, <span class="string">&#x27;USA&#x27;</span>, <span class="string">&#x27;Jim Jones&#x27;</span>, <span class="string">&#x27;jjones@fun4all.com&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Customers(cust_id, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact, cust_email)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;1000000004&#x27;</span>, <span class="string">&#x27;Fun4All&#x27;</span>, <span class="string">&#x27;829 Riverside Drive&#x27;</span>, <span class="string">&#x27;Phoenix&#x27;</span>, <span class="string">&#x27;AZ&#x27;</span>, <span class="string">&#x27;88888&#x27;</span>, <span class="string">&#x27;USA&#x27;</span>, <span class="string">&#x27;Denise L. Stephens&#x27;</span>, <span class="string">&#x27;dstephens@fun4all.com&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Customers(cust_id, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;1000000005&#x27;</span>, <span class="string">&#x27;The Toy Store&#x27;</span>, <span class="string">&#x27;4545 53rd Street&#x27;</span>, <span class="string">&#x27;Chicago&#x27;</span>, <span class="string">&#x27;IL&#x27;</span>, <span class="string">&#x27;54545&#x27;</span>, <span class="string">&#x27;USA&#x27;</span>, <span class="string">&#x27;Kim Howard&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------</span></span><br><span class="line"><span class="comment">-- Populate Vendors table</span></span><br><span class="line"><span class="comment">-- ----------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Vendors(vend_id, vend_name, vend_address, vend_city, vend_state, vend_zip, vend_country)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;BRS01&#x27;</span>,<span class="string">&#x27;Bears R Us&#x27;</span>,<span class="string">&#x27;123 Main Street&#x27;</span>,<span class="string">&#x27;Bear Town&#x27;</span>,<span class="string">&#x27;MI&#x27;</span>,<span class="string">&#x27;44444&#x27;</span>, <span class="string">&#x27;USA&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Vendors(vend_id, vend_name, vend_address, vend_city, vend_state, vend_zip, vend_country)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;BRE02&#x27;</span>,<span class="string">&#x27;Bear Emporium&#x27;</span>,<span class="string">&#x27;500 Park Street&#x27;</span>,<span class="string">&#x27;Anytown&#x27;</span>,<span class="string">&#x27;OH&#x27;</span>,<span class="string">&#x27;44333&#x27;</span>, <span class="string">&#x27;USA&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Vendors(vend_id, vend_name, vend_address, vend_city, vend_state, vend_zip, vend_country)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;DLL01&#x27;</span>,<span class="string">&#x27;Doll House Inc.&#x27;</span>,<span class="string">&#x27;555 High Street&#x27;</span>,<span class="string">&#x27;Dollsville&#x27;</span>,<span class="string">&#x27;CA&#x27;</span>,<span class="string">&#x27;99999&#x27;</span>, <span class="string">&#x27;USA&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Vendors(vend_id, vend_name, vend_address, vend_city, vend_state, vend_zip, vend_country)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;FRB01&#x27;</span>,<span class="string">&#x27;Furball Inc.&#x27;</span>,<span class="string">&#x27;1000 5th Avenue&#x27;</span>,<span class="string">&#x27;New York&#x27;</span>,<span class="string">&#x27;NY&#x27;</span>,<span class="string">&#x27;11111&#x27;</span>, <span class="string">&#x27;USA&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Vendors(vend_id, vend_name, vend_address, vend_city, vend_state, vend_zip, vend_country)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;FNG01&#x27;</span>,<span class="string">&#x27;Fun and Games&#x27;</span>,<span class="string">&#x27;42 Galaxy Road&#x27;</span>,<span class="string">&#x27;London&#x27;</span>, <span class="keyword">NULL</span>,<span class="string">&#x27;N16 6PS&#x27;</span>, <span class="string">&#x27;England&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Vendors(vend_id, vend_name, vend_address, vend_city, vend_state, vend_zip, vend_country)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;JTS01&#x27;</span>,<span class="string">&#x27;Jouets et ours&#x27;</span>,<span class="string">&#x27;1 Rue Amusement&#x27;</span>,<span class="string">&#x27;Paris&#x27;</span>, <span class="keyword">NULL</span>,<span class="string">&#x27;45678&#x27;</span>, <span class="string">&#x27;France&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- -----------------------</span></span><br><span class="line"><span class="comment">-- Populate Products table</span></span><br><span class="line"><span class="comment">-- -----------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Products(prod_id, vend_id, prod_name, prod_price, prod_desc)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;BR01&#x27;</span>, <span class="string">&#x27;BRS01&#x27;</span>, <span class="string">&#x27;8 inch teddy bear&#x27;</span>, <span class="number">5.99</span>, <span class="string">&#x27;8 inch teddy bear, comes with cap and jacket&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Products(prod_id, vend_id, prod_name, prod_price, prod_desc)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;BR02&#x27;</span>, <span class="string">&#x27;BRS01&#x27;</span>, <span class="string">&#x27;12 inch teddy bear&#x27;</span>, <span class="number">8.99</span>, <span class="string">&#x27;12 inch teddy bear, comes with cap and jacket&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Products(prod_id, vend_id, prod_name, prod_price, prod_desc)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;BR03&#x27;</span>, <span class="string">&#x27;BRS01&#x27;</span>, <span class="string">&#x27;18 inch teddy bear&#x27;</span>, <span class="number">11.99</span>, <span class="string">&#x27;18 inch teddy bear, comes with cap and jacket&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Products(prod_id, vend_id, prod_name, prod_price, prod_desc)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;BNBG01&#x27;</span>, <span class="string">&#x27;DLL01&#x27;</span>, <span class="string">&#x27;Fish bean bag toy&#x27;</span>, <span class="number">3.49</span>, <span class="string">&#x27;Fish bean bag toy, complete with bean bag worms with which to feed it&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Products(prod_id, vend_id, prod_name, prod_price, prod_desc)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;BNBG02&#x27;</span>, <span class="string">&#x27;DLL01&#x27;</span>, <span class="string">&#x27;Bird bean bag toy&#x27;</span>, <span class="number">3.49</span>, <span class="string">&#x27;Bird bean bag toy, eggs are not included&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Products(prod_id, vend_id, prod_name, prod_price, prod_desc)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;BNBG03&#x27;</span>, <span class="string">&#x27;DLL01&#x27;</span>, <span class="string">&#x27;Rabbit bean bag toy&#x27;</span>, <span class="number">3.49</span>, <span class="string">&#x27;Rabbit bean bag toy, comes with bean bag carrots&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Products(prod_id, vend_id, prod_name, prod_price, prod_desc)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;RGAN01&#x27;</span>, <span class="string">&#x27;DLL01&#x27;</span>, <span class="string">&#x27;Raggedy Ann&#x27;</span>, <span class="number">4.99</span>, <span class="string">&#x27;18 inch Raggedy Ann doll&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Products(prod_id, vend_id, prod_name, prod_price, prod_desc)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;RYL01&#x27;</span>, <span class="string">&#x27;FNG01&#x27;</span>, <span class="string">&#x27;King doll&#x27;</span>, <span class="number">9.49</span>, <span class="string">&#x27;12 inch king doll with royal garments and crown&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Products(prod_id, vend_id, prod_name, prod_price, prod_desc)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;RYL02&#x27;</span>, <span class="string">&#x27;FNG01&#x27;</span>, <span class="string">&#x27;Queen doll&#x27;</span>, <span class="number">9.49</span>, <span class="string">&#x27;12 inch queen doll with royal garments and crown&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ---------------------</span></span><br><span class="line"><span class="comment">-- Populate Orders table</span></span><br><span class="line"><span class="comment">-- ---------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Orders(order_num, order_date, cust_id)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">20005</span>, <span class="string">&#x27;2012-05-01&#x27;</span>, <span class="string">&#x27;1000000001&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Orders(order_num, order_date, cust_id)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">20006</span>, <span class="string">&#x27;2012-01-12&#x27;</span>, <span class="string">&#x27;1000000003&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Orders(order_num, order_date, cust_id)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">20007</span>, <span class="string">&#x27;2012-01-30&#x27;</span>, <span class="string">&#x27;1000000004&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Orders(order_num, order_date, cust_id)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">20008</span>, <span class="string">&#x27;2012-02-03&#x27;</span>, <span class="string">&#x27;1000000005&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Orders(order_num, order_date, cust_id)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">20009</span>, <span class="string">&#x27;2012-02-08&#x27;</span>, <span class="string">&#x27;1000000001&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- -------------------------</span></span><br><span class="line"><span class="comment">-- Populate OrderItems table</span></span><br><span class="line"><span class="comment">-- -------------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> OrderItems(order_num, order_item, prod_id, quantity, item_price)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">20005</span>, <span class="number">1</span>, <span class="string">&#x27;BR01&#x27;</span>, <span class="number">100</span>, <span class="number">5.49</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> OrderItems(order_num, order_item, prod_id, quantity, item_price)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">20005</span>, <span class="number">2</span>, <span class="string">&#x27;BR03&#x27;</span>, <span class="number">100</span>, <span class="number">10.99</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> OrderItems(order_num, order_item, prod_id, quantity, item_price)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">20006</span>, <span class="number">1</span>, <span class="string">&#x27;BR01&#x27;</span>, <span class="number">20</span>, <span class="number">5.99</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> OrderItems(order_num, order_item, prod_id, quantity, item_price)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">20006</span>, <span class="number">2</span>, <span class="string">&#x27;BR02&#x27;</span>, <span class="number">10</span>, <span class="number">8.99</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> OrderItems(order_num, order_item, prod_id, quantity, item_price)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">20006</span>, <span class="number">3</span>, <span class="string">&#x27;BR03&#x27;</span>, <span class="number">10</span>, <span class="number">11.99</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> OrderItems(order_num, order_item, prod_id, quantity, item_price)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">20007</span>, <span class="number">1</span>, <span class="string">&#x27;BR03&#x27;</span>, <span class="number">50</span>, <span class="number">11.49</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> OrderItems(order_num, order_item, prod_id, quantity, item_price)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">20007</span>, <span class="number">2</span>, <span class="string">&#x27;BNBG01&#x27;</span>, <span class="number">100</span>, <span class="number">2.99</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> OrderItems(order_num, order_item, prod_id, quantity, item_price)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">20007</span>, <span class="number">3</span>, <span class="string">&#x27;BNBG02&#x27;</span>, <span class="number">100</span>, <span class="number">2.99</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> OrderItems(order_num, order_item, prod_id, quantity, item_price)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">20007</span>, <span class="number">4</span>, <span class="string">&#x27;BNBG03&#x27;</span>, <span class="number">100</span>, <span class="number">2.99</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> OrderItems(order_num, order_item, prod_id, quantity, item_price)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">20007</span>, <span class="number">5</span>, <span class="string">&#x27;RGAN01&#x27;</span>, <span class="number">50</span>, <span class="number">4.49</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> OrderItems(order_num, order_item, prod_id, quantity, item_price)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">20008</span>, <span class="number">1</span>, <span class="string">&#x27;RGAN01&#x27;</span>, <span class="number">5</span>, <span class="number">4.99</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> OrderItems(order_num, order_item, prod_id, quantity, item_price)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">20008</span>, <span class="number">2</span>, <span class="string">&#x27;BR03&#x27;</span>, <span class="number">5</span>, <span class="number">11.99</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> OrderItems(order_num, order_item, prod_id, quantity, item_price)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">20008</span>, <span class="number">3</span>, <span class="string">&#x27;BNBG01&#x27;</span>, <span class="number">10</span>, <span class="number">3.49</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> OrderItems(order_num, order_item, prod_id, quantity, item_price)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">20008</span>, <span class="number">4</span>, <span class="string">&#x27;BNBG02&#x27;</span>, <span class="number">10</span>, <span class="number">3.49</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> OrderItems(order_num, order_item, prod_id, quantity, item_price)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">20008</span>, <span class="number">5</span>, <span class="string">&#x27;BNBG03&#x27;</span>, <span class="number">10</span>, <span class="number">3.49</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> OrderItems(order_num, order_item, prod_id, quantity, item_price)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">20009</span>, <span class="number">1</span>, <span class="string">&#x27;BNBG01&#x27;</span>, <span class="number">250</span>, <span class="number">2.49</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> OrderItems(order_num, order_item, prod_id, quantity, item_price)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">20009</span>, <span class="number">2</span>, <span class="string">&#x27;BNBG02&#x27;</span>, <span class="number">250</span>, <span class="number">2.49</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> OrderItems(order_num, order_item, prod_id, quantity, item_price)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">20009</span>, <span class="number">3</span>, <span class="string">&#x27;BNBG03&#x27;</span>, <span class="number">250</span>, <span class="number">2.49</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>细胞生物学复习整理</title>
      <link href="2020/06/24/%E7%BB%86%E8%83%9E%E7%94%9F%E7%89%A9%E5%AD%A6/"/>
      <url>2020/06/24/%E7%BB%86%E8%83%9E%E7%94%9F%E7%89%A9%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<p>选择、名词解释、问答题 以下内容仅供参考</p><hr><h2 id="绪论"><a class="header-anchor" href="#绪论"></a>绪论</h2><h3 id="名词解释"><a class="header-anchor" href="#名词解释"></a>名词解释</h3><p><strong>细胞生物学</strong>：细胞生物学是研究和揭示细胞基本生命活动规律的科学，它从显微、亚显微与分子水平上研究细胞结构与功能，细胞增殖、分化、代谢、运动、衰老、死亡，以及细胞信号转导，细胞基因表达与调控，细胞起源与进化等重大生命过程。</p><p><strong>细胞</strong>：细胞是生物体结构与功能的基本单位。</p><p><strong>细胞学说</strong>：细胞学说是由施旺和施莱登两人共同提出，并由一系列的学者进行修正的学说，其基本内容包括：细胞是有机体，一切动植物都是由细胞发育而来，并由细胞和细胞产物构成；每个细胞是一个相对独立的单位，既有“它自己”的生命，又对与其他细胞共同组成的整体的生命有所助益；新的细胞可以通过已存在的细胞繁殖产生。</p><h3 id="问答题"><a class="header-anchor" href="#问答题"></a>问答题</h3><h4 id="细胞生物学的发展历史大致可划分为哪几个阶段"><a class="header-anchor" href="#细胞生物学的发展历史大致可划分为哪几个阶段"></a>细胞生物学的发展历史大致可划分为哪几个阶段</h4><p>细胞生物学的发展大致可划分为5个阶段：</p><ul><li>细胞的发现</li><li>细胞学说的建立</li><li>细胞学的经典时期</li><li>实验细胞学与细胞学的分支及其发展</li><li>细胞生物学学科的形成与发展</li></ul><h4 id="如何理解细胞是生命活动的基本单位"><a class="header-anchor" href="#如何理解细胞是生命活动的基本单位"></a>如何理解细胞是生命活动的基本单位</h4><ul><li>细胞是构成有机体的基本单位；</li><li>细胞是代谢与功能的基本单位；</li><li>细胞是有机体生长与发育的基础；</li><li>细胞是繁殖的基本单位，是遗传的桥梁；</li><li>细胞是生命起源的归宿，是生物进化的起点。</li></ul><p>故细胞是生命活动的基本单位。</p><h4 id="比较真核细胞与原核细胞"><a class="header-anchor" href="#比较真核细胞与原核细胞"></a>比较真核细胞与原核细胞</h4><p>真核细胞与原核细胞最根本的区别可以归纳为两条：</p><ul><li>生物膜系统的分化与演变：</li></ul><p>​       真核细胞以膜系统的分化为基础，首先分化为两个独立的部分——细胞核与细胞质，细胞质内又以膜系统为基础分隔为结构更精细、功能更专一的单位——各种重要的细胞器。细胞内部结构与职能的分工是真核细胞区别于原核细胞的重要标志。细胞骨架为细胞内部空间布局提供了支架。</p><ul><li>遗传信息量与遗传装置的扩增与复杂化：<ul><li>真核细胞的基因组一般远远大于原核细胞的，作为遗传信息载体的DNA 也由原核细胞的环状单倍性变为线状多倍性；</li><li>原核细胞基因表达的调控主要以操纵子的形式来进行，这种简单的调控方式能适应多种不利环境，进行快速调节，真核细胞因细胞核的存在，使表达实现了多层次调控；</li><li>真核生物有不编码任何蛋白质或RNA 的基因间隔序列和内含子；</li><li>真核细胞拥有多条DNA 分子， 并且DNA 与蛋白质形成交替存在的染色质和染色体；</li><li>真核细胞发展出一整套由酶和调控蛋白组成的复杂精密的体系，严格调控细胞增殖，原核细胞的增殖没有严格阶段，也没有染色质与染色体结构的交替，更无纺锤体的出现。</li></ul></li></ul><h4 id="病毒与细胞在起源上的可能关系有几种？目前哪种观点更有说服力，有哪些证据？"><a class="header-anchor" href="#病毒与细胞在起源上的可能关系有几种？目前哪种观点更有说服力，有哪些证据？"></a>病毒与细胞在起源上的可能关系有几种？目前哪种观点更有说服力，有哪些证据？</h4><p>起源上目前存在3种主要观点：</p><ul><li>生物大分子→病毒→细胞</li><li>生物大分子→细胞、病毒</li><li>生物大分子→细胞→病毒</li></ul><p>目前，第二与第三种比较易于接受，第三种观点得到了更多实验结果的支持：</p><ul><li>在原核细胞中，环形DNA 分子的附加体可以质粒的形式在细胞中复制，也可以整合在细菌的染色体中。其行为与细菌病毒λ噬菌体类似。</li><li>真核生物中，尤其是脊椎动物中普遍存在的第二类反转录转座子的两端具有长末端重复序列，其结构与整合于细胞基因组上的反转录病毒十分相似。二者可能有相同的起源。</li><li>已有的证据表明，有些病毒（如腺病毒）的核酸与哺乳动物细胞DNA 某些片段的碱基序列十分相似。</li></ul><h2 id="细胞质膜"><a class="header-anchor" href="#细胞质膜"></a>细胞质膜</h2><h3 id="名词解释-v2"><a class="header-anchor" href="#名词解释-v2"></a>名词解释</h3><p><strong>生物膜</strong>：细胞中所有的膜结构统称生物膜。</p><p><strong>桥粒</strong>：桥粒是连接相邻细胞间的锚定连接方式， 最明显的形态特征是细胞内锚蛋白形成独特的盘状致密斑， 一侧与细胞内的中间丝相连， 另一侧与跨膜黏附性蛋白质相连， 在两个细胞之间形成纽扣样结构， 将相邻细胞铆接在一起。</p><p><strong>脑磷脂</strong>：磷脂酰乙醇胺，是3-磷酸甘油的衍生物。</p><h3 id="问答题-v2"><a class="header-anchor" href="#问答题-v2"></a>问答题</h3><h4 id="质膜是否具流动性？请设计实验证明。"><a class="header-anchor" href="#质膜是否具流动性？请设计实验证明。"></a>质膜是否具流动性？请设计实验证明。</h4><p>质膜具有流动性。可以使用荧光漂白恢复技术证明：</p><ul><li>首先用荧光物质标记膜蛋白或膜脂</li><li>然后用激光束照射细胞表面某一区域， 使被照射区域的荧光悴灭变暗形成一个漂白斑。</li><li>如果悴灭区域的亮度逐渐增加， 最后恢复到与周围的荧光光强度相等，则说明质膜具有流动性。</li></ul><h4 id="简述生物膜的基本成分与结构模型"><a class="header-anchor" href="#简述生物膜的基本成分与结构模型"></a>简述生物膜的基本成分与结构模型</h4><p>生物膜的基本成分有膜脂和膜蛋白</p><ul><li>膜脂是生物膜的基本组成成分，主要包括甘油磷脂、鞘脂和固醇3种基本类型</li><li>膜蛋白赋予生物膜非常重要的生物学功能。根据膜蛋白分离的难易程度及其与脂分子的结合方式，可分为：外在膜蛋白、内在膜蛋白和脂锚定膜蛋白3种基本类型。</li></ul><p>生物膜的结构模型根据提出顺序有“蛋白质—脂质—蛋白质” 的三明治式模型、单位膜模型、流动镶嵌模型和脂筏模型。<br>流动镶嵌模型主要强调：</p><ul><li>膜的流动性， 即膜蛋白和膜脂均可侧向运动。</li><li>膜蛋白分布的不对称性， 有的结合在膜表面， 有的嵌入或横跨脂双分子层。</li></ul><p>脂筏模型是对膜流动性的新的理解。在甘油磷脂为主体的生物膜上， 胆固醇、鞘磷脂等富集区域形成相对有序的脂相， 如同漂浮在脂双层上的“脂筏”一样载着执行某些特定生物学功能的各种膜蛋白。</p><h4 id="什么是去垢剂？分为哪几类？去垢剂的主要作用是什么？"><a class="header-anchor" href="#什么是去垢剂？分为哪几类？去垢剂的主要作用是什么？"></a>什么是去垢剂？分为哪几类？去垢剂的主要作用是什么？</h4><p>去垢剂是一端亲水、一端疏水的两性小分子，是分离与研究膜蛋白的常用试剂。</p><p>去垢剂分为离子型去垢剂（如SDS）和非离子型去垢剂（如Triton X-100）两种类型。</p><p>去垢剂可以插入膜脂， 与膜脂或膜蛋白的跨膜结构域等疏水部位结合， 形成可溶性的微粒。多用于膜蛋白的分离与纯化。</p><h4 id="生物膜的不对称性主要体现在哪几个方面？生物学意义是什么？"><a class="header-anchor" href="#生物膜的不对称性主要体现在哪几个方面？生物学意义是什么？"></a>生物膜的不对称性主要体现在哪几个方面？生物学意义是什么？</h4><p>生物膜的不对称性主要体现在：</p><ul><li>同一种膜脂在脂双层中的分布不同</li><li>同一种膜蛋白在脂双层中的分布都有特定的方向或拓扑学特征</li><li>糖蛋白和糖脂的糖基部分均位于细胞质膜的外侧</li></ul><p>生物膜的不对称性的生物学意义：</p><ul><li>糖脂的不对称分布是完成其生理功能的结构基础；</li><li>磷脂分子不对称分布的原因和生物学意义还不很清楚；</li><li>膜蛋白的不对称性是生物膜完成复杂的在时间与空间上有序的各种生理功能的保证。</li></ul><h4 id="根据功能不同，细胞连接可以分为哪几类？各有什么特点？"><a class="header-anchor" href="#根据功能不同，细胞连接可以分为哪几类？各有什么特点？"></a>根据功能不同，细胞连接可以分为哪几类？各有什么特点？</h4><p>可分为：封闭连接、锚定连接、通讯连接</p><ul><li>封闭连接：将相邻上皮细胞的质膜紧密地连接在一起， 阻止溶液中的小分子沿细胞间隙从细胞一侧渗透到另一侧。紧密连接是这种连接的典型代表。</li><li>锚定连接：通过细胞膜蛋白及细胞骨架系统将相邻细胞， 或细胞与胞外基质间黏着起来。根据直接参与细胞连接的细胞骨架纤维类型的不同，锚定连接又分为与中间丝相关的锚定连接与肌动蛋白纤维相关的锚定连接。前者包括桥粒和半桥粒；后者主要有黏着带和黏着斑。当细胞形成组织后，由于细胞间或者细胞与胞外基质间通过锚点连接分散作用力。从而增强细胞承受机械力的能力。</li><li>通讯连接：介导相邻细胞间的物质转运、化学或电信号的传递， 主要包括动物细胞间的间隙连接、神经元之间或神经元与效应细胞之间的化学突触和植物细胞间的胞间连丝。</li></ul><h2 id="物质的跨膜运输"><a class="header-anchor" href="#物质的跨膜运输"></a>物质的跨膜运输</h2><h3 id="名词解释-v3"><a class="header-anchor" href="#名词解释-v3"></a>名词解释</h3><p><strong>载体（蛋白）</strong>：膜上一类转运蛋白，可特异的、可逆的与特定的溶质分子结合，通过一系列构象改变介导溶质分子的跨膜转运。</p><p><strong>网格蛋白</strong>：由3个二聚体形成三脚蛋白复合体，每个二聚体包括1条相对分子质最为1.8×10<sup>5</sup> 的重链和1条3.5×10<sup>4</sup>~4×10<sup>4</sup>的轻链，是包被的结构单位。</p><p><strong>膜泡运输</strong>：大分子及颗粒物质不能直接通过细胞膜，而是通过一系列膜囊泡形成和融合来完成转运过程，称膜泡运输。</p><p><strong>水孔蛋白</strong>：是一类具有6个α螺旋区的蛋白质家族， 通常形成四聚体的膜蛋白以行使其转运水或甘油等分子的功能。</p><h3 id="问答题-v3"><a class="header-anchor" href="#问答题-v3"></a>问答题</h3><h4 id="简述被动运输与主动运输二者之间有哪些相同点和不同点。"><a class="header-anchor" href="#简述被动运输与主动运输二者之间有哪些相同点和不同点。"></a>简述被动运输与主动运输二者之间有哪些相同点和不同点。</h4><p>相同点：都需要蛋白质载体</p><p>不同点：</p><ul><li>主动运输需要消耗能量，而被动运输不需要消耗能量;</li><li>被动运输是顺电化学梯度或浓度梯度，而主动运输一般是逆着电化学梯度或浓度梯度</li></ul><h4 id="离子通道可以分为哪几种？作用机制分别是什么？"><a class="header-anchor" href="#离子通道可以分为哪几种？作用机制分别是什么？"></a>离子通道可以分为哪几种？作用机制分别是什么？</h4><p>离子通道可分为三种，分别是电压门通道、配体门通道和应力激活通道</p><ul><li>电压门通道：带电荷的蛋白质结构域会随跨膜电位梯度的改变而发生相应的移动， 从而使离子通道开启或关闭。</li><li>配体门通道：细胞内外的某些小分子配体与通道蛋白结合继而引起通道蛋白构象改变， 从而使离子通道开启或关闭。</li><li>应力激活通道：通道蛋白感应应力而改变构象，从而开启通道形成离子流， 产生电信号</li></ul><h4 id="根据能量来源的不同，主动运输可以分为哪几类？"><a class="header-anchor" href="#根据能量来源的不同，主动运输可以分为哪几类？"></a>根据能量来源的不同，主动运输可以分为哪几类？</h4><p>由ATP 直接提供能量（ATP 驱动泵）、间接提供能量（协同转运或偶联转运蛋白）以及光驱动泵3种基本类型。</p><h4 id="简述钠钾泵（钠钾ATP酶）的特点及其主要生理功能。"><a class="header-anchor" href="#简述钠钾泵（钠钾ATP酶）的特点及其主要生理功能。"></a>简述钠钾泵（钠钾ATP酶）的特点及其主要生理功能。</h4><p>特点：</p><ul><li>由2 个α和2个β亚基组成四聚体</li><li>每个循环消耗一个ATP 分子，可以逆着电化学梯度泵出3个Na<sup>+</sup>和泵入2个K<sup>+</sup></li><li>由ATP 直接提供能量的主动转运，而非协同转运</li></ul><p>Na<sup>+</sup>-K<sup>+</sup>泵主要生理功能：</p><ul><li>维持细胞膜电位：每一个工作循环下来，Na<sup>+</sup>-K<sup>+</sup>泵将从细胞泵出3 个Na<sup>+</sup>并泵入2个K<sup>+</sup>， 对膜电位的形成起到了一定作用。</li><li>维持动物细胞渗透平衡：Na<sup>+</sup>-K<sup>+</sup>泵不断地将Na<sup>+</sup>泵到胞外维持了细胞的渗透平衡。还有Cl<sup>-</sup>（靠膜电位停留在胞外） 参与维持动物细胞渗透压平衡。</li><li>吸收营养：动物细胞对葡萄糖或氨基酸等有机物吸收的能量由蕴藏在Na<sup>+</sup>电化学梯度中的势能提供。</li></ul><h4 id="以LDL为例，简述受体介导的胞吞作用的过程。"><a class="header-anchor" href="#以LDL为例，简述受体介导的胞吞作用的过程。"></a>以LDL为例，简述受体介导的胞吞作用的过程。</h4><ul><li>胆固醇在血液中的运输通过与磷脂和蛋白质结合形成低密度脂蛋白（LDL）</li><li>LDL与细胞表面的LDL受体特异地结合形成受体——LDL复合物</li><li>通过网格蛋白包被膜泡的内化作用进入细胞</li><li>经脱包被作用并与胞内体融合</li><li>胞内体的低pH环境可引起LDL与受体分离</li><li>胞内体以出芽的方式形成含有受体的小囊泡，返回细胞质膜，受体重复使用</li><li>含有LDL 的胞内体与溶酶体融合，LDL被水解， 释放出胆固醇和脂肪酸供细胞利用。</li></ul><p><img src="http://img.whl123456.top/image/image-20200701003128757.png" alt="LDL通过受体介导的胞吞作用进入细胞 P82"></p><h2 id="细胞质基质与内膜系统"><a class="header-anchor" href="#细胞质基质与内膜系统"></a>细胞质基质与内膜系统</h2><h3 id="名词解释-v4"><a class="header-anchor" href="#名词解释-v4"></a>名词解释</h3><p><strong>内膜系统</strong>：是指在结构、功能乃至发生上相互关联、由单层膜包被的细胞器或细胞结构。主要包括内质网、高尔基体、溶酶体、胞内体和分泌泡等。</p><p><strong>细胞质基质</strong>：在真核细胞的细胞质中，除去可分辨的细胞器以外的胶状物质，占据着细胞膜内、细胞核外的细胞内空间，称细胞质基质。</p><p><strong>分子伴侣</strong>：存在于细胞质基质或细胞器中，可以识别正在合成或部分折叠的多肽，并与之某些部位结合，协助其转运、正确折叠或装配的一类蛋白质，但其本身不参与终产物的形成。</p><p><strong>蛋白酶体</strong>：是细胞内降解蛋白质的大分子复合体，由约50种蛋白质亚基组成相对分子质量为2×10<sup>6</sup> ~ 2.4×10<sup>6</sup>，富含ATP 依赖的蛋白酶活性，其功能然若细胞内蛋白质破碎机。</p><p><strong>微体</strong>：过氧化物酶体又称微体，是由单层膜围绕的内含一种或几种氧化酶类的细胞器。</p><h3 id="问答题-v4"><a class="header-anchor" href="#问答题-v4"></a>问答题</h3><h4 id="细胞质基质的主要功能是什么？"><a class="header-anchor" href="#细胞质基质的主要功能是什么？"></a>细胞质基质的主要功能是什么？</h4><ol><li>完成许多中间代谢过程：如糖酵解过程、磷酸戊糖途径、糖醋酸途径、糖原的合成与部分分解过程等。</li><li>为某些蛋白质合成和脂肪酸合成提供场所</li><li>与细胞质骨架的相关功能：<ul><li>细胞质骨架维持细胞的形态、细胞的运动、细胞内的物质运输及能量传递有关；</li><li>细胞质骨架是细胞质基质结构体系的组织者，为细胞质基质中其他成分和细胞器提供锚定位点</li></ul></li><li>与细胞膜的相关功能：<ul><li>细胞内的各种膜相细胞器使细胞质基质产生区室化，从而通过生物膜结构将蛋白质等生物大分子限定在膜的二维平面上，促进反应高效而有序地进行；</li><li>依靠细胞膜或细胞器膜上的泵蛋白和离子通道维持细胞内外跨膜的离子梯度，依靠细胞膜某些协同转运蛋白调节细胞质基质的pH ，维持细胞内环境稳定。</li></ul></li><li>与蛋白质的修饰和选择性降解等方面有关：<ul><li>蛋白质的修饰：辅酶或辅基与酶的共价结合；磷酸化与去磷酸化；蛋白质糖基化作用；甲基化修饰；酰基化。</li><li>控制蛋白质的寿命</li><li>降解变性和错误折叠的蛋白质</li><li>帮助变性或错误折叠的蛋白质重新折叠，形成正确的分子构象</li></ul></li></ol><h4 id="简述蛋白质降解的泛素化途径。"><a class="header-anchor" href="#简述蛋白质降解的泛素化途径。"></a>简述蛋白质降解的泛素化途径。</h4><ul><li>泛素活化酶(E1) 通过形成酰基－腺甘酸中介物使泛素分子C端被激活， 该反应需要ATP；</li><li>转移活化的泛素分子与泛素结合酶(E2) 的半胱氨酸残基结合；</li><li>异肽键形成，即与E2结合的泛素羧基和靶蛋白赖氨酸侧链的氨基之间形成异肽键，该反应由泛素连接酶(E3)催化完成。</li></ul><p>重复上述步骤，形成具有寡聚泛素链的泛素化靶蛋白。泛素化标签被蛋白酶体帽识别，并利用ATP 水解提供的能量驱动泛素分子的切除和靶蛋白解折叠，去折叠的蛋白质转移至蛋白酶体核心腔内被降解。</p><p><img src="http://img.whl123456.top/image/image-20200701003429215.png" alt="P116"></p><h4 id="内质网可以分为哪2类？详细说明内质网的功能有哪些？"><a class="header-anchor" href="#内质网可以分为哪2类？详细说明内质网的功能有哪些？"></a>内质网可以分为哪2类？详细说明内质网的功能有哪些？</h4><p>内质网可分为糙面内质网和光面内质网</p><ol><li>蛋白质的合成是糙面内质网的主要功能。在糙面内质网上，多肽链边延伸边穿过内质网膜进入内质网腔，以这类方式合成的蛋白质主要包括：向细胞外分泌的蛋白质；膜的整合蛋白；细胞器中的可溶性驻留蛋白。</li><li>光面内质网是脂质合成的重要场所。内质网合成细胞需要包括磷脂和胆固醇在内的几乎全部膜脂，其中最主要的磷脂是磷脂酰胆碱（卵磷脂）。</li><li>蛋白质修饰与加工。<ul><li>发生在内质网和高尔基体的蛋白质糖基化；</li><li>在内质网发生二硫键的形成；</li><li>蛋白质折叠和多亚基蛋白的装配；</li><li>在内质网、高尔基体和分泌泡发生特异性的蛋白质水解切割；</li><li>在内质网的胞质侧发生的蛋白质修饰酰基化；</li><li>少数蛋白发生，新生肽的脯氨酸和赖氨酸要进行羟基化，形成羟脯氨酸和羟赖氨酸。</li></ul></li><li>新生多肽的折叠与组装。<ul><li>内质网中有一种蛋白二硫键异构酶（PDI），它附着在内质网膜腔面上，可以切断二硫键，从而帮助新合成的蛋白质重新形成二硫键并产生正确折叠的构象。</li><li>内质网含有一种结合蛋白(Bip)，是属于Hsp70家族的分子伴侣，在内质网中有两个作用：Bip同进入内质网的未折叠蛋白质的疏水氨基酸结合，防止多肽链不正确地折叠和聚合，或者识别错误折叠的蛋白质或未装配好的蛋白质亚单位，并促进它们重新折叠与装配；防止新合成的蛋白质在转运过程中变性或断裂。</li></ul></li><li>内质网的其他功能。<ul><li>肝细胞中的光面内质网中还含有一些酶具有解毒作用</li><li>心肌细胞和骨胳肌细胞中含有发达的特化的光面内质网（肌质网）是储存Ca<sup>2+</sup>的细胞器，对Ca<sup>2+</sup>具调节作用。</li><li>某些合成固醇类激素的细胞光面内质网非常丰富，其中含有制造胆固醇并进一步产生固醇类激素的一系列的酶。</li></ul></li></ol><h4 id="N-连接糖基化与O-连接糖基化的主要区别是什么？"><a class="header-anchor" href="#N-连接糖基化与O-连接糖基化的主要区别是什么？"></a>N-连接糖基化与O-连接糖基化的主要区别是什么？</h4><table><thead><tr><th>特征</th><th>N-连接</th><th>O-连接</th></tr></thead><tbody><tr><td>合成部位</td><td>糙面内质网和高尔基体</td><td>高尔基体</td></tr><tr><td>合成方式</td><td>来自同—个寡糖前体</td><td>—个个单糖加上去</td></tr><tr><td>与之结合的氨基酸残基</td><td>天冬酰胺</td><td>丝氨酸、苏氨酸、羟赖氨酸、羟脯氨酸</td></tr><tr><td>最终长度</td><td>至少5 个糖残基</td><td>一般1~4个糖残基，但ABO 血型抗原较长</td></tr><tr><td>第一个糖残基</td><td>N-乙酰葡糖胺</td><td>N-乙酰半乳糖胺等</td></tr></tbody></table><h4 id="高尔基体的主要功能包括哪几方面？"><a class="header-anchor" href="#高尔基体的主要功能包括哪几方面？"></a>高尔基体的主要功能包括哪几方面？</h4><ol><li>高尔基体与细胞的分泌活动：分泌性蛋白、多种细胞质膜上的膜蛋白、溶酶体中的酸性水解酶及胶原等胞外基质成分，其定向转运过程都是通过高尔基体完成的。</li><li>蛋白质的糖基化及其修饰：大多数蛋白质或膜脂的糖基化修饰和与高尔基体有关的多糖的合成，主要发生在高尔基体。</li><li>蛋白酶的水解和其他加工过程：有些多肽，经特异性水解才成为有生物活性的多肽。</li></ol><h4 id="根据处于完成生理功能的阶段的不同，溶酶体可以分为哪几类？溶酶体的功能是什么？结合高尔基体的功能，谈谈溶酶体是如何发生的？"><a class="header-anchor" href="#根据处于完成生理功能的阶段的不同，溶酶体可以分为哪几类？溶酶体的功能是什么？结合高尔基体的功能，谈谈溶酶体是如何发生的？"></a>根据处于完成生理功能的阶段的不同，溶酶体可以分为哪几类？溶酶体的功能是什么？结合高尔基体的功能，谈谈溶酶体是如何发生的？</h4><p>大致可分为初级溶酶体、次级溶酶体、残质体</p><p>溶酶体的功能：</p><ol><li>清除无用的生物大分子、衰老的细胞器及衰老损伤和死亡的细胞</li><li>防御功能</li><li>作为细胞内的消化“器官”为细胞提供营养</li><li>在分泌腺细胞中，溶酶体常常摄入分泌颗粒，参与分泌过程的调节</li><li>某些特定细胞程序性死亡，死亡后的细胞被周围吞噬细胞溶酶体消化清除。</li><li>参与受精过程中的顶体反应</li></ol><p>溶酶体的发生：</p><ol><li>溶酶体酶在糙面内质网上合成并经N－连接的糖基化基础修饰，然后转至高尔基体，在高尔基体的顺面膜囊中寡糖链上的甘露糖残基被磷酸化形成甘露糖-6-磷酸(M6P)；</li><li>在高尔基体的反面膜囊和TGN 膜上存在M6P的受体，溶酶体酶与其他蛋白质区分开来，并得以浓缩。</li><li>以出芽的方式形成网格蛋白/AP包被膜泡转运到溶酶体中；</li><li>进入前溶酶体的酸性环境后，M6P受体与M6P分离，并返回高尔基体。</li></ol><h2 id="细胞骨架"><a class="header-anchor" href="#细胞骨架"></a>细胞骨架</h2><h3 id="名词解释-v5"><a class="header-anchor" href="#名词解释-v5"></a>名词解释</h3><p><strong>细胞骨架</strong>：是指存在于真核细胞中的蛋白纤维网架体系。</p><p><strong>微丝</strong>：是指真核细胞中由肌动蛋白组成，直径为7nm的骨架纤维。</p><p><strong>微管</strong>：是指由微管蛋白亚基组装而成的管状结构。</p><p><strong>踏车行为</strong>：是指微丝的正极由于肌动蛋白亚基的不断添加而延长，而负极则由于肌动蛋白亚基去组装而缩短的现象。</p><p><strong>微管组织中心</strong>：是指在活细胞内，能够起始微管的成核作用，并使之延伸的细胞结构，主要包括中心体、纤毛基部、鞭毛基部。</p><h3 id="问答题-v5"><a class="header-anchor" href="#问答题-v5"></a>问答题</h3><h4 id="细胞质骨架包括哪3种结构组分？每一种组分的结构成分包括哪些蛋白？各有什么功能？"><a class="header-anchor" href="#细胞质骨架包括哪3种结构组分？每一种组分的结构成分包括哪些蛋白？各有什么功能？"></a>细胞质骨架包括哪3种结构组分？每一种组分的结构成分包括哪些蛋白？各有什么功能？</h4><p>细胞骨架主要包括微丝(MF)、微管(MT) 和中间丝(IF) 3种结构组分。</p><h5 id="微丝"><a class="header-anchor" href="#微丝"></a>微丝</h5><p>结构成分：主要结构成分是肌动蛋白，其在细胞内有两种存在形式，即肌动蛋白单体（又称球状肌动蛋白)和由单体组装而成的纤维状肌动蛋白。</p><p>功能：</p><ul><li>维持细胞形态；</li><li>赋予质膜机械强度；</li><li>细胞运动；</li><li>构成微绒毛、应力纤维；</li><li>参与胞质分裂；</li><li>参与肌肉收缩等</li></ul><h5 id="微管"><a class="header-anchor" href="#微管"></a>微管</h5><p>结构成分：α/β-微管蛋白二聚体是细胞质内游离态微管蛋白的主要存在形式， 也是微管组装的基本结构单位</p><p>功能：</p><ul><li>构成细胞的网状支架，维持细胞的形态；</li><li>参与细胞内物质运输；</li><li>细胞器的定位；</li><li>构成纤毛、鞭毛，参与细胞的运动；</li><li>纺锤体和染色体运动;</li></ul><h5 id="中间纤维"><a class="header-anchor" href="#中间纤维"></a>中间纤维</h5><p>结构成分，有6种主要类型：</p><ol><li><p>角蛋白，单体分为：酸性角蛋白（Ⅰ型）、中性或碱性角蛋白（Ⅱ型）。通过两者的异二聚体形成角蛋白纤维；</p></li><li><p>Ⅲ型中间丝，波形蛋白、结蛋白、微管成束蛋白、胶质丝酸性蛋白与外周蛋白；</p></li><li><p>Ⅳ型中间丝，包括3种神经丝蛋白亚基和α-介连蛋白；</p></li><li><p>Ⅴ型中间丝蛋白，核纤层蛋白A及其剪切体核纤层蛋白C 与核纤层蛋白B1和B2；</p></li><li><p>Ⅵ型中间丝蛋白，巢蛋白与desmuslin ；</p></li><li><p>晶状体中发现的phakinin/CP49和丝晶蛋白属于“孤儿”类型。</p></li></ol><p>功能：</p><ul><li>细胞抗机械压力的能力；</li><li>角蛋白纤维参与桥粒的形成和维持；</li><li>结蛋白纤维是肌肉Z盘的重要结构组分，对于维持肌肉细胞的收缩装置起重要作用；</li><li>神经元纤维在神经细胞轴突运输中起作用；</li><li>参与传递细胞内机械的或分子的信息；</li><li>中间纤维与mRNA的运输有关；</li><li>与细胞分化有关：形成跨膜信息通道。</li></ul><h4 id="依赖于微管的马达蛋白包括哪几类？各有什么特点？简述微管与细胞内物质运输之间的关系。"><a class="header-anchor" href="#依赖于微管的马达蛋白包括哪几类？各有什么特点？简述微管与细胞内物质运输之间的关系。"></a>依赖于微管的马达蛋白包括哪几类？各有什么特点？简述微管与细胞内物质运输之间的关系。</h4><p>依赖于微管的马达蛋白包括驱动蛋白和胞质动力蛋白</p><p>驱动蛋白特点</p><ol><li>是一条长80nm 的杆状结构，头部一端有两个呈球状的马达结构域，另一端是重链和轻链组成的扇形尾端，中间是重链组成的杆状区。</li><li>驱动蛋白具有许多超家族</li><li>驱动蛋白的行为与其马达结构域在多肽链中的位置有关，大多数以微管为轨道由微管负端向微管正端运送货物，是正端走向的微管发动机</li><li>大部分驱动蛋白可通过多肽链上一段卷曲螺旋相互作用而形成同源二聚体</li></ol><p>细胞质动力蛋白特点</p><ol><li>细胞质动力蛋白是由一个相对分子质量接近1.5×10<sup>6</sup>的巨大蛋白复合物组成，含多个多肽亚单位： 两条具有ATP酶活性的使其沿微管移动的重链，两条中间链和一些轻链。</li><li>动力蛋白是已知马达蛋白中最大、移动速度最快的成员。</li><li>细胞质动力蛋白只有两个重链家族成员，Dync1 h1和Dync1 h2 。</li><li>细胞质动力蛋白以微管为轨道由微管正端向微管负端运送货物，是负端走向的微管发动机</li></ol><p>微管是细胞内物质运输之间的轨道</p><h4 id="影响微丝、微管组装的特异性药物有哪些？各有什么特点？"><a class="header-anchor" href="#影响微丝、微管组装的特异性药物有哪些？各有什么特点？"></a>影响微丝、微管组装的特异性药物有哪些？各有什么特点？</h4><p>影响微丝的有细胞松弛素和鬼笔环肽等。</p><ul><li>细胞松弛素与微丝结合后可以将微丝切断，结合在微丝末端阻抑肌动蛋白在该部位的聚合，但对微丝的解聚没有明显影响，因而用细胞松弛素处理细胞可以破坏微丝的网络结构，并阻止细胞的运动。</li><li>鬼笔环肽与微丝表面有强亲和力，但不与肌动蛋白单体结合，能阻止微丝的解聚，使其保持稳定状态。</li></ul><p>影响微管的有秋水仙素和紫杉醇等</p><ul><li>秋水仙素与微管蛋白亚基结合组装到微管末端后，其他的微管蛋白亚基很难再在该处进行组装，但不影响该微管的去组装，从而导致细胞内微管网络的解体。</li><li>紫杉醇与微管结合后可以阻止微管的去组装，但不影响微管末端的组装微管不停地组装，不会解聚，其结果使细胞周期的运行被终止。</li></ul><h4 id="简述骨骼肌细胞的结构组分以及肌肉收缩的滑动模型理论。"><a class="header-anchor" href="#简述骨骼肌细胞的结构组分以及肌肉收缩的滑动模型理论。"></a>简述骨骼肌细胞的结构组分以及肌肉收缩的滑动模型理论。</h4><p>骨骼肌细胞的结构组分</p><p>骨骼肌细胞是由数百条更细的肌原纤维组成的集束，每根肌原纤维由称为肌节的收缩单元呈线性重复排列而成。每个肌节都表现出特征性的带型。</p><p>肌原纤维的带状条纹由粗肌丝和细肌丝的纤维有序组装而成。粗肌丝由肌球蛋白组装而成，细肌丝的主要成分是肌动蛋白，辅以原肌球蛋白和肌钙蛋白。肌球蛋白的头部突出于粗肌丝的表面，并可与细肌丝上肌动蛋白亚基结合，构成粗肌丝与细肌丝之间的横桥。</p><p>除此之外还有将细肌丝锚定于Z 盘或质膜上的CapZ、α-辅肌动蛋白和纽蛋白；在肌节中起结构作用的肌联蛋白、伴肌动蛋白和肌营养不良蛋白。</p><p>滑动模型理论：肌肉收缩时肌节缩短，但在肌节内并无粗／细肌丝的长度变化，而只是由神经冲动引发的细肌丝与粗肌丝之间的相对滑动所致。基本过程如下：P205</p><ol><li>动作电位的产生</li><li>Ca<sup>2+</sup>的释放</li><li>原肌球蛋白位移</li><li>细肌丝与粗肌丝之间的相对滑动<ul><li>在初始状态，组成粗肌丝的肌球蛋白的头部（马达结构域） 没有结合ATP 时，该肌球蛋白的头部与细肌丝结合，并成僵直状态。</li><li>ATP 结合到肌球蛋白的头部导致与肌动蛋白纤维的结合力下降， 肌球蛋白与肌动蛋白分开；</li><li>ATP 水解为ADP+Pi，ATP 水解释放出的能量被肌球蛋白吸收， 导致进一步的构象变化， 头部结构域向前抬升， 并结合到靠近细肌丝正极端的一个肌动蛋白亚基上；</li><li>Pi释放，肌球蛋白颈部结构域发生构象变化，头部与细丝的角度发生变化，拉动细肌丝导致细肌丝相对于粗肌丝的滑动；</li><li>ADP 释放，肌球蛋白的头部结构域与细肌丝之间又回到僵直状态。</li></ul></li></ol><h4 id="简述中间纤维（中间丝）的组装模式，并简要介绍中间纤维与核纤层蛋白之间的联系。"><a class="header-anchor" href="#简述中间纤维（中间丝）的组装模式，并简要介绍中间纤维与核纤层蛋白之间的联系。"></a>简述中间纤维（中间丝）的组装模式，并简要介绍中间纤维与核纤层蛋白之间的联系。</h4><p>中间纤维的组装模式</p><ol><li>两个单体的杆状区以平行排列的方式形成双股螺旋的二聚体；</li><li>两个二聚体以反向平行和半分子交错的形式组装成四聚体；</li><li>四聚体之间在纵向（首尾） 和侧向相互作用，最终组装成横截面由32个中间丝蛋白分子组成，长度不等的中间丝。</li></ol><p>中间纤维与核纤层蛋白之间的联系</p><p>由Ⅴ型中间丝蛋白组装而成的核纤层结构在核膜的内侧呈正交网状排列。核纤层与内核膜上的核纤层蛋白受体相连，是核膜的重要支撑结构，也是染色质的重要锚定位点。</p><h2 id="细胞核"><a class="header-anchor" href="#细胞核"></a>细胞核</h2><h3 id="名词解释-v6"><a class="header-anchor" href="#名词解释-v6"></a>名词解释</h3><p><strong>核小体</strong>：是染色质的基本单位，直径约10nm 的球形小体，由组蛋白和200bp左右的DNA组成。</p><p><strong>核定位信号</strong>：亲核蛋白上含有的特殊氨基酸序列，以保证整个蛋白质能够通过核孔复合体被转运到细胞核内。</p><p><strong>染色质</strong>：指间期细胞核内由DNA、组蛋白、非组蛋白及少量RNA组成的线性复合结构, 是间期细胞遗传物质存在的形式。</p><p><strong>动粒</strong>：在主缢痕处两个染色单体的外侧表面部位的特殊结构，它与染色体微管接触，是微管蛋白的组织中心。</p><p><strong>多线染色体</strong>：在某些细胞有丝分裂期间，DNA 多次复制而细胞不分裂。产生的子染色体并行排列，且体细胞内同源染色体配对，紧密结合在一起从而阻止染色质纤维进一步聚缩，形成体积很大的多线染色体。</p><p><strong>核纤层</strong>：主要由3种核纤层蛋白构成的中间纤维网络片层结构，紧贴内层核膜下，与胞质中间丝、核基质有密切联系。</p><h3 id="问答题-v6"><a class="header-anchor" href="#问答题-v6"></a>问答题</h3><h4 id="细胞核由哪几部分组成？主要功能是什么？"><a class="header-anchor" href="#细胞核由哪几部分组成？主要功能是什么？"></a>细胞核由哪几部分组成？主要功能是什么？</h4><p>细胞核主要由核被膜、核纤层、染色质、核仁及核体组成。</p><p>细胞核的主要功能：</p><ul><li>是遗传信息的主要贮存库；</li><li>是遗传信息的复制和传递的场所；</li><li>进行遗传信息的表达，是细胞生命活动的控制枢纽。</li></ul><h4 id="什么是核孔复合体？简述核孔复合体的结构组成，以及核孔复合体的运输功能有什么特点？"><a class="header-anchor" href="#什么是核孔复合体？简述核孔复合体的结构组成，以及核孔复合体的运输功能有什么特点？"></a>什么是核孔复合体？简述核孔复合体的结构组成，以及核孔复合体的运输功能有什么特点？</h4><p>核孔复合体是在核被膜上由多种核孔蛋白构成的联系核质和细胞质的复杂隧道结构。</p><p>核孔复合体的结构组成：核孔复合体主要由胞质环、核质环、辐和栓4部分组成。</p><ul><li>胞质环：位于核孔边缘的胞质面一侧，环上有8条短纤维对称分布伸向胞质。</li><li>核质环：位于核孔边缘的核质面一侧，环上对称地连有8条细长的纤维，向核内伸入50~70nm，在纤维的末端形成一个直径为60nm 的小环，小环由8 个颗粒构成。</li><li>辐：由核孔边缘伸向中心，呈辐射状八重对称，有位于核孔边缘的“柱状亚单位”、穿过核膜伸入双层核膜的膜间腔的“腔内亚单位”和靠近中心的“环带亚单位”的3个结构域。环带亚单位由8个颗粒状结构环绕形成核孔复合体核质交换的通道。</li><li>栓：位于核孔的中心，呈颗粒状或棒状。</li></ul><p>核孔复合体运输功能及特点，核孔复合体是核质交换的双功能、双向性亲水通道。</p><ul><li>双功能表现在核孔复合体有两种运输方式：被动扩散与主动运输。</li><li>双向性表现在既介导蛋白质的入核转运，又介导RNA、核糖核蛋白颗粒(RNP)的出核转运。</li></ul><h4 id="简述染色质组装的两种结构模型。"><a class="header-anchor" href="#简述染色质组装的两种结构模型。"></a>简述染色质组装的两种结构模型。</h4><p>染色质组装的多级螺旋模型，DNA（压缩7倍）→核小体（压缩6倍）→螺线管（压缩40倍）→超螺线管（压缩5倍）→染色单体</p><p>由DNA与组蛋白组装成核小体，在组蛋白H1的介导下核小体彼此连接形成直径约10nm的核小体串珠结构，在有组蛋白H1存在的情况下，由直径10nm的核小体串珠结构螺旋盘绕，每圈6个核小体，形成外径25~30nm，螺距12nm的螺线管，螺线管进一步螺旋形成直径为0.4μm 的超螺线管，再进一步螺旋折叠形成直径为2~10μm的染色单体。经过四级螺旋组装形成的染色体结构，共压缩了8400倍。</p><p>染色质组装的放射环结构模型，DNA→核小体→螺线管→DNA复制环→微带→染色单体</p><p>螺线管形成DNA复制环，每18个复制环呈放射状平面排列，结合在核基质上形成微带。微带是染色体高级结构的单位，约10<sup>6</sup>个微带沿纵轴构建成子染色体。</p><h4 id="什么是中期染色体的三种功能元件？其主要功能是什么？"><a class="header-anchor" href="#什么是中期染色体的三种功能元件？其主要功能是什么？"></a>什么是中期染色体的三种功能元件？其主要功能是什么？</h4><p>在细胞世代中确保染色体的复制和稳定遗传，染色体起码应具备3种功能元件，构成染色体DNA的这3种关键序列称为染色体DNA的功能元件。</p><p>三种功能元件的主要功能</p><ul><li>自主复制DNA 序列：确保染色体在细胞周期中能够自我复制，维持染色体在细胞世代传递中的连续性。</li><li>着丝粒DNA 序列：使细胞分裂时已完成复制的染色体能平均分配到子细胞中。</li><li>端粒DNA 序列：保持染色体的独立性和稳定性。</li></ul><h4 id="简述核仁的3种基本组分特点及功能，谈谈为什么凡是蛋白质合成旺盛的细胞中核仁都明显偏大。"><a class="header-anchor" href="#简述核仁的3种基本组分特点及功能，谈谈为什么凡是蛋白质合成旺盛的细胞中核仁都明显偏大。"></a>简述核仁的3种基本组分特点及功能，谈谈为什么凡是蛋白质合成旺盛的细胞中核仁都明显偏大。</h4><p>核仁的3种基本组分：纤维中心，致密纤维组分和颗粒组分</p><ul><li>纤维中心（FC）：包埋在颗粒组分内部一个或几个浅染的低电子密度的圆形结构。FC中的染色质不形成核小体结构，也没有组蛋白存在，但存在嗜银蛋白。其中磷蛋白C23可能与核仁中染色质结构的调节有关。是rRNA基因的储存位点。</li><li>致密纤维组分（DFC）：是核仁超微结构中电子密度最高的部分，呈环形或半月形包围FC, 由致密的纤维构成，通常见不到颗粒。转录主要发生在FC与DFC的交界处。</li><li>颗粒组分（GC）：是核仁的主要结构。它由直径15-20 nm的RNP构成。代表核糖体亚基成熟和储存的位点。</li></ul><p>蛋白质的合成需要核糖体，核糖体生物发生与核仁有关。在大小亚基合成时，小亚基所需的18S rRNA直接在核仁中合成，装配完成后从核仁运输出来，在核仁的停留时间较短，大亚基组装所需的28S rRNA、5.8S rRNA可以在核仁中合成但5S rRNA需要从核仁之外的其他部位汇集再进行装配，大亚基合成较慢，过多大亚基滞留在核仁中，故蛋白质合成旺盛的细胞中核仁都明显偏大。</p><h4 id="什么是核基质？什么是核骨架？核骨架的功能是什么"><a class="header-anchor" href="#什么是核基质？什么是核骨架？核骨架的功能是什么"></a>什么是核基质？什么是核骨架？核骨架的功能是什么</h4><p>核基质是指真核细胞的核内除染色质、核膜与核仁外，以蛋白质成分为主的网架结构。</p><p>核骨架广义上包括核基质、核纤层以及染色体骨架，狭义上是指核基质。</p><p>核骨架的功能</p><ol><li>维持细胞核的形态</li><li>为DNA、染色质在核中的空间排列提供支附作用</li><li>核骨架与DNA复制、基因表达及染色体的组装与构建有密切关系。</li></ol><h2 id="蛋白质分选和膜泡运输"><a class="header-anchor" href="#蛋白质分选和膜泡运输"></a>蛋白质分选和膜泡运输</h2><h3 id="名词解释-v7"><a class="header-anchor" href="#名词解释-v7"></a>名词解释</h3><p><strong>蛋白质分选</strong>：是指在核糖体上合成的蛋白质，通过信号肽，在翻译的同时进入内质网，然后经过各种加工和修饰，使不同去向的蛋白质带上不同的标记，最后经过高尔基体反面膜囊进行分选，包装到不同类型的小泡，并运送到目的地的过程。</p><p><strong>信号肽</strong>：位于蛋白质的N端，一般由16~26个氨基酸残基组成，其中包括疏水核心区、信号肽的C端和N端等3 部分，在蛋白质合成中将核糖体引导到内质网，进入内质网后通常被切除，无严格的专一性。</p><p><strong>膜泡运输</strong>：是蛋白质分选的一种特有的方式，普遍存在于真核细胞中。大分子和颗粒物质被运输时由膜包围形成膜泡，通过一系列膜囊泡的形成和融合来完成转运的过程。</p><h3 id="问答题-v7"><a class="header-anchor" href="#问答题-v7"></a>问答题</h3><h4 id="试述细胞内蛋白质的合成部位及其去向（蛋白质分选的途径）。"><a class="header-anchor" href="#试述细胞内蛋白质的合成部位及其去向（蛋白质分选的途径）。"></a>试述细胞内蛋白质的合成部位及其去向（蛋白质分选的途径）。</h4><p>核细胞中除线粒体和植物细胞叶绿体中能合成少量蛋白质外，绝大多数蛋白质都是由核基因编码，或在游离核糖体上合成，或在糙面内质网膜结合核糖体上合成。</p><p>核基因编码的蛋白质的分选大体可分2条途径：</p><ul><li>共翻译转运途径：在细胞质基质中多肽链合成起始后，转移到内质网，然后边合成边转入内质网腔，再经高尔基体运输至溶酶体、细胞膜或分泌到细胞外；</li><li>后翻译转运途径：在细胞质基质游离核糖体上完成多肽链的合成，然后转运至膜围绕的细胞器。</li></ul><h4 id="简述信号（肽）假说的主要内容。"><a class="header-anchor" href="#简述信号（肽）假说的主要内容。"></a>简述信号（肽）假说的主要内容。</h4><p>以分泌蛋白N端序列作为信号肽，指导分泌性蛋白质在内质网膜上合成，然后在信号肽引导下蛋白质边合成边通过移位子蛋白复合体进入内质网腔，在蛋白质合成结束之前切除信号肽。其他类型的蛋白质也含有类似的信号序列，指导蛋白质完成定向运输。</p><h4 id="由核基因编码的蛋白质是如何运送到线粒体中去的？"><a class="header-anchor" href="#由核基因编码的蛋白质是如何运送到线粒体中去的？"></a>由核基因编码的蛋白质是如何运送到线粒体中去的？</h4><p>在游离核糖体上合成的前体蛋白，与胞质蛋白分子伴侣Hsc70结合，并使其保持未折叠或部分折叠状态，其N端具有基质靶向序列，前体蛋白与内外膜接触点附近的输入受体(Tom20/22) 结合，被转运进入输入孔。</p><p>输入的蛋白进而通过内外膜接触点的输入通道（外膜为Tom40, 内膜为Tim23/17)，线粒体基质分子伴侣Hsc70与输入蛋白结合并水解ATP以驱动基质蛋白的输入。</p><p>输入的基质蛋白其基质靶向序列，在基质蛋白酶作用下被切除， 同时Hsc70 也从新输入的基质蛋白上释放出来，进而折叠，产生活性构象。</p><p><img src="http://img.whl123456.top/image/image-20200701004336084.png" alt="P143"></p><h4 id="转运膜泡表面包被蛋白可以分为哪3类？这3类膜泡类型的特征有什么不同？"><a class="header-anchor" href="#转运膜泡表面包被蛋白可以分为哪3类？这3类膜泡类型的特征有什么不同？"></a>转运膜泡表面包被蛋白可以分为哪3类？这3类膜泡类型的特征有什么不同？</h4><p>可分成COPⅡ包被膜泡、COPⅠ包被膜泡和网格蛋白/接头蛋白包被膜泡。</p><p>COPⅡ包被膜泡：由小分子 GTPase Sar1、 Sec23/Sec24、Sec13/Sec31以及大的纤维蛋白Sec16等组成，介导细胞内顺向运输即负责从内质网→高尔基体的物质运输；</p><p>COPⅠ包被膜泡：COPⅠ包被含有7种蛋白亚基包被蛋白复合物的装配与去装配依赖于ARF。负责回收、转运内质网逃逸蛋白返回内质网；介导高尔基体不同区域间的蛋白质运输。</p><p>网格蛋白/接头蛋白包被膜泡：是一类双层包被的膜泡，外层由网格蛋白组成，内层由接头蛋白复合物组成。纯化的网格蛋白分子呈三腿结构，每个分支含一条重链和一条轻链。负责运输途径质膜→内体；高尔基体→内体；高尔基体→溶酶体、植物液泡。</p><h4 id="膜泡运输的关键步骤涉及哪些过程？简述介导转运膜泡与靶膜融合的主要机制。"><a class="header-anchor" href="#膜泡运输的关键步骤涉及哪些过程？简述介导转运膜泡与靶膜融合的主要机制。"></a>膜泡运输的关键步骤涉及哪些过程？简述介导转运膜泡与靶膜融合的主要机制。</h4><p>膜泡运输的关键步骤至少涉及如下过程：</p><ul><li><p>供体膜的出芽、装配和断裂，形成不同的包被转运膜泡；</p></li><li><p>在细胞内由马达蛋白驱动、以微管为轨道的膜泡运输；</p></li><li><p>转运膜泡与特定靶膜的锚定和融合。</p></li></ul><p>介导转运膜泡与靶膜融合的主要机制：</p><ol><li><p>在供体膜上的鸟苷酸交换因子(GEF) 识别并结合特异性Rab蛋白， 诱发GTP置换GDP, 鸟苷酸交换引发Rab蛋白构象改变并暴露其共价结合的脂质基团，从而帮助Rab-GTP蛋白锚定在供体膜上，并随膜泡转移，在靶膜上Rab-GTP与Rab效应器结合，这种结合有助于膜泡锚定和v-SNARE 与t-SNARE 的配对 ;</p></li><li><p>v-SNARE 蛋白与同类t-SNARE 胞质结构域相互作用，形成稳定的卷曲SNARE复合体， 将膜泡与靶膜紧密束缚在一起；</p></li><li><p>伴随SNARE复合物形成后，供体膜泡与靶膜随即融合；</p></li><li><p>两膜融合后，NSF联合α-SNAP 蛋白随即与SNARE 复合体结合，然后NSF 催化ATP 水解，驱动SNARE 复合体解离， 游离的SNARE蛋白再用于其他膜泡的融合。</p></li><li><p>具有GTPase活性的Rab蛋白水解与之结合的GTP, 释放可溶性的Rab-GDP 进入细胞质。在细胞质中Rab-GDP与GDP 解离抑制物(GDI)结合，从而防止Rab 蛋白从Rab-GDP复合物中释放出来 ，直至与GEF 发生相互作用。</p></li></ol><p><img src="http://img.whl123456.top/image/image-20200701004811033.png" alt="P152"></p><h2 id="细胞信号转导"><a class="header-anchor" href="#细胞信号转导"></a>细胞信号转导</h2><h3 id="问答题-v8"><a class="header-anchor" href="#问答题-v8"></a>问答题</h3><h4 id="简述细胞信号转导系统的组成及其特性。"><a class="header-anchor" href="#简述细胞信号转导系统的组成及其特性。"></a>简述细胞信号转导系统的组成及其特性。</h4><p>通过细胞表面受体介导的信号通路通常由下列5个步骤组成：</p><ul><li>细胞表面受体特异性识别并结合胞外信号分子（配体），形成受体-配体复合物， 导致受体激活；</li><li>由于激活受体构象改变， 导致信号初级跨膜转导， 靶细胞内产生第二信使或活化的信号蛋白；</li><li>通过胞内第二信使或细胞内信号蛋白复合物的装配， 起始胞内信号放大的级联反应</li><li>细胞应答反应， 如果这种级联反应主要是通过酶的逐级激活， 结果将改变细胞代谢活性， 或者通过基因表达调控蛋白影响细胞基因表达和影响发育， 或者通过细胞骨架蛋白的修饰改变细胞形状或运动；</li><li>由于受体脱敏或受体下调，终止或降低细胞反应。</li></ul><p>信号转导系统的主要特性：</p><ul><li>特异性：细胞受体与胞外配体通过结构互补机制以非共价键结合， 形成受体-配体复合物， 简称具有“结合” 特异性，受体因结合配体而改变构象被激活，介导特定的细胞反应，从而又表现出“ 效应器” 特异性。此外，受体与配体的结合具有饱和性和可逆性的特征。</li><li>放大效应：信号传递至胞内效应器蛋白（通常由酶或离子通道蛋白组成），引发细胞内信号放大的级联反应，如果级联反应主要是通过酶的逐级激活，结果将改变细胞代谢活性。最常见的级联放大作用是通过蛋白质磷酸化实现的。</li><li>网络化与反馈调节机制：细胞信号系统网络化的相互作用是细胞生命活动的重要特征，在细胞内由一系列蛋白质组成的信号转导系统中，细胞对刺激作出适时适度的反应是细胞完成各种生命活动的基础，信号网络化效应有利于克服分子间相互作用的随机性对细胞生命活动的负面干扰。这样的网络特性是由一系列正反馈和负反馈环路组成的，对于及时校正反应的速率和强度是最基本的调控机制。</li><li>整合作用：多细胞生物的每个细胞都处于细胞“社会“ 环境之中，大最的信息以不同组合的方式调节细胞的行为。因此，细胞必须整合不同的信息，对细胞外信号分子的特异性组合作出程序性反应，甚至作出生死抉择，这样才能维持生命活动的有序性。</li></ul><h4 id="细胞信号传递的通路随信号受体存在部位不同可分为几大类？各有什么特点？"><a class="header-anchor" href="#细胞信号传递的通路随信号受体存在部位不同可分为几大类？各有什么特点？"></a>细胞信号传递的通路随信号受体存在部位不同可分为几大类？各有什么特点？</h4><p>根据靶细胞上的受体存在的部位，可将受体区分为细胞内受体和细胞表面受体。</p><p>故有细胞内受体介导的信号传递和细胞表面的G蛋白偶联受体介导的信号转导、酶联受体介导的信号转导和其他细胞表面受体介导的信号通路。</p><p>细胞内受体介导的信号传递受体位于细胞质基质或核基质中，主要识别和结合小的脂溶性信号分子，其中NO也可以作为气体信号分子进入靶细胞直接与酶接合。</p><p>细胞表面受体主要识别和结合亲水性信号分子，包括分泌型信号分子或膜结合型信号分子。其又分属三大家族：离子通道偶联受体、G蛋白偶联受体和酶偶联受体。</p><h4 id="概述G蛋白耦联受体介导的信号通路的组成、特点及主要功能。"><a class="header-anchor" href="#概述G蛋白耦联受体介导的信号通路的组成、特点及主要功能。"></a>概述G蛋白耦联受体介导的信号通路的组成、特点及主要功能。</h4><p>信号通路按其效应器蛋白的不同可分为3类：</p><ul><li>激活离子通道的G蛋白偶联受体；</li><li>激活或抑制腺苷酸环化酶，以cAMP为第二信使的G蛋白偶联受体；</li><li>激活磷脂酶C，以IP<sub>3</sub>和DAG作为双信使的G蛋白偶联受体。</li></ul><p><strong>激活离子通道的G蛋白偶联受体所介导的信号通路</strong></p><p>特点：当受体与配体结合被激活后，通过偶联G蛋白的分子开关作用，调控跨膜离子通道的开启与关闭，进而调节靶细胞的活性；</p><p>主要功能：</p><ul><li>心肌细胞上M乙酰胆碱受体激活G蛋白开启K<sup>+</sup>通道；</li><li>Gt蛋白偶联的光敏感受体的活化诱发cGMP门控阳离子通道的关闭。</li></ul><p><strong>激活或抑制腺苷酸环化酶的G蛋白偶联受体所介导的信号通路</strong></p><p>特点：G<sub>α</sub>亚基的首要效应酶腺苷酸环化酶，通过腺苷酸环化酶活性的变化调节靶细胞内第二信使cAMP的水平，进而影响信号通路的下游事件。</p><p>主要功能：</p><ul><li>对肝细胞和肌细胞糖原代谢进行调节；</li><li>对真核细胞基因表达进行调控。</li></ul><p><strong>激活磷脂酶C，以IP<sub>3</sub>和DAG作为双信使的G蛋白偶联受体所介导的信号通路</strong></p><p>特点：胞外信号被膜受体接受后，同时产生两个胞内信使，分别激活IP<sub>3</sub>-Ca<sup>2+</sup>和DAG-PKC两种不同的信号通路。</p><p>主要功能：</p><ul><li>驱动心机细胞收缩；</li><li>引发平滑肌舒张；</li><li>参与众多生理功能涉及细胞“短期生理效应”（细胞分泌、肌肉收缩等），又涉及细胞增殖、分化等“长期生理效应”。</li></ul><h4 id="cAMP信号通路和磷脂酰肌醇信号通路有哪些联系和区别？"><a class="header-anchor" href="#cAMP信号通路和磷脂酰肌醇信号通路有哪些联系和区别？"></a>cAMP信号通路和磷脂酰肌醇信号通路有哪些联系和区别？</h4><p>两者都属于G蛋白偶联受体所介导的细胞信号通路。</p><p>以cAMP为第二信使的信号通路中，主要是通过cAMP激活蛋白激酶A（PKA）所介导的。</p><p>磷脂酰肌醇信号通路中，胞外信号被膜受体接受后，同时产生两个胞内信使，IP<sub>3</sub>刺激细胞内质网释放Ca<sup>2+</sup>，DAP激活PKC。</p><h4 id="以RTK为例-简述酶联受体介导的信号转导过程。"><a class="header-anchor" href="#以RTK为例-简述酶联受体介导的信号转导过程。"></a>以RTK为例,简述酶联受体介导的信号转导过程。</h4><ol><li>在静息状态下RTK活性很低，配体的结合导致受体二聚化，当受体二聚化后，激活受体的蛋白酪氨酸激酶的活性，进而在二聚体内彼此交叉磷酸化受体胞内肽段的一个或多个酪氨酸残基（受体自磷酸化）。</li><li>活化的RTK通过磷酸酪氨酸残基可以结合多种细胞质中带有SH2结构域的蛋白，其中一类是接头蛋白，另一类是在信号通路中有关的酶。这两类RTK结合蛋白的结构和功能不同，但他们都具有两个高度保守而无催化活性的结构域SH2和SH3。</li><li>GRB2作为一种接头蛋白既与活化受体上的特异磷酸酪氨酸残基结合又与胞质蛋白鸟苷酸交换因子SOs结合，具有鸟苷酸交换因子活性的Sos蛋白与Ras结合导致活化Ras的构象改变，使非活性的Ras-GDP转换成有活性的Ras-GTP。</li></ol><p>以Ras激活Raf为例：</p><ol start="4"><li>活化是Ras蛋白与Raf（MAPKKK）的N端结构域结合并使其激活。</li><li>活化的Raf结合并磷酸化另一种蛋白激酶MAPKK</li><li>MAPKK磷酸化其唯一底物MAPK并使其激活</li><li>活化的MAPK进入细胞核，可使许多种底物蛋白的丝氨酸/苏氨酸残基磷酸化，包括调节细胞周期和细胞分化的特异性蛋白表达的转录因子，从而修饰它们的活性。</li></ol><p><img src="http://img.whl123456.top/image/image-20200701005128687.png" alt="P177"></p><p><img src="http://img.whl123456.top/image/image-20200701005209361.png" alt="P178"></p><h2 id="细胞增殖调控和细胞分化"><a class="header-anchor" href="#细胞增殖调控和细胞分化"></a>细胞增殖调控和细胞分化</h2><h3 id="问答题-v9"><a class="header-anchor" href="#问答题-v9"></a>问答题</h3><h4 id="简述细胞周期各时相的特点。并以MPF为例说明细胞周期的调控特点。"><a class="header-anchor" href="#简述细胞周期各时相的特点。并以MPF为例说明细胞周期的调控特点。"></a>简述细胞周期各时相的特点。并以MPF为例说明细胞周期的调控特点。</h4><p>G<sub>1</sub>期，开始合成细胞生长所需要的各种蛋白质、糖类、脂质等，但不合成细胞核DNA。</p><p>S期，细胞开始合成DNA和新的组蛋白。</p><p>G<sub>2</sub>期，此时细胞核内DNA含量已经增加一倍，其他结构物质和相关的亚细胞结构完成进入M期的必要准备。</p><p>M期，进行有丝分裂或或减数分裂。</p><hr><ol><li><p>MPF即CDK1，或p34<sup>cdc2</sup>激酶，由p34<sup>cdc2</sup>蛋白和周期蛋白B（cyclin B）结合而成。p34<sup>cdc2</sup>蛋白在细胞周期中的含量相对稳定，而周期蛋白B的含量则呈现出周期性变化。周期蛋白B一般在G<sub>1</sub>晚期开始合成，通过S 期，其含量不断增加，达到G<sub>2</sub>期，含量达到最大值。当p34<sup>cdc2</sup>蛋白与周期蛋白B结合后，表现出激酶活性。到G<sub>2</sub>晚期阶段，CDK1活性达到最大值并一直维持到M期的中期阶段。</p></li><li><p>CDK1激酶活性受到很多因素的综合调节。周期蛋白与CDK1结合是CDK1激酶活性表现的前提条件。但是，周期蛋白与CDK1结合是CDK1活化的必要不充分条件，还需要weel/mikl激酶和CDK1活化激酶催化CDK1的Thr14、Tyr15 、Thr161 磷酸化，然后，CDK1在磷酸酶Cdc25C的催化下，其Thr14 和Tyr15 去磷酸化，最终表现出激酶活性。</p></li><li><p>CDK1激酶通过使某些蛋白磷酸化，改变其下游的某些蛋白质的构象从而启动其功能，实现其调控细胞周期的目的。比如，组蛋白H1 磷酸化，促进染色体凝集；核纤层蛋白磷酸化，促进核纤层解聚；核仁蛋白磷酸化，促进核仁解体；p60<sup>c-Src</sup>蛋白磷酸化，促进细胞骨架重排；C-ab 1蛋白磷酸化，促进调整细胞形态等。</p></li><li><p>活化的CDK1促使分裂期细胞在分裂前期执行下列生化事件：</p><ul><li>染色质开始浓缩形成有丝分裂染色体；</li><li>细胞骨架解聚，有丝分裂纺锤体开始装配；</li><li>高尔基复合体、内质网等细胞器解体，形成小的膜泡。</li></ul></li><li><p>在有丝分裂的后期，活化的后期促进因子APC主要介导两类蛋白质降解：后期抑制因子和有丝分裂周期蛋白。前者维持姐妹染色单体粘连，抑制后期启动；后者的降解意味着CDK1失去活性，有丝分裂即将结束，即染色体开始去凝集，核膜重建。</p></li></ol><h4 id="细胞周期中有哪些检验点？各起何作用？"><a class="header-anchor" href="#细胞周期中有哪些检验点？各起何作用？"></a>细胞周期中有哪些检验点？各起何作用？</h4><p>G<sub>1</sub>期检验点：在G<sub>1</sub>期的晚期阶段，分裂的细胞可以通过一个特定时期进入 S 期，开始细胞核 DNA 合成，并继续运行直到完成细胞分裂， 这个特定时期称为检验点。在酵母中称为起始点（start），在哺乳动物中称为限制点（R 点）。G<sub>1</sub>期检验点的主要事件包括：DNA 是否损伤， 细胞外环境是否适宜，细胞体积是否足够大等。防止DNA 损伤或突变的细胞进入S期。</p><p>S期检验点：在S期内发生DNA 损伤如DNA 双链发生断裂时，S期内部检验点被激活，从而抑制复制起始点的启动，使DNA 复制速度减慢，S 期延长，同时激活DNA 修复和复制叉的恢复等机制。S 期检验点的主要事件是DNA 复制是否完成。出现损伤或未完成则使DNA 修复或减缓合成速度。</p><p>G<sub>2</sub>期检验点：细胞能否顺利进入M期要受到G<sub>2</sub>期检验点的控制， G<sub>2</sub>期检验点的主要事件包括：DNA 是否损伤， 细胞是否已生长到合适大小，环境因素是否利于细胞分裂等。阻止带有DNA 损伤的细胞进入M期，使得细胞有充足的时间将损伤的DNA 修复。</p><p>中-后期检验点（纺锤体组装检验点）：可以阻止染色体分离，直到姐妹染色单体正确地连接于有丝分裂纺锤体上。纺锤体组装检验点的主要事件包括：监控纺锤体微管与染色单体动粒的连接，染色体在赤道面的队列和向纺锤体两极的分离等。若这些事件未正确完成， 检验点将阻止细胞从分裂中期进入后期。</p><h4 id="什么是细胞分化？细胞分化的本质是什么？举例说明理由。"><a class="header-anchor" href="#什么是细胞分化？细胞分化的本质是什么？举例说明理由。"></a>什么是细胞分化？细胞分化的本质是什么？举例说明理由。</h4><p>在个体发育中，由一种相同的细胞类型经细胞分裂后逐渐在形态、结构和功能上形成稳定性差异，产生不同的细胞类群的过程称为细胞分化。</p><p>细胞分化的本质是基因组在时间和空间上的选择性表达，通过不同基因表达的开启或关闭，最终产生标志性蛋白质。如鸡的输卵管细胞合成卵清蛋白；胰岛β细胞合成胰岛素。</p><h1>自测</h1><h2 id="名词解释-v8"><a class="header-anchor" href="#名词解释-v8"></a>名词解释</h2><p><strong>细胞生物学</strong>：<u>细胞生物学是研究和揭示细胞基本生命活动规律的科学，它从显微、亚显微与分子水平上研究细胞结构与功能，细胞增殖、分化、代谢、运动、衰老、死亡，以及细胞信号转导，细胞基因表达与调控，细胞起源与进化等重大生命过程。</u></p><p><strong>细胞</strong>：<u>细胞是生物体结构与功能的基本单位。</u></p><p><strong>细胞学说</strong>：<u>细胞学说是由施旺和施莱登两人共同提出，并由一系列的学者进行修正的学说，其基本内容包括：细胞是有机体，一切动植物都是由细胞发育而来，并由细胞和细胞产物构成；每个细胞是一个相对独立的单位，既有“它自己”的生命，又对与其他细胞共同组成的整体的生命有所助益；新的细胞可以通过已存在的细胞繁殖产生。</u></p><p><strong>生物膜</strong>：<u>细胞中所有的膜结构统称生物膜。</u></p><p><strong>桥粒</strong>：<u>桥粒是连接相邻细胞间的锚定连接方式， 最明显的形态特征是细胞内锚蛋白形成独特的盘状致密斑， 一侧与细胞内的中间丝相连， 另一侧与跨膜黏附性蛋白质相连， 在两个细胞之间形成纽扣样结构， 将相邻细胞铆接在一起。</u></p><p><strong>脑磷脂</strong>：<u>磷脂酰乙醇胺，是3-磷酸甘油的衍生物。</u></p><p><strong>载体（蛋白）</strong>：<u>膜上一类转运蛋白，可特异的、可逆的与特定的溶质分子结合，通过一系列构象改变介导溶质分子的跨膜转运。</u></p><p><strong>网格蛋白</strong>：<u>由3个二聚体形成三脚蛋白复合体，每个二聚体包括1条相对分子质最为1.8×10<sup>5</sup> 的重链和1条3.5×10<sup>4</sup>~4×10<sup>4</sup>的轻链，是包被的结构单位。</u></p><p><strong>水孔蛋白</strong>：<u>是一类具有6个α螺旋区的蛋白质家族， 通常形成四聚体的膜蛋白以行使其转运水或甘油等分子的功能。</u></p><p><strong>内膜系统</strong>：<u>是指在结构、功能乃至发生上相互关联、由单层膜包被的细胞器或细胞结构。主要包括内质网、高尔基体、溶酶体、胞内体和分泌泡等。</u></p><p><strong>细胞质基质</strong>：<u>在真核细胞的细胞质中，除去可分辨的细胞器以外的胶状物质，占据着细胞膜内、细胞核外的细胞内空间，称细胞质基质。</u></p><p><strong>分子伴侣</strong>：<u>存在于细胞质基质或细胞器中，可以识别正在合成或部分折叠的多肽，并与之某些部位结合，协助其转运、正确折叠或装配的一类蛋白质，但其本身不参与终产物的形成。</u></p><p><strong>蛋白酶体</strong>：<u>是细胞内降解蛋白质的大分子复合体，由约50种蛋白质亚基组成相对分子质量为2×10<sup>6</sup> ~ 2.4×10<sup>6</sup>，富含ATP 依赖的蛋白酶活性，其功能然若细胞内蛋白质破碎机。</u></p><p><strong>微体</strong>：<u>过氧化物酶体又称微体，是由单层膜围绕的内含一种或几种氧化酶类的细胞器。</u></p><p><strong>细胞骨架</strong>：<u>是指存在于真核细胞中的蛋白纤维网架体系。</u></p><p><strong>微丝</strong>：<u>是指真核细胞中由肌动蛋白组成，直径为7nm的骨架纤维。</u></p><p><strong>微管</strong>：<u>是指由微管蛋白亚基组装而成的管状结构。</u></p><p><strong>踏车行为</strong>：<u>是指微丝的正极由于肌动蛋白亚基的不断添加而延长，而负极则由于肌动蛋白亚基去组装而缩短的现象。</u></p><p><strong>微管组织中心</strong>：<u>是指在活细胞内，能够起始微管的成核作用，并使之延伸的细胞结构，主要包括中心体、纤毛基部、鞭毛基部。</u></p><p><strong>核小体</strong>：<u>是染色质的基本单位，直径约10nm 的球形小体，由组蛋白和200bp左右的DNA组成。</u></p><p><strong>核定位信号</strong>：<u>亲核蛋白上含有的特殊氨基酸序列，以保证整个蛋白质能够通过核孔复合体被转运到细胞核内。</u></p><p><strong>染色质</strong>：<u>指间期细胞核内由DNA、组蛋白、非组蛋白及少量RNA组成的线性复合结构, 是间期细胞遗传物质存在的形式。</u></p><p><strong>动粒</strong>：<u>在主缢痕处两个染色单体的外侧表面部位的特殊结构，它与染色体微管接触，是微管蛋白的组织中心。</u></p><p><strong>多线染色体</strong>：<u>在某些细胞有丝分裂期间，DNA 多次复制而细胞不分裂。产生的子染色体并行排列，且体细胞内同源染色体配对，紧密结合在一起从而阻止染色质纤维进一步聚缩，形成体积很大的多线染色体。</u></p><p><strong>核纤层</strong>：<u>主要由3种核纤层蛋白构成的中间纤维网络片层结构，紧贴内层核膜下，与胞质中间丝、核基质有密切联系。</u></p><p><strong>蛋白质分选</strong>：<u>是指在核糖体上合成的蛋白质，通过信号肽，在翻译的同时进入内质网，然后经过各种加工和修饰，使不同去向的蛋白质带上不同的标记，最后经过高尔基体反面膜囊进行分选，包装到不同类型的小泡，并运送到目的地的过程。</u></p><p><strong>信号肽</strong>：<u>位于蛋白质的N端，一般由16~26个氨基酸残基组成，其中包括疏水核心区、信号肽的C端和N端等3 部分，在蛋白质合成中将核糖体引导到内质网，进入内质网后通常被切除，无严格的专一性。</u></p><p><strong>膜泡运输</strong>：<u>是蛋白质分选的一种特有的方式，普遍存在于真核细胞中。大分子和颗粒物质被运输时由膜包围形成膜泡，通过一系列膜囊泡的形成和融合来完成转运的过程。</u></p><h2 id="绪论-v2"><a class="header-anchor" href="#绪论-v2"></a>绪论</h2><details><summary>细胞生物学的发展历史大致可划分为哪几个阶段</summary>细胞生物学的发展大致可划分为5个阶段：<ul><li>细胞的发现</li><li>细胞学说的建立</li><li>细胞学的经典时期</li><li>实验细胞学与细胞学的分支及其发展</li><li>细胞生物学学科的形成与发展</li></ul></details><details><summary>如何理解细胞是生命活动的基本单位</summary><ul><li>细胞是构成有机体的基本单位；</li><li>细胞是代谢与功能的基本单位；</li><li>细胞是有机体生长与发育的基础；</li><li>细胞是繁殖的基本单位，是遗传的桥梁；</li><li>细胞是生命起源的归宿，是生物进化的起点。</li></ul><p>故细胞是生命活动的基本单位。</p></details><details><summary>比较真核细胞与原核细胞</summary><p>真核细胞与原核细胞最根本的区别可以归纳为两条：</p><ul><li>生物膜系统的分化与演变：</li></ul><p>​       真核细胞以膜系统的分化为基础，首先分化为两个独立的部分——细胞核与细胞质，细胞质内又以膜系统为基础分隔为结构更精细、功能更专一的单位——各种重要的细胞器。细胞内部结构与职能的分工是真核细胞区别于原核细胞的重要标志。细胞骨架为细胞内部空间布局提供了支架。</p><ul><li>遗传信息量与遗传装置的扩增与复杂化：<ul><li>真核细胞的基因组一般远远大于原核细胞的，作为遗传信息载体的DNA 也由原核细胞的环状单倍性变为线状多倍性；</li><li>原核细胞基因表达的调控主要以操纵子的形式来进行，这种简单的调控方式能适应多种不利环境，进行快速调节，真核细胞因细胞核的存在，使表达实现了多层次调控；</li><li>真核生物有不编码任何蛋白质或RNA 的基因间隔序列和内含子；</li><li>真核细胞拥有多条DNA 分子， 并且DNA 与蛋白质形成交替存在的染色质和染色体；</li><li>真核细胞发展出一整套由酶和调控蛋白组成的复杂精密的体系，严格调控细胞增殖，原核细胞的增殖没有严格阶段，也没有染色质与染色体结构的交替，更无纺锤体的出现。</li></ul></li></ul></details><details><summary>病毒与细胞在起源上的可能关系有几种？目前哪种观点更有说服力，有哪些证据？</summary>起源上目前存在3种主要观点：<ul><li>生物大分子→病毒→细胞</li><li>生物大分子→细胞、病毒</li><li>生物大分子→细胞→病毒</li></ul><p>目前，第二与第三种比较易于接受，第三种观点得到了更多实验结果的支持：</p><ul><li>在原核细胞中，环形DNA 分子的附加体可以质粒的形式在细胞中复制，也可以整合在细菌的染色体中。其行为与细菌病毒λ噬菌体类似。</li><li>真核生物中，尤其是脊椎动物中普遍存在的第二类反转录转座子的两端具有长末端重复序列，其结构与整合于细胞基因组上的反转录病毒十分相似。二者可能有相同的起源。</li><li>已有的证据表明，有些病毒（如腺病毒）的核酸与哺乳动物细胞DNA 某些片段的碱基序列十分相似。</li></ul></details><h2 id="细胞质膜-v2"><a class="header-anchor" href="#细胞质膜-v2"></a>细胞质膜</h2><details><summary>质膜是否具流动性？请设计实验证明。</summary>质膜具有流动性。可以使用荧光漂白恢复技术证明：<ul><li>首先用荧光物质标记膜蛋白或膜脂</li><li>然后用激光束照射细胞表面某一区域， 使被照射区域的荧光悴灭变暗形成一个漂白斑。</li><li>如果悴灭区域的亮度逐渐增加， 最后恢复到与周围的荧光光强度相等，则说明质膜具有流动性。</li></ul></details><details><summary>简述生物膜的基本成分与结构模型</summary>生物膜的基本成分有膜脂和膜蛋白<ul><li>膜脂是生物膜的基本组成成分，主要包括甘油磷脂、鞘脂和固醇3种基本类型</li><li>膜蛋白赋予生物膜非常重要的生物学功能。根据膜蛋白分离的难易程度及其与脂分子的结合方式，可分为：外在膜蛋白、内在膜蛋白和脂锚定膜蛋白3种基本类型。</li></ul><p>生物膜的结构模型根据提出顺序有“蛋白质—脂质—蛋白质” 的三明治式模型、单位膜模型、流动镶嵌模型和脂筏模型。<br>流动镶嵌模型主要强调：</p><ul><li>膜的流动性， 即膜蛋白和膜脂均可侧向运动。</li><li>膜蛋白分布的不对称性， 有的结合在膜表面， 有的嵌入或横跨脂双分子层。</li></ul><p>脂筏模型是对膜流动性的新的理解。在甘油磷脂为主体的生物膜上， 胆固醇、鞘磷脂等富集区域形成相对有序的脂相， 如同漂浮在脂双层上的“脂筏”一样载着执行某些特定生物学功能的各种膜蛋白。</p></details><details><summary>什么是去垢剂？分为哪几类？去垢剂的主要作用是什么？</summary>去垢剂是一端亲水、一端疏水的两性小分子，是分离与研究膜蛋白的常用试剂。<p>去垢剂分为离子型去垢剂（如SDS）和非离子型去垢剂（如Triton X-100）两种类型。</p><p>去垢剂可以插入膜脂， 与膜脂或膜蛋白的跨膜结构域等疏水部位结合， 形成可溶性的微粒。多用于膜蛋白的分离与纯化。</p></details><details><summary>生物膜的不对称性主要体现在哪几个方面？生物学意义是什么？</summary>生物膜的不对称性主要体现在：<ul><li>同一种膜脂在脂双层中的分布不同</li><li>同一种膜蛋白在脂双层中的分布都有特定的方向或拓扑学特征</li><li>糖蛋白和糖脂的糖基部分均位于细胞质膜的外侧</li></ul><p>生物膜的不对称性的生物学意义：</p><ul><li>糖脂的不对称分布是完成其生理功能的结构基础；</li><li>磷脂分子不对称分布的原因和生物学意义还不很清楚；</li><li>膜蛋白的不对称性是生物膜完成复杂的在时间与空间上有序的各种生理功能的保证。</li></ul></details><details><summary>根据功能不同，细胞连接可以分为哪几类？各有什么特点？</summary>可分为：封闭连接、锚定连接、通讯连接<ul><li>封闭连接：将相邻上皮细胞的质膜紧密地连接在一起， 阻止溶液中的小分子沿细胞间隙从细胞一侧渗透到另一侧。紧密连接是这种连接的典型代表。</li><li>锚定连接：通过细胞膜蛋白及细胞骨架系统将相邻细胞， 或细胞与胞外基质间黏着起来。根据直接参与细胞连接的细胞骨架纤维类型的不同，锚定连接又分为与中间丝相关的锚定连接与肌动蛋白纤维相关的锚定连接。前者包括桥粒和半桥粒；后者主要有黏着带和黏着斑。当细胞形成组织后，由于细胞间或者细胞与胞外基质间通过锚点连接分散作用力。从而增强细胞承受机械力的能力。</li><li>通讯连接：介导相邻细胞间的物质转运、化学或电信号的传递， 主要包括动物细胞间的间隙连接、神经元之间或神经元与效应细胞之间的化学突触和植物细胞间的胞间连丝。</li></ul></details><h2 id="物质的跨膜运输-v2"><a class="header-anchor" href="#物质的跨膜运输-v2"></a>物质的跨膜运输</h2><details><summary>简述被动运输与主动运输二者之间有哪些相同点和不同点。</summary>相同点：两者都需要载体参与<p>不同点：</p><ul><li>被动运输不需要能量，而主动运输需要</li><li>被动运输是顺电化学梯度或浓度梯度，而主动运输一般是逆着电化学梯度或浓度梯度</li></ul></details><details><summary>离子通道可以分为哪几种？作用机制分别是什么？</summary>离子通道可分为三种，分别是电压门通道、配体门通道和应力激活通道<ul><li>电压门通道：带电荷的蛋白质结构域会随跨膜电位梯度的改变而发生相应的移动， 从而使离子通道开启或关闭。</li><li>配体门通道：细胞内外的某些小分子配体与通道蛋白结合继而引起通道蛋白构象改变， 从而使离子通道开启或关闭。</li><li>应力激活通道：通道蛋白感应应力而改变构象，从而开启通道形成离子流， 产生电信号</li></ul></details><details><summary>根据能量来源的不同，主动运输可以分为哪几类？</summary>可分为由ATP 直接提供能量( ATP 驱动泵）、间接提供能量（协同转运或偶联转运蛋白）以及光驱动泵。</details><details><summary>简述钠钾泵（钠钾ATP酶）的特点及其主要生理功能。</summary>特点：<ul><li>由2 个α和2个β亚基组成四聚体</li><li>每个循环消耗一个ATP 分子，可以逆着电化学梯度泵出3个Na<sup>+</sup>和泵入2个K<sup>+</sup></li><li>由ATP 直接提供能量的主动转运，而非协同转运</li></ul><p>Na<sup>+</sup>-K<sup>+</sup>泵主要生理功能：</p><ul><li>维持细胞膜电位：每一个工作循环下来，Na<sup>+</sup>-K<sup>+</sup>泵将从细胞泵出3 个Na<sup>+</sup>并泵入2个K<sup>+</sup>， 对膜电位的形成起到了一定作用。</li><li>维持动物细胞渗透平衡：Na<sup>+</sup>-K<sup>+</sup>泵不断地将Na<sup>+</sup>泵到胞外维持了细胞的渗透平衡。还有Cl<sup>-</sup>（靠膜电位停留在胞外） 参与维持动物细胞渗透压平衡。</li><li>吸收营养：动物细胞对葡萄糖或氨基酸等有机物吸收的能量由蕴藏在Na<sup>+</sup>电化学梯度中的势能提供。</li></ul></details><details><summary>以LDL为例，简述受体介导的胞吞作用的过程。</summary><ul><li>胆固醇在血液中的运输通过与磷脂和蛋白质结合形成低密度脂蛋白（LDL）</li><li>LDL与细胞表面的低密度脂蛋白受体特异地结合形成受体——LDL复合物</li><li>通过网格蛋白包被膜泡的内化作用进入细胞</li><li>经脱包被作用并与胞内体融合</li><li>胞内体的低pH环境可引起LDL与受体分离</li><li>胞内体以出芽的方式形成含有受体的小囊泡，返回细胞质膜，受体重复使用</li><li>含有LDL 的胞内体与溶酶体融合，低密度脂蛋白被水解， 释放出胆固醇和脂肪酸供细胞利用。</li></ul></details><h2 id="细胞质基质与内膜系统-v2"><a class="header-anchor" href="#细胞质基质与内膜系统-v2"></a>细胞质基质与内膜系统</h2><details><summary>细胞质基质的主要功能是什么？</summary><ol><li>完成许多中间代谢过程：如糖酵解过程、磷酸戊糖途径、糖醋酸途径、糖原的合成与部分分解过程等。</li><li>为某些蛋白质合成和脂肪酸合成提供场所</li><li>与细胞质骨架的相关功能：<ul><li>细胞质骨架维持细胞的形态、细胞的运动、细胞内的物质运输及能量传递有关；</li><li>细胞质骨架是细胞质基质结构体系的组织者，为细胞质基质中其他成分和细胞器提供锚定位点</li></ul></li><li>与细胞膜的相关功能：<ul><li>细胞内的各种膜相细胞器使细胞质基质产生区室化，从而通过生物膜结构将蛋白质等生物大分子限定在膜的二维平面上，促进反应高效而有序地进行；</li><li>依靠细胞膜或细胞器膜上的泵蛋白和离子通道维持细胞内外跨膜的离子梯度，依靠细胞膜某些协同转运蛋白调节细胞质基质的pH ，维持细胞内环境稳定。</li></ul></li><li>与蛋白质的修饰和选择性降解等方面有关：<ul><li>蛋白质的修饰：辅酶或辅基与酶的共价结合；磷酸化与去磷酸化；蛋白质糖基化作用；甲基化修饰；酰基化。</li><li>控制蛋白质的寿命</li><li>降解变性和错误折叠的蛋白质</li><li>帮助变性或错误折叠的蛋白质重新折叠，形成正确的分子构象</li></ul></li></ol></details><details><summary>简述蛋白质降解的泛素化途径。</summary><ul><li>泛素活化酶(E1) 通过形成酰基－腺甘酸中介物使泛素分子C端被激活， 该反应需要ATP；</li><li>转移活化的泛素分子与泛素结合酶(E2) 的半胱氨酸残基结合；</li><li>异肽键形成，即与E2结合的泛素羧基和靶蛋白赖氨酸侧链的氨基之间形成异肽键，该反应由泛素连接酶(E3)催化完成。</li></ul><p>重复上述步骤，形成具有寡聚泛素链的泛素化靶蛋白。泛素化标签被蛋白酶体帽识别，并利用ATP 水解提供的能量驱动泛素分子的切除和靶蛋白解折叠，去折叠的蛋白质转移至蛋白酶体核心腔内被降解。</p></details><details><summary>内质网可以分为哪2类？详细说明内质网的功能有哪些？</summary>内质网可分为糙面内质网和光面内质网<ol><li>蛋白质的合成是糙面内质网的主要功能。在糙面内质网上，多肽链边延伸边穿过内质网膜进入内质网腔，以这类方式合成的蛋白质主要包括：向细胞外分泌的蛋白质；膜的整合蛋白；细胞器中的可溶性驻留蛋白。</li><li>光面内质网是脂质合成的重要场所。内质网合成细胞需要包括磷脂和胆固醇在内的几乎全部膜脂，其中最主要的磷脂是磷脂酰胆碱（卵磷脂）。</li><li>蛋白质修饰与加工。<ul><li>发生在内质网和高尔基体的蛋白质糖基化；</li><li>在内质网发生二硫键的形成；</li><li>蛋白质折叠和多亚基蛋白的装配；</li><li>在内质网、高尔基体和分泌泡发生特异性的蛋白质水解切割；</li><li>在内质网的胞质侧发生的蛋白质修饰酰基化；</li><li>少数蛋白发生，新生肽的脯氨酸和赖氨酸要进行羟基化，形成羟脯氨酸和羟赖氨酸。</li></ul></li><li>新生多肽的折叠与组装。<ul><li>内质网中有一种蛋白二硫键异构酶（PDI），它附着在内质网膜腔面上，可以切断二硫键，从而帮助新合成的蛋白质重新形成二硫键并产生正确折叠的构象。</li><li>内质网含有一种结合蛋白(Bip)，是属于Hsp70家族的分子伴侣，在内质网中有两个作用：Bip同进入内质网的未折叠蛋白质的疏水氨基酸结合，防止多肽链不正确地折叠和聚合，或者识别错误折叠的蛋白质或未装配好的蛋白质亚单位，并促进它们重新折叠与装配；防止新合成的蛋白质在转运过程中变性或断裂。</li></ul></li><li>内质网的其他功能。<ul><li>肝细胞中的光面内质网中还含有一些酶具有解毒作用</li><li>心肌细胞和骨胳肌细胞中含有发达的特化的光面内质网（肌质网）是储存Ca<sup>2+</sup>的细胞器，对Ca<sup>2+</sup>具调节作用。</li><li>某些合成固醇类激素的细胞光面内质网非常丰富，其中含有制造胆固醇并进一步产生固醇类激素的一系列的酶。</li></ul></li></ol></details><details><summary> N-连接糖基化与O-连接糖基化的主要区别是什么？</summary><table><thead><tr><th>特征</th><th>N-连接</th><th>O-连接</th></tr></thead><tbody><tr><td>合成部位</td><td>糙面内质网和高尔基体</td><td>高尔基体</td></tr><tr><td>合成方式</td><td>来自同—个寡糖前体</td><td>—个个单糖加上去</td></tr><tr><td>与之结合的氨基酸残基</td><td>天冬酰胺</td><td>丝氨酸、苏氨酸、羟赖氨酸、羟脯氨酸</td></tr><tr><td>最终长度</td><td>至少5 个糖残基</td><td>一般1~4个糖残基，但ABO 血型抗原较长</td></tr><tr><td>第一个糖残基</td><td>N-乙酰葡糖胺</td><td>N-乙酰半乳糖胺等</td></tr></tbody></table></details><details><summary>高尔基体的主要功能包括哪几方面？</summary><ol><li>高尔基体与细胞的分泌活动：分泌性蛋白、多种细胞质膜上的膜蛋白、溶酶体中的酸性水解酶及胶原等胞外基质成分，其定向转运过程都是通过高尔基体完成的。</li><li>蛋白质的糖基化及其修饰：大多数蛋白质或膜脂的糖基化修饰和与高尔基体有关的多糖的合成，主要发生在高尔基体。</li><li>蛋白酶的水解和其他加工过程：有些多肽，经特异性水解才成为有生物活性的多肽。</li></ol></details><details><summary>根据处于完成生理功能的阶段的不同，溶酶体可以分为哪几类？溶酶体的功能是什么？结合高尔基体的功能，谈谈溶酶体是如何发生的？</summary><p>大致可分为初级溶酶体、次级溶酶体、残质体</p><p>溶酶体的功能：</p><ol><li>清除无用的生物大分子、衰老的细胞器及衰老损伤和死亡的细胞</li><li>防御功能</li><li>作为细胞内的消化“器官”为细胞提供营养</li><li>在分泌腺细胞中，溶酶体常常摄入分泌颗粒，参与分泌过程的调节</li><li>某些特定细胞程序性死亡，死亡后的细胞被周围吞噬细胞溶酶体消化清除。</li><li>参与受精过程中的顶体反应</li></ol><p>溶酶体的发生：</p><ol><li>溶酶体酶在糙面内质网上合成并经N－连接的糖基化基础修饰，然后转至高尔基体，在高尔基体的顺面膜囊中寡糖链上的甘露糖残基被磷酸化形成甘露糖-6-磷酸(M6P)；</li><li>在高尔基体的反面膜囊和TGN 膜上存在M6P的受体，溶酶体酶与其他蛋白质区分开来，并得以浓缩。</li><li>以出芽的方式形成网格蛋白/AP包被膜泡转运到溶酶体中；</li><li>进入前溶酶体的酸性环境后，M6P受体与M6P分离，并返回高尔基体。</li></ol></details><h2 id="细胞骨架-v2"><a class="header-anchor" href="#细胞骨架-v2"></a>细胞骨架</h2><details><summary>细胞质骨架包括哪3种结构组分？每一种组分的结构成分包括哪些蛋白？各有什么功能？</summary>细胞骨架主要包括微丝(MF)、微管(MT) 和中间丝(IF) 3种结构组分。<p>微丝</p><p>结构成分：主要结构成分是肌动蛋白，其在细胞内有两种存在形式，即肌动蛋白单体（又称球状肌动蛋白)和由单体组装而成的纤维状肌动蛋白。</p><p>功能：</p><ul><li>维持细胞形态；</li><li>赋予质膜机械强度；</li><li>细胞运动；</li><li>构成微绒毛、应力纤维；</li><li>参与胞质分裂；</li><li>参与肌肉收缩等</li></ul><p>微管</p><p>结构成分：α/β-微管蛋白二聚体是细胞质内游离态微管蛋白的主要存在形式， 也是微管组装的基本结构单位</p><p>功能：</p><ul><li>构成细胞的网状支架，维持细胞的形态；</li><li>参与细胞内物质运输；</li><li>细胞器的定位；</li><li>构成纤毛、鞭毛，参与细胞的运动；</li><li>纺锤体和染色体运动;</li></ul><p>中间纤维</p><p>结构成分，有6种主要类型：</p><ol><li><p>角蛋白，单体分为：酸性角蛋白（Ⅰ型）、中性或碱性角蛋白（Ⅱ型）。通过两者的异二聚体形成角蛋白纤维；</p></li><li><p>Ⅲ型中间丝，波形蛋白、结蛋白、微管成束蛋白、胶质丝酸性蛋白与外周蛋白；</p></li><li><p>Ⅳ型中间丝，包括3种神经丝蛋白亚基和α-介连蛋白；</p></li><li><p>Ⅴ型中间丝蛋白，核纤层蛋白A及其剪切体核纤层蛋白C 与核纤层蛋白B1和B2；</p></li><li><p>Ⅵ型中间丝蛋白，巢蛋白与desmuslin ；</p></li><li><p>晶状体中发现的phakinin/CP49和丝晶蛋白属于“孤儿”类型。</p></li></ol><p>功能：</p><ul><li>细胞抗机械压力的能力；</li><li>角蛋白纤维参与桥粒的形成和维持；</li><li>结蛋白纤维是肌肉Z盘的重要结构组分，对于维持肌肉细胞的收缩装置起重要作用；</li><li>神经元纤维在神经细胞轴突运输中起作用；</li><li>参与传递细胞内机械的或分子的信息；</li><li>中间纤维与mRNA的运输有关；与细胞分化有关：形成跨膜信息通道。</li></ul></details><details><summary>依赖于微管的马达蛋白包括哪几类？各有什么特点？简述微管与细胞内物质运输之间的关系。</summary>依赖于微管的马达蛋白包括驱动蛋白和胞质动力蛋白<p>驱动蛋白特点</p><ol><li>是一条长80nm 的杆状结构，头部一端有两个呈球状的马达结构域，另一端是重链和轻链组成的扇形尾端，中间是重链组成的杆状区。</li><li>驱动蛋白具有许多超家族</li><li>驱动蛋白的行为与其马达结构域在多肽链中的位置有关，大多数以微管为轨道由微管负端向微管正端运送货物，是正端走向的微管发动机</li><li>大部分驱动蛋白可通过多肽链上一段卷曲螺旋相互作用而形成同源二聚体</li></ol><p>细胞质动力蛋白特点</p><ol><li>细胞质动力蛋白是由一个相对分子质量接近1.5×10<sup>6</sup>的巨大蛋白复合物组成，含多个多肽亚单位： 两条具有ATP酶活性的使其沿微管移动的重链，两条中间链和一些轻链。</li><li>动力蛋白是已知马达蛋白中最大、移动速度最快的成员。</li><li>细胞质动力蛋白只有两个重链家族成员，Dync1 h1和Dync1 h2 。</li><li>细胞质动力蛋白以微管为轨道由微管正端向微管负端运送货物，是负端走向的微管发动机</li></ol><p>微管是细胞内物质运输之间的轨道</p></details><details><summary>影响微丝、微管组装的特异性药物有哪些？各有什么特点？</summary><p>影响微丝的有细胞松弛素和鬼笔环肽等。</p><ul><li>细胞松弛素与微丝结合后可以将微丝切断，结合在微丝末端阻抑肌动蛋白在该部位的聚合，但对微丝的解聚没有明显影响，因而用细胞松弛素处理细胞可以破坏微丝的网络结构，并阻止细胞的运动。</li><li>鬼笔环肽与微丝表面有强亲和力，但不与肌动蛋白单体结合，能阻止微丝的解聚，使其保持稳定状态。</li></ul><p>影响微管的有秋水仙素和紫杉醇等</p><ul><li>秋水仙素与微管蛋白亚基结合组装到微管末端后，其他的微管蛋白亚基很难再在该处进行组装，但不影响该微管的去组装，从而导致细胞内微管网络的解体。</li><li>紫杉醇与微管结合后可以阻止微管的去组装，但不影响微管末端的组装微管不停地组装，不会解聚，其结果使细胞周期的运行被终止。</li></ul></details><details><summary>简述骨骼肌细胞的结构组分以及肌肉收缩的滑动模型理论。</summary><p>骨骼肌细胞的结构组分</p><p>骨骼肌细胞是由数百条更细的肌原纤维组成的集束，每根肌原纤维由称为肌节的收缩单元呈线性重复排列而成。每个肌节都表现出特征性的带型。肌原纤维的带状条纹由粗肌丝和细肌丝的纤维有序组装而成。粗肌丝由肌球蛋白组装而成，细肌丝的主要成分是肌动蛋白，辅以原肌球蛋白和肌钙蛋白。肌球蛋白的头部突出于粗肌丝的表面，并可与细肌丝上肌动蛋白亚基结合，构成粗肌丝与细肌丝之间的横桥。</p><p>除此之外还有将细肌丝锚定于Z 盘或质膜上的CapZ、α-辅肌动蛋白和纽蛋白；在肌节中起结构作用的肌联蛋白、伴肌动蛋白和肌营养不良蛋白。</p><p>滑动模型理论：肌肉收缩时肌节缩短，但在肌节内并无粗／细肌丝的长度变化，而只是由神经冲动引发的细肌丝与粗肌丝之间的相对滑动所致。基本过程如下：</p><ol><li>动作电位的产生</li><li>Ca<sup>2+</sup>的释放</li><li>原肌球蛋白位移</li><li>细肌丝与粗肌丝之间的相对滑动<ul><li>在初始状态，组成粗肌丝的肌球蛋白的头部（马达结构域） 没有结合ATP 时，该肌球蛋白的头部与细肌丝结合，并成僵直状态。</li><li>ATP 结合到肌球蛋白的头部导致与肌动蛋白纤维的结合力下降， 肌球蛋白与肌动蛋白分开；</li><li>ATP 水解为ADP+Pi，ATP 水解释放出的能量被肌球蛋白吸收， 导致进一步的构象变化， 头部结构域向前抬升， 并结合到靠近细肌丝正极端的一个肌动蛋白亚基上；</li><li>Pi释放，肌球蛋白颈部结构域发生构象变化，头部与细丝的角度发生变化，拉动细肌丝导致细肌丝相对于粗肌丝的滑动；</li><li>ADP 释放，肌球蛋白的头部结构域与细肌丝之间又回到僵直状态。</li></ul></li></ol></details><details><summary>简述中间纤维（中间丝）的组装模式，并简要介绍中间纤维与核纤层蛋白之间的联系。</summary>中间纤维的组装模式<ol><li>两个单体的杆状区以平行排列的方式形成双股螺旋的二聚体；</li><li>两个二聚体以反向平行和半分子交错的形式组装成四聚体；</li><li>四聚体之间在纵向（首尾） 和侧向相互作用，最终组装成横截面由32个中间丝蛋白分子组成，长度不等的中间丝。</li></ol><p>中间纤维与核纤层蛋白之间的联系</p><p>由Ⅴ型中间丝蛋白组装而成的核纤层结构在核膜的内侧呈正交网状排列。核纤层与内核膜上的核纤层蛋白受体相连，是核膜的重要支撑结构，也是染色质的重要锚定位点。</p></details><h2 id="细胞核-v2"><a class="header-anchor" href="#细胞核-v2"></a>细胞核</h2><details><summary>细胞核由哪几部分组成？主要功能是什么？</summary>细胞核主要由核被膜、核纤层、染色质、核仁及核体组成。<p>细胞核的主要功能：</p><ul><li>是遗传信息的主要贮存库；</li><li>是遗传信息的复制和传递的场所；</li><li>进行遗传信息的表达，是细胞生命活动的控制枢纽。</li></ul></details><details><summary>什么是核孔复合体？简述核孔复合体的结构组成，以及核孔复合体的运输功能有什么特点？</summary>核孔复合体是在核被膜上由多种核孔蛋白构成的联系核质和细胞质的复杂隧道结构。<p>核孔复合体的结构组成：核孔复合体主要由胞质环、核质环、辐和栓4部分组成。</p><ul><li>胞质环：位于核孔边缘的胞质面一侧，环上有8条短纤维对称分布伸向胞质。</li><li>核质环：位于核孔边缘的核质面一侧，环上对称地连有8条细长的纤维，向核内伸入50~70nm，在纤维的末端形成一个直径为60nm 的小环，小环由8 个颗粒构成。</li><li>辐：由核孔边缘伸向中心，呈辐射状八重对称，有位于核孔边缘的“柱状亚单位”、穿过核膜伸入双层核膜的膜间腔的“腔内亚单位”和靠近中心的“环带亚单位”的3个结构域。环带亚单位由8个颗粒状结构环绕形成核孔复合体核质交换的通道。</li><li>栓：位于核孔的中心，呈颗粒状或棒状。</li></ul><p>核孔复合体运输功能及特点，核孔复合体是核质交换的双功能、双向性亲水通道。</p><ul><li>双功能表现在核孔复合体有两种运输方式：被动扩散与主动运输。</li><li>双向性表现在既介导蛋白质的入核转运，又介导RNA、核糖核蛋白颗粒(RNP)的出核转运。</li></ul></details><details><summary>简述染色质组装的两种结构模型。</summary>染色质组装的多级螺旋模型，DNA（压缩7倍）→核小体（压缩6倍）→螺线管（压缩40倍）→超螺线管（压缩5倍）→染色单体<p>由DNA与组蛋白组装成核小体，在组蛋白H1的介导下核小体彼此连接形成直径约10nm的核小体串珠结构，在有组蛋白H1存在的情况下，由直径10nm的核小体串珠结构螺旋盘绕，每圈6个核小体，形成外径25~30nm，螺距12nm的螺线管，螺线管进一步螺旋形成直径为0.4μm 的超螺线管，再进一步螺旋折叠形成直径为2~10μm的染色单体。经过四级螺旋组装形成的染色体结构，共压缩了8400倍。</p><p>染色质组装的放射环结构模型，DNA→核小体→螺线管→DNA复制环→微带→染色单体</p><p>螺线管形成DNA复制环，每18个复制环呈放射状平面排列，结合在核基质上形成微带。微带是染色体高级结构的单位，约10<sup>6</sup>个微带沿纵轴构建成子染色体。</p></details><details><summary>什么是中期染色体的三种功能元件？其主要功能是什么？</summary><p>在细胞世代中确保染色体的复制和稳定遗传，染色体起码应具备3种功能元件，构成染色体DNA的这3种关键序列称为染色体DNA的功能元件。</p><p>三种功能元件的主要功能</p><ul><li>自主复制DNA 序列：确保染色体在细胞周期中能够自我复制，维持染色体在细胞世代传递中的连续性。</li><li>着丝粒DNA 序列：使细胞分裂时已完成复制的染色体能平均分配到子细胞中。</li><li>端粒DNA 序列：保持染色体的独立性和稳定性。</li></ul></details><details><summary>简述核仁的3种基本组分特点及功能，谈谈为什么凡是蛋白质合成旺盛的细胞中核仁都明显偏大。</summary>核仁的3种基本组分：纤维中心，致密纤维组分和颗粒组分<ul><li>纤维中心（FC）：包埋在颗粒组分内部一个或几个浅染的低电子密度的圆形结构。FC中的染色质不形成核小体结构，也没有组蛋白存在，但存在嗜银蛋白。其中磷蛋白C23可能与核仁中染色质结构的调节有关。是rRNA基因的储存位点。</li><li>致密纤维组分（DFC）：是核仁超微结构中电子密度最高的部分，呈环形或半月形包围FC, 由致密的纤维构成，通常见不到颗粒。转录主要发生在FC与DFC的交界处。</li><li>颗粒组分（GC）：是核仁的主要结构。它由直径15-20 nm的RNP构成。代表核糖体亚基成熟和储存的位点。</li></ul><p>蛋白质的合成需要核糖体，核糖体生物发生与核仁有关。在大小亚基合成时，小亚基所需的18S rRNA直接在核仁中合成，装配完成后从核仁运输出来，在核仁的停留时间较短，大亚基组装所需的28S rRNA、5.8S rRNA可以在核仁中合成但5S rRNA需要从核仁之外的其他部位汇集再进行装配，大亚基合成较慢，过多大亚基滞留在核仁中，故蛋白质合成旺盛的细胞中核仁都明显偏大。</p></details><details><summary>什么是核基质？什么是核骨架？核骨架的功能是什么</summary><p>核基质是指真核细胞的核内除染色质、核膜与核仁外，以蛋白质成分为主的网架结构。</p><p>核骨架广义上包括核基质、核纤层以及染色体骨架，狭义上是指核基质。</p><p>核骨架的功能</p><ol><li>维持细胞核的形态</li><li>为DNA、染色质在核中的空间排列提供支附作用</li><li>核骨架与DNA复制、基因表达及染色体的组装与构建有密切关系。</li></ol></details><h2 id="蛋白质分选和膜泡运输-v2"><a class="header-anchor" href="#蛋白质分选和膜泡运输-v2"></a>蛋白质分选和膜泡运输</h2><details><summary>试述细胞内蛋白质的合成部位及其去向（蛋白质分选的途径）。</summary>核细胞中除线粒体和植物细胞叶绿体中能合成少量蛋白质外，绝大多数蛋白质都是由核基因编码，或在游离核糖体上合成，或在糙面内质网膜结合核糖体上合成。<p>核基因编码的蛋白质的分选大体可分2条途径：</p><ul><li>共翻译转运途径：在细胞质基质中多肽链合成起始后，转移到内质网，然后边合成边转入内质网腔，再经高尔基体运输至溶酶体、细胞膜或分泌到细胞外；</li><li>后翻译转运途径：在细胞质基质游离核糖体上完成多肽链的合成，然后转运至膜围绕的细胞器。</li></ul></details><details><summary>简述信号（肽）假说的主要内容。</summary>以分泌蛋白N端序列作为信号肽，指导分泌性蛋白质在内质网膜上合成，然后在信号肽引导下蛋白质边合成边通过移位子蛋白复合体进入内质网腔，在蛋白质合成结束之前切除信号肽。其他类型的蛋白质也含有类似的信号序列，指导蛋白质完成定向运输。</details><details><summary>由核基因编码的蛋白质是如何运送到线粒体中去的？</summary>在游离核糖体上合成的前体蛋白，与胞质蛋白分子伴侣Hsc70结合，并使其保持未折叠或部分折叠状态，其N端具有基质靶向序列，前体蛋白与内外膜接触点附近的输入受体(Tom20/22) 结合，被转运进入输入孔，输入的蛋白进而通过内外膜接触点的输入通道（外膜为Tom40, 内膜为Tim23/17)，线粒体基质分子伴侣Hsc70与输入蛋白结合并水解ATP以驱动基质蛋白的输入。输入的基质蛋白其基质靶向序列，在基质蛋白酶作用下被切除， 同时Hsc70 也从新输入的基质蛋白上释放出来，进而折叠，产生活性构象。</details><details><summary>转运膜泡表面包被蛋白可以分为哪3类？这3类膜泡类型的特征有什么不同？</summary>可分成COPⅡ包被膜泡、COPⅠ包被膜泡和网格蛋白/接头蛋白包被膜泡。<p>COPⅡ包被膜泡：由小分子 GTPase Sar1、 Sec23/Sec24、Sec13/Sec31以及大的纤维蛋白Sec16等组成，介导细胞内顺向运输即负责从内质网→高尔基体的物质运输；</p><p>COPⅠ包被膜泡：COPⅠ包被含有7种蛋白亚基包被蛋白复合物的装配与去装配依赖于ARF。负责回收、转运内质网逃逸蛋白返回内质网；介导高尔基体不同区域间的蛋白质运输。</p><p>网格蛋白/接头蛋白包被膜泡：是一类双层包被的膜泡，外层由网格蛋白组成，内层由接头蛋白复合物组成。纯化的网格蛋白分子呈三腿结构，每个分支含一条重链和一条轻链。负责运输途径质膜→内体；高尔基体→内体；高尔基体→溶酶体、植物液泡。</p></details><details><summary>膜泡运输的关键步骤涉及哪些过程？简述介导转运膜泡与靶膜融合的主要机制。</summary><p>膜泡运输的关键步骤至少涉及如下过程：</p><ul><li><p>供体膜的出芽、装配和断裂，形成不同的包被转运膜泡；</p></li><li><p>在细胞内由马达蛋白驱动、以微管为轨道的膜泡运输；</p></li><li><p>转运膜泡与特定靶膜的锚定和融合。</p></li></ul><p>介导转运膜泡与靶膜融合的主要机制：</p><p>在供体膜上的鸟苷酸交换因子(GEF) 识别并结合特异性Rab蛋白， 诱发GTP置换GDP, 鸟苷酸交换引发Rab蛋白构象改变并暴露其共价结合的脂质基团，从而帮助Rab-GTP蛋白锚定在供体膜上，并随膜泡转移，在靶膜上Rab-GTP与Rab效应器结合，这种结合有助于膜泡锚定和v-SNARE 与t-SNARE 的配对 ;</p><p>v-SNARE 蛋白与同类t-SNARE 胞质结构域相互作用，形成稳定的卷曲SNARE复合体， 将膜泡与靶膜紧密束缚在一起， 伴随SNARE复合物形成后，供体膜泡与靶膜随即融合，两膜融合后，NSF联合α-SNAP 蛋白随即与SNARE 复合体结合，然后NSF 催化ATP 水解，驱动SNARE 复合体解离， 游离的SNARE蛋白再用于其他膜泡的融合。</p><p>具有GTPase活性的Rab蛋白水解与之结合的GTP, 释放可溶性的Rab-GDP 进入细胞质。</p><p>在细胞质中Rab-GDP与GDP 解离抑制物(GDI)结合，从而防止Rab 蛋白从Rab-GDP复合物中释放出来 ，直至与GEF 发生相互作用。</p></details><h2 id="细胞信号转导-v2"><a class="header-anchor" href="#细胞信号转导-v2"></a>细胞信号转导</h2><details><summary>简述细胞信号转导系统的组成及其特性</summary><p>通过细胞表面受体介导的信号通路通常由下列5个步骤组成：</p><ul><li>细胞表面受体特异性识别并结合胞外信号分子（配体），形成受体-配体复合物， 导致受体激活；</li><li>由于激活受体构象改变， 导致信号初级跨膜转导， 靶细胞内产生第二信使或活化的信号蛋白；</li><li>通过胞内第二信使或细胞内信号蛋白复合物的装配， 起始胞内信号放大的级联反应</li><li>细胞应答反应， 如果这种级联反应主要是通过酶的逐级激活， 结果将改变细胞代谢活性， 或者通过基因表达调控蛋白影响细胞基因表达和影响发育， 或者通过细胞骨架蛋白的修饰改变细胞形状或运动；</li><li>由于受体脱敏或受体下调，终止或降低细胞反应。</li></ul><p>信号转导系统的主要特性：</p><ul><li>特异性：细胞受体与胞外配体通过结构互补机制以非共价键结合， 形成受体-配体复合物， 简称具有“结合” 特异性，受体因结合配体而改变构象被激活，介导特定的细胞反应，从而又表现出“ 效应器” 特异性。此外，受体与配体的结合具有饱和性和可逆性的特征。</li><li>放大效应：信号传递至胞内效应器蛋白（通常由酶或离子通道蛋白组成），引发细胞内信号放大的级联反应，如果级联反应主要是通过酶的逐级激活，结果将改变细胞代谢活性。最常见的级联放大作用是通过蛋白质磷酸化实现的。</li><li>网络化与反馈调节机制：细胞信号系统网络化的相互作用是细胞生命活动的重要特征，在细胞内由一系列蛋白质组成的信号转导系统中，细胞对刺激作出适时适度的反应是细胞完成各种生命活动的基础，信号网络化效应有利于克服分子间相互作用的随机性对细胞生命活动的负面干扰。这样的网络特性是由一系列正反馈和负反馈环路组成的，对于及时校正反应的速率和强度是最基本的调控机制。</li><li>整合作用：多细胞生物的每个细胞都处于细胞“社会“ 环境之中，大最的信息以不同组合的方式调节细胞的行为。因此，细胞必须整合不同的信息，对细胞外信号分子的特异性组合作出程序性反应，甚至作出生死抉择，这样才能维持生命活动的有序性。</li></ul></details><details><summary>细胞信号传递的通路随信号受体存在部位不同可分为几大类？各有什么特点？</summary><p>根据靶细胞上的受体存在的部位，可将受体区分为细胞内受体和细胞表面受体。</p><p>故有细胞内受体介导的信号传递和细胞表面的G蛋白偶联受体介导的信号转导、酶联受体介导的信号转导和其他细胞表面受体介导的信号通路。</p><p>细胞内受体介导的信号传递受体位于细胞质基质或核基质中，主要识别和结合小的脂溶性信号分子，其中NO也可以作为气体信号分子进入靶细胞直接与酶接合。</p><p>细胞表面受体主要识别和结合亲水性信号分子，包括分泌型信号分子或膜结合型信号分子。其又分属三大家族：离子通道偶联受体、G蛋白偶联受体和酶偶联受体。</p></details><details><summary>概述G蛋白耦联受体介导的信号通路的组成、特点及主要功能。</summary><p>信号通路按其效应器蛋白的不同可分为3类：</p><ul><li>激活离子通道的G蛋白偶联受体；</li><li>激活或抑制腺苷酸环化酶，以cAMP为第二信使的G蛋白偶联受体；</li><li>激活磷脂酶C，以IP<sub>3</sub>和DAG作为双信使的G蛋白偶联受体。</li></ul><p><strong>激活离子通道的G蛋白偶联受体所介导的信号通路</strong></p><p>特点：当受体与配体结合被激活后，通过偶联G蛋白的分子开关作用，调控跨膜离子通道的开启与关闭，进而调节靶细胞的活性；</p><p>主要功能：</p><ul><li>心肌细胞上M乙酰胆碱受体激活G蛋白开启K<sup>+</sup>通道；</li><li>Gt蛋白偶联的光敏感受体的活化诱发cGMP门控阳离子通道的关闭。</li></ul><hr><p><strong>激活或抑制腺苷酸环化酶的G蛋白偶联受体所介导的信号通路</strong></p><p>特点：G<sub>α</sub>亚基的首要效应酶腺苷酸环化酶，通过腺苷酸环化酶活性的变化调节靶细胞内第二信使cAMP的水平，进而影响信号通路的下游事件。</p><p>主要功能：</p><ul><li>对肝细胞和肌细胞糖原代谢进行调节；</li><li>对真核细胞基因表达进行调控。</li></ul><hr><p><strong>激活磷脂酶C，以IP<sub>3</sub>和DAG作为双信使的G蛋白偶联受体所介导的信号通路</strong></p><p>特点：胞外信号被膜受体接受后，同时产生两个胞内信使，分别激活IP<sub>3</sub>-Ca<sup>2+</sup>和DAG-PKC两种不同的信号通路。</p><p>主要功能：</p><ul><li>驱动心机细胞收缩；</li><li>引发平滑肌舒张；</li><li>参与众多生理功能涉及细胞“短期生理效应”（细胞分泌、肌肉收缩等），又涉及细胞增殖、分化等“长期生理效应”。</li></ul></details><details><summary>cAMP信号通路和磷脂酰肌醇信号通路有哪些联系和区别？</summary>两者都属于G蛋白偶联受体所介导的细胞信号通路。<p>以cAMP为第二信使的信号通路中，主要是通过cAMP激活蛋白激酶A（PKA）所介导的。</p><p>磷脂酰肌醇信号通路中，胞外信号被膜受体接受后，同时产生两个胞内信使，IP<sub>3</sub>刺激细胞内质网释放Ca<sup>2+</sup>，DAP激活PKC。</p></details><details><summary>以RTK为例,简述酶联受体介导的信号转导过程。</summary><ol><li>在静息状态下RTK活性很低，配体的结合导致受体二聚化，当受体二聚化后，激活受体的蛋白酪氨酸激酶的活性，进而在二聚体内彼此交叉磷酸化受体胞内肽段的一个或多个酪氨酸残基（受体自磷酸化）。</li><li>活化的RTK通过磷酸酪氨酸残基可以结合多种细胞质中带有SH2结构域的蛋白，其中一类是接头蛋白，另一类是在信号通路中有关的酶。这两类RTK结合蛋白的结构和功能不同，但他们都具有两个高度保守而无催化活性的结构域SH2和SH3。</li><li>GRB2作为一种接头蛋白既与活化受体上的特异磷酸酪氨酸残基结合又与胞质蛋白鸟苷酸交换因子SOs结合，具有鸟苷酸交换因子活性的Sos蛋白与Ras结合导致活化Ras的构象改变，使非活性的Ras-GDP转换成有活性的Ras-GTP。</li></ol><p>以Ras激活Raf为例：</p><ol start="4"><li>活化是Ras蛋白与Raf（MAPKKK）的N端结构域结合并使其激活。</li><li>活化的Raf结合并磷酸化另一种蛋白激酶MAPKK</li><li>MAPKK磷酸化其唯一底物MAPK并使其激活</li><li>活化的MAPK进入细胞核，可使许多种底物蛋白的丝氨酸/苏氨酸残基磷酸化，包括调节细胞周期和细胞分化的特异性蛋白表达的转录因子，从而修饰它们的活性。</li></ol></details><h2 id="细胞增殖调控和细胞分化-v2"><a class="header-anchor" href="#细胞增殖调控和细胞分化-v2"></a>细胞增殖调控和细胞分化</h2><details><summary>简述细胞周期各时相的特点。并以MPF为例说明细胞周期的调控特点。</summary><p>G<sub>1</sub>期，开始合成细胞生长所需要的各种蛋白质、糖类、脂质等，但不合成细胞核DNA。</p><p>S期，细胞开始合成DNA和新的组蛋白。</p><p>G<sub>2</sub>期，此时细胞核内DNA含量已经增加一倍，其他结构物质和相关的亚细胞结构完成进入M期的必要准备。</p><p>M期，进行有丝分裂或或减数分裂。</p><hr><ol><li><p>MPF即CDK1，或p34<sup>cdc2</sup>激酶，由p34<sup>cdc2</sup>蛋白和周期蛋白B（cyclin B）结合而成。p34<sup>cdc2</sup>蛋白在细胞周期中的含量相对稳定，而周期蛋白B的含量则呈现出周期性变化。周期蛋白B一般在G<sub>1</sub>晚期开始合成，通过S 期，其含量不断增加，达到G<sub>2</sub>期，含量达到最大值。当p34<sup>cdc2</sup>蛋白与周期蛋白B结合后，表现出激酶活性。到G<sub>2</sub>晚期阶段，CDK1活性达到最大值并一直维持到M期的中期阶段。</p></li><li><p>CDK1激酶活性受到很多因素的综合调节。周期蛋白与CDK1结合是CDK1激酶活性表现的前提条件。但是，周期蛋白与CDK1结合是CDK1活化的必要不充分条件，还需要weel/mikl激酶和CDK1活化激酶催化CDK1的Thr14、Tyr15 、Thr161 磷酸化，然后，CDK1在磷酸酶Cdc25C的催化下，其Thr14 和Tyr15 去磷酸化，最终表现出激酶活性。</p></li><li><p>CDK1激酶通过使某些蛋白磷酸化，改变其下游的某些蛋白质的构象从而启动其功能，实现其调控细胞周期的目的。比如，组蛋白H1 磷酸化，促进染色体凝集；核纤层蛋白磷酸化，促进核纤层解聚；核仁蛋白磷酸化，促进核仁解体；p60<sup>c-Src</sup>蛋白磷酸化，促进细胞骨架重排；C-ab 1蛋白磷酸化，促进调整细胞形态等。</p></li><li><p>活化的CDK1促使分裂期细胞在分裂前期执行下列生化事件：</p><ul><li>染色质开始浓缩形成有丝分裂染色体；</li><li>细胞骨架解聚，有丝分裂纺锤体开始装配；</li><li>高尔基复合体、内质网等细胞器解体，形成小的膜泡。</li></ul></li><li><p>在有丝分裂的后期，活化的后期促进因子APC主要介导两类蛋白质降解：后期抑制因子和有丝分裂周期蛋白。前者维持姐妹染色单体粘连，抑制后期启动；后者的降解意味着CDK1失去活性，有丝分裂即将结束，即染色体开始去凝集，核膜重建。</p></li></ol></details><details><summary>细胞周期中有哪些检验点？各起何作用？</summary><p>G<sub>1</sub>期检验点：在G<sub>1</sub>期的晚期阶段，分裂的细胞可以通过一个特定时期进入 S 期，开始细胞核 DNA 合成，并继续运行直到完成细胞分裂， 这个特定时期称为检验点。在酵母中称为起始点（start），在哺乳动物中称为限制点（R 点）。G<sub>1</sub>期检验点的主要事件包括：DNA 是否损伤， 细胞外环境是否适宜，细胞体积是否足够大等。防止DNA 损伤或突变的细胞进入S期。</p><p>S期检验点：在S期内发生DNA 损伤如DNA 双链发生断裂时，S期内部检验点被激活，从而抑制复制起始点的启动，使DNA 复制速度减慢，S 期延长，同时激活DNA 修复和复制叉的恢复等机制。S 期检验点的主要事件是DNA 复制是否完成。出现损伤或未完成则使DNA 修复或减缓合成速度。</p><p>G<sub>2</sub>期检验点：细胞能否顺利进入M期要受到G<sub>2</sub>期检验点的控制， G<sub>2</sub>期检验点的主要事件包括：DNA 是否损伤， 细胞是否已生长到合适大小，环境因素是否利于细胞分裂等。阻止带有DNA 损伤的细胞进入M期，使得细胞有充足的时间将损伤的DNA 修复。</p><p>中-后期检验点（纺锤体组装检验点）：可以阻止染色体分离，直到姐妹染色单体正确地连接于有丝分裂纺锤体上。纺锤体组装检验点的主要事件包括：监控纺锤体微管与染色单体动粒的连接，染色体在赤道面的队列和向纺锤体两极的分离等。若这些事件未正确完成， 检验点将阻止细胞从分裂中期进入后期。</p></details><details><summary>什么是细胞分化？细胞分化的本质是什么？举例说明理由。</summary><p>在个体发育中，由一种相同的细胞类型经细胞分裂后逐渐在形态、结构和功能上形成稳定性差异，产生不同的细胞类群的过程称为细胞分化。</p><p>细胞分化的本质是基因组在时间和空间上的选择性表达，通过不同基因表达的开启或关闭，最终产生标志性蛋白质。如鸡的输卵管细胞合成卵清蛋白；胰岛β细胞合成胰岛素。</p></details>]]></content>
      
      
      <categories>
          
          <category> 生物学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 细胞生物学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微生物学复习整理</title>
      <link href="2020/06/24/%E5%BE%AE%E7%94%9F%E7%89%A9%E5%AD%A6/"/>
      <url>2020/06/24/%E5%BE%AE%E7%94%9F%E7%89%A9%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="填空、选择、判断、简答、论述"><a class="header-anchor" href="#填空、选择、判断、简答、论述"></a>填空、选择、判断、简答、论述</h2><h2 id="绪论"><a class="header-anchor" href="#绪论"></a>绪论</h2><h3 id="微生物的五大共性"><a class="header-anchor" href="#微生物的五大共性"></a>微生物的五大共性</h3><ul><li>体积小，面积大：微生物大小以μm计，但比表面积（表面积/体积）大。由于一个小体积大面积系统必然有一个巨大的营养物质吸收面、代谢废物的排泄面和环境信息的交换面，从而产生其余4个共性，因此，这也是微生物最基本的特征</li><li>吸收多，转化快：这一特性为高速生长繁殖和产生大量代谢物提供了充分的物质基础</li><li>生长旺，繁殖快：这一特性可在短时间内把大量基质转化为有用产品，缩短科研周期，但也有不利的一面，如疾病、粮食霉变。</li><li>适应强，易变异：有些极端微生物能生活在高温、高酸、髙碱、髙盐、高毒、髙压或低温等极端环境中；微生物遗传物质易变异。</li><li>分布广，种类多：微生物的种类多构成了微生物多样性，主要表现在：<ul><li>物种的多样性；</li><li>生理代谢类的多样性；</li><li>代谢产物的多样性；</li><li>遗传基因的多样性；</li><li>生态类型的多样性。</li></ul></li></ul><h3 id="思考题"><a class="header-anchor" href="#思考题"></a>思考题</h3><h4 id="什么是微生物？习惯上它包括哪几大类群？"><a class="header-anchor" href="#什么是微生物？习惯上它包括哪几大类群？"></a>什么是微生物？习惯上它包括哪几大类群？</h4><p>微生物是指一切肉眼看不见或看不清的微小生物的总称。它们都是一些个体微小（一般&lt;0.1mm）、构造简单的低等生物。</p><p>习惯上包括三大类群</p><ul><li><p>属于原核类的细菌（真细菌和古生菌）、放线菌、蓝细菌（旧称“蓝绿藻”或“蓝藻”）、枝原体（又称支原体、立克次氏体和衣原体；</p></li><li><p>属于真核类的真菌（酵母菌、霉菌和蕈菌）、原生动物和显微藻类；</p></li><li><p>属于非细胞类的病毒和亚病毒（类病毒、拟病毒和朊病毒）</p></li></ul><h4 id="微生物学发展史如何分期？各期的时间、实质、创始人和特点是什么？我国人民在微生物学发展史上占有什么地位？有什么值得反思？"><a class="header-anchor" href="#微生物学发展史如何分期？各期的时间、实质、创始人和特点是什么？我国人民在微生物学发展史上占有什么地位？有什么值得反思？"></a>微生物学发展史如何分期？各期的时间、实质、创始人和特点是什么？我国人民在微生物学发展史上占有什么地位？有什么值得反思？</h4><p>微生物学发展史的分期以及各时期的时间、实质、创始人和特点如下：</p><h5 id="史前期（约8000年前-1676年）——朦胧阶段"><a class="header-anchor" href="#史前期（约8000年前-1676年）——朦胧阶段"></a>史前期（约8000年前~1676年）——朦胧阶段</h5><p>代表人物：<strong>各国劳动人民</strong>。其中尤以我国的制曲、酿酒技术著称</p><p>特点：</p><ul><li>未见细菌等微生物的个体；</li><li>凭实践经验利用微生物的有益活动（进行酿酒、发面、制酱、娘醋、沤肥、轮作、治病等）</li></ul><h5 id="初创期（1676-1861年）——形态描述阶段"><a class="header-anchor" href="#初创期（1676-1861年）——形态描述阶段"></a>初创期（1676~1861年）——形态描述阶段</h5><p>代表人物：<strong>列文虎克</strong>——微生物学的先驱者</p><p>特点：</p><ul><li>自制单式显微镜，观察到细菌等微生物的个体；</li><li>出于个人爱好对一些微生物进行形态描述。</li></ul><h5 id="奠基期（1861-1897年）——生理水平研究阶段"><a class="header-anchor" href="#奠基期（1861-1897年）——生理水平研究阶段"></a>奠基期（1861~1897年）——生理水平研究阶段</h5><p>代表人物：<strong>巴斯德</strong>——微生物学奠基人和<strong>科赫</strong>——细菌学奠基人。</p><p>特点：</p><ul><li>微生物学开始建立；</li><li>创立了一整套独特的微生物学基本研究方法；</li><li>开始运用“实践—理论—实践”的思想方法开展研究</li><li>建立了许多应用性分支学科</li><li>进入寻找人类和动物病原菌的黄金时期</li></ul><h5 id="发展期（1897-1953年）——生化水平研究阶段"><a class="header-anchor" href="#发展期（1897-1953年）——生化水平研究阶段"></a>发展期（1897~1953年）——生化水平研究阶段</h5><p>代表人物：<strong>E. Buchner</strong>——生物化学的奠基人</p><p>特点：</p><ul><li>对无细胞酵母菌“酒化酶”进行生化研究；</li><li>发现微生物的代谢统一性；</li><li>普通微生物学开始形成；</li><li>开展广泛寻找微生物的有益代谢产物；</li><li>青霉素的发现推动了微生物工业化培养技术的猛进。</li></ul><h5 id="成熟期（1953年-至今）——分子生物学水平研究阶段"><a class="header-anchor" href="#成熟期（1953年-至今）——分子生物学水平研究阶段"></a>成熟期（1953年~至今）——分子生物学水平研究阶段</h5><p>代表人物：<strong>J. Watson</strong>和 <strong>F. Crick</strong>——分子生物学奠基人</p><p>特点：</p><ul><li>广泛运用分子生物学理论和现代研究方法，深刻揭示微生物的各种生命活动规律；</li><li>以基因工程为主导，把传统的工业发酵提高到发酵工程新水平；</li><li>大量理论性、交叉性、应用性和实验性分支学科飞速发展；</li><li>微生物学的基础理论和独特实验技术推动了生命科学各领域飞速发展；</li><li>微生物基因组的研究促进了生物信息学时代的到来。</li></ul><h5 id="我国人民在微生物学发展史上的地位和反思："><a class="header-anchor" href="#我国人民在微生物学发展史上的地位和反思："></a>我国人民在微生物学发展史上的地位和反思：</h5><p><strong>地位</strong>：我国人民主要在微生物学的史前期有着非常卓越的贡献，凭借经验主观利用微生物为人类生产，并且一些技术改进后至今仍在使用。</p><p><strong>反思</strong>：此前，我国在微生物研究上没有深入，停留在现象应用层，但西方后来从微观角度研究，一步步发现微生物的本质。故对事物的认知不能仅停留在表面，要通过现象看本质。</p><h4 id="简述微生物在现代农业发展中的作用。"><a class="header-anchor" href="#简述微生物在现代农业发展中的作用。"></a>简述微生物在现代农业发展中的作用。</h4><p>微生物在现代农业特别在生态农业中有着十分重要的作用。</p><p>例如：</p><ul><li>以菌（含病毒）治害虫和以菌治植病的生物防治技术，</li><li>以菌增肥效（如根瘤菌接种剂）和以菌促生长（如赤霉素）的微生物增产技术，以菌作饲料（饵料）</li><li>以菌作蔬菜（各种食用菌）的单细胞蛋白和食用菌生产技术，</li><li>以菌产能源的沼气发酵技术等</li></ul><h4 id="简述微生物在当代环境保护中的作用。"><a class="header-anchor" href="#简述微生物在当代环境保护中的作用。"></a>简述微生物在当代环境保护中的作用。</h4><p>微生物在当代环境保护中的作用如下：</p><ul><li>微生物是地球上重要元素循环中的主要推动者；</li><li>微生物是占地球面积70%以上的海洋和其他水体中光合生产力的基础</li><li>微生物是一切食物链的重要环节，是污水和有机废物处理中的关键角色</li><li>微生物是生态农业中既重要却处于隐形态的环节，是环境污染和监测的重要指示生物等</li></ul><h4 id="为什么说微生物的“体积小、面积大”是决定其他4个共性的关键？"><a class="header-anchor" href="#为什么说微生物的“体积小、面积大”是决定其他4个共性的关键？"></a>为什么说微生物的“体积小、面积大”是决定其他4个共性的关键？</h4><p>微生物“体积小、面积大”是决定其他4个共性的关键的原因如下：</p><p>微生物体积小，但比表面积（表面积体积）大。由于微生物是一个如此突出的小体积大面积系统，从而赋予它们具有不同于一切大生物的五大共性，因为一个小体积大面积系统，必然有一个巨大的营养物质吸收面、代谢废物的排泄面和环境信息的交换面，并由此而产生其余4个共性。故“体积小，面积大”是决定其他4个共性的关键。</p><h4 id="试讨论微生物的多样性。"><a class="header-anchor" href="#试讨论微生物的多样性。"></a>试讨论微生物的多样性。</h4><p>微生物的多样性包括以下5个方面：</p><h5 id="物种的多样性"><a class="header-anchor" href="#物种的多样性"></a>物种的多样性</h5><p>迄今为止，人类已描述过的生物总数约200万种。据估计，微生物的总数约在50万至600万之间，且发现数还在急剧增长。</p><h5 id="生理代谢类型的多样性"><a class="header-anchor" href="#生理代谢类型的多样性"></a>生理代谢类型的多样性</h5><p>微生物的生理代谢类型之多，是动、植物所远远不及的。</p><ul><li>分解地球上储量最丰富的初级有机物一天然气、石油、纤维素、木质素的能力为微生物所垄断；</li><li>微生物有着最多样的产能方式，诸如细菌的光合作用，嗜盐菌的紫膜光合作用，自养细菌的化能合成作用，以及各种厌氧产能途径等；</li><li>生物固氮作用；</li><li>合成次生代谢产物等各种复杂有机物的能力；</li><li>对复杂有机分子基团的生物转化能力；</li><li>分解氰、酚、多氯联苯等有毒和剧毒物质的能力；</li><li>抵抗极端环境（热、冷、酸、碱、渗、压和辐射等）的能力；等等。</li></ul><h5 id="代谢产物的多样性"><a class="header-anchor" href="#代谢产物的多样性"></a>代谢产物的多样性</h5><p>微生物产生的代谢产物种类多，所产酶的种类也是及其丰富的。</p><h5 id="遗传基因的多样性"><a class="header-anchor" href="#遗传基因的多样性"></a>遗传基因的多样性</h5><p>从基因水平看微生物的多样性，内容更为丰富，这是近年来分子微生物学家正在积极探索的热点领域。在全球性的“人类基因组计划”(HGP) 的有力推动下，微生物基因组测序工作正在迅速开展，并取得了巨大的成就。</p><h5 id="生态类型的多样性"><a class="header-anchor" href="#生态类型的多样性"></a>生态类型的多样性</h5><p>微生物广泛分布于地球表层的生物圈（包括土壤圈、水圈、大气圈、岩石圈和冰雪圈）；</p><p>对于那些极端微生物即嗜极菌而言，则更易生活在极热、极冷、极酸、极碱、极盐、极压和极早等的极端环境中；</p><p>此外，微生物与微生物或与其他生物间还存在着众多的相互依存关系，如互生、共生、寄生、抗生和猎食等，如此众多的生态系统类型就会产生出各种相应生态型的微生物。</p><h2 id="原核生物的形态、构造和功能"><a class="header-anchor" href="#原核生物的形态、构造和功能"></a>原核生物的形态、构造和功能</h2><h3 id="填空题"><a class="header-anchor" href="#填空题"></a>填空题</h3><ol><li>微生物学的先驱者是 <strong><u>列文虎克</u></strong> ，微生物学的奠基人是 <strong><u>巴斯德</u></strong> ，细菌学的奠基人是 <strong><u>科赫</u></strong>，第一个看见并描述微生物的人是 <strong><u>列文虎克</u></strong></li><li>微生物学发展史可分为5期，其分别为 <strong><u>史前期</u></strong>、<strong><u>初创期</u></strong>、<strong><u>奠基期</u></strong>、<strong><u>发展期</u><strong>和</strong><u>成熟期</u></strong>。</li><li>革兰氏阳性细菌细胞壁的主要成分为 <strong><u>肽聚糖</u><strong>和</strong><u>磷壁酸</u></strong>，而革兰氏阴性细菌细胞壁的主要成分则是**<u>脂多糖</u><strong>、</strong><u>磷脂</u><strong>、</strong><u>脂蛋白</u><strong>和</strong><u>肽聚糖</u>**。</li><li>肽聚糖单体是由**<u>N-乙酰葡糖胺</u><strong>和</strong><u>N-乙酰胞壁酸</u><strong>以</strong><u>β-1,4糖苷键</u><strong>结合的</strong><u>双糖单位</u><strong>，以及</strong><u>四肽尾</u><strong>和</strong><u>肽桥</u><strong>3种成分组成的，其中的糖苷键可被</strong><u>溶菌酶</u>**水解。</li><li>革兰氏阳性细菌与革兰氏阴性细菌两者细胞壁在组成成分上主要差异为前者 **<u>肽聚糖</u><strong>含量高，后者</strong><u>脂类</u>**含量高。</li><li>球菌的大小以**<u>直径</u><strong>表示，杆菌的大小以</strong><u>宽×长</u>**表示。</li><li>脂多糖(LPS)是革兰氏**<u>阴性</u><strong>菌细胞壁</strong><u>外壁</u><strong>层的主要成分，它由</strong><u>O-侧链（O-多糖、O-抗原）</u><strong>、</strong><u>核心多糖</u><strong>、</strong><u>类脂A</u>**三部分构成。</li><li>测定细菌、放线菌的大小，一般以**<u>微米</u><strong>单位，而测定病毒的大小则以</strong><u>纳米</u>**为单位。</li><li>用人为方法除尽细胞壁的细菌称为**<u>原生质体</u><strong>，未除尽细胞壁的细菌称为</strong><u>球状体</u><strong>，因在实验室中发生缺壁突变的细菌称为<u><strong>L型细菌</strong></u>，而在自然界长期进化中形成的稳定性缺壁细菌则称为</strong><u>支原体</u>**。</li><li>在芽孢核心的外面有3层结构紧紧包裹着，它们是**<u>孢外壁</u><strong>、</strong><u>芽孢衣</u><strong>、</strong><u>皮层</u>**。</li><li>在芽孢皮层中，存在着**<u>芽孢肽聚糖</u><strong>和</strong><u>DPA-Ca</u>**两种特有的与芽孢耐热性有关的物质。</li><li>蓝细菌是光合微生物，进行**<u>光能无机</u><strong>营养，单细胞蓝细菌以</strong><u>细胞分裂</u><strong>繁殖为主，丝状体种类则以</strong><u>藻殖段</u><strong>繁殖。蓝细菌没有鞭毛，但能进行</strong><u>滑行</u>**运动。</li><li>磷壁酸是<u><strong>G<sup>+</sup></strong></u>菌细胞壁的特有成分，几丁质是**<u>霉菌</u><strong>细胞壁的主要成分，吡啶二羧酸钙（DPA-Ca）主要存在于细菌</strong><u>芽胞</u><strong>结构中，二氨基庚二酸（m-DAP）主要存在于</strong><u>G<sup>-</sup></u><strong>菌的壁中，藻胆素主要存在于</strong><u>蓝细菌</u>**中。</li><li>放线菌个体为**<u>分枝丝状</u><strong>体，根据菌丝在固体培养基上生长的情况，可以分为</strong><u>基内菌丝</u><strong>、</strong><u>气生菌丝</u><strong>、</strong><u>孢子丝</u>**。</li><li>放线菌既可以以**<u>菌丝</u><strong>繁殖，也可以以</strong><u>孢子</u><strong>繁殖，</strong><u>孢子</u>**繁殖是放线菌的主要繁殖方式。</li><li>细菌细胞有一个**<u>连续</u><strong>的细胞膜，它以大量的折皱陷入到细胞内部，陷入细胞内部的质膜物质称为</strong><u>中间体</u>**</li><li>支原体的菌落形态为**<u>典型的“煎鸡蛋”状</u>**。</li><li>在细菌中，存在着4种不同的糖被形式，即**<u>荚膜</u><strong>、</strong><u>微荚膜</u><strong>、</strong><u>黏液层</u><strong>和</strong><u>菌胶团</u>**。</li><li>鞭毛是细菌的运动器官，观察细菌是否着生鞭毛可通过**<u>鞭毛染色</u><strong>或</strong><u>悬滴法</u>**在光学显微镜下观察。</li><li>G<sup>-</sup>细菌的鞭毛是由**<u>基体</u><strong>以及</strong><u>钩形鞘</u><strong>和</strong><u>鞭毛丝</u><strong>3部分构成，在基体上着生</strong><u>L</u><strong>、</strong><u>P</u><strong>、</strong><u>S-M</u><strong>和</strong><u>C</u>**四个与鞭毛旋转有关的环。</li></ol><p><img src="http://img.whl123456.top/image/G+%E5%92%8CG-%E7%BB%86%E8%8F%8C%E7%BB%86%E8%83%9E%E5%A3%81%E6%9E%84%E9%80%A0%E7%9A%84%E6%AF%94%E8%BE%83.png" alt="G+和G-细菌细胞壁构造的比较"></p><h3 id="选择题"><a class="header-anchor" href="#选择题"></a>选择题</h3><ol><li>G<sup>-</sup>细菌细胞壁的最内层成分是（<strong>肽聚糖</strong>）</li><li>磷壁酸是( <strong>G<sup>+</sup></strong>)细菌细胞壁上的主要成分。</li><li>异染粒是属于细菌的(<strong>磷源类</strong>)类贮藏物。</li><li>下列（ ）物质决定了革兰氏阴性细菌细胞表面抗原的多样性。（<strong>脂多糖的O-多糖</strong>）</li><li>肽聚糖种类的多样性主要反映在( <strong>肽桥</strong> )结构的多样性上</li><li>不是脂多糖的功能的是（ ）<ul><li>G<sup>-</sup>细菌细胞壁成分</li><li><strong>允许物质通过外膜</strong></li><li>抗原功能</li><li>内毒素</li></ul></li><li>在G<sup>-</sup>细菌肽聚糖的四肽尾上，有一个与G<sup>+</sup>细菌不同的 (<strong>二氨基庚二酸</strong> )的氨基酸</li><li>脂多糖(LPS)是G<sup>-</sup>细菌的内毒素，其毒性来自分子中的(<strong>类脂A</strong>)</li><li>球状细菌分裂后排列成链状称为(<strong>链球菌</strong>)</li><li>在芽孢的各层结构中，含DPA-Ca量最高的层次是(<strong>皮层</strong>)</li><li>下列不是原核细胞结构的是(<strong>叶绿体</strong>)</li><li>按鞭毛的着生方式，大肠杆菌属于(<strong>周生鞭毛菌</strong>)</li><li>固氮菌所特有的休眠体构造称为(<strong>孢囊</strong>)</li><li>下列对放线菌的描述中（ ）是错误的<ul><li>放线菌孢子丝形状和孢子表面形状是分类依据。</li><li><strong>大部分放线菌具有生长发育良好的菌丝体，菌丝直径与霉菌类似；</strong></li><li>大部分放线菌是以孢子进行繁殖，菌落特征类似于霉菌；</li><li>所有放线菌细胞的结构与细菌基本相同，不同于霉菌；</li></ul></li><li>在下列微生物中( <strong>蓝细菌</strong> )能进行产氧的光合作用</li><li>下面关于芽孢的叙述，正确的是(<strong>所有芽孢细菌在其生长的一定阶段，均可形成芽孢</strong>)</li><li>细胞内含物中，（<strong>聚-β-羟基丁酸（PHB)</strong>）可以作为生物可降解塑料的良好原料。</li><li>溶菌酶溶解细菌细胞壁的主要原理是(<strong>降解双糖单位中的β-1,4-糖苷键</strong>)</li><li>原核微生物能量代谢及很多合成代谢的部位是（<strong>质膜</strong>）</li><li>（<strong>脂多糖的O-多糖</strong>）物质决定了革兰氏阴性细菌细胞表面抗原的多样性</li><li>细菌芽胞抗热性强是因为含有（<strong>2,6-吡啶二羧酸</strong>）</li><li><em>Bacillusthuringiensis</em>在形成芽胞同时,还能形成一种菱形或正方形的物质，称之为（<strong>伴胞晶体</strong>）</li><li>细菌的鞭毛是（<strong>细菌的一种运动器官</strong>）</li><li>细菌的芽胞是（<strong>细菌生长发育的一个阶段</strong>）</li><li>在下列原核生物分类中,属古细菌类的细菌是（<strong>产甲烷细菌</strong>）</li><li>下列对蓝细菌的描述中（）是错误的<ul><li>又称蓝藻或蓝绿藻</li><li><strong>某些蓝细菌有叶绿体</strong></li><li><strong>通过产氧型或非产氧型光合作用将光能转变成化学能</strong></li><li>某些蓝细菌形成异形胞、静息孢子和链丝段</li><li><strong>某些蓝细菌无鞭毛，但能在固体表面滑行；某些蓝细菌有鞭毛运动</strong></li></ul></li><li>(<strong>立克次氏体</strong>,<strong>衣原体</strong>)是专性活细胞内寄生的原核微生物</li></ol><h3 id="问答题"><a class="header-anchor" href="#问答题"></a>问答题</h3><h4 id="试用简图表示G-sup-sup-和G-sup-sup-细菌肽聚糖单体构造的差别，并作简要说明"><a class="header-anchor" href="#试用简图表示G-sup-sup-和G-sup-sup-细菌肽聚糖单体构造的差别，并作简要说明"></a>试用简图表示G<sup>+</sup>和G<sup>-</sup>细菌肽聚糖单体构造的差别，并作简要说明</h4><ul><li>G<sup>+</sup>菌四肽尾分子上的第3个氨基酸是L-Lys，而G<sup>-</sup>菌则是m-DAP</li><li>G<sup>+</sup>菌四肽尾的第4氨基酸上有一肽桥(常为甘氨酸五肽)，而G<sup>-</sup>菌则无</li></ul><p><img src="http://img.whl123456.top/image/image-20200624215428756.png" alt=""></p><p>M：N-乙酰胞壁酸</p><p>G：N-乙酰葡糖胺</p><h4 id="试述细菌革兰氏染色的机制。"><a class="header-anchor" href="#试述细菌革兰氏染色的机制。"></a>试述细菌革兰氏染色的机制。</h4><p>革兰氏染色的机制是由于不同细菌细胞壁化学成分的不同而引起的物理性状的差别是导致革兰氏染色反应不同的原因。</p><p>通过结晶紫初染和碘液媒染，在任何细菌的细胞膜内都可形成不溶于水的结晶紫—碘复合物。</p><p>G<sup>+</sup>细菌因壁厚，肽聚糖网的层次多和结构致密，以及不含类脂等原因，故用脱色剂(乙醇)处理后，可把结晶紫—碘复合物仍阻拦在细胞内，故呈现紫色；</p><p>反之，G<sup>-</sup>细菌因细胞壁薄，外膜层类脂含量高(脂多糖、脂蛋白)，以及肽聚糖层薄且交联松散，故用脱色剂乙醇处理后，就可把类脂和结晶紫—碘复合物溶出细胞，这种无色的细胞再经沙黄(番红)复染，就呈现红色。</p><h4 id="试用表解法对细菌的一般构造和特殊构造作一介绍"><a class="header-anchor" href="#试用表解法对细菌的一般构造和特殊构造作一介绍"></a>试用表解法对细菌的一般构造和特殊构造作一介绍</h4><p>一般构造：细胞壁；细胞膜；间体；细胞质；内含物；核区</p><p>特殊构造：糖被（荚膜、微荚膜、黏液层、菌胶团）、鞭毛、菌毛、性毛、芽孢</p><h4 id="请列表比较细菌的鞭毛、菌毛和性毛间的异同。"><a class="header-anchor" href="#请列表比较细菌的鞭毛、菌毛和性毛间的异同。"></a>请列表比较细菌的鞭毛、菌毛和性毛间的异同。</h4><table><thead><tr><th>项目</th><th>鞭毛</th><th>菌毛</th><th>性毛</th></tr></thead><tbody><tr><td>形态</td><td>长，波曲，中空；分鞭毛丝、钩形鞘和基体3部分</td><td>短，直，细，中空；构造简单</td><td>较长，较直，中空；构造简单</td></tr><tr><td>数目</td><td>一至数十条</td><td>一般有250-300 条</td><td>一至少数几条</td></tr><tr><td>着生部位</td><td>端生，周生，侧生</td><td>周生</td><td>不定</td></tr><tr><td>成分</td><td>鞭毛蛋白</td><td>菌毛蛋白</td><td>性毛蛋白</td></tr><tr><td>功能</td><td>运动</td><td>黏附</td><td>传递遗传物质</td></tr><tr><td>代表菌</td><td>大肠杆菌，芽孢杆菌，梭菌，弧菌，假单胞菌等</td><td>G<sup>-</sup>致病菌等</td><td>G<sup>-</sup>细菌的雄性菌株</td></tr></tbody></table><h4 id="渗透调节皮层膨胀学说是如何解释芽孢耐热机制的？"><a class="header-anchor" href="#渗透调节皮层膨胀学说是如何解释芽孢耐热机制的？"></a>渗透调节皮层膨胀学说是如何解释芽孢耐热机制的？</h4><p>芽孢的耐热性在于芽孢衣对多价阳离子和水分的透性很差，以及皮层的离子强度很高，从而使皮层产生极高的渗透压去夺取芽孢核心中的水分，其结果导致皮层的充分膨胀，而作为芽孢的生命部分—芽孢核心的细胞质却发生高度失水，并由此变得高度耐热了</p><h4 id="试列表比较G-sup-sup-与G-sup-sup-细菌间的10种主要差别"><a class="header-anchor" href="#试列表比较G-sup-sup-与G-sup-sup-细菌间的10种主要差别"></a>试列表比较G<sup>+</sup>与G<sup>-</sup>细菌间的10种主要差别</h4><table><thead><tr><th>项目</th><th>G<sup>+</sup>细菌</th><th>G<sup>-</sup>细菌</th></tr></thead><tbody><tr><td>革兰氏染色</td><td>紫色</td><td>红色</td></tr><tr><td>细胞壁肽聚糖层</td><td>厚</td><td>薄</td></tr><tr><td>磷壁酸含量</td><td>高</td><td>无</td></tr><tr><td>细胞壁外膜</td><td>无</td><td>有</td></tr><tr><td>脂多糖层</td><td>无</td><td>有</td></tr><tr><td>鞭毛结构</td><td>基体上只有2环</td><td>基体上有4环</td></tr><tr><td>产毒素</td><td>外毒素为主</td><td>内毒素为主</td></tr><tr><td>细胞抗机械强度</td><td>强</td><td>弱</td></tr><tr><td>细胞壁抗溶菌酶</td><td>弱</td><td>强</td></tr><tr><td>抗青霉索、磺胺</td><td>弱</td><td>强</td></tr><tr><td>抗链霉素、氯霉素、四环素</td><td>强</td><td>弱</td></tr><tr><td>抗碱性染料</td><td>弱</td><td>强</td></tr><tr><td>抗阴离子去污剂</td><td>弱</td><td>强</td></tr><tr><td>抗叠氮化钠</td><td>弱</td><td>强</td></tr><tr><td>抗干旱</td><td>强</td><td>弱</td></tr><tr><td>产芽孢</td><td>有的种产</td><td>不产</td></tr><tr><td>去除细胞壁</td><td>较易(可制成厚生质体)</td><td>较难(制成球状体)</td></tr></tbody></table><h4 id="以链霉菌为例，描述这类典型放线菌的菌丝、孢子和菌落的一般特征"><a class="header-anchor" href="#以链霉菌为例，描述这类典型放线菌的菌丝、孢子和菌落的一般特征"></a>以链霉菌为例，描述这类典型放线菌的菌丝、孢子和菌落的一般特征</h4><h5 id="菌丝"><a class="header-anchor" href="#菌丝"></a>菌丝</h5><p>当其孢子落在固体基质表面并发芽后，就不断伸长、分枝并以放射状向基质表面和内层扩展，形成大量色浅、较细的具有吸收营养和排泄代谢废物功能的基内菌丝体，同时在其又不断向上空间方向分化出颜色较深、直径较粗的分枝菌丝，这就是气生菌丝体。不久，大部分气生菌丝体成熟，分化成孢子丝，并通过横割分裂方式，产生成串的分生孢子。</p><h5 id="孢子"><a class="header-anchor" href="#孢子"></a>孢子</h5><p>链霉菌孢子丝的形态多样，有直、波曲、钩状、螺旋状和轮生(一级轮生或二级轮生)等多种， 其颜色十分丰富，且与其表面纹饰相关。</p><p>孢子表面纹饰在电镜下清晰可见，表面有光滑、褶皱、疣、刺、发或鳞片状，刺又有粗细、大小、长短和疏密之分。一般凡属直或波曲的孢子丝， 其孢子表面均呈光滑状， 若为螺旋状的孢子丝， 则孢子表面会因种而异， 有光滑、刺状或毛发状的。</p><h5 id="菌落"><a class="header-anchor" href="#菌落"></a>菌落</h5><ul><li><p>在固体培养基上</p><ul><li>小型、干燥、不透明、表面呈致密的丝绒状，上有一薄层彩色的＂干粉＂；</li><li>菌落和培养基的连接紧密，难以挑取；</li><li>菌落的正反面颜色常不一致，以及在菌落边缘的琼脂平面有变形的现象；等等。</li></ul></li><li><p>在液体培养基上（内）</p><p>常可见到在液面与瓶壁交界处粘贴着一圈菌苔，培养液清而不混，其中悬浮着许多珠状菌丝团，一些大型菌丝团则沉在瓶底等现象。</p></li></ul><h2 id="真核微生物的形态、构造和功能"><a class="header-anchor" href="#真核微生物的形态、构造和功能"></a>真核微生物的形态、构造和功能</h2><h3 id="填空题-v2"><a class="header-anchor" href="#填空题-v2"></a>填空题</h3><ol><li>一些酵母菌芽殖后，子细胞不马上脱离母细胞，而是中间以狭小面积相连、形成状如藕节的**<u>假菌丝</u>**</li><li>真菌是不含有**<u>叶绿素</u><strong>，</strong><u>异养吸收型</u><strong>营养，以</strong><u>无性或有性孢子</u>**进行繁殖的真核微生物</li><li>酵母菌的无性繁殖方式主要有**<u>芽殖</u><strong>、</strong><u>裂殖</u>**</li><li>丝状真菌的无隔菌丝是由**<u>单个</u><strong>细胞组成,有隔菌丝是由</strong><u>多个</u>**细胞组成</li><li>酵母菌细胞壁呈**<u>三明治</u><strong>结构，外层为</strong><u>甘露聚糖</u><strong>，内层为</strong><u>葡聚糖</u><strong>，中间夹有</strong><u>蛋白质</u>**</li><li>以下各类真核微生物的细胞壁主要成分分别是：酵母菌为**<u>葡聚糖</u><strong>，低等真菌为</strong><u>纤维素</u><strong>，高等真菌为</strong><u>几丁质</u>**</li><li>真菌子囊果的种类有 <strong><u>闭囊壳</u></strong>、<strong><u>子囊壳</u></strong>、**<u>子囊盘</u>**三种</li><li>真核生物鞭毛杆的横切面为<u><strong>9+2</strong></u>型，其基体横切面则为<u><strong>9+0</strong></u>型</li><li>真菌卵孢子是由两个大小不同的配子囊经结合后形成的，其中小型配子囊叫 <strong><u>雄器</u></strong>，大型配子囊叫 <strong><u>藏卵器</u></strong>。</li><li>真菌生长在基质内的菌丝叫 <u><strong>基内（营养或一级）菌丝</strong></u>，其功能主要是 <strong><u>吸收营养物质</u></strong> ，伸出基质外的菌丝叫 <strong><u>气生菌丝</u></strong> ，其功能主要是 <strong><u>分化成繁殖器官产生孢子</u></strong></li><li>构成丝状真菌营养体的基本单位是 <strong><u>菌丝</u></strong></li><li>担子菌的双核菌丝是靠一种叫 <strong><u>锁状联合</u></strong> 的特殊结构进行细胞分裂,以保证每一个子代细胞都含有来自父母亲本的两个子核。</li><li>霉菌无性繁殖孢子的种类主要有 <strong><u>游动孢子</u></strong>，<strong><u>孢囊孢子</u></strong>，<strong><u>分生孢子</u></strong>，<strong><u>节孢子</u></strong>，**<u>厚垣孢子</u>**五种。</li><li>真菌的有性孢子种类有 <strong><u>卵孢子</u></strong>，<strong><u>接合孢子</u></strong>，<strong><u>子囊孢子</u></strong>，<strong><u>担孢子</u></strong></li></ol><h3 id="选择题-v2"><a class="header-anchor" href="#选择题-v2"></a>选择题</h3><ol><li><p>下列哪一项不是真菌的共同特征</p><ul><li>具有核膜</li><li>能进行有丝分裂</li><li>细胞质中存在细胞器</li><li><strong>能进行减数分裂</strong></li></ul></li><li><p>下面的选项中（<strong>子囊孢子</strong>）是酵母菌可能采取的有性繁殖类型。</p></li><li><p>根霉的无性孢子为（<strong>内生的孢囊孢子</strong> ），曲霉和青霉的无性孢子为（ <strong>外生的分生孢子</strong>  ）</p></li><li><p><strong>肽聚糖</strong>不出现在真核生物的细胞壁中</p></li><li><p>下列（<strong>孢囊孢子</strong>）不是真菌的有性孢子</p></li><li><p>具有假根结构的霉菌是 <strong>根霉属</strong></p></li><li><p>寄生真菌靠吸器吸收养料，吸器存在于 <strong>寄主细胞里面</strong></p></li><li><p>根霉菌的假根是长在 <strong>匍匐菌丝上</strong></p></li><li><p>啤酒酵母菌的生活史属 <strong>单双倍体型</strong></p></li><li><p>木耳（<em>Auricularia</em>）的有性孢子是 <strong>担孢子</strong></p></li><li><p>在真核微生物的“9+2”型鞭毛中，具有ATP酶功能的构造是 <strong>动力蛋白臂</strong></p></li><li><p>酵母菌的菌落特征是 （<strong>较细菌菌落大、厚、较稠、较不透明、有酒香味</strong>）</p></li><li><p>霉菌的菌落特征是（<strong>形态大、蛛网状、绒毛状、干燥、不透明、不易挑起</strong>）</p></li><li><p>锁状联合是担子菌（<strong>双核的次生菌丝</strong> ）的生长方式</p></li><li><p>出芽繁殖的酵母菌细胞，当子细胞离开母细胞时，在母细胞上留下一个（<strong>芽痕</strong>）</p></li><li><p>路德类酵母的生活史属（<strong>双倍体型</strong>）</p></li><li><p>真酵母是指（<strong>具有有性繁殖的酵母菌</strong>）</p></li><li><p>八孢裂殖酵母菌的生活史属（<strong>单倍体型</strong>）</p></li><li><p>霉菌菌丝直径一般为3~10μm，比较放线菌菌丝约粗（<strong>10倍</strong>）</p></li></ol><h3 id="问答题-v2"><a class="header-anchor" href="#问答题-v2"></a>问答题</h3><h4 id="真菌的营养菌丝体可以分化成哪些特殊的形态结构？它们的功能是什么？"><a class="header-anchor" href="#真菌的营养菌丝体可以分化成哪些特殊的形态结构？它们的功能是什么？"></a>真菌的营养菌丝体可以分化成哪些特殊的形态结构？它们的功能是什么？</h4><ol><li><p>匍匐枝和假根：匍匐菌丝是使菌丝向四周蔓延，并在其上可产生孢囊梗，假根能使菌丝固着在基物上，并能吸收营养</p></li><li><p>吸器：寄生真菌侵入寄主细胞内吸收营养；</p></li><li><p>菌环和菌网：某些捕虫类真菌用来捕捉线虫、轮虫等，以获养料；</p></li><li><p>附着枝和附着胞：一些真菌用来将菌丝附着在寄主体表上；</p></li><li><p>菌核和菌索：抗逆不良环境条件</p></li></ol><h4 id="真菌的有性生殖过程可分为哪几个阶段？请说明每个阶段的内容"><a class="header-anchor" href="#真菌的有性生殖过程可分为哪几个阶段？请说明每个阶段的内容"></a>真菌的有性生殖过程可分为哪几个阶段？请说明每个阶段的内容</h4><p>质配：两个单倍体性细胞相接触，细胞质及内含物融合在一起，但染色体数目仍为单倍体。</p><p>核配：质配后双核细胞中的两个核融合，产生出二倍体的接合子核，染色数目是双倍的。</p><p>减数分裂：双倍体核进行两次连续的核分裂，核的染色体数目减半，形成单倍体的有性孢子。</p><h4 id="图示酿酒酵母的生活史，并说明其生活史特点"><a class="header-anchor" href="#图示酿酒酵母的生活史，并说明其生活史特点"></a>图示酿酒酵母的生活史，并说明其生活史特点</h4><p><img src="http://img.whl123456.top/image/image-20200625003944058.png" alt=""></p><p>生活史特点：</p><ul><li>一般情况下都以营养体状态进行出芽繁殖；</li><li>营养体既能以单倍体（n）形式存在，也能以二倍体（2n）形式存在；</li><li>在特定的条件下才进行有性繁殖</li></ul><h4 id="列表比较真菌孢子的类型和主要特点"><a class="header-anchor" href="#列表比较真菌孢子的类型和主要特点"></a>列表比较真菌孢子的类型和主要特点</h4><p><img src="http://img.whl123456.top/image/image-20200625004023324.png" alt=""></p><h2 id="病毒和亚病毒因子"><a class="header-anchor" href="#病毒和亚病毒因子"></a>病毒和亚病毒因子</h2><h3 id="填空题-v3"><a class="header-anchor" href="#填空题-v3"></a>填空题</h3><ol><li>病毒分为**<u>真病毒</u><strong>和</strong><u>亚病毒因子</u>**</li><li>病毒直径很小，通常用**<u>nm</u>**作为度量单位，病毒、细菌和真菌个体直径比约 <strong><u>1:10:100</u></strong></li><li>病毒粒的基本成分是**<u>核酸</u><strong>、</strong><u>蛋白质</u>**</li><li>病毒的核酸位于病毒颗粒的中心，称为 <strong><u>核心或基因组</u></strong>，蛋白质包围后形成 <strong><u>衣壳</u></strong></li><li>病毒粒的对称体制有 <strong><u>螺旋对称</u></strong>、<strong><u>二十面体对称</u></strong>、<strong><u>复合对称</u></strong></li><li>病毒粒大量聚集后可以形成具有一定形态和构造的特殊“群体”，植病毒在细胞内形成 <strong><u>包含体</u></strong>，在植物叶片上形成 <strong><u>枯斑</u></strong>；噬菌体在细菌菌苔上形成 <strong><u>噬菌斑</u></strong>；动物病毒在宿主单层细胞培养物上形成 <strong><u>空斑</u></strong></li><li>T4噬菌体由**<u>头部</u><strong>、</strong><u>颈部</u><strong>、</strong><u>尾部</u>**三部分组成</li><li>噬菌体的繁殖一般分为5个阶段，即 <strong><u>吸附</u></strong>、<strong><u>侵入</u></strong>、<strong><u>增殖（复制与生物合成）</u></strong>、<strong><u>成熟（装配）</u></strong>、 **<u>裂解（释放）</u>**凡是在短时间内连续完成5个阶段的噬菌体称为 **<u>烈性噬菌体</u>**其经历的繁殖过程称为 <strong><u>裂解性周期或增殖性周期</u></strong>，在短时间内不能连续完成5个阶段的噬菌体称为 <strong><u>温和噬菌体</u></strong></li><li>定量描绘烈性噬菌体生长规律的曲线称为 <strong><u>一步生长曲线</u><strong>烈性噬菌体从生长曲线上可以分为 <strong><u>潜伏期</u></strong>、</strong><u>裂解期</u></strong>、**<u>平稳期</u>**三个阶段。</li><li>温和性噬菌体侵入寄主细胞并不立即引起宿主细胞裂解的现象称为 <strong><u>溶源性</u></strong>，带有温和性噬菌体基因组的细菌称为 <strong><u>溶源菌</u></strong>，整合在细菌基因组上的噬菌体基因组称为 <strong><u>前噬菌体</u></strong></li><li>温和性噬菌体侵入宿主细胞后，即可以进行 <strong><u>裂解性</u><strong>循环繁殖，又可以进行</strong><u>溶源性</u><strong>循环繁殖，所以其在宿主细胞内存在的形式有 <strong><u>游离态</u></strong>、</strong><u>整合态</u></strong>、**<u>营养态</u>**三种状态</li><li>人和动物病毒的形态一般为 <strong><u>球状</u></strong>，植物和昆虫的病毒形态一般为 <strong><u>杆状</u></strong>，而原核生物的病毒形态一般为 <strong><u>复合型</u></strong></li><li>TMV病毒粒子的形状为 <strong><u>杆状</u></strong>，所含核酸为 <strong><u>ssRNA</u></strong></li><li>T4噬菌体感染寄主细胞依靠 **<u>尾鞘收缩</u>**将 **<u>头部核酸（DNA）</u>**注入寄主细胞</li><li>病毒是一种无**<u>细胞</u><strong>结构，能通过 <strong><u>细菌过滤器</u></strong>，严格寄生于</strong><u>活细胞</u>**超显微生物</li><li>卫星病毒（拟病毒）是依赖 **<u>辅助病毒</u><strong>进行复制的一种小的</strong><u>RNA</u>**病毒</li></ol><h3 id="选择题-v3"><a class="header-anchor" href="#选择题-v3"></a>选择题</h3><ol><li>没有蛋白质外壳，只有RNA，可以在宿主细胞中自我复制的亚病毒因子是 <strong>类病毒</strong></li><li>下面的叙述中，哪一项不是病毒的特征<ul><li>不具有细胞结构，具有一般化学大分子的特征；</li><li>个体微小，在电子显微镜下才能看见；</li><li>严格的活细胞内寄生；</li><li><strong>对大多数抗生素敏感</strong></li></ul></li><li>溶源菌中的温和噬菌体基因组通常不影响宿主细胞的 <strong>繁殖功能</strong></li><li>病毒的核酸称为基因组，（<strong>蛋白质外壳</strong>）称为衣壳</li><li>CPV是 <strong>质多角体病毒</strong>，NPV是 <strong>核多角体病毒</strong></li><li>与病毒复制过程无关的过程（<strong>减数分裂</strong>）</li><li>噬菌体是侵蚀（<strong>细菌</strong>）的病毒</li><li>类病毒是一类仅含有侵染性（ <strong>RNA</strong> ）的病毒</li><li>病毒显著区别于其他生物的特征是（ <strong>独特的繁殖方式</strong> ）</li><li>病毒物理颗粒计数方法测定的是（<strong>有活力的病毒与无活力病毒数量的总和</strong>）</li><li>描述螺旋对称壳体特征的参数有（<strong>螺旋长度与直径</strong>）</li><li>温和性噬菌体基因组在溶源性细菌内可以下列状态存在（<strong>整合于宿主染色体或质粒形式</strong>）</li><li>T4噬菌体的形态是（<strong>蝌蚪形</strong>），腺病毒的形态是（<strong>球形</strong>），TMV的形态是（<strong>杆状</strong>）</li><li>病毒核心成份是（<strong>核酸</strong>），衣壳的组成成分是（<strong>蛋白质</strong>），包膜的组成成分是（<strong>脂类</strong>）</li><li>在溶源细胞中，原噬菌体以（<strong>整合态</strong>）形式存在于宿主细胞中</li><li>噬菌体是一种感染微生物的病毒，缺乏（<strong>独立代谢的酶体系</strong>）</li></ol><h3 id="问答题-v3"><a class="header-anchor" href="#问答题-v3"></a>问答题</h3><h4 id="简述烈性噬菌体的生活史"><a class="header-anchor" href="#简述烈性噬菌体的生活史"></a>简述烈性噬菌体的生活史</h4><ol><li>尾丝与宿主细胞特异性吸附；</li><li>病毒核酸侵入宿主细胞内；</li><li>病毒核酸和蛋白质在宿主细胞内的复制和合成；</li><li>病毒核酸和蛋白质装配；</li><li>大量子代噬菌体裂解释放到宿主细胞外。</li></ol><h4 id="什么是效价？其测定方法有哪些？简述测定噬菌体效价的双层平板法。"><a class="header-anchor" href="#什么是效价？其测定方法有哪些？简述测定噬菌体效价的双层平板法。"></a>什么是效价？其测定方法有哪些？简述测定噬菌体效价的双层平板法。</h4><p>效价：每毫升试样中所含有的具侵染性的噬菌体粒子数</p><p>测定方法有：液体稀释法、玻片快速测定法、单层平板法和双层平板法。</p><p>双层平板法：先在培养皿中倒入底层固体培养基，凝固后再倒入含有宿主细菌和一定稀释度噬菌体的半固体培养基。培养一段时间后，计算噬菌斑的数量。</p><h4 id="什么是一步生长曲线？画出自然裂解的曲线图，图中的各期又有何特点？"><a class="header-anchor" href="#什么是一步生长曲线？画出自然裂解的曲线图，图中的各期又有何特点？"></a>什么是一步生长曲线？画出自然裂解的曲线图，图中的各期又有何特点？</h4><p>定量描述烈性噬菌体生长规律的实验曲线，称为一步生长曲线。</p><ul><li>潜伏期：细胞内已经开始装配噬菌体粒子并可用电镜观察到；</li><li>裂解期：宿主细胞迅速裂解溶液中噬菌体粒子急剧增多；</li><li>平稳期：感染后的宿主细胞已全部裂解，溶液中的噬菌体效价达到最高点。</li></ul><p><img src="http://img.whl123456.top/image/clip_image002-1593018096062.jpg" alt=""></p><h4 id="什么是类病毒、拟病毒、卫星病毒、RNA病毒和阮病毒？"><a class="header-anchor" href="#什么是类病毒、拟病毒、卫星病毒、RNA病毒和阮病毒？"></a>什么是类病毒、拟病毒、卫星病毒、RNA病毒和阮病毒？</h4><p>类病毒：一类只含有RNA一种成分，专性寄生在活细胞内的分子病源体。</p><p>拟病毒：指一类包裹在真病毒粒中的有缺陷的类病毒。</p><p>卫星病毒：基因组缺损、必须依赖某形态较大的专一辅助病毒才能复制和表达的小型伴生病毒。</p><p>RNA病毒：遗传物质是核糖核酸RNA的病毒 。</p><p>朊病毒：一类不含核酸的传染性蛋白质。</p><h4 id="谈谈你对“新型冠状病毒”的认识与思考"><a class="header-anchor" href="#谈谈你对“新型冠状病毒”的认识与思考"></a>谈谈你对“新型冠状病毒”的认识与思考</h4><p>型冠状病毒，国际病毒分类委员会将该病毒命名为SARS-CoV-2，属于网巢病毒目冠状病毒科（<em>Betacoronavirus</em>），病毒粒呈圆形或椭圆形，直径约80～120nm。由衣壳（衣壳外有包膜）和ssRNA组成。有三种主要蛋白：包膜蛋白（E蛋白）、膜蛋白（M蛋白）和刺突蛋白（S蛋白）。基因组长度约3万个核苷酸。病毒具有热敏感性，暴露在紫外线下或处于56℃高温环境下30分钟可达到灭活效果。利用乙醚、75%乙醇、含氯消毒剂、过氧乙酸和氯仿等脂溶剂均可有效灭活病毒。</p><p>经历这次肺炎疫情，我深刻的感受到了新冠病毒带给人们的危害。人类也多次在与病毒的斗争中付出惨痛的代价，例如1918年流感大流行。但一个世纪以来，伴随着基础学科的进步，生物学的有关发展，人们对病毒的认识逐渐加深，正因为认识的不断深入，人类才能更好的抑制病毒带来的负面影响。与此同时仍要对自然抱有敬畏之心，要从这次疫情中吸取经验教训，在让全球走出这场风波的同时，更是为全世界打上一针“预防针”。</p><h2 id="微生物的营养和培养基"><a class="header-anchor" href="#微生物的营养和培养基"></a>微生物的营养和培养基</h2><h3 id="填空题-v4"><a class="header-anchor" href="#填空题-v4"></a>填空题</h3><ol><li><p>微生物生长繁殖所需六大营养要素是**<u>碳源</u><strong>、</strong><u>氮源</u><strong>、</strong><u>无机盐</u><strong>、</strong><u>生长因子</u><strong>、 <strong><u>水</u></strong>、</strong><u>能源</u>**</p></li><li><p>根据**<u>碳源</u>**，微生物可分为自养型和异养型。</p></li><li><p>根据**<u>能源</u>**，微生物可分为光能营养型和化能营养型。</p></li><li><p>根据**<u>氢供体</u>**，微生物可分为无机营养型和有机营养型。</p></li><li><p>根据碳源、能源和氢供体性质的不同，微生物的营养类型可分为**<u>光能无机自养</u><strong>、 <strong><u>光能有机异养</u></strong> 、</strong><u>化能无机自养</u>**、 <strong><u>化能有机异养</u></strong></p></li><li><p>设计、配制培养基所要遵循的原则包括**<u>目的明确</u>**、 <strong><u>营养协同</u></strong>、 <strong><u>理化适宜</u></strong>、 <strong><u>经济节约</u></strong></p></li><li><p>按所含成分划分，培养基可分为**<u>天然培养基</u><strong>、 <strong><u>组合培养基</u></strong>、</strong><u>半组合培养基</u>**</p></li><li><p>按物理状态划分，培养基可分为**<u>固体</u>**、 <strong><u>半固体</u></strong>、 <strong><u>液体</u></strong>、  <strong><u>脱水培养基</u></strong></p></li><li><p>按用途划分，培养基可分为**<u>基础</u>** 、<strong><u>加富</u></strong>、 <strong><u>鉴别</u></strong>、 <strong><u>选择</u></strong></p></li><li><p>营养物质进入细胞的方式有**<u>单纯扩散</u>** 、<strong><u>促进扩散</u></strong>、 <strong><u>主动运输</u></strong>、 <strong><u>基团移位</u></strong></p></li><li><p>在营养物质的四种运输方式中,只有**<u>基团移位</u>**运输方式改变了被运输物质的分子结构</p></li><li><p>在营养物质运输中,能逆浓度梯度方向进行营养物运输的运输方式是**<u>主动运输</u><strong>、</strong><u>基团移位</u>**</p></li><li><p>在营养物质运输中顺浓度梯度方向运输营养物质进入微生物细胞的运输方式是**<u>单纯扩散</u><strong>、</strong><u>促进扩散</u>**</p></li><li><p>在营养物质运输中既消耗能量又需要载体的运输方式是**<u>主动运输</u><strong>、</strong><u>基团移位</u>**</p></li><li><p>微生物细胞采用主动运输方式吸收营养物的机制在于，通过消耗**<u>能量</u><strong>使载体蛋白发生</strong><u>构象</u><strong>变化，从而能够</strong><u>逆浓度</u>**梯度从外界摄取营养物。</p></li></ol><h3 id="选择题-v4"><a class="header-anchor" href="#选择题-v4"></a>选择题</h3><ol><li>在含有下列物质的培养基中，大肠杆菌首先利用的碳物质是（<strong>葡萄糖</strong>）</li><li>下列物质可用作生长因子的是（<strong>维生素</strong>）</li><li>一般酵母菌生长最适水活度值为（<strong>0.88</strong>）</li><li>大肠杆菌属于(<strong>化能有机异养</strong> )型的微生物</li><li>蓝细菌和藻类属于( <strong>光能无机自养</strong> )型的微生物。</li><li>硝化细菌属于(<strong>化能无机自养</strong> )型的微生物。</li><li>需要载体但不能进行逆浓度运输的是（<strong>促进扩散</strong>）</li><li>实验室培养细菌常用的的培养基是（<strong>牛肉膏蛋白胨培养基</strong>）</li><li>培养百日咳博德氏苗的培养基中含有血液，这种培养基是（<strong>加富培养基</strong>）</li><li>用来分离固氮菌的培养基中缺乏氮源，这种培养基是一种（<strong>选择培养基</strong>）</li><li>一般细菌适宜的生长pH为（<strong>6.5-7.5</strong>）</li><li>水分子可通过(<strong>单纯扩散</strong>)进入细胞</li></ol><h3 id="问答题-v4"><a class="header-anchor" href="#问答题-v4"></a>问答题</h3><h4 id="什么叫碳源？试从元素水平、化合物水平和培养基原料水平列出微生物的碳源谱"><a class="header-anchor" href="#什么叫碳源？试从元素水平、化合物水平和培养基原料水平列出微生物的碳源谱"></a>什么叫碳源？试从元素水平、化合物水平和培养基原料水平列出微生物的碳源谱</h4><p>一切能满足微生物生长繁殖所需碳元素的营养源，称为碳源</p><p><img src="http://img.whl123456.top/image/1.png" alt=""></p><h4 id="列表说明微生物的营养类型是如何分类的，并举例说明相应的微生物种类。"><a class="header-anchor" href="#列表说明微生物的营养类型是如何分类的，并举例说明相应的微生物种类。"></a>列表说明微生物的营养类型是如何分类的，并举例说明相应的微生物种类。</h4><table><thead><tr><th>营养类型</th><th>能源</th><th>氢供体</th><th>基本碳源</th><th>实例</th></tr></thead><tbody><tr><td>光能无机营养型  （光能自养型）</td><td>光</td><td>无机物</td><td>CO<sub>2</sub></td><td>紫硫细菌、绿硫细菌、藻类</td></tr><tr><td>光能有机营养型  （光能异养型）</td><td>光</td><td>有机物</td><td>CO<sub>2</sub>及简单有机物</td><td>红螺细菌</td></tr><tr><td>化能无机营养型  （化能自养型）</td><td>无机物</td><td>无机物</td><td>CO<sub>2</sub></td><td>硝化细菌、硫化细菌</td></tr><tr><td>化能有机营养型  （化能异养型）</td><td>有机物</td><td>有机物</td><td>有机物</td><td>绝大多数细菌和全部真核微生物</td></tr></tbody></table><h4 id="列表比较营养物质的四种跨膜输送形式。"><a class="header-anchor" href="#列表比较营养物质的四种跨膜输送形式。"></a>列表比较营养物质的四种跨膜输送形式。</h4><table><thead><tr><th>比较项目</th><th>单纯扩散</th><th>促进扩散</th><th>主动运送</th><th>基团移位</th></tr></thead><tbody><tr><td>特异载体蛋白</td><td>无</td><td>有</td><td>有</td><td>有</td></tr><tr><td>运输速度</td><td>慢</td><td>快</td><td>快</td><td>快</td></tr><tr><td>物质运输方向</td><td>由浓至稀</td><td>由浓至稀</td><td>由稀至浓</td><td>由稀至浓</td></tr><tr><td>平衡时胞内外浓度</td><td>相等</td><td>相等</td><td>胞内浓度高</td><td>胞内浓度高</td></tr><tr><td>运输分子</td><td>无特异性</td><td>特异性</td><td>特异性</td><td>特异性</td></tr><tr><td>能量消耗</td><td>不需要</td><td>不需要</td><td>需要</td><td>需要</td></tr><tr><td>运输后物质的结构</td><td>不变</td><td>不变</td><td>不变</td><td>改变</td></tr></tbody></table><h4 id="什么是鉴别性培养基？以伊红美蓝-EMB-培养基为例，分析鉴别培养基的作用原理。"><a class="header-anchor" href="#什么是鉴别性培养基？以伊红美蓝-EMB-培养基为例，分析鉴别培养基的作用原理。"></a>什么是鉴别性培养基？以伊红美蓝(EMB)培养基为例，分析鉴别培养基的作用原理。</h4><p>鉴定性培养基一类在成分中加有与目的菌的无色代谢产物发生显色反应的指示剂，从而达到只须用肉眼辨别颜色就能方便地从近似菌落中找出目的菌菌落的培养基。</p><p>EMB培养基含有伊红和美蓝两种染料作为指示剂，大肠杆菌可发酵乳糖产酸造成酸性环境时，这两种染料结合形成复合物，使大肠杆菌苗落带金属光泽的深紫色，而与其他不能发酵乳糖产酸的微生物区分开。</p><h2 id="微生物的代谢"><a class="header-anchor" href="#微生物的代谢"></a>微生物的代谢</h2><h3 id="填空题-v5"><a class="header-anchor" href="#填空题-v5"></a>填空题</h3><ol><li><p>微生物的4种糖酵解途径中，**<u>EMP</u>**是存在于大多数生物体内的一条主流代谢途径；</p><p>**<u>ED</u>**是存在于某些缺乏完整EMP途径的微生物中的一种替代途径，为微生物所特有；</p><p>**<u>HMP</u>**是产生4碳、5碳等中间产物，为生物合成提供多种前体物质的途径。</p></li><li><p>同型乳酸发酵是指葡萄糖经**<u>EMP</u>**途径降解为丙酮酸，丙酮酸在乳酸脱氢酶的作用下被NADH还原为乳酸。</p><p>异型乳酸发酵经**<u>HMP</u><strong>途径分解葡萄糖。代谢终产物除乳酸外，还有</strong><u>乙醇或乙酸</u>**</p></li><li><p>代谢是细胞内发生的全部生化反应的总称，主要是由**<u>分解代谢</u>**、 **<u>合成代谢</u>**两个过程组成。</p><p>微生物的分解代谢是指**<u>大分子物质</u><strong>在细胞内降解成</strong><u>小分子物质</u><strong>，并</strong><u>产生</u>**能量的过程；</p><p>合成代谢是指利用**<u>小分子物质</u><strong>在细胞内合成</strong><u>大分子物质</u><strong>，并</strong><u>消耗</u>**能量的过程。</p></li><li><p>产能代谢中，化能微生物通过**<u>底物水平</u><strong>磷酸化和</strong><u>氧化</u>**磷酸化将某种物质氧化而释放的能量储存在ATP等高能分子中；</p><p>光合微生物则通过**<u>光合</u>**磷酸化将光能转变成为化学能储存在ATP中。</p><p>**<u>底物水平</u>**磷酸化既存在于发酵过程中，也存在于呼吸作用过程中。</p></li><li><p>呼吸作用与发酵作用的根本区别是呼吸作用中电子载体不是将电子直接传递给底物降解的中间产物，而是交给**<u>电子传递</u><strong>系统，逐步释放出能量后再交给</strong><u>最终电子受体</u>**</p></li><li><p>生物氧化的形式包括**<u>得氧</u><strong>、</strong><u>脱氢</u><strong>、</strong><u>失电子</u><strong>三种，其过程可分为</strong><u>脱氢</u><strong>、</strong><u>递氢</u><strong>、</strong><u>受氢</u><strong>三个阶段，其功能有</strong><u>产ATP</u><strong>、</strong><u>产[H]</u><strong>、</strong><u>产中间代谢物</u><strong>三种，类型包括</strong><u>呼吸</u><strong>、</strong><u>无氧呼吸</u><strong>、</strong><u>发酵</u>**</p></li><li><p>无氧呼吸的最终电子受体不是氧，而是外源电子受体，像NO<sub>3</sub><sup>-</sup>、NO<sub>2</sub><sup>-</sup>、SO<sub>4</sub><sup>2-</sup>、S<sub>2</sub>O<sub>3</sub><sup>2-</sup>、CO<sub>2</sub>等**<u>无机化合物</u><strong>，或</strong><u>延胡索酸</u>**等有机化合物</p></li><li><p>化能自养微生物氧化**<u>无机物</u><strong>而获得能量和还原力。能量的产生是通过</strong><u>氧化磷酸化</u><strong>形式，电子受体通常是O<sub>2</sub>，还原力的获得是</strong><u>逆呼吸链</u><strong>的方向进行传递，</strong><u>消耗</u>**能量</p></li><li><p>微生物将空气中的N<sub>2</sub>还原为NH<sub>3</sub>的过程称为**<u>生物固氮</u><strong>该过程中根据微生物和其他生物之间相互的关系。固氮体系可以分为</strong><u>自生固氮体系</u><strong>、</strong><u>共生固氮体系</u><strong>、</strong><u>联合固氮体系</u>**三种。</p></li><li><p>次级代谢是微生物生长至**<u>指数期后期</u><strong>或</strong><u>稳定期</u><strong>，以</strong><u>初级代谢产物</u>**为前体，合成一些对微生物自身生命活动无明确生理功能的物质的过程。</p></li><li><p>自养微生物固定CO<sub>2</sub>的途径主要有3条：卡尔文循环途径，可分为**<u>CO<sub>2</sub>的固定(羧化反应)</u><strong>、</strong><u>被固定CO<sub>2</sub>的还原(还原反应)</u>**、 <strong><u>CO<sub>2</sub>受体的再生</u></strong></p></li><li><p><em>Staphylococcus aureus</em>（金黄色葡萄球菌）肽聚糖合成分为3个阶段：细胞质中合成的**<u>“Park”核苷酸</u><strong>，在细胞膜中进一步合成</strong><u>肽聚糖单体分子</u><strong>，然后在细胞膜外壁引物存在下合成肽聚糖。青霉素在细胞膜外抑制</strong><u>转肽酶</u>**的活性从而抑制肽聚糖的合成。</p></li><li><p>固氮酶包括两种组分：组分Ⅰ是**<u>固二氮酶</u><strong>，是一种</strong><u>钼铁蛋白</u><strong>，由4个亚基组成；组分Ⅱ是一种</strong><u>固二氮酶还原酶</u><strong>，是一种</strong><u>铁蛋白</u>**，由两个亚基组成。P1、P2单独存在时，都没有活性，只有形成复合体后才有固氮酶活性。</p></li><li><p>底物脱氢4条途径有中产生还原力为NADH的途径有**<u>EMP</u><strong>、</strong><u>ED</u><strong>、</strong><u>TCA</u><strong>，产NADPH的途径有</strong><u>HMP</u><strong>、</strong><u>ED</u><strong>产FADH2的途径有</strong><u>TCA</u>**。</p></li></ol><h3 id="选择题-v5"><a class="header-anchor" href="#选择题-v5"></a>选择题</h3><ol><li>化能自养微生物的能量来源于（<strong>还原态无机化合物</strong>）</li><li>下列葡萄糖生成丙酮酸的糖酵解途径中，（<strong>EMP途径</strong>）是最普遍的、存在于大多数生物体内的一条主流代谢途径。</li><li>列葡萄糖生成丙酮酸的糖酵解途径中，（<strong>ED途径</strong>）是存在于某些缺乏完整EMP途径的替代途径。</li><li>酵母菌和运动发酵单胞菌乙醇发酵的区别是（<strong>糖酵解途径不同</strong>）</li><li>同型乳酸发酵中葡萄糖生成丙酮酸的途径是（<strong>EMP途径</strong>）</li><li>ATP或GTP的生成与高能化合物的酶催化转换相偶联的产能方式是（<strong>底物水平磷酸化</strong>）</li><li>卡尔文循环途径中CO2固定(羧化反应)的受体是（<strong>核酮糖-1,5-2磷酸</strong>）</li><li>由丙酮酸开始的其他发酵过程中，主要产物是丁酸、丁醇、异丙醇的发酵的是(<strong>丁酸发醇</strong>)</li><li>下列代谢方式中，能量获得最有效的方式是(<strong>有氧呼吸</strong>)</li><li>青霉素抑制金黄色葡萄球菌肽聚糖合成的(<strong>细胞膜外的转肽酶</strong>)</li><li>下面对于好氧呼吸的描述(<strong>电子供体是有机化合物，电子受体是无机化合物</strong>)是正确的。</li><li>无氧呼吸中呼吸链末端的氢受体是(<strong>氧化型无机化合物和少数有机化合物</strong>)</li><li>硝化细菌是(<strong>化能自养菌，氧化亚硝酸生成硝酸获得能量</strong>)</li><li>不能用于解释好氧性固氮菌其固氮酶的抗氧机制的是<ul><li>呼吸保护作用</li><li>构象保护</li><li>膜的分隔作用</li><li><strong>某些固氮酶对氧气不敏感</strong></li></ul></li><li>当一个NADH2分子经代谢并让它的电子通过电子传递链传递后，可产生(<strong>3个ATP分子</strong>)</li><li>微生物从糖酵解途径中可获得(<strong>2</strong>)个ATP分子</li><li>下列光合作用微生物中进行的是非环式光合磷酸化作用的是(<strong>蓝细菌</strong>)</li><li>当进行糖酵解化学反应时，(<strong>从一个葡萄糖分子产生两个丙酮酸分子</strong>)</li><li>延胡索酸呼吸中，(<strong>延胡索酸</strong>)是末端氢受体</li><li>厌氧微生物进行呼吸吗(<strong>进行呼吸，但是不利用氧气</strong>)</li></ol><h3 id="问答题-v5"><a class="header-anchor" href="#问答题-v5"></a>问答题</h3><h4 id="列表比较同型乳酸发酵与异型乳酸发酵"><a class="header-anchor" href="#列表比较同型乳酸发酵与异型乳酸发酵"></a>列表比较同型乳酸发酵与异型乳酸发酵</h4><p><img src="http://img.whl123456.top/image/2.png" alt=""></p><h4 id="试述嗜盐菌紫膜光合作用的基本原理"><a class="header-anchor" href="#试述嗜盐菌紫膜光合作用的基本原理"></a>试述嗜盐菌紫膜光合作用的基本原理</h4><p>细菌的视紫红质的功能与叶绿素相似，能吸收光能，并在光量子的驱动下起着质子泵的作用。这时，它将反应中产生的质子一一逐出细胞膜外，从而使紫膜内外形成一个质子梯度差。根据化学渗透学说，这一梯度差（即质子动势）在驱逐H<sup>+</sup>通过ATP酶的孔道进入膜内以达到质子平衡时，就会产生ATP。当环境中O<sub>2</sub>浓度很低时，嗜盐菌无法利用氧化磷酸化来满足其正常需求，若光照条件适宜，它就能合成紫膜，并利用紫膜的光介导ATP合成机制获得必要的能量。</p><h4 id="固氮过程需满足哪些条件？"><a class="header-anchor" href="#固氮过程需满足哪些条件？"></a>固氮过程需满足哪些条件？</h4><ul><li>ATP的供应</li><li>还原力[H]及其载体</li><li>固氮酶<ul><li>组分Ⅰ：真正“固氮酶”，又称钼铁蛋白（MF）、钼铁氧还蛋白（MoFd）</li><li>组分Ⅱ：固氮酶还原酶，不含钼只含铁的蛋白，又称铁蛋白、固氮铁氧还蛋白</li></ul></li><li>还原性底物氮</li><li>Mg<sup>2+</sup></li><li>严格的厌氧微环境</li></ul><h4 id="蓝细菌是一类放氧性光合生物，又是一类固氮菌，说明其固氮酶的抗氧保护机制。"><a class="header-anchor" href="#蓝细菌是一类放氧性光合生物，又是一类固氮菌，说明其固氮酶的抗氧保护机制。"></a>蓝细菌是一类放氧性光合生物，又是一类固氮菌，说明其固氮酶的抗氧保护机制。</h4><p>异形胞是部分蓝细菌适应于有氧条件下进行固氮作用的特殊细胞。机制：</p><ul><li>很厚的细胞壁；</li><li>缺乏产氧光合系统Ⅱ；</li><li>有高的脱氢酶和氢化酶活力；</li><li>这还有高的超氧化物歧化酶活力，有解除氧毒害的功能；</li><li>其呼吸强度也高于邻近的营养细胞。</li></ul><p>没有异形胞分化的蓝细菌：</p><ul><li>将固氮作用与光合作用分开进行(黑暗下固氮，光照下进行光合作用)</li><li>在束状群体中央失去光合系统Ⅱ的细胞中进行固氮作用</li><li>提高细胞内过氧化物酶或超氧化物歧化酶活力以解除氧毒害</li></ul><h4 id="细菌酒精发酵与酵母菌的酒精发酵有何异同"><a class="header-anchor" href="#细菌酒精发酵与酵母菌的酒精发酵有何异同"></a>细菌酒精发酵与酵母菌的酒精发酵有何异同</h4><p>共同点：葡萄糖降解为丙酮酸，丙酮酸脱羧为乙醛，乙醛再还原成乙醇<br>不同点：</p><ul><li>产生丙酮酸的途径不同：酵母型酒精发酵是通过EMP途径，而细菌酒精发酵是通过ED途径。</li><li>净产ATP不同：与酵母乙醇发酵相比，细菌乙醇发酵净产生ATP只有1个</li><li>菌种不同：参与酵母型酒精发酵的是酿酒酵母，细菌酒精发酵是运动发酵单胞菌等微好氧菌。</li></ul><h4 id="列表比较呼吸、无氧呼吸和发酵的异同点"><a class="header-anchor" href="#列表比较呼吸、无氧呼吸和发酵的异同点"></a>列表比较呼吸、无氧呼吸和发酵的异同点</h4><table><thead><tr><th>项目</th><th>有氧呼吸</th><th>无氧呼吸</th><th>发酵</th></tr></thead><tbody><tr><td>氧化基质</td><td>有机物</td><td>有机物</td><td>有机物</td></tr><tr><td>氢受体</td><td>O<sub>2</sub></td><td>无机或有机氧化物</td><td>氧化型中间代谢产物  (乙醛、丙酮酸等）</td></tr><tr><td>产物</td><td>CO<sub>2</sub>、H<sub>2</sub>O</td><td>还原型无机或有机氧化物</td><td>还原型中间代谢产物（乙醇、乳酸等）</td></tr><tr><td>产能效率</td><td>高</td><td>中</td><td>低</td></tr><tr><td>产能机制</td><td>氧化磷酸化</td><td>氧化磷酸化</td><td>底物水平磷酸化</td></tr><tr><td>递氢体</td><td>电子传递链  （完整）</td><td>电子传递链（不完整）</td><td>无</td></tr></tbody></table><h2 id="微生物的生长及其控制"><a class="header-anchor" href="#微生物的生长及其控制"></a>微生物的生长及其控制</h2><h3 id="填空题-v6"><a class="header-anchor" href="#填空题-v6"></a>填空题</h3><ol><li>根据微生物与氧气的关系，可将微生物分成**<u>好氧</u><strong>，</strong><u>兼性厌氧</u><strong>，</strong><u>厌氧</u><strong>，</strong><u>微好氧</u><strong>，</strong><u>耐氧</u>**五个类型</li><li>测定微生物生长量的间接方法有**<u>比浊法</u>**， <strong><u>生理指标法</u></strong></li><li>一条典型的生长曲线至少可分为**<u>迟缓期</u><strong>，</strong><u>对数生长期</u>** ，<strong><u>稳定生长期</u></strong> ，**<u>衰亡期</u>**4个生长时期</li><li>控制连续培养的方法有**<u>恒浊法</u>**， <strong><u>恒化法</u></strong></li><li>现代实验室中研究厌氧菌最有效的三大技术是**<u>厌氧罐技术</u><strong>，  <strong><u>厌氧手套箱技术</u></strong>  ，</strong><u>亨盖特滚管技术</u>**</li><li>对玻璃器皿、金属用具等物品可用**<u>高压蒸汽灭菌法</u>**， **<u>干热灭菌法</u>**进行灭菌；而对牛奶或其他液态食品一般采用 **<u>巴氏消毒法</u>**灭菌</li><li>多数细菌生长最适pH是**<u>6.5-7.5</u><strong>，放线菌生长最适pH一般是 <strong><u>7.5-8.0</u></strong>，真菌生长的最适pH一般是</strong><u>5-6</u>**</li><li>杀灭或抑制微生物的物理因素有**<u>高温</u><strong>，  <strong><u>辐射</u></strong> ，</strong><u>超声波</u>** ，<strong><u>渗透压</u></strong> ，<strong><u>干燥</u></strong> 等</li><li>微生物按其生长温度范围可分为**<u>低温型</u><strong>，</strong><u>中温型</u><strong>，</strong><u>高温型</u><strong>3 类，最适生长温度分别为</strong><u>(10-15) ℃</u><strong>，</strong><u>(25-37) ℃</u><strong>，</strong><u>(45-50) ℃</u>**</li><li>抗代谢药物中磺胺类是由于与**<u>对氨基苯甲酸</u><strong>相似，从而竞争性地与二氢叶酸合成酶结合，使其不能合成</strong><u>叶酸</u>**</li></ol><h3 id="选择题-v6"><a class="header-anchor" href="#选择题-v6"></a>选择题</h3><ol><li><p>所有微生物世代时间<strong>不同</strong></p></li><li><p>高温对微生物的致死是因为</p><ul><li>高温使菌体蛋白变性</li><li>高温使核酸变性</li><li>高温破坏细胞膜的透性</li><li><strong>以上都是</strong></li></ul></li><li><p>如果将处于对数期的细菌移至相同组分的新鲜培养基中，该批培养物将处于哪个生长期?<strong>对数期</strong></p></li><li><p>细菌细胞进入稳定期是由于：①细胞已为快速生长作好了准备；②<strong>代谢产生的毒性物质发生了积累</strong>；③<strong>能源已耗尽</strong>；④细胞已衰老且衰老细胞停止分裂；⑤在重新开始生长前需要合成新的蛋白质（<strong>2, 3</strong>）</p></li><li><p>对生活的微生物进行计数的最准确的方法是<strong>平板菌落记数</strong></p></li><li><p>用比浊法测定生物量的特点是<strong>简单快速，但需要大量的细胞</strong></p></li><li><p>下列哪种保存方法会降低食物的水活度<strong>腌肉</strong></p></li><li><p>细胞复制时所有的细胞组分都按比例有规律地增加的现象是<strong>平衡生长</strong></p></li><li><p>最适生长温度低于20℃的微生物被称为<strong>嗜冷菌</strong></p></li><li><p>过氧化氢酶能解除<strong>过氧化氢</strong>的毒性</p></li><li><p>能导致微生物死亡的化学试剂是 <strong>溶菌剂</strong> 、<strong>杀菌剂</strong></p></li><li><p>只能用高压灭菌才能杀死的是<strong>细菌的内生孢子</strong></p></li><li><p>常用的高压灭菌的温度是<strong>121℃</strong></p></li><li><p>巴斯德消毒法可用于 <strong>啤酒</strong>、 <strong>葡萄酒</strong>、<strong>牛奶</strong>的消毒</p></li><li><p>巴氏灭菌的工艺条件是：<strong>(62-63) ℃30 min</strong></p></li><li><p>能通过抑制叶酸合成而抑制细菌生长 <strong>磺胺类药物</strong></p></li><li><p>专性厌氧微生物是由于其细胞内缺少 <strong>SOD</strong>，从而不能解除分子氧对细胞的毒害。</p></li><li><p>使用高压锅灭菌时，打开排汽阀的目的是<strong>排尽锅内冷空气</strong></p></li><li><p>直接显微镜计数用来测定下面所有微生物群体的数目，除了<strong>病毒</strong>之外</p></li><li><p>有人大量使用广谱抗生素，目的在于消炎，可是停药一段时间后，他长期低烧，又找不到体内有炎症的部位，发烧的原因可能是<strong>大肠内菌群失调</strong></p></li></ol><h3 id="问答题-v6"><a class="header-anchor" href="#问答题-v6"></a>问答题</h3><h4 id="图示分批培养中微生物的生长曲线，并说明各个时期的特点。"><a class="header-anchor" href="#图示分批培养中微生物的生长曲线，并说明各个时期的特点。"></a>图示分批培养中微生物的生长曲线，并说明各个时期的特点。</h4><p><img src="http://img.whl123456.top/image/3.png" alt=""></p><p>延滞期特点：生长速率常数等于零；细胞形态变大；RNA含量增加；代谢活力强；对不良条件抵抗能力降低。</p><p>指数期特点：生长速率最大，代时最短；细胞进行平衡生长；酶系活跃，代谢旺盛。</p><p>稳定期特点：细胞生长速率为零；活菌数保持相对稳定，总菌数达最高水平；合成次生代谢产物；细胞内出现储藏物质，芽孢杆菌这时开始形成芽孢。</p><p>衰亡期：细菌死亡数大于增殖数,活菌数明显减少,群体衰落 ；细胞出现多形态,大小不等的 畸形,变成衰退型 ；细胞死亡,出现自溶现象；产生或释放抗生素等次生代谢产物；芽孢释放。</p><h4 id="与分批发酵相比，连续培养有何优点？"><a class="header-anchor" href="#与分批发酵相比，连续培养有何优点？"></a>与分批发酵相比，连续培养有何优点？</h4><p>由于连续培养中微生物的生长一直保持在对数期，生物量浓度在较长时间内保持恒定，因此单批发酵相比，连续培养：</p><ul><li>能缩短发酵周期，提高设备利用率；</li><li>便于自动控制；</li><li>降低动力消耗体力劳动强度；</li><li>产品质量较稳定。</li></ul><h4 id="试比较灭菌、消毒、防腐和化疗之间的区别。"><a class="header-anchor" href="#试比较灭菌、消毒、防腐和化疗之间的区别。"></a>试比较灭菌、消毒、防腐和化疗之间的区别。</h4><p>灭菌是杀死所有微生物；</p><p>消毒是杀死或消除所有病原微生物，达到防止病原菌传播的目的；</p><p>防腐是利用理化因子使微生物暂不生长；</p><p>化疗是有效地消除宿主体内的微生物。</p><h4 id="什么原因导致抗生素不敏感的抗性菌株的增多"><a class="header-anchor" href="#什么原因导致抗生素不敏感的抗性菌株的增多"></a>什么原因导致抗生素不敏感的抗性菌株的增多?</h4><ul><li>细胞质膜透性改变，使抗生素不进入细胞；</li><li>通过主动外排系统把进入细胞内的药物主动排出细胞外；</li><li>把药物作用的靶位加以修饰和改变；</li><li>产生一种能使药物失去活性的酶</li><li>形成“救护途径”，通过被药物的代谢途径发生变异，而变为仍能合成原产物的新途径。</li></ul><h4 id="试述影响微生物生长过程中延滞期长短的因素。"><a class="header-anchor" href="#试述影响微生物生长过程中延滞期长短的因素。"></a>试述影响微生物生长过程中延滞期长短的因素。</h4><p>菌种：繁殖速度较快的菌种的延迟期一般较短；</p><p>接种物菌龄：用对数生长期的菌种接种时，其延迟期较短，甚至检查不到延迟期；</p><p>接种量：一般来说，接种量增大可缩短甚至消除延迟期（发酵工业上一般采用1/10的接种量）；</p><p>培养基成分：在营养成分丰富的天然培养基上生长的延滞期比在合成培养基上生长时短；接种后培养基成分有较大变化时，会使延滞期加长，所以发酵工业上尽量使发酵培养基的成分与种子培养基接近。</p><h2 id="微生物遗传变异和育种"><a class="header-anchor" href="#微生物遗传变异和育种"></a>微生物遗传变异和育种</h2><h3 id="填空题-v7"><a class="header-anchor" href="#填空题-v7"></a>填空题</h3><ol><li>通过**<u>细菌转化</u><strong>实验，证明</strong><u>DNA</u><strong>是肺炎链球菌的遗传物质；通过</strong><u>噬菌体感染</u><strong>实验，证明</strong><u>DNA</u><strong>是噬菌体的遗传物质；通过</strong><u>植物病毒重建</u><strong>，证明了TMV的遗传物质是</strong><u>RNA</u>**</li><li>紫外线照射能使DNA相邻碱基形成**<u>嘧啶二聚体</u><strong>，从而导致DNA复制产生错误，用紫外线诱变微生物后应在</strong><u>黑暗</u><strong>条件下进行，以防止</strong><u>光复活</u>**现象的产生</li><li>证明基因突变自发性和不对应性的三个经典实验是**<u>变量试验</u>**、 <strong><u>涂布试验</u></strong>、 <strong><u>影印平板培养法</u></strong></li><li>细菌在一般情况下是一套基因，即**<u>单倍体</u><strong>；真核微生物通常是有两套基因又称</strong><u>二倍体</u>**</li><li>**<u>Col</u>**质粒首先发现于大肠杆菌中而得名，该质粒含有编码大肠菌素的基因</li><li>四种引起细菌基因重组的方式是**<u>转化</u>**、 <strong><u>转导</u></strong>、 <strong><u>接合</u></strong>、 <strong><u>原生质体融合</u></strong></li><li>营养缺陷型是微生物遗传学研究中重要的选择标记和育种的重要手段，由于这类突变型在**<u>基本培养基</u>**上不生长，所以是一种负选择标记</li><li>在**<u>普遍</u><strong>转导中，噬菌体可以转导供体染色体的任何部分到受体细胞中；而在</strong><u>局限</u>**转导中，噬菌体总是携带同样的片段到受体细胞中。</li><li>基因突变具有的特性为**<u>自发性</u>**、 <strong><u>不对应性</u></strong>、 <strong><u>稀有性</u></strong>、 <strong><u>独立性</u></strong>、 <strong><u>可诱变性</u></strong>、 <strong><u>稳定性</u></strong>、 <strong><u>可逆性</u></strong></li><li>筛选高产菌株用**<u>琼脂块培养</u><strong>法；筛选抗药性菌株用</strong><u>梯度平板</u>**法</li></ol><h3 id="选择题-v7"><a class="header-anchor" href="#选择题-v7"></a>选择题</h3><ol><li>最小的遗传单位是<strong>基因</strong></li><li>细菌直接摄取外界游离的DNA片段发生变异称为<strong>转化</strong></li><li>由于个别碱基的置换、插入或缺失引起的突变称为<strong>基因突变</strong></li><li>某个碱基的改变，使代表某种氨基酸的密码子变为蛋白质合成的终止密码子(UAA，UAG，UGA)。蛋白质的合成提前终止，产生截短的蛋白质，这种基因突变是<strong>无义突变</strong></li><li>当 <strong>F<sup>-</sup>菌株和F<sup>+</sup>菌株接合</strong>，会发生基因重组，并使F<sup>-</sup>菌株变化F<sup>+</sup>菌株。</li><li>游离于各种微生物细胞质中的小DNA分子称作下列哪种结构<strong>质粒</strong></li><li>诱变育种是指利用各种诱变剂处理微生物细胞，提高基因的随机(<strong>突变频率</strong>)，通过一定的筛选方法获得所需要的高产优质菌株。</li><li>以噬菌体为媒介，把供体细胞的DNA片段带到受体细胞中，使后者获得前者的部分遗传性状的现象叫<strong>转导</strong></li><li>由一种诱变剂引起DNA分子中一个或少数几个核苷酸的增加或缺失，从而引造成突变点以后的全部遗传密码的转录和转译发生错误，由这种突变产生的突变体称为<strong>移码突变</strong></li><li>营养缺陷型菌株是指<strong>丧失了合成某种营养成分能力的菌株</strong>的菌株</li><li>受体菌和供体菌直接接触，而得到DNA片段的过程，称为<strong>接合</strong></li><li>携带核染色体基因的F因子称为<strong>F′菌株</strong></li></ol><h3 id="问答题-v7"><a class="header-anchor" href="#问答题-v7"></a>问答题</h3><h4 id="试比较普遍性转导和局限性转导的异同"><a class="header-anchor" href="#试比较普遍性转导和局限性转导的异同"></a>试比较普遍性转导和局限性转导的异同</h4><p>相同点：均以噬菌体为媒介，导致遗传物质的转移。</p><p>不同点：</p><table><thead><tr><th>项目</th><th>普遍性转导</th><th>局限性转导</th></tr></thead><tbody><tr><td>能够转导的基因</td><td>供体菌的几乎任何基因</td><td>供体菌的少数基因</td></tr><tr><td>噬菌体的位置</td><td>不整合到寄主染色体上</td><td>整合到寄主染色体上</td></tr><tr><td>转导噬菌体的获得</td><td>可通过裂解反应得到</td><td>只能通过诱导溶源菌得到</td></tr><tr><td>转导子的性质</td><td>属非溶源型，转导的物质，主要是供体菌的DNA</td><td>属缺陷溶源型，转导的物质，有供体的DNA和噬菌体DNA</td></tr></tbody></table><h4 id="试述用艾姆氏（Ames）法检测致癌剂的实验的原理和方法。"><a class="header-anchor" href="#试述用艾姆氏（Ames）法检测致癌剂的实验的原理和方法。"></a>试述用艾姆氏（Ames）法检测致癌剂的实验的原理和方法。</h4><p>艾姆氏试验是一种利用细菌营养缺陷型的回复突变来检测环境或食品中是否存在化学致癌剂的简便有效方法。此法测定潜在化学致癌物是基于这样的原理：鼠伤寒沙门氏菌的组氨酸营养缺陷型（his<sup>-</sup>）菌株在基本培养基[-]的平板上不能生长，如发生回复突变变成原养型（his<sup>+</sup>）后则能生长。</p><p>方法大致是在含待测可疑“三致”物例如黄曲霉毒素、二甲氨基偶氮苯（俗名“奶油黄”）、“反应停”等的试样中，加入鼠肝匀浆液，经一段时间保温后，吸入滤纸片中，然后将滤纸片放置于上述平板中央。</p><p>经培养后，出现3种情况：</p><ol><li>在平板上无大量菌落产生，说明试样中不含诱变剂；</li><li>在纸片周围有一抑制圈，其外周出现大量菌落，说明试样中有某种高浓度的诱变剂存在；</li><li>在纸片周围长有大量菌落，说明试样中有浓度适当的诱变剂存在。</li></ol><h4 id="列表比较四种基因重组方式的异同"><a class="header-anchor" href="#列表比较四种基因重组方式的异同"></a>列表比较四种基因重组方式的异同</h4><table><thead><tr><th>类型</th><th>受体/供体是否接触</th><th>DNA传递媒介</th><th>重组涉及DNA大小</th></tr></thead><tbody><tr><td>转化</td><td>否</td><td>无</td><td>一个或少数几个基因</td></tr><tr><td>转导</td><td>否</td><td>噬菌体</td><td>一个或少数几个基因</td></tr><tr><td>接合</td><td>是</td><td>F因子</td><td>部分染色体</td></tr><tr><td>原生质体融合</td><td>原生质体</td><td>原生质体</td><td>2个细胞的基因组</td></tr></tbody></table><h4 id="比较大肠杆菌的F-sup-sup-、F-sup-sup-、Hfr和F’菌株区别？并图示这四者之间的关系"><a class="header-anchor" href="#比较大肠杆菌的F-sup-sup-、F-sup-sup-、Hfr和F’菌株区别？并图示这四者之间的关系"></a>比较大肠杆菌的F<sup>+</sup>、F<sup>-</sup>、Hfr和F’菌株区别？并图示这四者之间的关系</h4><p>F<sup>+</sup> 菌株：F因子以游离状态存在，可独立于染色体进行自主复制，且细胞表面有相当数量的性菌毛。</p><p>F <sup>-</sup>菌株：不含F因子，无相当数量的性菌毛。</p><p>Hfr菌株：F因子整合在宿主染色体的一定部位，并与宿主染色体同步复制。</p><p>F′菌株：因为F因子整合到染色体上是一种可逆过程，当 F因子从 Hfr菌染色体上脱落时，会出现一定概率的错误基因交换，从而使 F因子带上宿主染色体的遗传因子，这时的 F因子称为F′因子。</p><p>图P222</p><h2 id="微生物的生态"><a class="header-anchor" href="#微生物的生态"></a>微生物的生态</h2><h3 id="填空题-v8"><a class="header-anchor" href="#填空题-v8"></a>填空题</h3><ol><li>微生物与生物环境间的最典型的5种相互关系为**<u>互生</u><strong>、</strong><u>共生</u><strong>、</strong><u>寄生</u><strong>、</strong><u>拮抗</u><strong>、</strong><u>捕食</u>**</li><li>从热泉中可以分离到**<u>嗜热微生物</u><strong>；从深海中可以分离到</strong><u>嗜冷微生物</u><strong>；从酸矿水中可分离到</strong><u>嗜酸微生物</u><strong>；从石灰水中可分离到</strong><u>嗜碱微生物</u><strong>；从盐湖中可分离到</strong><u>嗜盐微生物</u>**</li><li>微生物间共生关系最典型的例子是菌藻共生而形成的**<u>地衣</u><strong>。其中的菌类一般为真菌中的</strong><u>子囊菌</u><strong>，而藻类一般为</strong><u>绿藻</u><strong>或</strong><u>蓝藻（蓝细菌）</u><strong>。藻类可以为菌类提供</strong><u>有机养料</u><strong>而菌类则可为藻类提供</strong><u>矿质元素</u>**。</li><li>按耐热能力的不同，嗜热微生物可被分成5个不同类群：<strong><u>耐热菌</u></strong>、<strong><u>兼性嗜热菌</u></strong>、<strong><u>专性嗜热菌</u></strong>、<strong><u>极端嗜热菌</u></strong>、<strong><u>超嗜热菌</u></strong></li><li>清水中营养物浓度很低，故清水中微生物以**<u>化能自养</u><strong>微生物和</strong><u>光能自养</u>**微生物为主。</li><li>磷循环包括**<u>可溶性无机磷同化</u><strong>、</strong><u>不溶性磷溶解</u><strong>、</strong><u>有机磷的矿化</u>**</li><li>硝化作用是一个严格**<u>好氧</u><strong>的过程，反硝化作用则需要在</strong><u>厌氧</u>**条件下进行。</li><li>我国卫生部规定的饮用水的标准是：1mL自来水中的细菌（37°，培养24h）总数不可超过**<u>100</u><strong>个，而1000mL自来水中的大肠菌数则不能超过</strong><u>3</u>**个（37℃，48h）。</li><li>污水处理按程度可分为**<u>一级处理</u><strong>、</strong><u>二级处理</u><strong>、</strong><u>三级处理</u>**</li><li>水体的富营养化包括**<u>水华</u><strong>、</strong><u>赤潮</u>**</li></ol><h3 id="选择题-v8"><a class="header-anchor" href="#选择题-v8"></a>选择题</h3><ol><li>和豆科植物共生固氮的微生物是<strong>根瘤菌</strong></li><li>适用于生物冶金的微生物类群主要是<strong>嗜酸微生物</strong></li><li>在白蚁、蟑螂等昆虫肠道和反刍动物的瘤胃内有大量的细菌和原生动物， 这是动物和微生物之间一种<strong>共生关系</strong></li><li>酸矿水的形成是微生物对某些金属和非金属元素转化的结合。下列哪种循环与酸矿水形成有关?<strong>S循环</strong></li><li>酸菜腌制后可以保存相当长的时间,这是人们利用了微生物之间的<strong>拮抗关系</strong></li><li>悉生动物是指已人为接种上（<strong>种或数种已知的纯种微生物</strong>）的无菌动物或无菌植物</li><li>在制作酸菜或青贮饲料时，一般并不人工接种乳酸菌，这是人们利用了植物的<strong>叶面附生微生物</strong></li><li>弗来明发现青霉素是由于观察到在产青霉菌菌落周围不见有革兰阳性细菌 生长，而再深入研究创造奇迹的。这是人类首次观察到的微生物之间的<strong>专一性拮抗关系</strong></li><li>纤维分解菌与自生固氮菌之间由于前者为后者提供碳源，后者为前者提供 氮源而构成了<strong>互生关系</strong></li><li>冬虫夏草是由昆虫和真菌通过<strong>寄生关系</strong>形成的一种名贵中药</li></ol><h3 id="问答题-v8"><a class="header-anchor" href="#问答题-v8"></a>问答题</h3><h4 id="什么是正常菌群？试分析肠道正常菌群与人体的关系。"><a class="header-anchor" href="#什么是正常菌群？试分析肠道正常菌群与人体的关系。"></a>什么是正常菌群？试分析肠道正常菌群与人体的关系。</h4><p>正常菌群是生活在健康动物各部位、数量大，种类较稳定、一般能发挥有益作用的微生物种群。</p><p>肠道正常菌群对宿主有很多有益作用，包括排阻、抑制外来致病菌、提供维生素等营养，产生有助消化的酶，分解有毒或致癌物质，产生有机酸，促进肠道的蠕动，刺激机体的免疫系统并提高其免疫力以及存在一定程度的固氮作用等。</p><p>肠道正常菌群与人体的关系是一种十分重要又极其复杂的共生关系。正常菌群的微生态平衡是相对的、可变的和有条件的，正常菌群失调时会成为致病菌。</p><h4 id="什么是活性污泥？活性污泥法处理污水的过程非常类似于恒浊的连续培养，两者的不同点在哪里"><a class="header-anchor" href="#什么是活性污泥？活性污泥法处理污水的过程非常类似于恒浊的连续培养，两者的不同点在哪里"></a>什么是活性污泥？活性污泥法处理污水的过程非常类似于恒浊的连续培养，两者的不同点在哪里?</h4><p>活性污泥：一种由活细菌、原生动物和其他微生物群聚集在一起组成的凝絮团，在污水处理中具有很强的吸附、分解有机物或毒物的能力。</p><p>不同：活性污泥法是维持曝气池中活性污泥有相对稳定的浓度，实现的方法是回流二次沉淀池沉降的污泥。恒浊连续培养是调控培养器中流人、流出液的流速，使培养液中的微生物浓度基本恒定。前者靠回流维持污泥浓度恒定，后者则靠调控流速维持。</p><h2 id="传染与免疫"><a class="header-anchor" href="#传染与免疫"></a>传染与免疫</h2><h3 id="填空题-v9"><a class="header-anchor" href="#填空题-v9"></a>填空题</h3><ol><li>B细胞分化会产生两种细胞**<u>浆细胞</u>**、 <strong><u>记忆细胞</u></strong></li><li>人和哺乳动物的中枢免疫器官包括**<u>骨髓</u><strong>、</strong><u>胸腺</u>**</li><li>外周免疫器官主要是**<u>淋巴结</u><strong>、</strong><u>脾脏</u>**</li><li>粒细胞包括**<u>中性粒细胞</u><strong>、 <strong><u>嗜酸性粒细胞</u></strong> 、</strong><u>嗜碱性粒细胞</u>**</li><li>具有免疫原性和反应原性的抗原称为**<u>完全抗原</u><strong>具有</strong><u>反应原性(或免疫反应性)</u><strong>而没有</strong><u>免疫原性</u>**的抗原称为半抗原。</li><li>免疫球蛋白分为**<u>lgM</u>** 、<strong><u>IgG</u></strong>、<strong><u>lgE</u></strong>、 <strong><u>lgA</u></strong>、 **<u>IgD</u>**五类</li><li>细菌毒素可分为**<u>外毒素</u>**、 <strong><u>内毒素</u></strong></li><li>病原菌或病原体的侵袭力由**<u>吸附和侵入能力</u><strong>、</strong><u>繁殖和扩散能力</u><strong>、</strong><u>对宿主防御功能的抵抗能力</u>**三方面组成</li><li>阻挡微生物入侵的有效生理屏障有**<u>皮肤与粘膜</u>**、 <strong><u>血脑屏障</u></strong>、 <strong><u>血胎屏障</u></strong></li><li>炎症的五大主要症状表现为**<u>红</u><strong>、 <strong><u>肿</u></strong> 、</strong><u>热</u>**、 <strong><u>痛</u></strong>、 <strong><u>功能障碍</u></strong></li></ol><h3 id="选择题-v9"><a class="header-anchor" href="#选择题-v9"></a>选择题</h3><ol><li>浆细胞是<strong>产生抗体的细胞</strong></li><li>302医院著名专家姜素椿患上了“非典”，他根据自己掌握的科学知识，建议注射曾患过“非典”被治愈并且没有患其他传染病的人的血清，达到了预期目的，他本人也被治愈。他的这种做法是利用了患者血清中的<strong>抗体</strong></li><li>下列各项中通过接种疫苗能够预防的疾病是<strong>传染病</strong></li><li>以下(  )性质不是抗原必备的<ul><li><strong>必须有一个半抗原表位</strong></li><li>必须与被免疫动物种属不同</li><li>必须相对分子质量大结构复杂</li><li>必须可以被抗原递呈细胞降解</li></ul></li><li>抗体的抗原结合位点位于<strong>重链和轻链的V区</strong></li><li>器官移植的成功是人类医学的伟大成果，因为移植到人体内的器官很不易成活。根据现代免疫学的概念，植入器官的组织细胞相当于<strong>抗原</strong></li><li>抗体发生作用的特点是<strong>抗原消失后，抗体仍然存在于人体内</strong></li><li>早在10世纪，我国人民就已经采用将轻症天花病人的痘浆接种到健康人身上的方法，来预防天花。这里所说的痘浆和这种方法分别属于<strong>抗原</strong> 、<strong>特异性免疫</strong></li><li>自然的非特异免疫的一个重要组分是<strong>白细胞的吞噬</strong></li><li>能用于人工被动免疫的制品有<strong>抗毒素</strong>、 <strong>丙种球蛋白</strong></li></ol><h3 id="问答题-v9"><a class="header-anchor" href="#问答题-v9"></a>问答题</h3><h4 id="机体对细胞内毒素和细菌外毒素的免疫应答有何不同"><a class="header-anchor" href="#机体对细胞内毒素和细菌外毒素的免疫应答有何不同"></a>机体对细胞内毒素和细菌外毒素的免疫应答有何不同</h4><p>细菌外毒素是细菌分泌到胞外的分子，机体对其免疫应答以体液免疫为主，通过B细胞识别、活化并产生抗毒素抗体分子使之灭活。</p><p>细菌内毒素为细菌胞壁成分，机体对其免疫应答以对细菌的细胞免疫为主，包括吞噬杀伤、补体溶菌、以及T细胞介导的细胞免疫。</p><h4 id="表解宿主免疫力的三道防线"><a class="header-anchor" href="#表解宿主免疫力的三道防线"></a>表解宿主免疫力的三道防线</h4><p><img src="http://img.whl123456.top/image/5-1593058333493.png" alt=""></p><h4 id="试列表比较B细胞与T细胞的异同处"><a class="header-anchor" href="#试列表比较B细胞与T细胞的异同处"></a>试列表比较B细胞与T细胞的异同处</h4><table><thead><tr><th>比较项目</th><th>T细胞</th><th>B细胞</th></tr></thead><tbody><tr><td>来源</td><td>骨髓</td><td>骨髓</td></tr><tr><td>成熟部位</td><td>胸腺</td><td>骨髓</td></tr><tr><td>寿命</td><td>数月至数年</td><td>或长（数月至数年）或短（数天至数周）</td></tr><tr><td>运动性</td><td>强</td><td>差</td></tr><tr><td>表面标志</td><td>T细胞受体（TCR）</td><td>补体受体和Ig</td></tr><tr><td>增殖和分化</td><td>在抗原刺激后发生增殖</td><td>抗原刺激下增殖、分化为浆细胞、记忆细胞</td></tr><tr><td>产物</td><td>合成并释放各种淋巴因子</td><td>合成并释放抗体</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 生物学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微生物学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>植物生理学复习整理</title>
      <link href="2020/06/22/%E6%A4%8D%E7%89%A9%E7%94%9F%E7%90%86%E5%AD%A6/"/>
      <url>2020/06/22/%E6%A4%8D%E7%89%A9%E7%94%9F%E7%90%86%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<p>名词解释、简答</p><hr><h1>植物生理学</h1><h2 id="植物的水分代谢"><a class="header-anchor" href="#植物的水分代谢"></a>植物的水分代谢</h2><h3 id="名词解释"><a class="header-anchor" href="#名词解释"></a>名词解释</h3><p><strong>水势</strong>($\psi_{\mathrm{w}}$)：每偏摩尔体积水的化学势差。符号：$\psi_{\mathrm{w}}$。</p><p><strong>渗透势</strong>($\psi_\pi$)：由于溶液中溶质颗粒的存在而引起的水势降低值。用负值表示。亦称溶质势（$\psi_\pi$）。</p><p><strong>衬质势</strong>($\psi_m$)：细胞胶体物质亲水性和毛细管对自由水束缚而引起的水势降低值，以负值表示。符号$\psi_m$ 。</p><p><strong>蒸腾作用</strong>：水分以气体状态通过植物体表面从体内散失到体外的现象。</p><p><strong>根压</strong>：植物根部的生理活动使液流从根部上升的压力。</p><p><strong>蒸腾拉力</strong>：由于蒸腾作用产主的一系列水势梯度使导管中水分上升的力量。</p><p><strong>蒸腾速率</strong>：又称蒸腾强度，指植物在单位时间内，单位面积通过蒸腾作用而散失的水分量。（g/dm<sup>2</sup>·h）</p><p><strong>内聚力学说</strong>：又称蒸腾流-内聚力-张力学说。即以水分的内聚力解释水分沿导管上升原因的学说。</p><h3 id="问答题"><a class="header-anchor" href="#问答题"></a>问答题</h3><h4 id="简述水分的植物生理生态作用"><a class="header-anchor" href="#简述水分的植物生理生态作用"></a>简述水分的植物生理生态作用</h4><ul><li>水分能便植物保持固有的姿态</li><li>水分是重要代谢过程的反应物质和产物</li><li>水是细胞原生质的主要组成成分</li><li>细胞分裂及伸长都需要水分</li><li>水分是植物对物质吸收和运输及生化反应的一种良好溶剂</li><li>可以通过水的理化特性以调节植物周围的大气湿度、温度等。对维持植物体温稳定和降低体温也有重要作用</li></ul><h4 id="利用质壁分离现象可以解决哪些问题"><a class="header-anchor" href="#利用质壁分离现象可以解决哪些问题"></a>利用质壁分离现象可以解决哪些问题</h4><ul><li>说明原生质层是半透膜。</li><li>判断细胞死活。只有活细胞的原生质层才是半透膜，才有质壁分离现象，如细胞死亡，则不能产主质壁分离现象。</li><li>测定细胞液的渗透势</li></ul><h4 id="蒸腾作用有什么生理意义"><a class="header-anchor" href="#蒸腾作用有什么生理意义"></a>蒸腾作用有什么生理意义</h4><ul><li>是植物对水分吸收和运输的主要动力</li><li>促进植物对矿物质和有机物的吸收及其在植物体内的转运</li><li>能够降低叶片的温度，以免灼伤</li></ul><h4 id="气孔开闭机理的假说有哪些？请简述之"><a class="header-anchor" href="#气孔开闭机理的假说有哪些？请简述之"></a>气孔开闭机理的假说有哪些？请简述之</h4><ol><li>淀粉–糖变化学说：在光照下保卫细胞进行光合作用合成可溶性糖。另外由于光合作用消耗CO<sub>2</sub>，使保卫细胞pH值升高，淀粉磷酸化酶水解细胞中淀粉形成可溶性糖，细胞水势下降，当保卫细胞水势低于周围的细胞水势时，便吸水迫使气孔张开，在暗中光合作用停止，情况与上述相反，气孔关闭。</li><li>无机离子吸收学说：在光照下，保卫细胞质膜上具有光活化H<sup>+</sup>泵ATP酶，分解光合磷酸化产生的ATP并将H<sup>+</sup>分泌到细胞壁，同时将外面的K<sup>+</sup>吸收到细胞中来，Cl<sup>-</sup>也伴随着K<sup>+</sup>进入，以保证保卫细胞的电中性，保卫细胞中积累较多的K<sup>+</sup>和，降低水势，气孔就张开，反之，则气孔关闭。</li><li>苹果酸生成学说。在光下保卫细胞内的CO<sub>2</sub>被利用，pH值就上升，剩余的CO<sub>2</sub>就转变成重碳酸盐（HCO<sub>3</sub><sup>-</sup>），淀粉通过糖酵解作用产生的磷酸烯醇式丙酮酸在PEP羧化酶作用下与HCO<sub>3</sub><sup>-</sup>作用形成草酰乙酸，然后还原成苹果酸，可作为渗透物降低水势，气孔张开，反之关闭。</li></ol><h2 id="植物的矿质营养"><a class="header-anchor" href="#植物的矿质营养"></a>植物的矿质营养</h2><h3 id="名词解释-v2"><a class="header-anchor" href="#名词解释-v2"></a>名词解释</h3><p><strong>矿质营养</strong>: 是指植物对氮和矿质元素的吸收、运输与同化的过程。</p><p><strong>灰分元素</strong>：亦称矿质元素，将干燥植物材料燃烧后，剩余一些不能挥发的物质称为灰分元素。</p><p><strong>单盐毒害和离子拮抗</strong>：单盐毒害是指溶液中因只有一种金属离子而对植物之毒害作用的现象；在发生单盐毒害的溶液中加入少量其他金属离子，即能减弱或消除这种单盐毒害，离子间的这种作用称为离子拮抗。</p><p><strong>平衡溶液</strong>：在含有适当比例的多种盐溶液中，各种离子的毒害作用被消除，植物可以正常生长发育，这种溶液称为平衡溶液。</p><p><strong>诱导酶</strong>：又称适应酶，指植物体内本来不含有，但在特定外来物质的诱导下可以生成的酶。如硝酸还原酶可为NO<sub>3</sub><sup>-</sup>所诱导。</p><p><strong>生物固氮</strong>：某些微生物把空气中游离氮固定转化为含氮化合物的过程。</p><h3 id="问答题-v2"><a class="header-anchor" href="#问答题-v2"></a>问答题</h3><h4 id="植物必需的矿质元素要具备哪些条件"><a class="header-anchor" href="#植物必需的矿质元素要具备哪些条件"></a>植物必需的矿质元素要具备哪些条件</h4><ul><li>缺乏该元素植物生育发生障碍不能完成生活史。</li><li>除去该元素则表现专一的缺乏症，这种缺乏症是可以预防和恢复的。</li><li>该元素在植物营养生理上表现直接的效果而不是间接的。</li></ul><h4 id="为什么把氮称为生命元素"><a class="header-anchor" href="#为什么把氮称为生命元素"></a>为什么把氮称为生命元素</h4><p>氮在植物生命活动中占据重要地位，它是植物体内许多重要化合物的成分，如核酸（DNA、RNA）、蛋白质（包括酶）、磷脂、叶绿素。光敏色素、维生素B、IAA、CTK、生物碱等都含有氮。</p><p>同时氮也是参与物质代谢和能量代谢的ADP、ATP、CoA、CoQ、FAD、FMN、NAD<sup>+</sup>、NADP<sup>+</sup>、铁卟琳等物质的组分。</p><p>上述物质有些是生物膜、细胞质、细胞核的结构物质，有些是调节生命活动的生理活性物质。</p><p>因此，氮是建造植物体的结构物质，也是植物体进行能量代谢、物质代谢及各种生理活动所必需的起重要作用的生命元素。</p><h4 id="植物细胞吸收矿质元素的方式有哪些"><a class="header-anchor" href="#植物细胞吸收矿质元素的方式有哪些"></a>植物细胞吸收矿质元素的方式有哪些</h4><ul><li>被动吸收：包括简单扩散、杜南平衡。不消耗代谢能。</li><li>主动吸收：有载体和质子泵参与，需消耗代谢能。</li><li>胞饮作用：是一种非选择性吸收方式。</li></ul><h4 id="为什么土壤温度过低，植物吸收矿质元素的速率下降"><a class="header-anchor" href="#为什么土壤温度过低，植物吸收矿质元素的速率下降"></a>为什么土壤温度过低，植物吸收矿质元素的速率下降</h4><ul><li>因为温度低时代谢弱，能量不足，主动吸收慢</li><li>胞质粘性增大，离子进入困难。其中以对钾和硅酸的吸收影响最大。</li></ul><h4 id="白天和夜晚硝酸盐还原速度是否相同？为什么"><a class="header-anchor" href="#白天和夜晚硝酸盐还原速度是否相同？为什么"></a>白天和夜晚硝酸盐还原速度是否相同？为什么?</h4><p>硝酸盐在昼夜的还原速度不同，白天还原速度显著较夜晚快，这是因为白天光合作用产生的还原力及磷酸丙糖能促进硝酸盐的还原。</p><h4 id="合理施肥增产的原因是什么"><a class="header-anchor" href="#合理施肥增产的原因是什么"></a>合理施肥增产的原因是什么</h4><p>合理施肥增产的实质在于改善光合性能（增大光合面积，提高光合能力，延长光合时间，有利光合产量分配利用等），通过光合过程形成更多的有机物获得高产。</p><h4 id="根外施肥有哪些优点"><a class="header-anchor" href="#根外施肥有哪些优点"></a>根外施肥有哪些优点?</h4><ul><li>作物在生育后期根部吸肥能力衰退时或营养临界期时，可根外施肥补充营养 。</li><li>某些肥料易被土壤固定而根外施肥无此毛病，且用量少</li><li>补充植物缺乏的微量元素，用量省、见效快。</li></ul><h2 id="植物的光合作用"><a class="header-anchor" href="#植物的光合作用"></a>植物的光合作用</h2><h3 id="名词解释-v3"><a class="header-anchor" href="#名词解释-v3"></a>名词解释</h3><p><strong>光合色素</strong>：指植物体内含有的具有吸收光能并将其用于光合作用的色素，包括叶绿素、类胡萝卜素、藻胆素等。</p><p><strong>原初反应</strong>：包括光能的吸收、传递以及光能向电能的转变，即由光所引起的氧化还原过程。</p><p><strong>红降现象</strong>：当光波大于685nm时，虽然仍被叶绿素大量吸收，但量子效率急剧下降，这种现象被称为红降现象。</p><p><strong>爱默生效应</strong>：如果在长波红光（大于685nm）照射时，再加上波长较短的红光（650nm），则量子产额大增，比分别单独用两种波长的光照射时的总和还要高。</p><p><strong>光合链</strong>：即光合作用中的电子传递。它包括质体醌、细胞色素、质体蓝素、铁氧还蛋白等许多电子传递体，当然还包括光系统Ⅰ和光系统Ⅱ的作用中心。其作用是水的光氧化所产生的电子依次传递，最后传递给NADP<sup>+</sup>。光合链也称Z链。</p><p><strong>光合作用单位</strong>：结合在类囊体膜上，能进行光合作用的最小结构单位。</p><p><strong>作用中心色素</strong>：指具有光化学活性的少数特殊状态的叶绿素a分子。</p><p><strong>聚光色素</strong>：指没有光化学活性，只能吸收光能并将其传递给作用中心色素的色素分子。聚光色素又叫天线色素。</p><p><strong>光能利用率</strong>：单位面积上的植物光合作用所累积的有机物所含的能量，占照射在相同面积地面上的日光能量的百分比。</p><p><strong>光合磷酸化</strong>：叶绿体（或载色体）在光下把无机磷和ADP转化为ATP，并形成高能磷酸键的过程。</p><p><strong>光呼吸</strong>：植物的绿色细胞在光照下吸收氧气，放出CO<sub>2</sub>的过程。光呼吸的主要代谢途径就是乙醇酸的氧化，乙醇酸来源于RuBP的氧化。光呼吸之所以需要光就是因为RuBP的再生需要光。</p><p><strong>光补偿点</strong>：同一叶子在同一时间内，光合过程中吸收的CO<sub>2</sub>和呼吸过程中放出的CO<sub>2</sub>等量时的光照强度。</p><p><strong>CO<sub>2</sub>补偿点</strong>：当光合吸收的CO<sub>2</sub>量与呼吸释放的CO<sub>2</sub>量相等时，外界的CO<sub>2</sub>浓度。</p><p><strong>光饱和点</strong>：增加光照强度，光合速率不再增加时的光照强度。</p><h3 id="问答题-v3"><a class="header-anchor" href="#问答题-v3"></a>问答题</h3><h4 id="植物的叶片为什么是绿色的？秋天树叶为什么会呈现黄色或红色？"><a class="header-anchor" href="#植物的叶片为什么是绿色的？秋天树叶为什么会呈现黄色或红色？"></a>植物的叶片为什么是绿色的？秋天树叶为什么会呈现黄色或红色？</h4><p>光合色素主要吸收红光和蓝紫光，对绿光吸收很少，所以植物的时片呈绿色。</p><p>秋天树叶变黄是由于低温抑制了叶绿素的生物合成，已形成的叶绿素也被分解破坏，而类胡萝卜素比较稳定，所以叶片呈现黄色。</p><p>至于红叶，是因为秋天降温，体内积累较多的糖分以适应寒冷，体内可溶性糖多了，就形成较多的花色素，叶子就呈红色。</p><h4 id="提高植物光能利用率的途径和措施有哪些？"><a class="header-anchor" href="#提高植物光能利用率的途径和措施有哪些？"></a>提高植物光能利用率的途径和措施有哪些？</h4><ul><li>增加光合面积：①合理密植；②改善株型。</li><li>延长光合时间：①提高复种指数；②延长生育期 ③补充人工光照。</li><li>提高光合速率：①增加田间CO<sub>2</sub> 浓度；②降低光呼吸。</li></ul><h4 id="光合作用的全过程大致分为哪三大步骤？"><a class="header-anchor" href="#光合作用的全过程大致分为哪三大步骤？"></a>光合作用的全过程大致分为哪三大步骤？</h4><ul><li>光能的吸收传递和转变为电能过程。</li><li>电能转变为活跃的化学能过程。</li><li>活跃的化学能转变为稳定的化学能过程。</li></ul><h4 id="C-sub-3-sub-途径是谁发现的？分哪几个阶段？每个阶段的作用是什么？"><a class="header-anchor" href="#C-sub-3-sub-途径是谁发现的？分哪几个阶段？每个阶段的作用是什么？"></a>C<sub>3</sub>途径是谁发现的？分哪几个阶段？每个阶段的作用是什么？</h4><p>C<sub>3</sub>途径是卡尔文（Calvin）等人发现的。可分为三个阶段：</p><ul><li>羧化阶段，CO<sub>2</sub>被固定，生成3-磷酸甘油酸，为最初产物；</li><li>还原阶段：利用同化力（NADPH、ATP）将3-磷酸甘油酸还原成3-磷酸甘油醛——光合作用中的第一个三碳糖；</li><li>更新阶段，光合碳循环中形成的3-磷酸甘油醛，经过一系列的转变，再重新形成RuBP的过程。</li></ul><h4 id="C-sub-3-sub-途径的调节方式有哪几个方面？"><a class="header-anchor" href="#C-sub-3-sub-途径的调节方式有哪几个方面？"></a>C<sub>3</sub>途径的调节方式有哪几个方面？</h4><ol><li>酶活化调节：通过改变叶的内部环境，间接地影响酶的活性。如间质中pH的升高，Mg<sup>2+</sup>浓度升高，可激活RuBPCase和Ru5P激酶。</li><li>质量作用的调节，代谢物的浓度可以影响反应的方向和速率。</li><li>转运作用的调节，叶绿体内的光合最初产物——磷酸丙糖，从叶绿体运到细胞质的数量，受细胞质里的Pi数量所控制。Pi充足，进入叶绿体内多，就有利于叶绿体内磷酸丙糖的输出，光合速率就会加快。</li></ol><h4 id="如何解释C-sub-4-sub-植物比C-sub-3-sub-植物的光呼吸低？"><a class="header-anchor" href="#如何解释C-sub-4-sub-植物比C-sub-3-sub-植物的光呼吸低？"></a>如何解释C<sub>4</sub>植物比C<sub>3</sub>植物的光呼吸低？</h4><p>C<sub>4</sub>植物PEP羧化酶对CO<sub>2</sub>亲和力高，固定CO<sub>2</sub>的能力强，在叶肉细胞形成C<sub>4</sub>二羧酸之后，再转运到维管束鞘细胞，脱羧后放出CO<sub>2</sub>，就起到了CO<sub>2</sub> 泵的作用，增加了CO<sub>2</sub>浓度，提高了RuBP羧化酶的活性，有利于CO<sub>2</sub> 的固定和还原，不利于乙醇酸形成，不利于光呼吸进行，所以C<sub>4</sub>植物光呼吸测定值很低。</p><p>而C<sub>3</sub>植物，在叶肉细胞内固定CO<sub>2</sub>，叶肉细胞的CO<sub>2</sub>/O<sub>2</sub>的比值较低，此时，RuBP加氧酶活性增强，有利于光呼吸的进行，而且C<sub>3</sub>植物中RuBP羧化酶对CO<sub>2</sub>亲和力低，光呼吸释放的CO<sub>2</sub>，不易被重新固定。</p><h4 id="如何评价光呼吸的生理功能？"><a class="header-anchor" href="#如何评价光呼吸的生理功能？"></a>如何评价光呼吸的生理功能？</h4><p>光呼吸是具有一定的生理功能的，也有害处：</p><ul><li>有害的方面：减少了光合产物的形成和累积，不仅不能贮备能量，还要消耗大量能量。</li><li>有益之处：<ul><li>消除了乙醇酸的累积所造成的毒害。</li><li>此过程可以作为丙糖和氨基酸的补充途径。</li><li>防止高光强对叶绿体的破坏，消除了过剩的同化力，保护了光合作用正常进行。</li><li>消耗了O<sub>2</sub>之后，降低了O<sub>2</sub>/CO<sub>2</sub>之比，可提高RuBP羧化酶的活性，有利于碳素同化作用的进行。</li></ul></li></ul><h4 id="简述CAM植物同化CO-sub-2-sub-的特点。"><a class="header-anchor" href="#简述CAM植物同化CO-sub-2-sub-的特点。"></a>简述CAM植物同化CO<sub>2</sub>的特点。</h4><p>这类植物晚上气孔开放，吸进CO<sub>2</sub>，在PEP羧化酶作用下与PEP结合形成苹果酸累积于液泡中。</p><p>白天气孔关闭，液泡中的苹果酸便运到细胞质，放出CO<sub>2</sub>参与卡尔文循环形成淀粉等。</p><h4 id="作物为什么会出现“午休”现象？"><a class="header-anchor" href="#作物为什么会出现“午休”现象？"></a>作物为什么会出现“午休”现象？</h4><ul><li>水分在中午供给不上，气孔关闭；</li><li>CO<sub>2</sub>供应不足；</li><li>光合产物淀粉等来不及分解运走，累积在叶肉细胞中，阻碍细胞内CO<sub>2</sub>的运输；</li><li>生理钟调控。</li></ul><h2 id="植物的呼吸作用"><a class="header-anchor" href="#植物的呼吸作用"></a>植物的呼吸作用</h2><h3 id="名词解释-v4"><a class="header-anchor" href="#名词解释-v4"></a>名词解释</h3><p><strong>末端氧化酶</strong>：是指处于生物氧化作用一系列反应的最末端，将底物脱下的氢或电子传递给氧，并形成H<sub>2</sub>O或H<sub>2</sub>O<sub>2</sub>的氧化酶类。</p><p><strong>抗氰呼吸</strong>：某些植物组织对氰化物不敏感的那部分呼吸。即在有氰化物存在的条件下仍有一定的呼吸作用。</p><p><strong>呼吸商</strong>：又称呼吸系数，简称RQ，是指在一定时间内，植物组织释放CO<sub>2</sub>的摩尔数与吸收氧的摩尔数之比。</p><p><strong>呼吸速率</strong>：以单位鲜重、干重或单位面积在单位时间内所放出的CO<sub>2</sub>的重量（或体积）或所吸收O<sub>2</sub>的重量（或体积）来表示。</p><p><strong>糖酵解</strong>：是指在细胞质内所发生的、由葡萄糖分解为丙酮酸的过程。</p><p><strong>三羧酸循环</strong>：丙酮酸在有氧条件下，通过一个包括三羧酸和二羧酸的循环而逐步氧化分解生成CO<sub>2</sub>的过程。又称为柠檬酸环或Krebs环，简称TCA循环。</p><p><strong>戊糖磷酸途径</strong>：简称PPP或HMP。是指在细胞质内进行的一种葡萄糖直接氧化降解的酶促反应过程。</p><p><strong>呼吸链</strong>：呼吸代谢中间产物随电子和质子，沿着一系列有顺序的电子传递体组成的电子传递途径，传递到分子氧的总轨道。</p><p><strong>氧化磷酸化</strong>：是指呼吸链上的氧化过程，伴随着ADP被磷酸化为ATP的作用。</p><h3 id="问答题-v4"><a class="header-anchor" href="#问答题-v4"></a>问答题</h3><h4 id="呼吸作用多条路线论点的内容和意义如何？"><a class="header-anchor" href="#呼吸作用多条路线论点的内容和意义如何？"></a>呼吸作用多条路线论点的内容和意义如何？</h4><p>植物呼吸代谢多条路线论点是汤佩松先生提出来的，其内容是是：</p><ul><li>呼吸化学途径多样性（EMP、PPP、TCA等）；</li><li>呼吸链电子传递系统的多样性（电子传递主路，几条支路，如抗氰支路）；</li><li>末端氧化酶系统的多样性（细胞色素氧化酶，酚氧化酶，抗坏血酸氧化酶，乙醇酸氧化酶和交替氧化酶）。</li></ul><p>这些多样性，是植物在长期进化过程中对不断变化的外界环境的一种适应性表现，其要点是呼吸代谢（对生理功能）的控制和被控制（酶活性）过程。而且认为该过程受到生长发育和不同环境条件的影响，这个论点，为呼吸代谢研究指出了努力方向。</p><h4 id="戊糖磷酸途径在植物呼吸代谢中具有什么生理意义"><a class="header-anchor" href="#戊糖磷酸途径在植物呼吸代谢中具有什么生理意义"></a>戊糖磷酸途径在植物呼吸代谢中具有什么生理意义</h4><p>戊糖磷酸途径中形成的NADPH是细胞内必需NADPH才能进行生物合成反应的主要来源，如脂肪合成。其中间产物核糖和磷酸又是合成核苷酸的原料，植物感病时戊糖磷酸途径所占比例上升，因此，戊糖磷酸途径在植物呼吸代谢中占有特殊的地位。</p><h4 id="呼吸作用糖的分解代谢途径有几种？在细胞的什么部位进行？"><a class="header-anchor" href="#呼吸作用糖的分解代谢途径有几种？在细胞的什么部位进行？"></a>呼吸作用糖的分解代谢途径有几种？在细胞的什么部位进行？</h4><p>有EMP、TCA和PPP三种。EMP和PPP在细胞质中进行的。TCA是在线粒体中进行的。</p><h4 id="什么叫末端氧化酶？主要有哪几种？"><a class="header-anchor" href="#什么叫末端氧化酶？主要有哪几种？"></a>什么叫末端氧化酶？主要有哪几种？</h4><p>处于生物氧化作用一系列反应的最末端，将底物脱下的氢或电子传递给氧，并形成H<sub>2</sub>O或凡H<sub>2</sub>O<sub>2</sub>的氧化酶都称为末端氧化酶。如：细胞色素氧化酶、交替氧化酶（抗氰氧化酶）、酚氧化酶、抗坏血酸氧化酶、黄素氧化酶等，也有把过氧化氢物和过氧化物酶列入其中。</p><h4 id="抗氰呼吸有何特点？"><a class="header-anchor" href="#抗氰呼吸有何特点？"></a>抗氰呼吸有何特点？</h4><p>已知抗氰呼吸电子传递的途径不通过细胞色素系统，而是由泛醌传递给一个受体（X），再由X直接传递给氧，这样就越过了磷酸化部位Ⅱ、Ⅲ，对氰化物不敏，且P/O比为1或＜1。因此，在进行抗氰呼吸时有大量热能释放。</p><p>抗氰呼吸的强弱除了与植物种类有关外，也与发育状况、外界条件有关。且抗氰呼吸在正常途径受阻时得到加强，所以抗氰呼吸是一种与正常呼吸途径交替进行的适应性过程。</p><h4 id="粮食贮藏时为什么要降低呼吸速率？"><a class="header-anchor" href="#粮食贮藏时为什么要降低呼吸速率？"></a>粮食贮藏时为什么要降低呼吸速率？</h4><ul><li>因为呼吸速率高会大量消耗有机物；</li><li>呼吸放出的水分又会使粮堆湿度增大，粮食“出汗”，呼吸加强；</li><li>呼吸放出的热量又使粮温增高，反过来又促进呼吸增强，同时高温高湿微生物迅速繁殖，最后导致粮食变质。</li></ul><h4 id="长时间无氧呼吸植物为什么会死亡？"><a class="header-anchor" href="#长时间无氧呼吸植物为什么会死亡？"></a>长时间无氧呼吸植物为什么会死亡？</h4><ul><li>无氧呼吸产生酒精，酒精使细胞质的蛋白质变性。</li><li>氧化1mol葡萄糖产生的能量少。要维持正常的生理需要就要消耗更多的有机物，这样体内养分耗损过多。</li><li>没有丙酮酸的有氧分解过程，缺少合成其他物质的原料。</li></ul><h4 id="植物组织受到损伤时呼吸速率为何加快？"><a class="header-anchor" href="#植物组织受到损伤时呼吸速率为何加快？"></a>植物组织受到损伤时呼吸速率为何加快？</h4><ul><li>一是原来氧化酶与其底物在结构上是隔开的，损伤使原来的间隔破坏，酚类化合物迅速被氧化。</li><li>二是损伤使某些细胞转变为分生状态，形成愈伤组织以修复伤处，这些生长旺盛的细胞比原来的休眠或成熟组织的呼吸速率要快得多。</li></ul><h4 id="低温导致烂秧的原因是什么？"><a class="header-anchor" href="#低温导致烂秧的原因是什么？"></a>低温导致烂秧的原因是什么？</h4><p>是因为低温破坏了线粒体的结构，呼吸“空转”，缺乏能量引起代谢紊乱的缘故。</p><h4 id="早稻浸种催芽时用温水淋种和翻堆的目的是什么？"><a class="header-anchor" href="#早稻浸种催芽时用温水淋种和翻堆的目的是什么？"></a>早稻浸种催芽时用温水淋种和翻堆的目的是什么？</h4><p>目的就是控制温度和通气，使呼吸作用顺利进行。否则谷堆中部温度过高就会引起“烧芽”现象。</p><h2 id="植物生长物质"><a class="header-anchor" href="#植物生长物质"></a>植物生长物质</h2><h3 id="名词解释-v5"><a class="header-anchor" href="#名词解释-v5"></a>名词解释</h3><p><strong>植物生长物质</strong>：是一些调节植物生长发育的物质。包括植物激素和植物生长调节剂。</p><p><strong>植物激素</strong>：指一些在植物体内合成，并从产生之处运送到别处，对生长发育起显著作用的微量有机物。</p><p><strong>植物生长调节剂</strong>：指一些具有植物激素活性的人工合成的物质。</p><p><strong>极性运输</strong>：只能从植物形态学的上端向下端运输，而不能倒过来运输。</p><p><strong>三重反应</strong>：乙烯可抑制黄化豌豆幼苗上胚轴的伸长生长；促进其加粗生长；地上部分失去负向地性生长（偏上生长）。</p><p><strong>生长抑制剂</strong>：这类物质主要作用于顶端分生组织区，干扰顶端细胞分裂，引起茎伸长的停顿和顶端优势破坏。其作用不能被赤霉素所恢复。</p><p><strong>生长延缓剂</strong>：抑制节间伸长而不破坏顶芽的化合物。其作用可被GA所恢复。</p><h3 id="问答题-v5"><a class="header-anchor" href="#问答题-v5"></a>问答题</h3><h4 id="乙烯促进果实成熟的原因何在？"><a class="header-anchor" href="#乙烯促进果实成熟的原因何在？"></a>乙烯促进果实成熟的原因何在？</h4><p>乙烯能增加细胞膜的透性，促使呼吸作用加强某些肉质果实出现呼吸骤变，因而引起果实内的各种有机物质发生急剧变化，使果实甜度增加，酸味减少，涩味消失，香味产主，色泽变艳，果实由硬变软，达到完全成熟。</p><h4 id="生长素与赤霉素之生理作用方面的相互关系如何？"><a class="header-anchor" href="#生长素与赤霉素之生理作用方面的相互关系如何？"></a>生长素与赤霉素之生理作用方面的相互关系如何？</h4><p>生长素与赤霉素之间存在相辅相成作用。</p><ul><li>GA有抑制IAA氧化酶活性的作用防止IAA的氧化；</li><li>GA能增加蛋白酶的活性，促进蛋白质分解，色氨酸数量增多，有利于IAA的生物合成</li><li>GA促进生长素由束缚型转变为自由型。</li></ul><h4 id="赤霉素在生产上的应用主要有哪些方面？"><a class="header-anchor" href="#赤霉素在生产上的应用主要有哪些方面？"></a>赤霉素在生产上的应用主要有哪些方面？</h4><ul><li>促进麦芽糖化，GA诱导α-淀粉酶的形成这一发现己被应用到啤酒生产中。</li><li>促进营养生长，如在水稻“三系”的制种过程中，切花生产上等都有应用</li><li>防止脱落，促进单性结实</li><li>打破休眠。</li></ul><h4 id="人们认为植物的休眠与生长是由哪两种激素调节的？如何调节？"><a class="header-anchor" href="#人们认为植物的休眠与生长是由哪两种激素调节的？如何调节？"></a>人们认为植物的休眠与生长是由哪两种激素调节的？如何调节？</h4><p>植物的生长和休眠是由赤霉素和脱落酸两种激素调节的。它们的合成前体都是甲瓦龙酸，甲瓦龙酸在长日照条件下形成赤霉素，短日照条件下形成脱落酸，因此，夏季日照长，产生赤霉素促进植物生长；而冬季来临前，日照短，产生脱落酸使芽进入休眠。</p><h4 id="生长抑制剂和生长延缓剂抑制生长的作用方式有何不同？"><a class="header-anchor" href="#生长抑制剂和生长延缓剂抑制生长的作用方式有何不同？"></a>生长抑制剂和生长延缓剂抑制生长的作用方式有何不同？</h4><p>生长抑制剂是抑制顶端分生组织生长，丧失顶端优势，使植株形态发生很大变化，外施GA不能逆转达种抑制反应</p><p>生长延缓剂是抑制茎部近顶端分生组织的细胞伸长，节间缩短，叶数和节数不变，株型紧凑矮小，生殖器官不受影响或影响不大，外施GA可逆转其抑制效应。</p><h2 id="植物的生长生理"><a class="header-anchor" href="#植物的生长生理"></a>植物的生长生理</h2><h3 id="名词解释-v6"><a class="header-anchor" href="#名词解释-v6"></a>名词解释</h3><p><strong>生长</strong>：细胞、器官或有机体的数目、大小与重量的不可逆增加，即发育过程中量的变化称为生长。</p><p><strong>分化</strong>：来自同一分子或遗传上同质的细胞转变为形态上、机能上、化学构成上异质的细胞称为分化。</p><p><strong>发育</strong>：在植物生命周期过程中，植物发生大小、形态、结构、功能上的变化，称为发育，发育包括生长与分化两个方面，即生长与分化贯穿在整个发育过程中。</p><p><strong>种子寿命</strong>：从种子成熟到失去发芽能力的时间。</p><p><strong>种子活力</strong>：种子在田间条件（非理想条件）下萌发的速度、整齐度及幼苗健壮生长的潜在能力，它包括种子萌发成苗和对不良环境的忍受力两个方面。种子活力与种子的大小、成熟度有关，也与贮藏条件和贮藏时间有关。</p><p><strong>温周期现象</strong>：植物对昼夜温度周期性变化的反应。</p><p><strong>顶端优势</strong>：植物顶端在生长上占有优势的现象。</p><p><strong>细胞全能性</strong>：指植物体的每个细胞携带一个完整基因组，并具有发育成完整植株的潜在能力。</p><p><strong>光形态建成</strong>：光控制植物生长、发育和分化的过程。</p><p><strong>光敏色素</strong>：植物体内存在的一种吸收红光-远红光可逆转换的光受体（色素蛋白质）。</p><p><strong>生理钟</strong>：又称生物钟。指植物内生节奏调节的近似24小时的周期性变化节律。</p><p><strong>生长大周期</strong>：植物在不同生育时期的生长速率表现出慢-快-慢的变化规律，呈现“S”型的生长曲线，这个过程称生长大周期。</p><p><strong>向性运动</strong>：指外界对植物单向刺激所引起的定向生长运动。</p><p><strong>感性运动</strong>：指外界对植物不定向刺激所引起的运动。</p><h3 id="问答题-v6"><a class="header-anchor" href="#问答题-v6"></a>问答题</h3><h4 id="种子萌发时，有机物质发生哪些生理生化变化？"><a class="header-anchor" href="#种子萌发时，有机物质发生哪些生理生化变化？"></a>种子萌发时，有机物质发生哪些生理生化变化？</h4><ul><li>淀粉的转化：淀粉在淀粉酶、麦芽糖酶或淀粉磷酸化酶作用下转变成葡萄糖（或磷酸葡萄糖）。</li><li>脂肪的转化：脂肪在脂肪酶作用下转变为甘油和脂肪酸，再进一步转化为糖。</li><li>蛋白质的转化：胚乳或子叶内贮藏的蛋白质在蛋白酶和肽酶的催化下，分解为氨基酸。</li></ul><h4 id="水稻种子萌发时，表现出“干长根，湿长芽”现象的原因何在？"><a class="header-anchor" href="#水稻种子萌发时，表现出“干长根，湿长芽”现象的原因何在？"></a>水稻种子萌发时，表现出“干长根，湿长芽”现象的原因何在？</h4><p>“干长根，湿长芽”现象是由于根和胚芽鞘的生长所要求的含氧量不同所致。</p><p>根的生长，既有细胞的伸长和扩大，也包括细胞分裂，而细胞分裂需要有氧呼吸提供能量和重要的中间产物。因而水多、氧不足时，根的生长受到抑制。但是胚芽鞘的生长，主要是细胞的伸长与扩大，在水层中，水分供应充足，故而芽生长较快。</p><p>此外，“干根湿芽”还与生长素含量有关。在水少供氧充足时，IAA氧化酶活性升高，使IAA含量降低，以至胚芽鞘细胞伸长和扩大受抑制，根生长受影响小。而在有水层的条件下，氧气少，IAA氧化酶活性降低，IAA含量升高，从而促进胚芽鞘细胞的伸长，并且IAA运输到根部，因根对IAA比较敏感，使根的生长受到抑制。</p><p>还有人认为，胚芽鞘呼吸酶以细胞色素氧化酶为主，与O<sub>2</sub>亲和力高，幼根则以抗氰氧化酶为主，与O<sub>2</sub>亲和力较低，因而在水多时，胚芽鞘生长快于幼根。</p><h4 id="高山上的树木为什么比平地生长的矮小？"><a class="header-anchor" href="#高山上的树木为什么比平地生长的矮小？"></a>高山上的树木为什么比平地生长的矮小？</h4><ul><li>高山上水分较少，土壤也较瘠薄，肥力较低，气温也较低，且风力较大，这些因素都不利于树木纵向生长；</li><li>高山顶上因云雾较少，空气中灰尘较少，所以光照较强，紫外光也较多，由于强光特别是紫外光抑制植物生长，因而高山上的树木生长缓慢而矮小。</li></ul><h4 id="试述光对植物生长的影响。"><a class="header-anchor" href="#试述光对植物生长的影响。"></a>试述光对植物生长的影响。</h4><p>光对植物生长的影响是多方面的，主要有下列几方面：</p><ul><li>光是光合作用的能源和启动者，为植物的生长提供有机营养和能源；</li><li>光控制植物的形态建成，即叶的伸展扩大，茎的高矮，分枝的多少、长度、根冠比等都与光照强弱和光质有关；</li><li>日照时数影响植物生长与休眠。绝大多数多年生植物都是长日照条件促进生长、短日照条件诱导休眠；</li><li>光影响种子萌发，需光种子的萌发受光照的促进，而需暗种子的萌发则受光抑制，</li><li>此外，一些豆科植物叶片的昼开夜合，气孔运动等都受光的调节。</li></ul><h4 id="简述根和地上部分生长的相关性如何？"><a class="header-anchor" href="#简述根和地上部分生长的相关性如何？"></a>简述根和地上部分生长的相关性如何？</h4><p>根和地上部分的关系是既互相促进、互相依赖，又互相矛盾、互相制约的。</p><p>根系生长需要地上部供给光合产物、生长素和维生素，而地上部分生长又需根部吸收的水分、矿质，根部合成的多种氨基酸和细胞分裂素等。这就是两者相互依存、互相促进的一面，所以树大根深，根深叶茂。</p><p>但两者又有相互矛盾，相互制约的一面，例如过分旺盛的地上部分的生长会抑制地下部分的生长，只有两者的比例比较适当，才能获得高产。</p><h4 id="常言道：“根深叶茂”是何道理？"><a class="header-anchor" href="#常言道：“根深叶茂”是何道理？"></a>常言道：“根深叶茂”是何道理？</h4><p>植物“根深叶茂”原因如下：</p><ul><li>地上部分生长需要的水分和矿物质主要是由根系供给的，另外根系还能合成多种氨基酸、细胞分裂素、生物碱等供应地上部分，因此，根系发育得好，对地上部分生长也有利。</li><li>植物地上部分对根的生长也有促进作用，叶片中制造的糖类、维生素等供应给根以利根的生长。因此，地上部分长不好，根系也长不好。</li></ul><h4 id="一般认为光敏色素分布在细胞什么地方？Pr型和Pfr型的光学特性有何不同？"><a class="header-anchor" href="#一般认为光敏色素分布在细胞什么地方？Pr型和Pfr型的光学特性有何不同？"></a>一般认为光敏色素分布在细胞什么地方？Pr型和Pfr型的光学特性有何不同？</h4><p>一般认为光敏色素与膜系统结合，分布在质膜、线粒体膜、核膜、叶绿体膜和内质网膜上。</p><p>Pr型的吸收高峰在660nm，Pfr型的吸收高峰在730nm，两类型光敏色素在不同光谱作用下可互相转换，当Pr型吸收660nm红光后就转变为Pfr，而Pfr吸收730nm远红光后会转为Pr 型。</p><h4 id="关于光敏色素作用机理的基因调节假说内容如何？"><a class="header-anchor" href="#关于光敏色素作用机理的基因调节假说内容如何？"></a>关于光敏色素作用机理的基因调节假说内容如何？</h4><p>在接受红光照射后，Pfr型经过一系列过程，将信号转移到基因，活化或抑制某些特定基因，使转录出单股mRNA的速度发生改变，mRNA翻译成特殊蛋白质（酶），最后表现出形态建成。研究证明，多种酶的活性通过光敏色素受光调节，如PAL、NR等。蛋白质磷酸化受Ca<sup>2+</sup>-CaM调节，它可能是连接光敏色素的光活化和基因表达的中间步骤。</p><h4 id="为什么横放的茎会背地生长，而横放的根却向地生长。"><a class="header-anchor" href="#为什么横放的茎会背地生长，而横放的根却向地生长。"></a>为什么横放的茎会背地生长，而横放的根却向地生长。</h4><p>根和茎横放后，其体内的生长素由于重力的作用，造成背地面少于向地面，由于根较茎对生长的敏感性强，因此，向地面的茎由于生长素浓度高生长快，因此向上弯曲，而向地面的根由于生长素浓度高而生长受抑制，因此根向下弯曲生长。</p><h2 id="植物的生殖生理"><a class="header-anchor" href="#植物的生殖生理"></a>植物的生殖生理</h2><h3 id="名词解释-v7"><a class="header-anchor" href="#名词解释-v7"></a>名词解释</h3><p><strong>春化作用</strong>：低温促进植物开花的作用。</p><p><strong>去春化作用</strong>：已春化的植物或萌动种子，在春化过程结束之前，如置于高温条件下，春化效果即行消失，这种现象叫去春化作用。</p><p><strong>光周期与光周期现象</strong>：在一天中，白天和黑夜的相对长度叫光周期。植物对光周期的反应叫光周期现象。</p><p><strong>临界日长</strong>：诱导短日植物开花所需的最长日照时数，或诱导长日植物开花所需的最短日照时数。</p><p><strong>长日植物</strong>：日长必须长于临界日长才能开花的植物。</p><p><strong>短日植物</strong>：日长必须小于临界日长才能开花的植物。</p><p><strong>日中性植物</strong>：在任何日照长度下都能开花的植物。</p><p><strong>花粉识别蛋白</strong>：能够感受柱头上感受蛋白的刺激而决定花粉是否萌发，存在于花粉外壁上的一种膜蛋白。识别蛋白是一种糖蛋白。</p><h3 id="问答题-v7"><a class="header-anchor" href="#问答题-v7"></a>问答题</h3><h4 id="说明光周期现象与植物地理起源和分布的关系，以及在生产上的应用？"><a class="header-anchor" href="#说明光周期现象与植物地理起源和分布的关系，以及在生产上的应用？"></a>说明光周期现象与植物地理起源和分布的关系，以及在生产上的应用？</h4><p>植物光周期现象的形成，是长期适应该地区自然光周期的结果。纬度不同，不同光周期类型的植物分布亦不同。</p><ul><li>在低纬度地区，因为没有长日照条件，所以只有短日植物。</li><li>在高纬度地区，适于长日植物生长，所以这里分布着长日植物。</li><li>在中纬度地区（温度），长日照与短日照条件都有，因此长日植物与短日植物均有分布。</li></ul><p>所有这些都与原产地生长季节的日照条件相适应。</p><p>光周期现象可应用于：</p><ul><li>正确地引种栽培<ul><li>了解被引进品种对光周期的反应类型；</li><li>了解原产地与引种地日照条件的差异；</li><li>考虑被引进作物收获的是营养体，还是收获果实或种子。</li></ul></li><li>在育种上应用<ul><li>选育对光周期不敏感的植物；</li><li>杂交时控制光照时间，克服花期不遇。</li></ul></li><li>在蔬菜、花卉栽培上应用<ul><li>栽种叶菜、根菜类，不满足其对光周期的要求则抑制开花；</li><li>收获的是花菜、果菜类，尽量满足对日照的要求，促进开花；</li><li>为使菊花（短日植物）提前开花，可进行遮光处理。</li></ul></li></ul><h4 id="春化作用在农业生产实践中有何应用价值"><a class="header-anchor" href="#春化作用在农业生产实践中有何应用价值"></a>春化作用在农业生产实践中有何应用价值 ?</h4><ol><li>人工春化处理<ul><li>用于春天补种冬小麦；</li><li>在育种工作中利用春化处理，可以在一年中培育 3~4 代冬性作物，加速育种过程；</li><li>为了避免春季“倒春寒”对春小麦的低温伤害，可对种子进行人工春化处理后适当晚播，使之在缩短生育期的情况下正常成熟。</li></ul></li><li>调种引种，引种时应注意原产地所处的纬度，了解品种对低温的要求。若将北方的品种引种到南方，就可能因当地温度较高而不能顺利通过春化阶段，使植物只进行营养生长而不开花结实，造成不可弥补的损失。</li><li>控制花期<ul><li>如低温处理可以使秋播的一、二年生草本花卉改为春播，当年开花；</li><li>对以营养器官为收获对象的植物，如洋葱、当归等，可用解除春化的方法，抑制开花，延长营养生长，从而增加产量和提高品质。</li></ul></li></ol><h4 id="肉质果实成熟时发生了哪些生理生化变化？"><a class="header-anchor" href="#肉质果实成熟时发生了哪些生理生化变化？"></a>肉质果实成熟时发生了哪些生理生化变化？</h4><ol><li>果实变甜。 果实成熟后期，淀粉可以转变成为可溶性糖，使果实变甜。</li><li>酸味减少。未成熟的果实中积累较多的有机酸。在果实成熟过程中，有机酸含量下降，这是因为：<ul><li>有的转变为糖；</li><li>有的作为呼吸底物氧化为CO<sub>2</sub>和H<sub>2</sub>O；</li><li>有些则被Ca<sup>2+</sup>、K<sup>+</sup>等所中和。</li></ul></li><li>涩味消失。果实成熟时，单宁可被过氧化物酶氧化成无涩味的过氧化物，或单宁凝结成不溶于水的胶状物质，涩味消失。</li><li>香味产生。主要是一些芳香族和脂肪族的酯，还有一些特殊的醛类，如桔子中柠檬醛可以产生香味。</li><li>由硬变软。这与果肉细胞壁中层的果胶质水解为可溶性的果酸有关。</li><li>色泽变艳。果皮由绿色变为黄色，是由干果皮中叶绿素逐渐破坏而失绿，类胡萝素仍存在，呈现黄色，或因花色素形成而呈现红色。</li></ol><h4 id="到了深秋，树木的芽为什么会进入休眠状态？"><a class="header-anchor" href="#到了深秋，树木的芽为什么会进入休眠状态？"></a>到了深秋，树木的芽为什么会进入休眠状态？</h4><p>到了秋天导致树木形成休眠芽进入休眠状态的原因，主要是由于日照时数的缩短所引起的。</p><p>秋天的短日照作为进入休眠的信号，这一信号由叶片中的光敏色素感受后，便促进甲羟戊酸合成ABA（脱落酸），并转移到生长点，抑制mRNA和tRNA的生物合成因而也就抑制了蛋白质与酶的生物合成，进而抑制芽的生长，使芽进入休眠状态。</p><h4 id="呼吸跃变与果实贮藏的关系如何？在生产上有何指导意义？"><a class="header-anchor" href="#呼吸跃变与果实贮藏的关系如何？在生产上有何指导意义？"></a>呼吸跃变与果实贮藏的关系如何？在生产上有何指导意义？</h4><p>果实呼吸跃变是果实成熟的一种特征，大多数果实成熟是与呼吸的跃变相伴随的，呼吸跃变结束即意味着果实已达成熟。</p><p>在果实贮藏或运输中，可以通过降低温度，推迟呼吸跃变发生的时间，另一是增加周围CO<sub>2</sub>的浓度，降低呼吸跃变发生的强度，这样就可达到延迟成熟，保持鲜果，防止腐烂的目的。</p><h4 id="论述种子休眠的原因及其解除休眠的措施"><a class="header-anchor" href="#论述种子休眠的原因及其解除休眠的措施"></a>论述种子休眠的原因及其解除休眠的措施</h4><p>种子休眠的原因：</p><ul><li>种皮（果皮）的限制；</li><li>种子未完成后熟；</li><li>抑制物质的作用</li></ul><p>解除休眠的措施有：机械破损，温度处理，化学处理，清水冲洗，层积处理</p><h1>自测</h1><h2 id="植物的水分代谢-v2"><a class="header-anchor" href="#植物的水分代谢-v2"></a>植物的水分代谢</h2><h3 id="名词解释-v8"><a class="header-anchor" href="#名词解释-v8"></a>名词解释</h3><p><strong>水势</strong>($\psi_{\mathrm{w}}$)：<u>每偏摩尔体积水的化学势差。</u>符号：$\psi_{\mathrm{w}}$。</p><p><strong>渗透势</strong>($\psi_\pi$)：<u>由于溶液中溶质颗粒的存在而引起的水势降低值。用负值表示。</u>亦称溶质势（$\psi_\pi$）。</p><p><strong>衬质势</strong>($\psi_m$)：<u>细胞胶体物质亲水性和毛细管对自由水束缚而引起的水势降低值，以负值表示。</u>符号$\psi_m$ 。</p><p><strong>蒸腾作用</strong>：<u>水分以气体状态通过植物体表面从体内散失到体外的现象。</u></p><p><strong>根压</strong>：<u>植物根部的生理活动使液流从根部上升的压力。</u></p><p><strong>蒸腾拉力</strong>：<u>由于蒸腾作用产主的一系列水势梯度使导管中水分上升的力量。</u></p><p><strong>蒸腾速率</strong>：<u>又称蒸腾强度，指植物在单位时间内，单位面积通过蒸腾作用而散失的水分量。</u>（g/dm<sup>2</sup>·h）</p><p><strong>内聚力学说</strong>：<u>又称蒸腾流-内聚力-张力学说。即以水分的内聚力解释水分沿导管上升原因的学说。</u></p><h3 id="问答题-v8"><a class="header-anchor" href="#问答题-v8"></a>问答题</h3><h4 id="简述水分的植物生理生态作用-v2"><a class="header-anchor" href="#简述水分的植物生理生态作用-v2"></a>简述水分的植物生理生态作用</h4><ul><li><u>水分能便植物保持固有的姿态</u></li><li><u>水分是重要代谢过程的反应物质和产物</u></li><li><u>水是细胞原生质的主要组成成分</u></li><li><u>细胞分裂及伸长都需要水分</u></li><li><u>水分是植物对物质吸收和运输及生化反应的一种良好溶剂</u></li><li><u>可以通过水的理化特性以调节植物周围的大气湿度、温度等。对维持植物体温稳定和降低体温也有重要作用</u></li></ul><h4 id="利用质壁分离现象可以解决哪些问题-v2"><a class="header-anchor" href="#利用质壁分离现象可以解决哪些问题-v2"></a>利用质壁分离现象可以解决哪些问题</h4><ul><li><u>说明原生质层是半透膜。</u></li><li><u>判断细胞死活。只有活细胞的原生质层才是半透膜，才有质壁分离现象，如细胞死亡，则不能产主质壁分离现象。</u></li><li><u>测定细胞液的渗透势</u></li></ul><h4 id="蒸腾作用有什么生理意义-v2"><a class="header-anchor" href="#蒸腾作用有什么生理意义-v2"></a>蒸腾作用有什么生理意义</h4><ul><li><u>是植物对水分吸收和运输的主要动力</u></li><li><u>促进植物对矿物质和有机物的吸收及其在植物体内的转运</u></li><li><u>能够降低叶片的温度，以免灼伤</u></li></ul><h4 id="气孔开闭机理的假说有哪些？请简述之-v2"><a class="header-anchor" href="#气孔开闭机理的假说有哪些？请简述之-v2"></a>气孔开闭机理的假说有哪些？请简述之</h4><ol><li><u>淀粉–糖变化学说：在光照下保卫细胞进行光合作用合成可溶性糖。另外由于光合作用消耗CO<sub>2</sub>，使保卫细胞pH值升高，淀粉磷酸化酶水解细胞中淀粉形成可溶性糖，细胞水势下降，当保卫细胞水势低于周围的细胞水势时，便吸水迫使气孔张开，在暗中光合作用停止，情况与上述相反，气孔关闭。</u></li><li><u>无机离子吸收学说：在光照下，保卫细胞质膜上具有光活化H<sup>+</sup>泵ATP酶，分解光合磷酸化产生的ATP并将H<sup>+</sup>分泌到细胞壁，同时将外面的K<sup>+</sup>吸收到细胞中来，Cl<sup>-</sup>也伴随着K<sup>+</sup>进入，以保证保卫细胞的电中性，保卫细胞中积累较多的K<sup>+</sup>和，降低水势，气孔就张开，反之，则气孔关闭。</u></li><li><u>苹果酸生成学说。在光下保卫细胞内的CO<sub>2</sub>被利用，pH值就上升，剩余的CO<sub>2</sub>就转变成重碳酸盐（HCO<sub>3</sub><sup>-</sup>），淀粉通过糖酵解作用产生的磷酸烯醇式丙酮酸在PEP羧化酶作用下与HCO<sub>3</sub><sup>-</sup>作用形成草酰乙酸，然后还原成苹果酸，可作为渗透物降低水势，气孔张开，反之关闭。</u></li></ol><h2 id="植物的矿质营养-v2"><a class="header-anchor" href="#植物的矿质营养-v2"></a>植物的矿质营养</h2><h3 id="名词解释-v9"><a class="header-anchor" href="#名词解释-v9"></a>名词解释</h3><p><strong>矿质营养</strong>: <u>是指植物对氮和矿质元素的吸收、运输与同化的过程。</u></p><p><strong>灰分元素</strong>：<u>亦称矿质元素，将干燥植物材料燃烧后，剩余一些不能挥发的物质称为灰分元素。</u></p><p><strong>单盐毒害和离子拮抗</strong>：<u>单盐毒害是指溶液中因只有一种金属离子而对植物之毒害作用的现象；在发生单盐毒害的溶液中加入少量其他金属离子，即能减弱或消除这种单盐毒害，离子间的这种作用称为离子拮抗。</u></p><p><strong>平衡溶液</strong>：<u>在含有适当比例的多种盐溶液中，各种离子的毒害作用被消除，植物可以正常生长发育，这种溶液称为平衡溶液。</u></p><p><strong>诱导酶</strong>：<u>又称适应酶，指植物体内本来不含有，但在特定外来物质的诱导下可以生成的酶。如硝酸还原酶可为NO<sub>3</sub><sup>-</sup>所诱导。</u></p><p><strong>生物固氮</strong>：<u>某些微生物把空气中游离氮固定转化为含氮化合物的过程。</u></p><h3 id="问答题-v9"><a class="header-anchor" href="#问答题-v9"></a>问答题</h3><h4 id="植物必需的矿质元素要具备哪些条件-v2"><a class="header-anchor" href="#植物必需的矿质元素要具备哪些条件-v2"></a>植物必需的矿质元素要具备哪些条件</h4><ul><li><u>缺乏该元素植物生育发生障碍不能完成生活史。</u></li><li><u>除去该元素则表现专一的缺乏症，这种缺乏症是可以预防和恢复的。</u></li><li><u>该元素在植物营养生理上表现直接的效果而不是间接的。</u></li></ul><h4 id="为什么把氮称为生命元素-v2"><a class="header-anchor" href="#为什么把氮称为生命元素-v2"></a>为什么把氮称为生命元素</h4><p><u>氮在植物生命活动中占据重要地位，它是植物体内许多重要化合物的成分，如核酸（DNA、RNA）、蛋白质（包括酶）、磷脂、叶绿素。光敏色素、维生素B、IAA、CTK、生物碱等都含有氮。</u></p><p><u>同时氮也是参与物质代谢和能量代谢的ADP、ATP、CoA、CoQ、FAD、FMN、NAD<sup>+</sup>、NADP<sup>+</sup>、铁卟琳等物质的组分。</u></p><p><u>上述物质有些是生物膜、细胞质、细胞核的结构物质，有些是调节生命活动的生理活性物质。</u></p><p><u>因此，氮是建造植物体的结构物质，也是植物体进行能量代谢、物质代谢及各种生理活动所必需的起重要作用的生命元素。</u></p><h4 id="植物细胞吸收矿质元素的方式有哪些-v2"><a class="header-anchor" href="#植物细胞吸收矿质元素的方式有哪些-v2"></a>植物细胞吸收矿质元素的方式有哪些</h4><ul><li><u>被动吸收：包括简单扩散、杜南平衡。不消耗代谢能。</u></li><li><u>主动吸收：有载体和质子泵参与，需消耗代谢能。</u></li><li><u>胞饮作用：是一种非选择性吸收方式。</u></li></ul><h4 id="为什么土壤温度过低，植物吸收矿质元素的速率下降-v2"><a class="header-anchor" href="#为什么土壤温度过低，植物吸收矿质元素的速率下降-v2"></a>为什么土壤温度过低，植物吸收矿质元素的速率下降</h4><ul><li><u>因为温度低时代谢弱，能量不足，主动吸收慢</u></li><li><u>胞质粘性增大，离子进入困难。其中以对钾和硅酸的吸收影响最大。</u></li></ul><h4 id="白天和夜晚硝酸盐还原速度是否相同？为什么-v2"><a class="header-anchor" href="#白天和夜晚硝酸盐还原速度是否相同？为什么-v2"></a>白天和夜晚硝酸盐还原速度是否相同？为什么?</h4><p><u>硝酸盐在昼夜的还原速度不同，白天还原速度显著较夜晚快，这是因为白天光合作用产生的还原力及磷酸丙糖能促进硝酸盐的还原。</u></p><h4 id="合理施肥增产的原因是什么-v2"><a class="header-anchor" href="#合理施肥增产的原因是什么-v2"></a>合理施肥增产的原因是什么</h4><p><u>合理施肥增产的实质在于改善光合性能（增大光合面积，提高光合能力，延长光合时间，有利光合产量分配利用等），通过光合过程形成更多的有机物获得高产。</u></p><h4 id="根外施肥有哪些优点-v2"><a class="header-anchor" href="#根外施肥有哪些优点-v2"></a>根外施肥有哪些优点?</h4><ul><li><u>作物在生育后期根部吸肥能力衰退时或营养临界期时，可根外施肥补充营养 。</u></li><li><u>某些肥料易被土壤固定而根外施肥无此毛病，且用量少</u></li><li><u>补充植物缺乏的微量元素，用量省、见效快。</u></li></ul><h2 id="植物的光合作用-v2"><a class="header-anchor" href="#植物的光合作用-v2"></a>植物的光合作用</h2><h3 id="名词解释-v10"><a class="header-anchor" href="#名词解释-v10"></a>名词解释</h3><p><strong>光合色素</strong>：<u>指植物体内含有的具有吸收光能并将其用于光合作用的色素，包括叶绿素、类胡萝卜素、藻胆素等。</u></p><p><strong>原初反应</strong>：<u>包括光能的吸收、传递以及光能向电能的转变，即由光所引起的氧化还原过程。</u></p><p><strong>红降现象</strong>：<u>当光波大于685nm时，虽然仍被叶绿素大量吸收，但量子效率急剧下降，这种现象被称为红降现象。</u></p><p><strong>爱默生效应</strong>：<u>如果在长波红光（大于685nm）照射时，再加上波长较短的红光（650nm），则量子产额大增，比分别单独用两种波长的光照射时的总和还要高。</u></p><p><strong>光合链</strong>：<u>即光合作用中的电子传递。它包括质体醌、细胞色素、质体蓝素、铁氧还蛋白等许多电子传递体，当然还包括光系统Ⅰ和光系统Ⅱ的作用中心。其作用是水的光氧化所产生的电子依次传递，最后传递给NADP<sup>+</sup>。光合链也称Z链。</u></p><p><strong>光合作用单位</strong>：<u>结合在类囊体膜上，能进行光合作用的最小结构单位。</u></p><p><strong>作用中心色素</strong>：<u>指具有光化学活性的少数特殊状态的叶绿素a分子。</u></p><p><strong>聚光色素</strong>：<u>指没有光化学活性，只能吸收光能并将其传递给作用中心色素的色素分子。聚光色素又叫天线色素。</u></p><p><strong>光能利用率</strong>：<u>单位面积上的植物光合作用所累积的有机物所含的能量，占照射在相同面积地面上的日光能量的百分比。</u></p><p><strong>光合磷酸化</strong>：<u>叶绿体（或载色体）在光下把无机磷和ADP转化为ATP，并形成高能磷酸键的过程。</u></p><p><strong>光呼吸</strong>：<u>植物的绿色细胞在光照下吸收氧气，放出CO<sub>2</sub>的过程。光呼吸的主要代谢途径就是乙醇酸的氧化，乙醇酸来源于RuBP的氧化。光呼吸之所以需要光就是因为RuBP的再生需要光。</u></p><p><strong>光补偿点</strong>：<u>同一叶子在同一时间内，光合过程中吸收的CO<sub>2</sub>和呼吸过程中放出的CO<sub>2</sub>等量时的光照强度。</u></p><p><strong>CO<sub>2</sub>补偿点</strong>：<u>当光合吸收的CO<sub>2</sub>量与呼吸释放的CO<sub>2</sub>量相等时，外界的CO<sub>2</sub>浓度。</u></p><p><strong>光饱和点</strong>：<u>增加光照强度，光合速率不再增加时的光照强度。</u></p><h3 id="问答题-v10"><a class="header-anchor" href="#问答题-v10"></a>问答题</h3><h4 id="植物的叶片为什么是绿色的？秋天树叶为什么会呈现黄色或红色？-v2"><a class="header-anchor" href="#植物的叶片为什么是绿色的？秋天树叶为什么会呈现黄色或红色？-v2"></a>植物的叶片为什么是绿色的？秋天树叶为什么会呈现黄色或红色？</h4><p><u>光合色素主要吸收红光和蓝紫光，对绿光吸收很少，所以植物的时片呈绿色。</u></p><p><u>秋天树叶变黄是由于低温抑制了叶绿素的生物合成，已形成的叶绿素也被分解破坏，而类胡萝卜素比较稳定，所以叶片呈现黄色。</u></p><p><u>至于红叶，是因为秋天降温，体内积累较多的糖分以适应寒冷，体内可溶性糖多了，就形成较多的花色素，叶子就呈红色。</u></p><h4 id="提高植物光能利用率的途径和措施有哪些？-v2"><a class="header-anchor" href="#提高植物光能利用率的途径和措施有哪些？-v2"></a>提高植物光能利用率的途径和措施有哪些？</h4><ul><li><u>增加光合面积：①合理密植；②改善株型。</u></li><li><u>延长光合时间：①提高复种指数；②延长生育期 ③补充人工光照。</u></li><li><u>提高光合速率：①增加田间CO<sub>2</sub> 浓度；②降低光呼吸。</u></li></ul><h4 id="光合作用的全过程大致分为哪三大步骤？-v2"><a class="header-anchor" href="#光合作用的全过程大致分为哪三大步骤？-v2"></a>光合作用的全过程大致分为哪三大步骤？</h4><ul><li><u>光能的吸收传递和转变为电能过程。</u></li><li><u>电能转变为活跃的化学能过程。</u></li><li><u>活跃的化学能转变为稳定的化学能过程。</u></li></ul><h4 id="C-sub-3-sub-途径是谁发现的？分哪几个阶段？每个阶段的作用是什么？-v2"><a class="header-anchor" href="#C-sub-3-sub-途径是谁发现的？分哪几个阶段？每个阶段的作用是什么？-v2"></a>C<sub>3</sub>途径是谁发现的？分哪几个阶段？每个阶段的作用是什么？</h4><p><u>C<sub>3</sub>途径是卡尔文（Calvin）等人发现的。可分为三个阶段：</u></p><ul><li><u>羧化阶段，CO<sub>2</sub>被固定，生成3-磷酸甘油酸，为最初产物；</u></li><li><u>还原阶段：利用同化力（NADPH、ATP）将3-磷酸甘油酸还原成3-磷酸甘油醛——光合作用中的第一个三碳糖；</u></li><li><u>更新阶段，光合碳循环中形成的3-磷酸甘油醛，经过一系列的转变，再重新形成RuBP的过程。</u></li></ul><h4 id="C-sub-3-sub-途径的调节方式有哪几个方面？-v2"><a class="header-anchor" href="#C-sub-3-sub-途径的调节方式有哪几个方面？-v2"></a>C<sub>3</sub>途径的调节方式有哪几个方面？</h4><ol><li><u>酶活化调节：通过改变叶的内部环境，间接地影响酶的活性。如间质中pH的升高，Mg<sup>2+</sup>浓度升高，可激活RuBPCase和Ru5P激酶。</u></li><li><u>质量作用的调节，代谢物的浓度可以影响反应的方向和速率。</u></li><li><u>转运作用的调节，叶绿体内的光合最初产物——磷酸丙糖，从叶绿体运到细胞质的数量，受细胞质里的Pi数量所控制。Pi充足，进入叶绿体内多，就有利于叶绿体内磷酸丙糖的输出，光合速率就会加快。</u></li></ol><h4 id="如何解释C-sub-4-sub-植物比C-sub-3-sub-植物的光呼吸低？-v2"><a class="header-anchor" href="#如何解释C-sub-4-sub-植物比C-sub-3-sub-植物的光呼吸低？-v2"></a>如何解释C<sub>4</sub>植物比C<sub>3</sub>植物的光呼吸低？</h4><p><u>C<sub>4</sub>植物PEP羧化酶对CO<sub>2</sub>亲和力高，固定CO<sub>2</sub>的能力强，在叶肉细胞形成C<sub>4</sub>二羧酸之后，再转运到维管束鞘细胞，脱羧后放出CO<sub>2</sub>，就起到了CO<sub>2</sub> 泵的作用，增加了CO<sub>2</sub>浓度，提高了RuBP羧化酶的活性，有利于CO<sub>2</sub> 的固定和还原，不利于乙醇酸形成，不利于光呼吸进行，所以C<sub>4</sub>植物光呼吸测定值很低。</u></p><p><u>而C<sub>3</sub>植物，在叶肉细胞内固定CO<sub>2</sub>，叶肉细胞的CO<sub>2</sub>/O<sub>2</sub>的比值较低，此时，RuBP加氧酶活性增强，有利于光呼吸的进行，而且C<sub>3</sub>植物中RuBP羧化酶对CO<sub>2</sub>亲和力低，光呼吸释放的CO<sub>2</sub>，不易被重新固定。</u></p><h4 id="如何评价光呼吸的生理功能？-v2"><a class="header-anchor" href="#如何评价光呼吸的生理功能？-v2"></a>如何评价光呼吸的生理功能？</h4><p><u>光呼吸是具有一定的生理功能的，也有害处：</u></p><ul><li><u>有害的方面：减少了光合产物的形成和累积，不仅不能贮备能量，还要消耗大量能量。</u></li><li><u>有益之处：</u><ul><li><u>消除了乙醇酸的累积所造成的毒害。</u></li><li><u>此过程可以作为丙糖和氨基酸的补充途径。</u></li><li><u>防止高光强对叶绿体的破坏，消除了过剩的同化力，保护了光合作用正常进行。</u></li><li><u>消耗了O<sub>2</sub>之后，降低了O<sub>2</sub>/CO<sub>2</sub>之比，可提高RuBP羧化酶的活性，有利于碳素同化作用的进行。</u></li></ul></li></ul><h4 id="简述CAM植物同化CO-sub-2-sub-的特点。-v2"><a class="header-anchor" href="#简述CAM植物同化CO-sub-2-sub-的特点。-v2"></a>简述CAM植物同化CO<sub>2</sub>的特点。</h4><p><u>这类植物晚上气孔开放，吸进CO<sub>2</sub>，在PEP羧化酶作用下与PEP结合形成苹果酸累积于液泡中。</u></p><p><u>白天气孔关闭，液泡中的苹果酸便运到细胞质，放出CO<sub>2</sub>参与卡尔文循环形成淀粉等。</u></p><h4 id="作物为什么会出现“午休”现象？-v2"><a class="header-anchor" href="#作物为什么会出现“午休”现象？-v2"></a>作物为什么会出现“午休”现象？</h4><ul><li><u>水分在中午供给不上，气孔关闭；</u></li><li><u>CO<sub>2</sub>供应不足；</u></li><li><u>光合产物淀粉等来不及分解运走，累积在叶肉细胞中，阻碍细胞内CO<sub>2</sub>的运输；</u></li><li><u>生理钟调控。</u></li></ul><h2 id="植物的呼吸作用-v2"><a class="header-anchor" href="#植物的呼吸作用-v2"></a>植物的呼吸作用</h2><h3 id="名词解释-v11"><a class="header-anchor" href="#名词解释-v11"></a>名词解释</h3><p><strong>末端氧化酶</strong>：<u>是指处于生物氧化作用一系列反应的最末端，将底物脱下的氢或电子传递给氧，并形成H<sub>2</sub>O或H<sub>2</sub>O<sub>2</sub>的氧化酶类。</u></p><p><strong>抗氰呼吸</strong>：<u>某些植物组织对氰化物不敏感的那部分呼吸。即在有氰化物存在的条件下仍有一定的呼吸作用。</u></p><p><strong>呼吸商</strong>：<u>又称呼吸系数，简称RQ，是指在一定时间内，植物组织释放CO<sub>2</sub>的摩尔数与吸收氧的摩尔数之比。</u></p><p><strong>呼吸速率</strong>：<u>以单位鲜重、干重或单位面积在单位时间内所放出的CO<sub>2</sub>的重量（或体积）或所吸收O<sub>2</sub>的重量（或体积）来表示。</u></p><p><strong>糖酵解</strong>：<u>是指在细胞质内所发生的、由葡萄糖分解为丙酮酸的过程。</u></p><p><strong>三羧酸循环</strong>：<u>丙酮酸在有氧条件下，通过一个包括三羧酸和二羧酸的循环而逐步氧化分解生成CO<sub>2</sub>的过程。又称为柠檬酸环或Krebs环，简称TCA循环。</u></p><p><strong>戊糖磷酸途径</strong>：<u>简称PPP或HMP。是指在细胞质内进行的一种葡萄糖直接氧化降解的酶促反应过程。</u></p><p><strong>呼吸链</strong>：<u>呼吸代谢中间产物随电子和质子，沿着一系列有顺序的电子传递体组成的电子传递途径，传递到分子氧的总轨道。</u></p><p><strong>氧化磷酸化</strong>：<u>是指呼吸链上的氧化过程，伴随着ADP被磷酸化为ATP的作用。</u></p><h3 id="问答题-v11"><a class="header-anchor" href="#问答题-v11"></a>问答题</h3><h4 id="呼吸作用多条路线论点的内容和意义如何？-v2"><a class="header-anchor" href="#呼吸作用多条路线论点的内容和意义如何？-v2"></a>呼吸作用多条路线论点的内容和意义如何？</h4><p><u>植物呼吸代谢多条路线论点是汤佩松先生提出来的，其内容是是：</u></p><ul><li><u>呼吸化学途径多样性（EMP、PPP、TCA等）；</u></li><li><u>呼吸链电子传递系统的多样性（电子传递主路，几条支路，如抗氰支路）；</u></li><li><u>末端氧化酶系统的多样性（细胞色素氧化酶，酚氧化酶，抗坏血酸氧化酶，乙醇酸氧化酶和交替氧化酶）。</u></li></ul><p><u>这些多样性，是植物在长期进化过程中对不断变化的外界环境的一种适应性表现，其要点是呼吸代谢（对生理功能）的控制和被控制（酶活性）过程。而且认为该过程受到生长发育和不同环境条件的影响，这个论点，为呼吸代谢研究指出了努力方向。</u></p><h4 id="戊糖磷酸途径在植物呼吸代谢中具有什么生理意义-v2"><a class="header-anchor" href="#戊糖磷酸途径在植物呼吸代谢中具有什么生理意义-v2"></a>戊糖磷酸途径在植物呼吸代谢中具有什么生理意义</h4><p><u>戊糖磷酸途径中形成的NADPH是细胞内必需NADPH才能进行生物合成反应的主要来源，如脂肪合成。其中间产物核糖和磷酸又是合成核苷酸的原料，植物感病时戊糖磷酸途径所占比例上升，因此，戊糖磷酸途径在植物呼吸代谢中占有特殊的地位。</u></p><h4 id="呼吸作用糖的分解代谢途径有几种？在细胞的什么部位进行？-v2"><a class="header-anchor" href="#呼吸作用糖的分解代谢途径有几种？在细胞的什么部位进行？-v2"></a>呼吸作用糖的分解代谢途径有几种？在细胞的什么部位进行？</h4><p><u>有EMP、TCA和PPP三种。EMP和PPP在细胞质中进行的。TCA是在线粒体中进行的。</u></p><h4 id="什么叫末端氧化酶？主要有哪几种？-v2"><a class="header-anchor" href="#什么叫末端氧化酶？主要有哪几种？-v2"></a>什么叫末端氧化酶？主要有哪几种？</h4><p><u>处于生物氧化作用一系列反应的最末端，将底物脱下的氢或电子传递给氧，并形成H<sub>2</sub>O或凡H<sub>2</sub>O<sub>2</sub>的氧化酶都称为末端氧化酶。如：细胞色素氧化酶、交替氧化酶（抗氰氧化酶）、酚氧化酶、抗坏血酸氧化酶、黄素氧化酶等，也有把过氧化氢物和过氧化物酶列入其中。</u></p><h4 id="抗氰呼吸有何特点？-v2"><a class="header-anchor" href="#抗氰呼吸有何特点？-v2"></a>抗氰呼吸有何特点？</h4><p><u>已知抗氰呼吸电子传递的途径不通过细胞色素系统，而是由泛醌传递给一个受体（X），再由X直接传递给氧，这样就越过了磷酸化部位Ⅱ、Ⅲ，对氰化物不敏，且P/O比为1或＜1。因此，在进行抗氰呼吸时有大量热能释放。</u></p><p><u>抗氰呼吸的强弱除了与植物种类有关外，也与发育状况、外界条件有关。且抗氰呼吸在正常途径受阻时得到加强，所以抗氰呼吸是一种与正常呼吸途径交替进行的适应性过程。</u></p><h4 id="粮食贮藏时为什么要降低呼吸速率？-v2"><a class="header-anchor" href="#粮食贮藏时为什么要降低呼吸速率？-v2"></a>粮食贮藏时为什么要降低呼吸速率？</h4><ul><li><u>因为呼吸速率高会大量消耗有机物；</u></li><li><u>呼吸放出的水分又会使粮堆湿度增大，粮食“出汗”，呼吸加强；</u></li><li><u>呼吸放出的热量又使粮温增高，反过来又促进呼吸增强，同时高温高湿微生物迅速繁殖，最后导致粮食变质。</u></li></ul><h4 id="长时间无氧呼吸植物为什么会死亡？-v2"><a class="header-anchor" href="#长时间无氧呼吸植物为什么会死亡？-v2"></a>长时间无氧呼吸植物为什么会死亡？</h4><ul><li><u>无氧呼吸产生酒精，酒精使细胞质的蛋白质变性。</u></li><li><u>氧化1mol葡萄糖产生的能量少。要维持正常的生理需要就要消耗更多的有机物，这样体内养分耗损过多。</u></li><li><u>没有丙酮酸的有氧分解过程，缺少合成其他物质的原料。</u></li></ul><h4 id="植物组织受到损伤时呼吸速率为何加快？-v2"><a class="header-anchor" href="#植物组织受到损伤时呼吸速率为何加快？-v2"></a>植物组织受到损伤时呼吸速率为何加快？</h4><ul><li><u>一是原来氧化酶与其底物在结构上是隔开的，损伤使原来的间隔破坏，酚类化合物迅速被氧化。</u></li><li><u>二是损伤使某些细胞转变为分生状态，形成愈伤组织以修复伤处，这些生长旺盛的细胞比原来的休眠或成熟组织的呼吸速率要快得多。</u></li></ul><h4 id="低温导致烂秧的原因是什么？-v2"><a class="header-anchor" href="#低温导致烂秧的原因是什么？-v2"></a>低温导致烂秧的原因是什么？</h4><p><u>是因为低温破坏了线粒体的结构，呼吸“空转”，缺乏能量引起代谢紊乱的缘故。</u></p><h4 id="早稻浸种催芽时用温水淋种和翻堆的目的是什么？-v2"><a class="header-anchor" href="#早稻浸种催芽时用温水淋种和翻堆的目的是什么？-v2"></a>早稻浸种催芽时用温水淋种和翻堆的目的是什么？</h4><p><u>目的就是控制温度和通气，使呼吸作用顺利进行。否则谷堆中部温度过高就会引起“烧芽”现象。</u></p><h2 id="植物生长物质-v2"><a class="header-anchor" href="#植物生长物质-v2"></a>植物生长物质</h2><h3 id="名词解释-v12"><a class="header-anchor" href="#名词解释-v12"></a>名词解释</h3><p><strong>植物生长物质</strong>：<u>是一些调节植物生长发育的物质。包括植物激素和植物生长调节剂。</u></p><p><strong>植物激素</strong>：<u>指一些在植物体内合成，并从产生之处运送到别处，对生长发育起显著作用的微量有机物。</u></p><p><strong>植物生长调节剂</strong>：<u>指一些具有植物激素活性的人工合成的物质。</u></p><p><strong>极性运输</strong>：<u>只能从植物形态学的上端向下端运输，而不能倒过来运输。</u></p><p><strong>三重反应</strong>：<u>乙烯可抑制黄化豌豆幼苗上胚轴的伸长生长；促进其加粗生长；地上部分失去负向地性生长（偏上生长）。</u></p><p><strong>生长抑制剂</strong>：<u>这类物质主要作用于顶端分生组织区，干扰顶端细胞分裂，引起茎伸长的停顿和顶端优势破坏。其作用不能被赤霉素所恢复。</u></p><p><strong>生长延缓剂</strong>：<u>抑制节间伸长而不破坏顶芽的化合物。其作用可被GA所恢复。</u></p><h3 id="问答题-v12"><a class="header-anchor" href="#问答题-v12"></a>问答题</h3><h4 id="乙烯促进果实成熟的原因何在？-v2"><a class="header-anchor" href="#乙烯促进果实成熟的原因何在？-v2"></a>乙烯促进果实成熟的原因何在？</h4><p><u>乙烯能增加细胞膜的透性，促使呼吸作用加强某些肉质果实出现呼吸骤变，因而引起果实内的各种有机物质发生急剧变化，使果实甜度增加，酸味减少，涩味消失，香味产主，色泽变艳，果实由硬变软，达到完全成熟。</u></p><h4 id="生长素与赤霉素之生理作用方面的相互关系如何？-v2"><a class="header-anchor" href="#生长素与赤霉素之生理作用方面的相互关系如何？-v2"></a>生长素与赤霉素之生理作用方面的相互关系如何？</h4><p><u>生长素与赤霉素之间存在相辅相成作用。</u></p><ul><li><u>GA有抑制IAA氧化酶活性的作用防止IAA的氧化；</u></li><li><u>GA能增加蛋白酶的活性，促进蛋白质分解，色氨酸数量增多，有利于IAA的生物合成</u></li><li><u>GA促进生长素由束缚型转变为自由型。</u></li></ul><h4 id="赤霉素在生产上的应用主要有哪些方面？-v2"><a class="header-anchor" href="#赤霉素在生产上的应用主要有哪些方面？-v2"></a>赤霉素在生产上的应用主要有哪些方面？</h4><ul><li><u>促进麦芽糖化，GA诱导α-淀粉酶的形成这一发现己被应用到啤酒生产中。</u></li><li><u>促进营养生长，如在水稻“三系”的制种过程中，切花生产上等都有应用</u></li><li><u>防止脱落，促进单性结实</u></li><li><u>打破休眠。</u></li></ul><h4 id="人们认为植物的休眠与生长是由哪两种激素调节的？如何调节？-v2"><a class="header-anchor" href="#人们认为植物的休眠与生长是由哪两种激素调节的？如何调节？-v2"></a>人们认为植物的休眠与生长是由哪两种激素调节的？如何调节？</h4><p><u>植物的生长和休眠是由赤霉素和脱落酸两种激素调节的。它们的合成前体都是甲瓦龙酸，甲瓦龙酸在长日照条件下形成赤霉素，短日照条件下形成脱落酸，因此，夏季日照长，产生赤霉素促进植物生长；而冬季来临前，日照短，产生脱落酸使芽进入休眠。</u></p><h4 id="生长抑制剂和生长延缓剂抑制生长的作用方式有何不同？-v2"><a class="header-anchor" href="#生长抑制剂和生长延缓剂抑制生长的作用方式有何不同？-v2"></a>生长抑制剂和生长延缓剂抑制生长的作用方式有何不同？</h4><p><u>生长抑制剂是抑制顶端分生组织生长，丧失顶端优势，使植株形态发生很大变化，外施GA不能逆转达种抑制反应</u></p><p><u>生长延缓剂是抑制茎部近顶端分生组织的细胞伸长，节间缩短，叶数和节数不变，株型紧凑矮小，生殖器官不受影响或影响不大，外施GA可逆转其抑制效应。</u></p><h2 id="植物的生长生理-v2"><a class="header-anchor" href="#植物的生长生理-v2"></a>植物的生长生理</h2><h3 id="名词解释-v13"><a class="header-anchor" href="#名词解释-v13"></a>名词解释</h3><p><strong>生长</strong>：<u>细胞、器官或有机体的数目、大小与重量的不可逆增加，即发育过程中量的变化称为生长。</u></p><p><strong>分化</strong>：<u>来自同一分子或遗传上同质的细胞转变为形态上、机能上、化学构成上异质的细胞称为分化。</u></p><p><strong>发育</strong>：<u>在植物生命周期过程中，植物发生大小、形态、结构、功能上的变化，称为发育，发育包括生长与分化两个方面，即生长与分化贯穿在整个发育过程中。</u></p><p><strong>种子寿命</strong>：<u>从种子成熟到失去发芽能力的时间。</u></p><p><strong>种子活力</strong>：<u>种子在田间条件（非理想条件）下萌发的速度、整齐度及幼苗健壮生长的潜在能力，它包括种子萌发成苗和对不良环境的忍受力两个方面。种子活力与种子的大小、成熟度有关，也与贮藏条件和贮藏时间有关。</u></p><p><strong>温周期现象</strong>：<u>植物对昼夜温度周期性变化的反应。</u></p><p><strong>顶端优势</strong>：<u>植物顶端在生长上占有优势的现象。</u></p><p><strong>细胞全能性</strong>：<u>指植物体的每个细胞携带一个完整基因组，并具有发育成完整植株的潜在能力。</u></p><p><strong>光形态建成</strong>：<u>光控制植物生长、发育和分化的过程。</u></p><p><strong>光敏色素</strong>：<u>植物体内存在的一种吸收红光-远红光可逆转换的光受体（色素蛋白质）。</u></p><p><strong>生理钟</strong>：<u>又称生物钟。指植物内生节奏调节的近似24小时的周期性变化节律。</u></p><p><strong>生长大周期</strong>：<u>植物在不同生育时期的生长速率表现出慢-快-慢的变化规律，呈现“S”型的生长曲线，这个过程称生长大周期。</u></p><p><strong>向性运动</strong>：<u>指外界对植物单向刺激所引起的定向生长运动。</u></p><p><strong>感性运动</strong>：<u>指外界对植物不定向刺激所引起的运动。</u></p><h3 id="问答题-v13"><a class="header-anchor" href="#问答题-v13"></a>问答题</h3><h4 id="种子萌发时，有机物质发生哪些生理生化变化？-v2"><a class="header-anchor" href="#种子萌发时，有机物质发生哪些生理生化变化？-v2"></a>种子萌发时，有机物质发生哪些生理生化变化？</h4><ul><li><u>淀粉的转化：淀粉在淀粉酶、麦芽糖酶或淀粉磷酸化酶作用下转变成葡萄糖（或磷酸葡萄糖）。</u></li><li><u>脂肪的转化：脂肪在脂肪酶作用下转变为甘油和脂肪酸，再进一步转化为糖。</u></li><li><u>蛋白质的转化：胚乳或子叶内贮藏的蛋白质在蛋白酶和肽酶的催化下，分解为氨基酸。</u></li></ul><h4 id="水稻种子萌发时，表现出“干长根，湿长芽”现象的原因何在？-v2"><a class="header-anchor" href="#水稻种子萌发时，表现出“干长根，湿长芽”现象的原因何在？-v2"></a>水稻种子萌发时，表现出“干长根，湿长芽”现象的原因何在？</h4><p><u>“干长根，湿长芽”现象是由于根和胚芽鞘的生长所要求的含氧量不同所致。</u></p><p><u>根的生长，既有细胞的伸长和扩大，也包括细胞分裂，而细胞分裂需要有氧呼吸提供能量和重要的中间产物。因而水多、氧不足时，根的生长受到抑制。但是胚芽鞘的生长，主要是细胞的伸长与扩大，在水层中，水分供应充足，故而芽生长较快。</u></p><p><u>此外，“干根湿芽”还与生长素含量有关。在水少供氧充足时，IAA氧化酶活性升高，使IAA含量降低，以至胚芽鞘细胞伸长和扩大受抑制，根生长受影响小。而在有水层的条件下，氧气少，IAA氧化酶活性降低，IAA含量升高，从而促进胚芽鞘细胞的伸长，并且IAA运输到根部，因根对IAA比较敏感，使根的生长受到抑制。</u></p><p><u>还有人认为，胚芽鞘呼吸酶以细胞色素氧化酶为主，与O<sub>2</sub>亲和力高，幼根则以抗氰氧化酶为主，与O<sub>2</sub>亲和力较低，因而在水多时，胚芽鞘生长快于幼根。</u></p><h4 id="高山上的树木为什么比平地生长的矮小？-v2"><a class="header-anchor" href="#高山上的树木为什么比平地生长的矮小？-v2"></a>高山上的树木为什么比平地生长的矮小？</h4><ul><li><u>高山上水分较少，土壤也较瘠薄，肥力较低，气温也较低，且风力较大，这些因素都不利于树木纵向生长；</u></li><li><u>高山顶上因云雾较少，空气中灰尘较少，所以光照较强，紫外光也较多，由于强光特别是紫外光抑制植物生长，因而高山上的树木生长缓慢而矮小。</u></li></ul><h4 id="试述光对植物生长的影响。-v2"><a class="header-anchor" href="#试述光对植物生长的影响。-v2"></a>试述光对植物生长的影响。</h4><p><u>光对植物生长的影响是多方面的，主要有下列几方面：</u></p><ul><li><u>光是光合作用的能源和启动者，为植物的生长提供有机营养和能源；</u></li><li><u>光控制植物的形态建成，即叶的伸展扩大，茎的高矮，分枝的多少、长度、根冠比等都与光照强弱和光质有关；</u></li><li><u>日照时数影响植物生长与休眠。绝大多数多年生植物都是长日照条件促进生长、短日照条件诱导休眠；</u></li><li><u>光影响种子萌发，需光种子的萌发受光照的促进，而需暗种子的萌发则受光抑制，</u></li><li><u>此外，一些豆科植物叶片的昼开夜合，气孔运动等都受光的调节。</u></li></ul><h4 id="简述根和地上部分生长的相关性如何？-v2"><a class="header-anchor" href="#简述根和地上部分生长的相关性如何？-v2"></a>简述根和地上部分生长的相关性如何？</h4><p><u>根和地上部分的关系是既互相促进、互相依赖，又互相矛盾、互相制约的。</u></p><p><u>根系生长需要地上部供给光合产物、生长素和维生素，而地上部分生长又需根部吸收的水分、矿质，根部合成的多种氨基酸和细胞分裂素等。这就是两者相互依存、互相促进的一面，所以树大根深，根深叶茂。</u></p><p><u>但两者又有相互矛盾，相互制约的一面，例如过分旺盛的地上部分的生长会抑制地下部分的生长，只有两者的比例比较适当，才能获得高产。</u></p><h4 id="常言道：“根深叶茂”是何道理？-v2"><a class="header-anchor" href="#常言道：“根深叶茂”是何道理？-v2"></a>常言道：“根深叶茂”是何道理？</h4><p><u>植物“根深叶茂”原因如下：</u></p><ul><li><u>地上部分生长需要的水分和矿物质主要是由根系供给的，另外根系还能合成多种氨基酸、细胞分裂素、生物碱等供应地上部分，因此，根系发育得好，对地上部分生长也有利。</u></li><li><u>植物地上部分对根的生长也有促进作用，叶片中制造的糖类、维生素等供应给根以利根的生长。因此，地上部分长不好，根系也长不好。</u></li></ul><h4 id="一般认为光敏色素分布在细胞什么地方？Pr型和Pfr型的光学特性有何不同？-v2"><a class="header-anchor" href="#一般认为光敏色素分布在细胞什么地方？Pr型和Pfr型的光学特性有何不同？-v2"></a>一般认为光敏色素分布在细胞什么地方？Pr型和Pfr型的光学特性有何不同？</h4><p><u>一般认为光敏色素与膜系统结合，分布在质膜、线粒体膜、核膜、叶绿体膜和内质网膜上。</u></p><p><u>Pr型的吸收高峰在660nm，Pfr型的吸收高峰在730nm，两类型光敏色素在不同光谱作用下可互相转换，当Pr型吸收660nm红光后就转变为Pfr，而Pfr吸收730nm远红光后会转为Pr 型。</u></p><h4 id="关于光敏色素作用机理的基因调节假说内容如何？-v2"><a class="header-anchor" href="#关于光敏色素作用机理的基因调节假说内容如何？-v2"></a>关于光敏色素作用机理的基因调节假说内容如何？</h4><p><u>在接受红光照射后，Pfr型经过一系列过程，将信号转移到基因，活化或抑制某些特定基因，使转录出单股mRNA的速度发生改变，mRNA翻译成特殊蛋白质（酶），最后表现出形态建成。研究证明，多种酶的活性通过光敏色素受光调节，如PAL、NR等。蛋白质磷酸化受Ca<sup>2+</sup>-CaM调节，它可能是连接光敏色素的光活化和基因表达的中间步骤。</u></p><h4 id="为什么横放的茎会背地生长，而横放的根却向地生长。-v2"><a class="header-anchor" href="#为什么横放的茎会背地生长，而横放的根却向地生长。-v2"></a>为什么横放的茎会背地生长，而横放的根却向地生长。</h4><p><u>根和茎横放后，其体内的生长素由于重力的作用，造成背地面少于向地面，由于根较茎对生长的敏感性强，因此，向地面的茎由于生长素浓度高生长快，因此向上弯曲，而向地面的根由于生长素浓度高而生长受抑制，因此根向下弯曲生长。</u></p><h2 id="植物的生殖生理-v2"><a class="header-anchor" href="#植物的生殖生理-v2"></a>植物的生殖生理</h2><h3 id="名词解释-v14"><a class="header-anchor" href="#名词解释-v14"></a>名词解释</h3><p><strong>春化作用</strong>：<u>低温促进植物开花的作用。</u></p><p><strong>去春化作用</strong>：<u>已春化的植物或萌动种子，在春化过程结束之前，如置于高温条件下，春化效果即行消失，这种现象叫去春化作用。</u></p><p><strong>光周期与光周期现象</strong>：<u>在一天中，白天和黑夜的相对长度叫光周期。植物对光周期的反应叫光周期现象。</u></p><p><strong>临界日长</strong>：<u>诱导短日植物开花所需的最长日照时数，或诱导长日植物开花所需的最短日照时数。</u></p><p><strong>长日植物</strong>：<u>日长必须长于临界日长才能开花的植物。</u></p><p><strong>短日植物</strong>：<u>日长必须小于临界日长才能开花的植物。</u></p><p><strong>日中性植物</strong>：<u>在任何日照长度下都能开花的植物。</u></p><p><strong>花粉识别蛋白</strong>：<u>能够感受柱头上感受蛋白的刺激而决定花粉是否萌发，存在于花粉外壁上的一种膜蛋白。识别蛋白是一种糖蛋白。</u></p><h3 id="问答题-v14"><a class="header-anchor" href="#问答题-v14"></a>问答题</h3><h4 id="说明光周期现象与植物地理起源和分布的关系，以及在生产上的应用？-v2"><a class="header-anchor" href="#说明光周期现象与植物地理起源和分布的关系，以及在生产上的应用？-v2"></a>说明光周期现象与植物地理起源和分布的关系，以及在生产上的应用？</h4><p><u>植物光周期现象的形成，是长期适应该地区自然光周期的结果。纬度不同，不同光周期类型的植物分布亦不同。</u></p><ul><li><u>在低纬度地区，因为没有长日照条件，所以只有短日植物。</u></li><li><u>在高纬度地区，适于长日植物生长，所以这里分布着长日植物。</u></li><li><u>在中纬度地区（温度），长日照与短日照条件都有，因此长日植物与短日植物均有分布。</u></li></ul><p><u>所有这些都与原产地生长季节的日照条件相适应。</u></p><p><u>光周期现象可应用于：</u></p><ul><li><u>正确地引种栽培</u><ul><li><u>了解被引进品种对光周期的反应类型；</u></li><li><u>了解原产地与引种地日照条件的差异；</u></li><li><u>考虑被引进作物收获的是营养体，还是收获果实或种子。</u></li></ul></li><li><u>在育种上应用</u><ul><li><u>选育对光周期不敏感的植物；</u></li><li><u>杂交时控制光照时间，克服花期不遇。</u></li></ul></li><li><u>在蔬菜、花卉栽培上应用</u><ul><li><u>栽种叶菜、根菜类，不满足其对光周期的要求则抑制开花；</u></li><li><u>收获的是花菜、果菜类，尽量满足对日照的要求，促进开花；</u></li><li><u>为使菊花（短日植物）提前开花，可进行遮光处理。</u></li></ul></li></ul><h4 id="春化作用在农业生产实践中有何应用价值-v2"><a class="header-anchor" href="#春化作用在农业生产实践中有何应用价值-v2"></a>春化作用在农业生产实践中有何应用价值 ?</h4><ol><li><u>人工春化处理</u><ul><li><u>用于春天补种冬小麦；</u></li><li><u>在育种工作中利用春化处理，可以在一年中培育 3~4 代冬性作物，加速育种过程；</u></li><li><u>为了避免春季“倒春寒”对春小麦的低温伤害，可对种子进行人工春化处理后适当晚播，使之在缩短生育期的情况下正常成熟。</u></li></ul></li><li><u>调种引种，引种时应注意原产地所处的纬度，了解品种对低温的要求。若将北方的品种引种到南方，就可能因当地温度较高而不能顺利通过春化阶段，使植物只进行营养生长而不开花结实，造成不可弥补的损失。</u></li><li><u>控制花期</u><ul><li><u>如低温处理可以使秋播的一、二年生草本花卉改为春播，当年开花；</u></li><li><u>对以营养器官为收获对象的植物，如洋葱、当归等，可用解除春化的方法，抑制开花，延长营养生长，从而增加产量和提高品质。</u></li></ul></li></ol><h4 id="肉质果实成熟时发生了哪些生理生化变化？-v2"><a class="header-anchor" href="#肉质果实成熟时发生了哪些生理生化变化？-v2"></a>肉质果实成熟时发生了哪些生理生化变化？</h4><ol><li><u>果实变甜。 果实成熟后期，淀粉可以转变成为可溶性糖，使果实变甜。</u></li><li><u>酸味减少。未成熟的果实中积累较多的有机酸。在果实成熟过程中，有机酸含量下降，这是因为：</u><ul><li><u>有的转变为糖；</u></li><li><u>有的作为呼吸底物氧化为CO<sub>2</sub>和H<sub>2</sub>O；</u></li><li><u>有些则被Ca<sup>2+</sup>、K<sup>+</sup>等所中和。</u></li></ul></li><li><u>涩味消失。果实成熟时，单宁可被过氧化物酶氧化成无涩味的过氧化物，或单宁凝结成不溶于水的胶状物质，涩味消失。</u></li><li><u>香味产生。主要是一些芳香族和脂肪族的酯，还有一些特殊的醛类，如桔子中柠檬醛可以产生香味。</u></li><li><u>由硬变软。这与果肉细胞壁中层的果胶质水解为可溶性的果酸有关。</u></li><li><u>色泽变艳。果皮由绿色变为黄色，是由干果皮中叶绿素逐渐破坏而失绿，类胡萝素仍存在，呈现黄色，或因花色素形成而呈现红色。</u></li></ol><h4 id="到了深秋，树木的芽为什么会进入休眠状态？-v2"><a class="header-anchor" href="#到了深秋，树木的芽为什么会进入休眠状态？-v2"></a>到了深秋，树木的芽为什么会进入休眠状态？</h4><p><u>到了秋天导致树木形成休眠芽进入休眠状态的原因，主要是由于日照时数的缩短所引起的。</u></p><p><u>秋天的短日照作为进入休眠的信号，这一信号由叶片中的光敏色素感受后，便促进甲羟戊酸合成ABA（脱落酸），并转移到生长点，抑制mRNA和tRNA的生物合成因而也就抑制了蛋白质与酶的生物合成，进而抑制芽的生长，使芽进入休眠状态。</u></p><h4 id="呼吸跃变与果实贮藏的关系如何？在生产上有何指导意义？-v2"><a class="header-anchor" href="#呼吸跃变与果实贮藏的关系如何？在生产上有何指导意义？-v2"></a>呼吸跃变与果实贮藏的关系如何？在生产上有何指导意义？</h4><p><u>果实呼吸跃变是果实成熟的一种特征，大多数果实成熟是与呼吸的跃变相伴随的，呼吸跃变结束即意味着果实已达成熟。</u></p><p><u>在果实贮藏或运输中，可以通过降低温度，推迟呼吸跃变发生的时间，另一是增加周围CO<sub>2</sub>的浓度，降低呼吸跃变发生的强度，这样就可达到延迟成熟，保持鲜果，防止腐烂的目的。</u></p><h4 id="论述种子休眠的原因及其解除休眠的措施-v2"><a class="header-anchor" href="#论述种子休眠的原因及其解除休眠的措施-v2"></a>论述种子休眠的原因及其解除休眠的措施</h4><p><u>种子休眠的原因：</u></p><ul><li><u>种皮（果皮）的限制；</u></li><li><u>种子未完成后熟；</u></li><li><u>抑制物质的作用</u></li></ul><p><u>解除休眠的措施有：机械破损，温度处理，化学处理，清水冲洗，层积处理</u></p>]]></content>
      
      
      <categories>
          
          <category> 生物学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 植物生理学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java注解和反射</title>
      <link href="2020/06/13/Java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/"/>
      <url>2020/06/13/Java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<p>Java注解和反射</p><hr><h2 id="反射"><a class="header-anchor" href="#反射"></a>反射</h2><p>Java 反射技术应用广泛，它能够配置：类的全限定名、方法和参数，完成对象的初始化，甚至是反射某些方法。可以大大增强 Java 的可配置性。</p><p>反射：框架设计的灵魂<br>框架：半成品软件。可以在框架的基础上进行软件开发，简化编码<br>反射：将类的各个组成部分封装为其他对象，这就是反射机制</p><h3 id="通过反射构建对象"><a class="header-anchor" href="#通过反射构建对象"></a>通过反射构建对象</h3><p>在 Java 中允许通过反射配置信息构建对象，比如 <code>ReflectServicelmpl</code> 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectServiceImpl</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">System.err.println(<span class="string">&quot;Hello &quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后通过反射的方法去构建它</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ReflectServiceImpl <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ReflectServiceImpl object = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        object = (ReflectServiceImpl) Class.forName(<span class="string">&quot;com.lean.ssm.chapter2.reflect.ReflectServiceImpl&quot;</span>)</span><br><span class="line">            .newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException | InstantiationException | IllegalAccessException ex) &#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2020年7月10日</p><h3 id="获取Class对象"><a class="header-anchor" href="#获取Class对象"></a>获取Class对象</h3><ul><li><p>源代码阶段：<code>Class.forName(“全类名”)</code>将字节码文件加载进内存，返回Class对象，多用于配置文件</p></li><li><p>已经加载到内存中<code>类名.class</code>，多用于参数传递</p></li><li><p><code>对象.getClass</code>，多用于对象的获取字节码的方式</p></li></ul><blockquote><p>同一个字节码文件在一次程序运行中，只会加载一次，不论通过哪一种方式创建</p></blockquote><h3 id="获取成员变量-Field"><a class="header-anchor" href="#获取成员变量-Field"></a><strong>获取成员变量(Field)</strong></h3><ul><li><code>getFields()</code>获取public修饰的成员变量</li><li><code>getField()</code>获取指定名称的public修饰的成员变量</li><li><code>getDeclaredFields()</code>获取所有的成员变量，不考虑修饰符</li></ul><blockquote><p>操作：</p><ol><li>设置值<code>set()</code></li><li>获取值<code>get()</code></li><li>忽略访问权限修饰符的安全检查<code>setAccessible(true)</code></li></ol></blockquote><h3 id="获取构造方法"><a class="header-anchor" href="#获取构造方法"></a><strong>获取构造方法</strong></h3><p>构造方法用来创建对象</p><p><code>getConstructor()</code>获取构造方法</p><p><code>newInstance()</code>创建对象</p><h3 id="获取成员方法"><a class="header-anchor" href="#获取成员方法"></a><strong>获取成员方法</strong></h3><p>成员方法用来执行方法</p><p><code>getMethod()</code>获取成员方法</p><p><code>invoke()</code>执行方法</p><h2 id="注解-Annotation"><a class="header-anchor" href="#注解-Annotation"></a>注解 Annotation</h2><p>JDK1.5之后的新特性</p><h3 id="基本内置注解"><a class="header-anchor" href="#基本内置注解"></a>基本内置注解</h3><ul><li><p><code>@Override</code>：检测被标注的方法是否继承于父类(接口)</p></li><li><p><code>Deprecated</code>：被注解的内容已过时</p></li><li><p><code>@SuppressWarning</code>：压制警告编译器</p><blockquote><p>一般传递参数<code>all</code>  <code>@SuppressWarning(“all”)</code></p></blockquote></li></ul><h3 id="定义注解"><a class="header-anchor" href="#定义注解"></a>定义注解</h3><p>格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">元注解</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> 注解名称&#123;</span><br><span class="line">    属性列表</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质：是一个接口，默认继承Annotation接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> 注解名称 <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">annotation</span>.<span class="title">Annotation</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>属性： 接口中的抽象方法</p><ol><li><p>不能定义<code>void</code>方法</p></li><li><p>定义了属性，使用时需要对属性赋值，定义时使用default，则使用默认值</p></li><li><p>如果只有一个属性且属性名时<code>value</code>，定义时则可以省略<code>value</code>直接赋值</p></li><li><p>数组赋值需要使用<code>&#123;&#125;</code>包裹，只有一个值时可以省略<code>&#123;&#125;</code></p></li></ol><h4 id="元注解"><a class="header-anchor" href="#元注解"></a>元注解</h4><p>用于描述注解的注解</p><p><strong><code>@Target</code>：描述注解能够作用的位置</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE,TYPE_PARAMETER,TYPE_USE&#125;)</span></span><br></pre></td></tr></table></figure><blockquote><p>ElementType取值：</p><ul><li>TYPE：可以作用于类上</li><li>METHOD：可以作用于方法上</li><li>FIELD：可以作用于成员方法上</li></ul></blockquote><p><strong><code>@Retention</code>：描述注解被保留的阶段</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="comment">//当前被描述的注解，会保留到class字节码文件中，并被JVM读取到</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.CLASS)</span><span class="comment">//当前被描述的注解，会保留到class字节码文件中但不会被JVM读取到</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span><span class="comment">//不会保留到class字节码文件</span></span><br></pre></td></tr></table></figure><p><strong><code>@Documented</code>：描述注解是否被抽取到API文档中</strong></p><p><strong><code>@Inherited</code>：描述注解是否被子类继承</strong></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java后端Linux环境搭建</title>
      <link href="2020/06/11/Java%E5%90%8E%E7%AB%AFLinux%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>2020/06/11/Java%E5%90%8E%E7%AB%AFLinux%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>参考<a href="https://github.com/hansonwang99/JavaCollection">文档</a>，基于CentOS 7.7.1908</p><hr><h2 id="安装须知"><a class="header-anchor" href="#安装须知"></a>安装须知</h2><h3 id="安装文件"><a class="header-anchor" href="#安装文件"></a>安装文件</h3><p>准备以下软件的Linux安装文件</p><ul><li>Maven</li><li>Tomcat</li><li>Zookeeper</li><li>Git</li><li>JDK</li><li>Kafka</li><li>MySQL</li><li>Nginx</li><li>Node</li><li>Python</li><li>Redis</li></ul><h3 id="安装的基本步骤"><a class="header-anchor" href="#安装的基本步骤"></a>安装的基本步骤</h3><ol><li>解压安装文件至/usr/local/下创建的文件夹下</li><li>修改软件的配置文件（可选）</li><li>配置软件路径到/etc/profile文件中，刷新环境变量<code>source /ect/profile</code></li><li>查看软件安装是否成功，查看软件的版本</li></ol><h3 id="各软件版本查看方式整理"><a class="header-anchor" href="#各软件版本查看方式整理"></a>各软件版本查看方式整理</h3><ol><li><p>Git：<code>git --version</code></p></li><li><p>Java：<code>java -version</code></p></li><li><p>Node：<code>node -v</code>、<code>npm version</code>、<code>npx -v</code></p></li><li><p>Python：<code>python -V</code>、<code>python3 -V</code>（注意<code>V</code>大写）</p></li><li><p>Maven：<code>mvn -v</code></p></li><li><p>Nginx：<code>nginx -v</code></p></li></ol><h2 id="Git"><a class="header-anchor" href="#Git"></a>Git</h2><h3 id="通过yum包管理器安装"><a class="header-anchor" href="#通过yum包管理器安装"></a>通过yum包管理器安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install git</span><br></pre></td></tr></table></figure><p>通过<code>git --version</code>查看是否安装成功</p><p>安装的版本是<code>git version 1.8.3.1</code></p><h2 id="JDK安装"><a class="header-anchor" href="#JDK安装"></a>JDK安装</h2><p>安装Oracle JDK</p><h2 id="node环境安装"><a class="header-anchor" href="#node环境安装"></a>node环境安装</h2><p><img src="http://img.whl123456.top/image/image-20200611002658715.png" alt="node"></p><p><img src="http://img.whl123456.top/image/image-20200611002658715.png" alt="image-20200611002658715"></p><h2 id="Maven"><a class="header-anchor" href="#Maven"></a>Maven</h2><h3 id="遇到的问题"><a class="header-anchor" href="#遇到的问题"></a>遇到的问题</h3><p>在配置Maven环境变量中失误在<code>$MAVEN_HOME</code>和<code>/bin:$path</code>之间打了个空格</p><p><img src="http://img.whl123456.top/image/image-20200612155538407.png" alt="image-20200612155538407"></p><p>在退出vim，执行<code>source /etc/profile</code>报错</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/libexec/grepconf.sh: line 5: grep: command not found</span><br><span class="line">-bash: export: `/bin:/usr/local/sbin:/usr/sbin:/usr/local/node/node-v12.16.3-linux-x64/bin:/usr/local/maven/apache-maven-3.6.3:/root/bin:/usr/local/java/jdk1.8.0_161/bin&#x27;: not a valid identifier</span><br></pre></td></tr></table></figure><p>此后，导致如<code>ls</code>、<code>vim</code>等命令不能使用，也不能使用其他命令修改profile，可先执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=/bin:/usr/bin:$PATH</span><br></pre></td></tr></table></figure><p>临时更改环境变量在找出配置错误的环境变量并修改</p><h2 id="MySQL（多次安装失败）"><a class="header-anchor" href="#MySQL（多次安装失败）"></a>MySQL（多次安装失败）</h2><p>前提</p><p>卸载系统自带的Mariadb</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa|grep mariadb</span><br></pre></td></tr></table></figure><p>如果有Mariadb包，使用如下方式全部卸载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y remove 包名</span><br></pre></td></tr></table></figure><p>下载或者使用准备好的安装包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;dev.mysql.com&#x2F;get&#x2F;Downloads&#x2F;MySQL-5.7&#x2F;mysql-5.7.24-linux-glibc2.12-x86_64.tar.gz</span><br></pre></td></tr></table></figure><p>解压并重命名文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf /root/mysql-5.7.24-linux-glibc2.12-x86_64.tar.gz -C /usr/local/</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv mysql-5.7.24-linux-glibc2.12-x86_64 mysql</span><br></pre></td></tr></table></figure><p>创建MySQL用户和用户组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd mysql</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -g mysql mysql</span><br></pre></td></tr></table></figure><p>创建data目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/local/mysql/data</span><br></pre></td></tr></table></figure><p>修改MySQL目录的归属用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R mysql:mysql /usr/local/mysql</span><br></pre></td></tr></table></figure><p>配置MySQL的配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/my.cnf</span><br></pre></td></tr></table></figure><p>加入内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[mysql]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置mysql客户端默认字符集</span></span><br><span class="line">default-character-set=utf8</span><br><span class="line">socket=/var/lib/mysql/mysql.sock</span><br><span class="line">[mysqld]</span><br><span class="line">skip-name-resolve</span><br><span class="line"><span class="meta">#</span><span class="bash">设置3306端⼝</span></span><br><span class="line">port = 3306</span><br><span class="line">socket=/var/lib/mysql/mysql.sock</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置mysql的安装⽬录</span></span><br><span class="line">basedir=/usr/local/mysql</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置mysql数据库的数据的存放⽬录</span></span><br><span class="line">datadir=/usr/local/mysql/data</span><br><span class="line"><span class="meta">#</span><span class="bash"> 允许最⼤连接数</span></span><br><span class="line">max_connections=200</span><br><span class="line"><span class="meta">#</span><span class="bash"> 服务端使⽤的字符集默认为8⽐特编码的latin1字符集</span></span><br><span class="line">character-set-server=utf8</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建新表时将使⽤的默认存储引擎</span></span><br><span class="line">default-storage-engine=INNODB</span><br><span class="line">lower_case_table_names=1</span><br><span class="line">max_allowed_packet=16M</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /var/lib/mysql</span><br><span class="line">chmod 777 /var/lib/mysql</span><br></pre></td></tr></table></figure><p>安装MySQL</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/mysql</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/mysqld --initialize --user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data</span><br></pre></td></tr></table></figure><p>此时遇到一个问题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mysqld: error while loading shared libraries: libaio.so.1: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure><p>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install libaio</span><br></pre></td></tr></table></figure><p>在重新</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/mysqld --initialize --user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data</span><br></pre></td></tr></table></figure><p>记下<code>root@localhost：</code>后的密码</p><p><img src="http://img.whl123456.top/image/image-20200612162005461.png" alt="image-20200612162005461"></p><p>启动MySQL</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysqld start</span><br></pre></td></tr></table></figure><p>报错无法启动MySQL，原因是MariaDB</p><p>对于以下报错，个人尝试多种方式都未能解决，故不使用MySQL转向MariaDB</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed to restart mysqld.service: Unit not found.</span><br></pre></td></tr></table></figure><p>问题2</p><p>使用的阿里云ECS，再一次修改MySQL配置文件后，无法使用Workbench远程连接，但可以使用VNC进行连接</p><p>阿里云ECS登录实例失败，原因：拒绝连接</p><p>问题未找到，最后无奈通过重新初始化磁盘才可以连接</p><h2 id="MariaDB"><a class="header-anchor" href="#MariaDB"></a>MariaDB</h2><p>MariaDB数据库管理系统是MySQL的一个分支，主要由开源社区在维护，采用GPL授权许可 MariaDB的目的是完全兼容MySQL，包括API和命令行，使之能轻松成为MySQL的代替品。</p><p>MariaDB由MySQL的创始人Michael Widenius（英语：Michael Widenius）主导开发，他早前曾以10亿美元的价格，将自己创建的公司MySQL AB卖给了SUN，此后，随着SUN被甲骨文收购，MySQL的所有权也落入Oracle的手中。</p><blockquote><p>MariaDB数据库安装<a href="https://www.jianshu.com/p/85ad52c88399">参考</a></p></blockquote><p>使用yum命令安装mariaDB</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install mariadb mariadb-server</span><br></pre></td></tr></table></figure><p>启动mariaDB</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start mariadb</span><br></pre></td></tr></table></figure><p>设置开机启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable mariadb</span><br></pre></td></tr></table></figure><p>进行简单相关配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql_secure_installation</span><br></pre></td></tr></table></figure><p><img src="http://img.whl123456.top/image/image-20200612205521591.png" alt="image-20200612205521591"></p><p>配置mariaDB字符集</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/my.cnf</span><br></pre></td></tr></table></figure><p>添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">init_connect&#x3D;&#39;SET collation_connection &#x3D; utf8_unicode_ci&#39;</span><br><span class="line">init_connect&#x3D;&#39;SET NAMES utf8&#39;</span><br><span class="line">character-set-server&#x3D;utf8</span><br><span class="line">collation-server&#x3D;utf8_unicode_ci</span><br><span class="line">skip-character-set-client-handshake</span><br></pre></td></tr></table></figure><p><img src="http://img.whl123456.top/image/image-20200612205634824.png" alt="image-20200612205634824"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/my.cnf.d/client.cnf</span><br></pre></td></tr></table></figure><p>添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">default-character-set&#x3D;utf8</span><br></pre></td></tr></table></figure><p><img src="http://img.whl123456.top/image/image-20200612205809998.png" alt="image-20200612205809998"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;my.cnf.d&#x2F;mysql-clients.cnf</span><br></pre></td></tr></table></figure><p>添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">default-character-set&#x3D;utf8</span><br></pre></td></tr></table></figure><p><img src="http://img.whl123456.top/image/image-20200612205933709.png" alt="image-20200612205933709"></p><p>重启mariadb</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mariadb</span><br></pre></td></tr></table></figure><p>登录mariaDB，查看MariaDB字符集</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">-</span>uroot <span class="operator">-</span>p</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> &quot;%character%&quot;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> &quot;%collation%&quot;;</span><br></pre></td></tr></table></figure><p>远程连接</p><p>在登录情况下输入以下SQL语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use mysql;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> host,<span class="keyword">user</span>,password <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><p><img src="http://img.whl123456.top/image/image-20200612210519878.png" alt="image-20200612210519878"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;为远程连接设置的密码&#x27;</span>；</span><br></pre></td></tr></table></figure><blockquote><p>参考<a href="https://www.cnblogs.com/lanuage/p/8179589.html">文章</a></p></blockquote><p>以Navicat为例连接远程MariaDB</p><p><img src="http://img.whl123456.top/image/image-20200612213409377.png" alt="image-20200612213409377"></p><h2 id="Nginx"><a class="header-anchor" href="#Nginx"></a>Nginx</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install nginx</span><br><span class="line"></span><br><span class="line">nginx -v</span><br></pre></td></tr></table></figure><p>查看安装目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ql nginx</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;logrotate.d&#x2F;nginx</span><br><span class="line">&#x2F;etc&#x2F;nginx&#x2F;fastcgi.conf</span><br><span class="line">&#x2F;etc&#x2F;nginx&#x2F;fastcgi.conf.default</span><br><span class="line">&#x2F;etc&#x2F;nginx&#x2F;fastcgi_params</span><br><span class="line">&#x2F;etc&#x2F;nginx&#x2F;fastcgi_params.default</span><br><span class="line">&#x2F;etc&#x2F;nginx&#x2F;koi-utf</span><br><span class="line">&#x2F;etc&#x2F;nginx&#x2F;koi-win</span><br><span class="line">&#x2F;etc&#x2F;nginx&#x2F;mime.types</span><br><span class="line">&#x2F;etc&#x2F;nginx&#x2F;mime.types.default</span><br><span class="line">&#x2F;etc&#x2F;nginx&#x2F;nginx.conf</span><br><span class="line">&#x2F;etc&#x2F;nginx&#x2F;nginx.conf.default</span><br><span class="line">&#x2F;etc&#x2F;nginx&#x2F;scgi_params</span><br><span class="line">&#x2F;etc&#x2F;nginx&#x2F;scgi_params.default</span><br><span class="line">&#x2F;etc&#x2F;nginx&#x2F;uwsgi_params</span><br><span class="line">&#x2F;etc&#x2F;nginx&#x2F;uwsgi_params.default</span><br><span class="line">&#x2F;etc&#x2F;nginx&#x2F;win-utf</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;nginx-upgrade</span><br><span class="line">&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;nginx.service</span><br><span class="line">&#x2F;usr&#x2F;lib64&#x2F;nginx&#x2F;modules</span><br><span class="line">&#x2F;usr&#x2F;sbin&#x2F;nginx</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;doc&#x2F;nginx-1.16.1</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;doc&#x2F;nginx-1.16.1&#x2F;CHANGES</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;doc&#x2F;nginx-1.16.1&#x2F;README</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;doc&#x2F;nginx-1.16.1&#x2F;README.dynamic</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;doc&#x2F;nginx-1.16.1&#x2F;UPGRADE-NOTES-1.6-to-1.10</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;licenses&#x2F;nginx-1.16.1</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;licenses&#x2F;nginx-1.16.1&#x2F;LICENSE</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;man&#x2F;man3&#x2F;nginx.3pm.gz</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;man&#x2F;man8&#x2F;nginx-upgrade.8.gz</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;man&#x2F;man8&#x2F;nginx.8.gz</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;404.html</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;50x.html</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;en-US</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;icons</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;icons&#x2F;poweredby.png</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;img</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;nginx-logo.png</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;poweredby.png</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;vim&#x2F;vimfiles&#x2F;ftdetect&#x2F;nginx.vim</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;vim&#x2F;vimfiles&#x2F;ftplugin&#x2F;nginx.vim</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;vim&#x2F;vimfiles&#x2F;indent&#x2F;nginx.vim</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;vim&#x2F;vimfiles&#x2F;syntax&#x2F;nginx.vim</span><br><span class="line">&#x2F;var&#x2F;lib&#x2F;nginx</span><br><span class="line">&#x2F;var&#x2F;lib&#x2F;nginx&#x2F;tmp</span><br><span class="line">&#x2F;var&#x2F;log&#x2F;nginx</span><br></pre></td></tr></table></figure><p>启动nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;sbin&#x2F;nginx</span><br></pre></td></tr></table></figure><p>设置配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</span><br></pre></td></tr></table></figure><p>停止服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;sbin&#x2F;nginx -s stop</span><br></pre></td></tr></table></figure><p>重新加载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;sbin&#x2F;nginx -s reload</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet</title>
      <link href="2020/05/26/JavaEE-02-Servlet/"/>
      <url>2020/05/26/JavaEE-02-Servlet/</url>
      
        <content type="html"><![CDATA[<p>JavaWeb之Servlet，开发动态Web的技术</p><hr><h2 id="Servlet简介"><a class="header-anchor" href="#Servlet简介"></a>Servlet简介</h2><p>Servlet其实就是一个遵循Servlet开发的java类。Servlet是由服务器调用的，运行在服务器端。</p><p>开发Servlet需要实现的步骤：</p><ul><li>编写一个类实现Servlet接口</li><li>把开发好的Java类部署到Web服务器中</li></ul><h2 id="Tomcat下的Servlet案例"><a class="header-anchor" href="#Tomcat下的Servlet案例"></a>Tomcat下的Servlet案例</h2><p>启动Tomcat，进入http://localhost:8080/examples/</p><p>可以看到Tomcat为我们提供的Examples</p><p><img src="http://img.whl123456.top/image/Examples.png" alt="Examples"></p><p>选择<a href="http://localhost:8080/examples/servlets">Servlets examples</a>，就可以看到实例以及源码</p><p>选择<a href="http://localhost:8080/examples/servlets/helloworld.html">HelloWorld Example</a>源码可以看到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ServletException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        out.println(<span class="string">&quot;&lt;html&gt;&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;&lt;head&gt;&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;&lt;title&gt;Hello World!&lt;/title&gt;&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;&lt;/head&gt;&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;&lt;body&gt;&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;&lt;h1&gt;Hello World!&lt;/h1&gt;&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;&lt;/body&gt;&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;&lt;/html&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初使用Servlet"><a class="header-anchor" href="#初使用Servlet"></a>初使用Servlet</h2><p>使用Maven将Servlet有关的包</p><p>去<a href="https://mvnrepository.com/">Maven资源库网站</a>寻找需要的包，搜索servlet api（<a href="https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api">搜索结果</a>）</p><p>已<a href="https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api/4.0.1">4.0.1为例</a>，复制Maven格式的项目依赖到pom.xml中的<code>&lt;dependencies&gt;...&lt;/dependencies&gt;</code>内</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--作用域--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在IEDA中刷新本地项目依赖的pom.xml，便会自动下载需要的依赖</p><hr><p>创建Servlet项目</p><p><img src="http://img.whl123456.top/image/image-20200526224208126.png" alt="image-20200526224208126"></p><p>在HelloServlet文件中输入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IDEA会进行自动导包</p><hr><p>重写<code>doGet</code>和<code>doPost</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">        <span class="comment">//响应的类型：HTML</span></span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">        resp.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">//获取响应的输出流</span></span><br><span class="line">        PrintWriter out = resp.getWriter();  <span class="comment">//resp.getOutputStream()</span></span><br><span class="line">        out.println(<span class="string">&quot;&lt;html&gt;&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;&lt;head&gt;&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;&lt;title&gt;Hello World!&lt;/title&gt;&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;&lt;/head&gt;&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;&lt;body&gt;&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;&lt;h1&gt;Hello World!&lt;/h1&gt;&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;&lt;/body&gt;&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;&lt;/html&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p>去<code>webapp→WEB-INF→web.xml</code>注册Servlet，将以下内容放入<code>&lt;web-app&gt;...&lt;/web-app&gt;</code>内</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--注册Servlet--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>helloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>top.whl123456.servlet.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--设置Mapping（映射）--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>helloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--请求路径--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><p>启动Tomcat，访问web.xml中设置的映射<a href="http://localhost:8080/hello">http://localhost:8080/hello</a>便可以进入到动态页面</p><p>到此的<a href="https://github.com/Lanqilu/JavaWeb/commit/98152c4fa0058deed28a3fd48c61e000fec65b65">项目源码</a>已在GitHub中</p><h2 id="HelloServlet"><a class="header-anchor" href="#HelloServlet"></a>HelloServlet</h2><ol><li><p>创建一个普通Maven项目，删除src文件夹</p></li><li><p>在pom.xml文件中添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>通过创建Module建立子模块</p><blockquote><p>在父项目中的pom.xml中自动生成<code>&lt;modules&gt;...&lt;/modules&gt;</code></p><p>在子项目中的pom.xml中自动生成<code>&lt;parent&gt;...&lt;/parent&gt;</code></p><p>父项目中的jar包子项目可以直接使用，反之不可以</p></blockquote></li><li><p>更换web.xml文件内容至最新内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee</span></span></span><br><span class="line"><span class="tag"><span class="string">                      http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">metadata-complete</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在main文件夹中建立java和resources文件夹，文件结构图如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">JavaWeb02</span><br><span class="line"> ├── JavaWeb02.iml</span><br><span class="line"> ├── pom.xml</span><br><span class="line"> └── servlet01</span><br><span class="line">     ├── pom.xml</span><br><span class="line">     └── src</span><br><span class="line">         └── main</span><br><span class="line">             ├── java</span><br><span class="line">             ├── resources</span><br><span class="line">             └── webapp</span><br><span class="line">                 ├── index.jsp</span><br><span class="line">                 └── WEB-INF</span><br><span class="line">                     └── web.xml</span><br></pre></td></tr></table></figure></li><li><p>创建一个简单的Servlet Demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Servlet有两个默认的实现类：HttpServlet，GenericServlet</p></blockquote></li></ol><hr><ol start="7"><li><p>重写<code>doPost()</code>和<code>doGet()</code>方法</p><blockquote><p>IDEA中重写方法的快捷键是Ctrl+O</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//get和post只是请求方式的不同，业务逻辑一样，可以相互调用</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">//ServletOutputStream outputStream = resp.getOutputStream();</span></span><br><span class="line">    PrintWriter writer = resp.getWriter();<span class="comment">//响应流</span></span><br><span class="line">    writer.print(<span class="string">&quot;hello,servlet&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPut</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    doGet(req, resp);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>编写Servlet的映射，见上节配置</p></li><li><p>配置Tomcat，配置项目发布路径</p><blockquote><p>对于artifact配置可参考，该<a href="https://www.cnblogs.com/gbb123/p/6782227.html">博客</a></p></blockquote></li></ol><h2 id="ServletContext"><a class="header-anchor" href="#ServletContext"></a>ServletContext</h2><h2 id="HttpServletResponse"><a class="header-anchor" href="#HttpServletResponse"></a>HttpServletResponse</h2><p>Web服务器接收到客户端的Http请求，针对这个请求，分别创建一个代表请求的 HttpServletRequest对象，代表响应的一个 HttpServletResponse</p><ul><li>获取客户端请求的参数：HttpServletRequest</li><li>给客户端响应一些信息：HttpServletResponse</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpServletResponse</span> <span class="keyword">extends</span> <span class="title">ServletResponse</span> </span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.whl123456.top/image/servletResponse.png" alt="HttpServletResponse&amp;ServletResponse"></p><h3 id="分类"><a class="header-anchor" href="#分类"></a>分类</h3><p>向浏览器发送数据的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServletResponse</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletOutputStream <span class="title">getOutputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> PrintWriter <span class="title">getWriter</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向浏览器发送响应头的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServletResponse</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCharacterEncoding</span><span class="params">(String charset)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentLength</span><span class="params">(<span class="keyword">int</span> len)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentLengthLong</span><span class="params">(<span class="keyword">long</span> len)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentType</span><span class="params">(String type)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpServletResponse</span> <span class="keyword">extends</span> <span class="title">ServletResponse</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDateHeader</span><span class="params">(String name, <span class="keyword">long</span> date)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addDateHeader</span><span class="params">(String name, <span class="keyword">long</span> date)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHeader</span><span class="params">(String name, String value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addHeader</span><span class="params">(String name, String value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIntHeader</span><span class="params">(String name, <span class="keyword">int</span> value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addIntHeader</span><span class="params">(String name, <span class="keyword">int</span> value)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>状态码常量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpServletResponse</span> <span class="keyword">extends</span> <span class="title">ServletResponse</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SC_CONTINUE = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SC_SWITCHING_PROTOCOLS = <span class="number">101</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SC_OK = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SC_CREATED = <span class="number">201</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SC_ACCEPTED = <span class="number">202</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SC_NON_AUTHORITATIVE_INFORMATION = <span class="number">203</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SC_NO_CONTENT = <span class="number">204</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SC_RESET_CONTENT = <span class="number">205</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SC_PARTIAL_CONTENT = <span class="number">206</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SC_MULTIPLE_CHOICES = <span class="number">300</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SC_MOVED_PERMANENTLY = <span class="number">301</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SC_MOVED_TEMPORARILY = <span class="number">302</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SC_FOUND = <span class="number">302</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SC_SEE_OTHER = <span class="number">303</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SC_NOT_MODIFIED = <span class="number">304</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SC_USE_PROXY = <span class="number">305</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SC_TEMPORARY_REDIRECT = <span class="number">307</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SC_BAD_REQUEST = <span class="number">400</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SC_UNAUTHORIZED = <span class="number">401</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SC_PAYMENT_REQUIRED = <span class="number">402</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SC_FORBIDDEN = <span class="number">403</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SC_NOT_FOUND = <span class="number">404</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SC_METHOD_NOT_ALLOWED = <span class="number">405</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SC_NOT_ACCEPTABLE = <span class="number">406</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SC_PROXY_AUTHENTICATION_REQUIRED = <span class="number">407</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SC_REQUEST_TIMEOUT = <span class="number">408</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SC_CONFLICT = <span class="number">409</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SC_GONE = <span class="number">410</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SC_LENGTH_REQUIRED = <span class="number">411</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SC_PRECONDITION_FAILED = <span class="number">412</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SC_REQUEST_ENTITY_TOO_LARGE = <span class="number">413</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SC_REQUEST_URI_TOO_LONG = <span class="number">414</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SC_UNSUPPORTED_MEDIA_TYPE = <span class="number">415</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SC_REQUESTED_RANGE_NOT_SATISFIABLE = <span class="number">416</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SC_EXPECTATION_FAILED = <span class="number">417</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SC_INTERNAL_SERVER_ERROR = <span class="number">500</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SC_NOT_IMPLEMENTED = <span class="number">501</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SC_BAD_GATEWAY = <span class="number">502</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SC_SERVICE_UNAVAILABLE = <span class="number">503</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SC_GATEWAY_TIMEOUT = <span class="number">504</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SC_HTTP_VERSION_NOT_SUPPORTED = <span class="number">505</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常见应用"><a class="header-anchor" href="#常见应用"></a>常见应用</h3><ol><li>向浏览器输出消息</li><li>下载文件<ul><li>获取下载文件的路径</li><li>下载文件的文件名</li><li>浏览器支持</li><li>获取下载文件的输入流</li><li>创建缓冲区</li><li>获取OutPutStream对象</li><li>将文件OutPutStream流写入到buffer缓冲区</li><li>使用OutPutStream将缓冲区中的数据输出到客户端</li></ul></li></ol><h4 id="下载文件"><a class="header-anchor" href="#下载文件"></a>下载文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">fileServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//  获取下载文件的路径</span></span><br><span class="line">        String realPath = <span class="string">&quot;E:\\Desktop\\JavaWeb02\\response\\src\\main\\resources\\1.png&quot;</span>;</span><br><span class="line">        <span class="comment">//String realPath = this.getServletContext().getRealPath(filePath);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;下载文件的路径：&quot;</span>+ realPath);</span><br><span class="line">        <span class="comment">//  下载文件的文件名</span></span><br><span class="line">        String fileName = realPath.substring(realPath.lastIndexOf(<span class="string">&quot;\\&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//  浏览器支持</span></span><br><span class="line">        resp.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>,<span class="string">&quot;attachment;filename=&quot;</span>+ URLEncoder.encode(fileName,<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">        <span class="comment">//  获取下载文件的输入流</span></span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(realPath);</span><br><span class="line">        <span class="comment">//  创建缓冲区</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">//  获取OutPutStream对象</span></span><br><span class="line">        ServletOutputStream outputStream = resp.getOutputStream();</span><br><span class="line">        <span class="comment">//  将文件OutPutStream流写入到buffer缓冲区,使用OutPutStream将缓冲区中的数据输出到客户端</span></span><br><span class="line">        <span class="keyword">while</span> ((len=fileInputStream.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            outputStream.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  关闭流</span></span><br><span class="line">        fileInputStream.close();</span><br><span class="line">        outputStream.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="验证码功能"><a class="header-anchor" href="#验证码功能"></a>验证码功能</h4><ul><li>前端实现，js</li><li>后端实现，java图片类，生成一张图片</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">//浏览器5s自动刷新</span></span><br><span class="line">    resp.setHeader(<span class="string">&quot;refresh&quot;</span>,<span class="string">&quot;3&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在内存中创建图片</span></span><br><span class="line">    BufferedImage bufferedImage = <span class="keyword">new</span> BufferedImage(<span class="number">80</span>,<span class="number">20</span>,BufferedImage.TYPE_3BYTE_BGR);</span><br><span class="line">    <span class="comment">//得到图片</span></span><br><span class="line">    Graphics2D graphics = (Graphics2D) bufferedImage.getGraphics();<span class="comment">//笔</span></span><br><span class="line">    <span class="comment">//设置图片的背景颜色</span></span><br><span class="line">    graphics.setColor(Color.white);</span><br><span class="line">    graphics.fillRect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">80</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="comment">//给图片写数据</span></span><br><span class="line">    graphics.setColor(Color.BLUE);</span><br><span class="line">    graphics.setFont(<span class="keyword">new</span> Font(<span class="keyword">null</span>, Font.BOLD, <span class="number">20</span>));</span><br><span class="line">    graphics.drawString(makeNum(),<span class="number">0</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//告诉浏览器，这个请求用浏览器打开</span></span><br><span class="line">    resp.setContentType(<span class="string">&quot;image/jpeg&quot;</span>);</span><br><span class="line">    <span class="comment">//网站缓存，不让浏览器设置缓存</span></span><br><span class="line">    resp.setDateHeader(<span class="string">&quot;expires&quot;</span>,-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//缓存控制</span></span><br><span class="line">    resp.setHeader(<span class="string">&quot;Cache-Control&quot;</span>,<span class="string">&quot;no-cache&quot;</span>);</span><br><span class="line">    resp.setHeader(<span class="string">&quot;Pragma&quot;</span>,<span class="string">&quot;no-cache&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把图片写给浏览器</span></span><br><span class="line">    <span class="keyword">boolean</span> write = ImageIO.write(bufferedImage,<span class="string">&quot;jpg&quot;</span>, resp.getOutputStream());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成随机数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">makeNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    String num = random.nextInt(<span class="number">9999999</span>) + <span class="string">&quot;&quot;</span>;</span><br><span class="line">    StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span> - num.length(); i++) &#123;</span><br><span class="line">        stringBuffer.append(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    num = stringBuffer.toString() + num;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Response实现重定向"><a class="header-anchor" href="#Response实现重定向"></a>Response实现重定向</h3><p>重定向：一个Web资源B收到客户端A的请求后，B通知客户端A访问另外一个web资源C的过程</p><p>使用场景：用户登录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendRedirect</span><span class="params">(String var1)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    resp.sendRedirect(<span class="string">&quot;/response_war/img&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Status Code:302</p><p>Location:/response_war/img</p><p>实现原理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">resp.setHeader(<span class="string">&quot;Location&quot;</span>,<span class="string">&quot;/response_war/img&quot;</span>);</span><br><span class="line">resp.setStatus(<span class="number">302</span>);</span><br></pre></td></tr></table></figure><blockquote><p>重定向url会发生变化</p><p>转发url不会发生变化</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理请求</span></span><br><span class="line">String username = req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">String password = req.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;username = &quot;</span> + username);</span><br><span class="line">System.out.println(<span class="string">&quot;password = &quot;</span> + password);</span><br><span class="line"></span><br><span class="line">resp.sendRedirect(<span class="string">&quot;/response_war/success.jsp&quot;</span>);</span><br></pre></td></tr></table></figure><p>注意文件路径</p><h2 id="HttpServletRequest"><a class="header-anchor" href="#HttpServletRequest"></a>HttpServletRequest</h2><p>HttpServletRequest代表客户端的请求，用户通过Http协议访问服务器，Http请求中的所有信息会被封装到HttpServletRequest，通过这个 HttpServletRequest的方法，获得客户端的所有信息</p><h3 id="获取前端传递的参数"><a class="header-anchor" href="#获取前端传递的参数"></a>获取前端传递的参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String username = req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">String password = req.getParameter(<span class="string">&quot;password&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="请求转发"><a class="header-anchor" href="#请求转发"></a>请求转发</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">req.getRequestDispatcher(<span class="string">&quot;/success.jsp&quot;</span>).forward(req,resp);</span><br></pre></td></tr></table></figure><h2 id="Cookie和Session"><a class="header-anchor" href="#Cookie和Session"></a>Cookie和Session</h2><h3 id="cookie"><a class="header-anchor" href="#cookie"></a>cookie</h3><ul><li>从请求中拿到 cookie信息</li><li>服务器响应给客户端 cookie</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务端从客户端获取Cookie</span></span><br><span class="line">Cookie[] cookies = req.getCookies();</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断Cookie是否存在</span></span><br><span class="line"><span class="keyword">if</span> (cookies != <span class="keyword">null</span>) &#123;</span><br><span class="line">    out.write(<span class="string">&quot;上次访问时间是:&quot;</span>);</span><br><span class="line">    <span class="comment">//遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cookies.length; i++) &#123;</span><br><span class="line">        Cookie cookie = cookies[i];</span><br><span class="line">        <span class="comment">//获取Cookie名字</span></span><br><span class="line">        <span class="keyword">if</span>(cookie.getName().equals(<span class="string">&quot;time&quot;</span>))&#123;</span><br><span class="line">            <span class="comment">//获取Cookie中的值</span></span><br><span class="line">            <span class="keyword">long</span> time = Long.parseLong(cookie.getValue());</span><br><span class="line">            Date date = <span class="keyword">new</span> Date(time);</span><br><span class="line">            out.write(date.toLocaleString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    out.write(<span class="string">&quot;第一次访问&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务器给客户端响应Cookie</span></span><br><span class="line">Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">&quot;time&quot;</span>, System.currentTimeMillis()+<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//cookie有效期</span></span><br><span class="line">cookie.setMaxAge(<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line">resp.addCookie(cookie);</span><br></pre></td></tr></table></figure><h3 id="session"><a class="header-anchor" href="#session"></a>session</h3><ul><li><p>一次登录多次使用，保存用户信息</p></li><li><p>购物车信息</p></li><li><p>网站经常使用的信息</p></li></ul><blockquote><p>与Cookie的区别</p><ul><li>Cookie是把用户的数据写给用户的浏览器，浏览器保存（可以保存多个）</li><li>Session把用户的数据写到用户独占 Session中，服务器端保存（保存重要的信息，减少服务器资源的浪费</li><li>Session对象由服务创建；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//得到Session</span></span><br><span class="line">HttpSession session = req.getSession();</span><br><span class="line"></span><br><span class="line"><span class="comment">//存信息</span></span><br><span class="line">session.setAttribute(<span class="string">&quot;name&quot;</span>,<span class="keyword">new</span> Person(<span class="string">&quot;Lanqilu&quot;</span>,<span class="number">18</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取Session的ID</span></span><br><span class="line">String id = session.getId();</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> aNew = session.isNew();</span><br><span class="line"><span class="keyword">if</span> (aNew) &#123;</span><br><span class="line">resp.getWriter().write(<span class="string">&quot;session创建成功&quot;</span> + id);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">resp.getWriter().write(<span class="string">&quot;session已经存在&quot;</span> + id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//得到Session</span></span><br><span class="line">HttpSession session = req.getSession();</span><br><span class="line"></span><br><span class="line"><span class="comment">//取Session</span></span><br><span class="line">Person person = (Person) session.getAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;person.toString() = &quot;</span> + person.toString());</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HttpSession session = req.getSession();</span><br><span class="line">session.removeAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">//手动注销</span></span><br><span class="line">session.invalidate();</span><br></pre></td></tr></table></figure><p>Session自动过期，web.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--设置Session默认的失效时间--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--15分钟后自动失效--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>15<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Servlet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习笔记</title>
      <link href="2020/05/25/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/"/>
      <url>2020/05/25/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>参考《C Primer Plus》 第六版</p><hr><h2 id="C语言概述"><a class="header-anchor" href="#C语言概述"></a>C语言概述</h2><p>简单的C程序示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    num = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;My favorite number is %d because it is first.\n&quot;</span>,num);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.whl123456.top/image/image-20200525231404657.png" alt="image-20200525231404657"></p><hr><h3 id="include-指令和头文件"><a class="header-anchor" href="#include-指令和头文件"></a><code>#include</code> 指令和头文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span> <span class="comment">//包含另一个文件</span></span></span><br></pre></td></tr></table></figure><p>该行告诉编译器把 <code>stdio.h</code> 中的内容包含在当前程序中。</p><p><code>stdio.h</code> 是 C 编译器软件包的标准部分，它提供键盘<strong>输入</strong>和屏幕<strong>输出</strong>的支持。</p><blockquote><p>stdio的全称是standard input output，h是head的缩写，.h是头文件的文件格式</p><p>在C++中<code>#include&lt;stdio.h&gt;</code>等价写法<code>#include&lt;cstdio&gt;</code></p></blockquote><p>作用相当于把 <code>stdio.h</code> 文件中的所有内容都输入该行所在的位置。</p><p><code>#include</code> 这行代码是一条 C <strong>预处理器指令</strong></p><h3 id="main-函数"><a class="header-anchor" href="#main-函数"></a><code>main()</code>函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span>  <span class="comment">//主函数</span></span></span><br></pre></td></tr></table></figure><p>C 程序包含一个或多个函数，它们是 C 程序的基本模块。</p><p>主函数是一个程序的入口位置，整个程序从主函数开始执行。一个程序最多只能有一个主函数。</p><p>圆括号表明 main()是一个函数名。int 表明 main()函数返回一个整数，void 表明 main()不带任何参数。</p><p>main 是一个极其普通的名称，但是这是唯一的选择</p><blockquote><p>C 程序一定从 main()函数开始执行（目前不必考虑例外的情况）。</p><p>除了 main()函数，你可以任意命名其他函数，而且 main()函数必须是开始的函数。</p></blockquote><h3 id="注释"><a class="header-anchor" href="#注释"></a>注释</h3><p>在程序中，被<code>/*  */</code>两个符号括起来的部分是程序的注释。</p><p>C99 新增了另一种风格的注释，普遍用于 C++和 Java。这种新风格使用<code>//</code>符号创建注释，仅限于单行。</p><h3 id="花括号、函数体和块"><a class="header-anchor" href="#花括号、函数体和块"></a>花括号、函数体和块</h3><p>一般而言，所有的 C 函数都使用花括号<code>&#123;&#125;</code>标记函数体的开始和结束。</p><p>花括号还可用于把函数中的多条语句合并为一个单元或块。</p><h3 id="声明"><a class="header-anchor" href="#声明"></a>声明</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num;  <span class="comment">//声明</span></span><br></pre></td></tr></table></figure><p>以前的 C 语言，还要求把变量声明在块的顶部，其他语句不能在任何声明的前面。</p><p>C99 和 C11 遵循 C++的惯例，可以把声明放在块中的任何位置。尽管如此，首次使用变量之前一定要先声明它。</p><blockquote><p>命名</p><p>可以用小写字母、大写字母、数字和下划线（_）来命名。<br>而且，名称的第 1 个字符必须是字符或下划线，不能是数字。</p><p>操作系统和 C 库经常使用以一个或两个下划线字符开始的标识符（如，_kcab），因此最好避免在自己的程序中使用这种名称。</p><p>C 语言的名称区分大小写，即把一个字母的大写和小写视为两个不同的字符。</p></blockquote><p>声明变量的 4 个理由：</p><ul><li>把所有的变量放在一处，方便读者查找和理解程序的用途。</li><li>声明变量会促使你在编写程序之前做一些计划。</li><li>声明变量有助于发现隐藏在程序中的小错误，如变量名拼写错误。</li><li>如果事先未声明变量，C 程序将无法通过编译。</li></ul><h3 id="赋值"><a class="header-anchor" href="#赋值"></a>赋值</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>在执行<code>int num;</code>声明时，编译器在计算机内存中为变量<code>num</code>预留了空间，然后在执行这行赋值表达式语句时，把值储存在之前预留的位置。</p><p>赋值表达式语句从右侧把值赋到左侧</p><h3 id="printf-函数"><a class="header-anchor" href="#printf-函数"></a><code>printf()</code>函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;My favorite number is %d because it is first.\n&quot;</span>, num);</span><br></pre></td></tr></table></figure><p>圆括号表明 <code>printf</code> 是一个函数名。</p><p>实际参数（简称实参）是传递给函数的特定值，形式参数（简称形参）是函数中用于储存值的变量</p><p><code>\n </code>组合代表一个换行符，换行符是一个转义序列（用于代表难以表示或无法输入的字符）</p><p>参数中的<code>%d </code>相当于是一个占位符，其作用是指明输出 <code>num</code> 值的位置，<code>%</code>提醒程序，要在该处打印一个变量，<code>d </code>表明把变量作为十进制整数打印</p><p><code>printf()</code>函数名中的 <code>f</code> 提醒用户，这是一种格式化打印函数。</p><h3 id="return-语句"><a class="header-anchor" href="#return-语句"></a><code>return</code> 语句</h3><p>有返回值的 C 函数要有 <code>return</code> 语句</p><p>如果遗漏 <code>main()</code>函数中的 <code>return</code> 语句，程序在运行至最外面的右花括号（<code>&#125;</code>）时会返回 <code>0</code>。</p><h2 id="数据"><a class="header-anchor" href="#数据"></a>数据</h2><p>有些数据类型在程序使用之前已经预先设定好了，在整个程序的运行过程中没有变化，这些称为常量（constant）</p><p>其他数据类型在程序运行期间可能会改变或被赋值，这些称为变量（variable）</p><p><img src="http://img.whl123456.top/image/image-20200526211617340.png" alt="C语言数据类型关键字"></p><ul><li><p>用 <code>int</code> 关键字来表示基本的整数类型</p></li><li><p><code>long</code>、<code>short</code> 和 <code>unsigned</code>和 C90 新增的 <code>signed</code> 用于提供基本整数类型的变式，例如 <code>unsigned short int</code> 和 <code>long long int</code>。</p></li><li><p><code>char</code> 关键字用于指定字母和其他字符（如，<code>#</code>、<code>$</code>、<code>%</code>和<code>*</code>）,<code>char</code> 类型也可以表示较小的整数</p></li><li><p><code>float</code>、<code>double</code> 和 <code>long double</code> 表示带小数点的数</p></li><li><p><code>_Bool </code>类型表示布尔值（<code>true</code> 或 <code>false</code>）</p></li><li><p><code>_complex</code> 和<code>_Imaginary</code> 分别表示复数和虚数</p></li></ul><blockquote><p><strong>位、字节和字</strong></p><p>最小的存储单元是位（bit），可以储存 0 或 1</p><p>字节（byte）是常用的计算机存储单位。对于几乎所有的机器，1 字节均为 8 位。</p><p>字（word）是设计计算机时给定的自然存储单位。对于 8 位的微型计算机（如，最初的苹果机），1 个字长只有 8 位。从那以后，个人计算机字长增至 16 位、32 位，直到目前的 64 位。</p></blockquote><h3 id="整数和浮点数"><a class="header-anchor" href="#整数和浮点数"></a>整数和浮点数</h3><p>整数和数学的概念一样，在 C 语言中，整数是没有小数部分的数</p><p>浮点数与数学中实数的概念差不多。2.75、3.16E7、7.00 和 2e-8 都是浮点数。3.16E7 表示 3.16×10<sup>7</sup></p><ul><li>整数没有小数部分，浮点数有小数部分。</li><li>浮点数可以表示的范围比整数大。</li><li>对于一些算术运算（如，两个很大的数相减），浮点数损失的精度更多。</li><li>因为在任何区间内（如，1.0 到 2.0 之间）都存在无穷多个实数，所以计算机的浮点数不能表示区间内所有的值。浮点数通常只是实际值的近似值。例如，7.0 可能被储存为浮点值 6.99999。</li><li>过去，浮点运算比整数运算慢。不过，现在许多 CPU 都包含浮点处理器，缩小了速度上的差距。</li></ul><h3 id="C-语言基本数据类型"><a class="header-anchor" href="#C-语言基本数据类型"></a>C 语言基本数据类型</h3><h4 id="int-类型"><a class="header-anchor" href="#int-类型"></a><code>int</code> 类型</h4><p><code>int</code> 类型是有符号整型，即 <code>int</code> 类型的值必须是整数，可以是正整数、负整数或零。</p><p>一般而言，储存一个 <code>int</code> 要占用一个机器字长</p><p>ISO C 规定 <code>int</code> 的取值范围最小为-32768～32767</p><p>一般而言，系统用一个特殊位的值表示有符号整数的正负号</p><h5 id="声明-int-变量"><a class="header-anchor" href="#声明-int-变量"></a>声明 <code>int</code> 变量</h5><p>要声明多个变量，可以单独声明每个变量，也可在 int 后面列出多个变量名，变量名之间用逗号分隔。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> erns; </span><br><span class="line"><span class="keyword">int</span> hogs, cows, goats;</span><br></pre></td></tr></table></figure><p>提供值方法：1. 赋值；2. 通过函数，如<code>scanf()</code>获得值；3. 初始化变量</p><p>初始化（initialize）变量就是为变量赋一个初始值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hogs = <span class="number">21</span>; </span><br><span class="line"><span class="keyword">int</span> cows = <span class="number">32</span>, goats = <span class="number">14</span>; </span><br><span class="line"><span class="keyword">int</span> dogs, cats = <span class="number">94</span>; <span class="comment">/* 有效，但是这种格式很糟糕 */</span></span><br></pre></td></tr></table></figure><p>以上示例的最后一行，只初始化了 cats，并未初始化 dogs。这种写法很容易让人误认为 dogs 也被初始化为 94，所以最好不要把初始化的变量和未初始化的变量放在同一条声明中。</p><h5 id="打印-int-值"><a class="header-anchor" href="#打印-int-值"></a>打印 <code>int</code> 值</h5><p>可以使用 <code>printf()</code>函数打印 <code>int</code> 类型的值</p><p><code>%d</code>称为<strong>转换说明</strong>，它指定了 <code>printf()</code>应使用什么格式来显示一个值。格式化字符串中的每个<code>%d</code> 都与待打印变量列表中相应的 <code>int</code> 值匹配。</p><h5 id="八进制和十六进制"><a class="header-anchor" href="#八进制和十六进制"></a>八进制和十六进制</h5><p>在 C 语言中，用特定的前缀表示使用哪种进制。</p><p>0x 或 0X 前缀表示十六进制值，所以十进制数 16 表示成十六进制是 0x10 或 0X10。</p><p>与此类似，0 前缀表示八进制。例如，十进制数 16 表示成八进制是 020。</p><p>以十进制显示数字，使用<code>%d</code>；以八进制显示数字，使用<code>%o</code>；以十六进制显示数字，使用<code>%x</code>。</p><p>另外，要显示各进制数的前缀0、0x 和 0X，必须分别使用<code>%#o</code>、<code>%#x</code>、<code>%#X</code></p><h5 id="其他整数类型"><a class="header-anchor" href="#其他整数类型"></a>其他整数类型</h5><p>C 语言提供 3 个附属关键字修饰基本整数类型：<code>short</code>、<code>long</code> 和 <code>unsigned</code></p><ul><li><p><code>short int</code> 类型（或者简写为 <code>short</code>）占用的存储空间可能比 <code>int</code> 类型少，常用于较小数值的场合以节省空间。与 <code>int</code> 类似，<code>short</code> 是有符号类型。</p></li><li><p><code>long int</code> 或 <code>long</code> 占用的存储空间可能比 <code>int</code> 多，适用于较大数值的场合。与 <code>int</code> 类似，<code>long</code>是有符号类型。</p></li><li><p><code>long long int</code> 或 <code>long long</code>（C99 标准加入）占用的储存空间可能比 <code>long</code> 多，适用于更大数值的场合。该类型<strong>至少占 64 位</strong>。与 <code>int</code> 类似，<code>long long</code> 是有符号类型。</p></li><li><p><code>unsigned int</code> 或 <code>unsigned</code> 只用于<strong>非负值</strong>的场合。这种类型与有符号类型表示的范围不同。例如，16 位 <code>unsigned int</code> 允许的取值范围是 0～65535，而不是-32768～32767。用于表示正负号的位现在用于表示另一个二进制位，所以无符号整型可以表示更大的数。</p></li><li><p>在 C90 标准中，添加了 <code>unsigned long int</code> 或 <code>unsigned long</code> 和 <code>unsigned int</code> 或 <code>unsigned short</code> 类型。C99 标准又添加了 <code>unsigned long long int</code> 或 <code>unsigned long long</code>。</p></li><li><p>在任何有符号类型前面添加关键字 <code>signed</code>，可强调使用有符号类型的意图。例如，<code>short</code>、<code>short int</code>、<code>signed short</code>、<code>signed short int</code> 都表示同一种类型。</p></li></ul><p><code>int</code> 类型那么多，应该如何选择？</p><p>首先，考虑 <code>unsigned</code> 类型。这种类型的数常用于计数，因为计数不用负数。而且，<code>unsigned</code> 类型可以表示更大的正数。</p><p>如果一个数超出了 <code>int</code> 类型的取值范围，且在 <code>long</code> 类型的取值范围内时，使用 <code>long</code> 类型。</p><p>然而，对于那些 <code>long</code> 占用的空间比 <code>int</code> 大的系统，使用 <code>long</code> 类型会减慢运算速度。因此，如非必要，请不要使用 <code>long</code> 类型。另外要注意一点：如果在 <code>long</code> 类型和 <code>int</code> 类型占用空间相同的机器上编写代码，当确实需要 32 位的整数时，应使用 <code>long</code> 类型而不是 <code>int</code> 类型，以便把程序移植到 16 位机后仍然可以正常工作。类似地，如果确实需要 64 位的整数，应使用 <code>long long</code> 类型。</p><p>如果在 <code>int</code> 设置为 32 位的系统中要使用 16 位的值，应使用 <code>short</code> 类型以节省存储空间。通常，只有当程序使用相对于系统可用内存较大的整型数组时，才需要重点考虑节省空间的问题。使用 <code>short</code> 类型的另一个原因是，计算机中某些组件使用的硬件寄存器是 16 位。</p><h4 id="char类型"><a class="header-anchor" href="#char类型"></a><code>char</code>类型</h4><p><code>char</code> 类型用于储存字符（如，字母或标点符号），但是从技术层面看，<code>char</code> 是整数类型。</p><h5 id="声明-char-类型变量"><a class="header-anchor" href="#声明-char-类型变量"></a>声明 <code>char</code> 类型变量</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> response; </span><br><span class="line"><span class="keyword">char</span> itable, latan;</span><br></pre></td></tr></table></figure><h5 id="字符常量和初始化"><a class="header-anchor" href="#字符常量和初始化"></a>字符常量和初始化</h5><p>在 C 语言中，用单引号括起来的单个字符被称为字符常量（character constant）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> broiled;  <span class="comment">/* 声明一个 char 类型的变量 */</span> </span><br><span class="line">broiled = <span class="string">&#x27;T&#x27;</span>; <span class="comment">/* 为其赋值，正确 */</span> </span><br><span class="line">broiled = T;  <span class="comment">/* 错误！此时 T 是一个变量 */</span> </span><br><span class="line">broiled = <span class="string">&quot;T&quot;</span>; <span class="comment">/* 错误！此时&quot;T&quot;是一个字符串 */</span></span><br><span class="line"><span class="keyword">char</span> grade = <span class="number">65</span>; <span class="comment">/* 对于 ASCII，这样做没问题，但这是一种不好的编程风格 */</span></span><br></pre></td></tr></table></figure><h5 id="符号常量和-const常量"><a class="header-anchor" href="#符号常量和-const常量"></a>符号常量和 const常量</h5><p>符号常量通俗地讲就是“替换”，即用一个标识符来替代常量，又称为“宏定义”或者“宏替换”。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pi 3.14</span></span><br></pre></td></tr></table></figure><p>另一种定义常量的方法是使用 <code>const</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const double pi &#x3D; 3.14;</span><br></pre></td></tr></table></figure><p>于是在程序中凡是使用pi的地方将在程序执行前全部自动替换为3.14。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pi 3.14</span></span><br><span class="line"><span class="comment">//const double pi = 3.14;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">double</span> r = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, pi * r * r);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="非打印字符"><a class="header-anchor" href="#非打印字符"></a>非打印字符</h5><ol><li>使用 ASCII 码</li><li>用特殊的符号序列表示一些特殊的字符。这些符号序列叫作转义序列（escape sequence）</li></ol><p><img src="http://img.whl123456.top/image/image-20200526215203116.png" alt="转义序列"></p><h4 id="Bool-类型"><a class="header-anchor" href="#Bool-类型"></a><code>_Bool</code> 类型</h4><p>C99 标准添加了<code>_Bool</code> 类型，用于表示布尔值，即逻辑值 true 和 false。因为 C 语言用值 1 表示<br>true，值 0 表示 false，所以<code>_Bool</code> 类型实际上也是一种整数类型。但原则上它仅占用 1 位存储空间，<br>因为对 0 和 1 而言，1 位的存储空间足够了。</p><h4 id="可移植类型：stdint-h-和-inttypes-h"><a class="header-anchor" href="#可移植类型：stdint-h-和-inttypes-h"></a>可移植类型：<code>stdint.h</code> 和 <code>inttypes.h</code></h4><p>C 语言提供了许多有用的整数类型。但是，某些类型名在不同系统中的功能不一样。C99 新增了两个<br>头文件 <code>stdint.h</code> 和 <code>inttypes.h</code>，以确保 C 语言的类型在各系统中的功能相同。</p><h4 id="float、double-和-long-double"><a class="header-anchor" href="#float、double-和-long-double"></a><code>float</code>、<code>double</code> 和 <code>long double</code></h4><p>C 标准规定，<code>float</code> 类型必须至少能表示 6 位有效数字，且取值范围至少是 10<sup>-37</sup> ~10<sup>+37</sup>。</p><p><code>double</code> 类型和 <code>float</code> 类型的最小取值范围相同，但至少必须能表示 10 位有效数字。一般情况下，<code>double</code> 占用 64 位而不是 32 位。</p><p><code>long double</code>，以满足比 <code>double</code> 类型更高的精度要求。不过，C 只保证<code>long double</code> 类型至少与 <code>double</code> 类型的精度相同。</p><h4 id="类型大小"><a class="header-anchor" href="#类型大小"></a>类型大小</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//* typesize.c -- 打印类型大小 */ </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">     <span class="comment">/* C99 为类型大小提供%zd 转换说明 */</span> </span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Type int has a size of %zd bytes.\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)); </span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Type char has a size of %zd bytes.\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span>)); </span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Type long has a size of %zd bytes.\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">long</span>)); </span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Type long long has a size of %zd bytes.\n&quot;</span>, </span><br><span class="line">               <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>)); </span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Type double has a size of %zd bytes.\n&quot;</span>, </span><br><span class="line">              <span class="keyword">sizeof</span>(<span class="keyword">double</span>)); </span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Type long double has a size of %zd bytes.\n&quot;</span>, </span><br><span class="line">              <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">double</span>)); </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sizeof</code> 是 C 语言的内置运算符，以字节为单位给出指定类型的大小。</p><p>C99 和 C11 提供<code>%zd</code> 转换说明匹配 <code>sizeof</code> 的返回类型1。一些不支持 C99 和 C11 的编译器可用<code>%u</code> 或<code>%lu</code> 代替<code>%zd</code>。</p><p>该程序的输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Type int has a size of 4 bytes. </span><br><span class="line">Type char has a size of 1 bytes. </span><br><span class="line">Type long has a size of 8 bytes. </span><br><span class="line">Type long long has a size of 8 bytes. </span><br><span class="line">Type double has a size of 8 bytes. </span><br><span class="line">Type long double has a size of 16 bytes.</span><br></pre></td></tr></table></figure><p>C 语言定义了 <code>char</code> 类型是 1 字节，所以 <code>char</code> 类型的大小一定是 1 字节。</p><p>而在 <code>char</code> 类型为 16 位、<code>double</code>类型为 64 位的系统中，<code>sizeof</code> 给出的 <code>double</code> 是 4 字节。</p><h3 id="强制类型转换"><a class="header-anchor" href="#强制类型转换"></a>强制类型转换</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> r = <span class="number">12.56</span>;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>, b = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (<span class="keyword">int</span>)r); <span class="comment">//r强制转换成int</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a/b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.1f&quot;</span>, (<span class="keyword">double</span>)a / (<span class="keyword">double</span>)b);<span class="comment">//%.1f保留一位小数输出</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串和格式化输入-输出"><a class="header-anchor" href="#字符串和格式化输入-输出"></a>字符串和格式化输入/输出</h2><h3 id="字符串简介"><a class="header-anchor" href="#字符串简介"></a>字符串简介</h3><p>字符串（character string）是一个或多个字符的序列。</p><p>双引号仅告知编译器它括起来的是字符串，正如单引号用于标识单个字符一样。</p><h3 id="char-类型数组和-null-字符"><a class="header-anchor" href="#char-类型数组和-null-字符"></a><code>char</code> 类型数组和 <code>null</code> 字符</h3><p>C 语言没有专门用于储存字符串的变量类型，字符串都被储存在 <code>char</code> 类型的数组中。数组由连续的存<br>储单元组成，字符串中的字符被储存在相邻的存储单元中，每个单元储存一个字符。</p><p>数组末尾位置的字符<code>\0</code>。这是空字符（null character），C 语言用它标记字符串的结束。空字符不是数字 0，它是非打印字符，其 ASCII 码值是（或等价于）0。</p><h3 id="strlen-函数"><a class="header-anchor" href="#strlen-函数"></a><code>strlen()</code>函数</h3><p><code>strlen()</code>函数给出字符串中的字符长度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* praise2.c */</span> </span><br><span class="line"><span class="comment">// 如果编译器不识别%zd，尝试换成%u 或%lu。 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span>      <span class="comment">/* 提供 strlen()函数的原型 */</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRAISE <span class="meta-string">&quot;You are an extraordinary being.&quot;</span> </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">     <span class="keyword">char</span> name[<span class="number">40</span>]; </span><br><span class="line"> </span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;What&#x27;s your name? &quot;</span>); </span><br><span class="line">     <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, name); </span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Hello, %s. %s\n&quot;</span>, name, PRAISE); </span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Your name of %zd letters occupies %zd memory cells.\n&quot;</span>, </span><br><span class="line">               <span class="built_in">strlen</span>(name), <span class="keyword">sizeof</span> name); </span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;The phrase of praise has %zd letters &quot;</span>, </span><br><span class="line">               <span class="built_in">strlen</span>(PRAISE)); </span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;and occupies %zd memory cells.\n&quot;</span>, <span class="keyword">sizeof</span> PRAISE); </span><br><span class="line"> </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//What&#x27;s your name? Serendipity Chance </span></span><br><span class="line"><span class="comment">//Hello, Serendipity. You are an extraordinary being. </span></span><br><span class="line"><span class="comment">//Your name of 11 letters occupies 40 memory cells. </span></span><br><span class="line"><span class="comment">//The phrase of praise has 31 letters and occupies 32 memory cells.</span></span><br></pre></td></tr></table></figure><blockquote><p>一般而言，C 把函数库中相关的函数归为一类，并为每类函数提供一个头文件。例如，<code>printf()</code>和<code>scanf()</code>都隶属标准输入和输出函数，使用 <code>stdio.h</code> 头文件。<code>string.h</code> 头文件中包含了 <code>strlen()</code>函数和其他一些与字符串相关的函数（如拷贝字符串的函数和字符串查找函数）。</p></blockquote><h3 id="常量和-C-预处理器"><a class="header-anchor" href="#常量和-C-预处理器"></a>常量和 C 预处理器</h3><h3 id="printf-和-scanf"><a class="header-anchor" href="#printf-和-scanf"></a><code>printf()</code>和 <code>scanf()</code></h3><p><img src="http://img.whl123456.top/image/image-20200528222920536.png" alt="转换说明及其打印的输出结果"></p><h2 id="运算符、表达式和语句"><a class="header-anchor" href="#运算符、表达式和语句"></a>运算符、表达式和语句</h2><h3 id="基本运算符"><a class="header-anchor" href="#基本运算符"></a>基本运算符</h3><h3 id="其他运算符"><a class="header-anchor" href="#其他运算符"></a>其他运算符</h3><h3 id="表达式和语句"><a class="header-anchor" href="#表达式和语句"></a>表达式和语句</h3><h3 id="类型转换"><a class="header-anchor" href="#类型转换"></a>类型转换</h3><h3 id="带参数的函数"><a class="header-anchor" href="#带参数的函数"></a>带参数的函数</h3><h2 id="循环"><a class="header-anchor" href="#循环"></a>循环</h2><h3 id="while循环"><a class="header-anchor" href="#while循环"></a><code>while</code>循环</h3><h3 id="for-循环"><a class="header-anchor" href="#for-循环"></a><code>for</code> 循环</h3><h3 id="出口条件循环：do-while"><a class="header-anchor" href="#出口条件循环：do-while"></a>出口条件循环：<code>do while</code></h3><h2 id="分支和跳转"><a class="header-anchor" href="#分支和跳转"></a>分支和跳转</h2><h3 id="if-语句"><a class="header-anchor" href="#if-语句"></a><code>if</code> 语句</h3><h3 id="if-else-语句"><a class="header-anchor" href="#if-else-语句"></a><code>if else</code> 语句</h3><h3 id="逻辑运算符"><a class="header-anchor" href="#逻辑运算符"></a>逻辑运算符</h3><h3 id="条件运算符"><a class="header-anchor" href="#条件运算符"></a>条件运算符</h3><h3 id="continue-和-break"><a class="header-anchor" href="#continue-和-break"></a><code>continue</code> 和 <code>break</code></h3><h3 id="多重选择：switch-和-break"><a class="header-anchor" href="#多重选择：switch-和-break"></a>多重选择：<code>switch</code> 和 <code>break</code></h3><h3 id="goto-语句"><a class="header-anchor" href="#goto-语句"></a><code>goto</code> 语句</h3><h2 id="字符输入-输出和输入验证"><a class="header-anchor" href="#字符输入-输出和输入验证"></a>字符输入/输出和输入验证</h2><h3 id="单字符-I-O：getchar-和-putchar"><a class="header-anchor" href="#单字符-I-O：getchar-和-putchar"></a>单字符 I/O：<code>getchar()</code>和 <code>putchar()</code></h3><h3 id="缓冲区"><a class="header-anchor" href="#缓冲区"></a>缓冲区</h3><h3 id="结束键盘输入"><a class="header-anchor" href="#结束键盘输入"></a>结束键盘输入</h3><h3 id="重定向和文件"><a class="header-anchor" href="#重定向和文件"></a>重定向和文件</h3><h2 id="函数"><a class="header-anchor" href="#函数"></a>函数</h2><h3 id="常用math函数"><a class="header-anchor" href="#常用math函数"></a>常用math函数</h3><p>需要在程序开头加上<code>math.h</code>头文件</p><h4 id="fabs-double-x"><a class="header-anchor" href="#fabs-double-x"></a><code>fabs(double x)</code></h4><p>该函数用于对 <code>double</code>型变量取绝对值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">double</span> db = <span class="number">-12.56</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, <span class="built_in">fabs</span>(db)); <span class="comment">//输出：12.56</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="floor（double-x）和-ceil（double-x）"><a class="header-anchor" href="#floor（double-x）和-ceil（double-x）"></a><code>floor（double x）</code>和 <code>ceil（double x）</code></h4><p>分别用于 <code>double</code>型变量的向下取整和向上取整</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">double</span> db1 = <span class="number">-12.56</span>;</span><br><span class="line"><span class="keyword">double</span> db2 = <span class="number">12.56</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.0f %.0f\n&quot;</span>, <span class="built_in">floor</span>(db1),<span class="built_in">ceil</span>(db1)); <span class="comment">//输出：-13 -12</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.0f %.0f\n&quot;</span>, <span class="built_in">floor</span>(db2),<span class="built_in">ceil</span>(db2)); <span class="comment">//输出：12 13</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="pow-double-r-double-p"><a class="header-anchor" href="#pow-double-r-double-p"></a><code>pow(double r,double p)</code></h4><p>返回r的p次幂的值</p><h4 id="sqrt（double-x）"><a class="header-anchor" href="#sqrt（double-x）"></a><code>sqrt（double x）</code></h4><p>该函数用于返回 double型变量的算术平方根</p><h4 id="log（double-x）"><a class="header-anchor" href="#log（double-x）"></a><code>log（double x）</code></h4><p>该函数用于返回 double型变量的以自然对数为底的对数</p><h4 id="sin（-double-x）、cos（-double-x）和tan（-double-x）"><a class="header-anchor" href="#sin（-double-x）、cos（-double-x）和tan（-double-x）"></a><code>sin（ double x）、cos（ double x）和tan（ double x）</code></h4><h4 id="asin（double-x），-acos（double-x）F-atan-（double-x"><a class="header-anchor" href="#asin（double-x），-acos（double-x）F-atan-（double-x"></a><code>asin（double x）， acos（double x）F atan （double x)</code></h4><h4 id="round（double-x）"><a class="header-anchor" href="#round（double-x）"></a><code>round（double x）</code></h4><h2 id="数组和指针"><a class="header-anchor" href="#数组和指针"></a>数组和指针</h2><h3 id="数组"><a class="header-anchor" href="#数组"></a>数组</h3><h3 id="多维数组"><a class="header-anchor" href="#多维数组"></a>多维数组</h3><h3 id="指针和数组"><a class="header-anchor" href="#指针和数组"></a>指针和数组</h3><h3 id="函数、数组和指针"><a class="header-anchor" href="#函数、数组和指针"></a>函数、数组和指针</h3><h3 id="指针操作"><a class="header-anchor" href="#指针操作"></a>指针操作</h3><h2 id="字符串和字符串函数"><a class="header-anchor" href="#字符串和字符串函数"></a>字符串和字符串函数</h2><h2 id="枚举"><a class="header-anchor" href="#枚举"></a>枚举</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">color</span> &#123;</span>RED,YELLO,GREEN&#125;;<span class="comment">//RED = 0,YELLO = 1,GREEN = 3...</span></span><br><span class="line"><span class="comment">// enum 枚举类型名字 &#123;名字0,…,名字n&#125;;</span></span><br><span class="line"><span class="comment">// 枚举类型名字可忽略</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">enum</span> color c)</span></span>;</span><br></pre></td></tr></table></figure><p>用枚举而不是定义独立的const in变量</p><p>常量符号，它们的类型只能是int</p><h3 id="技巧：自动计数的枚举"><a class="header-anchor" href="#技巧：自动计数的枚举"></a>技巧：自动计数的枚举</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">COLOR</span> &#123;</span>RED, YELLOW, GREEN, NumCOLORS&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举中各常量值依次递加，故最后一个值可代表常量个数</p><h3 id="指定枚举量的值"><a class="header-anchor" href="#指定枚举量的值"></a>指定枚举量的值</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">COLOR</span> &#123;</span>RED=<span class="number">1</span>, YELLOW, GREEN=<span class="number">5</span>, NumCOLORS&#125;;<span class="comment">//YELLOW = 2,NumCOLORS?</span></span><br></pre></td></tr></table></figure><h2 id="存储类别、链接和内存管理"><a class="header-anchor" href="#存储类别、链接和内存管理"></a>存储类别、链接和内存管理</h2><h2 id="文件输入-输出"><a class="header-anchor" href="#文件输入-输出"></a>文件输入/输出</h2><h2 id="结构和其他数据形式"><a class="header-anchor" href="#结构和其他数据形式"></a>结构和其他数据形式</h2><p>表达数据比较复杂，但需要一个整体来表达，使用结构——一个复合的数据类型</p><h3 id="声明结构类型"><a class="header-anchor" href="#声明结构类型"></a>声明结构类型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">int</span> day;</span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line">&#125;;<span class="comment">//注意分号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">data</span> <span class="title">today</span>;</span></span><br><span class="line">    </span><br><span class="line">    today.month = <span class="number">06</span>;</span><br><span class="line">    today.day = <span class="number">01</span>;</span><br><span class="line">    today.year = <span class="number">2020</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Today&#x27;s date is %i-%i-%i.\n&quot;</span>,</span><br><span class="line">           today.year,today.month,today.day);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另两种声明结构的形式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;p1,p2;<span class="comment">//p和p2都是一种无名结构，里面有x和y</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ponit</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;p1,p2;<span class="comment">//p和p2都是ponit的结构，里面有x和y</span></span><br></pre></td></tr></table></figure><h3 id="结构的初始化"><a class="header-anchor" href="#结构的初始化"></a>结构的初始化</h3><p>两种方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">int</span> day;</span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> <span class="title">today</span> =</span> &#123;<span class="number">07</span>,<span class="number">31</span>,<span class="number">2014</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> <span class="title">thismonth</span> =</span> &#123;.month=<span class="number">7</span>, .year=<span class="number">2014</span>&#125;;<span class="comment">//此时day为0</span></span><br></pre></td></tr></table></figure><h3 id="结构成员"><a class="header-anchor" href="#结构成员"></a>结构成员</h3><p>数组的单元必须是相同类型，结构的成员可以是不同类型</p><p>访问成员</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">date</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> month;</span><br><span class="line">        <span class="keyword">int</span> day;</span><br><span class="line">        <span class="keyword">int</span> year;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">date</span> <span class="title">today</span> =</span> &#123;<span class="number">07</span>,<span class="number">31</span>,<span class="number">2014</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(today.day);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结构运算"><a class="header-anchor" href="#结构运算"></a>结构运算</h3><p>要访问整个结构，直接用结构变量的名字</p><p>对于整个结构，可以做赋值、取地址，也可以传递给函数参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p1 = (struct ponit)&#123;<span class="number">5</span>,<span class="number">10</span>&#125;;<span class="comment">//相当于p1.x=5;p1.y=10;</span></span><br><span class="line">p1=p2;<span class="comment">//相当于p1.x=p2.x; p1.y=p2.y</span></span><br></pre></td></tr></table></figure><h3 id="结构指针"><a class="header-anchor" href="#结构指针"></a>结构指针</h3><p>结构变量的名字并不是结构变量的地址，必须使用&amp;运算符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> <span class="title">today</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> *<span class="title">pDate</span> =</span> &amp;today;</span><br></pre></td></tr></table></figure><h3 id="结构与函数"><a class="header-anchor" href="#结构与函数"></a>结构与函数</h3><h4 id="结构作为函数的参数"><a class="header-anchor" href="#结构作为函数的参数"></a>结构作为函数的参数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numberOfDays</span><span class="params">(struct date d)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>整个结构可以作为参数的值传入函数</li><li>在函数内<strong>新建</strong>一个结构变量，并<strong>复制</strong>调用者的结构的值</li><li>也可以返回一个结构</li></ul><h4 id="结构指针作为参数"><a class="header-anchor" href="#结构指针作为参数"></a>结构指针作为参数</h4><blockquote><p>If a large structure is to be passed to a function, it is generally more efficient to pass a pointer than to copy the whole structure. ——K&amp;R</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">int</span> day;</span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line">&#125; myday;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> *<span class="title">p</span> =</span> &amp;myday;</span><br><span class="line">(*p).month = <span class="number">12</span>;<span class="comment">//方法一</span></span><br><span class="line">p-&gt;month = <span class="number">12</span>;<span class="comment">//方法二</span></span><br></pre></td></tr></table></figure><p>用<code>-&gt;</code>表示指针所指的结构变量中的成员</p><h4 id="结构作为函数的返回值"><a class="header-anchor" href="#结构作为函数的返回值"></a>结构作为函数的返回值</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct point <span class="title">getstruct1</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ponit</span> <span class="title">p</span>;</span></span><br><span class="line">    scanf_s(<span class="string">&quot;%d&quot;</span>,&amp;p.x);</span><br><span class="line">    scanf_s(<span class="string">&quot;%d&quot;</span>,&amp;p.y);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct point* <span class="title">getstruct2</span><span class="params">(struct ponit *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ponit</span> <span class="title">p</span>;</span></span><br><span class="line">    scanf_s(<span class="string">&quot;%d&quot;</span>,&amp;p-&gt;x);</span><br><span class="line">    scanf_s(<span class="string">&quot;%d&quot;</span>,&amp;p-&gt;y);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="位操作"><a class="header-anchor" href="#位操作"></a>位操作</h2><h2 id="C-预处理器和-C-库"><a class="header-anchor" href="#C-预处理器和-C-库"></a>C 预处理器和 C 库</h2><h2 id="高级数据表示"><a class="header-anchor" href="#高级数据表示"></a>高级数据表示</h2>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程</title>
      <link href="2020/04/06/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>2020/04/06/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>Java多线程</p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多线程创建</span></span><br><span class="line"><span class="comment">/*  1. 创建一个继承与Thread类的子类</span></span><br><span class="line"><span class="comment">    2. 重写Thread类的run()方法</span></span><br><span class="line"><span class="comment">    3. 创建Thread类的子类的对象</span></span><br><span class="line"><span class="comment">    4. 通过此对象调用start()*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//3.创建Thread类的子类的对象</span></span><br><span class="line">        MyThread t1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="comment">//通过此对象调用start()</span></span><br><span class="line">        t1.start();<span class="comment">//线程开始执行或调用当前线程的run()方法</span></span><br><span class="line"><span class="comment">//        t1.run();//直接调用run()方法是单线程</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取当前线程的名字</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Thread.currentThread().getName() = &quot;</span> + Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);<span class="comment">//hello先输出</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//再创建线程</span></span><br><span class="line"><span class="comment">//        t1.start();//报错:IllegalThreadStateException</span></span><br><span class="line">        <span class="comment">//重新创建一个线程对象</span></span><br><span class="line">        MyThread t2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.创建一个继承与Thread类的子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">//2.重写Thread类的run()方法</span></span><br><span class="line">    <span class="comment">//将此线程的操作声明在run()中</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span><span class="comment">// run+Enter快捷方式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取当前线程的名字</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Thread.currentThread().getName() = &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建两个线程一个遍历偶数一个遍历奇数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        evenThread t1 = <span class="keyword">new</span> evenThread();</span><br><span class="line">        oddThread t2 = <span class="keyword">new</span> oddThread();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//简便方式:匿名子类</span></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：i = &quot;</span> + i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历偶数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">evenThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：i = &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历奇数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">oddThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：i = &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread中常用方法</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* getPriority() 获取线程优先级</span></span><br><span class="line"><span class="comment">* setPriority() 改变线程优先级</span></span><br><span class="line"><span class="comment">*   MAX_PRIORITY --&gt; 10</span></span><br><span class="line"><span class="comment">*   MIN_PRIORITY --&gt; 1</span></span><br><span class="line"><span class="comment">*   NORM_PRIORITY --&gt; 5</span></span><br><span class="line"><span class="comment">* setName()     设置线程名</span></span><br><span class="line"><span class="comment">* sleep()       睡眠指定时间</span></span><br><span class="line"><span class="comment">* join()        阻塞</span></span><br><span class="line"><span class="comment">* isAlive()     查看线程状态</span></span><br><span class="line"><span class="comment">* yield()       释放当前CPU的使用权</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        thread t1 = <span class="keyword">new</span> thread(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        t1.setName(<span class="string">&quot;A&quot;</span>);<span class="comment">//设置线程名</span></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;t1.isAlive() = &quot;</span> + t1.isAlive());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//主线程命名</span></span><br><span class="line">        Thread.currentThread().setName(<span class="string">&quot;主线程&quot;</span>);</span><br><span class="line">        <span class="comment">//获取线程名称</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Thread.currentThread().getName() = &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="comment">//获取线程优先级</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Thread.currentThread().getPriority() = &quot;</span> + Thread.currentThread().getPriority());</span><br><span class="line">        <span class="comment">//改变线程优先级</span></span><br><span class="line">        Thread.currentThread().setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread.currentThread().getPriority() = &quot;</span> + Thread.currentThread().getPriority());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line"><span class="comment">//            try &#123;</span></span><br><span class="line"><span class="comment">//                //睡眠指定时间</span></span><br><span class="line"><span class="comment">//                Thread.currentThread().sleep(1000);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//                e.printStackTrace();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：i = &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">20</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//阻塞直到其他线程完成</span></span><br><span class="line">                    t1.join();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;t1.isAlive() = &quot;</span> + t1.isAlive());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">thread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：i = &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">10</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//释放当前CPU的使用权</span></span><br><span class="line">                Thread.currentThread().yield();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过构造器对线程命名</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">thread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java容器</title>
      <link href="2020/04/06/Java%E5%AE%B9%E5%99%A8/"/>
      <url>2020/04/06/Java%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>Java数组与集合</p><hr><h2 id="数组"><a class="header-anchor" href="#数组"></a>数组</h2><p>如果我们有一组类型相同的变量，例如，5位同学的成绩，可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 5位同学的成绩:</span></span><br><span class="line">        <span class="keyword">int</span> n1 = <span class="number">68</span>;</span><br><span class="line">        <span class="keyword">int</span> n2 = <span class="number">79</span>;</span><br><span class="line">        <span class="keyword">int</span> n3 = <span class="number">91</span>;</span><br><span class="line">        <span class="keyword">int</span> n4 = <span class="number">85</span>;</span><br><span class="line">        <span class="keyword">int</span> n5 = <span class="number">62</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但其实没有必要定义5个<code>int</code>变量。可以使用数组来表示“一组”<code>int</code>类型。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 5位同学的成绩:</span></span><br><span class="line">        <span class="keyword">int</span>[] ns = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">        ns[<span class="number">0</span>] = <span class="number">68</span>;</span><br><span class="line">        ns[<span class="number">1</span>] = <span class="number">79</span>;</span><br><span class="line">        ns[<span class="number">2</span>] = <span class="number">91</span>;</span><br><span class="line">        ns[<span class="number">3</span>] = <span class="number">85</span>;</span><br><span class="line">        ns[<span class="number">4</span>] = <span class="number">62</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>数组能够顺序存储相同类型的多个数据。除了存储数据，我们也希望能够访问数据。访问数组中的某个元素的方法是将其编号然后<strong>索引</strong>。如果我们有 N 个值，它们的编号则为 0 至 N-1。这样对于 0 到 N-1 之间任意的 i，我们就能够在 Java 代码中用 <code>a[i]</code> 唯一地表示第 i 个元素的值。在 Java中这种数组被称为一维数组。</p><h3 id="创建并初始化数组"><a class="header-anchor" href="#创建并初始化数组"></a>创建并初始化数组</h3><p>在 Java 程序中创建一个数组需要三步：</p><ul><li>声明数组的名字和类型；</li><li>创建数组；</li><li>初始化数组元素。</li></ul><p>定义一个数组类型的变量，使用数组类型“<code>类型[]</code>”，例如，<code>int[]</code>。和单个基本类型变量不同，数组变量初始化必须使用<code>new int[5]</code>表示创建一个可容纳5个<code>int</code>元素的数组。</p><p>Java的数组有几个特点：</p><ul><li>数组所有元素初始化为默认值，整型都是<code>0</code>，浮点型是<code>0.0</code>，布尔型是<code>false</code>；</li><li>数组一旦创建后，大小就不可改变。</li></ul><p>要访问数组中的某一个元素，需要使用索引。数组索引从<code>0</code>开始，例如，5个元素的数组，索引范围是<code>0</code>~<code>4</code>。</p><p>可以修改数组中的某一个元素，使用赋值语句，例如，<code>ns[1] = 79;</code>。</p><p>可以用<code>数组变量.length</code>获取数组大小：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 5位同学的成绩:</span></span><br><span class="line">        <span class="keyword">int</span>[] ns = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">        System.out.println(ns.length); <span class="comment">// 5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组是引用类型，在使用索引访问数组元素时，如果索引超出范围，运行时将报错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 5位同学的成绩:</span></span><br><span class="line">        <span class="keyword">int</span>[] ns = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">        System.out.println(ns[n]); <span class="comment">// 索引n不能超出范围</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以在定义数组时直接指定初始化的元素，这样就不必写出数组大小，而是由编译器自动推算数组大小。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 5位同学的成绩:</span></span><br><span class="line">        <span class="keyword">int</span>[] ns = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">68</span>, <span class="number">79</span>, <span class="number">91</span>, <span class="number">85</span>, <span class="number">62</span> &#125;;</span><br><span class="line">        System.out.println(ns.length); <span class="comment">// 编译器自动推算数组大小为5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以进一步简写为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] ns = &#123; <span class="number">68</span>, <span class="number">79</span>, <span class="number">91</span>, <span class="number">85</span>, <span class="number">62</span> &#125;;</span><br></pre></td></tr></table></figure><p>注意数组是引用类型，并且数组大小不可变。我们观察下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 5位同学的成绩:</span></span><br><span class="line">        <span class="keyword">int</span>[] ns;</span><br><span class="line">        ns = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">68</span>, <span class="number">79</span>, <span class="number">91</span>, <span class="number">85</span>, <span class="number">62</span> &#125;;</span><br><span class="line">        System.out.println(ns.length); <span class="comment">// 5</span></span><br><span class="line">        ns = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">        System.out.println(ns.length); <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组大小变了吗？看上去好像是变了，但其实根本没变。</p><p>对于数组<code>ns</code>来说，执行<code>ns = new int[] &#123; 68, 79, 91, 85, 62 &#125;;</code>时，它指向一个5个元素的数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">     ns</span><br><span class="line">      │</span><br><span class="line">      ▼</span><br><span class="line">┌───┬───┬───┬───┬───┬───┬───┐</span><br><span class="line">│   │68 │79 │91 │85 │62 │   │</span><br><span class="line">└───┴───┴───┴───┴───┴───┴───┘</span><br></pre></td></tr></table></figure><p>执行<code>ns = new int[] &#123; 1, 2, 3 &#125;;</code>时，它指向一个<em>新的</em>3个元素的数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">     ns ──────────────────────┐</span><br><span class="line">                              │</span><br><span class="line">                              ▼</span><br><span class="line">┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐</span><br><span class="line">│   │68 │79 │91 │85 │62 │   │ 1 │ 2 │ 3 │   │</span><br><span class="line">└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘</span><br></pre></td></tr></table></figure><p>但是，原有的5个元素的数组并没有改变，只是无法通过变量<code>ns</code>引用到它们而已。</p><h3 id="字符串数组"><a class="header-anchor" href="#字符串数组"></a>字符串数组</h3><p>如果数组元素不是基本类型，而是一个引用类型，那么，修改数组元素会有哪些不同？</p><p>字符串是引用类型，因此我们先定义一个字符串数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] names = &#123;</span><br><span class="line">    <span class="string">&quot;ABC&quot;</span>, <span class="string">&quot;XYZ&quot;</span>, <span class="string">&quot;zoo&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于<code>String[]</code>类型的数组变量<code>names</code>，它实际上包含3个元素，但每个元素都指向某个字符串对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">          ┌─────────────────────────┐</span><br><span class="line">    names │   ┌─────────────────────┼───────────┐</span><br><span class="line">      │   │   │                     │           │</span><br><span class="line">      ▼   │   │                     ▼           ▼</span><br><span class="line">┌───┬───┬─┴─┬─┴─┬───┬───────┬───┬───────┬───┬───────┬───┐</span><br><span class="line">│   │░░░│░░░│░░░│   │ &quot;ABC&quot; │   │ &quot;XYZ&quot; │   │ &quot;zoo&quot; │   │</span><br><span class="line">└───┴─┬─┴───┴───┴───┴───────┴───┴───────┴───┴───────┴───┘</span><br><span class="line">      │                 ▲</span><br><span class="line">      └─────────────────┘</span><br></pre></td></tr></table></figure><p>对<code>names[1]</code>进行赋值，例如<code>names[1] = &quot;cat&quot;;</code>，效果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">          ┌─────────────────────────────────────────────────┐</span><br><span class="line">    names │   ┌─────────────────────────────────┐           │</span><br><span class="line">      │   │   │                                 │           │</span><br><span class="line">      ▼   │   │                                 ▼           ▼</span><br><span class="line">┌───┬───┬─┴─┬─┴─┬───┬───────┬───┬───────┬───┬───────┬───┬───────┬───┐</span><br><span class="line">│   │░░░│░░░│░░░│   │ &quot;ABC&quot; │   │ &quot;XYZ&quot; │   │ &quot;zoo&quot; │   │ &quot;cat&quot; │   │</span><br><span class="line">└───┴─┬─┴───┴───┴───┴───────┴───┴───────┴───┴───────┴───┴───────┴───┘</span><br><span class="line">      │                 ▲</span><br><span class="line">      └─────────────────┘</span><br></pre></td></tr></table></figure><p>这里注意到原来<code>names[1]</code>指向的字符串<code>&quot;XYZ&quot;</code>并没有改变，仅仅是将<code>names[1]</code>的引用从指向<code>&quot;XYZ&quot;</code>改成了指向<code>&quot;cat&quot;</code>，其结果是字符串<code>&quot;XYZ&quot;</code>再也无法通过<code>names[1]</code>访问到了。</p><p>对“指向”有了更深入的理解后，试解释如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] names = &#123;<span class="string">&quot;ABC&quot;</span>, <span class="string">&quot;XYZ&quot;</span>, <span class="string">&quot;zoo&quot;</span>&#125;;</span><br><span class="line">        String s = names[<span class="number">1</span>];</span><br><span class="line">        names[<span class="number">1</span>] = <span class="string">&quot;cat&quot;</span>;</span><br><span class="line">        System.out.println(s); <span class="comment">// s是&quot;XYZ&quot;还是&quot;cat&quot;?</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组操作"><a class="header-anchor" href="#数组操作"></a>数组操作</h3><h4 id="遍历数组"><a class="header-anchor" href="#遍历数组"></a>遍历数组</h4><p>我们在Java程序基础里介绍了数组这种数据类型。有了数组，我们还需要来操作它。而数组最常见的一个操作就是遍历。</p><p>通过<code>for</code>循环就可以遍历数组。因为数组的每个元素都可以通过索引来访问，因此，使用标准的<code>for</code>循环可以完成一个数组的遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ns = &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span> &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;ns.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = ns[i];</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了实现<code>for</code>循环遍历，初始条件为<code>i=0</code>，因为索引总是从<code>0</code>开始，继续循环的条件为<code>i，因为当</code>i=ns.length<code>时，</code>i<code>已经超出了索引范围（索引范围是</code>0<code>~</code>ns.length-1<code>），每次循环后，</code>i++`。</p><p>第二种方式是使用<code>for each</code>循环，直接迭代数组的每个元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ns = &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span> &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : ns) &#123;</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：在<code>for (int n : ns)</code>循环中，变量<code>n</code>直接拿到<code>ns</code>数组的元素，而不是索引。</p><p>显然<code>for each</code>循环更加简洁。但是，<code>for each</code>循环无法拿到数组的索引，因此，到底用哪一种<code>for</code>循环，取决于我们的需要。</p><h4 id="打印数组内容"><a class="header-anchor" href="#打印数组内容"></a>打印数组内容</h4><p>直接打印数组变量，得到的是数组在JVM中的引用地址：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] ns = &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span> &#125;;</span><br><span class="line">System.out.println(ns); <span class="comment">// 类似 [I@7852e922</span></span><br></pre></td></tr></table></figure><p>这并没有什么意义，因为我们希望打印的数组的元素内容。因此，使用<code>for each</code>循环来打印它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] ns = &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n : ns) &#123;</span><br><span class="line">    System.out.print(n + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>for each</code>循环打印也很麻烦。幸好Java标准库提供了<code>Arrays.toString()</code>，可以快速打印数组内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历数组</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ns = &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span> &#125;;</span><br><span class="line">        System.out.println(Arrays.toString(ns));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>倒序遍历数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ns = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=ns.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            System.out.println(ns[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组排序"><a class="header-anchor" href="#数组排序"></a>数组排序</h4><p>对数组进行排序是程序中非常基本的需求。常用的排序算法有冒泡排序、插入排序和快速排序等。</p><p>我们来看一下如何使用冒泡排序算法对一个整型数组从小到大进行排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ns = &#123; <span class="number">28</span>, <span class="number">12</span>, <span class="number">89</span>, <span class="number">73</span>, <span class="number">65</span>, <span class="number">18</span>, <span class="number">96</span>, <span class="number">50</span>, <span class="number">8</span>, <span class="number">36</span> &#125;;</span><br><span class="line">        <span class="comment">// 排序前:</span></span><br><span class="line">        System.out.println(Arrays.toString(ns));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ns.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ns.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ns[j] &gt; ns[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="comment">// 交换ns[j]和ns[j+1]:</span></span><br><span class="line">                    <span class="keyword">int</span> tmp = ns[j];</span><br><span class="line">                    ns[j] = ns[j+<span class="number">1</span>];</span><br><span class="line">                    ns[j+<span class="number">1</span>] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 排序后:</span></span><br><span class="line">        System.out.println(Arrays.toString(ns));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>冒泡排序的特点是，每一轮循环后，最大的一个数被交换到末尾，因此，下一轮循环就可以“刨除”最后的数，每一轮循环都比上一轮循环的结束位置靠前一位。</p><p>另外，注意到交换两个变量的值必须借助一个临时变量。像这么写是错误的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">x = y; <span class="comment">// x现在是2</span></span><br><span class="line">y = x; <span class="comment">// y现在还是2</span></span><br></pre></td></tr></table></figure><p>正确的写法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t = x; <span class="comment">// 把x的值保存在临时变量t中, t现在是1</span></span><br><span class="line">x = y; <span class="comment">// x现在是2</span></span><br><span class="line">y = t; <span class="comment">// y现在是t的值1</span></span><br></pre></td></tr></table></figure><p>实际上，Java的标准库已经内置了排序功能，我们只需要调用JDK提供的<code>Arrays.sort()</code>就可以排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 排序</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ns = &#123; <span class="number">28</span>, <span class="number">12</span>, <span class="number">89</span>, <span class="number">73</span>, <span class="number">65</span>, <span class="number">18</span>, <span class="number">96</span>, <span class="number">50</span>, <span class="number">8</span>, <span class="number">36</span> &#125;;</span><br><span class="line">        Arrays.sort(ns);</span><br><span class="line">        System.out.println(Arrays.toString(ns));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>必须注意，对数组排序实际上修改了数组本身。例如，排序前的数组是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] ns = &#123; <span class="number">9</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span> &#125;;</span><br></pre></td></tr></table></figure><p>在内存中，这个整型数组表示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      ┌───┬───┬───┬───┐</span><br><span class="line">ns───&gt;│ 9 │ 3 │ 6 │ 5 │</span><br><span class="line">      └───┴───┴───┴───┘</span><br></pre></td></tr></table></figure><p>当我们调用<code>Arrays.sort(ns);</code>后，这个整型数组在内存中变为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      ┌───┬───┬───┬───┐</span><br><span class="line">ns───&gt;│ 3 │ 5 │ 6 │ 9 │</span><br><span class="line">      └───┴───┴───┴───┘</span><br></pre></td></tr></table></figure><p>即变量<code>ns</code>指向的数组内容已经被改变了。</p><p>如果对一个字符串数组进行排序，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] ns = &#123; <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pear&quot;</span> &#125;;</span><br></pre></td></tr></table></figure><p>排序前，这个数组在内存中表示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">                   ┌──────────────────────────────────┐</span><br><span class="line">               ┌───┼──────────────────────┐           │</span><br><span class="line">               │   │                      ▼           ▼</span><br><span class="line">         ┌───┬─┴─┬─┴─┬───┬────────┬───┬───────┬───┬──────┬───┐</span><br><span class="line">ns ─────&gt;│░░░│░░░│░░░│   │&quot;banana&quot;│   │&quot;apple&quot;│   │&quot;pear&quot;│   │</span><br><span class="line">         └─┬─┴───┴───┴───┴────────┴───┴───────┴───┴──────┴───┘</span><br><span class="line">           │                 ▲</span><br><span class="line">           └─────────────────┘</span><br></pre></td></tr></table></figure><p>调用<code>Arrays.sort(ns);</code>排序后，这个数组在内存中表示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">                   ┌──────────────────────────────────┐</span><br><span class="line">               ┌───┼──────────┐                       │</span><br><span class="line">               │   │          ▼                       ▼</span><br><span class="line">         ┌───┬─┴─┬─┴─┬───┬────────┬───┬───────┬───┬──────┬───┐</span><br><span class="line">ns ─────&gt;│░░░│░░░│░░░│   │&quot;banana&quot;│   │&quot;apple&quot;│   │&quot;pear&quot;│   │</span><br><span class="line">         └─┬─┴───┴───┴───┴────────┴───┴───────┴───┴──────┴───┘</span><br><span class="line">           │                              ▲</span><br><span class="line">           └──────────────────────────────┘</span><br></pre></td></tr></table></figure><p>原来的3个字符串在内存中均没有任何变化，但是<code>ns</code>数组的每个元素指向变化了。</p><h4 id="典型的数组处理代码"><a class="header-anchor" href="#典型的数组处理代码"></a>典型的数组处理代码</h4><p>找出数组中最大的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> max = a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.lenth; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] &gt; max)&#123;</span><br><span class="line">        max = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算数组元素的平均值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> N = a.length;</span><br><span class="line"><span class="keyword">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">    sum += a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> average = sum / N;</span><br></pre></td></tr></table></figure><p>复制数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> N = a.length;</span><br><span class="line"><span class="keyword">double</span>[] b = <span class="keyword">new</span> <span class="keyword">double</span>[N];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">   b[i] = a[i]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>颠倒数组元素的顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> N = a.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N/<span class="number">2</span>; i++)&#123;    </span><br><span class="line">    <span class="keyword">double</span> temp = a[i];</span><br><span class="line">    a[i] = a[N-<span class="number">1</span>-i];</span><br><span class="line">    a[N-i-<span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>矩阵相乘（方阵）<code>a[][] * b[][] = c[][]</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> N = a.length;</span><br><span class="line"><span class="keyword">double</span>[][] c = <span class="keyword">new</span> <span class="keyword">double</span>[N][N];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++)&#123;</span><br><span class="line">        <span class="comment">// 计算行 i 和列 j 的点乘</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; N; k++)&#123;</span><br><span class="line">            c[i][j] += a[i][k]*b[k][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多维数组"><a class="header-anchor" href="#多维数组"></a>多维数组</h3><h4 id="二维数组"><a class="header-anchor" href="#二维数组"></a>二维数组</h4><p>二维数组就是数组的数组。定义一个二维数组如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二维数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] ns = &#123;</span><br><span class="line">            &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;,</span><br><span class="line">            &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;,</span><br><span class="line">            &#123; <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span> &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(ns.length); <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为<code>ns</code>包含3个数组，因此，<code>ns.length</code>为<code>3</code>。实际上<code>ns</code>在内存中的结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                    ┌───┬───┬───┬───┐</span><br><span class="line">         ┌───┐  ┌──&gt;│ 1 │ 2 │ 3 │ 4 │</span><br><span class="line">ns ─────&gt;│░░░│──┘   └───┴───┴───┴───┘</span><br><span class="line">         ├───┤      ┌───┬───┬───┬───┐</span><br><span class="line">         │░░░│─────&gt;│ 5 │ 6 │ 7 │ 8 │</span><br><span class="line">         ├───┤      └───┴───┴───┴───┘</span><br><span class="line">         │░░░│──┐   ┌───┬───┬───┬───┐</span><br><span class="line">         └───┘  └──&gt;│ 9 │10 │11 │12 │</span><br><span class="line">                    └───┴───┴───┴───┘</span><br></pre></td></tr></table></figure><p>如果我们定义一个普通数组<code>arr0</code>，然后把<code>ns[0]</code>赋值给它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二维数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] ns = &#123;</span><br><span class="line">            &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;,</span><br><span class="line">            &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;,</span><br><span class="line">            &#123; <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span> &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span>[] arr0 = ns[<span class="number">0</span>];</span><br><span class="line">        System.out.println(arr0.length); <span class="comment">// 4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实际上<code>arr0</code>就获取了<code>ns</code>数组的第0个元素。因为<code>ns</code>数组的每个元素也是一个数组，因此，<code>arr0</code>指向的数组就是<code>&#123; 1, 2, 3, 4 &#125;</code>。在内存中，结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">            arr0 ─────┐</span><br><span class="line">                      ▼</span><br><span class="line">                    ┌───┬───┬───┬───┐</span><br><span class="line">         ┌───┐  ┌──&gt;│ 1 │ 2 │ 3 │ 4 │</span><br><span class="line">ns ─────&gt;│░░░│──┘   └───┴───┴───┴───┘</span><br><span class="line">         ├───┤      ┌───┬───┬───┬───┐</span><br><span class="line">         │░░░│─────&gt;│ 5 │ 6 │ 7 │ 8 │</span><br><span class="line">         ├───┤      └───┴───┴───┴───┘</span><br><span class="line">         │░░░│──┐   ┌───┬───┬───┬───┐</span><br><span class="line">         └───┘  └──&gt;│ 9 │10 │11 │12 │</span><br><span class="line">                    └───┴───┴───┴───┘</span><br></pre></td></tr></table></figure><p>访问二维数组的某个元素需要使用<code>array[row][col]</code>，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(ns[<span class="number">1</span>][<span class="number">2</span>]); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure><p>二维数组的每个数组元素的长度并不要求相同，例如，可以这么定义<code>ns</code>数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] ns = &#123;</span><br><span class="line">    &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;,</span><br><span class="line">    &#123; <span class="number">5</span>, <span class="number">6</span> &#125;,</span><br><span class="line">    &#123; <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个二维数组在内存中的结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                    ┌───┬───┬───┬───┐</span><br><span class="line">         ┌───┐  ┌──&gt;│ 1 │ 2 │ 3 │ 4 │</span><br><span class="line">ns ─────&gt;│░░░│──┘   └───┴───┴───┴───┘</span><br><span class="line">         ├───┤      ┌───┬───┐</span><br><span class="line">         │░░░│─────&gt;│ 5 │ 6 │</span><br><span class="line">         ├───┤      └───┴───┘</span><br><span class="line">         │░░░│──┐   ┌───┬───┬───┐</span><br><span class="line">         └───┘  └──&gt;│ 7 │ 8 │ 9 │</span><br><span class="line">                    └───┴───┴───┘</span><br></pre></td></tr></table></figure><p>要打印一个二维数组，可以使用两层嵌套的for循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>[] arr : ns) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : arr) &#123;</span><br><span class="line">        System.out.print(n);</span><br><span class="line">        System.out.print(<span class="string">&#x27;, &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者使用Java标准库的<code>Arrays.deepToString()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二维数组</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] ns = &#123;</span><br><span class="line">            &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;,</span><br><span class="line">            &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;,</span><br><span class="line">            &#123; <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span> &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(Arrays.deepToString(ns));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三维数组"><a class="header-anchor" href="#三维数组"></a>三维数组</h4><p>三维数组就是二维数组的数组。可以这么定义一个三维数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][][] ns = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">        &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;,</span><br><span class="line">        &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;<span class="number">10</span>, <span class="number">11</span>&#125;,</span><br><span class="line">        &#123;<span class="number">12</span>, <span class="number">13</span>&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;<span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>&#125;,</span><br><span class="line">        &#123;<span class="number">17</span>, <span class="number">18</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>它在内存中的结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">                              ┌───┬───┬───┐</span><br><span class="line">                   ┌───┐  ┌──&gt;│ 1 │ 2 │ 3 │</span><br><span class="line">               ┌──&gt;│░░░│──┘   └───┴───┴───┘</span><br><span class="line">               │   ├───┤      ┌───┬───┬───┐</span><br><span class="line">               │   │░░░│─────&gt;│ 4 │ 5 │ 6 │</span><br><span class="line">               │   ├───┤      └───┴───┴───┘</span><br><span class="line">               │   │░░░│──┐   ┌───┬───┬───┐</span><br><span class="line">        ┌───┐  │   └───┘  └──&gt;│ 7 │ 8 │ 9 │</span><br><span class="line">ns ────&gt;│░░░│──┘              └───┴───┴───┘</span><br><span class="line">        ├───┤      ┌───┐      ┌───┬───┐</span><br><span class="line">        │░░░│─────&gt;│░░░│─────&gt;│10 │11 │</span><br><span class="line">        ├───┤      ├───┤      └───┴───┘</span><br><span class="line">        │░░░│──┐   │░░░│──┐   ┌───┬───┐</span><br><span class="line">        └───┘  │   └───┘  └──&gt;│12 │13 │</span><br><span class="line">               │              └───┴───┘</span><br><span class="line">               │   ┌───┐      ┌───┬───┬───┐</span><br><span class="line">               └──&gt;│░░░│─────&gt;│14 │15 │16 │</span><br><span class="line">                   ├───┤      └───┴───┴───┘</span><br><span class="line">                   │░░░│──┐   ┌───┬───┐</span><br><span class="line">                   └───┘  └──&gt;│17 │18 │</span><br><span class="line">                              └───┴───┘</span><br></pre></td></tr></table></figure><p>如果我们要访问三维数组的某个元素，例如，<code>ns[2][0][1]</code>，只需要顺着定位找到对应的最终元素<code>15</code>即可。</p><p>理论上，我们可以定义任意的N维数组。但在实际应用中，除了二维数组在某些时候还能用得上，更高维度的数组很少使用。</p><h2 id="集合"><a class="header-anchor" href="#集合"></a>集合</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Basis</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建</span></span><br><span class="line">        ArrayList&lt;Integer&gt; ints = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//添加</span></span><br><span class="line">        ints.add(<span class="number">2</span>);</span><br><span class="line">        ints.add(<span class="number">3</span>);</span><br><span class="line">        ints.add(<span class="number">4</span>);</span><br><span class="line">        ints.add(<span class="number">5</span>);</span><br><span class="line">        ints.add(<span class="number">6</span>);</span><br><span class="line">        ints.add(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ints.size(); i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;ints.get(%d) = %d&quot;</span>, i, ints.get(i));</span><br><span class="line">            System.out.println();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回元素数量</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ints.size = &quot;</span> + ints.size());</span><br><span class="line">        <span class="comment">//返回指定索引对应元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ints.get(1) = &quot;</span> + ints.get(<span class="number">1</span>));</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型"><a class="header-anchor" href="#泛型"></a>泛型</h2>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django</title>
      <link href="2020/04/06/Django/"/>
      <url>2020/04/06/Django/</url>
      
        <content type="html"><![CDATA[<p>基于Django官方文档</p><hr><h2 id="使用Pycharm创建Django"><a class="header-anchor" href="#使用Pycharm创建Django"></a>使用Pycharm创建Django</h2><p><img src="http://img.whl123456.top/image/%E4%BD%BF%E7%94%A8Pycharm%E5%88%9B%E5%BB%BADjango.png" alt="使用Pycharm创建Django"></p><p>Django项目结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DjangoDemo # 根目录只是项目的容器</span><br><span class="line"> ├── db.sqlite3 # 数据库文件 </span><br><span class="line"> ├── DjangoDemo          # 纯 Python 包</span><br><span class="line"> │   ├── asgi.py         # 作为项目运行在 ASGI 兼容的Web服务器上的入口</span><br><span class="line"> │   ├── wsgi.py         # 作为项目运行在 WSGI 兼容的Web服务器上的入口</span><br><span class="line"> │   ├── settings.py     # Django 项目的配置文件</span><br><span class="line"> │   ├── urls.py         # Django 项目的 URL 声明，就像你网站的“目录”</span><br><span class="line"> │   └── __init__.py</span><br><span class="line"> ├── manage.py           # 一个用各种方式管理 Django 项目的命令行工具</span><br><span class="line"> ├── polls</span><br><span class="line"> └── templates</span><br></pre></td></tr></table></figure><p>Django应用结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">polls</span><br><span class="line"> ├── admin.py</span><br><span class="line"> ├── apps.py</span><br><span class="line"> ├── migrations</span><br><span class="line"> │   └── __init__.py</span><br><span class="line"> ├── models.py</span><br><span class="line"> ├── tests.py</span><br><span class="line"> ├── views.py</span><br><span class="line"> └── __init__.py</span><br></pre></td></tr></table></figure><p>命令行启动项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py runserver</span><br></pre></td></tr></table></figure><h2 id="创建应用视图"><a class="header-anchor" href="#创建应用视图"></a>创建应用视图</h2><p>创建视图，打开 <code>polls/views.py</code>，把下面这些 Python 代码输入进去：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&quot;Hello, world. You&#x27;re at the polls index.&quot;</span>)</span><br></pre></td></tr></table></figure><p>如果想看见效果，我们需要将一个 URL 映射到它——这就是我们需要 URLconf 的原因了。</p><p>创建 URLconf，在polls中新建<code>urls.py</code>文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">polls</span><br><span class="line"> ├── admin.py</span><br><span class="line"> ├── apps.py</span><br><span class="line"> ├── migrations</span><br><span class="line"> │   └── __init__.py</span><br><span class="line"> ├── models.py</span><br><span class="line"> ├── tests.py</span><br><span class="line"> ├── urls.py</span><br><span class="line"> ├── views.py</span><br><span class="line"> └── __init__.py</span><br></pre></td></tr></table></figure><p>在<code>urls.py</code>中，输入如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;&#x27;</span>, views.index, name=<span class="string">&#x27;index&#x27;</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在根 URLconf 文件中指定我们创建的 <code>polls.urls</code> 模块。在 <code>DjangoDemo/urls.py</code> 文件的 <code>urlpatterns</code> 列表里插入一个 <code>include()</code>， 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path, include</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;polls/&#x27;</span>, include(<span class="string">&#x27;polls.urls&#x27;</span>)),</span><br><span class="line">    path(<span class="string">&#x27;admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>函数 <a href="https://docs.djangoproject.com/zh-hans/3.0/ref/urls/#django.urls.include"><code>include()</code></a> 允许引用其它 URLconfs。每当 Django 遇到 <a href="https://docs.djangoproject.com/zh-hans/3.0/ref/urls/#django.urls.include"><code>include()</code></a> 时，它会截断与此项匹配的 URL 的部分，并将剩余的字符串发送到 URLconf 以供进一步处理。</p><p>你现在把 <code>index</code> 视图添加进了 URLconf。通过以下命令验证是否正常工作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py runserver</span><br></pre></td></tr></table></figure><p>访问http://127.0.0.1:8000/polls/而不是http://127.0.0.1:8000</p><p><code>path()</code>函数</p><p><code>path(route, view, [kwargs], [name])</code></p><ul><li><p><code>route</code>：是一个匹配 URL 的准则（类似正则表达式）。当 Django 响应一个请求时，它会从 <code>urlpatterns</code> 的第一项开始，按顺序依次匹配列表中的项，直到找到匹配的项。这些准则不会匹配 GET 和 POST 参数或域名。例如，URLconf 在处理请求 <code>https://www.example.com/myapp/</code> 时，它会尝试匹配 <code>myapp/</code> 。处理请求 <code>https://www.example.com/myapp/?page=3</code> 时，也只会尝试匹配 <code>myapp/</code>。</p></li><li><p><code>view</code>：当 Django 找到了一个匹配的准则，就会调用这个特定的视图函数，并传入一个 <a href="https://docs.djangoproject.com/zh-hans/3.0/ref/request-response/#django.http.HttpRequest"><code>HttpRequest</code></a> 对象作为第一个参数，被“捕获”的参数以关键字参数的形式传入。</p></li><li><p><code>kwargs</code>：任意个关键字参数可以作为一个字典传递给目标视图函数。</p></li><li><p><code>name</code>：为你的 URL 取名能使你在 Django 的任意地方唯一地引用它，尤其是在模板中。这个有用的特性允许你只改一个文件就能全局地修改某个 URL 模式。</p></li></ul><h2 id="基础配置"><a class="header-anchor" href="#基础配置"></a>基础配置</h2><p>在 <code>DjangoDemo/settings.py</code> 中</p><p>设置域名访问权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myblog&#x2F;settings.py</span><br><span class="line">ALLOWED_HOSTS &#x3D; []      # 修改前</span><br><span class="line">ALLOWED_HOSTS &#x3D; [&#39;*&#39;]   # 修改后，表示任何域名都能访问。如果指定域名的话，在&#39;&#39;里放入指定的域名即可</span><br></pre></td></tr></table></figure><hr><p>设置TEMPLATES里的’DIRS’，添加模板目录templates的路径，后面我们做网站模板的时候用得着。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 修改前</span><br><span class="line">&#39;DIRS&#39;: []</span><br><span class="line"># 修改后</span><br><span class="line">&#39;DIRS&#39;: [os.path.join(BASE_DIR, &#39;templates&#39;)]</span><br><span class="line"># 注：使用pycharm创建的话会自动添加</span><br></pre></td></tr></table></figure><hr><p>找到DATABASES设置网站数据库类型。这里我们使用默认的sqlite3。如果需要使用Mysql请查看文章：<a href="https://www.django.cn/forum/forum-6.html">Django如何使用Mysql数据库</a>，其它数据库请查看官方文档。<a href="https://docs.djangoproject.com/en/2.1/ref/settings/#databases">官方文档</a>，后期上线部署的话，也可以进行数据库与数据库之间的数据转换。具体可查看：<a href="https://www.django.cn/article/show-17.html">如何把SQLite数据库转换为Mysql数据库</a></p><p>在INSTALLED_APPS添加APP应用名称。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS &#x3D; [                  # Django 的自带应用</span><br><span class="line">    &#39;django.contrib.admin&#39;,         # 管理员站点</span><br><span class="line">    &#39;django.contrib.auth&#39;,          # 认证授权系统。</span><br><span class="line">    &#39;django.contrib.contenttypes&#39;,  # 内容类型框架</span><br><span class="line">    &#39;django.contrib.sessions&#39;,      # 会话框架</span><br><span class="line">    &#39;django.contrib.messages&#39;,      # 消息框架。</span><br><span class="line">    &#39;django.contrib.staticfiles&#39;,   # 管理静态文件的框架</span><br><span class="line">    &#39;polls.apps.PollsConfig&#39;,       # 注册APP应用</span><br><span class="line">]</span><br><span class="line"># 使用pycharm创建的话，这里自动添加</span><br></pre></td></tr></table></figure><hr><p>修改项目语言和时区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">myblog&#x2F;settings.py</span><br><span class="line"># 修改前为英文</span><br><span class="line"># LANGUAGE_CODE &#x3D; &#39;en-us&#39;</span><br><span class="line"># 修改后</span><br><span class="line">LANGUAGE_CODE &#x3D; &#39;zh-hans&#39;  # 语言修改为中文</span><br><span class="line"># 时区，修改前</span><br><span class="line"># TIME_ZONE &#x3D; &#39;UTC&#39;</span><br><span class="line"># 修改后</span><br><span class="line">TIME_ZONE &#x3D; &#39;Asia&#x2F;Shanghai&#39;</span><br></pre></td></tr></table></figure><hr><p>在项目根目录里创建static和media，两个目录。static用来存放模板CSS、JS、图片等静态资源，media用来存放上传的文件，后面我们在讲解数据库创建的时候有说明。</p><p>settings里找到STATIC_URL，然后在后面一行加上如下代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 设置静态文件目录和名称</span><br><span class="line">STATIC_URL &#x3D; &#39;&#x2F;static&#x2F;&#39;</span><br><span class="line"></span><br><span class="line"># 加入下面代码</span><br><span class="line"></span><br><span class="line"># 这个是设置静态文件夹目录的路径</span><br><span class="line">STATICFILES_DIRS &#x3D; (</span><br><span class="line">    os.path.join(BASE_DIR, &#39;static&#39;),</span><br><span class="line">)</span><br><span class="line"># 设置文件上传路径，图片上传、文件上传都会存放在此目录里</span><br><span class="line">MEDIA_URL &#x3D; &#39;&#x2F;media&#x2F;&#39;</span><br><span class="line">MEDIA_ROOT &#x3D; os.path.join(BASE_DIR, &#39;media&#39;)</span><br></pre></td></tr></table></figure><p>基本配置完成，更多关于配置文件的介绍，请查看文章：<a href="https://www.django.cn/course/show-10.html">全局配置settings详解</a></p><h2 id="配置数据库"><a class="header-anchor" href="#配置数据库"></a>配置数据库</h2><p>在 <code>DjangoDemo/settings.py</code> 中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认情况</span></span><br><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;ENGINE&#x27;</span>: <span class="string">&#x27;django.db.backends.sqlite3&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;NAME&#x27;</span>: os.path.join(BASE_DIR, <span class="string">&#x27;db.sqlite3&#x27;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>ENGINE</code>：可选值有 <code>'django.db.backends.sqlite3'</code>，<code>'django.db.backends.postgresql'</code>，<code>'django.db.backends.mysql'</code>，或 <code>'django.db.backends.oracle'</code>。其它 <a href="https://docs.djangoproject.com/zh-hans/3.0/ref/databases/#third-party-notes">可用后端</a>。</p></li><li><p><code>NAME</code>：数据库的名称。如果使用的是 SQLite，数据库将是你电脑上的一个文件，在这种情况下， <a href="https://docs.djangoproject.com/zh-hans/3.0/ref/settings/#std:setting-NAME"><code>NAME</code></a> 应该是此文件的绝对路径，包括文件名。默认值 <code>os.path.join(BASE_DIR, 'db.sqlite3')</code> 将会把数据库文件储存在项目的根目录。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">############修改成mysql如下：</span></span><br><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;ENGINE&#x27;</span>: <span class="string">&#x27;django.db.backends.mysql&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;NAME&#x27;</span>: <span class="string">&#x27;test&#x27;</span>,    <span class="comment">#你的数据库名称</span></span><br><span class="line">        <span class="string">&#x27;USER&#x27;</span>: <span class="string">&#x27;root&#x27;</span>,   <span class="comment">#你的数据库用户名</span></span><br><span class="line">        <span class="string">&#x27;PASSWORD&#x27;</span>: <span class="string">&#x27;445813&#x27;</span>, <span class="comment">#你的数据库密码</span></span><br><span class="line">        <span class="string">&#x27;HOST&#x27;</span>: <span class="string">&#x27;&#x27;</span>, <span class="comment">#你的数据库主机，留空默认为localhost</span></span><br><span class="line">        <span class="string">&#x27;PORT&#x27;</span>: <span class="string">&#x27;3306&#x27;</span>, <span class="comment">#你的数据库端口</span></span><br><span class="line">    &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#由于mysql默认引擎为MySQLdb，在__init__.py文件中添加下面代码</span></span><br><span class="line"><span class="comment">#在python3中须替换为pymysql,可在主配置文件（和项目同名的文件下，不是app配置文件）中增加如下代码</span></span><br><span class="line"><span class="comment">#import pymysql</span></span><br><span class="line"><span class="comment">#pymysql.install_as_MySQLdb()</span></span><br><span class="line"><span class="comment">#如果找不到pymysql板块，则通过pip install pymysql进行安装。</span></span><br></pre></td></tr></table></figure><p>数据库设置好之后，我们就依次输入下面的命令进行数据库迁移：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python manage.py makemigrations</span><br><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure><p>这个 <a href="https://docs.djangoproject.com/zh-hans/3.0/ref/django-admin/#django-admin-migrate"><code>migrate</code></a> 命令检查 <a href="https://docs.djangoproject.com/zh-hans/3.0/ref/settings/#std:setting-INSTALLED_APPS"><code>INSTALLED_APPS</code></a> 设置，为其中的每个应用创建需要的数据表，至于具体会创建什么，这取决于你的 <code>settings.py</code> 设置文件和每个应用的数据库迁移文件。</p><h2 id="创建模型"><a class="header-anchor" href="#创建模型"></a>创建模型</h2><p>在这个投票应用中，需要创建两个模型：问题 <code>Question</code> 和选项 <code>Choice</code>。</p><p><code>Question</code> 模型包括问题描述和发布时间。<code>Choice</code> 模型有两个字段，选项描述和当前得票数。每个选项属于一个问题。</p><p>在<code>models.py</code>文件中写入以下内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create your models here.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Question</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    question_text = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    pub_date = models.DateTimeField(<span class="string">&#x27;date published&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Choice</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    question = models.ForeignKey(Question, on_delete=models.CASCADE)</span><br><span class="line">    choice_text = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    votes = models.IntegerField(default=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>每个模型被表示为 <a href="https://docs.djangoproject.com/zh-hans/3.0/ref/models/instances/#django.db.models.Model"><code>django.db.models.Model</code></a> 类的子类。每个模型有许多类变量，它们都表示模型里的一个数据库字段。</p><p>每个字段都是 <a href="https://docs.djangoproject.com/zh-hans/3.0/ref/models/fields/#django.db.models.Field"><code>Field</code></a> 类的实例 - 比如，字符字段被表示为 <a href="https://docs.djangoproject.com/zh-hans/3.0/ref/models/fields/#django.db.models.CharField"><code>CharField</code></a> ，日期时间字段被表示为 <a href="https://docs.djangoproject.com/zh-hans/3.0/ref/models/fields/#django.db.models.DateTimeField"><code>DateTimeField</code></a> 。这将告诉 Django 每个字段要处理的数据类型。</p><p>每个 <a href="https://docs.djangoproject.com/zh-hans/3.0/ref/models/fields/#django.db.models.Field"><code>Field</code></a> 类实例变量的名字（例如 <code>question_text</code> 或 <code>pub_date</code> ）也是字段名，所以最好使用对机器友好的格式。你将会在 Python 代码里使用它们，而数据库会将它们作为列名。</p><p>你可以使用可选的选项来为 <a href="https://docs.djangoproject.com/zh-hans/3.0/ref/models/fields/#django.db.models.Field"><code>Field</code></a> 定义一个人类可读的名字。这个功能在很多 Django 内部组成部分中都被使用了，而且作为文档的一部分。如果某个字段没有提供此名称，Django 将会使用对机器友好的名称，也就是变量名。在上面的例子中，我们只为 <code>Question.pub_date</code> 定义了对人类友好的名字。对于模型内的其它字段，它们的机器友好名也会被作为人类友好名使用。</p><p>定义某些 <a href="https://docs.djangoproject.com/zh-hans/3.0/ref/models/fields/#django.db.models.Field"><code>Field</code></a> 类实例需要参数。例如 <a href="https://docs.djangoproject.com/zh-hans/3.0/ref/models/fields/#django.db.models.CharField"><code>CharField</code></a> 需要一个 <a href="https://docs.djangoproject.com/zh-hans/3.0/ref/models/fields/#django.db.models.CharField.max_length"><code>max_length</code></a> 参数。这个参数的用处不止于用来定义数据库结构，也用于验证数据，我们稍后将会看到这方面的内容。</p><p><a href="https://docs.djangoproject.com/zh-hans/3.0/ref/models/fields/#django.db.models.Field"><code>Field</code></a> 也能够接收多个可选参数；在上面的例子中：我们将 <code>votes</code> 的 <a href="https://docs.djangoproject.com/zh-hans/3.0/ref/models/fields/#django.db.models.Field.default"><code>default</code></a> 也就是默认值，设为0。</p><p>注意在最后，我们使用 <a href="https://docs.djangoproject.com/zh-hans/3.0/ref/models/fields/#django.db.models.ForeignKey"><code>ForeignKey</code></a> 定义了一个关系。这将告诉 Django，每个 <code>Choice</code> 对象都关联到一个 <code>Question</code> 对象。Django 支持所有常用的数据库关系：多对一、多对多和一对一。</p><h2 id="激活模型"><a class="header-anchor" href="#激活模型"></a>激活模型</h2><p>把 <code>polls</code> 应用安装到我们的项目里，见基础配置</p><p>运行下面的命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py makemigrations polls</span><br></pre></td></tr></table></figure><p>Terminal输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Migrations for &#39;polls&#39;:</span><br><span class="line">  polls\migrations\0001_initial.py</span><br><span class="line">    - Create model Question</span><br><span class="line">    - Create model Choice</span><br></pre></td></tr></table></figure><p>通过运行 <code>makemigrations</code> 命令，Django 会检测你对模型文件的修改（在这种情况下，你已经取得了新的），并且把修改的部分储存为一次迁移。</p><p>迁移是 Django 对于模型定义（也就是你的数据库结构）的变化的储存形式，它们其实也只是一些你磁盘上的文件。如果你想的话，你可以阅读一下你模型的迁移数据，它被储存在 <code>polls/migrations/0001_initial.py</code> 里。别担心，你不需要每次都阅读迁移文件，但是它们被设计成人类可读的形式，这是为了便于你手动调整Django的修改方式。</p><h2 id="Django-管理页面"><a class="header-anchor" href="#Django-管理页面"></a>Django 管理页面</h2><h3 id="创建一个管理员账号"><a class="header-anchor" href="#创建一个管理员账号"></a>创建一个管理员账号</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py createsuperuser</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="2020/03/27/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>2020/03/27/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>有人在碰到问题时,就想：“我知道,我可以用正则表达式。”现在，他就有了两个问题。</p><hr><p><img src="http://img.whl123456.top/image/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.png" alt="正则表达式"></p><p>正则表达式是一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配。为高级的文本模式匹配、抽取、与/或文本形式的搜索和替换提供了基础。</p><p>re 模块使 Python 语言拥有全部的正则表达式功能。</p><ul><li>搜索，在字符串任意部分中搜索匹配的模式。<code>search()</code></li><li>匹配，是判断一个字符串能否从起始处全部或者部分地匹配某个模式。<code>match()</code></li></ul><p><code>compile</code>函数根据一个模式字符串和可选的标志参数生成一个正则表达式对象。<br>该对象拥有一系列方法用于正则表达式匹配和替换。</p><p>re 模块也提供了与这些方法功能完全一致的函数，这些函数使用一个模式字符串做为它们的第一个参数。</p><h2 id="特殊符号和字符"><a class="header-anchor" href="#特殊符号和字符"></a>特殊符号和字符</h2><center>常见正则表达式符号和特殊字符</center><table><thead><tr><th style="text-align:left">表示法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><em>literal</em></td><td style="text-align:left">匹配文本字符串的字面值<em>literal</em></td></tr><tr><td style="text-align:left">re1<code>|</code>re2</td><td style="text-align:left">匹配正则表达式 re1 或者 re2（管道符号）</td></tr><tr><td style="text-align:left"><code>.</code></td><td style="text-align:left">匹配任何字符（除了<code>\n</code>之外）</td></tr><tr><td style="text-align:left"><code>^</code></td><td style="text-align:left">匹配字符串起始部分</td></tr><tr><td style="text-align:left"><code>$</code></td><td style="text-align:left">匹配字符串终止部分</td></tr><tr><td style="text-align:left"><code>*</code></td><td style="text-align:left">匹配 0 次或者多次前面出现的正则表达式</td></tr><tr><td style="text-align:left"><code>+</code></td><td style="text-align:left">匹配 1 次或者多次前面出现的正则表达式</td></tr><tr><td style="text-align:left"><code>?</code></td><td style="text-align:left">匹配 0 次或者 1 次前面出现的正则表达式，<strong>非贪婪</strong></td></tr><tr><td style="text-align:left"><code>&#123;</code>N<code>&#125;</code></td><td style="text-align:left">匹配 N 次前面出现的正则表达式</td></tr><tr><td style="text-align:left"><code>&#123;</code>M<code>,</code>N<code>&#125;</code></td><td style="text-align:left">匹配 M～N 次前面出现的正则表达式</td></tr><tr><td style="text-align:left"><code>[</code>…<code>]</code></td><td style="text-align:left">匹配来自字符集的任意单一字符</td></tr><tr><td style="text-align:left"><code>[</code>…x−y…<code>]</code></td><td style="text-align:left">匹配 x ～ y 范围中的任意单一字符</td></tr><tr><td style="text-align:left"><code>[^</code>…<code>]</code></td><td style="text-align:left">不匹配此字符集中出现的任何一个字符，包括某一范围的字符</td></tr><tr><td style="text-align:left"><code>(</code>…<code>)</code></td><td style="text-align:left">匹配封闭的正则表达式，然后另存为子组</td></tr><tr><td style="text-align:left"><code>\d</code></td><td style="text-align:left">匹配任何十进制数字，与<code>[0-9]</code>一致(<code>\D</code>与之相反)</td></tr><tr><td style="text-align:left"><code>\b</code></td><td style="text-align:left">匹配任何单词边界，指单词和空格间的位置（<code>\B</code>与之相反）</td></tr><tr><td style="text-align:left"><code>\w</code></td><td style="text-align:left">匹配任何字母数字字符，与<code>[A-Za-z0-9_]</code>相同(<code>\W</code>与之相反)</td></tr><tr><td style="text-align:left"><code>\s</code></td><td style="text-align:left">匹配任何空格字符，与<code>[\n\t\r\v\f]</code>相同（<code>\S</code>与之相反）</td></tr><tr><td style="text-align:left"><code>\N</code></td><td style="text-align:left">匹配已保存的子组 N（参见上面的<code>(</code>…<code>)</code>)</td></tr><tr><td style="text-align:left"><code>\</code><em>c</em></td><td style="text-align:left">逐字匹配任何特殊字符<em>c</em>(即仅按照字面意义匹配，不匹配特殊含义)</td></tr><tr><td style="text-align:left"><code>\A(\Z)</code></td><td style="text-align:left">匹配字符串的起始（结束）（另见上面介绍的<code>^</code>和<code>$</code>）</td></tr><tr><td style="text-align:left"><code>(?</code>iLmsux<code>)</code></td><td style="text-align:left">嵌入一个或者多个特殊“标记”参数（或者通过函数/方法）</td></tr><tr><td style="text-align:left"><code>(?:</code>…<code>)</code></td><td style="text-align:left">表示一个匹配不用保存的分组</td></tr><tr><td style="text-align:left"><code>(?P</code>&lt;<em>name</em>&gt;…<code>)</code></td><td style="text-align:left">像一个仅由name标识而不是数字 ID 标识的正则分组匹配</td></tr><tr><td style="text-align:left"><code>(?P=</code><em>name</em><code>)</code></td><td style="text-align:left">在同一字符串中匹配由<code>(?P&lt;name)</code>分组的之前文本</td></tr><tr><td style="text-align:left"><code>(?#</code>…<code>)</code></td><td style="text-align:left">表示注释，所有内容都被忽略</td></tr><tr><td style="text-align:left"><code>(?=</code>…<code>)</code></td><td style="text-align:left">匹配条件是如果…出现在之后的位置，而不使用输入字符串；称作正向前视断言</td></tr><tr><td style="text-align:left"><code>(?!</code>…<code>)</code></td><td style="text-align:left">匹配条件是如果…不出现在之后的位置，而不使用输入字符串；称作负向前视断言</td></tr><tr><td style="text-align:left"><code>(?&lt;=</code>…<code>)</code></td><td style="text-align:left">匹配条件是如果…出现在之前的位置，而不使用输入字符串；称作正向后视断言</td></tr><tr><td style="text-align:left"><code>(?&lt;!</code>…<code>)</code></td><td style="text-align:left">匹配条件是如果…不出现在之前的位置，而不使用输入字符串；称作负向后视断言</td></tr></tbody></table><h2 id="常用正则表达式"><a class="header-anchor" href="#常用正则表达式"></a>常用正则表达式</h2><table><thead><tr><th style="text-align:center">用处</th><th>值</th></tr></thead><tbody><tr><td style="text-align:center">用户名</td><td><code>/^\[a-z0-9_-\]&#123;3,16&#125;$/</code></td></tr><tr><td style="text-align:center">密码</td><td><code>/^\[a-z0-9_-\]&#123;6,18&#125;$/</code></td></tr><tr><td style="text-align:center">十六进制值</td><td><code>/^#?(\[a-f0-9\]&#123;6&#125;\|\[a-f0-9\]&#123;3&#125;)$/</code></td></tr><tr><td style="text-align:center">电子邮箱</td><td><code>/^(\[a-z0-9_\.-]+)@(\[\da-z\.-\]+)\.(\[a-z\.\]&#123;2,6&#125;)\$/ </code><br /><code>/^\[a-z\d\]+(\.\[a-z\d\]+)*@(\[\da-z](-\[\da-z\])?)+(\.&#123;1,2&#125;\[a-z\]+)+$/</code></td></tr><tr><td style="text-align:center">URL</td><td><code>/^(https?:\/\/)?(\[\da-z\.-\]+)\.(\[a-z\.\]&#123;2,6&#125;)([\/\w \.-]*)*\/?$/</code></td></tr><tr><td style="text-align:center">IP 地址</td><td><code>/((2\[0-4\]\d\|25\[0-5\]\|[01]?\d\d?)\.)&#123;3&#125;(2[0-4]\d\|25[0-5]\|[01]?\d\d?)/ &lt;br /&gt;/^(?:(?:25[0-5]\|2\[0-4][0-9]\|[01]?\[0-9][0-9]?)\.)&#123;3&#125;(?:25[0-5]\|2\[0-4][0-9]\|[01]?\[0-9][0-9]?)$/</code></td></tr><tr><td style="text-align:center">HTML 标签</td><td><code>/\^&lt;([a-z]+)(\[^&lt;]+)\*(?:&gt;(.*)&lt;\/\1&gt;\|\s+\/&gt;)$/</code></td></tr><tr><td style="text-align:center">删除代码\注释</td><td><code>(?&lt;!http:\|\S)//.*$</code></td></tr><tr><td style="text-align:center">Unicode编码中的汉字范围</td><td><code>/^[\u2E80-\u9FFF]+$/</code></td></tr></tbody></table><h2 id="re-search"><a class="header-anchor" href="#re-search"></a><code>re.search()</code></h2><p><code>re.search</code> 扫描整个字符串并返回第一个成功的匹配。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(re.search(<span class="string">&#x27;www&#x27;</span>, <span class="string">&#x27;www.runoob.com&#x27;</span>).span())</span><br><span class="line"><span class="built_in">print</span>(re.search(<span class="string">&#x27;com&#x27;</span>, <span class="string">&#x27;www.runoob.com&#x27;</span>).span())</span><br><span class="line"><span class="built_in">print</span>(re.search(<span class="string">&#x27;com&#x27;</span>, <span class="string">&#x27;www.runoob.com.com&#x27;</span>).span())</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">11</span>, <span class="number">14</span>)</span><br><span class="line">(<span class="number">11</span>, <span class="number">14</span>)</span><br></pre></td></tr></table></figure><h2 id="re-match"><a class="header-anchor" href="#re-match"></a><code>re.match()</code></h2><p><code>re.match</code>尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，<code>match()</code>就返回none。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="built_in">print</span>(re.match(<span class="string">&#x27;www&#x27;</span>, <span class="string">&#x27;www.runoob.com&#x27;</span>).span())  <span class="comment"># 在起始位置匹配</span></span><br><span class="line"><span class="built_in">print</span>(re.match(<span class="string">&#x27;com&#x27;</span>, <span class="string">&#x27;www.runoob.com&#x27;</span>))         <span class="comment"># 不在起始位置匹配</span></span><br></pre></td></tr></table></figure><pre><code>(0, 3)None</code></pre><h2 id="group-和groups"><a class="header-anchor" href="#group-和groups"></a><code>group()</code>和<code>groups()</code></h2><p><code>group(num)</code>或<code>groups() </code>匹配对象函数来获取匹配表达式。</p><p><code>group(num=0)</code>匹配的整个表达式的字符串，<code>group()</code>可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。</p><p><code>groups()</code>返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">line = <span class="string">&quot;Cats are smarter than dogs&quot;</span></span><br><span class="line"><span class="comment"># .* 表示任意匹配除换行符（\n、\r）之外的任何单个或多个字符</span></span><br><span class="line">matchObj = re.match( <span class="string">r&#x27;(.*) are (.*?) .*&#x27;</span>, line, re.M|re.I)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> matchObj:</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;matchObj.group() : &quot;</span>, matchObj.group())</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;matchObj.group(1) : &quot;</span>, matchObj.group(<span class="number">1</span>))</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;matchObj.group(2) : &quot;</span>, matchObj.group(<span class="number">2</span>))</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;matchObj.groups() :&quot;</span>,matchObj.groups())</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;No match!!&quot;</span>)</span><br></pre></td></tr></table></figure><pre><code>matchObj.group() :  Cats are smarter than dogsmatchObj.group(1) :  CatsmatchObj.group(2) :  smartermatchObj.groups() : ('Cats', 'smarter')</code></pre><h2 id="re-sub"><a class="header-anchor" href="#re-sub"></a><code>re.sub()</code></h2><p><code>re.sub</code>用于替换字符串中的匹配项。</p><p><code>re.sub(pattern, repl, string, count=0, flags=0)</code></p><ul><li><code>pattern</code> : 正则中的模式字符串。</li><li><code>repl</code> : 替换的字符串，也可为一个函数。</li><li><code>string</code> : 要被查找替换的原始字符串。</li><li><code>count</code> : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。</li><li><code>flags</code> : 编译时用的匹配模式，数字形式。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">phone = <span class="string">&quot;2004-959-559 # 这是一个电话号码&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 删除注释</span></span><br><span class="line">num = re.sub(<span class="string">r&#x27;#.*$&#x27;</span>, <span class="string">&quot;&quot;</span>, phone)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;电话号码 : &quot;</span>, num)  <span class="comment"># 电话号码 :  2004-959-559 </span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 移除非数字的内容</span></span><br><span class="line">num = re.sub(<span class="string">r&#x27;\D&#x27;</span>, <span class="string">&quot;&quot;</span>, phone)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;电话号码 : &quot;</span>, num)  <span class="comment"># 电话号码 :  2004959559</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将匹配的数字乘于 2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">double</span>(<span class="params">matched</span>):</span></span><br><span class="line">    value = <span class="built_in">int</span>(matched.group(<span class="string">&#x27;value&#x27;</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>(value * <span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line">s = <span class="string">&#x27;A23G4HFD567&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(re.sub(<span class="string">&#x27;(?P&lt;value&gt;\d+)&#x27;</span>, double, s))  <span class="comment"># A46G8HFD1134</span></span><br></pre></td></tr></table></figure><h2 id="re-compile"><a class="header-anchor" href="#re-compile"></a><code>re.compile</code></h2><p><code>compile</code>函数用于编译正则表达式,生成一个正则表达式(Pattern)对象,供<code>match()</code>和<code>search()</code>这两个函数使用。<br><code>re.compile(pattern[, flags])</code></p><ul><li><code>pattern</code> : 一个字符串形式的正则表达式</li><li><code>flags</code> 可选，表示匹配模式，比如忽略大小写，多行模式等，具体参数为：<ul><li><code>re.I</code> 忽略大小写</li><li><code>re.L</code> 表示特殊字符集 \w, \W, \b, \B, \s, \S 依赖于当前环境</li><li><code>re.M</code> 多行模式</li><li><code>re.S</code> 即为’ . ‘并且包括换行符在内的任意字符（’ . '不包括换行符）</li><li><code>re.U</code>表示特殊字符集 \w, \W, \b, \B, \d, \D, \s, \S 依赖于 Unicode 字符属性数据库</li><li><code>re.X</code> 为了增加可读性，忽略空格和’ # '后面的注释</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\d+&#x27;</span>)                    <span class="comment"># 用于匹配至少一个数字</span></span><br><span class="line">pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\d+&#x27;</span>)                    <span class="comment"># 用于匹配至少一个数字</span></span><br><span class="line">m = pattern.match(<span class="string">&#x27;one12twothree34four&#x27;</span>)        <span class="comment"># 查找头部，没有匹配</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;从头部开始匹配&quot;</span>,m)  <span class="comment"># 从头部开始匹配 None</span></span><br><span class="line">m = pattern.match(<span class="string">&#x27;one12twothree34four&#x27;</span>, <span class="number">3</span>, <span class="number">10</span>) <span class="comment"># 从&#x27;1&#x27;的位置开始匹配，正好匹配</span></span><br><span class="line"><span class="built_in">print</span>(m)  <span class="comment"># &lt;re.Match object; span=(3, 5), match=&#x27;12&#x27;&gt;     # 返回一个 Match 对象</span></span><br><span class="line"><span class="built_in">print</span>(m.group())  <span class="comment"># 12</span></span><br></pre></td></tr></table></figure><h2 id="re-findall"><a class="header-anchor" href="#re-findall"></a><code>re.findall()</code></h2><p>在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。</p><p><code>re.findall(string[, pos[, endpos]])</code></p><ul><li><code>string</code> 待匹配的字符串。</li><li><code>pos</code> 可选参数，指定字符串的起始位置，默认为 0。</li><li><code>endpos</code> 可选参数，指定字符串的结束位置，默认为字符串的长度。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\d+&#x27;</span>)   <span class="comment"># 查找数字</span></span><br><span class="line">result1 = pattern.findall(<span class="string">&#x27;runoob 123 google 456&#x27;</span>)</span><br><span class="line">result2 = pattern.findall(<span class="string">&#x27;run88oob123google456&#x27;</span>, <span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(result1)  <span class="comment"># [&#x27;123&#x27;, &#x27;456&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(result2)  <span class="comment"># [&#x27;88&#x27;, &#x27;12&#x27;]</span></span><br></pre></td></tr></table></figure><h2 id="re-finditer"><a class="header-anchor" href="#re-finditer"></a><code>re.finditer()</code></h2><p>和 <code>findall</code> 类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">it = re.finditer(<span class="string">r&quot;\d+&quot;</span>,<span class="string">&quot;12a32bc43jf3&quot;</span>) </span><br><span class="line"><span class="keyword">for</span> match <span class="keyword">in</span> it: </span><br><span class="line">    <span class="built_in">print</span> (match.group() ) <span class="comment">## 12 32 43 3</span></span><br></pre></td></tr></table></figure><h2 id="re-split"><a class="header-anchor" href="#re-split"></a><code>re.split</code></h2><p><code>split</code>方法按照能够匹配的子串将字符串分割后返回列表，它的使用形式如下：</p><p><code>re.split(pattern, string[, maxsplit=0, flags=0])</code></p><ul><li><code>pattern</code>匹配的正则表达式</li><li><code>string</code>要匹配的字符串。</li><li><code>maxsplit</code>分隔次数，<code>maxsplit=1</code>分隔一次，默认为 0，不限制次数。</li><li><code>flags</code>标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.split(<span class="string">&#x27;\W+&#x27;</span>, <span class="string">&#x27;runoob, runoob, runoob.&#x27;</span>)  <span class="comment"># [&#x27;runoob&#x27;, &#x27;runoob&#x27;, &#x27;runoob&#x27;, &#x27;&#x27;]</span></span><br></pre></td></tr></table></figure><p>当匹配成功时返回一个 Match 对象，其中：</p><ul><li><code>group(\[group1, …])</code> 方法用于获得一个或多个分组匹配的字符串，当要获得整个匹配的子串时，可直接使用 <code>group() </code>或 <code>group(0)</code>；</li><li><code>start(\[group])</code> 方法用于获取分组匹配的子串在整个字符串中的起始位置（子串第一个字符的索引），参数默认值为 0；</li><li><code>end(\[group])</code> 方法用于获取分组匹配的子串在整个字符串中的结束位置（子串最后一个字符的索引+1），参数默认值为 0；</li><li><code>span(\[group])</code>方法返回<code>(start(group), end(group))</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python网络数据采集</title>
      <link href="2020/03/24/Python%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/"/>
      <url>2020/03/24/Python%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>Python网络数据采集笔记</p><hr><h2 id="网络数据采集的基本原理"><a class="header-anchor" href="#网络数据采集的基本原理"></a>网络数据采集的基本原理</h2><p>对网络爬虫通常的想法：</p><ul><li>通过网站域名获取 HTML 数据</li><li>根据目标信息解析数据</li><li>存储目标信息</li><li>如果有必要，移动到另一个网页重复这个过程</li></ul><h2 id="Python实现网络连接"><a class="header-anchor" href="#Python实现网络连接"></a>Python实现网络连接</h2><p>使用python获取网页，代码实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line">html = urlopen(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(html.read())</span><br></pre></td></tr></table></figure><h3 id="urllib"><a class="header-anchor" href="#urllib"></a>urllib</h3><p>urllib 是 Python 的标准库，包含了从网络请求数据，处理cookie，甚至改变像请求头和用户代理这些元数据的函数。</p><p>urlopen 用来打开并读取一个从网络获取的远程对象。</p><blockquote><p>Python 2.x 里的的是 urllib2 库，在 Python 3.x 里，urllib2 改名为 urllib</p></blockquote><h3 id="BeautifulSoup"><a class="header-anchor" href="#BeautifulSoup"></a>BeautifulSoup</h3><p>BeautifulSoup通过定位 HTML 标签来 格式化和组织复杂的网络信息，用简单易用的 Python 对象为我们展现 XML 结构信息。</p><p>Pycharm可以自动导入其他安装可参考该<a href="https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/#id8">文档</a>，有关Python虚拟环境可参考该<a href="https://lanqilu.github.io/2019/10/12/Python/%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83venv/">文章</a></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install beautifulsoup4</span><br></pre></td></tr></table></figure><p>使用BeautifulSoup</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">html = urlopen(<span class="string">&quot;https://lanqilu.github.io/&quot;</span>)</span><br><span class="line">bsObj = BeautifulSoup(html.read())</span><br><span class="line"><span class="built_in">print</span>(bsObj.h1)</span><br></pre></td></tr></table></figure><h3 id="网络连接异常"><a class="header-anchor" href="#网络连接异常"></a>网络连接异常</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">html = urlopen(<span class="string">&quot;https://lanqilu.github.io/&quot;</span>)</span><br></pre></td></tr></table></figure><p>可能发生的异常有两种</p><ul><li>网页在服务器上不存在（或者获取页面的时候出现错误）</li><li>服务器不存在</li></ul><p>第一种异常发生时，程序会返回 HTTP 错误。可以查看<a href="https://lanqilu.github.io/2020/03/21/Web/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/">HTTP状态码</a>。所有类似情形，urlopen 函数都会抛出“HTTPError”异常</p><p>处理方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.error <span class="keyword">import</span> HTTPError</span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    html = urlopen(<span class="string">&quot;https://lanqilu.github.io/2018&quot;</span>) <span class="comment"># 异常网站 </span></span><br><span class="line"><span class="keyword">except</span> HTTPError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br><span class="line">    <span class="comment"># 返回空值，中断程序，或者执行另一个方案</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;程序继续&quot;</span>)</span><br><span class="line"><span class="comment"># 注意：如果你已经在上面异常捕捉那一段代码里返回或中断（break）</span></span><br><span class="line"><span class="comment"># 那么就不需要使用else语句了，这段代码也不会执行</span></span><br></pre></td></tr></table></figure><p>如果服务器不存在（URL链接打不开），urlopen 会返回一个 None 对象。</p><p>要调用的标签不存在，BeautifulSoup 就会返回 None 对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">from</span> urllib.error <span class="keyword">import</span> HTTPError</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getTitle</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        html = urlopen(url)</span><br><span class="line">    <span class="keyword">except</span> HTTPError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        bsObj = BeautifulSoup(html.read(), <span class="string">&quot;lxml&quot;</span>)</span><br><span class="line">        title = bsObj.body.h1</span><br><span class="line">    <span class="keyword">except</span> AttributeError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> title</span><br><span class="line"></span><br><span class="line">title = getTitle(<span class="string">&quot;https://www.runoob.com/&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> title <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Title could not be found&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(title)</span><br></pre></td></tr></table></figure><h2 id="HTML解析"><a class="header-anchor" href="#HTML解析"></a>HTML解析</h2><p>属性查找标签的方法，标签组的使用，以及标签解析树的导航过程</p><p>网络爬虫可以通过 class 属性的值，轻松地区分出两种不同的标签。</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;red&quot;</span>&gt;</span>Heavens! what a virulent attack!<span class="tag">&lt;/<span class="name">span</span>&gt;</span>&quot; replied <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=</span></span><br><span class="line"><span class="tag">&quot;<span class="attr">green</span>&quot;&gt;</span>the prince<span class="tag">&lt;/<span class="name">span</span>&gt;</span>, not in the least disconcerted by this reception.</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="comment">#%%</span></span><br><span class="line"><span class="comment"># 爬取页面</span></span><br><span class="line">html = urlopen(<span class="string">&quot;http://www.pythonscraping.com/pages/warandpeace.html&quot;</span>)</span><br><span class="line">bsObj = BeautifulSoup(html, features=<span class="string">&quot;lxml&quot;</span>) <span class="comment"># features 选择解析器</span></span><br><span class="line"><span class="comment"># 以用 findAll 函数抽取只包含在 &lt;span class=&quot;green&quot;&gt;&lt;/span&gt; 标签里的文字</span></span><br><span class="line">nameList = bsObj.findAll(<span class="string">&quot;span&quot;</span>, &#123;<span class="string">&quot;class&quot;</span>: <span class="string">&quot;green&quot;</span>&#125;)</span><br><span class="line"><span class="comment"># 打印输出</span></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> nameList:</span><br><span class="line">    <span class="built_in">print</span>(name.get_text())</span><br></pre></td></tr></table></figure><blockquote><p><code>get_text()</code></p><p><code>.get_text() </code>会把正在处理的 HTML 文档中所有的标签都清除，然后返回 一个只包含文字的字符串。假如你正在处理一个包含许多超链接、段落和标签的大段源代码，那么<code> .get_text()</code> 会把这些超链接、段落和标签都清除掉， 只剩下一串不带标签的文字。</p></blockquote><h3 id="BeautifulSoup的find-和findAll"><a class="header-anchor" href="#BeautifulSoup的find-和findAll"></a>BeautifulSoup的<code>find()</code>和<code>findAll()</code></h3><p><code>findAll</code>函数通过标签的名称和属性来查找标签</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">findAll(tag, attributes, recursive, text, limit, keywords)</span><br><span class="line">find(tag, attributes, recursive, text, keywords)</span><br></pre></td></tr></table></figure><p><code>tag</code>标签参数，可以传一个标签的名称或多个标签名称组成的 Python 列表做标签参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.findAll(&#123;<span class="string">&quot;h1&quot;</span>,<span class="string">&quot;h2&quot;</span>,<span class="string">&quot;h3&quot;</span>,<span class="string">&quot;h4&quot;</span>,<span class="string">&quot;h5&quot;</span>,<span class="string">&quot;h6&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><p><code>attributes</code>属性参数，是用一个 Python 字典封装一个标签的若干属性和对应的属性值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.findAll(<span class="string">&quot;span&quot;</span>, &#123;<span class="string">&quot;class&quot;</span>:&#123;<span class="string">&quot;green&quot;</span>, <span class="string">&quot;red&quot;</span>&#125;&#125;)</span><br></pre></td></tr></table></figure><p><code>recursive</code>递归参数，是一个布尔变量，设置为True，查找标签参数的所有子标签，以及子标签的子标签；设置为 False，就只查找文档的一级标签。（默认值是 True）</p><p><code>text</code>文本参数，是用标签的文本内容去匹配，而不是用标签的属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#%%</span></span><br><span class="line">html = urlopen(<span class="string">&quot;http://www.pythonscraping.com/pages/warandpeace.html&quot;</span>)</span><br><span class="line">bsObj = BeautifulSoup(html, features=<span class="string">&quot;lxml&quot;</span>)</span><br><span class="line">nameList = bsObj.findAll(text=<span class="string">&quot;the prince&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(nameList))  <span class="comment"># 7</span></span><br></pre></td></tr></table></figure><p><code>limit</code>范围限制参数，只用于<code>findAll</code>方法，获得的前几项结果是按照网页上的顺序排序</p><blockquote><p><code>find</code>等价于<code>findAll</code>的<code>limit</code>等于1时的情形</p></blockquote><p><code>keyword</code>关键词参数，用于选择具有指定属性的标签</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#%%</span></span><br><span class="line">html = urlopen(<span class="string">&quot;http://www.pythonscraping.com/pages/warandpeace.html&quot;</span>)</span><br><span class="line">bsObj = BeautifulSoup(html, features=<span class="string">&quot;lxml&quot;</span>)</span><br><span class="line">allText = bsObj.findAll(<span class="built_in">id</span>=<span class="string">&quot;text&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(allText[<span class="number">0</span>].get_text())</span><br></pre></td></tr></table></figure><blockquote><p><code>class</code>保留词问题</p><p><code>bsObj.findAll(class=&quot;green&quot;)</code>语法错误，解决方案<code>bsObj.findAll(class_=&quot;green&quot;)</code>或<code>bsObj.findAll(&quot;&quot;, &#123;&quot;class&quot;:&quot;green&quot;&#125;)</code></p></blockquote><h3 id="其他BeautifulSoup对象"><a class="header-anchor" href="#其他BeautifulSoup对象"></a>其他BeautifulSoup对象</h3><ul><li><code>NavigableString</code>对象：用来表示标签里的文字，不是标签</li><li><code>Comment</code>对象：用来查找 HTML 文档的注释标签</li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机书单</title>
      <link href="2020/03/23/Java%E4%B9%A6%E5%8D%95/"/>
      <url>2020/03/23/Java%E4%B9%A6%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<p>从各平台收集整理成的书单</p><hr><h2 id="Java"><a class="header-anchor" href="#Java"></a>Java</h2><h3 id="Java基础与进阶"><a class="header-anchor" href="#Java基础与进阶"></a>Java基础与进阶</h3><ul><li>[x] Java编程思想</li><li>[x] Java核心技术卷</li><li>[x] 深入理解JVM虚拟机</li><li>[ ] Java并发编程实战</li><li>[ ] Java并发编程艺术</li><li>[x] Effective Java</li><li>[ ] Java性能调优指南</li><li>[ ] Java性能权威指南</li></ul><h3 id="JavaWeb"><a class="header-anchor" href="#JavaWeb"></a>JavaWeb</h3><ul><li>[ ] 深入JavaWeb技术内幕</li><li>[x] Spring实战</li><li>[ ] Spring揭秘</li><li>[ ] Spring源码深度解析</li><li>[ ] Maven实战</li></ul><h2 id="Python"><a class="header-anchor" href="#Python"></a>Python</h2><ul><li>[ ] Python编程：从入门到实践</li><li>[ ] Python编程快速上手——让繁琐工作自动化</li><li>[ ] Python 基础教程</li><li>[ ] Python Cookbook</li><li>[ ] Python3 程序开发指南</li><li>[ ] Python 核心编程</li><li>[ ] Python学习手册</li><li>[ ] 流畅的 Python</li><li>[ ] Python源码剖析</li></ul><h2 id="数据库"><a class="header-anchor" href="#数据库"></a>数据库</h2><ul><li>[ ] SQL必知必会</li><li>[ ] 高性能MySQL</li><li>[x] MySQL技术内幕：InnoDB储存引擎</li><li>[ ] Redis实战</li><li>[ ] Redis设计与实现</li></ul><h2 id="计算机网络"><a class="header-anchor" href="#计算机网络"></a>计算机网络</h2><ul><li>[ ] TCP/IP详解</li><li>[x] 计算机网络：自顶向下</li><li>[ ] 图解HTTP</li><li>[ ] 图解TCP/IP</li></ul><h2 id="操作系统"><a class="header-anchor" href="#操作系统"></a>操作系统</h2><ul><li>[ ] 深入理解计算机系统</li><li>[ ] 现代操作系统</li><li>[ ] Linux内核设计与实现</li><li>[ ] Unix网络编程</li></ul><h2 id="数据结构与算法"><a class="header-anchor" href="#数据结构与算法"></a>数据结构与算法</h2><ul><li>[ ] 算法导论</li><li>[ ] 数据结构与算法（Java版）</li><li>[x] 算法图解</li><li>[x] 剑指offer</li><li>[x] 算法</li></ul><h2 id="其他计算机书籍"><a class="header-anchor" href="#其他计算机书籍"></a>其他计算机书籍</h2><ul><li>[ ] Git权威指南</li><li>[ ] 重构——改善既有代码的设计</li><li>[ ] 代码整洁之道</li><li>[x] 编码</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Book </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP</title>
      <link href="2020/03/21/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/"/>
      <url>2020/03/21/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>HTTP状态码</p><hr><h2 id="HTTP响应"><a class="header-anchor" href="#HTTP响应"></a>HTTP响应</h2><p>响应体</p><p>Accept：告诉浏览器，它所支持的数据类型</p><p>Accept- Encoding：支持哪种编码格式 GBK UTF-8 GB2312 ISO8859-1</p><p>Accept- Language：告诉浏览器，它的语言环境</p><p>Cache- Control：缓存控制</p><p>Connection：告诉浏览器，请求完成是断开还是保持连接</p><p>HOST：主机，，/</p><p>Refresh：告诉客户端，多久刷新一次</p><p>Location：让网页重新定位</p><h2 id="常见的状态码简述"><a class="header-anchor" href="#常见的状态码简述"></a>常见的状态码简述</h2><h3 id="2XX"><a class="header-anchor" href="#2XX"></a>2XX</h3><p>一般是请求成功</p><p>200 正常处理</p><p>204 成功处理，但服务器没有新数据返回，显示页面不更新</p><p>206 对服务器进行范围请求，只返回一部分数据</p><h3 id="3XX"><a class="header-anchor" href="#3XX"></a>3XX</h3><p>一般表示重定向</p><p>301 请求的资源已分配了新的URI中，URL地址改变了。【永久重定向】</p><p>302 请求的资源临时分配了新的URI中，URL地址没变【临时重定向】</p><p>303 与302相同的功能，但明确客户端应该采用GET方式来获取资源</p><p>304 发送了附带请求，但不符合条件【返回未过期的缓存数据】</p><p>307 与302相同，但不会把POST请求变成GET</p><h3 id="4XX"><a class="header-anchor" href="#4XX"></a>4XX</h3><p>表示客户端出错了。</p><p>400 请求报文语法错误了</p><p>401 需要认证身份</p><p>403 没有权限访问</p><p>404 服务器没有这个资源</p><h3 id="5XX"><a class="header-anchor" href="#5XX"></a>5XX</h3><p>服务器出错了</p><p>500 内部资源出错了</p><p>502  网关错误</p><p>503 服务器正忙</p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BootStrap</title>
      <link href="2020/03/21/BootStrap/"/>
      <url>2020/03/21/BootStrap/</url>
      
        <content type="html"><![CDATA[<p>Bootstrap 是由Twitter的Mark Otto和Jacob Thornton开发的一个基于 HTML、CSS、JavaScript的用于快速开发 Web 应用程序和网站的前端框架。</p><hr><h2 id="响应式布局"><a class="header-anchor" href="#响应式布局"></a>响应式布局</h2><p>同一套页面可以兼容不同分辨率的设备。</p><p>实现：依赖于栅格系统，将一行平均分成12个格子，可以指定元素占几个格子</p><p>步骤：</p><ol><li><p>定义容器。相当于之前的tableI</p></li><li><p>定义行。相当于之前的tr</p></li><li><p>定义元素。指定该元素在不同的设备上，所占的格子数目。<code>col-设备代号-格子数目</code></p></li></ol><h2 id="栅格系统"><a class="header-anchor" href="#栅格系统"></a>栅格系统</h2><p>栅格系统用于通过一系列的行（row）与列（column）的组合来创建页面布局，你的内容就可以放入这些创建好的布局中。下面就介绍一下 Bootstrap 栅格系统的工作原理：</p><ul><li>“行（row）”必须包含在 <code>.container</code> （固定宽度）或 <code>.container-fluid</code> （100% 宽度）中，以便为其赋予合适的排列（aligment）和内补（padding）。</li><li>通过“行（row）”在水平方向创建一组“列（column）”。</li><li>你的内容应当放置于“列（column）”内，并且，只有“列（column）”可以作为行（row）”的直接子元素。</li><li>类似 <code>.row</code> 和 <code>.col-xs-4</code> 这种预定义的类，可以用来快速创建栅格布局。Bootstrap 源码中定义的 mixin 也可以用来创建语义化的布局。</li><li>通过为“列（column）”设置 <code>padding</code> 属性，从而创建列与列之间的间隔（gutter）。通过为 <code>.row</code> 元素设置负值 <code>margin</code> 从而抵消掉为 <code>.container</code> 元素设置的 <code>padding</code>，也就间接为“行（row）”所包含的“列（column）”抵消掉了<code>padding</code>。</li><li>负值的 margin就是下面的示例为什么是向外突出的原因。在栅格列中的内容排成一行。</li><li>栅格系统中的列是通过指定1到12的值来表示其跨越的范围。例如，三个等宽的列可以使用三个 <code>.col-xs-4</code> 来创建。</li><li>如果一“行（row）”中包含了的“列（column）”大于 12，多余的“列（column）”所在的元素将被作为一个整体另起一行排列。</li><li>栅格类适用于与屏幕宽度大于或等于分界点大小的设备 ， 并且针对小屏幕设备覆盖栅格类。 因此，在元素上应用任何 <code>.col-md-*</code> 栅格类适用于与屏幕宽度大于或等于分界点大小的设备 ， 并且针对小屏幕设备覆盖栅格类。 因此，在元素上应用任何 <code>.col-lg-*</code> 不存在， 也影响大屏幕设备。</li></ul><h2 id="使用BootStrap"><a class="header-anchor" href="#使用BootStrap"></a>使用BootStrap</h2><h3 id="Bootstrap-4-CDN"><a class="header-anchor" href="#Bootstrap-4-CDN"></a>Bootstrap 4 CDN</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 新 Bootstrap4 核心 CSS 文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.staticfile.org/twitter-bootstrap/4.3.1/css/bootstrap.min.css&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!-- jQuery文件。务必在bootstrap.min.js 之前引入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.staticfile.org/jquery/3.2.1/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!-- bootstrap.bundle.min.js 用于弹窗、提示、下拉菜单，包含了 popper.min.js --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.staticfile.org/popper.js/1.15.0/umd/popper.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!-- 最新的 Bootstrap4 核心 JavaScript 文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.staticfile.org/twitter-bootstrap/4.3.1/js/bootstrap.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><table class="grid" cellspacing="0"><tbody><tr>  <td width="8.33%" >1</td>  <td width="8.33%">1</td>  <td width="8.33%">1</td>  <td width="8.33%">1</td>  <td width="8.33%">1</td>  <td width="8.33%">1</td>  <td width="8.33%">1</td>  <td width="8.33%">1</td>  <td width="8.33%">1</td>  <td width="8.33%">1</td>  <td width="8.33%">1</td>  <td width="8.33%">1</td></tr><tr>  <td colspan="4">4</td>  <td colspan="4">4</td>  <td colspan="4">4</td></tr><tr>  <td colspan="4">4</td>  <td colspan="8">8</td></tr><tr>  <td colspan="6">6</td>  <td colspan="6">6</td></tr><tr>  <td colspan="12">12</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BootStrap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven</title>
      <link href="2020/03/21/Maven/"/>
      <url>2020/03/21/Maven/</url>
      
        <content type="html"><![CDATA[<p>Maven是一个Java项目管理和构建工具，它可以定义项目结构、项目依赖，并使用统一的方式进行自动化构建，是Java项目不可缺少的工具。可以管理项目的整个声明周期，包括清除、编译，测试，报告、打包、部署等等。</p><hr><p>Maven是专门为Java项目打造的管理和构建工具，它的主要功能有：</p><ul><li><p>提供了一套标准化的项目结构；</p></li><li><p>提供了一套标准化的构建流程（编译，测试，打包，发布……）；</p></li><li><p>提供了一套依赖管理机制。</p></li></ul><h2 id="Maven项目结构"><a class="header-anchor" href="#Maven项目结构"></a>Maven项目结构</h2><p>一个使用Maven管理的普通的Java项目，它的目录结构默认如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a-maven-project</span><br><span class="line">├── pom.xml</span><br><span class="line">├── src</span><br><span class="line">│   ├── main</span><br><span class="line">│   │   ├── java</span><br><span class="line">│   │   └── resources</span><br><span class="line">│   └── test</span><br><span class="line">│       ├── java</span><br><span class="line">│       └── resources</span><br><span class="line">└── target</span><br></pre></td></tr></table></figure><p>项目的根目录<code>a-maven-project</code>是项目名，它有一个项目描述文件<code>pom.xml</code>，存放Java源码的目录是<code>src/main/java</code>，存放资源文件的目录是<code>src/main/resources</code>，存放测试源码的目录是<code>src/test/java</code>，存放测试资源的目录是<code>src/test/resources</code>，最后，所有编译、打包生成的文件都放在<code>target</code>目录里。这些就是一个Maven项目的标准目录结构。</p><p>我们再来看最关键的一个项目描述文件<code>pom.xml</code>，它的内容长得像下面：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itranswarp.learnjava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中，<code>groupId</code>类似于Java的包名，通常是公司或组织名称，<code>artifactId</code>类似于Java的类名，通常是项目名称，再加上<code>version</code>，一个Maven工程就是由<code>groupId</code>，<code>artifactId</code>和<code>version</code>作为唯一标识。我们在引用其他第三方库的时候，也是通过这3个变量确定。例如，依赖<code>commons-logging</code>：</p><h2 id="Maven配置"><a class="header-anchor" href="#Maven配置"></a>Maven配置</h2><h3 id="Maven-安装"><a class="header-anchor" href="#Maven-安装"></a>Maven 安装</h3><p>以Windows为例，其他系统安装可以参考<a href="https://www.runoob.com/maven/maven-setup.html">菜鸟教程</a></p><p>**第一步：**进入官网<a href="http://maven.apache.org/download.cgi">下载</a>或者直接去<a href="https://mirrors.tuna.tsinghua.edu.cn/apache/maven/maven-3/">清华镜像下载</a></p><p><img src="http://img.whl123456.top/image/image-20200220220737178.png" alt="image-20200220220803063"></p><p>不同平台下载对应的包：Windows下选择Binary zip archive下载</p><p><img src="http://img.whl123456.top/image/image-20200220220803063.png" alt="image-20200220220737178"></p><p>**第二步：**解压压缩包，然后设置环境变量</p><p>新建系统变量 <strong>MAVEN_HOME</strong>，变量值：为解压后目录的绝对地址</p><p><img src="http://img.whl123456.top/image/image-20200220222023598.png" alt="image-20200220222023598"></p><p>编辑系统变量 <strong>Path</strong>，新建变量值：<strong>%MAVEN_HOME%\bin</strong></p><p>**第三步：**在控制台输入<code>mvn -v</code>，如果能看到 Maven 相关版本信息，则说明 Maven 已经安装成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Apache Maven 3.6.3 (cecedd343002696d0abb50b32b541b8a6ba2883f)</span><br><span class="line">Maven home: D:\Apache-Maven-3.6.3\bin\..</span><br><span class="line">Java version: 13.0.1, vendor: Oracle Corporation, runtime: C:\Program Files\Java\jdk-13.0.1</span><br><span class="line">Default locale: zh_CN, platform encoding: GBK</span><br><span class="line">OS name: &quot;windows 10&quot;, version: &quot;10.0&quot;, arch: &quot;amd64&quot;, family: &quot;windows&quot;</span><br></pre></td></tr></table></figure><h3 id="Maven镜像"><a class="header-anchor" href="#Maven镜像"></a>Maven镜像</h3><p>中国区用户可以使用阿里云提供的<a href="https://help.aliyun.com/document_detail/102512.html?spm=a2c4e.11153940.0.0.213c7bdeWnIr1i">Maven镜像仓库</a>。使用Maven镜像仓库需要一个配置，在安装目录下进入conf目录，<code>settings.xml</code>配置文件，找到 <code>&lt;mirrors&gt;</code>如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- mirror</span></span><br><span class="line"><span class="comment">   | Specifies a repository mirror site to use instead of a given repository. The repository that</span></span><br><span class="line"><span class="comment">   | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used</span></span><br><span class="line"><span class="comment">   | for inheritance and direct lookup purposes, and must be unique across the set of mirrors.</span></span><br><span class="line"><span class="comment">   |     --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyunmaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>阿里云公共仓库<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="设置本地库"><a class="header-anchor" href="#设置本地库"></a>设置本地库</h3><p>继续在<code>settings.xml</code>文件中找到<code>&lt;localRepository&gt;</code>中间填入本地库<br><img src="http://img.whl123456.top/image/image-20200305202841108.png" alt="image-20200220223951120"></p><h3 id="IDEA中配置Maven"><a class="header-anchor" href="#IDEA中配置Maven"></a>IDEA中配置Maven</h3><p><img src="http://img.whl123456.top/image/image-20200220224606360.png" alt="image-20200220224606360"></p><p>注意<strong>For current project</strong>仅对当前项目有效</p><p>如果想要对所有项目生效需要在<strong>欢迎页</strong>进行上述设置</p><p><img src="http://img.whl123456.top/image/image-20200220223951120.png" alt="image-20200305202841108"></p><p>自动下载变化后的依赖</p><p><img src="http://img.whl123456.top/image/image-20200220225318659.png" alt="image-20200220225318659"></p><h2 id="有关概念"><a class="header-anchor" href="#有关概念"></a>有关概念</h2><h3 id="仓库"><a class="header-anchor" href="#仓库"></a>仓库</h3><h4 id="本地仓库"><a class="header-anchor" href="#本地仓库"></a>本地仓库</h4><p>Maven会把我们项目所构建出来的jar包等等资源存放在本地仓库中。当我们需要jar包的时候，Maven第一时间也是去本地仓库中寻找jar包</p><h4 id="中心仓库"><a class="header-anchor" href="#中心仓库"></a>中心仓库</h4><p>当Maven在本地仓库和私服找不到我们需要的jar包的时候，就去中心仓库中帮我们下载对应的jar包。</p><h4 id="私有服务器"><a class="header-anchor" href="#私有服务器"></a>私有服务器</h4><p>存储一些jar包的服务器，由于本地仓库不可能拥有大部分的jar包，一个团队要去开发，免不了总是去中心仓库下载，这就非常耗费时间了。</p><h3 id="maven软件构建的生命周期"><a class="header-anchor" href="#maven软件构建的生命周期"></a>maven软件构建的生命周期</h3><p>清除–&gt; 编译–&gt;测试–&gt;报告–&gt;打包（jar\war）–&gt;安装–&gt;部署</p><p><img src="http://img.whl123456.top/image/image-20200221210511211.png" alt="image-20200221210511211"></p><h3 id="maven坐标"><a class="header-anchor" href="#maven坐标"></a>maven坐标</h3><p>坐标的组成： groupId + artifactId+ version</p><ul><li>groupId：组id ,机构名，公司名：好比公司的id，或者是公司包名</li><li>artifactId：构建物id ，产品名或者产品的id</li><li>version ：版本号</li></ul><blockquote><p>Alibaba——▶支付宝——▶5.01版本</p></blockquote><p>jar包组成：artifactId-version.jar</p><h2 id="pom-xml"><a class="header-anchor" href="#pom-xml"></a>pom.xml</h2><p>pom.xml介绍：<strong>project object model 项目对象模型 ，它是maven核心配置文件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Maven在导入jar包时会导入这个jar包所依赖的其他包--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Maven版本和头文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--配置的GAV--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>top.whl123456<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>JavaWeb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--项目的打包方式--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--jar:java应用--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--war:JavaWbe应用--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>JavaWeb Maven Webapp<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- FIXME change it to the project&#x27;s website --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.example.com<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--配置--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--默认构建编码--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--编码版本--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--项目依赖--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--具体依赖的jar包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--项目构建需要的插件--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>JavaWeb<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span><span class="comment">&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-clean-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resources-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.22.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-war-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-install-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-deploy-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--在build中配置resource,来防止资源导出失败的问题--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot</title>
      <link href="2020/03/21/SpringBoot/"/>
      <url>2020/03/21/SpringBoot/</url>
      
        <content type="html"><![CDATA[<p><a href="https://spring.io/">SpringBoot</a></p><hr><h2 id="创建项目"><a class="header-anchor" href="#创建项目"></a>创建项目</h2><h3 id="项目环境"><a class="header-anchor" href="#项目环境"></a>项目环境</h3><p>JDK1.8、Maven、SpringBoot2.2.4、IDEA</p><h3 id="使用-IntelliJ-IDEA创建"><a class="header-anchor" href="#使用-IntelliJ-IDEA创建"></a>使用 IntelliJ IDEA创建</h3><p>**第一步：**菜单栏中选择：File =&gt; New =&gt; Project…，我们可以看到如下图所示的创建功能窗口。</p><blockquote><p>其中Initial Service Url指向的地址就是Spring官方提供的Spring Initializr工具地址，所以这里创建的工程实际上也是基于它的Web工具来实现的。</p></blockquote><p><img src="http://img.whl123456.top/image/image-20200220211502308.png" alt="创建项目"></p><p><strong>第二步</strong>：点击Next，等待片刻后，我们可以看到如下图所示的工程信息窗口：<br><img src="http://img.whl123456.top/image/image-20200220211700051.png" alt="设置项目"></p><ul><li><p>Type：使用什么构建工具，Maven还是Gradle；</p></li><li><p>Language：使用什么编程语言，Java、Kotlin还是Groovy；</p></li></ul><p><strong>第三步</strong>：继续点击Next，进入选择Spring Boot版本和依赖管理的窗口：</p><p><img src="http://img.whl123456.top/image/image-20200220212223616.png" alt="项目依赖"></p><p>在这里值的我们关注的是，它不仅包含了Spring Boot Starter POMs中的各个依赖，还包含了Spring Cloud的各种依赖。</p><p><strong>第四步</strong>：点击Next，进入最后关于工程物理存储的一些细节。最后，点击Finish就能完成工程的构建了。</p><h3 id="项目解析"><a class="header-anchor" href="#项目解析"></a>项目解析</h3><h4 id="项目结构解析"><a class="header-anchor" href="#项目结构解析"></a>项目结构解析</h4><p><img src="http://img.whl123456.top/image/image-20200220212945331.png" alt="项目结构"></p><ul><li><code>src/main/java</code>下的程序入口：<code>DemoApplication</code></li><li><code>src/main/resources</code>下的配置文件：<code>application.properties</code></li><li><code>src/test/</code>下的测试入口：<code>DemoApplicationTests</code></li></ul><p>生成的<code>DemoApplication</code>和<code>Demo``ApplicationTests</code>类都可以直接运行来启动当前创建的项目，由于目前该项目未配合任何数据访问或Web模块，程序会在加载完Spring之后结束运行。</p><h5 id="项目依赖解析"><a class="header-anchor" href="#项目依赖解析"></a>项目依赖解析</h5><p>打开<code>pom.xml</code>，看看Spring Boot项目的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如上所示，主要有四个部分：</p><ul><li>项目元数据：创建时候输入的Project Metadata部分，也就是Maven项目的基本元素，包括：<code>groupId</code>、<code>artifactId</code>、<code>version</code>、<code>name</code>、<code>description</code>等</li><li>parent：继承<code>spring-boot-starter-parent</code>的依赖管理，控制版本与打包等内容</li><li>dependencies：项目具体依赖，这里包含了<code>spring-boot-starter-web</code>用于实现HTTP接口（该依赖中包含了Spring MVC）；<code>spring-boot-starter-test</code>用于编写单元测试的依赖包。更多功能模块的使用我们将在后面的教程中逐步展开。</li><li>build：构建配置部分。默认使用了<code>spring-boot-maven-plugin</code>，配合<code>spring-boot-starter-parent</code>就可以把Spring Boot应用打包成JAR来直接运行。</li></ul><h3 id="启动"><a class="header-anchor" href="#启动"></a>启动</h3><h4 id="编写一个HTTP接口"><a class="header-anchor" href="#编写一个HTTP接口"></a>编写一个HTTP接口</h4><ul><li><p>在com.example.demo下面创建<code>HelloController</code>类，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动主程序，进入<a href="http://localhost:8080/hello">浏览器</a>，可以看到页面返回：Hello World</p></li></ul><h3 id="启动引导Spring"><a class="header-anchor" href="#启动引导Spring"></a>启动引导Spring</h3><p>创建SpringBoot项目后默认有一个DemoApplication类，其内容如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启组件扫描和自动配置</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//负责启动引导应用程序</span></span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@SpringBootApplication</code>开启了Spring的组件扫描和Spring Boot的自动配置功能。实际上，<code>@SpringBootApplication</code>将三个有用的注解组合在了一起。</p><ul><li>Spring的<code>@Configuration</code>：标明该类使用Spring基于Java的配置而不是XML的配置。</li><li>Spring的<code>@ComponentScan</code>：启用组件扫描，这样你写的Web控制器类和其他组件才能被自动发现并注册为Spring应用程序上下文里的Bean。</li><li>Spring Boot 的 <code>@EnableAutoConfiguration</code> ： 这 个 不 起 眼 的 小 注 解 也 可 以 称 为<code>@Abracadabra</code>，就是这一行配置开启了Spring Boot自动配置的魔力，让你不用再写成篇的配置了。</li></ul><p><code>DemoApplication</code>还是一个启动引导类，这里的<code>main()</code>方法让你可以在命令行里把该应用程序当作一个可执行JAR文件来运行。这里向<code>SpringApplication.run()</code>传递了一个<code>DemoApplication</code>类的引用，还有命令行参数，通过这些东西启动应用程序。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> JavaEE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring框架</title>
      <link href="2020/03/21/Spring%E6%A1%86%E6%9E%B6/"/>
      <url>2020/03/21/Spring%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<p>Spring框架</p><hr><h2 id="基础知识"><a class="header-anchor" href="#基础知识"></a>基础知识</h2><h3 id="程序的耦合"><a class="header-anchor" href="#程序的耦合"></a>程序的耦合</h3><p>耦合：程序间的依赖关系</p><p>包括：</p><ul><li>类之间的依赖</li><li>方法间的依赖</li></ul><p>解耦：降低程序间的依赖关系</p><p>实际开发中：应该做到：编译期不依赖，运行时才依赖。</p><p>解耦的思路：</p><ul><li>第一步：使用反射来创建对象，而避免使用new关键字。</li><li>第二步：通过读取配置文件来获取要创建的对象全限定类名</li></ul><h3 id="工厂模式"><a class="header-anchor" href="#工厂模式"></a>工厂模式</h3><p>Bean：在计算机英语中，有可重用组件的含义。</p><p>JavaBean：用java语言编写的可重用组件。JavaBean &gt;  实体类</p><h2 id="Spring介绍"><a class="header-anchor" href="#Spring介绍"></a>Spring介绍</h2><p>创建Spring的目的就是用来<strong>替代更加重量级的的企业级Java技术</strong>，<strong>简化Java的开发</strong></p><ul><li>基于POJO轻量级和<strong>最小侵入式开发</strong></li><li>通过依赖注入和面向接口实现<strong>松耦合</strong></li><li><strong>基于切面</strong>和惯例进行声明式编程</li><li>通过切面和模板<strong>减少样板式代码</strong></li></ul><blockquote><p>POJO（Plain Ordinary Java Object）简单的Java对象，实际就是普通JavaBeans，是为了避免和EJB混淆所创造的简称。</p><p>JavaBean 是一种JAVA语言写成的可重用组件。为写成JavaBean，类必须是具体的和公共的，并且具有无参数的构造器。JavaBean 通过提供符合一致性设计模式的公共方法将内部域暴露成员属性，set和get方法获取。众所周知，属性名称符合这种模式，其他Java 类可以通过自省机制(反射机制)发现和操作这些JavaBean 的属性。</p></blockquote><h3 id="Spring的狭义与广义"><a class="header-anchor" href="#Spring的狭义与广义"></a>Spring的狭义与广义</h3><p>狭义上的Spring特指Spring框架（Spring Framework）</p><p>广义上的Spring是指以Spring框架为核心的Spring技术栈</p><h2 id="Spring框架概述"><a class="header-anchor" href="#Spring框架概述"></a>Spring框架概述</h2><h3 id="模块化的Spring框架"><a class="header-anchor" href="#模块化的Spring框架"></a>模块化的Spring框架</h3><p>Spring框架是模块化的，允许开发人员自由选择需要使用的部分。</p><h3 id="使用Spring的好处"><a class="header-anchor" href="#使用Spring的好处"></a>使用Spring的好处</h3><p>Spring可以使用POJO来构建应用程序，并将企业服务非侵入性的应用到POJO。此功能适用于JavaSE编程模型和完全或部分的JavaEE模型</p><p>作为一个Java应用程序的开发者，可以从Spring平台获得以下好处：</p><ul><li>使本地Java方法可以执行数据库事务，而无须自己处理事务API</li><li>使本地Java方法可以执行远程过程，而无须自己处理远程API</li><li>使本地Java方法成为HTTP端点，而无须自己处理Servlet API</li><li>使本地Java方法可以拥有管理操作，而无须自己处理JMX API</li><li>使本地Java方法可以执行消息处理，而无须自己处理JMS API</li></ul><h3 id="IoC"><a class="header-anchor" href="#IoC"></a>IoC</h3><p>Spring框架的IoC组件就能够通过提供正规化的方法来组合不同的组件。</p><h2 id="侵入式概念"><a class="header-anchor" href="#侵入式概念"></a>侵入式概念</h2><p>Spring是一种非侵入式的框架</p><h3 id="侵入式"><a class="header-anchor" href="#侵入式"></a>侵入式</h3><p>对于EJB、Struts2等一些传统的框架，<strong>通常是要实现特定的接口，继承特定的类才能增强功能，改变了java类的结构</strong></p><h3 id="非侵入式"><a class="header-anchor" href="#非侵入式"></a>非侵入式</h3><p>对于Hibernate、Spring等框架，<strong>对现有的类结构没有影响，就能够增强JavaBean的功能</strong></p><h2 id="Spring-IoC的概念"><a class="header-anchor" href="#Spring-IoC的概念"></a>Spring IoC的概念</h2><p>Spring的IoC容器是整个Spring框架的核心和基础</p><h3 id="Spring-IoC-概述"><a class="header-anchor" href="#Spring-IoC-概述"></a>Spring IoC 概述</h3><p>IoC的全程为Inversion of Control，中文常翻译为“控制反转”，让别人为你服务，是一种通过描述（在Java中可以是XML或者注解）并通过第三方去产生或获取特定对象的方式。</p><p>在Spring中实现控制反转的是IoC容器，实现方法是依赖注入</p><p>“依赖注入”和“控制反转”其实就是一个事物的两种不同的说法。从技术上来讲，“依赖注入”是“控制反转”的特殊实现，但“依赖注入”还指一个对象应用另外一个对象来提供一个特殊能力。</p><p><strong>对象的创建交给外部容器完成，这个就做控制反转。</strong></p><blockquote><p>IoC的思想最核心的地方在于，资源不由使用资源的双方管理，而由不使用资源的第三方管理，这可以带来很多好处。</p><p>第一，资源集中管理，实现资源的可配置和易管理。</p><p>第二，降低了使用资源双方的依赖程度，也就是我们说的耦合度</p></blockquote><h3 id="Spring-IoC容器"><a class="header-anchor" href="#Spring-IoC容器"></a>Spring IoC容器</h3><p>无论是创建对象、处理对象之间的依赖关系、对象创建的时间还是对象的数量，我们都是在Spring为我们提供的IoC容器上配置对象的信息就好了。</p><p>Spring IoC容器的设计主要是基于<code>BeanFactory</code>和<code>ApplicationContext</code>两个接口，其中<code>ApplicationContext</code>是<code>BeanFactory</code>的子接口之一。<code>BeanFactory</code>是Spring IoC容器所定义的最底层接口，而<code>ApplicationContext</code>是其高级接口之一，并且对<code>BeanFactory</code>功能做了许多有用的扩展，故在绝大数工作情况下，都会使用<code>ApplicationContext</code>作为Spring IoC容器。</p><p><img src="http://img.whl123456.top/image/ApplicationContext.png" alt="ApplicationContext"></p><h3 id="BeanFactory"><a class="header-anchor" href="#BeanFactory"></a>BeanFactory</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5.2.6.RELEASE 源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">String FACTORY_BEAN_PREFIX = <span class="string">&quot;&amp;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Object <span class="title">getBean</span><span class="params">(String name, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">ObjectProvider&lt;T&gt; <span class="title">getBeanProvider</span><span class="params">(Class&lt;T&gt; requiredType)</span></span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">ObjectProvider&lt;T&gt; <span class="title">getBeanProvider</span><span class="params">(ResolvableType requiredType)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsBean</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, ResolvableType typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, Class&lt;?&gt; typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">Class&lt;?&gt; getType(String name) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">Class&lt;?&gt; getType(String name, <span class="keyword">boolean</span> allowFactoryBeanInit) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line">String[] getAliases(String name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>![BeanFactory](E:\OneDrive - lanqilu\我的图片库\blogimg\Spring框架\BeanFactory.png)</p><ul><li><code>getBean</code>的方法多用于获取配置给Spring IoC容器的Bean。从参数类型来看可以是字符串，也可以是<code>Class</code>类型，由于<code>Class</code>类型可以扩展接口也可以继承父类，所以在一定程度上会存在使用父类类型无法准确获得实例的异常。</li><li><code>isSingleton</code>用于判断是否为单例，如果判断为真，其意思是该Bean在容器中是作为一个唯一单例存在的。而<code>isPrototype</code>则相反，如果判断为真，意思是当你从容器中获取Bean，容器就为你生成一个新的实例。在默认情况下，Spring会为Bean创建一个单例，也就是默认情况下<code>isSingleton</code>返回true，而<code>isPrototype</code>返回false。</li><li><code>getAliases</code>方法是获取别名的方法。</li></ul><h3 id="容器的初始化和依赖注入"><a class="header-anchor" href="#容器的初始化和依赖注入"></a>容器的初始化和依赖注入</h3><p>Bean的定义和初始化在Spring IoC容器中的是两大步骤，它是先定义，然后初始化和依赖注入。</p><p>Bean的定义分为3步：</p><ul><li>Resource定位：这步是Spring IoC容器根据开发者的配置，进行资源定位，在Spring的开发中，通过XML或者注解都是十分常见的方式，定位的内容是由开发者所提供。</li><li>BeanDefinition的载入：将BeanDefinition的信息保存到Bean定义中，此时不会创建Bean的实例。</li><li>BeanDefinition的注册：将BeanDefinition的信息发布到Spring IoC容器中，但此时仍旧没有对应的Bean的实例创建。</li></ul><p>完成以上3步Bean就在Spring IoC容器中被定义了，而没有初始化，更没有完成依赖注入，也就是没有注入其配置的资源给Bean。</p><p>对于初始化和依赖注入，Spring Bean还有一个配置选项<code>lazy-init</code>，其含义就是是否初始化Spring Bean。在没有任何配置的情况下，它的默认值为default，实际值为false，也就是Spring IoC默认会自动初始化Bean。如果将其设置为true，那么只有当我们使用Spring IoC容器的<code>getBean</code>方法获取它时，它才会进行Bean的初始化，完成依赖注入。</p><h3 id="Bean的生命周期"><a class="header-anchor" href="#Bean的生命周期"></a>Bean的生命周期</h3><p>对于Bean而言，在容器中存在其生命周期，它的初始化和销毁也需要一个过程。</p><p><img src="E:%5CPictures%5Cblogimg%5CSpring%E6%A1%86%E6%9E%B6.assets%5CBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.svg" alt="Bean的生命周期"></p><ul><li>如果Bean实现了<code>BeanNameAware</code>接口的<code>setBeanName</code>方法，那么它就会调用这个方法</li><li>如果Bean实现了<code>BeanFactoryAware</code>接口的<code>setBeanFactory</code>方法，那么它就会调用这个方法</li><li>如果Bean实现了<code>ApplicationContextAware</code>接口的<code>setApplicationContext</code>方法，且Spring IoC容器也必须是一个<code>ApplicationContext</code>接口的实现类，那么才会调用这个方法，否则是不调用</li><li>如果Bean实现了<code>BeanPostProcessor</code>接口的<code>postProcessBeforeInitialization</code>方法，那么它就会调用这个方法（注意它针对全部Bean而言）</li><li>如果Bean实现了<code>InitializingBean</code>接口的<code>afterPropertiesSet</code>方法，那么它就会调用这个方法</li><li>如果Bean自定义了初始化方法，他就会调用已定义的初始化方法。</li><li>如果Bean实现了<code>BeanPostProcessor</code>接口的<code>postProcessAfterInitialization</code>方法，完成了这些调用，这个时候Bean就完成了初始化，那么Bean就存在Spring IoC的容器中，使用者就可以从中获取Bean的服务</li></ul><p>当服务器正常关闭，或者遇到其他关闭Spring IoC容器的事件，它就会调用对应的方法完成Bean的销毁，其步骤入下：</p><ul><li>如果Bean实现了接口<code>DisposableBean</code>的<code>destory</code>方法，那么就会调用它</li><li>如果定义了自定义销毁方法，那么就会调用它</li></ul><h2 id="装配Spring-Bean"><a class="header-anchor" href="#装配Spring-Bean"></a>装配Spring Bean</h2><h3 id="依赖注入的3种方式"><a class="header-anchor" href="#依赖注入的3种方式"></a>依赖注入的3种方式</h3><p>那么对象的对象之间的依赖关系Spring是怎么做的呢？？<strong>依赖注入（Dependency Injection，DI）</strong></p><ul><li><strong>Spring使用依赖注入来实现对象之间的依赖关系</strong></li><li><strong>在创建完对象之后，对象的关系处理就是依赖注入</strong></li></ul><p>一般而言，依赖注入可以分为3种方式：</p><ul><li>构造器注入</li><li>setter注入</li><li>接口注入</li></ul><p>构造器注入和setter注入是主要的方式，而接口注入是从别的地方注入的方式。</p><h4 id="构造器注入"><a class="header-anchor" href="#构造器注入"></a>构造器注入</h4><p>顾名思义，构造器注入依赖于构造方法实现，就是被注入对象可以通过在其构造方法中声明依赖对象的参数列表，让外部（通常是IoC容器）知道它需要哪些依赖对象。</p><p>在大部分情况下，我们通过类的构造方法来创建类对象，Spring也可以采用反射的方式通过使用构造方法来完成注入，这就是构造器注入的原理。</p><p>在配置文件中，<code>constructor-arg</code>元素用于定义类构造方法的参数。包括index方式、type方式和name方式</p><h4 id="setter方法注入"><a class="header-anchor" href="#setter方法注入"></a>setter方法注入</h4><p>setter注入式Spring中最主流的注入方式，它利用Java Bean规范所定义的setter方法来完成注入，灵活且可读性高。</p><p>它消除了使用构造器护注入时出现多个参数的可能性，首先可以把构造方法声明为无参数的，然后使用setter注入为其设置对应的值，其实也是通过Java反射技术实现的。</p><h4 id="三种注入方式的比较"><a class="header-anchor" href="#三种注入方式的比较"></a>三种注入方式的比较</h4><ul><li>接口注入。从注入方式的使用上来说，接口注入是现在不甚提倡的一种方式，基本处于“退役状态”。因为它强制被注入对象实现不必要的接口，带有侵入性。而构造方法注入和setter方法注入则不需要如此。</li><li>构造方法注入。这种注入方式的优点就是，对象在构造完成之后，即已进入就绪状态，可以马上使用。缺点就是，当依赖对象比较多的时候，构造方法的参数列表会比较长。而通过反射构造对象的时候，对相同类型的参数的处理会比较困难，维护和使用上也比较麻烦。而且在Java中，构造方法无法被继承，无法设置默认值。对于非必须的依赖处理，可能需要引入多个构造方法，而参数数量的变动可能造成维护上的不便。</li><li>setter方法注入。因为方法可以命名，所以setter方法注入在描述性上要比构造方法注入好一些。<br>另外，seter方法可以被继承，允许设置默认值，而且有良好的IDE支持。缺点当然就是对象无法在构造完成后马上进入就绪状态。</li><li>综上所述，构造方法注入和setter方法注入因为其侵入性较弱，且易于理解和使用，所以是现在使用最多的注入方式</li></ul><h3 id="装配Bean概述"><a class="header-anchor" href="#装配Bean概述"></a>装配Bean概述</h3><p>将开发的Bean装配到Spring IoC容器中，在大部分场景下使用<code>ApplicationContext</code>的具体实现类，因为对应的Spring IoC容器功能强大。</p><p>而在Spring中提供了3种方法进行配置：</p><ul><li>在XML中显示配置</li><li>在Java的接口和类中实现配置</li><li>隐式Bean的发现机制和自动装配原则</li></ul><p>在学习和工作中，这3种方式都会被用到，且常常混合使用，对于怎么选择有以下几点建议：</p><ul><li>基于约定优于配置的原则，最优先的应该时通过隐式Bean的发现机制和自动装配的原则。这样的好处是减少程序开发者的决定权，简单又不失灵活。</li><li>在没有办法使用自动装配原则的情况下应该优先考虑Java接口和类中实现配置，这样的好处是避免XMl配置的泛滥，也更为容易。这种场景典型了例子是一个父类有多个子类，比如学术类有两个子类：男生类和女生类，通过IoC容器初始化一个学术类，容器将无法知道使用哪个子类去初始化，这个时候可以使用Java的注解配置去指定。</li><li>上述方法都无法使用的情况下，那么只能选择XML去配置Sping IoC容器。由于现实中常常用到第三方的类库，有些类并不是我们开发的，我们无法修改里面的代码，这个时候就通过XML的方式配置使用了。</li></ul><h3 id="通过XML配置装配Bean"><a class="header-anchor" href="#通过XML配置装配Bean"></a>通过XML配置装配Bean</h3><p>使用XML装配Bean需要定义对应的XML，这里需要引入对应的XML模式（XSD）文件，这些文件会定义配置Spring Bean的一些元素</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述代码中引入了一个<code>beans</code>的定义，它是一个根元素，而XSD文件也被引入了，这样它所定义的元素将可以定义对应的Spring Bean</p><h4 id="装配简易值"><a class="header-anchor" href="#装配简易值"></a>装配简易值</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;source&quot;</span> <span class="attr">class</span>=<span class="string">&quot;top.whl.pojo2.Source&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;fruit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;橙汁&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;size&quot;</span> <span class="attr">value</span>=<span class="string">&quot;大杯&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sugar&quot;</span> <span class="attr">value</span>=<span class="string">&quot;少糖&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;juiceMaker2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;top.whl.pojo2.JuiceMaker2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;beverageShop&quot;</span> <span class="attr">value</span>=<span class="string">&quot;贡茶&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;source&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;source&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>id</code>属性是Spring找到这个Bean的编号，不过<code>id</code>不是一个必须的属性，如果没有声明它，那么Spring会采用<code>全限定名#&#123;number&#125;</code>的格式生成编号。例如：没有声明<code>id=&quot;source&quot;</code>，那么Spring为其生成的编号就是<code>&quot;top.whl.pojo2.Source#0&quot;</code>。当第二次声明没有id的属性的Bean时，编号就是<code>&quot;top.whl.pojo2.Source#1&quot;</code>，以此类推。</li><li><code>class</code> 是一个类的全限定名</li><li><code>property</code> 元素是定义类的属性，其中<code>name</code>属性定义的是属性名称，而<code>value</code>是其值</li><li><code>ref</code> 引用Spring中创建好的对象</li></ul><h4 id="装配集合"><a class="header-anchor" href="#装配集合"></a>装配集合</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>value-list-1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>value-list-2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>value-list-3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>List</code>属性为对应的<code>&lt;list&gt;</code>元素进行装配，然后通过多个<code>&lt;value&gt;</code>元素设值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;key1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;value-key-1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;key2&quot;</span> <span class="attr">value</span>=<span class="string">&quot;value-key-2&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;key3&quot;</span> <span class="attr">value</span>=<span class="string">&quot;value-key-3&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>Map</code>属性为对应的<code>map</code>元素进行装配，然后通过多个<code>&lt;entry&gt;</code>元素设值，其中<code>entry</code>包含一个键（key）和一个值（value）的设置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;props&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;prop1&quot;</span>&gt;</span>value-prop-1<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;prop2&quot;</span>&gt;</span>value-prop-2<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;prop3&quot;</span>&gt;</span>value-prop-3<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>Properties</code>属性，为对应的<code>&lt;props&gt;</code>元素进行装配，通过多个<code>&lt;prop&gt;</code>元素设置，其中<code>&lt;prop&gt;</code>元素有一个必填属性key，然后在之间设置值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;set&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>value-set-1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>value-set-2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>value-set-3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>Set</code>属性为对应的<code>&lt;set&gt;</code>元素进行装配，然后通过多个<code>&lt;value&gt;</code>元素设置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;array&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>value-array-1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>value-array-2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>value-array-3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于数组而言，可以使用<code>&lt;array&gt;</code>设置值，然后通过多个<code>&lt;value&gt;</code>元素设值。</p><hr><p>有些时候需要更为复杂的装载，比如一个List可以是一系列的对象，又如Map集合类，键可以 是一个类的对象，而值也要是一个类的对象。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;role1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;role2&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>List</code>属性使用<code>&lt;list&gt;</code>元素定义注入，使用多个<code>&lt;ref&gt;</code>元素的Bean属性去引用之前定义好的Bean</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key-ref</span>=<span class="string">&quot;role2&quot;</span> <span class="attr">value</span>=<span class="string">&quot;user1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key-ref</span>=<span class="string">&quot;role2&quot;</span> <span class="attr">value</span>=<span class="string">&quot;user2&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>Map</code>属性使用<code>&lt;map&gt;</code>元素定义注入，使用多个<code>&lt;enty&gt;</code>元素的<code>key-ref</code>属性去引用之前定义好的Bean做键，而用<code>value-ref</code>属性去引用之前定义好的Bean做值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;set&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;role1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;role2&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>Set</code>属性使用<code>&lt;set&gt;</code>元素定义注入，使用多个<code>&lt;ref&gt;</code>元素的Bean去引用之前定义好的Bean</p><h4 id="命名空间装配"><a class="header-anchor" href="#命名空间装配"></a>命名空间装配</h4><h3 id="通过注解装配Bean"><a class="header-anchor" href="#通过注解装配Bean"></a>通过注解装配Bean</h3><p>使用注解的方式可以减少XML的配置，注解功能更为强大，它既能实现XML的功能，也提供了自动装配的功能，采用了自动装配后，程序员所需要做的决断就少了，更加有利于程序的开发，这就是“约定优于配置”的开发原则。</p><p>在Spring中，它提供了两种方式来让Spring IoC容器发现Bean</p><ul><li>组件扫描：通过定义资源的方式，让Sprnig IoC容器扫描对应的包，从而把Bean装配进来。</li><li>自动装配：通过注解定义，使得一些依赖关系可以通过注解完成</li></ul><h4 id="使用-Component装配Bean"><a class="header-anchor" href="#使用-Component装配Bean"></a>使用<code>@Component</code>装配Bean</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(value = &quot;role&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Role</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;1&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="meta">@Value(&quot;role_name_1&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String roleName;</span><br><span class="line">    <span class="meta">@Value(&quot;role_note_1&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String note;</span><br><span class="line">    <span class="comment">/**** setter and getter ****/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注解<code>@Component</code>代表Spring IoC会把这个类扫描生成Bean实例，而其中的<code>value</code>属性代表这个类在Spring中的id，就相当于XML方式定义的Bean的id，也可以简写成<code>@Component(“role”)</code>，甚至直接写成<code>@Component</code>，对于不写的，Spring IoC容器就默认为类名，但是以首字母小写的形式作为id，为其生成对象，配置到容器中。</li><li>注解<code>@Value</code>代表是是值的注入，这里只是简单注入一些值，其中id是一个long型，注入的时候Spring会为其转化类型</li></ul><p>现在有了这个类，但是还不能进行测试，因为Spring IoC并不知道需要去哪里扫描对象，这个时候可以在同一个包下创建一个Java Config类来告诉它</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PojoConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类十分简单但要注意<code>@ComponentScan</code>代表进行扫描，默认是扫描当前包的路径，POJO的包名和它保持一致才能进行扫描，否则不行。</p><p>接下来通过Spring定义好的Spring IoC容器实现类<code>AnnotationConfigApplicationContext</code>去生成IoC容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pojo2Text</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(PojoConfig.class);</span><br><span class="line">        Role role = context.getBean(Role.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;role.getId() = &quot;</span> + role.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可以看出两个明显的弊端：</p><ul><li>对于<code>@ComponentScan</code>注解，它只是扫描所在包的Java类，但更多的时候需要的是可以扫描所指定的类</li><li>上面只注入了一些简单的值，而没有注入对象，同样在现实的开发中可以注入对象是十分重要的，也是常见的场景</li></ul><p><code>@ComponentScan</code>存在着两个配置项：</p><ul><li>第一个是<code>basePackages</code>，它是由base和package两个单词组成的，而package还使用了复数，意味着它可以配置一个Java包的数组，Spring会根据它的配置扫描对应的包和子包，将配置好的Bean装配起来</li><li>第二个是<code>basePackageClasses</code>，Class采用复数，意味着它可以配置多个类，Spring会根据配置的类所在的包，为包和子包进行扫描装配对应配置的Bean</li></ul><p>为验证<code>@ComponentScan</code>的配置项，首先定义一个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.whl.service2;</span><br><span class="line"><span class="keyword">import</span> top.whl.pojo2.Role;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RoleService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printRoleInfo</span><span class="params">(Role role)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用接口来编写一些操作类是Spring所推荐的，它可以将定义和实现相分离。接口的实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.whl.service2.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> top.whl.pojo2.Role;</span><br><span class="line"><span class="keyword">import</span> top.whl.service2.RoleService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoleServiceImpl</span> <span class="keyword">implements</span> <span class="title">RoleService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printRoleInfo</span><span class="params">(Role role)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;id = &quot;</span> + role.getId());</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + role.getRoleName());</span><br><span class="line">        System.out.println(<span class="string">&quot;note = &quot;</span> + role.getNote());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置<code>@ComponentScan</code>指定包扫描</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.whl.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> top.whl.pojo2.Role;</span><br><span class="line"><span class="keyword">import</span> top.whl.service2.RoleService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ComponentScan(basePackageClasses = &#123;Role.class, RoleService.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Service2Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(ApplicationConfig.class);</span><br><span class="line"></span><br><span class="line">        Role role = context.getBean(Role.class);</span><br><span class="line">        RoleService roleService = context.getBean(RoleService.class);</span><br><span class="line">        roleService.printRoleInfo(role);</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自动装配——-Autowired"><a class="header-anchor" href="#自动装配——-Autowired"></a>自动装配——<code>@Autowired</code></h4><h3 id="Spring模块"><a class="header-anchor" href="#Spring模块"></a>Spring模块</h3><p><strong>Spring可以分为6大模块</strong>：</p><ul><li><strong>Spring Core</strong>： Spring的核心功能： IOC容器, 解决对象创建及依赖关系</li><li><strong>Spring Web</strong>： Spring对web模块的支持。<ul><li>可以与struts整合,让struts的action创建交给spring</li><li>spring mvc模式</li></ul></li><li><strong>Spring DAO</strong>： Spring 对jdbc操作的支持 【JdbcTemplate模板工具类】</li><li><strong>Spring ORM</strong>： Spring对orm的支持：<ul><li>既可以与hibernate整合，【session】</li><li>也可以使用spring的对hibernate操作的封装</li></ul></li><li><strong>Spring AOP</strong>： 切面编程</li><li><strong>SpringEE</strong>： Spring 对JavaEE其他模块的支持</li></ul><p><img src="http://img.whl123456.top/image/Spring%E6%A1%86%E6%9E%B6.png" alt="Sping"></p><h3 id="Spring-Core模块"><a class="header-anchor" href="#Spring-Core模块"></a>Spring Core模块</h3><p>核心容器</p><h2 id="HelloSpirng"><a class="header-anchor" href="#HelloSpirng"></a>HelloSpirng</h2><blockquote><p>对应源码实例为：HelloSpring</p></blockquote><h2 id="applicationContext-xml的配置"><a class="header-anchor" href="#applicationContext-xml的配置"></a>applicationContext.xml的配置</h2><h3 id="别名"><a class="header-anchor" href="#别名"></a>别名</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&quot;原名&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;别名&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>原名和别名都可以被Spring创建，获取到原名对应的对象</p><h3 id="Bean的配置"><a class="header-anchor" href="#Bean的配置"></a>Bean的配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;top.whl.pojo.User&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user3,u3&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;whl_property&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>id</code>：bean的唯一标识符，是java类中的对象名</p><p><code>class</code>：bean对象对应的全限定名：包名+类名</p><p><code>name</code>：别名，可以同时取多个别名（用逗号、空格或分号分开），比<code>alias</code>更高级</p><h3 id="import"><a class="header-anchor" href="#import"></a>import</h3><p>用于团队开发，将多个配置文件导入合并</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;beans2.xml&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>对应源码实例为：SpringIoC02</p></blockquote><h2 id="依赖注入（DI）"><a class="header-anchor" href="#依赖注入（DI）"></a>依赖注入（DI）</h2><h3 id="构造器注入-v2"><a class="header-anchor" href="#构造器注入-v2"></a>构造器注入</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;top.whl.pojo.User&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user3,u3 u4&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--index方式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;whl_constructor-arg_index&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;top.whl.pojo.User&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user3,u3 u4&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--type方式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;whl_constructor-arg_type&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;top.whl.pojo.User&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user3,u3 u4&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;whl_constructor-arg_name&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>对应源码实例为：SpringIoC02</p></blockquote><h3 id="Set方式注入"><a class="header-anchor" href="#Set方式注入"></a>Set方式注入</h3><p>需要类中有Set方法</p><ul><li>依赖：bean对象的创建依赖于容器</li><li>注入：bean对象中的所有属性，由容器来注入</li></ul><p>测试对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    <span class="keyword">private</span> String[] books;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; hobbies;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; card;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; games;</span><br><span class="line">    <span class="keyword">private</span> String oh;</span><br><span class="line">    <span class="keyword">private</span> Properties info;</span><br><span class="line">    <span class="comment">//省略getter、setter和toString方法代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Text01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//CPX</span></span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        Student student = (Student) context.getBean(<span class="string">&quot;student&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;student.toString() = &quot;</span> + student.toString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注入方式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;address&quot;</span> <span class="attr">class</span>=<span class="string">&quot;top.whl.pojo.Address&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">value</span>=<span class="string">&quot;浙江&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;top.whl.pojo.Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--01 普通值注入直接使用value--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;whl&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--02 Bean注入使用ref--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;address&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--03 数组注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;books&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>红楼梦<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>西游记<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>水浒传<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>三国演义<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--04 List注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hobbies&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>篮球<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>足球<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>乒乓球<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>羽毛球<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--05 Map注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;card&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;学号&quot;</span> <span class="attr">value</span>=<span class="string">&quot;000000&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;身份证号&quot;</span> <span class="attr">value</span>=<span class="string">&quot;000000&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;银行卡号&quot;</span> <span class="attr">value</span>=<span class="string">&quot;000000&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--06 Set注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;games&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>LOL<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>CS<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--07 null注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;oh&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--08 Properties--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span> &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;姓名&quot;</span>&gt;</span>whl<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;年龄&quot;</span>&gt;</span>18<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;性别&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;driver&quot;</span>&gt;</span>000<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;url&quot;</span>&gt;</span>000<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;username&quot;</span>&gt;</span>000<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;password&quot;</span>&gt;</span>000<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>对应源码实例：SpringDI</p></blockquote><h3 id="拓展方式注入"><a class="header-anchor" href="#拓展方式注入"></a>拓展方式注入</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:c</span>=<span class="string">&quot;http://www.springframework.org/schema/c&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--p命名空间注入直接注入属性的值 property--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;top.whl.pojo.User&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;whl&quot;</span> <span class="attr">p:age</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--c命名空间注入 constructor--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;top.whl.pojo.User&quot;</span> <span class="attr">c:age</span>=<span class="string">&quot;19&quot;</span> <span class="attr">c:name</span>=<span class="string">&quot;whl02&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;user.xml&quot;</span>);</span><br><span class="line">    User user = context.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line">    System.out.println(<span class="string">&quot;user = &quot;</span> + user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;user.xml&quot;</span>);</span><br><span class="line">    User user2 = context.getBean(<span class="string">&quot;user2&quot;</span>, User.class);</span><br><span class="line">    System.out.println(<span class="string">&quot;user2 = &quot;</span> + user2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>测试对象User类中需要设置无参构造和有参构造才能使用c命名空间</p></blockquote><h2 id="Bean作用域"><a class="header-anchor" href="#Bean作用域"></a>Bean作用域</h2><table><thead><tr><th style="text-align:left">Scope</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-scopes-singleton">singleton</a></td><td style="text-align:left">(Default) Scopes a single bean definition to a single object instance for each Spring IoC container.</td></tr><tr><td style="text-align:left"><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-scopes-prototype">prototype</a></td><td style="text-align:left">Scopes a single bean definition to any number of object instances.</td></tr><tr><td style="text-align:left"><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-scopes-request">request</a></td><td style="text-align:left">Scopes a single bean definition to the lifecycle of a single HTTP request. That is, each HTTP request has its own instance of a bean created off the back of a single bean definition. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>.</td></tr><tr><td style="text-align:left"><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-scopes-session">session</a></td><td style="text-align:left">Scopes a single bean definition to the lifecycle of an HTTP <code>Session</code>. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>.</td></tr><tr><td style="text-align:left"><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-scopes-application">application</a></td><td style="text-align:left">Scopes a single bean definition to the lifecycle of a <code>ServletContext</code>. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>.</td></tr><tr><td style="text-align:left"><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#websocket-stomp-websocket-scope">websocket</a></td><td style="text-align:left">Scopes a single bean definition to the lifecycle of a <code>WebSocket</code>. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>.</td></tr></tbody></table><h3 id="singleton单例模式"><a class="header-anchor" href="#singleton单例模式"></a>singleton单例模式</h3><p>无论使用多少个Bean只有一个实例被创建，默认实现</p><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;user.xml&quot;</span>);</span><br><span class="line">    User user2 = context.getBean(<span class="string">&quot;singleton&quot;</span>, User.class);</span><br><span class="line">    User user3 = context.getBean(<span class="string">&quot;singleton&quot;</span>, User.class);</span><br><span class="line">    System.out.println(user3==user2);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显式创建</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;singleton&quot;</span> <span class="attr">class</span>=<span class="string">&quot;top.whl.pojo.User&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="prototype原型模式"><a class="header-anchor" href="#prototype原型模式"></a>prototype原型模式</h3><p>每次从容器（context）中getBean都会产生新对象</p><p>创建</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;prototype&quot;</span> <span class="attr">class</span>=<span class="string">&quot;top.whl.pojo.User&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;user.xml&quot;</span>);</span><br><span class="line">    User user2 = context.getBean(<span class="string">&quot;prototype&quot;</span>, User.class);</span><br><span class="line">    User user3 = context.getBean(<span class="string">&quot;prototype&quot;</span>, User.class);</span><br><span class="line">    System.out.println(user3==user2);<span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对应源码实例：SpringDI</p></blockquote><h3 id="其余"><a class="header-anchor" href="#其余"></a>其余</h3><p>其余在Web开发中使用</p><h2 id="Bean的自动装配"><a class="header-anchor" href="#Bean的自动装配"></a>Bean的自动装配</h2><p>3种装配方式：</p><ul><li>在xml中显式配置</li><li>在java中显式配置</li><li>隐式的自动装配</li></ul><h3 id="ByName"><a class="header-anchor" href="#ByName"></a>ByName</h3><p>自动在容器上下文中查找和对象set后对应的bean的id，id唯一且与set方法对应</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;top.whl.pojo.Person&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="ByType"><a class="header-anchor" href="#ByType"></a>ByType</h3><p>自动在容器上下文中查找和对象属性相同的bean，class唯一，可以省略bean的id</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person3&quot;</span> <span class="attr">class</span>=<span class="string">&quot;top.whl.pojo.Person&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="注解"><a class="header-anchor" href="#注解"></a>注解</h3><p>xml中导入context约束和开启注解支持</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>类中属性和Setter方法中开启注解，在类中可以不用写Set方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Cat cat;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//省略getter、setter和toString方法代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Autowired(required = true)</code>默认为true，如果设置<code>@Autowired(required = false)</code>，什么对象可以为null</p><p>但Bean中一个类配置多个id时使用<code>@Qualifier(value = &quot;对应id&quot;)</code>配合<code>@Autowired</code>可以指定bean，类型需要对应</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(value = &quot;dog2&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Dog dog;</span><br></pre></td></tr></table></figure><blockquote><p>对应源码实例：Autowire</p></blockquote><h2 id="使用注解开发"><a class="header-anchor" href="#使用注解开发"></a>使用注解开发</h2><p><code>@Autowired</code>：自动装配，放在属性前面</p><p><code>@Nullable</code>：表示字段可以为空，放在形参前面</p><p><code>@Resource</code>：Java中的注解，用于自动装配，Java11移除</p><p><code>@Component</code>：被扫描类，放在类前，配合Bean中<code>&lt;context:component-scan base-package=&quot;包名&quot;/&gt;</code>使用，等价于<code>&lt;bean id=&quot;&quot; class=&quot;&quot;/&gt;</code></p><p><code>@Value(&quot;值&quot;)</code>：等价于<code>&lt;property name=&quot;&quot; value=&quot;&quot;&gt;</code>，复杂值推荐走配置文件，放在属性或对应Set方法前</p><h3 id="前提配置bean"><a class="header-anchor" href="#前提配置bean"></a>前提配置bean</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--扫描指定目录下的包，使注解生效--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;top.whl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="属性注入"><a class="header-anchor" href="#属性注入"></a>属性注入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @Value(&quot;WHL&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;WHL1&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="衍生的注解"><a class="header-anchor" href="#衍生的注解"></a>衍生的注解</h3><p><code>@Component</code>有几个衍生注解，在Web开发中，按照MVC结构分层</p><ul><li>DAO：使用<code>@Repository</code></li><li>Service：使用<code>@Service</code></li><li>Controller：使用<code>@Controller</code></li></ul><p>以上注解功能同<code>@Component</code></p><h3 id="自动装配"><a class="header-anchor" href="#自动装配"></a>自动装配</h3><p><code>@Autowired</code>：自动装配，放在属性前面</p><p><code>@Nullable</code>：表示字段可以为空，放在形参前面</p><p><code>@Resource</code>：Java中的注解，用于自动装配，Java11移除</p><p>详见Bean的自动装配</p><h3 id="作用域"><a class="header-anchor" href="#作用域"></a>作用域</h3><p><code>@Scope(&quot;XXX&quot;)</code>详见Bean作用域</p><blockquote><p>对应源码实例：Annotation</p></blockquote><h3 id="小结"><a class="header-anchor" href="#小结"></a>小结</h3><ul><li>使用xml用来管理Bean</li><li>使用注解来完成属性注入</li></ul><h2 id="使用Java的方式配置Bean"><a class="header-anchor" href="#使用Java的方式配置Bean"></a>使用Java的方式配置Bean</h2><p>JavaConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;WHL&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;top.whl&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config01</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设计模式"><a class="header-anchor" href="#设计模式"></a>设计模式</h2><h3 id="静态代理"><a class="header-anchor" href="#静态代理"></a>静态代理</h3><p>代理的好处</p><ul><li><p>可以使真实角色的操作更加纯粹!不用去关注一些公共的业务</p></li><li><p>公共也就就交给代理角色!实现了业务的分工!</p></li><li><p>公共业务发生扩展的时候，方便集中管理!</p></li></ul><p>缺点</p><ul><li>一个真实角色就会产生1个代理角色</li><li>代码量会翻倍开发效率会变低</li></ul><p>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Rent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真实角色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Host</span> <span class="keyword">implements</span> <span class="title">Rent</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;房东出租房子&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Rent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Host host;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">(Host host)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        host.rent();</span><br><span class="line">        fee();</span><br><span class="line">        sign();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fee</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收小费&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sign</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;签合同&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端访问代理角色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Host host = <span class="keyword">new</span> Host();</span><br><span class="line">        Proxy proxy = <span class="keyword">new</span> Proxy(host);</span><br><span class="line">        proxy.rent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在不改变真实角色的代码的前提下增加功能</p><blockquote><p>对应实例源码：proxy</p></blockquote><h3 id="动态代理"><a class="header-anchor" href="#动态代理"></a>动态代理</h3><p>在静态代理的优点基础上还有</p><ul><li>一个动态代理可以代理多个类，只要改变接口</li></ul><p>实现方式</p><ul><li><p>基于接口的动态代理（JDK反射）</p></li><li><p>基于类的动态代理（CGLib）</p></li><li><p>Java字节码实现（Javasist）</p></li></ul><p>使用基于接口的动态代理</p><p>需要了解的两个类：<code>Proxy</code>（代理），<code>InvocationHandler</code>（调用处理）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//被代理的接口</span></span><br><span class="line">    <span class="keyword">private</span> Rent rent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRent</span><span class="params">(Rent rent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rent = rent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成得到代理类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(<span class="keyword">this</span>.getClass().getClassLoader(), rent.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理代理实例，并返回结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object o, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//反射实现</span></span><br><span class="line">        Object result = method.invoke(rent, args);</span><br><span class="line">        fee();</span><br><span class="line">        sign();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收小费&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sign</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;签合同&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//真实角色</span></span><br><span class="line">        Host host = <span class="keyword">new</span> Host();</span><br><span class="line">        <span class="comment">//代理角色（不存在）</span></span><br><span class="line">        ProxyInvocationHandler proxyInvocationHandler = <span class="keyword">new</span> ProxyInvocationHandler();</span><br><span class="line">        <span class="comment">//通过调用程序处理角色</span></span><br><span class="line">        proxyInvocationHandler.setRent(host);</span><br><span class="line">        Rent proxy = (Rent) proxyInvocationHandler.getProxy();<span class="comment">// 动态生成</span></span><br><span class="line">        proxy.rent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面向切面编程（AOP）"><a class="header-anchor" href="#面向切面编程（AOP）"></a>面向切面编程（AOP）</h2><p>AOP (Aspect Oriented Programming)意为：面向切面编程，通过<strong>预编译</strong>方式和运行期<strong>动态代理</strong>实现程序功能的统一维护的一种技术。</p><ul><li>Aspect（切面）：将关注点进行模块化。某些关注点可能会横跨多个对象，如事务管理，它是Java企业级应用中一个关于横切关注点很好的例子。在 Spring AOP中，切面可以使用常规类（基于模式的方法）或使用<code>@Aspect</code>注解的常规类来实现切面。</li><li>Join Point（连接点）：在程序执行过程中某个特定的点，如某方法调用时或处理异常时。在 Spring AOP中，一个连接点总是代表一个方法的执行。</li><li>Advice（通知）：在切面的某个特定的连接点上执行的动作。通知有各种类型，其中包括&quot;around&quot;、&quot;before&quot;和&quot;after&quot;等通知。许多AOP框架，包括 Spring，都是以拦截器来实现通知模型的，并维护一个以连接点为中心的拦截器链。</li><li>Pointcut（切入点）：匹配连接点的断言。通知和一个切入点表达式关联，并在满足这个切入点的连接点上运行（如当执行某个特定名称的方法时）。切入点表达式如何和连接点匹配是AOP的核心。 Spring默认使用 AspectJ切入点语法。</li><li>Introduction（引入）：声明额外的方法或某个类型的字段。 Spring允许引入新的接口（及个对应的实现）到任何被通知的对象。例如，可以使用一个引入来使bean实现 IsModified 接口以便简化缓存机制。在 AspectJ社区， Introduction也被称为 Inter-type Declaration（内部类型声明）。</li><li>Target Object（目标对象）：被一个或多个切面所通知的对象。也有人把它称为 Advised（被通知）对象。既然 Spring AOP是通过运行时代理实现的，那这个对象永远是一个 Proxied（被代理）对象。</li><li>AOP Proxy（AOP代理）：AOP框架创建的对象，用来实现 Aspect Contract（切面契约）包括通知方法执行等功能。在 Spring中，AOP代理可以是JDK动态代理或CGLB代理。</li><li>Weaving（织入）：把切面连接到其他的应用程序类型或对象上，并创建一个 Advised（被通知）的对象。这些可以在编译时（如使用 AspectJ编译器）、类加载时完成。</li></ul><p>Spring与其他纯Java AOP框架一样，在运行时完成织入。其中有关Advice（通知）的类型主要有以下几种：</p><ul><li>Before Advice（前置通知）：在某连接点之前执行的通知，但这个通知不能阻止连接点前的执行（除非它抛出一个异常）。</li><li>After Returning Advice（返回后通知）：在某连接点正常完成后执行的通知，如果一个方法没有抛出任何异常，将正常返回。</li><li>After Throwing Advice（抛出异常后通知）：在方法抛出异常退出时执行的通知</li><li>After（ finally） Advice（最后通知）：当某连接点退出时执行的通知（不论是正常返回还是异常退出）</li><li>Around Advice（环绕通知）：包围一个连接点的通知，如方法调用。这是最强大的一种通知类型。环绕通知可以在方法调用前后完成自定义的行为，它也会选择是否继续执行连接点，或者直接返回它们自己的返回值或抛出异常来结束执行。 Around Advice是最常用的一种通知类型。与AspectJ一样， Spring提供所有类型的通知，推荐使用尽量简单的通知类型来实现需要的功能。例如，如果只是需要用一个方法的返回值来更新缓存，虽然使用环绕通知也能完成同样的事情，但最好是使用 After Returnin通知，而不是使用环绕通知。用最合适的通知类型可以使编程模型变得简单，并且能够避免很多潜在的错误。例如，如果不调用 Join point（用于 Around Advice）的 proceed()方法，就不会有调用的问题。</li></ul><p>AOP是OOP的延续,是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p><h3 id="AOP在Spring中的作用"><a class="header-anchor" href="#AOP在Spring中的作用"></a>AOP在Spring中的作用</h3><p>提供声明式事务；允许用户自定义切面</p><ul><li><p>横切关注点：跨越应用程序多个模块的方法或功能。即使与业务逻辑无关，但需要关注的部分就是横切关注点。如日志、安全、缓存、事务等</p></li><li><p>切面（Aspect）：横切关注点被模块化的特殊对象。即，一个类。</p></li><li><p>通知（Advice）：切面必须要完成的工作。即，类中的一个方法。</p></li><li><p>目标（Target）：被通知的对象。</p></li><li><p>代理（Proxy）：向目标对象应用通知之后创建的对象。</p></li><li><p>切入点（PointCut）：切面通知执行的“地点”的定义</p></li><li><p>连接点（JointPoint）：与切入点匹配的执行点。</p></li></ul><p>![AOP](E:\OneDrive - lanqilu\我的图片库\blogimg\Spring框架\AOP.svg)</p><table><thead><tr><th>通知类型</th><th>连接点</th><th>实现接口</th></tr></thead><tbody><tr><td>前置通知</td><td>方法前</td><td>org.springframework.aop.MethodBeforeAdvice</td></tr><tr><td>后置通知</td><td>方法后</td><td>org.springframework.aop.AfterReturningAdvice</td></tr><tr><td>环绕通知</td><td>方法前后</td><td>org.aopalliance.intercept.MethodInterceptor</td></tr><tr><td>异常抛出通知</td><td>方法抛出异常</td><td>org.springframework.aop.ThrowsAdvice</td></tr><tr><td>引介通知</td><td>类中增加新的方法属性</td><td>org.springframework.aop.IntroductionAdvisor</td></tr></tbody></table><p>总结：AOP在不改变原有代码的情况下，去增加新的功能。</p><h2 id="使用Spring实现AOP"><a class="header-anchor" href="#使用Spring实现AOP"></a>使用Spring实现AOP</h2><h3 id="导入依赖"><a class="header-anchor" href="#导入依赖"></a>导入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="创建Service业务类"><a class="header-anchor" href="#创建Service业务类"></a>创建Service业务类</h3><p>创建UserService接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.halo.service;</span><br><span class="line"></span><br><span class="line">public interface UserService &#123;</span><br><span class="line">    public void add();</span><br><span class="line"></span><br><span class="line">    public void delete();</span><br><span class="line"></span><br><span class="line">    public void update();</span><br><span class="line"></span><br><span class="line">    public void select();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实现UserService接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.halo.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;增加了用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;删除了用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;更新了用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;查询了用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现方式一：使用Spring的API接口"><a class="header-anchor" href="#实现方式一：使用Spring的API接口"></a>实现方式一：使用Spring的API接口</h3><p>创建BeforeLog类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.halo.log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.MethodBeforeAdvice;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeforeLog</span> <span class="keyword">implements</span> <span class="title">MethodBeforeAdvice</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method: 要执行的目标对象的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args: 参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target:  目标对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(target.getClass().getName() + <span class="string">&quot; 的 &quot;</span> + method.getName() + <span class="string">&quot; 被执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建AfterLog类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.halo.log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.AfterReturningAdvice;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfterLog</span> <span class="keyword">implements</span> <span class="title">AfterReturningAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> returnValue: 返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(Object returnValue, Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了 &quot;</span> + method.getName() + <span class="string">&quot; 方法,返回的结果为: &quot;</span> + returnValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建并配置applicationContext.xml</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xmlns:aop=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/aop</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--注册Bean--&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;userService&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.halo.service.UserServiceImpl&quot;</span>/&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;beforeLog&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.halo.log.BeforeLog&quot;</span>/&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;afterLog&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.halo.log.AfterLog&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--使用原生SpringAPI接口--&gt;</span><br><span class="line">    &lt;!--配置AOP,需要导入AOP的约束--&gt;</span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line">        &lt;!--切入点:开始执行的位置--&gt;</span><br><span class="line">        &lt;!--execution(要执行的位置)--&gt;</span><br><span class="line">        &lt;aop:pointcut id=<span class="string">&quot;pointcut&quot;</span> expression=<span class="string">&quot;execution(* com.halo.service.UserServiceImpl.*(..))&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--执行环绕增加--&gt;</span><br><span class="line">        &lt;aop:advisor advice-ref=<span class="string">&quot;beforeLog&quot;</span> pointcut-ref=<span class="string">&quot;pointcut&quot;</span>/&gt;</span><br><span class="line">        &lt;aop:advisor advice-ref=<span class="string">&quot;afterLog&quot;</span> pointcut-ref=<span class="string">&quot;pointcut&quot;</span>/&gt;</span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>进行测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.halo.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AOPTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="comment">// 动态代理接口 不是实现类</span></span><br><span class="line">        UserService userService = context.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class);</span><br><span class="line">        userService.add();</span><br><span class="line">        userService.delete();</span><br><span class="line">        userService.select();</span><br><span class="line">        userService.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现方式二：自定义来实现AOP"><a class="header-anchor" href="#实现方式二：自定义来实现AOP"></a>实现方式二：自定义来实现AOP</h3><p>创建CustomPointCut类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.halo.custom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomPointCut</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;======方法执行前======&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;======方法执行后======&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置applicationContext.xml</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xmlns:aop=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/aop</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--注册Bean--&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;userService&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.halo.service.UserServiceImpl&quot;</span>/&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;custom&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.halo.custom.CustomPointCut&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line">        &lt;!--自定义切面 ref = 要引入的类--&gt;</span><br><span class="line">        &lt;aop:aspect ref=<span class="string">&quot;custom&quot;</span>&gt;</span><br><span class="line">            &lt;!--切入点--&gt;</span><br><span class="line">            &lt;aop:pointcut id=<span class="string">&quot;point&quot;</span> expression=<span class="string">&quot;execution(* com.halo.service.UserServiceImpl.*(..)) &quot;</span>/&gt;</span><br><span class="line">            &lt;!--通知--&gt;</span><br><span class="line">            &lt;aop:before method=<span class="string">&quot;before&quot;</span> pointcut-ref=<span class="string">&quot;point&quot;</span>/&gt;</span><br><span class="line">            &lt;aop:after method=<span class="string">&quot;after&quot;</span> pointcut-ref=<span class="string">&quot;point&quot;</span>/&gt;</span><br><span class="line">        &lt;/aop:aspect&gt;</span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>测试类不变</p><h3 id="实现方式三-注解"><a class="header-anchor" href="#实现方式三-注解"></a>实现方式三 注解</h3><p>创建AnnotationAOP类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.halo.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.Signature;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.After;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationAOP</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.halo.service.UserServiceImpl.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[Before]:方法执行前&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;execution(* com.halo.service.UserServiceImpl.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[After] :方法执行后&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在环绕增强中我们可以给定一个参数，代表我们要获取处理切入的点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Around(&quot;execution(* com.halo.service.UserServiceImpl.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[Around]:环绕前&quot;</span>);</span><br><span class="line">        <span class="comment">// 执行方法</span></span><br><span class="line">        Object proceed = joinPoint.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;[Around]:环绕后&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得签名</span></span><br><span class="line">        Signature signature = joinPoint.getSignature();</span><br><span class="line">        System.out.println(<span class="string">&quot;[signature]:&quot;</span> + signature);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建并配置applicationContext.xml</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xmlns:aop=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/aop</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">&quot;userService&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.halo.service.UserServiceImpl&quot;</span>/&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;annotationAOP&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.halo.Log.AnnotationAOP&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--开启注解支持--&gt;</span><br><span class="line">    &lt;!--proxy-target-<span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;false&quot;</span> 默认JDK,<span class="keyword">true</span>是cglib--&gt;</span><br><span class="line">    &lt;aop:aspectj-autoproxy proxy-target-<span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;false&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>测试Application同一二方法</p>]]></content>
      
      
      <categories>
          
          <category> JavaEE </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora快捷键</title>
      <link href="2020/03/21/Typora%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>2020/03/21/Typora%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<p>Typora快捷键</p><hr><h2 id="一、菜单栏"><a class="header-anchor" href="#一、菜单栏"></a>一、菜单栏</h2><ul><li>文件：<kbd>Alt</kbd>+<kbd>F</kbd></li><li>编辑：<kbd>Alt</kbd>+<kbd>E</kbd></li><li>段落：<kbd>Alt</kbd>+<kbd>P</kbd></li><li>格式：<kbd>Alt</kbd>+<kbd>O</kbd></li><li>视图：<kbd>Alt</kbd>+<kbd>V</kbd></li><li>主题：<kbd>Alt</kbd>+<kbd>T</kbd></li><li>帮助：<kbd>Alt</kbd>+<kbd>H</kbd></li></ul><h2 id="二、文件"><a class="header-anchor" href="#二、文件"></a>二、文件</h2><ul><li>新建：<kbd>Ctrl</kbd>+<kbd>N</kbd></li><li>新建窗口：<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>N</kbd></li><li>打开：<kbd>Ctrl</kbd>+<kbd>O</kbd></li><li>快速打开：<kbd>Ctrl</kbd>+<kbd>P</kbd></li><li>保存：<kbd>Ctrl</kbd>+<kbd>S</kbd></li><li>另存为：<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>S</kbd></li><li>偏好：<kbd>Ctrl</kbd>+<kbd>,</kbd></li><li>关闭：<kbd>Ctrl</kbd>+<kbd>W</kbd></li></ul><h2 id="三、编辑"><a class="header-anchor" href="#三、编辑"></a>三、编辑</h2><ul><li>撤销：<kbd>Ctrl</kbd>+<kbd>Z</kbd></li><li>重做：<kbd>Ctrl</kbd>+<kbd>Y</kbd></li><li>剪切：<kbd>Ctrl</kbd>+<kbd>X</kbd></li><li>复制：<kbd>Ctrl</kbd>+<kbd>C</kbd></li><li>粘贴：<kbd>Ctrl</kbd>+<kbd>V</kbd></li><li>复制为MarkDown：<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>C</kbd></li><li>粘贴为纯文本：<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>V</kbd></li><li>全选：<kbd>Ctrl</kbd>+<kbd>A</kbd></li><li>选中当前行/句：<kbd>Ctrl</kbd>+<kbd>L</kbd></li><li>选中当前格式文本：<kbd>Ctrl</kbd>+<kbd>E</kbd></li><li>选中当前词：<kbd>Ctrl</kbd>+<kbd>D</kbd></li><li>跳转到文首：<kbd>Ctrl</kbd>+<kbd>Home</kbd></li><li>跳转到所选内容：<kbd>Ctrl</kbd>+<kbd>J</kbd></li><li>跳转到文末：<kbd>Ctrl</kbd>+<kbd>End</kbd></li><li>查找：<kbd>Ctrl</kbd>+<kbd>F</kbd></li><li>查找下一个：<kbd>F3</kbd></li><li>查找上一个：<kbd>Shift</kbd>+<kbd>F3</kbd></li><li>替换：<kbd>Ctrl</kbd>+<kbd>H</kbd></li></ul><h2 id="四、段落"><a class="header-anchor" href="#四、段落"></a>四、段落</h2><ul><li>标题：<kbd>Ctrl</kbd>+<kbd>1</kbd>/<kbd>2</kbd>/<kbd>3</kbd>/<kbd>4</kbd>/<kbd>5</kbd></li><li>段落：<kbd>Ctrl</kbd>+<kbd>0</kbd></li><li>增大标题级别：<kbd>Ctrl</kbd>+<kbd>=</kbd></li><li>减少标题级别：<kbd>Ctrl</kbd>+<kbd>-</kbd></li><li>表格：<kbd>Ctrl</kbd>+<kbd>T</kbd></li><li>代码块：<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>K</kbd></li><li>公式块：<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>M</kbd></li><li>引用：<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>Q</kbd></li><li>有序列表：<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>[</kbd></li><li>无序列表：<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>]</kbd></li><li>增加缩进：<kbd>Ctrl</kbd>+<kbd>]</kbd></li><li>减少缩进：<kbd>Ctrl</kbd>+<kbd>[</kbd></li></ul><h2 id="五、格式"><a class="header-anchor" href="#五、格式"></a>五、格式</h2><ul><li>加粗：<kbd>Ctrl</kbd>+<kbd>B</kbd></li><li>斜体：<kbd>Ctrl</kbd>+<kbd>I</kbd></li><li>下划线：<kbd>Ctrl</kbd>+<kbd>U</kbd></li><li>代码：<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>`</kbd></li><li>删除线：<kbd>Alt</kbd>+<kbd>Shift</kbd>+<kbd>5</kbd></li><li>超链接：<kbd>Ctrl</kbd>+<kbd>K</kbd></li><li>图像：<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>I</kbd></li><li>清除样式：重复格式快捷键</li></ul><h2 id="六、视图"><a class="header-anchor" href="#六、视图"></a>六、视图</h2><ul><li>显示隐藏侧边栏：<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>L</kbd></li><li>大纲视图：<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>1</kbd></li><li>文档列表视图：<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>2</kbd></li><li>文件树视图：<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>3</kbd></li><li>源代码模式：<kbd>Ctrl</kbd>+<kbd>/</kbd></li><li>专注模式：<kbd>F8</kbd></li><li>打字机模式：<kbd>F9</kbd></li><li>切换全屏：<kbd>F11</kbd></li><li>实际大小：<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>0</kbd></li><li>放大：<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>=</kbd></li><li>缩小：<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>-</kbd></li><li>应用内窗口切换：<kbd>Ctrl</kbd>+<kbd>Tab</kbd></li><li>打开DevTools：<kbd>Shift</kbd>+<kbd>F12</kbd></li></ul>]]></content>
      
      
      <categories>
          
          <category> 快捷键 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快捷键 </tag>
            
            <tag> Markdown </tag>
            
            <tag> Typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA快捷键</title>
      <link href="2020/03/21/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>2020/03/21/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<p>IDEA快捷键</p><hr><h2 id="Ctrl"><a class="header-anchor" href="#Ctrl"></a>Ctrl</h2><table><thead><tr><th style="text-align:left">Win 快捷键</th><th style="text-align:left">Mac 快捷键</th><th style="text-align:left">介绍</th></tr></thead><tbody><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>F</kbd></td><td style="text-align:left"><kbd>Command</kbd> + <kbd>F</kbd></td><td style="text-align:left">在当前文件进行文本查找</td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>R</kbd></td><td style="text-align:left"><kbd>Command</kbd> + <kbd>R</kbd></td><td style="text-align:left">在当前文件进行文本替换</td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>Z</kbd></td><td style="text-align:left"><kbd>Command</kbd> + <kbd>Z</kbd></td><td style="text-align:left">撤销</td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>Y</kbd></td><td style="text-align:left"><kbd>Command</kbd> + <kbd>Delete</kbd></td><td style="text-align:left">删除光标所在行 或 删除选中的行</td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>D</kbd></td><td style="text-align:left"><kbd>Command</kbd> + <kbd>D</kbd></td><td style="text-align:left">复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面</td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>W</kbd></td><td style="text-align:left"><kbd>Option</kbd> + <kbd>方向键上</kbd></td><td style="text-align:left">递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围</td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>E</kbd></td><td style="text-align:left"><kbd>Command</kbd> + <kbd>E</kbd></td><td style="text-align:left">显示最近打开的文件记录列表</td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>N</kbd></td><td style="text-align:left"><kbd>Command</kbd> + <kbd>O</kbd></td><td style="text-align:left">根据输入的 <strong>类名</strong> 查找类文件</td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>J</kbd></td><td style="text-align:left"><kbd>Command</kbd> + <kbd>J</kbd></td><td style="text-align:left">插入自定义动态代码模板</td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>P</kbd></td><td style="text-align:left"><kbd>Command</kbd> + <kbd>P</kbd></td><td style="text-align:left">方法参数提示显示</td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>U</kbd></td><td style="text-align:left"><kbd>Command</kbd> + <kbd>U</kbd></td><td style="text-align:left">前往当前光标所在的方法的父类的方法 / 接口定义</td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>B</kbd></td><td style="text-align:left"><kbd>Command</kbd> + <kbd>B</kbd></td><td style="text-align:left">进入光标所在的方法/变量的接口或是定义处，等效于 <code>Ctrl + 左键单击</code></td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>/</kbd></td><td style="text-align:left"><kbd>Command</kbd> + <kbd>/</kbd></td><td style="text-align:left">注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号</td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>F1</kbd></td><td style="text-align:left"><kbd>Command</kbd> + <kbd>F1</kbd></td><td style="text-align:left">在光标所在的错误代码处显示错误信息</td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>F11</kbd></td><td style="text-align:left"><kbd>Option</kbd> + <kbd>F3</kbd></td><td style="text-align:left">选中文件 / 文件夹，使用助记符设定 / 取消书签</td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>F12</kbd></td><td style="text-align:left"><kbd>Command</kbd> + <kbd>F12</kbd></td><td style="text-align:left">弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选</td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>Space</kbd></td><td style="text-align:left"><kbd>Control</kbd> + <kbd>Space</kbd></td><td style="text-align:left">基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 <code>Alt + \</code></td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>Delete</kbd></td><td style="text-align:left"><kbd>Option</kbd> + <kbd>Fn</kbd>+ Delete</td><td style="text-align:left">删除光标后面的单词或是中文句</td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>BackSpace</kbd></td><td style="text-align:left"><kbd>Option</kbd> + <kbd>Delete</kbd></td><td style="text-align:left">删除光标前面的单词或是中文句</td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>1,2,3…9</kbd></td><td style="text-align:left"><kbd>Control</kbd> + <kbd>1,2,3…9</kbd></td><td style="text-align:left">定位到对应数值的书签位置</td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>加号</kbd></td><td style="text-align:left"><kbd>Command</kbd> + <kbd>加号</kbd></td><td style="text-align:left">展开代码</td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>减号</kbd></td><td style="text-align:left"><kbd>Command</kbd> + <kbd>减号</kbd></td><td style="text-align:left">折叠代码</td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>左键单击</kbd></td><td style="text-align:left"><kbd>Control</kbd> + <kbd>左键单击</kbd></td><td style="text-align:left">在打开的文件标题上，弹出该文件路径</td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>左方向键</kbd></td><td style="text-align:left"><kbd>Option</kbd> + <kbd>左方向键</kbd></td><td style="text-align:left">光标跳转到当前单词 / 中文句的左侧开头位置</td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>右方向键</kbd></td><td style="text-align:left"><kbd>Option</kbd> + <kbd>右方向键</kbd></td><td style="text-align:left">光标跳转到当前单词 / 中文句的右侧开头位置</td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>前方向键</kbd></td><td style="text-align:left">预设中没有该快捷键</td><td style="text-align:left">等效于鼠标滚轮向前效果</td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>后方向键</kbd></td><td style="text-align:left">预设中没有该快捷键</td><td style="text-align:left">等效于鼠标滚轮向后效果</td></tr></tbody></table><h2 id="Alt"><a class="header-anchor" href="#Alt"></a>Alt</h2><table><thead><tr><th style="text-align:left">Win 快捷键</th><th style="text-align:left">Mac 快捷键</th><th style="text-align:left">介绍</th></tr></thead><tbody><tr><td style="text-align:left"><kbd>Alt</kbd> + <kbd>`</kbd></td><td style="text-align:left"><kbd>Control</kbd> + <kbd>V</kbd></td><td style="text-align:left">显示版本控制常用操作菜单弹出层</td></tr><tr><td style="text-align:left"><kbd>Alt</kbd> + <kbd>F1</kbd></td><td style="text-align:left"><kbd>Option</kbd> + <kbd>F1</kbd></td><td style="text-align:left">显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择</td></tr><tr><td style="text-align:left"><kbd>Alt</kbd> + <kbd>F7</kbd></td><td style="text-align:left"><kbd>Option</kbd> + <kbd>F7</kbd></td><td style="text-align:left">查询所选对象/变量被引用</td></tr><tr><td style="text-align:left"><kbd>Alt</kbd> + <kbd>Enter</kbd></td><td style="text-align:left"><kbd>Option</kbd> + <kbd>Enter</kbd></td><td style="text-align:left">IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同</td></tr><tr><td style="text-align:left"><kbd>Alt</kbd> + <kbd>Insert</kbd></td><td style="text-align:left"><kbd>Command</kbd> + <kbd>N</kbd></td><td style="text-align:left">代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等</td></tr><tr><td style="text-align:left"><kbd>Alt</kbd> + <kbd>左方向键</kbd></td><td style="text-align:left"><kbd>Control</kbd> + <kbd>左方向键</kbd></td><td style="text-align:left">切换当前已打开的窗口中的子视图，比如Debug窗口中有Output、Debugger等子视图，用此快捷键就可以在子视图中切换</td></tr><tr><td style="text-align:left"><kbd>Alt</kbd> + <kbd>右方向键</kbd></td><td style="text-align:left"><kbd>Control</kbd> + <kbd>右方向键</kbd></td><td style="text-align:left">切换当前已打开的窗口中的子视图，比如Debug窗口中有Output、Debugger等子视图，用此快捷键就可以在子视图中切换</td></tr><tr><td style="text-align:left"><kbd>Alt</kbd> + <kbd>前方向键</kbd></td><td style="text-align:left"><kbd>Control</kbd> + <kbd>前方向键</kbd></td><td style="text-align:left">当前光标跳转到当前文件的前一个方法名位置</td></tr><tr><td style="text-align:left"><kbd>Alt</kbd> + <kbd>后方向键</kbd></td><td style="text-align:left"><kbd>Control</kbd> + <kbd>后方向键</kbd></td><td style="text-align:left">当前光标跳转到当前文件的后一个方法名位置</td></tr><tr><td style="text-align:left"><kbd>Alt</kbd> + <kbd>1,2,3…9</kbd></td><td style="text-align:left"><kbd>Command</kbd> + <kbd>1,2,3…9</kbd></td><td style="text-align:left">显示对应数值的选项卡，其中 1 是 Project 用得最多</td></tr></tbody></table><h2 id="Shift"><a class="header-anchor" href="#Shift"></a>Shift</h2><table><thead><tr><th style="text-align:left">Win 快捷键</th><th style="text-align:left">Mac 快捷键</th><th style="text-align:left">介绍</th></tr></thead><tbody><tr><td style="text-align:left"><kbd>Shift</kbd> + <kbd>F11</kbd></td><td style="text-align:left"><kbd>Command + F3</kbd></td><td style="text-align:left">弹出书签显示层</td></tr><tr><td style="text-align:left"><kbd>Shift</kbd> + <kbd>Tab</kbd></td><td style="text-align:left"><kbd>Shift + Tab</kbd></td><td style="text-align:left">取消缩进</td></tr><tr><td style="text-align:left"><kbd>Shift</kbd> + <kbd>Enter</kbd></td><td style="text-align:left"><kbd>Shift + Enter</kbd></td><td style="text-align:left">开始新一行。光标所在行下空出一行，光标定位到新行位置</td></tr><tr><td style="text-align:left"><kbd>Shift</kbd> + <kbd>左键单击</kbd></td><td style="text-align:left"><kbd>Shift + 左键单击</kbd></td><td style="text-align:left">在打开的文件名上按此快捷键，可以关闭当前打开文件</td></tr></tbody></table><h2 id="Ctrl-Alt"><a class="header-anchor" href="#Ctrl-Alt"></a>Ctrl + Alt</h2><table><thead><tr><th style="text-align:left">Win 快捷键</th><th style="text-align:left">Mac 快捷键</th><th style="text-align:left">介绍</th></tr></thead><tbody><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>L</kbd></td><td style="text-align:left"><kbd>Command</kbd> + <kbd>Option</kbd> + <kbd>L</kbd></td><td style="text-align:left">格式化代码，可以对当前文件和整个包目录使用</td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>O</kbd></td><td style="text-align:left"><kbd>Control</kbd> + <kbd>Option</kbd> + <kbd>O</kbd></td><td style="text-align:left">优化导入的类，可以对当前文件和整个包目录使用</td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>T</kbd></td><td style="text-align:left"><kbd>Command</kbd> + <kbd>Option</kbd> + <kbd>T</kbd></td><td style="text-align:left">对选中的代码弹出环绕选项弹出层</td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>S</kbd></td><td style="text-align:left"><kbd>Command</kbd> + <kbd>逗号</kbd></td><td style="text-align:left">打开 IntelliJ IDEA 系统设置</td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>Enter</kbd></td><td style="text-align:left"><kbd>Command</kbd> + <kbd>Option</kbd> + <kbd>Enter</kbd></td><td style="text-align:left">光标所在行上空出一行，光标定位到新行</td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>左方向键</kbd></td><td style="text-align:left"><kbd>Command</kbd> + <kbd>Option</kbd> + <kbd>左方向键</kbd></td><td style="text-align:left">退回到上一个操作的地方</td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>右方向键</kbd></td><td style="text-align:left"><kbd>Command</kbd> + <kbd>Option</kbd> + <kbd>右方向键</kbd></td><td style="text-align:left">前进到上一个操作的地方</td></tr></tbody></table><h2 id="Ctrl-Shift"><a class="header-anchor" href="#Ctrl-Shift"></a>Ctrl + Shift</h2><table><thead><tr><th style="text-align:left">Win 快捷键</th><th style="text-align:left">Mac 快捷键</th><th style="text-align:left">介绍</th></tr></thead><tbody><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>F</kbd></td><td style="text-align:left"><kbd>Command</kbd> + <kbd>Shift</kbd> + <kbd>F</kbd></td><td style="text-align:left">根据输入内容查找整个项目 或 指定目录内文件</td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>R</kbd></td><td style="text-align:left"><kbd>Command</kbd> + <kbd>Shift</kbd> + <kbd>R</kbd></td><td style="text-align:left">根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件</td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>J</kbd></td><td style="text-align:left"><kbd>Control</kbd> + <kbd>Shift</kbd> + <kbd>J</kbd></td><td style="text-align:left">自动将下一行合并到当前行末尾</td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>Z</kbd></td><td style="text-align:left"><kbd>Command</kbd> + <kbd>Shift</kbd> + <kbd>Z</kbd></td><td style="text-align:left">取消撤销</td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>W</kbd></td><td style="text-align:left"><kbd>Option</kbd> + <kbd>方向键下</kbd></td><td style="text-align:left">递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围</td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>N</kbd></td><td style="text-align:left"><kbd>Command</kbd> + <kbd>Shift</kbd> + <kbd>O</kbd></td><td style="text-align:left">通过文件名定位 / 打开文件 / 目录，打开目录需要在输入的内容后面多加一个正斜杠</td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>U</kbd></td><td style="text-align:left"><kbd>Command</kbd> + <kbd>Shift</kbd> + <kbd>U</kbd></td><td style="text-align:left">对选中的代码进行大 / 小写轮流转换</td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>T</kbd></td><td style="text-align:left"><kbd>Command</kbd> + <kbd>Shift</kbd> + <kbd>T</kbd></td><td style="text-align:left">对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择</td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>C</kbd></td><td style="text-align:left"><kbd>Command</kbd> + <kbd>Shift</kbd> + <kbd>C</kbd></td><td style="text-align:left">复制当前文件磁盘路径到剪贴板</td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>B</kbd></td><td style="text-align:left"><kbd>Control</kbd> + <kbd>Shift</kbd> + <kbd>B</kbd></td><td style="text-align:left">跳转到类型声明处</td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>/</kbd></td><td style="text-align:left"><kbd>Command</kbd> + <kbd>Option</kbd> + <kbd>/</kbd></td><td style="text-align:left">代码块注释</td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>[</kbd></td><td style="text-align:left"><kbd>Command</kbd> + <kbd>Shift</kbd> + <kbd>[</kbd></td><td style="text-align:left">选中从光标所在位置到它的顶部中括号位置</td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>]</kbd></td><td style="text-align:left"><kbd>Command</kbd> + <kbd>Shift</kbd> + <kbd>]</kbd></td><td style="text-align:left">选中从光标所在位置到它的底部中括号位置</td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>加号</kbd></td><td style="text-align:left"><kbd>Command</kbd> + <kbd>Shift</kbd> + <kbd>加号</kbd></td><td style="text-align:left">展开所有代码</td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>减号</kbd></td><td style="text-align:left"><kbd>Command</kbd> + <kbd>Shift</kbd> + <kbd>减号</kbd></td><td style="text-align:left">折叠所有代码</td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>F7</kbd></td><td style="text-align:left"><kbd>Command</kbd> + <kbd>Shift</kbd> + <kbd>F7</kbd></td><td style="text-align:left">高亮显示所有该选中文本，按Esc高亮消失</td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>F12</kbd></td><td style="text-align:left"><kbd>Command</kbd> + <kbd>Shift</kbd> + <kbd>F12</kbd></td><td style="text-align:left">编辑器最大化</td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>Enter</kbd></td><td style="text-align:left"><kbd>Command</kbd> + <kbd>Shift</kbd> + <kbd>Enter</kbd></td><td style="text-align:left">自动结束代码，行末自动添加分号</td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>Backspace</kbd></td><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>Backspace</kbd></td><td style="text-align:left">退回到上次修改的地方</td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>1,2,3…9</kbd></td><td style="text-align:left"><kbd>Control</kbd> + <kbd>Shift</kbd> + <kbd>1,2,3…9</kbd></td><td style="text-align:left">快速添加指定数值的书签</td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>左键单击</kbd></td><td style="text-align:left"><kbd>Command</kbd> + <kbd>Shift</kbd> + <kbd>左键单击</kbd></td><td style="text-align:left">把光标放在某个类变量上，按此快捷键可以直接定位到该类中</td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>左方向键</kbd></td><td style="text-align:left"><kbd>Option</kbd> + <kbd>Shift</kbd> + <kbd>左方向键</kbd></td><td style="text-align:left">在代码文件上，光标跳转到当前单词 / 中文句的左侧开头位置，同时选中该单词 / 中文句</td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>右方向键</kbd></td><td style="text-align:left"><kbd>Option</kbd> + <kbd>Shift</kbd> + <kbd>右方向键</kbd></td><td style="text-align:left">在代码文件上，光标跳转到当前单词 / 中文句的右侧开头位置，同时选中该单词 / 中文句</td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>前方向键</kbd></td><td style="text-align:left"><kbd>Command</kbd> + <kbd>Shift</kbd> + <kbd>前方向键</kbd></td><td style="text-align:left">光标放在方法名上，将方法移动到上一个方法前面，调整方法排序</td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>后方向键</kbd></td><td style="text-align:left"><kbd>Command</kbd> + <kbd>Shift</kbd> + <kbd>后方向键</kbd></td><td style="text-align:left">光标放在方法名上，将方法移动到下一个方法前面，调整方法排序</td></tr></tbody></table><h2 id="Alt-Shift"><a class="header-anchor" href="#Alt-Shift"></a>Alt + Shift</h2><table><thead><tr><th style="text-align:left">Win 快捷键</th><th style="text-align:left">Mac 快捷键</th><th style="text-align:left">介绍</th></tr></thead><tbody><tr><td style="text-align:left"><kbd>Alt</kbd> + <kbd>Shift</kbd> + <kbd>N</kbd></td><td style="text-align:left"><kbd>Option</kbd> + <kbd>Shift</kbd> + <kbd>B</kbd></td><td style="text-align:left">选择 / 添加 task</td></tr><tr><td style="text-align:left"><kbd>Alt</kbd> + <kbd>Shift</kbd> + <kbd>左键双击</kbd></td><td style="text-align:left"><kbd>Option</kbd> + <kbd>Shift</kbd> + <kbd>左键双击</kbd></td><td style="text-align:left">选择被双击的单词 / 中文句，按住不放，可以同时选择其他单词 / 中文句</td></tr><tr><td style="text-align:left"><kbd>Alt</kbd> + <kbd>Shift</kbd> + <kbd>前方向键</kbd></td><td style="text-align:left"><kbd>Option</kbd> + <kbd>Shift</kbd> + <kbd>前方向键</kbd></td><td style="text-align:left">移动光标所在行向上移动</td></tr><tr><td style="text-align:left"><kbd>Alt</kbd> + <kbd>Shift</kbd> + <kbd>后方向键</kbd></td><td style="text-align:left"><kbd>Option</kbd> + <kbd>Shift</kbd> + <kbd>后方向键</kbd></td><td style="text-align:left">移动光标所在行向下移动</td></tr></tbody></table><h2 id="Ctrl-Shift-Alt"><a class="header-anchor" href="#Ctrl-Shift-Alt"></a>Ctrl + Shift + Alt</h2><table><thead><tr><th style="text-align:left">Win 快捷键</th><th style="text-align:left">Mac 快捷键</th><th style="text-align:left">介绍</th></tr></thead><tbody><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>Alt</kbd> + <kbd>V</kbd></td><td style="text-align:left"><kbd>Command</kbd> + <kbd>Shift</kbd> + <kbd>Option</kbd> + <kbd>V</kbd></td><td style="text-align:left">无格式黏贴</td></tr><tr><td style="text-align:left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>Alt</kbd> + <kbd>S</kbd></td><td style="text-align:left"><kbd>Command</kbd> + <kbd>;</kbd></td><td style="text-align:left">打开当前项目设置</td></tr></tbody></table><h2 id="其他"><a class="header-anchor" href="#其他"></a>其他</h2><table><thead><tr><th style="text-align:left">Win 快捷键</th><th style="text-align:left">Mac 快捷键</th><th style="text-align:left">介绍</th></tr></thead><tbody><tr><td style="text-align:left"><kbd>F2</kbd></td><td style="text-align:left"><kbd>F2</kbd></td><td style="text-align:left">跳转到下一个高亮错误 或 警告位置</td></tr><tr><td style="text-align:left"><kbd>F4</kbd></td><td style="text-align:left"><kbd>F4</kbd></td><td style="text-align:left">编辑源</td></tr><tr><td style="text-align:left"><kbd>F11</kbd></td><td style="text-align:left"><kbd>F3</kbd></td><td style="text-align:left">添加书签</td></tr><tr><td style="text-align:left"><kbd>F12</kbd></td><td style="text-align:left"><kbd>F12</kbd></td><td style="text-align:left">回到前一个工具窗口</td></tr><tr><td style="text-align:left"><kbd>Tab</kbd></td><td style="text-align:left"><kbd>Tab</kbd></td><td style="text-align:left">缩进</td></tr><tr><td style="text-align:left"><kbd>ESC</kbd></td><td style="text-align:left"><kbd>ESC</kbd></td><td style="text-align:left">从工具窗口进入代码文件窗口</td></tr></tbody></table><h2 id="中文字体异常设置"><a class="header-anchor" href="#中文字体异常设置"></a>中文字体异常设置</h2><p><img src="http://img.whl123456.top/image/%E4%B8%AD%E6%96%87%E5%AD%97%E4%BD%93%E5%BC%82%E5%B8%B8%E8%AE%BE%E7%BD%AE.png" alt="中文字体异常设置"></p>]]></content>
      
      
      <categories>
          
          <category> 快捷键 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快捷键 </tag>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java常用类</title>
      <link href="2020/03/21/Java%E5%A4%84%E7%90%86%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F/"/>
      <url>2020/03/21/Java%E5%A4%84%E7%90%86%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>Java常用类</p><hr><h2 id="文本"><a class="header-anchor" href="#文本"></a>文本</h2><h3 id="String，StringBuffer和StringBuild"><a class="header-anchor" href="#String，StringBuffer和StringBuild"></a>String，StringBuffer和StringBuild</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">// StringBuffer和StringBuilder的使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBufferBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    String、StringBuffer、StringBuilder三者的异同？</span></span><br><span class="line"><span class="comment">    String:不可变的字符序列；底层使用char[]存储</span></span><br><span class="line"><span class="comment">    StringBuffer:可变的字符序列；线程安全的，效率低；底层使用char[]存储</span></span><br><span class="line"><span class="comment">    StringBuilder:可变的字符序列；jdk5.0新增的，线程不安全的，效率高；底层使用char[]存储</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    源码分析：</span></span><br><span class="line"><span class="comment">    String str = new String();//char[] value = new char[0];</span></span><br><span class="line"><span class="comment">    String str1 = new String(&quot;abc&quot;);//char[] value = new char[]&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    StringBuffer sb1 = new StringBuffer();//char[] value = new char[16];底层创建了一个长度是16的数组。</span></span><br><span class="line"><span class="comment">    System.out.println(sb1.length());//0</span></span><br><span class="line"><span class="comment">    sb1.append(&#x27;a&#x27;);//value[0] = &#x27;a&#x27;;</span></span><br><span class="line"><span class="comment">    sb1.append(&#x27;b&#x27;);//value[1] = &#x27;b&#x27;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    StringBuffer sb2 = new StringBuffer(&quot;abc&quot;);//char[] value = new char[&quot;abc&quot;.length() + 16];</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    //问题1. System.out.println(sb2.length());//3</span></span><br><span class="line"><span class="comment">    //问题2. 扩容问题:如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。</span></span><br><span class="line"><span class="comment">             默认情况下，扩容为原来容量的2倍 + 2，同时将原有数组中的元素复制到新的数组中。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            指导意义：开发中建议大家使用：StringBuffer(int capacity) 或 StringBuilder(int capacity)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StringBuffer sb1 = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        sb1.setCharAt(<span class="number">0</span>,<span class="string">&#x27;m&#x27;</span>);</span><br><span class="line">        System.out.println(sb1);</span><br><span class="line"></span><br><span class="line">        StringBuffer sb2 = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        System.out.println(sb2.length());<span class="comment">//0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    StringBuffer的常用方法：</span></span><br><span class="line"><span class="comment">    StringBuffer append(xxx)：提供了很多的append()方法，用于进行字符串拼接</span></span><br><span class="line"><span class="comment">    StringBuffer delete(int start,int end)：删除指定位置的内容</span></span><br><span class="line"><span class="comment">    StringBuffer replace(int start, int end, String str)：把[start,end)位置替换为str</span></span><br><span class="line"><span class="comment">    StringBuffer insert(int offset, xxx)：在指定位置插入xxx</span></span><br><span class="line"><span class="comment">    StringBuffer reverse() ：把当前字符序列逆转</span></span><br><span class="line"><span class="comment">    public int indexOf(String str)</span></span><br><span class="line"><span class="comment">    public String substring(int start,int end):返回一个从start开始到end索引结束的左闭右开区间的子字符串</span></span><br><span class="line"><span class="comment">    public int length()</span></span><br><span class="line"><span class="comment">    public char charAt(int n )</span></span><br><span class="line"><span class="comment">    public void setCharAt(int n ,char ch)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        总结：</span></span><br><span class="line"><span class="comment">        增：append(xxx)</span></span><br><span class="line"><span class="comment">        删：delete(int start,int end)</span></span><br><span class="line"><span class="comment">        改：setCharAt(int n ,char ch) / replace(int start, int end, String str)</span></span><br><span class="line"><span class="comment">        查：charAt(int n )</span></span><br><span class="line"><span class="comment">        插：insert(int offset, xxx)</span></span><br><span class="line"><span class="comment">        长度：length();</span></span><br><span class="line"><span class="comment">        *遍历：for() + charAt() / toString()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StringBuffer s1 = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        s1.append(<span class="number">1</span>);</span><br><span class="line">        s1.append(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        System.out.println(s1);</span><br><span class="line"><span class="comment">//        s1.delete(2,4);</span></span><br><span class="line"><span class="comment">//        s1.replace(2,4,&quot;hello&quot;);</span></span><br><span class="line"><span class="comment">//        s1.insert(2,false);</span></span><br><span class="line"><span class="comment">//        s1.reverse();</span></span><br><span class="line">        String s2 = s1.substring(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s1.length());</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    对比String、StringBuffer、StringBuilder三者的效率：</span></span><br><span class="line"><span class="comment">    从高到低排列：StringBuilder &gt; StringBuffer &gt; String</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//初始设置</span></span><br><span class="line">        <span class="keyword">long</span> startTime = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">long</span> endTime = <span class="number">0L</span>;</span><br><span class="line">        String text = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        StringBuffer buffer = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">//开始对比</span></span><br><span class="line">        startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">            buffer.append(String.valueOf(i));</span><br><span class="line">        &#125;</span><br><span class="line">        endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;StringBuffer的执行时间：&quot;</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">        startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">            builder.append(String.valueOf(i));</span><br><span class="line">        &#125;</span><br><span class="line">        endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;StringBuilder的执行时间：&quot;</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">        startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">            text = text + i;</span><br><span class="line">        &#125;</span><br><span class="line">        endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;String的执行时间：&quot;</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数字和数学运算"><a class="header-anchor" href="#数字和数学运算"></a>数字和数学运算</h2><h2 id="在-Java-8-中处理日期和时间"><a class="header-anchor" href="#在-Java-8-中处理日期和时间"></a>在 Java 8 中处理日期和时间</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JDK8之前的日期时间相关类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * jdk 8之前的日期时间的API测试</span></span><br><span class="line"><span class="comment"> * 1. System类中currentTimeMillis();</span></span><br><span class="line"><span class="comment"> * 2. java.util.Date和子类java.sql.Date</span></span><br><span class="line"><span class="comment"> * 3. SimpleDateFormat</span></span><br><span class="line"><span class="comment"> * 4. Calendar</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateTime</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.System类中的currentTimeMillis()</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。</span></span><br><span class="line">        <span class="comment">//称为时间戳</span></span><br><span class="line">        System.out.println(time);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">java.util.Date类</span></span><br><span class="line"><span class="comment">       |---java.sql.Date类</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1.两个构造器的使用</span></span><br><span class="line"><span class="comment">    &gt;构造器一：Date()：创建一个对应当前时间的Date对象</span></span><br><span class="line"><span class="comment">    &gt;构造器二：创建指定毫秒数的Date对象</span></span><br><span class="line"><span class="comment">2.两个方法的使用</span></span><br><span class="line"><span class="comment">    &gt;toString():显示当前的年、月、日、时、分、秒</span></span><br><span class="line"><span class="comment">    &gt;getTime():获取当前Date对象对应的毫秒数。（时间戳）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3. java.sql.Date对应着数据库中的日期类型的变量</span></span><br><span class="line"><span class="comment">    &gt;如何实例化</span></span><br><span class="line"><span class="comment">    &gt;如何将java.util.Date对象转换为java.sql.Date对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构造器一：Date()：创建一个对应当前时间的Date对象</span></span><br><span class="line">        Date date1 = <span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(date1.toString());<span class="comment">//Wed Feb 19 20:36:24 CST 2020</span></span><br><span class="line"></span><br><span class="line">        System.out.println(date1.getTime());<span class="comment">//1582115784712</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造器二：创建指定毫秒数的Date对象</span></span><br><span class="line">        Date date2 = <span class="keyword">new</span> Date(<span class="number">1582115784712L</span>);</span><br><span class="line">        System.out.println(date2.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建java.sql.Date对象</span></span><br><span class="line">        java.sql.Date date3 = <span class="keyword">new</span> java.sql.Date(<span class="number">1582115784712L</span>);</span><br><span class="line">        System.out.println(date3);<span class="comment">//2020-02-19</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如何将java.util.Date对象转换为java.sql.Date对象</span></span><br><span class="line">        <span class="comment">//情况一：</span></span><br><span class="line"><span class="comment">//        Date date4 = new java.sql.Date(1582115784712L);</span></span><br><span class="line"><span class="comment">//        java.sql.Date date5 = (java.sql.Date) date4;</span></span><br><span class="line">        <span class="comment">//情况二：</span></span><br><span class="line">        Date date6 = <span class="keyword">new</span> Date();</span><br><span class="line">        java.sql.Date date7 = <span class="keyword">new</span> java.sql.Date(date6.getTime());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    SimpleDateFormat的使用：SimpleDateFormat对日期Date类的格式化和解析</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    1.两个操作：</span></span><br><span class="line"><span class="comment">    1.1 格式化：日期 ---&gt;字符串</span></span><br><span class="line"><span class="comment">    1.2 解析：格式化的逆过程，字符串 ---&gt; 日期</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    2.SimpleDateFormat的实例化</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSimpleDateFormat</span><span class="params">()</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        <span class="comment">//实例化SimpleDateFormat:使用默认的构造器</span></span><br><span class="line">        SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//格式化：日期 ---&gt;字符串</span></span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(date);<span class="comment">//Wed Feb 19 20:53:45 CST 2020</span></span><br><span class="line"></span><br><span class="line">        String format = sdf.format(date);</span><br><span class="line">        System.out.println(format);<span class="comment">//20-2-19 下午8:53</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//解析：格式化的逆过程，字符串 ---&gt; 日期</span></span><br><span class="line">        String str = <span class="string">&quot;20-2-19 下午8:53&quot;</span>;</span><br><span class="line">        Date date1 = sdf.parse(str);</span><br><span class="line">        System.out.println(date1);<span class="comment">//Wed Dec 18 11:43:00 CST 2019</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//*************按照指定的方式格式化和解析：调用带参的构造器*****************</span></span><br><span class="line">        SimpleDateFormat sdf1 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line">        <span class="comment">//格式化</span></span><br><span class="line">        String format1 = sdf1.format(date);</span><br><span class="line">        System.out.println(format1);<span class="comment">//2020-02-19 08:53:45</span></span><br><span class="line">        <span class="comment">//解析:要求字符串必须是符合SimpleDateFormat识别的格式(通过构造器参数体现),否则，抛异常</span></span><br><span class="line">        Date date2 = sdf1.parse(<span class="string">&quot;2020-02-19 08:53:45&quot;</span>);</span><br><span class="line">        System.out.println(date2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    练习一：字符串&quot;2020-09-08&quot;转换为java.sql.Date</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testExer</span><span class="params">()</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        String birth = <span class="string">&quot;2020-09-08&quot;</span>;</span><br><span class="line"></span><br><span class="line">        SimpleDateFormat sdf1 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        Date date = sdf1.parse(birth);</span><br><span class="line"><span class="comment">//        System.out.println(date);</span></span><br><span class="line"></span><br><span class="line">        java.sql.Date birthDate = <span class="keyword">new</span> java.sql.Date(date.getTime());</span><br><span class="line">        System.out.println(birthDate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    练习二：&quot;三天打渔两天晒网&quot;   1990-01-01  xxxx-xx-xx 打渔？晒网？</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    举例：2020-09-08 ？ 总天数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    总天数 % 5 == 1,2,3 : 打渔</span></span><br><span class="line"><span class="comment">    总天数 % 5 == 4,0 : 晒网</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    总天数的计算？</span></span><br><span class="line"><span class="comment">    方式一：( date2.getTime() - date1.getTime()) / (1000 * 60 * 60 * 24) + 1</span></span><br><span class="line"><span class="comment">    方式二：1990-01-01  --&gt; 2019-12-31  +  2020-01-01 --&gt;2020-09-08*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Calendar日历类(抽象类）的使用</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCalendar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.实例化</span></span><br><span class="line">        <span class="comment">//方式一：创建其子类（GregorianCalendar）的对象</span></span><br><span class="line">        <span class="comment">//方式二：调用其静态方法getInstance()</span></span><br><span class="line">        Calendar calendar = Calendar.getInstance();</span><br><span class="line"><span class="comment">//        System.out.println(calendar.getClass());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.常用方法</span></span><br><span class="line">        <span class="comment">//get()</span></span><br><span class="line">        <span class="keyword">int</span> days = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        System.out.println(days);</span><br><span class="line">        System.out.println(calendar.get(Calendar.DAY_OF_YEAR));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//set()</span></span><br><span class="line">        <span class="comment">//calendar可变性</span></span><br><span class="line">        calendar.set(Calendar.DAY_OF_MONTH, <span class="number">22</span>);</span><br><span class="line">        days = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        System.out.println(days);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//add()</span></span><br><span class="line">        calendar.add(Calendar.DAY_OF_MONTH, -<span class="number">3</span>);</span><br><span class="line">        days = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        System.out.println(days);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//getTime():日历类---&gt; Date</span></span><br><span class="line">        Date date = calendar.getTime();</span><br><span class="line">        System.out.println(date);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//setTime():Date ---&gt; 日历类</span></span><br><span class="line">        Date date1 = <span class="keyword">new</span> Date();</span><br><span class="line">        calendar.setTime(date1);</span><br><span class="line">        days = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        System.out.println(days);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"><span class="keyword">import</span> java.time.format.FormatStyle;</span><br><span class="line"><span class="keyword">import</span> java.time.temporal.TemporalAccessor;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JDK8之后的time包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewDateTime</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//偏移量</span></span><br><span class="line">        Date date1 = <span class="keyword">new</span> Date(<span class="number">2020</span> - <span class="number">1900</span>,<span class="number">9</span> - <span class="number">1</span>,<span class="number">8</span>);</span><br><span class="line">        System.out.println(date1);<span class="comment">//Tue Sep 08 00:00:00 GMT+08:00 2020</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    LocalDate、LocalTime、LocalDateTime 的使用</span></span><br><span class="line"><span class="comment">    说明：</span></span><br><span class="line"><span class="comment">        1.LocalDateTime相较于LocalDate、LocalTime，使用频率要高</span></span><br><span class="line"><span class="comment">        2.类似于Calendar</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//now():获取当前的日期、时间、日期+时间</span></span><br><span class="line">        LocalDate localDate = LocalDate.now();</span><br><span class="line">        LocalTime localTime = LocalTime.now();</span><br><span class="line">        LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line"></span><br><span class="line">        System.out.println(localDate);</span><br><span class="line">        System.out.println(localTime);</span><br><span class="line">        System.out.println(localDateTime);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//of():设置指定的年、月、日、时、分、秒。没有偏移量</span></span><br><span class="line">        LocalDateTime localDateTime1 = LocalDateTime.of(<span class="number">2020</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">13</span>, <span class="number">23</span>, <span class="number">43</span>);</span><br><span class="line">        System.out.println(localDateTime1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//getXxx()：获取相关的属性</span></span><br><span class="line">        System.out.println(localDateTime.getDayOfMonth());</span><br><span class="line">        System.out.println(localDateTime.getDayOfWeek());</span><br><span class="line">        System.out.println(localDateTime.getMonth());</span><br><span class="line">        System.out.println(localDateTime.getMonthValue());</span><br><span class="line">        System.out.println(localDateTime.getMinute());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//体现不可变性</span></span><br><span class="line">        <span class="comment">//withXxx():设置相关的属性</span></span><br><span class="line">        LocalDate localDate1 = localDate.withDayOfMonth(<span class="number">22</span>);</span><br><span class="line">        System.out.println(localDate);</span><br><span class="line">        System.out.println(localDate1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        LocalDateTime localDateTime2 = localDateTime.withHour(<span class="number">4</span>);</span><br><span class="line">        System.out.println(localDateTime);</span><br><span class="line">        System.out.println(localDateTime2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不可变性</span></span><br><span class="line">        LocalDateTime localDateTime3 = localDateTime.plusMonths(<span class="number">3</span>);</span><br><span class="line">        System.out.println(localDateTime);</span><br><span class="line">        System.out.println(localDateTime3);</span><br><span class="line"></span><br><span class="line">        LocalDateTime localDateTime4 = localDateTime.minusDays(<span class="number">6</span>);</span><br><span class="line">        System.out.println(localDateTime);</span><br><span class="line">        System.out.println(localDateTime4);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Instant的使用</span></span><br><span class="line"><span class="comment">    类似于 java.util.Date类</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//now():获取本初子午线对应的标准时间</span></span><br><span class="line">        Instant instant = Instant.now();</span><br><span class="line">        System.out.println(instant);<span class="comment">//2019-02-18T07:29:41.719Z</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加时间的偏移量</span></span><br><span class="line">        OffsetDateTime offsetDateTime = instant.atOffset(ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line">        System.out.println(offsetDateTime);<span class="comment">//2019-02-18T15:32:50.611+08:00</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//toEpochMilli():获取自1970年1月1日0时0分0秒（UTC）开始的毫秒数  ---&gt; Date类的getTime()</span></span><br><span class="line">        <span class="keyword">long</span> milli = instant.toEpochMilli();</span><br><span class="line">        System.out.println(milli);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//ofEpochMilli():通过给定的毫秒数，获取Instant实例  --&gt;Date(long millis)</span></span><br><span class="line">        Instant instant1 = Instant.ofEpochMilli(<span class="number">1550475314878L</span>);</span><br><span class="line">        System.out.println(instant1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    DateTimeFormatter:格式化或解析日期、时间</span></span><br><span class="line"><span class="comment">    类似于SimpleDateFormat</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//        方式一：预定义的标准格式。如：ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIME</span></span><br><span class="line">        DateTimeFormatter formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME;</span><br><span class="line">        <span class="comment">//格式化:日期--&gt;字符串</span></span><br><span class="line">        LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">        String str1 = formatter.format(localDateTime);</span><br><span class="line">        System.out.println(localDateTime);</span><br><span class="line">        System.out.println(str1);<span class="comment">//2019-02-18T15:42:18.797</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//解析：字符串 --&gt;日期</span></span><br><span class="line">        TemporalAccessor parse = formatter.parse(<span class="string">&quot;2019-02-18T15:42:18.797&quot;</span>);</span><br><span class="line">        System.out.println(parse);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        方式二：</span></span><br><span class="line"><span class="comment">//        本地化相关的格式。如：ofLocalizedDateTime()</span></span><br><span class="line"><span class="comment">//        FormatStyle.LONG / FormatStyle.MEDIUM / FormatStyle.SHORT :适用于LocalDateTime</span></span><br><span class="line">        DateTimeFormatter formatter1 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.LONG);</span><br><span class="line">        <span class="comment">//格式化</span></span><br><span class="line">        String str2 = formatter1.format(localDateTime);</span><br><span class="line">        System.out.println(str2);<span class="comment">//2019年2月18日 下午03时47分16秒</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//      本地化相关的格式。如：ofLocalizedDate()</span></span><br><span class="line"><span class="comment">//      FormatStyle.FULL / FormatStyle.LONG / FormatStyle.MEDIUM / FormatStyle.SHORT : 适用于LocalDate</span></span><br><span class="line">        DateTimeFormatter formatter2 = DateTimeFormatter.ofLocalizedDate(FormatStyle.MEDIUM);</span><br><span class="line">        <span class="comment">//格式化</span></span><br><span class="line">        String str3 = formatter2.format(LocalDate.now());</span><br><span class="line">        System.out.println(str3);<span class="comment">//2019-2-18</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//       重点： 方式三：自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”)</span></span><br><span class="line">        DateTimeFormatter formatter3 = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line">        <span class="comment">//格式化</span></span><br><span class="line">        String str4 = formatter3.format(LocalDateTime.now());</span><br><span class="line">        System.out.println(str4);<span class="comment">//2019-02-18 03:52:09</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//解析</span></span><br><span class="line">        TemporalAccessor accessor = formatter3.parse(<span class="string">&quot;2019-02-18 03:52:09&quot;</span>);</span><br><span class="line">        System.out.println(accessor);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Math"><a class="header-anchor" href="#Math"></a>Math</h3><h2 id="异常处理"><a class="header-anchor" href="#异常处理"></a>异常处理</h2><h2 id="代码校验"><a class="header-anchor" href="#代码校验"></a>代码校验</h2><h2 id="Junit单元测试"><a class="header-anchor" href="#Junit单元测试"></a>Junit单元测试</h2><p>测试分类：</p><ol><li>黑盒测试：指定输入看输出</li><li>白盒测试：关注程序执行流程</li></ol><p>Junit属于白盒测试</p><ol><li><p>定义一个测试类(测试用例)</p><blockquote><p>测试类名：被测试的类名Test</p><p>包名：xxx.xxx.xx.test</p></blockquote></li><li><p>定义测试方法：可以独立运行</p><blockquote><p>方法名：test测试的方法名</p><p>返回值：void</p><p>参数列表：空参</p></blockquote></li><li><p>给方法加上<code>@Test</code>，导入Junit依赖环境</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAdd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 创建对象</span></span><br><span class="line">    Calculator calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line">    <span class="comment">//2. 调用方法</span></span><br><span class="line">    <span class="keyword">int</span> result = calculator.add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">//3.断言</span></span><br><span class="line">    Assert.assertEquals(<span class="number">3</span>,result);<span class="comment">//期望的结果,运算的结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Before</code></p><p>初始化方法：用于资源申请，所有测试方法在执行之前都会执行该方法</p><p><code>@After</code></p><p>释放资源方法：在所有测试方法执行完后，都会自动执行该方法</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象编程</title>
      <link href="2020/03/21/Java-02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
      <url>2020/03/21/Java-02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>所有 Java 程序都使用对象，对象的类型由类或接口定义。每个 Java 程序都定义成类，而复杂的程序会定义很多类和接口。</p><hr><h2 id="对象导论"><a class="header-anchor" href="#对象导论"></a>对象导论</h2><h3 id="抽象过程"><a class="header-anchor" href="#抽象过程"></a>抽象过程</h3><p>面向对象语言的五个基本特性，这些特性表现了一个纯粹的面向对象的程序设计方式：</p><ol><li>万物皆对象。将对象视为奇特的变量，它可以储存数据，除此之外，你还可以要求它在自身上执行操作。理论上讲，你可以抽取待求解决的任何概念化构件（狗、建筑物、服务等），将其表示为程序中的对象。</li><li>程序是对象的集合，它们通过发送消息来告知彼此要做的。要想请求一个对象，就必须对该对象发送一条消息。更具体地说，可以把消息想象为对某个特定对象的方法的调用请求。</li><li>每个对象都有自己的由其他对象所构成的储存。换句话说，可以通过创建包含现有对象的包的方式来创建新类型的对象。因此，可以在程序中构建复杂的体系，同时将其复杂性隐藏在对象的简单性背后。</li><li>每个对象都拥有其类型。按照通用的说法，“每个对象都是某个类（class）的一个实例（instance）”，这里“类”就是“类型”的同义词。每个类最重要的区别于其他类型的特征就是“可以发送什么样的消息给它”。</li><li>某一个特定类型的所有对象都可以接受同样的消息。可替代性是OOP中最强有力的概念之一</li></ol><p>对象具有状态、行为和标识。这意味着每一个对象都可以拥有内部类数据（它们给出了该对象的状态）和方法（它们产生行为），并且每一个对象都可以唯一地与其他对象区分开来，具体说来，就是每一个对象在内存中都有一个唯一的地址。</p><h2 id="面向对象程序设计概述"><a class="header-anchor" href="#面向对象程序设计概述"></a>面向对象程序设计概述</h2><p>面向对象程序设计（object-oriented programming，OOP）是当今主流的程序设计范型，它取代了20世纪70年代的“结构化”或过程式编程技术。由于Java是面向对象的所以你必须熟悉OOP才能够很好地使用Java。</p><p>面向对象的程序是由对象组成的，每个对象包含用户公开的特定功能部分和隐藏的实现部分。程序中很多兑现来自标准库，还有一些是自定义的。究竟是自己构造对象，还是从外界购买对象完全取决于对开发项目的预算和时间。但是，从根本上说，只有对象能够满足要求，就不必关心其功能到底是如何实现的。</p><p>传统的结构化程序设计通过设计一系列的过程（即算法）来求解问题。一旦确定了这些过程，就要开始考虑储存数据的适当方式。这就是Pascal语言的设计者Niklaus Wirth将其著作命名为《算法+数据结构=程序》的原因。需要注意的是，在Wirth的这个书名中，算法是第一位的，数据结构是第二位的，这就明确地表述了程序员的工作方式。首先要确定如何操作数据，然后再决定如何组织数据的结构，一边于操作数据。而OOP却调换了这个次序，将数据放在第一位，然后再考虑操作数据的算法。</p><p>对于一些规模较小的问题，将其分解为过程开发比较理想。面向对象更加适合解决规模较大的问题。</p><h3 id="类"><a class="header-anchor" href="#类"></a>类</h3><p>类（class）是构造对象的模板或蓝图。我们可以将类想象成制作小甜饼的模具，将对象想象为小甜饼。由类构造（construct）对象的过程称为创建类的实例（instance）</p><p>用Java编写的所有代码都位于某个类里面。标准Java库中提供了几千个类，可用于各种目的，如用户界面设计、日期、日历和网络编程。尽管如此，在Java中还是需要创建一些自己的类，以便描述你的应用程序所对应的问题领域中的对象。</p><p>封装（encapsulation，有时称为数据隐藏）是处理对象的一个重要概念。从形式上看，封装就是将数据和行为组合在一个包中，并对对象的使用者隐藏具体的实现方式。对象中的数据为实例字段（instance field），操作数据的过程称为方法（method）。作为一个类的实例，特定对象都有一组特定的实例字段值。这些值的集合就是这个对象的当前状态（state）。无论何时，只要在对象上调用一个方法，它的状态就有可能发生改变。</p><p>实现封装的关键在于，绝对不能让类中的方法直接访问其他类的实例字段，程序只能通过对象的方法与对象的数据进行交互。封装给对象赋予了“黑盒”特征，这是提高重用性合可靠性的关键。这意味着一个类可以完全改变存储数据的方式，只要仍旧使用同样的方法操作数据，其他对象就不会知道也不用关系这个类所发生的变化。</p><p>OOP的另一个原则会让用户自定义Java类变得更为容易，这就是：可以通过扩展其他类来构建新类。事实上，在Java中，所有的类都源自一个“神通广大的超类”，它就是<code>Object</code>。所有其他类都扩展自这个<code>Object</code>类</p><p>在扩展一个已有的类时，这个扩展后的新类具有被扩展的类的全部属性合方法。你只需要在新类中提供适用于这个新类的新方法和数据字段就可以了。通过扩展一个类来建立另外一个类的过程称为继承（inheritance）。</p><h3 id="对象"><a class="header-anchor" href="#对象"></a>对象</h3><p>要想使用OOP，一定要清楚对象的三个主要特性：</p><ul><li>对象的行为（behavior）：可以对对象完成哪些操作，或者可以对对象应用哪些方法</li><li>对象的状态（state）：当调用哪些方法时，对象会如何响应</li><li>对象的标识（identity）：如何区分具有相同行为与状态的不同对象</li></ul><h3 id="识别类"><a class="header-anchor" href="#识别类"></a>识别类</h3><h3 id="类之间的关系"><a class="header-anchor" href="#类之间的关系"></a>类之间的关系</h3><h2 id="使用预定义类"><a class="header-anchor" href="#使用预定义类"></a>使用预定义类</h2><h3 id="对象与对象变量"><a class="header-anchor" href="#对象与对象变量"></a>对象与对象变量</h3><p>要想使用对象，首先必须构造对象，并指定其初始状态。然后对对象应用方法。</p><p>在Java程序设计语言中，要使用构造器（constructor，或称为构造函数）构造新实例。构造器是一种特殊的方法，用来构造并初始化对象。下面看一个例子。在标准Java库中包含一个<code>Date</code>类。它的对象可以描述一个时间点。</p><p>构造器的名字应该与类名相同。因此<code>Date</code>类的构造器名为<code>Date</code>。想要构造一个<code>Date</code>对象，需要在构造器前面加上<code>new</code>操作符，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Date()</span><br></pre></td></tr></table></figure><p>这个表达式构造了一个新对象。这个对象被初始化为当前的日期和时间。</p><p>如果需要的话，也可以将这个对象传递给一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="keyword">new</span> Date());</span><br></pre></td></tr></table></figure><p>或者，也可以对刚刚创建的对象应用一个方法。<code>Date</code>类中有一个<code>toString</code>方法。这个方法将返回日期的字符串描述。下面的语句可以说明如何对新构造的<code>Date</code>对象应用<code>toString</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> Date().toString();</span><br></pre></td></tr></table></figure><p>在着两个例子中，构造的对象仅使用了一次。通常你会希望构造的对象可以多次使用，因此，需要将对象存放在一个变量中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date birthday = <span class="keyword">new</span> Date();</span><br></pre></td></tr></table></figure><p>在对象与对象之间存在着一个重要的区别。例如，一下语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date deadline；<span class="comment">// deadline doesn&#x27;t refer to any object</span></span><br></pre></td></tr></table></figure><p>定义了一个对象变量<code>deadline</code>，它可以引用<code>Date</code>类型的对象。但是，一定要认识到：变量<code>deadline</code>不是一个对象，而且实际上它也没有引用任何对象。此时还不能在这个变量上使用任何<code>Date</code>方法。必须首先初始化变量<code>deadline</code>，这里有两个选择。</p><p>可以初始化这个变量，让它引用一个新的构造的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deadline = <span class="keyword">new</span> Date();</span><br></pre></td></tr></table></figure><p>也可以设置这个变量，让它引用一个已有的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deadline = birthday；</span><br></pre></td></tr></table></figure><p>现在，这两个变量都引用同一个对象，要认识到重要的一点：对象变量并没有实际包含一个对象，它只是引用一个对象。</p><p>在Java中，任何对象变量的值都是对存储在另外一个地方的某个对象的引用，下面的语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date deadline = <span class="keyword">new</span> Date();</span><br></pre></td></tr></table></figure><p>有两个部分。表达式<code>new Date()</code>构造了一个<code>Date</code>类型的对象，它的</p><p>P98</p><h2 id="类简介"><a class="header-anchor" href="#类简介"></a>类简介</h2><p>类是 Java 程序最基本的元素结构。编写 Java 代码不可能不定义类。所有 Java 语句都在类中，而且所有方法都在类中实现。</p><h3 id="面向对象的基本概念"><a class="header-anchor" href="#面向对象的基本概念"></a>面向对象的基本概念</h3><p>类：类由一些保存值的数据字段和处理这些值的方法组成。类定义一种新的引用类型。</p><p>对象：对象是类的实例。对象一般通过实例化类创建，方法是使用 new 关键字并调用构造方法。</p><p>一个类的定义包含一个签名和一个主体。类的签名定义类的名称，可能还会指定其他重要信息。类的主体是一些放在花括号里的成员。类的成员一般包含字段和方法，也可以包含构造方法、初始化程序和嵌套类型。成员可以是静态的，也可以是非静态的。静态成员属于类本身，而非静态成员关联在类的实例上。</p><blockquote><p>常见的成员有四种：类字段、类方法、实例字段和实例方法。Java 的主要工作就是与这些成员交互。</p></blockquote><p>类的签名可能会声明它扩展自其他类。被扩展的类叫作超类，扩展其他类的类叫作子类。子类继承超类的成员，而且可以声明新成员，或者使用新的实现覆盖继承的方法。</p><p>类的成员可以使用访问修饰符 <code>public</code>、<code>protected</code> 或 <code>private</code>。这些修饰符指定成员在使用方和子类中是否可见以及能否访问。类通过这种方式控制对非公开 API 成员的访问。隐藏成员是一种面向对象设计技术，叫作数据封装（data encapsulation）</p><h3 id="其他引用类型"><a class="header-anchor" href="#其他引用类型"></a>其他引用类型</h3><p>类的签名可能还会声明类实现了一个或多个接口。接口是一种类似于类的引用类型，其中定义了方法签名，但一般没有实现方法的方法主体。</p><p>不过，从 Java 8 开始，接口可以使用关键字 <code>default</code> 指明其中的方法是可选的。如果方法是可选的，接口文件必须包含默认的实现（因此才选用 <code>default</code> 这个关键词）；所有实现这个接口的类，如果没有实现可选的方法，就使用接口中默认的实现。</p><p>实现接口的类必须为接口的非默认方法提供主体。实现某个接口的类的实例，也是这个接口类型的实例。</p><p>类和接口是 Java 定义的五种基本引用类型中最重要的两个。另外三个基本引用类型是数组、枚举类型和注解类型（通常直接叫“注解”）。枚举是特殊的类，注解是特殊的接口。</p><h3 id="定义类的句法"><a class="header-anchor" href="#定义类的句法"></a>定义类的句法</h3><p>最简单的类定义方式是在关键字 <code>class</code> 后面放上类的名称，然后在花括号中放一些类的成员。<code>class</code> 关键字前面可以放修饰符关键字或注解。</p><ul><li>如果类扩展其他类，类名后面要加上<code>extends</code> 关键字和要扩展的类名。</li><li>如果类实现一个或多个接口，类名或 <code>extends</code> 子句之后要加上 <code>implements</code> 关键字和用逗号分隔的接口名。</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Integer</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Comparable</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 这里是类的成员 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义泛型类时还可以指定类型参数和通配符。</p><p>类声明可以包含修饰符关键字。除访问控制修饰符（<code>public</code>、<code>protected</code> 等）之外，还可以使用：</p><ul><li><code>abstract</code>：<code>abstract</code> 修饰的类未完全实现，不能实例化。只要类中有 <code>abstract</code> 修饰的方法，这个<br>类就必须使用 <code>abstract</code> 声明。</li><li><code>final</code>：<code>final</code> 修饰符指明这个类无法被扩展。类不能同时声明为 <code>abstract</code> 和 <code>final</code>。</li><li><code>strictfp</code>：如果类声明为 <code>strictfp</code>，那么其中所有的方法都声明为 <code>strictfp</code>。这个修饰符极少使用。</li></ul><h2 id="字段和方法"><a class="header-anchor" href="#字段和方法"></a>字段和方法</h2><p>类可以看成是由一些数据（也叫状态）和操作这些状态的代码组成的。数据存储在字段中，操作数据的代码则组织在方法中。</p><p>字段和方法有两种不同的类型：关联在类自身上的类成员（也叫静态成员），关联在类的单个实例（即对象）身上的实例成员。因此成员分为四类：类字段、类方法、实例字段、实例方法</p><p>示例定义了一个简单的类 <code>Circle</code>，包含所有这四种成员类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123; </span><br><span class="line">  <span class="comment">// 类字段 </span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> PI= <span class="number">3.14159</span>;  <span class="comment">// 有用的常量 </span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 类方法：基于参数计算得到一个值 </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">radiansToDegrees</span><span class="params">(<span class="keyword">double</span> radians)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> radians * <span class="number">180</span> / PI; </span><br><span class="line">  &#125; </span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 实例字段 </span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">double</span> r;               <span class="comment">// 圆的半径 </span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 两个实例方法：处理对象的实例字段 </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">area</span><span class="params">()</span> </span>&#123;         <span class="comment">// 计算圆的面积 </span></span><br><span class="line">    <span class="keyword">return</span> PI * r * r; </span><br><span class="line">  &#125; </span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">circumference</span><span class="params">()</span> </span>&#123; <span class="comment">// 计算圆的周长 </span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * PI * r; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="声明字段的句法"><a class="header-anchor" href="#声明字段的句法"></a>声明字段的句法</h3><p>声明字段的句法和声明局部变量的句法很像，不过声明字段时还可以使用修饰符。最简单的字段声明包含字段类型和字段名。类型前面可以放零个或多个修饰符关键字或注解，名称后面可以跟着一个等号和初始化表达式，提供字段的初始值。如果两个或多个字段的类型和修饰符都相同，那么可以把一些用逗号分隔的字段名和初始化表达式放在类型后面。如下是一些有效的字段声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">private</span> String name; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DAYS_PER_WEEK = <span class="number">7</span>; </span><br><span class="line">String[] daynames = <span class="keyword">new</span> String[DAYS_PER_WEEK]; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">17</span>, b = <span class="number">37</span>, c = <span class="number">53</span>;</span><br></pre></td></tr></table></figure><p>字段的修饰符由零个或多个下述关键字组成。</p><ul><li><code>public</code>、<code>protected</code>、<code>private</code>：这些访问控制修饰符指明字段是否能在定义它的类之外使用，以及能在何处使用。</li><li><code>static</code>：如果使用，这个修饰符指明字段关联在定义它的类自身上，而不是类的实例身上。</li><li><code>final</code>：这个修饰符指明，字段一旦初始化，其值就不能改变。如果字段同时使用 <code>static</code> 和<code>final</code> 修饰，那么这个字段就是编译时常量，javac 会将其内联化。<code>final</code> 修饰的字段也可以用来创建实例不可变的类。</li><li><code>transient</code>：这个修饰符指明字段不是对象持久状态的一部分，无需跟对象的其他内容一起序列化。</li><li><code>volatile</code>：这个修饰符指明字段有额外的语义，可被两个或多个线程同时使用。<code>volatile</code> 修饰符的意思是，字段的值必须始终从主存储器中读取和释放，不能被线程缓存（在寄存器或CPU 缓存中）。</li></ul><h3 id="类字段"><a class="header-anchor" href="#类字段"></a>类字段</h3><p>类字段关联在定义它的类身上，而不是类的实例身上。下面这行代码声明一个类字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.14159</span>;</span><br></pre></td></tr></table></figure><p>这行代码声明了一个字段，类型为 <code>double</code>，名称为 <code>PI</code>，并且把值设为 <code>3.14159</code>。<code>static</code> 修饰符表明这个字段是类字段。因为使用了 <code>static</code> 修饰符，所以类字段有时也叫静态字段。<code>final</code> 修饰符表明这个字段的值不会改变。因为字段 <code>PI</code> 表示一个常量，而且声明时加上了 <code>final</code>，所以无法修改它的值。在 Java（以及很多其他语言）中，习惯使用大写字母命名常量，因此这个字段的名称是 PI，而不是 pi。类字段经常用来定义常量，也就是说，<code>static</code> 和 <code>final</code> 修饰符经常放在一起使用。然而，并不是所有类字段都是常量，因此字段可以声明为<code>static</code> 但不声明为 <code>final</code>。</p><p>公开的静态字段其实就是全局变量。不过，类字段的名称会被定义它的类名限定，因此，如果不同的模块定义了同名的全局变量，Java 不会出现其他语言遇到的名称冲突问题。关于静态字段，有个重点要理解，即字段的值只有一个副本。字段关联在类自身上，而不是类的实例身上。看一下 <code>Circle</code> 类中的各个方法，它们都使用了同一个字段。在<code>Circle</code> 类内部，可以直接使用 <code>PI</code> 引用这个字段。但是在类的外部，既要使用类名也要使用字段名，这样才能引用这个独一无二的字段。<code>Circle</code> 类外部的方法要使用 <code>Circle.PI</code>才能访问这个字段。</p><h3 id="类方法"><a class="header-anchor" href="#类方法"></a>类方法</h3><p>和类字段一样，类方法也使用 <code>static</code> 修饰符声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">radiansToDegrees</span><span class="params">(<span class="keyword">double</span> rads)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> rads * <span class="number">180</span> / PI; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码声明了一个类方法，名为 <code>radiansToDegrees()</code>。这个方法只有一个参数，类型为<code>double</code>，而且会返回一个 <code>double</code> 类型的值。</p><p>和类字段一样，类方法也关联在类身上，而不是对象身上。在类的外部调用类方法时，既要指定类名也要指定方法名。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.0弧度等于多少角度？ </span></span><br><span class="line"><span class="keyword">double</span> d = Circle.radiansToDegrees(<span class="number">2.0</span>);</span><br></pre></td></tr></table></figure><p>如果想在定义类方法的类中调用类方法，则不用指定类名。还可以使用静态成员导入声明，减少输入的代码量。<br>注意，<code>Circle.radiansToDegrees()</code> 方法的主体使用了类字段 <code>PI</code>。类方法可以使用所在类（或其他类）中的任何类字段和类方法。</p><p>类方法不能使用任何实例字段或实例方法，因为类方法不关联在类的实例身上。也就是说，虽然 <code>adiansToDegrees()</code> 方法在 <code>Circle</code> 类中定义，但它不能使用 <code>Circle</code> 对象的任何实例成员。</p><h3 id="实例字段"><a class="header-anchor" href="#实例字段"></a>实例字段</h3><p>声明时没使用 <code>static</code> 修饰符的字段是实例字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">double</span> r;    <span class="comment">// 圆的半径</span></span><br></pre></td></tr></table></figure><p>实例字段关联在类的实例身上，所以创建的每个 <code>Circle</code> 对象都有自己的一个 <code>double</code> 类型 r 字段副本。在这个例子中，r 表示某个圆的半径。每个 <code>Circle</code> 对象的半径和其他所有<code>Circle</code> 对象的都不同。</p><p>在类定义内部，实例字段只通过名称引用。在实例方法 <code>circumference()</code> 的主体中有一个例子。在类外部，实例字段的名称前面必须加上包含这个字段的对象的引用。例如，如果变量 <code>c</code> 保存的是一个 <code>Circle</code> 对象的引用，那么可以使用表达式 <code>c.r</code> 引用这个圆的半径：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Circle c = <span class="keyword">new</span> Circle(); <span class="comment">// 创建一个Circle对象，把引用存储在c中 </span></span><br><span class="line">c.r = <span class="number">2.0</span>;               <span class="comment">// 把一个值赋值给实例字段r </span></span><br><span class="line">Circle d = <span class="keyword">new</span> Circle(); <span class="comment">// 再创建一个Circle对象 </span></span><br><span class="line">d.r = c.r * <span class="number">2</span>;           <span class="comment">// 让这个圆是前一个的两倍大</span></span><br></pre></td></tr></table></figure><p>实例字段是面向对象编程的关键。实例字段保存对象的状态，实例字段的值把两个对象区分开来。</p><h3 id="实例方法"><a class="header-anchor" href="#实例方法"></a>实例方法</h3><p>实例方法处理类的具体实例（对象），只要声明方法时没使用 static 关键字，这个方法默认就是实例方法。</p><p>实例方法这个特性让面向对象编程开始变得有趣。示例中定义的 Circle 类包含两个实例方法，<code>area()</code> 和 <code>circumference()</code>，分别计算指定 Circle 对象表示的圆的面积和周长。若想在定义实例方法的类之外使用实例方法，必须在方法名前加上要处理的实例引用。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个Circle对象，存储在变量c中 </span></span><br><span class="line">Circle c = <span class="keyword">new</span> Circle(); </span><br><span class="line">c.r = <span class="number">2.0</span>;              <span class="comment">// 设定这个对象的实例字段 </span></span><br><span class="line"><span class="keyword">double</span> a = c.area();    <span class="comment">// 调用这个对象的实例方法</span></span><br></pre></td></tr></table></figure><p>在实例方法内部，可以自然地访问属于调用这个方法的对象的实例字段。前面说过，经常可以把对象理解为包含状态（通过对象的字段表示）和行为（处理状态的方法）的包（bundle）。<br>实现所有实例方法时都使用了一个隐式参数，方法签名里没显示这个参数。这个隐式参数是 <code>this</code>，它的值是调用这个方法的对象引用。在我们的例子中，是一个 <code>Circle</code> 对象。</p><h3 id="this引用的工作方式"><a class="header-anchor" href="#this引用的工作方式"></a><code>this</code>引用的工作方式</h3><p>方法签名中不显示隐式参数 <code>this</code>，是因为往往用不到。只要 Java 方法在类中访问实例字段，都默认访问 <code>this</code> 参数指向的对象中的字段。实例方法调用同一个类中的其他实例方法时也一样，可以理解为“在当前对象上调用实例方法”。</p><p>不过，如果想明确表明方法访问的是自己的字段或方法，可以显式使用 <code>this</code> 关键字。例如，可以改写 <code>area()</code> 方法，显式使用 <code>this</code> 引用实例字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">area</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Circle.PI * <span class="keyword">this</span>.r * <span class="keyword">this</span>.r; &#125;</span><br></pre></td></tr></table></figure><p>上述代码还显式使用类名引用类字段 <code>PI</code>。在这样简单的方法中，一般无需如此明确。然而，遇到复杂情况时，在不强制要求使用 <code>this</code> 的地方使用 <code>this</code>，有时可以让代码的意图更明确。</p><p>不过，有些情况下必须使用 <code>this</code> 关键字。例如，如果方法的参数或方法中的局部变量和类中的某个字段同名，那么就必须使用 <code>this</code> 引用这个字段，因为只使用字段名的话，引用的是方法的参数或局部变量。</p><p>例如，可以把下述方法添加到 <code>Circle</code> 类中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRadius</span><span class="params">(<span class="keyword">double</span> r)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">this</span>.r = r;      <span class="comment">// 把参数r的值赋值给字段this.r </span></span><br><span class="line">                   <span class="comment">// 注意，不能写成r = r </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有些开发者会谨慎选择方法的参数名，避免和字段名冲突，因此可以最大限度地少使用<code>this</code>。</p><p>最后，注意，实例方法可以使用 <code>this</code> 关键字，但类方法不能使用。这是因为类方法不关联在单个对象身上。</p><h2 id="创建和初始化对象"><a class="header-anchor" href="#创建和初始化对象"></a>创建和初始化对象</h2><p>构造方法是类成员，作用是初始化新建实例中的字段。</p><p>再看一下创建 Circle 对象的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Circle c = <span class="keyword">new</span> Circle();</span><br></pre></td></tr></table></figure><p>这行代码的意思是，调用看起来有点儿像方法的东西创建一个新 Circle 实例。其实，<code>Circle()</code> 是一种构造方法，是类中的成员，和类同名，而且像方法一样，有主体。</p><p>构造方法的工作方式是这样的：</p><ul><li><p><code>new</code> 运算符表明我们想创建类的一个新实例。</p></li><li><p>首先，分配内存存储新建的对象实例；</p></li><li><p>然后，调用构造方法的主体，并传入指定的参数；</p></li><li><p>最后，构造方法使用这些参数执行初始化新对象所需的一切操作。</p></li></ul><p>Java 中的每个类都至少有一个构造方法，其作用是执行初始化新对象所需的操作。定义的 Circle 类没有显式定义构造方法，因此 javac 编译器自动为我们提供了一个构造方法（叫作默认构造方法）。这个构造方法没有参数，而且不执行任何特殊的初始化操作。</p><h3 id="定义构造方法"><a class="header-anchor" href="#定义构造方法"></a>定义构造方法</h3><p>可是 <code>Circle</code> 对象显然要做些初始化操作，下面就来定义一个构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.14159</span>; <span class="comment">// 常量 </span></span><br><span class="line">    <span class="comment">// 实例字段，保存圆的半径 </span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">double</span> r; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 构造方法：初始化r字段</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> r)</span> </span>&#123; <span class="keyword">this</span>.r = r; &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 实例方法：基于半径计算得到值 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">circumference</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span> * PI * r; &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">area</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> PI * r*r; &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">radius</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> r; &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新定义了 <code>Circle</code> 类，包含一个构造方法，指定新建 <code>Circle</code> 对象的半径。借此机会，我们还把字段改成了受保护的（禁止对象随意访问）。</p><p>如果依赖编译器提供的默认构造方法，就要编写如下的代码显式初始化半径：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Circle c = <span class="keyword">new</span> Circle(); </span><br><span class="line">c.r = <span class="number">0.25</span>;</span><br></pre></td></tr></table></figure><p>添加上述构造方法后，初始化变成创建对象过程的一部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Circle c = <span class="keyword">new</span> Circle(<span class="number">0.25</span>);</span><br></pre></td></tr></table></figure><p>下面是一些关于命名、声明和编写构造方法的基本注意事项。</p><ul><li>构造方法的名称始终和类名一样。</li><li>声明构造方法时不指定返回值类型，连 <code>void</code> 都不用。</li><li>构造方法的主体初始化对象。可以把主体的作用想象为设定 <code>this</code> 引用的内容。</li><li>构造方法不能返回 <code>this</code> 或任何其他值。</li></ul><h3 id="定义多个构造方法"><a class="header-anchor" href="#定义多个构造方法"></a>定义多个构造方法</h3><p>有时，根据遇到的情况，可能想在多个不同的方式中选择一个最便利的方式初始化对象。例如，我们可能想使用指定的值初始化圆的半径，或者使用一个合理的默认值初始化。为<code>Circle</code> 类定义两个构造方法的方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">()</span> </span>&#123; r = <span class="number">1.0</span>; &#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> r)</span> </span>&#123; <span class="keyword">this</span>.r = r; &#125;</span><br></pre></td></tr></table></figure><p><code>Circle</code> 类只有一个实例字段，由此并没有太多的初始化方式。不过在复杂的类中，经常会定义不同的构造方法。<br>只要构造方法的参数列表不同，为一个类定义多个构造方法完全是合法的。编译器会根据提供的参数数量和类型判断你想使用的是哪个构造方法。定义多个构造方法和方法重载的原理类似。</p><h3 id="在一个构造方法中调用另一个构造方法"><a class="header-anchor" href="#在一个构造方法中调用另一个构造方法"></a>在一个构造方法中调用另一个构造方法</h3><p>如果类有多个构造方法，会用到 <code>this</code> 关键字的一种特殊用法。在一个构造方法中可以使用<code>this</code> 关键字调用同一个类中的另一个构造方法。因此，前面 <code>Circle</code> 类的两个构造方法可以改写成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是基本构造方法：初始化半径 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> r)</span> </span>&#123; <span class="keyword">this</span>.r = r; &#125; </span><br><span class="line"><span class="comment">// 这个构造方法使用this()调用前一个构造方法 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">()</span> </span>&#123; <span class="keyword">this</span>(<span class="number">1.0</span>); &#125;</span><br></pre></td></tr></table></figure><ul><li>如果一些构造方法共用大量的初始化代码，这种技术是有用的，因为能避免代码重复。</li><li>如果构造方法执行很多初始化操作，在这种复杂的情况下，这种技术十分有用。</li></ul><p>使用 <code>this()</code> 时有个重大的限制：只能出现在构造方法的第一个语句中。但是，调用这个方法后，可以执行构造方法所需的任何其他初始化操作。这个限制的原因涉及自动调用超类的构造方法。</p><h3 id="字段的默认值和初始化程序"><a class="header-anchor" href="#字段的默认值和初始化程序"></a>字段的默认值和初始化程序</h3><p>类中的字段不一定要初始化。如果没有指定初始值，字段自动使用默认值初始化：false、\u0000、0、0.0 或 null。具体使用哪个值，根据字段的类型而定。这些默认值由 Java 语言规范规定，实例字段和类字段都适用。</p><p>如果字段的默认值不适合字段，可以显式提供其他的初始值。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.14159</span>; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">double</span> r = <span class="number">1.0</span>;</span><br></pre></td></tr></table></figure><p>字段声明不是任何方法的一部分。Java 编译器会自动为字段生成初始化代码，然后把这些代码放在类的所有构造方法中。这些初始化代码按照字段在源码中出现的顺序插入构造方法，因此，字段的初始化程序可以使用在其之<br>前声明的任何字段的初始值。</p><p>例如下述代码片段是一个假设类，定义了一个构造方法和两个实例字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleClass</span> </span>&#123; </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> len = <span class="number">10</span>; </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] table = <span class="keyword">new</span> <span class="keyword">int</span>[len]; </span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SampleClass</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) table[i] = i; </span><br><span class="line">  &#125; </span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 类余下的内容省略了…… </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对这个例子来说，javac 生成的构造方法其实和下述代码等效：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SampleClass</span><span class="params">()</span> </span>&#123; </span><br><span class="line">  <span class="keyword">int</span> len = <span class="number">10</span>; </span><br><span class="line">  <span class="keyword">int</span>[] table = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) table[i] = i; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果某个构造方法的开头使用 <code>this()</code> 调用其他构造方法，那么字段的初始化代码不会出现在这个构造方法中。此时，初始化由 <code>this()</code> 调用的构造方法处理。</p><p>既然实例字段在构造方法中初始化，那么类字段在哪初始化呢？就算从不创建类的实例，类字段也关联在类身上。这意味着，类字段要在调用构造方法之前初始化。</p><p>为此，javac 会为每个类自动生成一个类初始化方法。类字段在这个方法的主体中初始化。这个方法只在首次使用类之前调用一次（经常是在 Java 虚拟机首次加载类时）</p><p>和实例字段的初始化一样，类字段的初始化表达式按照类字段在源码中的顺序插入类初始化方法。因此，类字段的初始化表达式可以使用在其之前声明的类字段。类初始化方法是内部方法，对 Java 程序员不可见。在类文件中，它的名称是 <code>&lt;clinit&gt;</code>（例如，使用 javap检查类文件时可以看到这个方法）。</p><p><strong>初始化程序块</strong></p><p>至此，我们知道对象可以通过字段的初始化表达式和构造方法中的任何代码初始化。类有一个类初始化方法，这个方法和构造方法不一样，不能像构造方法那样显式定义主体。不过，Java 允许编写用于初始化类字段的代码，所用的结构叫静态初始化程序。静态初始化程序由 static 关键字及随后的花括号中的代码块组成。在类定义中，静态初始化程序可以放在字段和方法定义能出现的任何位置。例如，下述代码为两个类字段执行一些重要的初始化操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们可以使用三角函数画出圆的轮廓 </span></span><br><span class="line"><span class="comment">// 不过，三角函数很慢，所以预先算出一些值 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrigCircle</span> </span>&#123; </span><br><span class="line">  <span class="comment">// 这是静态查找表和各自的初始化程序 </span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUMPTS = <span class="number">500</span>; </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> sines[] = <span class="keyword">new</span> <span class="keyword">double</span>[NUMPTS]; </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> cosines[] = <span class="keyword">new</span> <span class="keyword">double</span>[NUMPTS]; </span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 这是一个静态初始化程序，填充上述数组 </span></span><br><span class="line">  <span class="keyword">static</span> &#123; </span><br><span class="line">    <span class="keyword">double</span> x = <span class="number">0.0</span>; </span><br><span class="line">    <span class="keyword">double</span> delta_x = (Circle.PI/<span class="number">2</span>)/(NUMPTS-<span class="number">1</span>); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, x = <span class="number">0.0</span>; i &lt; NUMPTS; i++, x += delta_x) &#123; </span><br><span class="line">      sines[i] = Math.sin(x); </span><br><span class="line">      cosines[i] = Math.cos(x); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// 类余下的内容省略了…… </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个类可以有任意多个静态初始化程序。各个初始化程序块的主体会和所有静态字段的初始化表达式一起合并到类初始化方法中。静态初始化程序和类方法的相同点是，不能使用this 关键字，也不能使用类中的任何实例字段或实例方法。</p><p>类还可以有实例初始化程序。实例初始化程序和静态初始化程序类似，不过初始化的是对象而不是类。一个类可以有任意多个实例初始化程序，而且实例初始化程序可以放在字段和方法定义能出现的任何位置。各个实例初始化程序的主体和所有实例字段初始化表达式一起，放在类中每个构造方法的开头。实例初始化程序的外观和静态初始化程序类似，不过不使用 static 关键字。也就是说，实例初始化程序只是放在花括号里的任意 Java 代码。</p><p>实例初始化程序可以初始化数组或其他需要复杂初始化操作的字段。实例初始化程序有时很有用，因为它们把初始化代码放在字段后面，而不是单独放在构造方法中。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUMPTS = <span class="number">100</span>; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] data = <span class="keyword">new</span> <span class="keyword">int</span>[NUMPTS]; </span><br><span class="line">&#123; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUMPTS; i++) data[i] = i; &#125;</span><br></pre></td></tr></table></figure><p>不过，现实中很少使用实例初始化程序。</p><h2 id="子类和继承"><a class="header-anchor" href="#子类和继承"></a>子类和继承</h2><p>前面定义的 <code>Circle</code> 是个简单的类，只通过半径区分不同的圆。假设我们要同时使用大小和位置表示圆。例如，在笛卡儿平面中，圆心在 (0, 0)、半径为 1.0 的圆，与圆心在 (1, 2)、半径为 1.0 的圆不同。为此，需要一个新类，我们称其为 <code>PlaneCircle</code>。</p><p>我们想添加表示圆所在位置的功能，但不想失去 <code>Circle</code> 类的任何现有功能。为此，可以把<code>PlaneCircle</code> 类定义为 <code>Circle</code> 类的子类，让 <code>PlaneCircle</code> 类继承超类 <code>Circle</code> 的字段和方法。</p><p>通过定义子类或扩展超类向类中添加功能的能力，是面向对象编程范式的核心。</p><h3 id="扩展类"><a class="header-anchor" href="#扩展类"></a>扩展类</h3><p>如何把 <code>PlaneCircle</code> 类定义为 <code>Circle</code> 类的子类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlaneCircle</span> <span class="keyword">extends</span> <span class="title">Circle</span> </span>&#123; </span><br><span class="line">  <span class="comment">// 自动继承了Circle类的字段和方法， </span></span><br><span class="line">  <span class="comment">// 因此只要在这里编写新代码 </span></span><br><span class="line">  <span class="comment">// 新实例字段，存储圆心的位置 </span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> cx, cy; </span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 新构造方法，用于初始化新字段 </span></span><br><span class="line">  <span class="comment">// 使用特殊的句法调用构造方法Circle() </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PlaneCircle</span><span class="params">(<span class="keyword">double</span> r, <span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">super</span>(r);      <span class="comment">// 调用超类的构造方法Circle() </span></span><br><span class="line">    <span class="keyword">this</span>.cx = x;   <span class="comment">// 初始化实例字段cx </span></span><br><span class="line">    <span class="keyword">this</span>.cy = y;   <span class="comment">// 初始化实例字段cy </span></span><br><span class="line">  &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getCentreX</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> cx; </span><br><span class="line">  &#125; </span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getCentreY</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> cy; </span><br><span class="line">  &#125; </span><br><span class="line"> </span><br><span class="line">  <span class="comment">// area()和circumference()方法继承自Circle类 </span></span><br><span class="line">  <span class="comment">// 新实例方法，检查点是否在圆内 </span></span><br><span class="line">  <span class="comment">// 注意，这个方法使用了继承的实例字段r </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInside</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">double</span> dx = x - cx, dy = y - cy;            <span class="comment">// 到圆心的距离 </span></span><br><span class="line">    <span class="keyword">double</span> distance = Math.sqrt(dx*dx + dy*dy); <span class="comment">// 勾股定理 </span></span><br><span class="line">    <span class="keyword">return</span> (distance &lt; r);                      <span class="comment">// 返回true或false </span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一行中使用的 <code>extends</code> 关键字。这个关键字告诉 Java，<code>PlaneCircle</code> 类扩展 <code>Circle</code> 类（或者说是 <code>Circle</code> 类的子类），这意味着 <code>PlaneCircle</code> 类会继承 <code>Circle</code> 类的字段和方法。</p><blockquote><p>有多种方式能表达新对象类型具有 <code>Circle</code> 的特征，而且有位置。这或许是最简单的方式，但不一定是最合适的方式，尤其是在大型系统中。</p></blockquote><p><code>isInside()</code> 方法的定义展示了字段继承：这个方法使用了字段 <code>r</code>（由 <code>Circle</code> 类定义），就像这个字段是在 <code>PlaneCircle</code> 中定义的一样。<code>PlaneCircle</code> 还继承了 <code>Circle</code> 的方法。因此，如果变量 <code>pc</code> 保存的值是一个 <code>PlaneCircle</code> 对象引用，那么可以编写如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> ratio = pc.circumference() / pc.area();</span><br></pre></td></tr></table></figure><p>这么做就好像 <code>area()</code> 和 <code>circumference()</code> 两个方法是在 <code>PlaneCircle</code> 中定义的一样。</p><p>子类的另一个特性是，每个 <code>PlaneCircle</code> 对象都是完全合法的 <code>Circle</code> 对象。如果 <code>pc</code> 是一个 <code>PlaneCircle</code> 对象的引用，那么可以把这个引用赋值给 <code>Circle</code> 类型的变量，忽略它表示的位置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位置在原点的单位圆 </span></span><br><span class="line">PlaneCircle pc = <span class="keyword">new</span> PlaneCircle(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>); </span><br><span class="line">Circle c = pc;     <span class="comment">// 无需校正，赋值给Circle类型的变量</span></span><br></pre></td></tr></table></figure><p>把 <code>PlaneCircle</code> 对象赋值给 <code>Circle</code> 类型的变量时无需校正。<code>Circle</code> 类型的变量 <code>c</code> 中保存的值仍然是有效的 <code>PlaneCircle</code> 对象，但编译器不确定这一点，因此不校正无法反向（缩小）转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缩小转换需要校正（虚拟机还要做运行时检查） </span></span><br><span class="line">PlaneCircle pc2 = (PlaneCircle) c; </span><br><span class="line"><span class="keyword">boolean</span> origininside = ((PlaneCircle) c).isInside(<span class="number">0.0</span>, <span class="number">0.0</span>);</span><br></pre></td></tr></table></figure><p>如果声明类时使用了 <code>final</code> 修饰符，那么这个类无法被扩展或定义子类。<code>java.lang.String</code> 是 final 类的一个示例。把类声明为 <code>final</code> 可以避免不需要的类扩展：在 String 对象上调用方法时，就算 String 类来自某个未知的外部源，你也知道这个方法是在 String 类中定义的。</p><h3 id="超类、对象和类层次结构"><a class="header-anchor" href="#超类、对象和类层次结构"></a>超类、对象和类层次结构</h3><p>在这个示例中，<code>PlaneCircle</code> 是 <code>Circle</code> 的子类，也可以说 <code>Circle</code> 是 <code>PlaneCircle</code> 的超类。类的超类在 <code>extends</code> 子句中指定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlaneCircle</span> <span class="keyword">extends</span> <span class="title">Circle</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>你定义的每个类都有超类。如果没使用 <code>extends</code> 子句指定超类，那么超类是 <code>java.lang.Object</code>。<code>Object</code> 是特殊的类，原因有如下两个：</p><ul><li>它是 Java 中唯一一个没有超类的类；</li><li>所有 Java 类都从 <code>Object</code> 类中继承方法。</li></ul><p>因为每个类（除了 <code>Object</code> 类）都有超类，所以 Java 中的类组成一个类层次结构。</p><h3 id="子类的构造方法"><a class="header-anchor" href="#子类的构造方法"></a>子类的构造方法</h3><p>再看一下示例中的 <code>PlaneCircle()</code> 构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PlaneCircle</span><span class="params">(<span class="keyword">double</span> r, <span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">super</span>(r);       <span class="comment">// 调用超类的构造方法Circle() </span></span><br><span class="line">  <span class="keyword">this</span>.cx = x;    <span class="comment">// 初始化实例字段cx </span></span><br><span class="line">  <span class="keyword">this</span>.cy = y;    <span class="comment">// 初始化实例字段cy </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这个构造方法显式初始化了 <code>PlaneCircle</code> 类中新定义的字段 <code>cx</code> 和 <code>cy</code>，但仍使用超类的 <code>Circle()</code> 构造方法初始化继承的字段。为了调用超类的构造方法，这个构造方法调用了<code>super()</code> 方法。</p><p><code>super</code> 是 Java 的保留字。它的用法之一是，在子类的构造方法中调用超类的构造方法。这种用法和在一个构造方法中使用 <code>this()</code> 调用同一个类中的其他构造方法类似。使用<code>super()</code> 调用构造方法和使用 <code>this()</code> 调用构造方法有同样的限制：</p><ul><li>只能在构造方法中像这样使用 <code>super()</code>；</li><li>必须在构造方法的第一个语句中调用超类的构造方法，甚至要放在局部变量声明之前。</li></ul><p>传给 <code>super()</code> 的实参必须与超类构造方法的形参匹配。如果超类定义了多个构造方法，那么 <code>super()</code> 可以调用其中任何一个，具体是哪个，由传入的参数决定。</p><h3 id="构造方法链"><a class="header-anchor" href="#构造方法链"></a>构造方法链</h3><ul><li>创建类的实例时，Java 保证一定会调用这个类的构造方法；</li><li>创建任何子类的实例时，Java还保证一定会调用超类的构造方法。</li></ul><p>为了保证第二点，Java 必须确保每个构造方法都会调用超类的构造方法。</p><p>因此，如果构造方法的第一个语句没有使用 <code>this()</code> 或 <code>super()</code> 显式调用另一个构造方法，javac 编译器会插入 <code>super()</code>（即调用超类的构造方法，而且不传入参数）。如果超类没有无需参数的可见构造方法，这种隐式调用会导致编译出错。</p><p>以 <code>PlaneCircle</code> 类为例，创建这个类的新实例时会发生下述事情：</p><ul><li>首先，调用 <code>PlaneCircle</code> 类的构造方法；</li><li>这个构造方法显示调用了 <code>super(r)</code>，调用 <code>Circle</code> 类的一个构造方法；</li><li><code>Circle()</code> 构造方法会隐式调用 <code>super()</code>，调用 <code>Circle</code> 的超类 <code>Object</code> 的构造方法（Object只有一个构造方法）；</li><li>此时，到达层次结构的顶端了，接下来开始运行构造方法；</li><li>首先运行 <code>Object</code> 构造方法的主体；</li><li>返回后，再运行 <code>Circle()</code> 构造方法的主体；</li><li>最后，对 <code>super(r)</code> 的调用返回后，接着执行 <code>PlaneCircle()</code> 构造方法中余下的语句。</li></ul><p>这个过程表明，构造方法链在一起调用；只要创建对象，就会调用一系列构造方法，从子类到超类，一直向上，直到类层次结构的顶端 <code>Object</code> 类为止。因为超类的构造方法始终在子类的构造方法的第一个语句中调用，所以 <code>Object</code> 类的构造方法的主体始终最先运行，然后运行 <code>Object</code> 的子类的构造方法，就这样沿着类层次结构一直向下，直到实例化的那个类为止。</p><blockquote><p>调用构造方法时，超类中的字段也会被初始化。</p></blockquote><h3 id="默认构造方法"><a class="header-anchor" href="#默认构造方法"></a>默认构造方法</h3><p>前面对构造方法链的说明漏了一点。如果构造方法没有调用超类的构造方法，Java 会隐式调用。那么，如果类没有声明构造方法呢？此时，Java 会为类隐式添加一个构造方法。这个默认的构造方法什么也不做，只是调用超类的构造方法。</p><p>例如，如果没为 <code>PlaneCircle</code> 类声明构造方法，那么 Java 会隐式插入下述构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PlaneCircle</span><span class="params">()</span> </span>&#123; <span class="keyword">super</span>(); &#125;</span><br></pre></td></tr></table></figure><p>如果超类 <code>Circle</code> 没有声明无参数的构造方法，那么在这个自动插入 <code>PlaneCircle()</code> 类的默认构造方法中调用 <code>super()</code> 会导致编译出错。一般来说，如果类没有定义无参数的构造方法，那么它的所有子类必须定义显式调用超类构造方法的构造方法，而且要传入所需的参数。</p><p>如果类没有定义任何构造方法，默认会为其提供一个无参数的构造方法。声明为 <code>public</code> 的类，提供的构造方法也声明为 <code>public</code>。提供给其他类的默认构造方法则不使用任何可见性修饰符，这些构造方法具有默认的可见性。</p><p>如果创建的 <code>public</code> 类不能公开实例化，就应该至少声明一个非 <code>public</code> 的构造方法，以此避免插入默认的 <code>public</code> 构造方法。从来不会实例化的类（例如 <code>java.lang.Math</code> 或 <code>java.lang.System</code>），应该定义一个 <code>private</code> 构造方法。这种构造方法不能在类外部调用，但可以避免自动插入默认的构造方法。</p><h3 id="遮盖超类的字段"><a class="header-anchor" href="#遮盖超类的字段"></a>遮盖超类的字段</h3><p>假如 <code>PlaneCircle</code> 类需要知道圆心到原点 (0, 0) 的距离，我们可以再添加一个实例字段保存这个值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">double</span> r;</span><br></pre></td></tr></table></figure><p>在构造方法中添加下述代码可以算出这个字段的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.r = Math.sqrt(cx*cx + cy*cy); <span class="comment">// 勾股定理</span></span><br></pre></td></tr></table></figure><p>但是等一下，这个新添加的字段 <code>r</code> 和超类 <code>Circle</code> 中表示半径的字段 <code>r</code> 同名了。发生这种情况时，我们说，<code>PlaneCircle</code> 类的 <code>r</code> 字段遮盖了 <code>Circle</code> 类的 <code>r</code> 字段。（当然，这个例子是故意这么做的。新字段其实应该命名为 distanceFromOrigin。）</p><blockquote><p>在你编写的代码中，为字段命名时应该避免遮盖超类的字段。如果遮盖了，几乎就表明代码写得不好。</p></blockquote><p>这样定义 <code>PlaneCircle</code> 类之后，表达式 <code>r</code> 和 <code>this.r</code> 都引用 <code>PlaneCircle</code> 类中的这个字段。那么，如何引用 <code>Circle</code> 类中保存圆的半径的 <code>r</code> 字段呢？有一种特殊的句法可以实现这个需求——使用 <code>super</code> 关键字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r       <span class="comment">// 引用PlaneCircle的字段 </span></span><br><span class="line"><span class="keyword">this</span>.r  <span class="comment">// 引用PlaneCircle的字段 </span></span><br><span class="line"><span class="keyword">super</span>.r <span class="comment">// 引用Circle的字段</span></span><br></pre></td></tr></table></figure><p>引用被遮盖的字段还有一种方式——把 <code>this</code>（或类的实例）校正为适当的超类，然后再访问字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((Circle) <span class="keyword">this</span>).r <span class="comment">// 引用Circle类的字段</span></span><br></pre></td></tr></table></figure><p>如果想引用的遮盖字段不是在类的直接超类中定义的，这种校正技术特别有用。假如有三个类 A、B 和 C，它们都定义了一个名为 x 的字段，而且 C 是 B 的子类，B 是 A 的子类。那么，在 C 类的方法中可以按照下面的方式引用这些不同的字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x              <span class="comment">// C类的x字段 </span></span><br><span class="line"><span class="keyword">this</span>.x         <span class="comment">// C类的x字段 </span></span><br><span class="line"><span class="keyword">super</span>.x        <span class="comment">// B类的x字段 </span></span><br><span class="line">((B)<span class="keyword">this</span>).x    <span class="comment">// B类的x字段 </span></span><br><span class="line">((A)<span class="keyword">this</span>).x    <span class="comment">// A类的x字段 </span></span><br><span class="line"><span class="keyword">super</span>.<span class="keyword">super</span>.x  <span class="comment">// 非法，不能这样引用A类的x字段</span></span><br></pre></td></tr></table></figure><p>类似地，如果 c 是 C 类的实例，那么可以像这样引用这三个字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c.x           <span class="comment">// C类的x字段 </span></span><br><span class="line">((B)c).x      <span class="comment">// B类的x字段 </span></span><br><span class="line">((A)c).x      <span class="comment">// A类的x字段</span></span><br></pre></td></tr></table></figure><p>目前为止，讨论的都是实例字段。类字段也能被遮盖。引用被遮盖的类字段中的值，可以使用相同的 <code>super</code> 句法，但没必要这么做，因为始终可以把类名放在类字段前引用这个字段。假如 <code>PlaneCircle</code> 的实现方觉得 <code>Circle.PI</code> 字段没有提供足够的小数位，那么他可以自己定义 <code>PI</code> 字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.14159265358979323846</span>;</span><br></pre></td></tr></table></figure><p>现在，<code>PlaneCircle</code> 类中的代码可以通过表达式 <code>PI</code> 或 <code>PlaneCircle.PI</code> 使用这个更精确的值，还可以使用表达式 <code>super.PI</code> 和 <code>Circle.PI</code> 引用精度不高的旧值。不过，<code>PlaneCircle</code>继承的 <code>area()</code> 和 <code>circumference()</code> 方法是在 <code>Circle</code> 类中定义的，所以，就算 <code>Circle.PI</code> 被<code>PlaneCircle.PI</code> 遮盖了，这两个方法还是会使用 <code>Circle.PI</code> 的值。</p><h3 id="覆盖超类的方法"><a class="header-anchor" href="#覆盖超类的方法"></a>覆盖超类的方法</h3><p>如果类中定义的某个实例方法和超类的某个方法有相同的名称、返回值类型和参数，那么这个方法会覆盖（override）超类中对应的方法。在这个类的对象上调用这个方法时，调用的是新定义的方法，而不是超类中定义的旧方法。</p><blockquote><p>覆盖方法的返回值类型可以是原方法返回值的子类（没必要一模一样）。这叫作协变返回（covariant return）。</p></blockquote><p>方法覆盖是面向对象编程中一项重要且有用的技术。<code>PlaneCircle</code> 没有覆盖 <code>Circle</code> 类定义的任何方法，不过，假设我们要再定义一个 <code>Circle</code> 的子类，名为 <code>Ellipse</code>。</p><p>此时，<code>Ellipse</code> 一定要覆盖 <code>Circle</code> 的 <code>area()</code> 和 <code>circumference()</code> 方法，因为计算圆的面积和周长的公式不适用于椭圆。</p><p>下面针对方法覆盖的讨论只涉及实例方法。类方法的运作机制完全不同，无法覆盖。和字段一样，类方法也能被子类遮盖，但不能覆盖。好的编程风格是调用类方法时始终在前面加上定义这个方法的类名。如果把类名当成方法名的一部分，那么这两个方法的名称就不一样，因此其实并没有遮盖什么。</p><p>在进一步讨论方法覆盖之前，要理解方法覆盖和方法重载之间的区别。方法重载指的是（在同一个类中）定义多个名称相同但参数列表不同的方法。这和方法覆盖十分不同，因此别混淆了。</p><h4 id="覆盖不是遮盖"><a class="header-anchor" href="#覆盖不是遮盖"></a>覆盖不是遮盖</h4><p>虽然 Java 使用很多类似的方式对待字段和方法，但方法覆盖和字段遮盖一点儿都不一样。为了引用遮盖的字段，只需把对象校正成适当超类的实例，但不能使用这种技术调用覆盖的实例方法。下述代码展示了这个重要区别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;                          <span class="comment">// 定义一个类，名为A </span></span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">1</span>;                       <span class="comment">// 一个实例字段 </span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;            <span class="comment">// 一个实例方法 </span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">char</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;A&#x27;</span>; &#125;  <span class="comment">// 一个类方法 </span></span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;                <span class="comment">// 定义A的一个子类 </span></span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">2</span>;                       <span class="comment">// 遮盖A类的字段i </span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> -i; &#125;           <span class="comment">// 覆盖A类的方法f </span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">char</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;B&#x27;</span>; &#125;  <span class="comment">// 遮盖A类的类方法g() </span></span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverrideTest</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123; </span><br><span class="line">    B b = <span class="keyword">new</span> B();               <span class="comment">// 创建一个类型为B的新对象 </span></span><br><span class="line">    System.out.println(b.i);     <span class="comment">// 引用B.i，打印2 </span></span><br><span class="line">    System.out.println(b.f());   <span class="comment">// 引用B.f()，打印-2 </span></span><br><span class="line">    System.out.println(b.g());   <span class="comment">// 引用B.g()，打印B </span></span><br><span class="line">    System.out.println(B.g());   <span class="comment">// 调用B.g()更好的方式 </span></span><br><span class="line"> </span><br><span class="line">    A a = (A) b;                 <span class="comment">// 把b校正成A类的实例 </span></span><br><span class="line">    System.out.println(a.i);     <span class="comment">// 现在引用的是A.i，打印1 </span></span><br><span class="line">    System.out.println(a.f());   <span class="comment">// 还是引用B.f()，打印-2 </span></span><br><span class="line">    System.out.println(a.g());   <span class="comment">// 引用A.g()，打印A </span></span><br><span class="line">    System.out.println(A.g());   <span class="comment">// 调用A.g()更好的方式 </span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初看起来，可能觉得方法覆盖和字段遮盖的这种区别有点奇怪，但稍微想想，确实有道理。</p><p>假设我们要处理一些 <code>Circle</code> 和 <code>Ellipse</code> 对象。为了记录这些圆和椭圆，我们把它们存储在一个 <code>Circle[]</code> 类型的数组中。这么做是可以的，因为 <code>Ellipse</code> 是 <code>Circle</code> 的子类，所以所有 <code>Ellipse</code> 对象都是合法的 <code>Circle</code> 对象。</p><p>遍历这个数组的元素时，不需要知道也无需关心元素是 <code>Circle</code> 对象还是 <code>Ellipse</code> 对象。不过，需要密切关注的是，在数组的元素上调用 <code>area()</code> 方法是否能得到正确的值。也就是说，如果是椭圆对象就不能使用计算圆面积的公式。</p><p>我们真正希望的是，计算面积时对象能“做正确的事”：<code>Circle</code> 对象使用自己的方式计算，<code>Ellipse</code> 对象使用对椭圆来说正确的方式计算。</p><p>这样理解，就不会对 Java 使用不同的方式处理方法覆盖和字段遮盖感到奇怪了。</p><h4 id="虚拟方法查找"><a class="header-anchor" href="#虚拟方法查找"></a>虚拟方法查找</h4><p>如果一个 <code>Circle[]</code> 类型的数组保存的是 <code>Circle</code> 和 <code>Ellipse</code> 对象，那么编译器怎么知道要在具体的元素上调用 <code>Circle</code> 类还是 <code>Ellipse</code> 类的 <code>area()</code> 方法呢？事实上，源码编译器在编译时并不知道要调用哪个方法。</p><p>不过，javac 生成的字节码会在运行时使用“虚拟方法查找”（virtual method lookup）。解释器运行代码时，会查找适用于数组中各个对象的 <code>area()</code> 方法。即，解释器解释表达式<code>o.area()</code> 时，会检查变量 <code>o</code> 引用的对象的真正运行时类型，然后找到适用于这个类型的<code>area()</code> 方法。</p><p>JVM 不会直接使用关联在变量 <code>o</code> 表示的静态类型身上的 <code>area()</code> 方法，如果这么做，前面详述的方法覆盖机制就不成立了。Java 的实例方法默认使用虚拟查找。之后会详细介绍编译时和运行时类型，以及它们对虚拟方法查找的影响。</p><h4 id="调用被覆盖的方法"><a class="header-anchor" href="#调用被覆盖的方法"></a>调用被覆盖的方法</h4><p>我们已经说明了方法覆盖和字段遮盖之间的重要区别。然而，调用被覆盖的方法的 Java 句法和访问被遮盖的字段的句法十分类似——都使用 <code>super</code> 关键字。如下述代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; </span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">1</span>;                <span class="comment">// 被子类B遮盖的实例字段 </span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;     <span class="comment">// 被子类B覆盖的实例方法</span></span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123; </span><br><span class="line">  <span class="keyword">int</span> i;                    <span class="comment">// 这个字段遮盖A类的字段i </span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;                 <span class="comment">// 这个方法覆盖A类的方法f() </span></span><br><span class="line">    i = <span class="keyword">super</span>.i + <span class="number">1</span>;      <span class="comment">// 可以像这样读取A.i的值 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.f() + i; <span class="comment">// 可以像这样调用A.f() </span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面说过，使用 <code>super</code> 引用被遮盖的字段时，相当于把 <code>this</code> 校正为超类类型，然后通过超类类型访问字段。不过，使用 <code>super</code> 调用被覆盖的方法和校正 <code>this</code> 引用不是一回事。也就是说，在上述代码中，表达式 <code>super.f()</code> 和 <code>((A)this).f()</code> 的作用不一样。</p><p>解释器使用 <code>super</code> 句法调用实例方法时，会执行一种修改过的虚拟方法查找。第一步和常规的虚拟方法查找一样，确定调用方法的对象属于哪个类。正常情况下，运行时会在这个类中寻找对应的方法定义。但是，使用 <code>super</code> 句法调用方法时，先在这个类的超类中查找。如果超类直接实现了这个方法，那就调用这个方法。如果超类继承了这个方法，那就调用继承的方法。</p><p>注意，<code>super</code> 关键字调用的是方法的直接覆盖版本。假设 A 类有个子类 B，B 类有个子类C，而且这三个类都定义了同一个方法 <code>f()</code>。在 <code>C.f()</code> 方法中使用 <code>super.f()</code> 可以调用方法 <code>B.f()</code>，因为 <code>C.f()</code> 直接覆盖了 <code>B.f()</code>。但是，<code>C.f()</code> 不能直接调用 <code>A.f()</code>，因为 <code>super.super.f()</code> 不是合法的 Java 句法。当然，如果 <code>C.f()</code> 调用了 <code>B.f()</code>，有合理的理由认为，<code>B.f()</code> 可能会调用 <code>A.f()</code>。</p><p>使用被覆盖的方法时，这种链式调用相当常见。覆盖方法是增强方法功能，但不完全取代这个方法的一种方式。</p><blockquote><p>别把调用被覆盖方法的 <code>super</code> 和构造方法中调用超类构造方法的 <code>super()</code> 搞混了。虽然二者使用的关键字相同，但却是两种完全不同的句法。具体而言，可以在类中的任何位置使用 <code>super</code> 调用超类中被覆盖的方法，但是只能在构造方法的第一个语句中使用 <code>super()</code> 调用超类的构造方法。</p></blockquote><p>还有一点很重要，即记住，只能在覆盖某个方法的类内部使用 <code>super</code> 调用被覆盖的方法。假如 <code>e</code> 引用的是一个 <code>Ellipse</code> 对象，那么无法在 <code>e</code> 上调用 <code>Circle</code> 类中定义的 <code>area()</code> 方法。</p><h2 id="数据隐藏和封装"><a class="header-anchor" href="#数据隐藏和封装"></a>数据隐藏和封装</h2><p>类由一些数据和方法组成。目前，我们尚未说明的最重要的面向对象技术之一是，把数据隐藏在类中，只能通过方法获取。这种技术叫作<strong>封装</strong>（encapsulation），因为它把数据（和内部方法）安全地密封在类这个“容器”中，只能由可信的用户（即这个类中的方法）访问。</p><p>为什么要这么做呢？最重要的原因是，隐藏类的内部实现细节。如果避免让程序员依赖这些细节，你就可以放心地修改实现，而无需担心会破坏使用这个类的现有代码。</p><blockquote><p>你应该始终封装自己的代码。如果没有封装好，那么几乎无法推知并最终确认代码是否正确，尤其是在多线程环境中（而基本上所有 Java 程序都运行在多线程环境中）。</p></blockquote><p>使用封装的另一个原因是保护类，避免有意或无意做了糊涂事。类中经常包含一些相互依赖的字段，而且这些字段的状态必须始终如一。如果允许程序员（包括你自己）直接操作这些字段，修改某个字段后可能不会修改重要的相关字段，那么类的状态就前后不一致了。然而，如果必须调用方法才能修改字段，那么这个方法可以做一切所需的措施，确保状态一致。类似地，如果类中定义的某些方法仅供内部使用，隐藏这些方法能避免这个类的用户调用这些方法。</p><p>封装还可以这样理解：把类的数据都隐藏后，方法就是在这个类的对象上能执行的唯一一种可能的操作。</p><p>只要小心测试和调试方法，就可以认为类能按预期的方式运行。然而，如果类的所有字段都可以直接操作，那么要测试的可能性根本数不完。</p><p>隐藏类的字段和方法还有一些次要的原因。</p><ul><li>如果内部字段和方法在外部可见，会弄乱类的 API。让可见的字段尽量少，可以保持类的整洁，从而更易于使用和理解。</li><li>如果方法对类的使用者可见，就必须为其编写文档。把方法隐藏起来，可以节省时间和精力。</li></ul><h3 id="访问控制"><a class="header-anchor" href="#访问控制"></a>访问控制</h3><p>Java 定义了一些访问控制规则，可以禁止类的成员在类外部使用。 <code>public</code> 关键字，连同 <code>protected</code>和 <code>private</code>（还有一个特殊的），是访问控制修饰符，为字段或方法指定访问规则。</p><h4 id="访问包"><a class="header-anchor" href="#访问包"></a>访问包</h4><p>Java 语言不直接支持包的访问控制。访问控制一般在类和类的成员这些层级完成</p><h4 id="访问类"><a class="header-anchor" href="#访问类"></a>访问类</h4><p>默认情况下，顶层类在定义它的包中可以访问。不过，如果顶层类声明为 <code>public</code>，那么在任何地方都能访问。</p><h4 id="访问成员"><a class="header-anchor" href="#访问成员"></a>访问成员</h4><p>类的成员在类的主体里始终可以访问。默认情况下，在定义这个类的包中也可以访问成员。这种默认的访问等级一般叫作包访问。这只是四个可用的访问等级中的一个。其他三个等级使用 <code>public</code>、<code>protected</code> 和 <code>private</code> 修饰符定义。下面是使用这三个修饰符的示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Laundromat</span> </span>&#123;      <span class="comment">// 所有人都可以使用这个类 </span></span><br><span class="line">  <span class="keyword">private</span> Laundry[] dirty;     <span class="comment">// 不能使用这个内部字段 </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wash</span><span class="params">()</span> </span>&#123; ... &#125;   <span class="comment">// 但能使用这两个公开的方法 </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dry</span><span class="params">()</span> </span>&#123; ... &#125;    <span class="comment">// 处理内部字段 </span></span><br><span class="line">  <span class="comment">// 子类可能会想调整这个字段 </span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">int</span> temperature; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下述访问规则适用于类的成员：</p><ul><li>类中的所有字段和方法在类的主体里始终可以使用。</li><li>如果类的成员使用 <code>public</code> 修饰符声明，那么可以在能访问这个类的任何地方访问这个成员。这是限制最松的访问控制类型。</li><li>如果类的成员声明为 <code>private</code>，那么除了在类内部之外，其他地方都不能访问这个成员。这是限制最严的访问控制类型。</li><li>如果类的成员声明为 <code>protected</code>，那么包里的所有类都能访问这个成员（等同于默认的包访问规则），而且在这个类的任何子类的主体中也能访问这个成员，而不管子类在哪个包中定义。</li><li>如果声明类的成员时没使用任何修饰符，那么使用默认的访问规则（有时叫包访问），包中的所有类都能访问这个成员，但在包外部不能访问。</li></ul><blockquote><p>默认的访问规则比 <code>protected</code> 严格，因为默认规则不允许在包外部的子类中访问成员。</p></blockquote><p>使用 <code>protected</code> 修饰的成员时要格外小心。假设 A 类使用 <code>protected</code> 声明了一个字段 x，而且在另一个包中定义的 B 类继承 A 类（重点是 B 类在另一包中定义）。因此，B 类继承了这个 <code>protected</code> 声明的字段 x，那么，在 B 类的代码中可以访问当前实例的这个字段，而且引用 B 类实例的代码也能访问这个字段。但是，这并不意味着在 B 类的代码中能读取任何一个 A 类实例的受保护字段。</p><p>下面通过代码讲解这个语言细节。A 类的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> javanut6.ch03; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> String name; </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(String named)</span> </span>&#123; </span><br><span class="line">        name = named; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> name; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B 类的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> javanut6.ch03.different; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> javanut6.ch03.A; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123; </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">(String named)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">super</span>(named); </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;B: &quot;</span> + name; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Java 的包不能“嵌套”，所以 <code>javanut6.ch03.different</code> 和 <code>javanut6.ch03</code>是不同的包。<code>javanut6.ch03.different</code> 不以任何方式包含在 <code>javanut6.ch03</code> 中，也和 <code>javanut6.ch03</code> 没有任何关系。</p></blockquote><p>可是，如果我们试图把下面这个新方法添加到 B 类中，会导致编译出错，因为 B 类的实例无法访问任何一个 A 类的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">examine</span><span class="params">(A a)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;B sees: &quot;</span> + a.name; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果把这个方法改成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">examine</span><span class="params">(B b)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;B sees another B: &quot;</span> + b.name; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就能编译通过，因为同一类型的多个实例可以访问各自的 <code>protected</code> 字段。当然，如果 B 类和 A 类在同一包中，那么任何一个 B 类的实例都能访问任何一个 A 类实例的全部受保护字段，因为使用 <code>protected</code> 声明的字段对同一个包中的每个类都可见。</p><h4 id="访问控制和继承"><a class="header-anchor" href="#访问控制和继承"></a>访问控制和继承</h4><p>Java 规范规定：</p><ul><li>子类继承超类中所有可以访问的实例字段和实例方法；</li><li>如果子类和超类在同一个包中定义，那么子类继承所有没使用 <code>private</code> 声明的实例字段和方法；</li><li>如果子类在其他包中定义，那么它继承所有使用 <code>protected</code> 和 <code>public</code> 声明的实例字段和方法；</li><li>使用 <code>private</code> 声明的字段和方法绝不会被继承；类字段和类方法也一样；</li><li>构造方法不会被继承（而是链在一起调用）。</li></ul><p>不过，有些程序员会对“子类不继承超类中不可访问的字段和方法”感到困惑。这似乎暗示了，创建子类的实例时不会为超类中使用 private 声明的字段分配内存。然而，这不是上述规定想表述的。</p><blockquote><p>其实，子类的每个实例都包含一个完整的超类实例，其中包括所有不可访问的字段和方法。</p></blockquote><p>某些成员可能无法访问，这似乎和类的成员在类的主体中始终可以访问相矛盾。为了避免误解，我们要使用“继承的成员”表示那些可以访问的超类成员。</p><p>那么，关于成员访问性的正确表述应该是：“所有继承的成员和所有在类中定义的成员都是可以访问的。”这句话还可以换种方式说：</p><ul><li>类继承超类的所有实例字段和实例方法（但不继承构造方法）；</li><li>在类的主体中始终可以访问这个类定义的所有字段和方法，而且还可以访问继承自超类的可访问的字段和方法。</li></ul><h4 id="成员访问规则总结"><a class="header-anchor" href="#成员访问规则总结"></a>成员访问规则总结</h4><table><thead><tr><th>能否访问</th><th>公开</th><th>受保护</th><th>默认</th><th>私有</th></tr></thead><tbody><tr><td>定义成员的类</td><td>是</td><td>是</td><td>是</td><td>是</td></tr><tr><td>同一个包中的类</td><td>是</td><td>是</td><td>是</td><td>否</td></tr><tr><td>不同包中的子类</td><td>是</td><td>是</td><td>否</td><td>否</td></tr><tr><td>不同的包，也不是子类</td><td>是</td><td>否</td><td>否</td><td>否</td></tr></tbody></table><p>下面是一些使用可见性修饰符的经验法则。</p><ul><li>只使用 <code>public</code> 声明组成类的公开 API 的方法和常量。使用 <code>public</code> 声明的字段只能是常量和不能修改的对象，而且必须同时使用 <code>final</code> 声明。</li><li>使用 <code>protected</code> 声明大多数使用这个类的程序员不会用到的字段和方法，但在其他包中定义子类时可能会用到。</li><li>如果字段和方法供类的内部实现细节使用，但是同一个包中协作的类也要使用，那么就使用默认的包可见性。</li><li>使用 <code>private</code> 声明只在类内部使用，在其他地方都要隐藏的字段和方法。</li></ul><blockquote><p>严格来说，使用 <code>protected</code> 声明的成员是类公开 API 的一部分，必须为其编写文档，而且不能轻易修改，以防破坏依赖这些成员的代码。</p></blockquote><p>如果不确定该使用 <code>protected</code>还是 <code>private</code> ，那么先使用 <code>private</code>。如果太过严格，可以稍微放松访问限制（如果是字段的话，还可以提供访问器方法）。设计 API 时这么做尤其重要，因为提高访问限制是不向后兼容的改动，可能会破坏依赖成员访问性的代码。</p><h3 id="数据访问器方法"><a class="header-anchor" href="#数据访问器方法"></a>数据访问器方法</h3><p>在 <code>Circle</code> 类那个示例中，我们使用 <code>public</code> 声明表示圆半径的字段。<code>Circle</code> 类可能有很好的理由让这个字段可以公开访问；这个类很简单，字段之间不相互依赖。但是，当前实现的 <code>Circle</code> 类允许对象的半径为负数，而半径为负数的圆肯定不存在。可是，只要半径存储在声明为 <code>public</code> 的字段中，任何程序员都能把这个字段的值设为任何想要的值，而不管这个值有多么不合理。唯一的办法是限制程序员，不让他们直接访问这个字段，然后定义<code>public</code> 方法，间接访问这个字段。提供 <code>public</code> 方法读写字段和把字段本身声明为 <code>public</code>不是一回事。目前而言，二者的区别是，方法可以检查错误。</p><p>例如，我们或许不想让 <code>Circle</code> 对象的半径使用负数——负数显然不合理，但目前的实现没有阻止这么做。以下展示了使用数据隐藏和封装技术定义的 <code>Circle</code> 类，避免把半径设为负数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> shapes;        <span class="comment">// 为这个类指定一个包 </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;  <span class="comment">// 这个类还使用public声明 </span></span><br><span class="line">  <span class="comment">// 这是通用的常量，所以要保证声明为public </span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.14159</span>; </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">double</span> r;  <span class="comment">// 半径被隐藏了，但在子类中可见 </span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 限制半径取值的方法 </span></span><br><span class="line">  <span class="comment">// 这是子类可能感兴趣的实现细节 </span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">checkRadius</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (radius &lt; <span class="number">0.0</span>) </span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;radius may not be negative.&quot;</span>); </span><br><span class="line">  &#125; </span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 非默认的构造方法 </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> r)</span> </span>&#123;  </span><br><span class="line">    checkRadius(r); </span><br><span class="line">    <span class="keyword">this</span>.r = r; </span><br><span class="line">  &#125; </span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 公开的数据访问器方法 </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getRadius</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> r; &#125; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRadius</span><span class="params">(<span class="keyword">double</span> r)</span> </span>&#123; </span><br><span class="line">    checkRadius(r); </span><br><span class="line">    <span class="keyword">this</span>.r = r; </span><br><span class="line">  &#125; </span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 操作实例字段的方法 </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">area</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> PI * r * r; &#125; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">circumference</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span> * PI * r; &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Circle</code> 类的这个版本使用 <code>protected</code> 声明 <code>r</code> 字段，还定义了访问器方法 <code>getRadius()</code> 和<code>setRadius()</code>，用于读写这个字段的值，而且限制半径不能为负数。<code>r</code> 字段使用 <code>protected</code>声明，所以可以在子类中直接（且高效地）访问。</p><p>我们在一个名为 <code>shapes</code> 的包中定义 <code>Circle</code> 类。因为 <code>r</code> 字段使用 <code>protected</code> 声明，所以<code>shapes</code> 包中的任何其他类都能直接访问这个字段，而且能把它设为任何值。这里假设<code>shapes</code> 包中的所有类都由同一个作者或者协作的多个作者编写，而且包中的类相互信任，不会滥用拥有的访问权限影响彼此的实现细节。</p><p>最后，限制半径不能使用负数的代码在一个使用 <code>protected</code> 声明的方法中，这个方法是<code>checkRadius()</code>。虽然 <code>Circle</code> 类的用户无法调用这个方法，但这个类的子类可以调用，而且如果想修改对半径的限制，还可以覆盖这个方法。</p><blockquote><p>在 Java 中，数据访问器方法的命名有个通用约定，即以“get”和“set”开头。但是，如果要访问的字段是 boolean 类型，那么读取字段的方法使用的名称可能会以“is”开头。例如，名为 readable 的 boolean 类型字段对应的访问器方法是 <code>isReadable()</code> 而不是 <code>getReadable()</code>。</p></blockquote><h2 id="抽象类和方法"><a class="header-anchor" href="#抽象类和方法"></a>抽象类和方法</h2><p>我们把 <code>Circle</code> 类声明为 <code>shapes</code> 包的一部分。假设我们计划实现多个表示形状的类：Rectangle、Square、Ellipse、Triangle 等。我们可以在这些表示形状的类中定义两个基本方法：<code>area()</code> 和 <code>circumference()</code>。那么，为了能方便处理由形状组成的数组，这些表示形状的类最好有个共同的超类 <code>Shape</code>。这样组织类层次结构的话，每个形状对象，不管具体表示的是什么形状，都能赋予类型为 <code>Shape</code> 的变量、字段或数组元素。我们想在 <code>Shape</code> 类中封装所有形状共用的功能（例如，<code>area()</code> 和 <code>circumference()</code> 方法）。但是，通用的 <code>Shape</code> 类不表示任何类型的形状，所以不能为这些方法定义有用的实现。Java使用抽象方法解决这种问题。</p><p>Java 允许使用 <code>abstract</code> 修饰符声明方法，此时只定义方法但不实现方法。<code>abstract</code> 修饰的方法没有主体，只有一个签名和一个分号。以下是 <code>abstract</code> 方法和这些方法所在的<code>abstract</code> 类相关的规则。</p><ul><li><p>只要类中有一个 <code>abstract</code> 方法，那么这个类本身就自动成为 <code>abstract</code> 类，而且必须声明为 <code>abstract</code> 类，否则会导致编译出错。</p></li><li><p><code>abstract</code> 类无法实例化。</p></li><li><p><code>abstract</code> 类的子类必须覆盖超类的每个 <code>abstract</code> 方法并且把这些方法全部实现（即提供方法主体），才能实例化。这种类一般叫作具体子类（concrete subclass），目的是强调它不是抽象类。</p></li><li><p>如果 <code>abstract</code> 类的子类没有实现继承的所有 <code>abstract</code> 方法，那么这个子类还是抽象类，而且必须使用 <code>abstract</code> 声明。</p></li><li><p>使用 <code>static</code>、<code>private</code> 和 <code>final</code> 声明的方法不能是抽象方法，因为这三种方法在子类中不能覆盖。类似地，<code>final</code> 类中不能有任何 <code>abstract</code> 方法。</p></li><li><p>就算类中没有 <code>abstract</code> 方法，这个类也能声明为 <code>abstract</code>。使用这种方式声明的<code>abstract</code> 类表明实现的不完整，要交给子类实现。这种类不能实例化。</p></li></ul><p>下 面 通 过 一 个 示 例 说 明 这 些 规 则 的 运 作 方 式。 如 果 定 义 <code>Shape</code> 类 时 把 <code>area()</code> 和<code>circumference()</code> 声明为 <code>abstract</code> 方法，那么 <code>Shape</code> 的子类必须实现这两个方法才能实例化。也就是说，每个 <code>Shape</code> 对象都要确保实现了这两个方法。以下示例展示了如何编写代码。在这段代码中，定义了一个抽象的 <code>Shape</code> 类和两个具体子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">area</span><span class="params">()</span></span>;                      <span class="comment">// 两个抽象方法 </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">circumference</span><span class="params">()</span></span>;             <span class="comment">// 注意，没有主体，只有分号 </span></span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123; </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.14159265358979323846</span>; </span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">double</span> r;                                 <span class="comment">// 实例字段 </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> r)</span> </span>&#123; <span class="keyword">this</span>.r = r; &#125;             <span class="comment">// 构造方法 </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getRadius</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> r; &#125;             <span class="comment">// 访问器 </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">area</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> PI*r*r; &#125;             <span class="comment">// 实现超类中的 </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">circumference</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span>*PI*r; &#125;    <span class="comment">// 两个抽象方法 </span></span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123; </span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">double</span> w, h;                              <span class="comment">// 实例字段 </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span><span class="params">(<span class="keyword">double</span> w, <span class="keyword">double</span> h)</span> </span>&#123;              <span class="comment">// 构造方法 </span></span><br><span class="line">    <span class="keyword">this</span>.w = w; <span class="keyword">this</span>.h = h; </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getWidth</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> w; &#125;              <span class="comment">// 访问器方法 </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getHeight</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> h; &#125;             <span class="comment">// 另一个访问器 </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">area</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> w*h; &#125;                <span class="comment">// 实现超类中的 </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">circumference</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span>*(w + h); &#125; <span class="comment">// 两个抽象方法 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Shape 类中每个抽象方法的括号后面都是分号，没有花括号，也没定义方法的主体。使用以上示例中定义的这几个类可以编写如下的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Shape[] shapes = <span class="keyword">new</span> Shape[<span class="number">3</span>];       <span class="comment">// 创建一个保存形状的数组 </span></span><br><span class="line">shapes[<span class="number">0</span>] = <span class="keyword">new</span> Circle(<span class="number">2.0</span>);         <span class="comment">// 填充这个数组 </span></span><br><span class="line">shapes[<span class="number">1</span>] = <span class="keyword">new</span> Rectangle(<span class="number">1.0</span>, <span class="number">3.0</span>); </span><br><span class="line">shapes[<span class="number">2</span>] = <span class="keyword">new</span> Rectangle(<span class="number">4.0</span>, <span class="number">2.0</span>); </span><br><span class="line"> </span><br><span class="line"><span class="keyword">double</span> totalArea = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; shapes.length; i++) </span><br><span class="line">    totalArea += shapes[i].area();   <span class="comment">// 计算这些形状的面积</span></span><br></pre></td></tr></table></figure><p>有两点要注意。</p><ul><li>Shape 类的子类对象可以赋值给 Shape 类型数组中的元素，无需校正。这又是一个放大转换引用类型的例子。</li><li>即便 Shape 类没有定义 <code>area()</code> 和 <code>circumference()</code> 方法的主体，各个 Shape 对象还是能调用这两个方法。调用这两个方法时，使用虚拟方法查找技术找到要调用的方法。因此，圆的面积使用 <code>Circle</code> 类中定义的方法计算，矩形的面积使用 <code>Rectangle</code> 类中定义的方法计算。</li></ul><h2 id="转换引用类型"><a class="header-anchor" href="#转换引用类型"></a>转换引用类型</h2><p>对象可以在不同的引用类型之间转换。和基本类型一样，引用类型转换可以是放大转换（编译器自动完成），也可以是需要校正的缩小转换（或许运行时还要检查）。要想理解引用类型的转换，必须理解引用类型组成的层次结构，这个体系叫作<strong>类层次结构</strong>。</p><p>每个 Java 引用类型都扩展其他类型，被扩展的类型是这个类型的超类。类型继承超类的字段和方法，然后定义属于自己的一些额外的字段和方法。在 Java 中，类层次结构的根是一个特殊的类，名为 <code>Object</code>。所有 Java 类都直接或间接地扩展 <code>Object</code> 类。<code>Object</code> 类定义了一些特殊的方法，所有对象都能继承（或覆盖）这些方法。</p><p>简单理解类层次结构之后，我们可以定义引用类型的转换规则了。</p><ul><li><p>对象不能转换成不相关的类型。例如，就算使用校正运算符，Java 编译器也不允许把<code>String</code> 对象转换成 <code>Point</code> 对象。</p></li><li><p>对象可以转换成超类类型，或者任何祖先类类型。这是放大转换，因此不用校正。例如，<code>String</code> 对象可以赋值给 <code>Object</code> 类型的变量，或者传入期待 <code>Object</code> 类型参数的方法。</p></li><li><p>对象可以转换成子类类型，但这是缩小转换，需要校正。Java 编译器临时允许执行这种转换，但 Java 解释器在运行时会做检查，确保转换有效。根据程序的逻辑，确认对象的确是子类的实例后才会把对象校正成子类类型。否则，解释器会抛出<code>ClassCastException</code> 异常。例如，如果把一个 <code>String</code> 对象赋值给 <code>Object</code> 类型的变量，那么后面可以校正这个变量的值，再变回 <code>String</code> 类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object o = <span class="string">&quot;string&quot;</span>;   <span class="comment">// 把String对象放大转换成Object类型 </span></span><br><span class="line">String s = (String) o; <span class="comment">// 程序后面再把这个Object对象缩小转换成String类型</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>没有执行转换操作，而是直接把对象当成超类的实例。这种行为有时称为里氏替换原则（Liskov substitution principle）</p></blockquote><p>数组是对象，而且有自己的一套转换规则。首先，任何数组都能放大转换成 <code>Object</code> 对象。带校正的缩小转换能把这个对象转换回数组。下面是一个示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把数组放大转换成Object对象 </span></span><br><span class="line">Object o = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;; </span><br><span class="line"><span class="comment">// 程序后面…… </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span>[] a = (<span class="keyword">int</span>[]) o;  <span class="comment">// 缩小转换回数组类型</span></span><br></pre></td></tr></table></figure><p>除了能把数组转换成对象之外，如果两个数组的“基类型”是可以相互转换的引用类型，那么数组还能转换成另一个类型的数组。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个字符串数组 </span></span><br><span class="line">String[] strings = <span class="keyword">new</span> String[] &#123; <span class="string">&quot;hi&quot;</span>, <span class="string">&quot;there&quot;</span> &#125;; </span><br><span class="line"><span class="comment">// 可以放大转换成CharSequence[]类型 </span></span><br><span class="line"><span class="comment">// 因为String类型可以放大转换成CharSequence类型 </span></span><br><span class="line">CharSequence[] sequences = strings; </span><br><span class="line"><span class="comment">// 缩小转换回String[]类型需要校正 </span></span><br><span class="line">strings = (String[]) sequences; </span><br><span class="line"><span class="comment">// 这是一个由字符串数组组成的数组 </span></span><br><span class="line">String[][] s = <span class="keyword">new</span> String[][] &#123; strings &#125;; </span><br><span class="line"><span class="comment">// 不能转换成CharSequence[]类型，因为String[]类型 </span></span><br><span class="line"><span class="comment">// 不能转换成CharSequence类型：维数不匹配 </span></span><br><span class="line"> </span><br><span class="line">sequences = s; <span class="comment">// 不会编译这行代码 </span></span><br><span class="line"><span class="comment">// s可以转换成Object类型或Object[]类型，因为所有数组类型 </span></span><br><span class="line"><span class="comment">// （包括String[]和String[][]类型）都能转换成Object类型 </span></span><br><span class="line">Object[] objects = s;</span><br></pre></td></tr></table></figure><p>注意，这些数组转换规则只适用于由对象或数组组成的数组。基本类型的数组不能转换为任何其他数组类型，就算基本基类型之间能相互转换也不行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 就算int类型能放大转换成double类型 </span></span><br><span class="line"><span class="comment">// 也不能把int[]类型转换成double[]类型</span></span><br><span class="line"><span class="comment">// 这行代码会导致编译出错 </span></span><br><span class="line"><span class="keyword">double</span>[] data = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;; </span><br><span class="line"><span class="comment">// 但是，这行代码是合法的，因为int[]类型能转换成Object类型 </span></span><br><span class="line">Object[] objects = <span class="keyword">new</span> <span class="keyword">int</span>[][] &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><h2 id="修饰符总结"><a class="header-anchor" href="#修饰符总结"></a>修饰符总结</h2><h3 id="访问控制修饰符"><a class="header-anchor" href="#访问控制修饰符"></a>访问控制修饰符</h3><p>Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。</p><ol><li><p><code>default</code> (即默认，什么也不写）：在同一包内可见，不使用任何修饰符。可以使用的对象包括类、接口、变量和方法。</p></li><li><p><code>private</code> ：在同一类内可见。可以使用的对象包括变量和方法。 <strong>注意：不能修饰类（外部类）</strong></p></li><li><p><code>public</code>：对所有类可见。可以使用的对象包括类、接口、变量和方法</p></li><li><p><code>protected</code>： 对同一包内的类和所有子类可见。可以使用的对象包括变量和方法。 <strong>注意：不能修饰类（外部类）</strong>。</p></li></ol><h3 id="非访问修饰符"><a class="header-anchor" href="#非访问修饰符"></a>非访问修饰符</h3><p>为了实现一些其他的功能，Java 也提供了许多非访问修饰符。</p><ol><li><p><code>static</code> 修饰符：用来修饰类方法和类变量。</p><p>静态变量：<code>static</code> 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 <code>static</code> 变量。</p><p>静态方法：<code>static</code> 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。</p><blockquote><p>对类变量和方法的访问可以直接使用 classname.variablename 和 classname.methodname 的方式访问。</p></blockquote></li><li><p><code>final</code> 修饰符：用来修饰类、方法和变量，<code>final</code>修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。</p><p><code>final</code> 变量：<code>final</code> 表示“最后的、最终的”含义，变量一旦赋值后，不能被重新赋值。被 <code>final</code> 修饰的实例变量必须显式指定初始值。<code>final</code> 修饰符通常和 <code>static</code> 修饰符一起使用来创建类常量</p></li><li><p><code>abstract</code> 修饰符：用来创建抽象类和抽象方法。抽象类：抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。抽象类可以包含抽象方法和非抽象方法。方法可以通过使用保留词<code>void</code>作为返回类型来表明不会返回任何值。</p><p>一个类不能同时被 <code>abstract</code> 和 <code>final</code> 修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。</p></li><li><p><code>synchronized</code>和 <code>volatile</code>修饰符，主要用于线程的编程。</p></li></ol><h3 id="总结"><a class="header-anchor" href="#总结"></a>总结</h3><table><thead><tr><th>修饰符</th><th>用于</th><th>意义</th></tr></thead><tbody><tr><td><code>abstract</code></td><td>类</td><td>这个类不能实例化，而且可能包含未实现的方法</td></tr><tr><td></td><td>接口</td><td>所有接口都是抽象的。声明接口时这个修饰符是可选的</td></tr><tr><td></td><td>方法</td><td>这个方法没有主体，主体由子类提供。签名后面是一个分号。所在的类必须也是抽象的</td></tr><tr><td><code>default</code></td><td>方法</td><td>这个接口方法的实现是可选的。接口为不想实现这个方法的类提供了一个默认实现。</td></tr><tr><td><code>final</code></td><td>类</td><td>不能创建这个类的子类</td></tr><tr><td></td><td>方法</td><td>不能覆盖这个方法</td></tr><tr><td></td><td>字段</td><td>这个字段的值不能改变。<code>static final</code> 修饰的字段是编译时常量</td></tr><tr><td></td><td>变量</td><td>值不能改变的局部变量、方法参数或异常参数</td></tr><tr><td><code>native</code></td><td>方法</td><td>这个方法使用某种与平台无关的方式实现（经常使用 C 语言）。没有提供主体，签名后面是一个分号</td></tr><tr><td>无（包）</td><td>类</td><td>没声明为 public 的类只能在包中访问</td></tr><tr><td></td><td>接口</td><td>没声明为 public 的接口只能在包中访问</td></tr><tr><td></td><td>成员</td><td>没声明为 private、protected 或 public 的成员具有包可见性，只能在包中访问</td></tr><tr><td><code>private</code></td><td>成员</td><td>这个成员只在定义它的类中可以访问</td></tr><tr><td><code>protected</code></td><td>成员</td><td>这个成员只在定义它的包中和子类中可以访问</td></tr><tr><td><code>public</code></td><td>类</td><td>能访问所在包的地方都能访问这个类</td></tr><tr><td></td><td>接口</td><td>能访问所在包的地方都能访问这个接口</td></tr><tr><td></td><td>成员</td><td>能访问所在类的地方都能访问这个成员</td></tr><tr><td><code>strictfp</code></td><td>类</td><td>这个类中的所有方法都隐式声明为 <code>strictfp</code></td></tr><tr><td></td><td>方法</td><td>这个方法必须使用严格遵守 IEEE 754 标准的方式执行浮点运算。具体而言，所有数值，包括中间结果，都要使用 IEEEfloat 或 double 类型表示，而且不能利用本地平台浮点格式或硬件提供的额外精度或取值范围。这个修饰符极少使用</td></tr><tr><td><code>static</code></td><td>类</td><td>使用 <code>static</code> 声明的内部类是顶层类，而不是所在类的成员。</td></tr><tr><td></td><td>方法</td><td><code>static</code> 方法是类方法。不隐式传入 <code>this</code> 对象引用。可通过类名调用</td></tr><tr><td></td><td>字段</td><td><code>static</code> 字段是类字段。不管创建多少类实例，这个字段都只有一个实例。可通过类名访问</td></tr><tr><td></td><td>初始化程序</td><td>这个初始化程序在加载类时运行，而不是创建实例时运行</td></tr><tr><td><code>synchronized</code></td><td>方法</td><td>这个方法对类或实例执行非原子操作，所以必须小心，确保不能让两个线程同时修改类或实例。对 <code>static</code> 方法来说，执行方法之前先为类获取一个锁。对非 static 方法来说，会为具体的对象实例获取一个锁。</td></tr><tr><td><code>transient</code></td><td>字段</td><td>这个字段不是对象持久化状态的一部分，因此不会随对象一起序列化。在对象序列化时使用，参见 <code>java.io.ObjectOutputStream</code></td></tr><tr><td><code>volatile</code></td><td>字段</td><td>这个字段能被异步线程访问，因此必须对其做些特定的优化。这个修饰符有时可以替代 <code>synchronized</code>。</td></tr></tbody></table><h2 id="面向对象编程（OOP）"><a class="header-anchor" href="#面向对象编程（OOP）"></a>面向对象编程（OOP）</h2><ul><li>对管理人员，它实现了更快和更廉价的开发与维护过程。</li><li>对分析 与设计人员，建模处理变得更加简单，能生成清晰、易于维护的设计方案。</li><li>对程序员，对象模型显得如此高雅和浅显。</li></ul><p>基本特征：</p><ul><li>所有东西都是对象。可将对象想象成一种新型变量；它保存着数据，但可要求它对自身进行操作。理论上讲，可从要解决的问题身上提出所有概念性的组件，然后在程序中将其表达为一个对象。</li><li>程序是一大堆对象的组合；通过消息传递，各对象知道自己该做些什么。为了向对象发出请求，需向那个对象“发送一条消息”。更具体地讲，可将消息想象为一个调用请求，它调用的是从属于目标对象的一个子例程或函数。</li><li>每个对象都有自己的存储空间，可容纳其他对象。或者说，通过封装现有对象，可制作出新型对象。所以，尽管对象的概念非常简单，但在程序中却可达到任意高的复杂程度。</li><li>每个对象都有一种类型。根据语法，每个对象都是某个“类”的一个“实例”。其中，“类”（Class）是“类型”（Type）的同义词。一个类最重要的特征就是“能将什么消息发给它？”。</li><li>同一类所有对象都能接收相同的消息。由于类型为“圆”（Circle）的一个对象也属于类型为“形状”（Shape）的一个对象，所以一个圆完全能接收形状消息。这意味着可让程序代码统一指挥“形状”，令其自动控制所有符合“形状”描述的对象，其中自然包括“圆”。这一特性称为对象的“可替换性”，是OOP最重要的概念之一。</li></ul><h3 id="面向对象和面向过程的区别"><a class="header-anchor" href="#面向对象和面向过程的区别"></a><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md">面向对象和面向过程的区别</a></h3><ul><li><p><strong>面向过程</strong> ：<strong>面向过程性能比面向对象高。</strong> 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发。但是，<strong>面向过程没有面向对象易维护、易复用、易扩展。</strong></p></li><li><p><strong>面向对象</strong> ：<strong>面向对象易维护、易复用、易扩展。</strong> 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，<strong>面向对象性能比面向过程低</strong>。</p><blockquote><p>面向过程 ：面向过程性能比面向对象高。 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发。</p><p>这个并不是根本原因，面向过程也需要分配内存，计算内存偏移量，Java性能差的主要原因并不是因为它是面向对象语言，而是Java是半编译语言，最终的执行代码并不是可以直接被CPU执行的二进制机械码。</p><p>而面向过程语言大多都是直接编译成机械码在电脑上执行，并且其它一些面向过程的脚本语言性能也并不一定比Java好。</p></blockquote></li></ul><p>Java是一种面向对象的编程语言。面向对象编程，英文是Object-Oriented Programming，简称OOP。</p><p>那什么是面向对象编程？</p><p>和面向对象编程不同的，是面向过程编程。面向过程编程，是把模型分解成一步一步的过程。比如，老板告诉你，要编写一个TODO任务，必须按照以下步骤一步一步来：</p><ol><li>读取文件；</li><li>编写TODO；</li><li>保存文件。</li></ol><p>而面向对象编程，顾名思义，你得首先有个对象：</p><p>有了对象后，就可以和对象进行互动：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GirlFriend gf = <span class="keyword">new</span> GirlFriend();</span><br><span class="line">gf.name = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">gf.send(<span class="string">&quot;flowers&quot;</span>);</span><br></pre></td></tr></table></figure><p>因此，面向对象编程，是一种通过对象的方式，把现实世界映射到计算机模型的一种编程方法。</p><h2 id="内存的分配"><a class="header-anchor" href="#内存的分配"></a>内存的分配</h2><p>有六个地方可以保存数据：</p><ul><li>寄存器。这是最快的保存区域，因为它位于和其他所有保存方式不同的地方：处理器内部。然而，寄存器的数量十分有限，所以寄存器是根据需要由编译器分配。我们对此没有直接的控制权，也不可能在自己的程序里找到寄存器存在的任何踪迹</li><li>堆栈。驻留于常规 RAM（随机访问存储器）区域，但可通过它的“堆栈指针”获得处理的直接支持。堆栈指针若向下移，会创建新的内存；若向上移，则会释放那些内存。这是一种特别快、特别有效的数据保存方式，仅次于寄存器。创建程序时，Java编译器必须准确地知道堆栈内保存的所有数据的“长度”以及“存在时间”。这是由于它必须生成相应的代码，以便向上和向下移动指针。这一限制无疑影响了程序的灵活性，所以尽管有些 Java数据要保存在堆栈里——特别是对象句柄，但Java对象并不放到其中</li><li>堆。一种常规用途的内存池（也在 RAM区域），其中保存了Java对象。和堆栈不同，“内存堆”或“堆”（Heap）最吸引人的地方在于编译器不必知道要从堆里分配多少存储空间，也不必知道存储的数据要<br>在堆里停留多长的时间。因此，用堆保存数据时会得到更大的灵活性。要求创建一个对象时，只需用new命令编制相关的代码即可。执行这些代码时，会在堆里自动进行数据的保存。当然，为达到这种灵活性，必然会付出一定的代价：在堆里分配存储空间时会花掉更长的时间！</li><li>静态存储。这儿的“静态”（Static）是指“位于固定位置”（尽管也在 RAM里）。程序运行期间，静态存储的数据将随时等候调用。可用static关键字指出一个对象的特定元素是静态的。但 Java对象本身永远都不会置入静态存储空间。</li><li>常数存储。常数值通常直接置于程序代码内部。这样做是安全的，因为它们永远都不会改变。有的常数需要严格地保护，所以可考虑将它们置入只读存储器（ROM）。</li><li>非 RAM存储。若数据完全独立于一个程序之外，则程序不运行时仍可存在，并在程序的控制范围之外。其中两个最主要的例子便是“流式对象”和“固定对象”。对于流式对象，对象会变成字节流，通常会发给另一台机器。而对于固定对象，对象保存在磁盘中。即使程序中止运行，它们仍可保持自己的状态不变。对于这些类型的数据存储，一个特别有用的技巧就是它们能存在于其他媒体中。一旦需要，甚至能将它们恢复成普通的、基于RAM的对象。</li></ul><h2 id="面向对象基础"><a class="header-anchor" href="#面向对象基础"></a>面向对象基础</h2><p>面向对象编程，是一种通过对象的方式，把现实世界映射到计算机模型的一种编程方法。</p><p>现实世界中，我们定义了“人”这种抽象概念，而具体的人则是“小明”、“小红”、“小军”等一个个具体的人。所以，“人”可以定义为一个类（class），而具体的人则是实例（instance）：</p><table><thead><tr><th style="text-align:left">现实世界</th><th style="text-align:left">计算机模型</th><th style="text-align:left">Java代码</th></tr></thead><tbody><tr><td style="text-align:left">人</td><td style="text-align:left">类 / class</td><td style="text-align:left"><code>class Person &#123; &#125;</code></td></tr><tr><td style="text-align:left">小明</td><td style="text-align:left">实例 / ming</td><td style="text-align:left"><code>Person ming = new Person()</code></td></tr><tr><td style="text-align:left">小红</td><td style="text-align:left">实例 / hong</td><td style="text-align:left"><code>Person hong = new Person()</code></td></tr><tr><td style="text-align:left">小军</td><td style="text-align:left">实例 / jun</td><td style="text-align:left"><code>Person jun = new Person()</code></td></tr></tbody></table><p>同样的，“书”也是一种抽象的概念，所以它是类，而《Java核心技术》、《Java编程思想》、《Java学习笔记》则是实例：</p><table><thead><tr><th style="text-align:left">现实世界</th><th style="text-align:left">计算机模型</th><th style="text-align:left">Java代码</th></tr></thead><tbody><tr><td style="text-align:left">书</td><td style="text-align:left">类 / class</td><td style="text-align:left"><code>class Book &#123; &#125;</code></td></tr><tr><td style="text-align:left">Java核心技术</td><td style="text-align:left">实例 / book1</td><td style="text-align:left"><code>Book book1 = new Book()</code></td></tr><tr><td style="text-align:left">Java编程思想</td><td style="text-align:left">实例 / book2</td><td style="text-align:left"><code>Book book2 = new Book()</code></td></tr><tr><td style="text-align:left">Java学习笔记</td><td style="text-align:left">实例 / book3</td><td style="text-align:left"><code>Book book3 = new Book()</code></td></tr></tbody></table><h4 id="class和instance"><a class="header-anchor" href="#class和instance"></a>class和instance</h4><p>所以，只要理解了class和instance的概念，基本上就明白了什么是面向对象编程。</p><p>class是一种对象模版，它定义了如何创建实例，因此，class本身就是一种数据类型</p><p>而instance是对象实例，instance是根据class创建的实例，可以创建多个instance，每个instance类型相同，但各自属性可能不相同</p><h4 id="定义class"><a class="header-anchor" href="#定义class"></a>定义class</h4><p>在Java中，创建一个类，例如，给这个类命名为<code>Person</code>，就是定义一个<code>class</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个<code>class</code>可以包含多个字段（<code>field</code>），字段用来描述一个类的特征。上面的<code>Person</code>类，我们定义了两个字段，一个是<code>String</code>类型的字段，命名为<code>name</code>，一个是<code>int</code>类型的字段，命名为<code>age</code>。因此，通过<code>class</code>，把一组数据汇集到一个对象上，实现了数据封装。</p><p><code>public</code>是用来修饰字段的，它表示这个字段可以被外部访问。</p><p>我们再看另一个<code>Book</code>类的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String author;</span><br><span class="line">    <span class="keyword">public</span> String isbn;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建实例"><a class="header-anchor" href="#创建实例"></a>创建实例</h4><p>定义了class，只是定义了对象模版，而要根据对象模版创建出真正的对象实例，必须用new操作符。</p><p>new操作符可以创建一个实例，然后，我们需要定义一个引用类型的变量来指向这个实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person ming = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure><p>上述代码创建了一个Person类型的实例，并通过变量<code>ming</code>指向它。</p><p>注意区分<code>Person ming</code>是定义<code>Person</code>类型的变量<code>ming</code>，而<code>new Person()</code>是创建<code>Person</code>实例。</p><p>有了指向这个实例的变量，我们就可以通过这个变量来操作实例。访问实例变量可以用<code>变量.字段</code>，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ming.name = <span class="string">&quot;Xiao Ming&quot;</span>; <span class="comment">// 对字段name赋值</span></span><br><span class="line">ming.age = <span class="number">12</span>; <span class="comment">// 对字段age赋值</span></span><br><span class="line">System.out.println(ming.name); <span class="comment">// 访问字段name</span></span><br><span class="line"></span><br><span class="line">Person hong = <span class="keyword">new</span> Person();</span><br><span class="line">hong.name = <span class="string">&quot;Xiao Hong&quot;</span>;</span><br><span class="line">hong.age = <span class="number">15</span>;</span><br></pre></td></tr></table></figure><p>上述两个变量分别指向两个不同的实例，它们在内存中的结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">            ┌──────────────────┐</span><br><span class="line">ming ──────&gt;│Person instance   │</span><br><span class="line">            ├──────────────────┤</span><br><span class="line">            │name &#x3D; &quot;Xiao Ming&quot;│</span><br><span class="line">            │age &#x3D; 12          │</span><br><span class="line">            └──────────────────┘</span><br><span class="line">            ┌──────────────────┐</span><br><span class="line">hong ──────&gt;│Person instance   │</span><br><span class="line">            ├──────────────────┤</span><br><span class="line">            │name &#x3D; &quot;Xiao Hong&quot;│</span><br><span class="line">            │age &#x3D; 15          │</span><br><span class="line">            └──────────────────┘</span><br></pre></td></tr></table></figure><p>两个<code>instance</code>拥有<code>class</code>定义的<code>name</code>和<code>age</code>字段，且各自都有一份独立的数据，互不干扰。</p><h2 id="方法的性质"><a class="header-anchor" href="#方法的性质"></a>方法的性质</h2><h4 id="方法的参数按值传递"><a class="header-anchor" href="#方法的参数按值传递"></a>方法的参数按值传递</h4><p>在方法中参数变量的使用方法和局部变量相同，唯一不同的是参数变量的初始值是由调用方提供的。方法处理的是参数的值，而非参数本身。这种方式产生的结果是在静态方法中改变一个参数变量的值对调用者没有影响。本书中我们一般不会修改参数变量。值传递也意味着数组参数将会是原数组的别名（见 1.1.5.4 节）——方法中使用的参数变量能够引用调用者的数组并改变其内容（只是不能改变原数组变量本身）。例如，Arrays.sort() 将能够改变通过参数传递的数组的内容，将其排序。</p><h4 id="方法名可以被重载"><a class="header-anchor" href="#方法名可以被重载"></a>方法名可以被重载</h4><p>例如，Java 的 Math 包使用这种方法为所有的原始数值类型实现了Math.abs()、Math.min() 和 Math.max() 函数。重载的另一种常见用法是为函数定义两个版本，其中一个需要一个参数而另一个则为该参数提供一个默认值。</p><h4 id="方法只能返回一个值，但可以包含多个返回语句"><a class="header-anchor" href="#方法只能返回一个值，但可以包含多个返回语句"></a>方法只能返回一个值，但可以包含多个返回语句</h4><p>一个 Java 方法只能返回一个值，它的类型是方法签名中声明的类型。静态方法第一次执行到一条返回语句时控制权将会回到调用代码中。尽管可能存在多条返回语句，任何静态方法每次都只会返回一个值，即被执行的第一条返回语句的参数。</p><h4 id="方法可以产生副作用"><a class="header-anchor" href="#方法可以产生副作用"></a>方法可以产生副作用</h4><p>方法的返回值可以是 void，这表示该方法没有返回值。返回值为void 的静态函数不需要明确的返回语句，方法的最后一条语句执行完毕后控制权将会返回给调用方。我们称 void 类型的静态方法会产生副作用（接受输入、产生输出、修改数组或者改变系统状态）。例如，我们的程序中的静态方法 main() 的返回值就是 void，因为它的作用是向外输出。技术上来说，数学方法的返回值都不会是 void（Math.random() 虽然不接受参数但也有返回值）</p><h2 id="静态方法，-static关键字"><a class="header-anchor" href="#静态方法，-static关键字"></a>静态方法， static关键字</h2><p>通常，我们创建类时会指出那个类的对象的外观与行为。除非用new创建那个类的一个对象，否则实际上并未得到任何东西。只有执行了 new后，才会正式生成数据存储空间，并可使用相应的方法。但在两种特殊的情形下，上述方法并不堪用。</p><ul><li>一种情形是只想用一个存储区域来保存一个特定的数据——无论要创建多少个对象，甚至根本不创建对象。</li><li>另一种情形是我们需要一个特殊的方法，它没有与这个类的任何对象关联。也就是说，即使没有创建对象，也需要一个能调用的方法。</li></ul><p>为满足这两方面的要求，可使用static（静态）关键字。</p><p>这些方法由出现在public或private关键词之后的static关键词标识。方法封装了由一系列语句所描述的运算。</p><p>方法需要参数（某种数据类型的值）并根据参数计算出某种数据类型的返回值（例如数学函数的结果）或者产生某种副作用（例如打印一个值）。</p><p><img src="http://img.whl123456.top/image/%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90.png" alt="静态方法解析"></p><h4 id="典型静态方法的实现"><a class="header-anchor" href="#典型静态方法的实现"></a>典型静态方法的实现</h4><p>计算一个整数的绝对值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="keyword">return</span> -x;</span><br><span class="line">    <span class="keyword">else</span>       <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算一个浮点数的绝对值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">abs</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0.0</span>) <span class="keyword">return</span> -x;</span><br><span class="line">    <span class="keyword">else</span>         <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判定一个数是否是素数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (N &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i*i &lt;= N; i++)</span><br><span class="line">        <span class="keyword">if</span> (N % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算平方根（牛顿迭代法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">double</span> c)</span></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (c &lt; <span class="number">0</span>) <span class="keyword">return</span> Double.NaN;</span><br><span class="line">    <span class="keyword">double</span> err = <span class="number">1e-15</span>;</span><br><span class="line">    <span class="keyword">double</span> t = c;</span><br><span class="line">    <span class="keyword">while</span> (Math.abs(t - c/t) &gt; err * t)</span><br><span class="line">        t = (c/t + t) / <span class="number">2.0</span>;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算直角三角形的斜边</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">hypotenuse</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Math.sqrt(a*a + b*b); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算调和级数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">H</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123; </span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        sum += <span class="number">1.0</span> / i;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>五十音图</title>
      <link href="2020/02/27/%E4%BA%94%E5%8D%81%E9%9F%B3%E5%9B%BE/"/>
      <url>2020/02/27/%E4%BA%94%E5%8D%81%E9%9F%B3%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>五十音图</p><hr><h2 id="五十音"><a class="header-anchor" href="#五十音"></a>五十音</h2><table><thead><tr><th>あ　ア（a）</th><th>い　イ（i）</th><th>う　ウ（u）</th><th>え　エ（e）</th><th>お　オ（o）</th></tr></thead><tbody><tr><td>か　カ（ka）</td><td>き　キ（ki）</td><td>く　ク（ku）</td><td>け　ケ（ke）</td><td>こ　コ（ko）</td></tr><tr><td>さ　サ（sa）</td><td>し　シ（shi）</td><td>す　ス（su）</td><td>せ　セ（se）</td><td>そ　ソ（so）</td></tr><tr><td>た　タ（ta）</td><td>ち　チ（chi）</td><td>つ　ツ（tsu）</td><td>て　テ（te）</td><td>と　ト（to）</td></tr><tr><td>な　ナ（na）</td><td>に　ニ（ni）</td><td>ぬ　ヌ（nu）</td><td>ね　ネ（ne）</td><td>の　ノ（no）</td></tr><tr><td>は　ハ（ha）</td><td>ひ　ヒ（hi）</td><td>ふ　フ（fu）</td><td>へ　ヘ（he）</td><td>ほ　ホ（ho）</td></tr><tr><td>ま　マ（ma）</td><td>み　ミ（mi）</td><td>む　ム（mu）</td><td>め　メ（me）</td><td>も　モ（mo）</td></tr><tr><td>や　ヤ（ya）</td><td></td><td>ゆ　ユ（yu）</td><td></td><td>よ　ヨ（yo）</td></tr><tr><td>ら　ラ（ra）</td><td>り　リ（ri）</td><td>る　ル（ru）</td><td>れ　レ（re）</td><td>ろ　ロ（ro）</td></tr><tr><td>わ　ワ（wa）</td><td></td><td></td><td></td><td>を　ヲ（o）</td></tr><tr><td>ん　ン（n）</td><td></td><td></td><td></td><td></td></tr></tbody></table><h2 id="浊音"><a class="header-anchor" href="#浊音"></a>浊音</h2><table><thead><tr><th>が　ガ（ga）</th><th>ぎ　ギ（gi）</th><th>ぐ　グ（gu）</th><th>げ　ゲ（ge）</th><th>ご　ゴ（go）</th></tr></thead><tbody><tr><td>ざ　ザ（za）</td><td>じ　ジ（ji）</td><td>ず　ズ（zu）</td><td>ぜ　ゼ（ze）</td><td>ぞ　ゾ（zo）</td></tr><tr><td>だ　ダ（da）</td><td>ぢ　ヂ（ji）</td><td>づ　ヅ（zu）</td><td>で　デ（ze）</td><td>ど　ド（do）</td></tr><tr><td>ば　バ（ba）</td><td>び　ビ（bi）</td><td>ぶ　ブ（bu）</td><td>べ　ベ（be）</td><td>ぼ　ボ（bo）</td></tr><tr><td>ぱ　パ（pa）</td><td>ぴ　ピ（pi）</td><td>ぷ　プ（pu）</td><td>ぺ　ペ（pe）</td><td>ぽ　ポ（po）</td></tr></tbody></table><h2 id="拗音"><a class="header-anchor" href="#拗音"></a>拗音</h2><table><thead><tr><th>きゃ　キャ（kya）</th><th>きゅ　キュ（kyu）</th><th>きょ　キョ（kyo）</th></tr></thead><tbody><tr><td>しゃ　シャ（sha）</td><td>しゅ　シュ（shu）</td><td>しょ　ショ（sho）</td></tr><tr><td>ちゃ　チャ（cha）</td><td>ちゅ　チュ（chu）</td><td>ちょ　チョ（cho）</td></tr><tr><td>にゃ　ニャ（nya）</td><td>にゃ　チャ（nyu）</td><td>にょ　ニョ（nyo）</td></tr><tr><td>ひゃ　ひゃ（hya）</td><td>ひゃ　ヒュ（hyu）</td><td>ひょ　ヒョ（gyo）</td></tr><tr><td>みゃ　ミャ（mya）</td><td>みゅ　ミュ（myu）</td><td>みょ　ミョ（myo）</td></tr><tr><td>りゃ　リャ（rya）</td><td>りゅ　リュ（ryu）</td><td>りょ　リョ（ryo）</td></tr><tr><td>ぎゃ　ギャ（gya）</td><td>ぎゅ　ギュ（gyu）</td><td>ぎょ　ギョ（gyo）</td></tr><tr><td>じゃ　ジャ（ja）</td><td>じゅ　ジュ（ju）</td><td>じょ　ジョ（jo）</td></tr><tr><td>びゃ　ビャ（bya）</td><td>びゅ　ビュ（byu）</td><td>びょ　ビョ（byo）</td></tr><tr><td>ぴゃ　ぴゃ（pya）</td><td>ぴゅ　ピュ（pyu）</td><td>ぴょ　ピョ（pyo）</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 日语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习笔记</title>
      <link href="2020/01/03/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2020/01/03/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>用于记录Linux学习过程,基于CentOS</p><hr><h2 id="Linux简单介绍"><a class="header-anchor" href="#Linux简单介绍"></a>Linux简单介绍</h2><p>Linux可划分为以下四个部分：</p><ul><li>Linux内核：主要负责系统内存管理、软件程序管理、硬件设备管理和文件系统管理四种功能</li><li>GNU工具：</li><li>图形化桌面环境</li><li>应用软件</li></ul><p><img src="http://img.whl123456.top/image/Linux.png" alt="Linux系统"></p><h3 id="内存管理系统"><a class="header-anchor" href="#内存管理系统"></a>内存管理系统</h3><p>Linux内核不仅管理服务器上的可用物理内存，还可以创建和管理虚拟内存。</p><p>内核通过硬盘上的存储空间来实现虚拟内存，这块区域称为<strong>交换空间</strong>（swap space）。</p><p>内存存储单元按组划分成很多块，这些块称作页面（page）。内核将每个内存页面放在物理 内存或交换空间。然后，内核会维护一个内存页面表，指明哪些页面位于物理内存内，哪些页面被换到了磁盘上。</p><p>内核会记录哪些内存页面正在使用中，并自动把一段时间未访问的内存页面复制到交换空间区域（称为换出，swapping out）——即使还有可用内存。当程序要访问一个已被换出的内存页面时，内核必须从物理内存换出另外一个内存页面给它让出空间，然后从交换空间换入请求的内存页面。显然，这个过程要花费时间，拖慢运行中的进程。只要Linux系统在运行，为运行中的程序换出内存页面的过程就不会停歇。</p><h3 id="软件程序管理"><a class="header-anchor" href="#软件程序管理"></a>软件程序管理</h3><p>Linux操作系统将运行中的程序称为<strong>进程</strong>。内核控制着Linux系统如何管理运行在系统上的所有进程。</p><p>内核创建了第一个进程（称为init进程）来启动系统上所有其他进程。</p><blockquote><p>脚本通过到/etc/init.d目录下的入口启动</p></blockquote><p>当内核启动时，它会将init进程加载到虚拟内存中。内核在启动任何其他进程时，都会在虚拟内存中给新进程分配一 块专有区域来存储该进程用到的数据和代码。</p><h3 id="硬件设备管理"><a class="header-anchor" href="#硬件设备管理"></a>硬件设备管理</h3><p>任何Linux系统需要与之通信的设备，都需要在内核代码中加入其驱动程序代码。驱动程序代码相当于应用程序和硬件设备的中间人，允许内核与设备之间交换数据。</p><p>在Linux内核中有两种方法用于插入设备驱动代码：</p><ul><li>编译进内核的设备驱动代码</li><li>可插入内核的设备驱动模块</li></ul><p>开发人员提出了内核模块的概念。它允许将驱动代码插入到运行中的内核而无需重新编译内 核。</p><p>Linux系统将硬件设备当成特殊的文件，称为设备文件。设备文件有3种分类：</p><ul><li>字符型设备文件</li><li>块设备文件</li><li>网络设备文件</li></ul><p>字符型设备文件是指处理数据时每次只能处理一个字符的设备。大多数类型的调制解调器和终端都是作为字符型设备文件创建的。</p><p>块设备文件是指处理数据时每次能处理大块数据的设备，比如硬盘。</p><p>网络设备文件是指采用数据包发送和接收数据的设备，包括各种网卡和一个特殊的回环设备。这个回环设备允许Linux系统使用常见的网络编程协议同自身通信。</p><p>Linux为系统上的每个设备都创建一种称为<strong>节点</strong>的特殊文件。与设备的所有通信都通过设备节点完成。每个节点都有唯一的数值对供Linux内核标识它。数值对包括一个主设备号和一个次设备号。类似的设备被划分到同样的主设备号下。次设备号用于标识主设备组下的某个特定设备。</p><h3 id="文件系统管理"><a class="header-anchor" href="#文件系统管理"></a>文件系统管理</h3><p><img src="http://img.whl123456.top/image/image-20200611200821228.png" alt="Linux文件系统"></p><h2 id="注意事项"><a class="header-anchor" href="#注意事项"></a>注意事项</h2><ul><li><p>Linux严格区分大小写</p></li><li><p>Linux中所有的内容以文件形式保存，包括硬件</p></li><li><p>Linux不靠扩展名区分文件类型，基于权限</p><blockquote><p>压缩包：.gz、.bz2、.tar.bz2、.tgz<br>二进制包：.rpm<br>脚本文件：.sh<br>配置文件：.conf</p></blockquote></li><li><p>设备需要挂载后才能使用</p></li><li><p>Linux使用正斜线（\）在文件路径中划分目录，反斜线（/）用来标志转义字符</p></li></ul><h2 id="Linux各目录的作用"><a class="header-anchor" href="#Linux各目录的作用"></a>Linux各目录的作用</h2><ul><li>/bin/：存放系统命令目录，所有用户都可以执行</li><li>/sbin/：只有root可以设置</li><li>/usr/bin/：存放与系统启动无关的命令，单用户下无法执行</li><li>/usr/sbin/：只有root可以设置</li><li>/boot/：系统启动目录，保存系统相关的文件</li><li>/dev/：设备保存位置</li><li>/etc/：配置文件保存位置</li><li>/home/：普通用户目录</li><li>/lib/：系统调用的函数库</li><li>/opt/：第三方安装的软件保存位置，习惯把软件放置到/usr/local/</li><li>/lost+found/：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件</li><li>/root/：该目录为系统管理员，也称作超级权限者的用户主目录。</li><li>/proc/：虚拟文件系统，设备状态信息，数据保存在内存中</li><li>/sys/：保存内核相关信息</li><li>/root/：超级用户</li><li>/srv/：服务数据目录</li><li>/tmp/：临时目录，可以清空</li><li>/usr/：系统软件资源目录</li><li>/var/：动态数据保存位置，日志，软件运行产生的文件</li></ul><h2 id="Linux常用命令"><a class="header-anchor" href="#Linux常用命令"></a>Linux常用命令</h2><p>命令格式：命令 [-选项]  [参数]</p><h3 id="目录处理"><a class="header-anchor" href="#目录处理"></a>目录处理</h3><ol><li><p>显示目录文件：<code>ls</code></p><p>命令英文原意：list</p><ul><li><code>-a</code> 显示所有文件，包括隐藏文件</li><li><code>-l</code> 显示详情信息[h]人性化显示（可以直接使用<code>ll</code>）</li><li><code>-d</code> 查看目录属性</li><li><code>-i</code> 文件ID号</li></ul><blockquote><p>-rw-r–r–</p><p>第1个“-”文件类型包括：-二进制文件，d目录，l软连接文件</p><p>第2-4个所有者</p><p>第5-7个所属组</p><p>第8-10个其他人</p><p>r读、w写、x执行</p></blockquote></li><li><p>创建目录：<code>mkdir</code><br>命令英文原意：make directories</p><ul><li><code>-p</code> 递归创建</li></ul></li><li><p>切换目录：<code>cd</code></p><p>命令英文原意：change directory</p></li><li><p>查看当前目录：<code>pwd</code></p></li><li><p>删除空目录：<code>rmdir</code><br>命令英文原意：remove empty directories</p></li><li><p>复制文件或目录：<code>cp</code><br>命令英文原意：copy</p><ul><li><code>-rp</code>[原目录] [目标目录]</li><li><code>-r</code> 复制目录</li><li><code>-p</code> 保留文件属性</li></ul></li><li><p>剪切或改名文件：<code>mv</code><br>命令英文原意：move</p><ul><li>mv [原目录] [目标目录]</li></ul></li><li><p>删除文件：<code>rm</code><br>命令英文原意：remove</p><ul><li><code>-r</code> 删除目录</li><li><code>-f</code> 强制删除</li></ul></li></ol><h3 id="文件处理"><a class="header-anchor" href="#文件处理"></a>文件处理</h3><ol><li>创建空文件：<code>touch</code></li><li>显示文件内容：<code>cat</code> ；<code>tac</code>（反向展示）[-n]</li><li>分页显示文件内容：more；less<ul><li>空格或f翻页</li><li>回车换行</li><li>q退出</li><li>less b向上翻页</li><li>less 查找n</li></ul></li><li>显示文件前几行：<code>head</code> [-n]指定行数</li><li>显示文件后几行：<code>tail</code> [-f] 查看动态变化[-n]</li></ol><h3 id="链接命令"><a class="header-anchor" href="#链接命令"></a>链接命令</h3><p>生成链接文件：<code>ln</code>（link）[-s]创建软链接</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>脚注测试页</title>
      <link href="2019/12/25/%E8%84%9A%E6%B3%A8%E6%B5%8B%E8%AF%95%E9%A1%B5/"/>
      <url>2019/12/25/%E8%84%9A%E6%B3%A8%E6%B5%8B%E8%AF%95%E9%A1%B5/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a class="header-anchor" href="#Quick-Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a class="header-anchor" href="#Create-a-new-post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a class="header-anchor" href="#Run-server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a><br>使用 Markdown<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>可以效率的书写文档, 直接转换成 HTML, 你可以使用 Typora<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup> 编辑器进行书写。</p><p>使用 Markdown<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>可以效率的书写文档, 直接转换成 HTML<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>, 你可以使用 Typora<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup> 编辑器进行书写。</p><h3 id="Generate-static-files"><a class="header-anchor" href="#Generate-static-files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a class="header-anchor" href="#Deploy-to-remote-sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>Markdown是一种纯文本标记语言 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>NEW WAY TO READ &amp; WRITE MARKDOWN. <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p>Markdown是一种纯文本标记语言 <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p>HyperText Markup Language 超文本标记语言 <a href="#fnref4" class="footnote-backref">↩︎</a></p></li><li id="fn5" class="footnote-item"><p>NEW WAY TO READ &amp; WRITE MARKDOWN. <a href="#fnref5" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码高亮测试</title>
      <link href="2019/12/21/%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE%E6%B5%8B%E8%AF%95/"/>
      <url>2019/12/21/%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">puts <span class="string">&quot;Hello World!&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Hello World!\n God Bless You!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.write(<span class="string">&#x27;Hello, World&#x27;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> (<span class="string">&quot;Hello, World&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象</title>
      <link href="2019/10/18/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>2019/10/18/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p>面向对象</p><hr><p><img src="https://puui.qpic.cn/fans_admin/0/3_1409075683_1572055659163/0" alt=""></p><h2 id="面向对象有关概念"><a class="header-anchor" href="#面向对象有关概念"></a>面向对象有关概念</h2><ul><li><p><strong>类(Class)</strong>： 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。</p></li><li><p><strong>方法</strong>：类中定义的函数。</p></li><li><p><strong>类变量</strong>：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。</p></li><li><p><strong>数据成员</strong>：类变量或者实例变量用于处理类及其实例对象的相关的数据。</p></li><li><p><strong>方法重写</strong>：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。</p></li><li><p><strong>局部变量</strong>：定义在方法中的变量，只作用于当前实例的类。</p></li><li><p><strong>实例变量</strong>：在类的声明中，属性是用变量来表示的。这种变量就称为实例变量，是在类声明的内部但是在类的其他成员方法之外声明的。</p></li><li><p><strong>继承</strong>：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟&quot;是一个（is-a）&quot;关系（例图，Dog是一个Animal）。</p></li><li><p><strong>实例化</strong>：创建一个类的实例，类的具体对象。</p></li><li><p><strong>对象</strong>：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。</p></li></ul><h3 id="类和实例"><a class="header-anchor" href="#类和实例"></a>类和实例</h3><p>面向对象最重要的概念就是类（Class）和实例（Instance）</p><p>类是抽象的模板，比如Student类</p><p>实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，各个实例拥有的数据都互相独立，互不影响</p><p>方法就是与实例绑定的函数，和普通函数不同，方法可以直接访问实例的数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个Dog类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age</span>):</span><span class="comment"># 写进属性,第一个参数是self</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.ages = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 类中定义的函数,第一个参数永远是实例变量self,并且调用时不用传递该参数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_ages</span>(<span class="params">self, ages</span>):</span></span><br><span class="line">        self.ages = ages</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sit</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(self.name.title()+<span class="string">&quot; is now sitting.&quot;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">roll_over</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(self.name.title()+<span class="string">&quot; rolled over!&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="数据封装"><a class="header-anchor" href="#数据封装"></a>数据封装</h3><p>面向对象编程的一个重要特点就是数据封装。</p><p>封装数据的函数是和类本身是关联起来的,称之为类的方法</p><h3 id="访问限制"><a class="header-anchor" href="#访问限制"></a>访问限制</h3><p>如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__，在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实例化类</span></span><br><span class="line">my_dog = Dog(<span class="string">&quot;Willie&quot;</span>, <span class="number">6</span>)</span><br><span class="line">my_dog.ages = <span class="number">7</span> <span class="comment"># 直接修改属性值</span></span><br><span class="line">my_dog.update_ages(<span class="number">8</span>) <span class="comment"># 通过方法修改属性值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My dog&#x27;s name is &quot;</span> + my_dog.name.title() + <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My dog is &quot;</span> + <span class="built_in">str</span>(my_dog.age) + <span class="string">&quot; years old.&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My dog is &quot;</span> + <span class="built_in">str</span>(my_dog.ages) + <span class="string">&quot; years old.&quot;</span>)</span><br><span class="line">my_dog.sit()</span><br><span class="line">my_dog.roll_over()</span><br></pre></td></tr></table></figure><h3 id="继承"><a class="header-anchor" href="#继承"></a>继承</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wolf</span>(<span class="params">Dog</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(name, age)</span><br><span class="line">        self.ears = <span class="string">&#x27;long&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sit</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(self.name.title() + <span class="string">&quot; don&#x27;t sit&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_wolf = Wolf(<span class="string">&#x27;wolf&#x27;</span>, <span class="number">123</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My wolf&#x27;s name is &quot;</span> + my_wolf.name.title() + <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My wolf is &quot;</span> + <span class="built_in">str</span>(my_wolf.age) + <span class="string">&quot; years old.&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My wolf is &quot;</span> + <span class="built_in">str</span>(my_wolf.ages) + <span class="string">&quot; years old.&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(my_wolf.ears)</span><br><span class="line">my_wolf.sit()</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    My wolf&#x27;s name is Wolf.</span></span><br><span class="line"><span class="string">    My wolf is 123 years old.</span></span><br><span class="line"><span class="string">    My wolf is 0 years old.</span></span><br><span class="line"><span class="string">    long</span></span><br><span class="line"><span class="string">    Wolf don&#x27;t sit</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数式编程</title>
      <link href="2019/10/01/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
      <url>2019/10/01/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！</p><hr><p><img src="https://pic.superbed.cn/item/5db3aa6e8b58bc7bf718ef58.jpg" alt=""></p><h2 id="高阶函数"><a class="header-anchor" href="#高阶函数"></a>高阶函数</h2><h3 id="变量可以指向函数"><a class="header-anchor" href="#变量可以指向函数"></a>变量可以指向函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="built_in">abs</span>(-<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(x) <span class="comment"># 10</span></span><br><span class="line">f = <span class="built_in">abs</span></span><br><span class="line"><span class="built_in">print</span>(s) <span class="comment"># &lt;built-in function abs&gt;</span></span><br></pre></td></tr></table></figure><p>结论：函数本身也可以赋值给变量，即：变量可以指向函数。</p><h3 id="map-reduce"><a class="header-anchor" href="#map-reduce"></a>map()/reduce()</h3><p><code>map()</code>函数接收两个参数，一个是函数，一个是<code>Iterable</code>(可迭代对象)，<code>map</code>将传入的函数依次作用到序列的每个元素，并把结果作为新的<code>Iterator</code>返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line">r = <span class="built_in">map</span>(f, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(r)) <span class="comment"># [1, 4, 9, 16, 25, 36, 49, 64, 81]</span></span><br></pre></td></tr></table></figure><p><code>reduce</code>把一个函数作用在一个序列<code>[x1, x2, x3, ...]</code>上，这个函数必须接收两个参数，<code>reduce</code>把结果继续和序列的下一个元素做累积计算，其效果就是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</span><br></pre></td></tr></table></figure><h3 id="filter"><a class="header-anchor" href="#filter"></a>filter()</h3><p>和<code>map()</code>类似，<code>filter()</code>也接收一个函数和一个序列。和<code>map()</code>不同的是，<code>filter()</code>把传入的函数依次作用于每个元素，然后根据返回值是<code>True</code>还是<code>False</code>决定保留还是丢弃该元素。</p><h3 id="sorted"><a class="header-anchor" href="#sorted"></a>sorted()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sorted</span>([<span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;about&#x27;</span>, <span class="string">&#x27;Zoo&#x27;</span>, <span class="string">&#x27;Credit&#x27;</span>], key=<span class="built_in">str</span>.lower)</span><br></pre></td></tr></table></figure><h3 id="返回函数"><a class="header-anchor" href="#返回函数"></a>返回函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span>():</span></span><br><span class="line">    fs = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span>():</span></span><br><span class="line">             <span class="keyword">return</span> i*i</span><br><span class="line">        fs.append(f)</span><br><span class="line">    <span class="keyword">return</span> fs</span><br><span class="line"></span><br><span class="line">f1, f2, f3 = count()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">j</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">g</span>():</span></span><br><span class="line">            <span class="keyword">return</span> j*j</span><br><span class="line">        <span class="keyword">return</span> g</span><br><span class="line">    fs = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">        fs.append(f(i)) <span class="comment"># f(i)立刻被执行，因此i的当前值被传入f()</span></span><br><span class="line">    <span class="keyword">return</span> fs</span><br><span class="line"> f1, f2, f3 = count()</span><br></pre></td></tr></table></figure><h3 id="匿名函数"><a class="header-anchor" href="#匿名函数"></a>匿名函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x * x, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]))</span><br></pre></td></tr></table></figure><h3 id="装饰器"><a class="header-anchor" href="#装饰器"></a>装饰器</h3><p>由于函数也是一个对象，而且函数对象可以被赋值给变量，所以，通过变量也能调用该函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">now</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;2015-3-25&#x27;</span>)</span><br><span class="line">f = now</span><br><span class="line">f() <span class="comment"># 2015-3-25</span></span><br></pre></td></tr></table></figure><p>函数对象有一个<code>__name__</code>属性，可以拿到函数的名字：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">now.__name__</span><br><span class="line"><span class="string">&#x27;now&#x27;</span></span><br><span class="line">f.__name__</span><br><span class="line"><span class="string">&#x27;now&#x27;</span></span><br></pre></td></tr></table></figure><p>现在，假设我们要增强<code>now()</code>函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改<code>now()</code>函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kw</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;call %s():&#x27;</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"><span class="meta">@log</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">now</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;2015-3-25&#x27;</span>)</span><br><span class="line"></span><br><span class="line">now()</span><br><span class="line"><span class="comment"># call now():</span></span><br><span class="line"><span class="comment"># 2015-3-25</span></span><br></pre></td></tr></table></figure><p>把<code>@log</code>放到<code>now()</code>函数的定义处，相当于执行了语句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">now = log(now)</span><br></pre></td></tr></table></figure><p>由于<code>log()</code>是一个decorator，返回一个函数，所以，原来的<code>now()</code>函数仍然存在，只是现在同名的<code>now</code>变量指向了新的函数，于是调用<code>now()</code>将执行新函数，即在<code>log()</code>函数中返回的<code>wrapper()</code>函数。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二级Python基础</title>
      <link href="2019/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BA%8C%E7%BA%A7Python%E5%9F%BA%E7%A1%80/"/>
      <url>2019/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BA%8C%E7%BA%A7Python%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>参考<a href="https://github.com/Xanxus-5/NCRE-Python">Xanxus-5/NCRE-Python</a></p><hr><p><img src="https://puui.qpic.cn/fans_admin/0/3_1409075683_1572058823439/0" alt=""></p><h2 id="程序设计基本方法"><a class="header-anchor" href="#程序设计基本方法"></a>程序设计基本方法</h2><h3 id="程序设计语言概述"><a class="header-anchor" href="#程序设计语言概述"></a>程序设计语言概述</h3><ul><li>程序设计语言是计算机能够理解和识别用户操作意图的一种交互体系，它按照特定规则组织计算机指令，使计算机能够自动进行各种运算处理。</li><li>按照程序设计语言规则组织起来的一组计算机指令称为计算机程序.</li><li>高级编程语言根据执行机制不同可分成两类：<strong>静态语言</strong>和<strong>脚本语言</strong>，静态语言采用编译方式执行，脚本语言采用解释方式执行。例如，C语言是静 态语言，Python语言是脚本语言。</li><li>采用<strong>编译执行的编程语言是静态语言</strong>，如C语言、Java语言；<strong>采用解释执行的编程语言是脚本语言</strong>，如JavaScript语言、PHP语言<ul><li><p><strong>编译</strong>是将源代码转换成目标代码的过程，通常，源代码是高级语言代码，目标代码是机器语言代码，执行编译的计算机程序称为编译器</p><blockquote><p>对于相同源代码，编译所产生的目标代码执行速度更快。</p><p>目标代码不需要编译器就可以运行，在同类型操作系统上使用灵活。</p></blockquote></li><li><p><strong>解释</strong>是将源代码逐条转换成目标代码同时逐条运行目标代码的过程。执行解释的计算机程序称为解释器。</p><blockquote><p>解释执行需要保留源代码，程序纠错和维护十分方便。</p><p>只要存在解释器，源代码可以在任何操作系统上运行，可移植性好</p></blockquote></li></ul></li></ul><h3 id="计算机编程"><a class="header-anchor" href="#计算机编程"></a>计算机编程</h3><p>计算思维是区别于以数学为代表的逻辑思维和以物理为代表的实证思维的第三种思维模式。</p><p>编程是一个求解问题的过程</p><ul><li>首先需要分析问题，抽象内容之间的交互关系</li><li>设计利用计算机求解问题的确定性方法，</li><li>进而通过编写和调试代码解决问题</li></ul><p>这是从抽象问题到解决问题的完整过程。</p><h3 id="程序的基本编写方法"><a class="header-anchor" href="#程序的基本编写方法"></a>程序的基本编写方法</h3><p>IPO程序编写方法</p><ul><li><p>输入数据</p><p>输入（Input）是一个程序的开始。程序要处理的数据有多种来源，形成了多种输入方式，包括：文件输入、网络输入、控制台输入、交互界面输出、随机数据输入、内部参数输入等。</p></li><li><p>处理数据</p><p>处理（Process）是程序对输入数据进行计算产生输出结果的过程。计算问题的处理方法统称为“算法”，它是程序最重要的组成部分。可以说，算法是一个程序的灵魂。</p></li><li><p>输出数据</p><p>输出（Output）是程序展示运算成果的方式。程序的输出方式包括：控制台输出、图形输出、文件输出、网络输出、操作系统内部变量输出等。</p></li></ul><h3 id="Python语言概述"><a class="header-anchor" href="#Python语言概述"></a>Python语言概述</h3><p>Python重要特点：</p><ol><li><p>具有通用性；</p><p>Python语言可以用于几乎任何与程序设计相关应用的开发，不仅适合训练变成思维，更适合诸如数据分析、机器学习、人工智能、Web开发等具体的技术领域。</p></li><li><p>语法简洁；</p><p>只有33个保留字</p></li><li><p>生态高产；</p><p>Python解释器提供了几百个内置类和函数库，此外，世界各地程序员通过开源社区贡献了十几万个第三方函数库，几乎覆盖了计算机技术的各个领域，编写Python程序可以大量利用已有内置或第三方代码，具备良好的编程生态。</p></li></ol><p>具体特点：</p><ol><li><p>平台无关；</p><p>Python程序可以在任何安装解释器的计算机环境中执行，因此，可以不经修改地实现跨操作系统运行。</p></li><li><p>强制可续；</p><p>Python通过强制缩进（类似文章段落的首行空格）来体现语句间的逻辑关系，显著提高了程序的可读性，进而增强了Python程序的可维护性。</p></li><li><p>支持中文；</p></li><li><p>格式多样；</p></li><li><p>类库便捷；</p></li><li><p>开源理念；</p></li></ol><h3 id="实例"><a class="header-anchor" href="#实例"></a>实例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#斐波那契数列(F(n) = F(n-2) + F(n-1)）, n &gt;= 2)</span></span><br><span class="line">a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> a &lt; <span class="number">1000</span> :</span><br><span class="line">    <span class="built_in">print</span>(a, end = <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">a, b = b, a + b</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#计算圆半径</span></span><br><span class="line">r = <span class="number">25</span></span><br><span class="line">area = <span class="number">3.1415</span> * r * r</span><br><span class="line"><span class="built_in">print</span>(area)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;:.2f&#125;&#x27;</span>.<span class="built_in">format</span>(area)) <span class="comment">#两位小数</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#绘制五角星</span></span><br><span class="line"><span class="keyword">from</span> turtle <span class="keyword">import</span> *</span><br><span class="line">color(<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">begin_fill()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    fd(<span class="number">200</span>)</span><br><span class="line">    rt(<span class="number">144</span>)</span><br><span class="line">end_fill()</span><br><span class="line">done()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#程序运行计时</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">limit = <span class="number">10</span> * <span class="number">1000</span> * <span class="number">1000</span></span><br><span class="line">start = time.perf_counter()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    limit -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> limit &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">delta = time.perf.counter() - start</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;时间是:&#123;&#125;秒&#x27;</span>.<span class="built_in">format</span>(delta))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#绘制七种圆圈</span></span><br><span class="line"><span class="keyword">import</span> turtle</span><br><span class="line">colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;indigo&#x27;</span>, <span class="string">&#x27;purple&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    c = color[i]</span><br><span class="line">    turtle.color(c.c)</span><br><span class="line">    turtle.begin_fill()</span><br><span class="line">    turtle.rt(<span class="number">360</span>/<span class="number">7</span>)</span><br><span class="line">    turtle.circle(<span class="number">50</span>)</span><br><span class="line">    turtle.end_fill()</span><br><span class="line">turtle.done()</span><br></pre></td></tr></table></figure><h2 id="Python基本语法元素"><a class="header-anchor" href="#Python基本语法元素"></a>Python基本语法元素</h2><h3 id="语法元素的名称"><a class="header-anchor" href="#语法元素的名称"></a>语法元素的名称</h3><p><strong>缩进</strong>：表示程序的逻辑。指每行语句开始前的空白局域，用来表示Python程序之间的<strong>包含和层次关系</strong>。1个缩进 = 4个空格。缩进是Python语言中<strong>表明程序框架的唯一手段</strong>。</p><p><strong>注释</strong>：注释是代码中的辅助性文字，<strong>会被编译或解释器略去，不被计算机执行</strong>，一般用于程序员对代码的说明。Python语言采用#表示一行注释的开始，多行注释需要在每行开始都使用#。</p><p><strong>变量</strong>：可以随时命名、赋值、使用。</p><p><strong>命名</strong>：Python语言允许采用大写字母、小写字母、数字、下划线(_)和汉字等字符及其组合给变量命名，但名字的首字符不能是数字，中间不能出现空格，长度没有限制，标识符对大小写敏感。</p><p>保留字（keyword）：</p><table><thead><tr><th style="text-align:center">and</th><th style="text-align:center">as</th><th style="text-align:center">assert</th><th style="text-align:center">break</th><th style="text-align:center">class</th><th style="text-align:center">continue</th></tr></thead><tbody><tr><td style="text-align:center">def</td><td style="text-align:center">del</td><td style="text-align:center">elif</td><td style="text-align:center">else</td><td style="text-align:center">except</td><td style="text-align:center">False</td></tr><tr><td style="text-align:center">finally</td><td style="text-align:center">for</td><td style="text-align:center">from</td><td style="text-align:center">global</td><td style="text-align:center">if</td><td style="text-align:center">import</td></tr><tr><td style="text-align:center">in</td><td style="text-align:center">is</td><td style="text-align:center">lambda</td><td style="text-align:center">None</td><td style="text-align:center">nonlocal</td><td style="text-align:center">not</td></tr><tr><td style="text-align:center">or</td><td style="text-align:center">pass</td><td style="text-align:center">return</td><td style="text-align:center">True</td><td style="text-align:center">try</td><td style="text-align:center">while</td></tr><tr><td style="text-align:center">with</td><td style="text-align:center">yield</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><h3 id="数据类型"><a class="header-anchor" href="#数据类型"></a>数据类型</h3><p>Python语言支持多种数据类型，最简单的包括数字类型、字符串类型，略微复杂的包括元组类型、集合类型、列表类型、字典类型等。</p><p><strong>数字类型</strong>：整数、浮点数、复数</p><p>一个整数值可以表示为十进制、十六进制、八进制和二进制等不同进制形式。</p><ul><li>二进制： 0b001111110010</li><li>八进制： 0o1762</li><li>十进制： 1010</li><li>十六进制：0x3F2</li></ul><p>一个浮点数可以表示为带有小数点的一般形式，也可以采用科学计数法表示。例如：浮点数123.456，两种表示方式如下：</p><ul><li>一般形式： 123.456</li><li>科学计数法： 1.23456e2</li></ul><p>复数类型与数学中的复数相一致，采用a+bj的形式表示，存在实部和虚部。</p><p><strong>字符串</strong>：双引号与单引号作用相同</p><p><strong>切片</strong>：[N : M]格式获取字符串的子串（从N到M但不包含M）。</p><p><img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BA%8C%E7%BA%A7Python%E5%9F%BA%E7%A1%80/1568883436400.png" alt="1568883436400"></p><p><strong>如果字符串长度为L，正向递增需要以最左侧字符序号为0，向右依次递增，最右侧字符序号为L-1；</strong></p><p><strong>反向递减序号以最右侧字符序号为-1，向左依次递减，最左侧字符序号为-L。</strong></p><p>可以通过Python默认提供的<code>len()</code>函数获取字符串的长度，一个中文字符和西文字符的长度都记为1</p><h3 id="程序的语句元素"><a class="header-anchor" href="#程序的语句元素"></a>程序的语句元素</h3><p><strong>表达式</strong>:产生或计算新数据值的代码片段称为表达式。</p><p><strong>赋值语句</strong>：&lt;变量&gt; = &lt;表达式&gt;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 变量x和y交换</span></span><br><span class="line">t = x</span><br><span class="line">x = y</span><br><span class="line">y = t</span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">x, y = y, x</span><br></pre></td></tr></table></figure><p><strong>引用</strong>：</p><p>python程序会经常使用当前程序之外已有的功能代码，这个过程叫“引用”。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &lt;库名称&gt;</span><br><span class="line"><span class="comment"># 调用具体功能</span></span><br><span class="line">&lt;库名称&gt;.&lt;函数名称&gt;()</span><br></pre></td></tr></table></figure><h3 id="基本输入输出函数"><a class="header-anchor" href="#基本输入输出函数"></a>基本输入输出函数</h3><p><code>input()</code>:获得用户输入</p><p><code>&lt;变量&gt; = input(&quot;&lt;提示性文字&gt;&quot;)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">input</span>(<span class="string">&#x27;请输入：&#x27;</span>)</span><br><span class="line"><span class="comment"># &gt;请输入: X</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># &gt;X</span></span><br></pre></td></tr></table></figure><p><code>eval()</code>：去掉字符串最外侧的引号。</p><p>以Python表达式的方式解析并执行字符串，将返回结果输出</p><p><code>&lt;变量&gt; = eval(&quot;&lt;字符串&gt;&quot;)</code></p><p><code>print()</code>：用于输出运算结果</p><ol><li><p>仅输出：<code>print('&lt;字符串&gt;')</code>；</p></li><li><p>仅输出一个或多个变量：<code>print(&lt;变量1&gt;, &lt;变量2&gt;, ..., &lt;变量n&gt;)</code>；</p></li><li><p>混合：<code>print(&lt;输出字符串模板&gt;.format(&lt;变量1&gt;, &lt;变量2&gt;..., &lt;变量n&gt;)</code>。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a, b = <span class="number">3</span>, <span class="number">66</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;数字&#123;&#125;和数字&#123;&#125;的和是&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(a, b, a+b))</span><br><span class="line"><span class="comment"># &gt;数字3和数字66的和是69</span></span><br></pre></td></tr></table></figure></li><li><p>默认会在最后增加一个换行，或用：<code>print('&lt;内容&gt;', end = '&lt;结尾&gt;')</code></p></li></ol><h3 id="实例解析–倒背如流"><a class="header-anchor" href="#实例解析–倒背如流"></a>实例解析–倒背如流</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将输入字符反向输出</span></span><br><span class="line"><span class="comment"># 方法一</span></span><br><span class="line"><span class="comment"># 采用正向递增序号，利用len()函数将i设为最后一个字符的索引序号，然后逐次输出至第一个字符。</span></span><br><span class="line">s = <span class="built_in">input</span>(<span class="string">&quot;请输入一段文本：&quot;</span>)</span><br><span class="line">i = <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &gt;= <span class="number">0</span> :</span><br><span class="line">    <span class="built_in">print</span>(s[i], end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    i = i - <span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法二</span></span><br><span class="line"><span class="comment"># 采用反向递减序号，将i首先设置为-1，直接索引最后一个字符，然后逐次输出至第一个字符。</span></span><br><span class="line">s = <span class="built_in">input</span>(<span class="string">&quot;请输入一段文本：&quot;</span>)</span><br><span class="line">i = -<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &gt;= -<span class="number">1</span> * <span class="built_in">len</span>(s):</span><br><span class="line">    <span class="built_in">print</span>(s[i], end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    i = i - <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="⭐基本数据类型"><a class="header-anchor" href="#⭐基本数据类型"></a>⭐基本数据类型</h2><h3 id="⭐整数类型"><a class="header-anchor" href="#⭐整数类型"></a>⭐整数类型</h3><p>|   种类   | 引导符号 |                         描述                        |<br>|  :------:| :------: | :-------------------------------------------- —: |<br>|  十进制  |    无    |               默认情况，例：1010,-1010               |<br>|  二进制  | 0b 或 0B |          由字符0和1组成，例：0b1010，0B1010           |<br>|  八进制  | 0o 或 0O |          由字符0到7组成，例：0o1010，0O1010           |<br>| 十六进制 | 0x 或 0X |由字符0到9、a 到 f 或 A 到 F 组成，例：0x1010，0X1010  |</p><p>不同进制的整数可以<strong>直接运算</strong></p><h3 id="浮点数类型"><a class="header-anchor" href="#浮点数类型"></a>浮点数类型</h3><p>必须带有小数部分，小数可以是0。</p><p>除十进制外，浮点数没有其他进制表示形式</p><p>科学计算法使用字母 e 或 E 作为幂的符号，以10为基数</p><p>不确定尾数：两个浮点数运算，有一定概率在运算结果后增加一些不确定尾数</p><p><code>round()</code>函数：对字符串四舍五入。</p><p><code>round(1.2345, 2) = 1.23</code></p><h3 id="复数类型"><a class="header-anchor" href="#复数类型"></a>复数类型</h3><p>基本单位元素 j 或 J ,叫做“虚数单位”。含有虚数单位的数被称为复数</p><p>复数可以看作是二元有序实数对（a, b），表示 a + bj，a 是实数部分，b 是虚数部分。</p><p><strong>当 b 是1时，1不能省略，即’1j’表示复数</strong>而单独j则表示Python程序中的一个变量。</p><p>对于复数 z，可以用 <code>z.real</code> 和 <code>z.imag</code>分别获得它的实部和虚部</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>((<span class="number">1.23e4</span> + <span class="number">5.67e4j</span>).real ) <span class="comment"># 12300.0</span></span><br><span class="line"><span class="built_in">print</span>((<span class="number">1.23e4</span> + <span class="number">5.67e4j</span>).imag)  <span class="comment"># 56700.0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">1.23e4</span> + <span class="number">5.67e4j</span>.imag)    <span class="comment">#先获得5.67e4j的虚部，再与1.23e4进行求和计算 69000.0</span></span><br></pre></td></tr></table></figure><h3 id="数字类型的运算"><a class="header-anchor" href="#数字类型的运算"></a>数字类型的运算</h3><h4 id="运算操作符"><a class="header-anchor" href="#运算操作符"></a>运算操作符</h4><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">x + y</td><td style="text-align:center">和</td></tr><tr><td style="text-align:center">x - y</td><td style="text-align:center">差</td></tr><tr><td style="text-align:center">x * y</td><td style="text-align:center">积</td></tr><tr><td style="text-align:center">x / y</td><td style="text-align:center">商，产生结果为浮点数</td></tr><tr><td style="text-align:center">x // y</td><td style="text-align:center">整数商，即：不大于 x 与 y 之商的最打整数</td></tr><tr><td style="text-align:center">x % y</td><td style="text-align:center">商的余数，称为模运算</td></tr><tr><td style="text-align:center">-x</td><td style="text-align:center">负值，即 x * (-1)</td></tr><tr><td style="text-align:center">+x</td><td style="text-align:center">x本身</td></tr><tr><td style="text-align:center">x ** y</td><td style="text-align:center">x 的 y 次幂</td></tr></tbody></table><p>基本规则：</p><ul><li><p>整数和浮点数混合运算，输出结果是浮点数；</p></li><li><p>整数之间运算，产生结果类型与操作符相关，<code>/</code> 的结果是浮点数；</p></li><li><p>整数或浮点数与复数运算，输出结果是复数；</p></li></ul><p><strong>所有</strong>二元运算操作符都可以与赋值符号（=）相连，形成<strong>增强赋值操作符</strong>（+=，-=等）。用 ‘op’ 表示运算操作符，增强赋值操作符的用法如下：</p><p>x op= y 等价于 x = x op y，op 与 = 之间不用加空格</p><h4 id="数值运算函数"><a class="header-anchor" href="#数值运算函数"></a>数值运算函数</h4><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>abs(x)</code></td><td style="text-align:center">x的绝对值</td></tr><tr><td style="text-align:center"><code>divmod(x, y)</code></td><td style="text-align:center">(x // y, x % y)，输出为二元组形式（也称为元组类型）</td></tr><tr><td style="text-align:center"><code>pow(x, y[, z])</code></td><td style="text-align:center">x**y[(x **y) % z]，幂运算</td></tr><tr><td style="text-align:center"><code>round(x[, d])</code></td><td style="text-align:center">对 x 四舍五入，保留 d 位小数</td></tr><tr><td style="text-align:center"><code>max(a, b, c, d, ...)</code></td><td style="text-align:center">最大值</td></tr><tr><td style="text-align:center"><code>min(a, b, c, d, ...)</code></td><td style="text-align:center">最小值</td></tr></tbody></table><h3 id="字符串类型及格式化"><a class="header-anchor" href="#字符串类型及格式化"></a>字符串类型及格式化</h3><p>单行字符串可以由一对单引号或双引号作为边界表示<br>多行字符串可以由一对三单引号或三双引号作为边界表示</p><p>反斜杠字符（<code>\</code>）表示“转义”，即该字符与后面相邻的一个字符共同组成了新的含义。</p><ul><li><code>\n</code>：换行；</li><li><code>\\</code>：反斜杠</li><li><code>\'</code>表示单引号</li><li><code>\&quot;</code>表示双引号</li><li><code>\t</code>：制表符</li></ul><p><strong><code>\</code> 的额外作用：续行</strong></p><h4 id="format-方法的基本使用"><a class="header-anchor" href="#format-方法的基本使用"></a><code>format()</code>方法的基本使用</h4><p>字符串<code>format()</code>方法的基本使用格式是：<code>&lt;模板字符串&gt;.format(&lt;逗号分隔的参数&gt;)</code></p><p>模板字符串是一个由字符串和槽组成的字符，用来控制字符串和变量的显示效果</p><p><code>&#123;&lt;参数符号&gt;:&lt;格式控制标记&gt;&#125;</code></p><p><code>:</code>引导符号</p><p>格式控制标记包括：<code>&lt;填充&gt;</code>、<code>&lt;对齐&gt;</code>、<code>&lt;宽度&gt;</code>、<code>&lt;.(精度)&gt;</code>、<code>英文逗号</code>、<code>&lt;类型&gt;</code>6个字段，这些字段都是可选的，可以组合使用</p><p><code>&lt;填充&gt;</code>、<code>&lt;对齐&gt;</code>和<code>&lt;宽度&gt;</code>主要用于对显示格式的规范。</p><ul><li><p><code>&lt;填充&gt;</code>:可以修改默认填充字符，填充字符只能有一个。</p></li><li><p><code>&lt;对齐&gt;</code>:<code>&lt;</code> 左对齐；<code>&gt;</code>右对齐；<code>^</code> 居中</p></li><li><p><code>&lt;宽度&gt;</code>:槽的设定输出宽度<br>宽度指当前槽的设定输出字符宽度，如果该槽参数实际值比宽度设定值大，则使用参数实际长度。如果该值的实际位数小于指定宽度，则按照对齐指定方式在宽度内对齐，默认以空格字符补充。</p></li><li><p><code>英文逗号</code>:数字的千位分隔符，适用于整数和浮点数<br><code>&lt;.精度&gt;</code> <code>&lt;类型&gt;</code>主要用于对数值本身的规范</p></li><li><p><code>&lt;.(精度)&gt;</code>:浮点数小数部分的精度或字符串的最大输出长度</p></li><li><p><code>&lt;类型&gt;</code>:整数类型：b, c, d, o, x, X；浮点数类型：e, E, f, %</p></li></ul><p>整数类型：</p><ul><li>b：输出整数的二进制方式；</li><li>c：输出整数对应的Unicode字符；</li><li>d：输出整数的十进制方式；</li><li>o：输出整数的八进制方式；</li><li>x：输出整数的小写十六进制方式；</li><li>X：输出整数的大写十六进制方式</li></ul><p>浮点类型：</p><ul><li>e：输出浮点数对应的小写字母e的指数形式；</li><li>E：输出浮点数对应的大写字母E的指数形式</li><li>f：输出浮点数的标准浮点形式；</li><li>%：输出浮点数的百分形式</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;:.2f&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">3.14159</span>)) <span class="comment">#输出小数后2位</span></span><br><span class="line"><span class="comment"># &#x27;3.14&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;:X&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">1010</span>)) <span class="comment">#输出十六进制形式</span></span><br><span class="line"><span class="comment"># &#x27;3F2&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;:.5&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;这是一个很长的字符串&#x27;</span>)) <span class="comment">#输出前5位</span></span><br><span class="line"><span class="comment"># &#x27;这是一个很&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;:-^10&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;PYTHON&#x27;</span>)) <span class="comment">#居中并以 - 填充</span></span><br><span class="line"><span class="comment"># &#x27;--PYTHON--&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="字符串类型的操作"><a class="header-anchor" href="#字符串类型的操作"></a>字符串类型的操作</h3><h4 id="字符串操作符"><a class="header-anchor" href="#字符串操作符"></a>字符串操作符</h4><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">x + y</td><td style="text-align:center">连接两个字符串 x 与 y</td></tr><tr><td style="text-align:center">x *n 或 n* x</td><td style="text-align:center">复制 n 次字符串 x</td></tr><tr><td style="text-align:center">x in s</td><td style="text-align:center">如果 x 是 s 的字符串，返回True，否则False</td></tr></tbody></table><h4 id="字符串处理函数"><a class="header-anchor" href="#字符串处理函数"></a>字符串处理函数</h4><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>len(x)</code></td><td style="text-align:center">返回 x 的长度，也可以返回其他组合数据类型的元素个数</td></tr><tr><td style="text-align:center"><code>str(x)</code></td><td style="text-align:center">返回任意类型 x 的字符串形式</td></tr><tr><td style="text-align:center"><code>chr(x)</code></td><td style="text-align:center">返回 Unicode 编码 x 对应的单字符</td></tr><tr><td style="text-align:center"><code>ord(x)</code></td><td style="text-align:center">返回单字符 x 表示的 Unicod 编码</td></tr><tr><td style="text-align:center"><code>hex(x)</code></td><td style="text-align:center">返回整数 x 对应十六进制的小写形式字符串</td></tr><tr><td style="text-align:center"><code>oct(x)</code></td><td style="text-align:center">返回整数 x 对应八进制的小写形式字符串</td></tr></tbody></table><h4 id="字符串处理方法"><a class="header-anchor" href="#字符串处理方法"></a>字符串处理方法</h4><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>str.lower(x)</code></td><td style="text-align:center">返回 str 全部小写</td></tr><tr><td style="text-align:center"><code>str.upper(x)</code></td><td style="text-align:center">返回 str 全部大写</td></tr><tr><td style="text-align:center"><code>str.split(sep = None)</code></td><td style="text-align:center">返回由 str 根据 sep 被分割构成的列表，默认以空格分割</td></tr><tr><td style="text-align:center"><code>str.count(sub)</code></td><td style="text-align:center">返回 sub 出现的次数</td></tr><tr><td style="text-align:center"><code>str.replace(old, new)</code></td><td style="text-align:center">返回 old 被替换为 new 的 str</td></tr><tr><td style="text-align:center"><code>str.center(width, fillchar)</code></td><td style="text-align:center">字符串居中函数，fillchar 可选，两侧新增字符采用fillchar填充</td></tr><tr><td style="text-align:center"><code>str.strip(chars)</code></td><td style="text-align:center">从 str 中去掉其左右 chars 中列出的字符</td></tr><tr><td style="text-align:center"><code>str.join(iter)</code></td><td style="text-align:center">将 iter 变量的每一个元素后增加一个 str</td></tr></tbody></table><p>例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Python is an excellent language.&#x27;</span>.replace(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;#&#x27;</span>))</span><br><span class="line"><span class="comment"># &#x27;Python is #n excellent l#ngu#ge.&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Python&#x27;</span>.center(<span class="number">20</span>, <span class="string">&#x27;=&#x27;</span>))</span><br><span class="line"><span class="comment"># &#x27;===Python===&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Python&#x27;</span>.center(<span class="number">2</span>, <span class="string">&#x27;=&#x27;</span>))</span><br><span class="line"><span class="comment"># &#x27;Python&#x27; #当 width 小于 str 长度，返回 str</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;   ==Python==   &#x27;</span>.strip(<span class="string">&#x27; =n&#x27;</span>))</span><br><span class="line"><span class="comment"># &#x27;Pytho&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;,&#x27;</span>.join(<span class="string">&#x27;12345&#x27;</span>))</span><br><span class="line"><span class="comment"># &#x27;1,2,3,4,5&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    str1 = <span class="string">&#x27;hello, world!&#x27;</span></span><br><span class="line">    str2 = <span class="string">&#x27;HeLLo, wOrld!&#x27;</span></span><br><span class="line">    <span class="comment"># 通过len函数计算字符串的长度</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(str1))  <span class="comment"># 13</span></span><br><span class="line">    <span class="comment"># 获得字符串首字母大写的copy</span></span><br><span class="line">    <span class="built_in">print</span>(str1.capitalize())  <span class="comment"># Hello, world!</span></span><br><span class="line">    <span class="comment"># 获得字符串变大写后的copy</span></span><br><span class="line">    <span class="built_in">print</span>(str1.title())  <span class="comment"># Hello, World!</span></span><br><span class="line">    <span class="built_in">print</span>(str2.title())  <span class="comment"># Hello, World!</span></span><br><span class="line">    <span class="comment"># 获得以首字母大写的方式显示每个单词后的copy</span></span><br><span class="line">    <span class="built_in">print</span>(str1.upper())  <span class="comment"># HELLO, WORLD!</span></span><br><span class="line">    <span class="built_in">print</span>(str2.lower())  <span class="comment"># hello, world!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    str1 = <span class="string">&#x27;hello, world!&#x27;</span></span><br><span class="line">    <span class="comment"># 从字符串中查找子串所在位置</span></span><br><span class="line">    <span class="built_in">print</span>(str1.find(<span class="string">&#x27;or&#x27;</span>))  <span class="comment"># 8</span></span><br><span class="line">    <span class="built_in">print</span>(str1.find(<span class="string">&#x27;shit&#x27;</span>))  <span class="comment"># -1</span></span><br><span class="line">    <span class="comment"># 与find类似但找不到子串时会引发异常</span></span><br><span class="line">    <span class="built_in">print</span>(str1.index(<span class="string">&#x27;or&#x27;</span>)) <span class="comment"># 8</span></span><br><span class="line">    <span class="built_in">print</span>(str1.index(<span class="string">&#x27;shit&#x27;</span>)) <span class="comment"># ValueError: substring not found</span></span><br><span class="line">    <span class="comment"># 检查字符串是否以指定的字符串开头</span></span><br><span class="line">    <span class="built_in">print</span>(str1.startswith(<span class="string">&#x27;He&#x27;</span>))  <span class="comment"># False</span></span><br><span class="line">    <span class="built_in">print</span>(str1.startswith(<span class="string">&#x27;hel&#x27;</span>))  <span class="comment"># True</span></span><br><span class="line">    <span class="comment"># 检查字符串是否以指定的字符串结尾</span></span><br><span class="line">    <span class="built_in">print</span>(str1.endswith(<span class="string">&#x27;!&#x27;</span>))  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    str1 = <span class="string">&#x27;hello, world!&#x27;</span></span><br><span class="line">    <span class="comment"># 将字符串以指定的宽度居中并在两侧填充指定的字符</span></span><br><span class="line">    <span class="built_in">print</span>(str1.center(<span class="number">50</span>, <span class="string">&#x27;*&#x27;</span>))</span><br><span class="line">    <span class="comment"># 将字符串以指定的宽度靠右放置左侧填充指定的字符</span></span><br><span class="line">    <span class="built_in">print</span>(str1.rjust(<span class="number">50</span>, <span class="string">&#x27; &#x27;</span>))</span><br><span class="line">    str3 = <span class="string">&#x27;abc123456&#x27;</span></span><br><span class="line">    <span class="comment"># 从字符串中取出指定位置的字符(下标运算)</span></span><br><span class="line">    <span class="built_in">print</span>(str3[<span class="number">2</span>])  <span class="comment"># c</span></span><br><span class="line">    <span class="comment"># 字符串切片(从指定的开始索引到指定的结束索引)</span></span><br><span class="line">    <span class="built_in">print</span>(str3[<span class="number">2</span>:<span class="number">5</span>])  <span class="comment"># c12</span></span><br><span class="line">    <span class="built_in">print</span>(str3[<span class="number">2</span>:])  <span class="comment"># c123456</span></span><br><span class="line">    <span class="built_in">print</span>(str3[<span class="number">2</span>::<span class="number">2</span>])  <span class="comment"># c246</span></span><br><span class="line">    <span class="built_in">print</span>(str3[::<span class="number">2</span>])  <span class="comment"># ac246</span></span><br><span class="line">    <span class="built_in">print</span>(str3[::-<span class="number">1</span>])  <span class="comment"># 654321cba</span></span><br><span class="line">    <span class="built_in">print</span>(str3[-<span class="number">3</span>:-<span class="number">1</span>])  <span class="comment"># 45</span></span><br><span class="line">    <span class="comment"># 检查字符串是否由数字构成</span></span><br><span class="line">    <span class="built_in">print</span>(str3.isdigit())  <span class="comment"># False</span></span><br><span class="line">    <span class="comment"># 检查字符串是否以字母构成</span></span><br><span class="line">    <span class="built_in">print</span>(str3.isalpha())  <span class="comment"># False</span></span><br><span class="line">    <span class="comment"># 检查字符串是否以数字和字母构成</span></span><br><span class="line">    <span class="built_in">print</span>(str3.isalnum())  <span class="comment"># True</span></span><br><span class="line">    str4 = <span class="string">&#x27;  hello, worl d   &#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(str4)</span><br><span class="line">    <span class="comment"># 获得字符串修剪空格的拷贝</span></span><br><span class="line">    <span class="built_in">print</span>(str4.strip())  <span class="comment"># &#x27;hello, worl d&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(str4.rstrip()) <span class="comment"># &#x27;  hello, worl d   &#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(str4.lstrip()) <span class="comment"># &#x27;hello, worl d   &#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h4 id="类型判断和类型间转换"><a class="header-anchor" href="#类型判断和类型间转换"></a>类型判断和类型间转换</h4><p><code>type(x)</code>：对 x 进行类型判断，适用于任何数据类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">eval</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入一个数字：&#x27;</span>))</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">type</span>(n) == <span class="built_in">type</span>(<span class="number">123</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;输入的是整数&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> <span class="built_in">type</span>(n) == <span class="built_in">type</span>(<span class="number">11.3</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;输入的是浮点数&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;无法判断&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>int(x)</code>：将 x 转为整数</p><p><code>float(x)</code>：将 x 转为浮点数</p><p><code>str(x)</code>：将 x 转为字符串</p><h3 id="实例解析–凯撒密码"><a class="header-anchor" href="#实例解析–凯撒密码"></a>实例解析–凯撒密码</h3><p>恺撒撒密码是古罗马恺撒大帝用来对军事情报进行加密的算法，它采用了替换方法对信息中的每一个英文字符循环替换为字母表序列该字符后面第三个字符：<br>原文：A B C D E F G H I J K L M N O P Q R S T U V W X Y Z<br>密文：D E F G H I J K L M N O P Q R S T U V W X Y Z A B C</p><p>原文字符P，其密文字符C满足如下条件：C = ( P + 3 ) mod 26</p><p>解密方法反之，满足：P = ( C – 3 ) mod 26</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 恺撒密码-加密</span></span><br><span class="line">ptxt = <span class="built_in">input</span>(<span class="string">&quot;请输入明文文本: &quot;</span>)</span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> ptxt:</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;a&quot;</span> &lt;= p &lt;= <span class="string">&quot;z&quot;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>)+(<span class="built_in">ord</span>(p)-<span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>)+<span class="number">3</span>)%<span class="number">26</span>), end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> <span class="string">&quot;A&quot;</span> &lt;= p &lt;= <span class="string">&quot;Z&quot;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="built_in">ord</span>(<span class="string">&quot;A&quot;</span>)+(<span class="built_in">ord</span>(p)-<span class="built_in">ord</span>(<span class="string">&quot;A&quot;</span>)+<span class="number">3</span>)%<span class="number">26</span>), end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(p, end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 恺撒密码-解密</span></span><br><span class="line">etxt = <span class="built_in">input</span>(<span class="string">&quot;请输入加密后文本: &quot;</span>)</span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> etxt:</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;a&quot;</span> &lt;= p &lt;= <span class="string">&quot;z&quot;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>)+(<span class="built_in">ord</span>(p)-<span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>)-<span class="number">3</span>)%<span class="number">26</span>), end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> <span class="string">&quot;A&quot;</span> &lt;= p &lt;= <span class="string">&quot;Z&quot;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="built_in">ord</span>(<span class="string">&quot;A&quot;</span>)+(<span class="built_in">ord</span>(p)-<span class="built_in">ord</span>(<span class="string">&quot;A&quot;</span>)-<span class="number">3</span>)%<span class="number">26</span>), end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(p, end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="程序的控制结构"><a class="header-anchor" href="#程序的控制结构"></a>程序的控制结构</h2><h3 id="程序流程图"><a class="header-anchor" href="#程序流程图"></a>程序流程图</h3><p>描述一个计算问题的程序过程有多种方式：IPO、流程图、伪代码和程序代码。</p><ul><li>起止框：表示程序逻辑的开始或结束；</li><li>判断框：表示一个判断条件，并根据判断结果选择不同的执行路径；</li><li>处理框：表示一组处理过程，对应于顺序执行的程序逻辑；</li><li>输入输出框：表示程序中的数据输入或结果输出；</li><li>注释框：表示程序的注释；</li><li>流向线：表示程序的控制流，以带箭头直线或曲线表达程序的执行路径；</li><li>连接点：表示多个流程图的连接方式，常用于将多个较小流程图组织成较大流程图。</li></ul><h3 id="程序控制结构"><a class="header-anchor" href="#程序控制结构"></a>程序控制结构</h3><p>三种基本结构：</p><ol><li>顺序结构：按照线性顺序依次执行；</li><li>分支结构：根据条件判断结果而选择不同向前执行路径；</li><li>循环结构：根据条件判断结果向后执行的一种运行方式。</li></ol><p>任何程序都由这三种基本结构组合而成</p><h3 id="单分支结构-if语句"><a class="header-anchor" href="#单分支结构-if语句"></a>单分支结构: if语句</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> &lt;条件&gt; :</span><br><span class="line">    &lt;语句块&gt;</span><br></pre></td></tr></table></figure><p>&lt;条件&gt;可一个或多个，用 and 与 or 连接多个条件。</p><h4 id="二分支结构-if-else语句"><a class="header-anchor" href="#二分支结构-if-else语句"></a>二分支结构: if-else语句</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> &lt;条件&gt; :</span><br><span class="line">    &lt;语句块<span class="number">1</span>&gt;</span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">    &lt;语句块<span class="number">2</span>&gt;</span><br></pre></td></tr></table></figure><p>更简洁的表达方式：适合&lt;语句块1&gt;和&lt;语句块2&gt;都只包含简单表达式的情况。</p><p><code>&lt;表达式1&gt; if &lt;条件&gt; else &lt;表达式2&gt;</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">eval</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入一个整数：&#x27;</span>))</span><br><span class="line">token = <span class="string">&#x27;&#x27;</span> <span class="keyword">if</span> s % <span class="number">3</span> == <span class="number">0</span> <span class="keyword">and</span> s % <span class="number">5</span> == <span class="number">0</span> <span class="keyword">else</span> <span class="string">&quot;不&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;这个数字&#123;&#125;能够同时被3和5整除。&#x27;</span>.<span class="built_in">format</span>(token))</span><br></pre></td></tr></table></figure><h4 id="多分支结构-if-elif-else语句"><a class="header-anchor" href="#多分支结构-if-elif-else语句"></a>多分支结构: if-elif-else语句</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> &lt;条件<span class="number">1</span>&gt; :</span><br><span class="line">    &lt;语句<span class="number">1</span>&gt;</span><br><span class="line"><span class="keyword">elif</span> &lt;条件<span class="number">2</span>&gt; :</span><br><span class="line">    &lt;语句<span class="number">2</span>&gt;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">    &lt;语句N&gt;</span><br></pre></td></tr></table></figure><p>按照多分支结构的代码顺序依次评估判断条件，寻找并执行第一个结果为 True 条件对应的语句块，然后跳过整个 if - elif -else 结构。（只有条件为 False 才会进入 elif）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">score = <span class="built_in">eval</span>(<span class="built_in">input</span>(<span class="string">&#x27;输入成绩：&#x27;</span>))</span><br><span class="line"><span class="keyword">if</span> score &gt;= <span class="number">90</span> :</span><br><span class="line">    grade = <span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="keyword">elif</span> score &gt;= <span class="number">80</span> :</span><br><span class="line">    grade = <span class="string">&#x27;B&#x27;</span></span><br><span class="line"><span class="keyword">elif</span> score &gt;= <span class="number">70</span> :</span><br><span class="line">    grade = <span class="string">&#x27;C&#x27;</span></span><br><span class="line"><span class="keyword">elif</span> score &gt;= <span class="number">60</span> :</span><br><span class="line">    grade = <span class="string">&#x27;D&#x27;</span></span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">    grade = <span class="string">&#x27;E&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;对应的等级是：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(grade))</span><br></pre></td></tr></table></figure><h3 id="判断条件及组合"><a class="header-anchor" href="#判断条件及组合"></a>判断条件及组合</h3><p>判断条件可以使用任何能够产生 True 或 False 的语句或函数</p><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:center">数学符号</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">&lt;</td><td style="text-align:center">&lt;</td><td style="text-align:center">小于</td></tr><tr><td style="text-align:center">&lt;=</td><td style="text-align:center">$\leq$</td><td style="text-align:center">小于等于</td></tr><tr><td style="text-align:center">&gt;=</td><td style="text-align:center">$\geq$</td><td style="text-align:center">大于等于</td></tr><tr><td style="text-align:center">&gt;</td><td style="text-align:center">&gt;</td><td style="text-align:center">大于</td></tr><tr><td style="text-align:center">==</td><td style="text-align:center">=</td><td style="text-align:center">等于</td></tr><tr><td style="text-align:center">!=</td><td style="text-align:center">$\neq$</td><td style="text-align:center">不等于</td></tr></tbody></table><p>Python 中，任何非零的数值、非空的数据类型都等价于 True，反之可以可直接用作判断条件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">0</span> == <span class="literal">False</span>)</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span> == <span class="literal">True</span>)</span><br><span class="line"><span class="comment"># False</span></span><br></pre></td></tr></table></figure><p>Python语言使用保留字not、and和or对条件进行逻辑运算或组合</p><p>not : 否；and : 与；or : 或</p><h3 id="程序的循环结构"><a class="header-anchor" href="#程序的循环结构"></a>程序的循环结构</h3><p>Python语言的循环结构包括两种：遍历循环和无限循环。</p><ul><li>遍历循环使用保留字<code>for</code>依次提取遍历结构各元素进行处理；</li><li>无限循环使用保留字<code>while</code>根据判断条件执行程序。</li></ul><h4 id="遍历循环-for"><a class="header-anchor" href="#遍历循环-for"></a>遍历循环: for</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &lt;循环变量&gt; <span class="keyword">in</span> &lt;遍历结构&gt; :</span><br><span class="line">    &lt;语句&gt;</span><br></pre></td></tr></table></figure><p>遍历结构可以是字符串、文件、<code>range()</code>函数或组合数据类型等。</p><p>字符串：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &lt;循环变量&gt; <span class="keyword">in</span> &lt;字符串&gt; :</span><br><span class="line">    &lt;语句块&gt;</span><br></pre></td></tr></table></figure><p><code>range()</code>函数：可以制定语句块的循环次数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &lt;循环变量&gt; <span class="keyword">in</span> <span class="built_in">range</span>(&lt;循环次数&gt;) :</span><br><span class="line">    &lt;语句块&gt;</span><br></pre></td></tr></table></figure><p>扩展模式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &lt;变量&gt; <span class="keyword">in</span> &lt;结构&gt; :</span><br><span class="line">    &lt;语句<span class="number">1</span>&gt;</span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">    &lt;语句<span class="number">2</span>&gt;</span><br></pre></td></tr></table></figure><p>当 for 循环正常结束后，程序会执行 else 语句。</p><p>else语句只在循环正常执行之后才执行并结束，因此，可以在&lt;语句块2&gt;中放置判断循环执行情况的语句。</p><h4 id="无限循环-while"><a class="header-anchor" href="#无限循环-while"></a>无限循环: while</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> &lt;条件&gt; :</span><br><span class="line">    &lt;语句块&gt;</span><br></pre></td></tr></table></figure><p>&lt;条件&gt;与 if 一样，结果为 True 或 False。</p><p>当判断条件为 True，执行循环体语句，结束后再次判断条件；当 False，循环终止，执行与 while 同级别缩进的后续语句。</p><p>else 扩展：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> &lt;条件&gt; :</span><br><span class="line">    &lt;语句<span class="number">1</span>&gt;</span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">    &lt;语句<span class="number">2</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="循环控制-break和continue"><a class="header-anchor" href="#循环控制-break和continue"></a>循环控制: break和continue</h4><p><code>break</code> : 用来跳出<strong>最内层</strong> for 或 while 循环，脱离后从循环后的代码继续执行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span> :</span><br><span class="line">    s = <span class="built_in">input</span>(<span class="string">&#x27;请输入名字(按Q退出)：&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">&#x27;Q&#x27;</span> :</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;输入的是：&#x27;</span>, s)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;程序退出&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>continue</code> : 结束当前当次循环，跳出循环体下面尚未执行的语句，但不跳出整个循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> <span class="string">&#x27;PYTHON&#x27;</span> :</span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">&#x27;Y&#x27;</span> :</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="built_in">print</span>(s, end = <span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>continue</code>语句和<code>break</code>语句的区别是：<code>continue</code>语句只结束本次循环，不终止整个循环的执行，而<code>break</code>具备结束循环的能力。</p><h3 id="程序的异常处理"><a class="header-anchor" href="#程序的异常处理"></a>程序的异常处理</h3><h4 id="try-except"><a class="header-anchor" href="#try-except"></a>try  except</h4><p>Python 用 try 和 except 进行异常处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> :</span><br><span class="line">    &lt;语句<span class="number">1</span>&gt;</span><br><span class="line"><span class="keyword">except</span> :</span><br><span class="line">    &lt;语句<span class="number">2</span>&gt;</span><br></pre></td></tr></table></figure><p>语句1是正常执行的程序内容，当执行这个语句发生异常时，则执行 except 后的语句2。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> :</span><br><span class="line">    n = <span class="built_in">eval</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入一个数字：&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;输入数字的3次方的值为：&#x27;</span>, n ** <span class="number">3</span>)</span><br><span class="line"><span class="keyword">except</span> :</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;输入错误，请输入一个数字！&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="实例解析——猜数字游戏"><a class="header-anchor" href="#实例解析——猜数字游戏"></a>实例解析——猜数字游戏</h3><p>编写一个“猜数字游戏”的程序，在1到1000之间随机产生一个数，然后请用户循环猜测这个数字，对于每个答案只回答“猜大了”或“猜小了”，直到猜测准确为止，输出用户的猜测次数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">target = random.randint(<span class="number">1</span>, <span class="number">1000</span>)</span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span> :</span><br><span class="line">    <span class="keyword">try</span> :</span><br><span class="line">        guess = <span class="built_in">eval</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入一个猜测的整数（1至1000）：&#x27;</span>))</span><br><span class="line">    <span class="keyword">except</span> :</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;输入有误，请重试。&#x27;</span>)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    count = count + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> guess &gt; target :</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;大了&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> guess &lt; target :</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;小了&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;猜对了&#x27;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;此轮的猜测次数是：&#x27;</span>, count)</span><br></pre></td></tr></table></figure><h2 id="函数和代码复用"><a class="header-anchor" href="#函数和代码复用"></a>函数和代码复用</h2><h3 id="函数的定义：def"><a class="header-anchor" href="#函数的定义：def"></a>函数的定义：def</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> &lt;函数名&gt;(<span class="params">&lt;参数列表&gt;</span>) :</span></span><br><span class="line">    &lt;函数体&gt;</span><br><span class="line">    <span class="keyword">return</span> &lt;返回值列表&gt;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact</span>(<span class="params">n</span>) :</span></span><br><span class="line">    s = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        s *= i</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"><span class="built_in">print</span> (fact(<span class="number">100</span>))</span><br></pre></td></tr></table></figure><p>使用步骤：</p><ol><li>函数定义；</li><li>函数调用；</li><li>函数执行；</li><li>函数返回</li></ol><h3 id="函数的参数传递"><a class="header-anchor" href="#函数的参数传递"></a>函数的参数传递</h3><h4 id="可选参数传递"><a class="header-anchor" href="#可选参数传递"></a>可选参数传递</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> &lt;函数名&gt;(<span class="params">&lt;非可选参数&gt;, &lt;可选参数&gt; = &lt;默认值&gt;</span>) :</span></span><br><span class="line">    &lt;函数体&gt;</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiply</span>(<span class="params">x, y = <span class="number">10</span></span>) :</span></span><br><span class="line">    <span class="built_in">print</span>(x * y)</span><br><span class="line">mulitply(<span class="number">99</span>)</span><br><span class="line"><span class="comment"># 990</span></span><br><span class="line">multiply(<span class="number">99</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 198</span></span><br></pre></td></tr></table></figure><h4 id="参数名称传递"><a class="header-anchor" href="#参数名称传递"></a>参数名称传递</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiply</span>(<span class="params">x, y = <span class="number">10</span></span>) :</span></span><br><span class="line">    <span class="built_in">print</span>(x * y)</span><br><span class="line">multiply(x = <span class="number">99</span>)</span><br><span class="line"><span class="comment"># 990</span></span><br><span class="line">multiply(y = <span class="number">2</span>, x = <span class="number">99</span>)</span><br><span class="line"><span class="comment"># 198</span></span><br></pre></td></tr></table></figure><p><strong>不需要保持参数传递的顺序，参数之间的顺序可以任意调整。</strong></p><h3 id="函数的返回值"><a class="header-anchor" href="#函数的返回值"></a>函数的返回值</h3><p><strong>⭐return 语句用来结束函数并将程序返回到函数被调用的位置继续执行。</strong></p><p>return语句可以出现在函数中的任何部分，同时可以将0个、1个或多个函数运算的结果返回给函数被调用处的变量。</p><h3 id="变量的作用域"><a class="header-anchor" href="#变量的作用域"></a>变量的作用域</h3><h4 id="局部变量"><a class="header-anchor" href="#局部变量"></a>局部变量</h4><p>在函数内部定义的变量，仅在函数内部有效，当函数退出时变量将不再存在。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">mul</span>(<span class="params">x, y = <span class="number">10</span></span>) :</span></span><br><span class="line">    z = x * y <span class="comment">#z是局部变量</span></span><br><span class="line">    <span class="keyword">return</span> z</span><br><span class="line">s = mul(<span class="number">99</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"><span class="comment"># 198</span></span><br><span class="line"><span class="built_in">print</span>(z)</span><br><span class="line"><span class="comment"># error : ...</span></span><br></pre></td></tr></table></figure><h4 id="全局变量"><a class="header-anchor" href="#全局变量"></a>全局变量</h4><p>在函数之外定义的变量，在程序执行全过程有效。全局变量在函数内部使用时，需提前使用 global 声明。<code>global &lt;全局变量&gt;</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">2</span> <span class="comment">#n是全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mul</span>(<span class="params">x, y = <span class="number">10</span></span>) :</span></span><br><span class="line">    <span class="keyword">global</span> n</span><br><span class="line">    <span class="keyword">return</span> x * y * n</span><br><span class="line">s = mul (<span class="number">99</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"><span class="number">396</span></span><br></pre></td></tr></table></figure><h3 id="代码复用"><a class="header-anchor" href="#代码复用"></a>代码复用</h3><p>好处：</p><ul><li>避免相同功能代码在被调用处重复编写；</li><li>当更新函数功能时，所有被调用处的功能都被更新。</li></ul><p>模块化设计：指通过函数的封装功能将程序划分为主程序、子程序和子程序间关系的表达。</p><p>模块化设计基本要求：</p><ul><li>紧耦合：尽可能合理划分功能块，功能块内部耦合紧密；</li><li>松耦合：模块间关系尽可能简单，功能块之间耦合度低。</li></ul><p>耦合性：指程序结构中各模块之间相互关联的程度，它取决于各模块间接口的复杂程度和调用方式。</p><ul><li>紧耦合：模块或系统间关系紧密，存在较多或复杂的相互调用。缺点：更新一个模块可能导致其他模块变化，复用较困难。</li><li>松耦合：一般基于消息或协议实现，系统间交互简单。</li></ul><h3 id="实例解析–软文的诗词风"><a class="header-anchor" href="#实例解析–软文的诗词风"></a>实例解析–软文的诗词风</h3><p>软文的诗词风将原有文章根据标点符号重新切分成短句并居中排版，对小屏幕阅读十分有利。使用程序将普通文章变成软文的诗词风十分有趣</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">txt = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">人生得意须尽欢，莫使金樽空对月。</span></span><br><span class="line"><span class="string">天生我材必有用，千金散尽还复来。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">linewidth = <span class="number">30</span>  <span class="comment"># 预定的输出宽度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lineSplit</span>(<span class="params">line</span>):</span></span><br><span class="line">    plist = [<span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27;!&#x27;</span>, <span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;，&#x27;</span>, <span class="string">&#x27;。&#x27;</span>, <span class="string">&#x27;！&#x27;</span>, <span class="string">&#x27;？&#x27;</span>]</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> plist:</span><br><span class="line">        line = line.replace(p, <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> line.split(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">linePrint</span>(<span class="params">line</span>):</span></span><br><span class="line">    <span class="keyword">global</span> linewidth</span><br><span class="line">    <span class="built_in">print</span>(line.center(linewidth, <span class="built_in">chr</span>(<span class="number">12288</span>)))</span><br><span class="line"></span><br><span class="line">newlines = lineSplit(txt)</span><br><span class="line"><span class="keyword">for</span> newline <span class="keyword">in</span> newlines:</span><br><span class="line">    linePrint(newline)</span><br></pre></td></tr></table></figure><h2 id="组合数据类型"><a class="header-anchor" href="#组合数据类型"></a>组合数据类型</h2><h3 id="组合数据类型基本概念"><a class="header-anchor" href="#组合数据类型基本概念"></a>组合数据类型基本概念</h3><p>能够表示多个数据的类型成为组合数据类型</p><ul><li>集合类型：元素集合，元素之间无序，相同元素在集合中唯一存在；</li><li>序列类型：元素向量，元素之间存在先后关系，通过序号访问，元素之间不排他；</li><li>映射类型：“键—值”数据项的组合，每个元素是一个键值对，表示为(key, value)。</li></ul><h4 id="集合类型概述"><a class="header-anchor" href="#集合类型概述"></a>集合类型概述</h4><p>包含0个或多个数据的无序组合，用大括号({})表示，集合中的元素可以动态增加或删除。</p><p>元素类型只能是不可变数据类型：整数、浮点数、字符串、元组等。</p><p>使用集合类型能够<strong>过滤重复元素</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">T = &#123;<span class="number">1010</span>, <span class="string">&#x27;1010&#x27;</span>, <span class="number">12.3</span>, <span class="number">1010</span>, <span class="number">1010</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(T)</span><br><span class="line"><span class="comment"># &#123;1010, &#x27;1010&#x27;, 12.3&#125;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">操作符及运算</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">S - T</td><td style="text-align:left">差集，返回一个新集合，包括在集合 S 中但不在集合 T 中的元素</td></tr><tr><td style="text-align:center">S &amp; T</td><td style="text-align:left">交集，返回一个新集合，包括同时在集合 S 和 T 中的元素</td></tr><tr><td style="text-align:center">S ^ T</td><td style="text-align:left">补集，返回一个新集合，包括集合 S 和 T 中非共同元素</td></tr><tr><td style="text-align:center">S | T</td><td style="text-align:left">并集，返回一个新集合，包括集合 S 和 T 中所有元素</td></tr></tbody></table><table><thead><tr><th style="text-align:center">函数或方法</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>S.add(x)</code></td><td>如果数据项 x 不在集合 S 中，将 x 增加到 S</td></tr><tr><td style="text-align:center"><code>S.remove(x)</code></td><td>如果 x 在集合 S 中，移除 x；不在则产生 KeyError 异常</td></tr><tr><td style="text-align:center"><code>S.clear()</code></td><td>移除 S 中所有数据项</td></tr><tr><td style="text-align:center"><code>len(S)</code></td><td>返回集合 S 元素个数</td></tr><tr><td style="text-align:center"><code>x in S</code></td><td>如果 x 是 S 的元素，返回 True；否则 False</td></tr><tr><td style="text-align:center"><code>x not in S</code></td><td>如果 x 不是 S 的元素，返回 True；否则 False</td></tr></tbody></table><p>set(x) 函数将其他的组合数据类型变成集合类型，也可以生成空集合变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">S = <span class="built_in">set</span>(<span class="string">&#x27;知之为知之不知为不知&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(S)</span><br><span class="line"><span class="comment"># &#123;&#x27;不&#x27;, &#x27;为&#x27;, &#x27;之&#x27;, &#x27;知&#x27;&#125;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> S :</span><br><span class="line">    <span class="built_in">print</span>(i, end = <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment"># 不为之知</span></span><br></pre></td></tr></table></figure><h4 id="序列类型概述"><a class="header-anchor" href="#序列类型概述"></a>序列类型概述</h4><p>序列类型是一维元素向量，元素之间存在先后关系，通过序号访问。</p><table><thead><tr><th style="text-align:center">操作符</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>x in s</code></td><td>如果 x 是 s 的元素，返回 True，否则 False</td></tr><tr><td style="text-align:center"><code>x not in s</code></td><td>如果 x 不是 s 的元素，返回 True，否则 False</td></tr><tr><td style="text-align:center"><code>s + t</code></td><td>连接 s 和 t</td></tr><tr><td style="text-align:center"><code>s * n 或 n * s</code></td><td>将序列 s 复制 n 次</td></tr><tr><td style="text-align:center"><code>s[i]</code></td><td>索引，返回 s 的第 i 个元素</td></tr><tr><td style="text-align:center"><code>s[i : j]</code></td><td>切片，返回包含 s 第 i 到 j 个元素的子序列（不包含 j）</td></tr><tr><td style="text-align:center"><code>s[i : j : k]</code></td><td>步骤切片，返回包含 s 第 i 到 j 个元素以 k 为步数的子序列</td></tr><tr><td style="text-align:center"><code>len(s)</code></td><td>s 的元素个数（长度）</td></tr><tr><td style="text-align:center"><code>min(s)</code></td><td>s 中的最小元素</td></tr><tr><td style="text-align:center"><code>max(s)</code></td><td>s 中的最大元素</td></tr><tr><td style="text-align:center"><code>s.index(x)</code></td><td>s 中第一次出现元素 x 的位置</td></tr><tr><td style="text-align:center"><code>s.count(x)</code></td><td>s 中出现 x 的总次数</td></tr></tbody></table><h4 id="映射类型概述"><a class="header-anchor" href="#映射类型概述"></a>映射类型概述</h4><p>映射类型是“键-值”数据项的组合，每个元素是一个键值对，即元素是(key, value)，元素之间是无序的。键值对是一种二元关系，源于属性和值的映射关系</p><h3 id="列表类型"><a class="header-anchor" href="#列表类型"></a>列表类型</h3><h4 id="定义"><a class="header-anchor" href="#定义"></a>定义</h4><ul><li>列表是包含0个或多个元组的有序序列，属于序列类型。</li><li>可进行元素的增加、删除、替换、查找。</li><li>没有长度限制，元素类型可以不同，不需要预定长度。</li><li>列表类型用中括号(<code>[]</code>)，也可以通过<code>list()</code> 函数将集合或字符串类型转换成列表类型。</li></ul><p>列表属于序列类型，所以列表类型支持序列类型对应的操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>(<span class="string">&#x27;举个栗子&#x27;</span>)</span><br><span class="line"><span class="comment"># [&#x27;举&#x27;, &#x27;个&#x27;, &#x27;栗&#x27;, &#x27;子&#x27;]</span></span><br></pre></td></tr></table></figure><h4 id="索引"><a class="header-anchor" href="#索引"></a>索引</h4><p>沿用序列类型的索引方式，即正向递增序号或反负递减序号，用中括号作为索引操作符，不得超过列表的元素范围，否则 IndexError。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ls = [<span class="number">1010</span>, <span class="string">&#x27;1010&#x27;</span>, [<span class="number">1010</span>, <span class="string">&#x27;1010&#x27;</span>], <span class="number">1010</span>]</span><br><span class="line">ls = [<span class="number">3</span>]</span><br><span class="line"><span class="comment"># 1010</span></span><br><span class="line">ls[-<span class="number">2</span>]</span><br><span class="line"><span class="comment"># [1010, &#x27;1010&#x27;]</span></span><br></pre></td></tr></table></figure><p>可以用<strong>遍历循环</strong>进行操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &lt;循环变量&gt; <span class="keyword">in</span> &lt;列表变量&gt; :</span><br><span class="line">    &lt;语句块&gt;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ls = [<span class="number">1010</span>, <span class="string">&#x27;1010&#x27;</span>, [<span class="number">1010</span>, <span class="string">&#x27;1010&#x27;</span>], <span class="number">1010</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ls :</span><br><span class="line">    <span class="built_in">print</span>(i * <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 2020</span></span><br><span class="line"><span class="comment"># 10101010</span></span><br><span class="line"><span class="comment"># [1010, &#x27;1010&#x27;, 1010, &#x27;1010&#x27;]</span></span><br><span class="line"><span class="comment"># 2020</span></span><br></pre></td></tr></table></figure><h4 id="切片"><a class="header-anchor" href="#切片"></a>切片</h4><p>切片后的结果也是列表类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;列表或列表变量&gt;[N : M]</span><br><span class="line">或</span><br><span class="line">&lt;列表或列表变量&gt;[N : M : K]</span><br></pre></td></tr></table></figure><p>在 [ ] 中表示区间需要用冒号（:），表示枚举使用英文逗号</p><p>一般要求 N 小于 M，当 N 大于 M 时，返回空列表</p><h3 id="列表类型的操作"><a class="header-anchor" href="#列表类型的操作"></a>列表类型的操作</h3><h4 id="操作函数"><a class="header-anchor" href="#操作函数"></a>操作函数</h4><table><thead><tr><th style="text-align:center">函数</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>len(ls)</code></td><td>列表 ls 的元素个数（长度）</td></tr><tr><td style="text-align:center"><code>min(ls)</code></td><td>ls 中的最小元素</td></tr><tr><td style="text-align:center"><code>max(ls)</code></td><td>ls 中的最大元素</td></tr><tr><td style="text-align:center"><code>list(x)</code></td><td>将 x 转变成列表类型</td></tr></tbody></table><h4 id="列表的操作方法"><a class="header-anchor" href="#列表的操作方法"></a>列表的操作方法</h4><p><code>&lt;列表变量&gt;.&lt;方法名称&gt;(&lt;方法参数&gt;)</code></p><table><thead><tr><th style="text-align:center">方法</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>ls.append(x)</code></td><td>在 ls 最后增加 x</td></tr><tr><td style="text-align:center"><code>ls.insert(i, x)</code></td><td>在 ls 第 i 位置增加 x</td></tr><tr><td style="text-align:center"><code>ls.clear()</code></td><td>删除 ls 中所有元素</td></tr><tr><td style="text-align:center"><code>ls.pop(i)</code></td><td>将 ls 中第 i 项元素取出并从 ls  中删除</td></tr><tr><td style="text-align:center"><code>ls.remove(x)</code></td><td>将 ls 中出现的第一个 x 删除</td></tr><tr><td style="text-align:center"><code>ls.reverse()</code></td><td>ls 中元素反转</td></tr><tr><td style="text-align:center"><code>ls.copy()</code></td><td>生成新列表，复制 ls</td></tr></tbody></table><p><strong>del</strong>对列表元素或片段进行删除，使用方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> &lt;列表变量&gt;[&lt;索引序号&gt;] 或</span><br><span class="line"><span class="keyword">del</span> &lt;列表变量&gt;[&lt;索引起始&gt;: &lt;索引结束&gt;]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ls = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">del</span> ls[<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(ls)</span><br><span class="line"><span class="comment"># [1, 3, 4]</span></span><br></pre></td></tr></table></figure><p><strong>ls.copy()</strong> 生成的新列表不受旧列表影响</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ls = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">lsn = ls.copy()</span><br><span class="line">ls.clear()</span><br><span class="line"><span class="built_in">print</span>(lsn)</span><br><span class="line"><span class="comment"># [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line">lt = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">ls = lt</span><br><span class="line">lt.clear()</span><br><span class="line"><span class="built_in">print</span>(ls)</span><br><span class="line"><span class="comment"># []</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    list1 = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>))</span><br><span class="line">    list1.append(<span class="number">100</span>)</span><br><span class="line">    <span class="built_in">print</span>(list1)  <span class="comment"># [1, 3, 5, 7, 100]</span></span><br><span class="line">    list2 = [<span class="string">&#x27;hello&#x27;</span>] * <span class="number">5</span>  </span><br><span class="line">    <span class="built_in">print</span>(list2)  <span class="comment"># [&#x27;hello&#x27;, &#x27;hello&#x27;, &#x27;hello&#x27;, &#x27;hello&#x27;, &#x27;hello&#x27;]</span></span><br><span class="line">    <span class="comment"># 计算列表长度(元素个数)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(list1))  <span class="comment"># 5</span></span><br><span class="line">    <span class="comment"># 下标(索引)运算，访问列表</span></span><br><span class="line">    <span class="built_in">print</span>(list1[<span class="number">0</span>])  <span class="comment"># 1</span></span><br><span class="line">    <span class="built_in">print</span>(list1[<span class="number">4</span>])  <span class="comment"># 100</span></span><br><span class="line">    <span class="built_in">print</span>(list1[<span class="number">5</span>])  <span class="comment"># IndexError: list index out of range</span></span><br><span class="line">    <span class="built_in">print</span>(list1[-<span class="number">1</span>])  <span class="comment"># 100</span></span><br><span class="line">    <span class="built_in">print</span>(list1[-<span class="number">3</span>])  <span class="comment"># 5</span></span><br><span class="line">    <span class="comment"># 替换元素</span></span><br><span class="line">    list1[<span class="number">2</span>] = <span class="number">300</span></span><br><span class="line">    <span class="built_in">print</span>(list1)  <span class="comment"># [1, 3, 300, 7, 100]</span></span><br><span class="line">    <span class="comment"># 添加元素</span></span><br><span class="line">    list1.append(<span class="number">200</span>)  <span class="comment"># 添加到尾部</span></span><br><span class="line">    list1.insert(<span class="number">1</span>, <span class="number">400</span>)  <span class="comment"># 插入到对应索引号</span></span><br><span class="line">    list1 += [<span class="number">1000</span>, <span class="number">2000</span>]  <span class="comment"># 添加到尾部</span></span><br><span class="line">    <span class="built_in">print</span>(list1)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(list1))</span><br><span class="line">    <span class="comment"># 删除元素</span></span><br><span class="line">    <span class="keyword">del</span> list1[<span class="number">0</span>]  <span class="comment"># 删除对应索引号的元素</span></span><br><span class="line">    <span class="built_in">print</span>(list1)</span><br><span class="line">    <span class="built_in">print</span>(list1.pop())  <span class="comment"># 弹出末尾元素，括号内输入索引值便可弹出对应元素</span></span><br><span class="line">    <span class="built_in">print</span>(list1)</span><br><span class="line">    list1.remove(<span class="number">3</span>)  <span class="comment"># 根据值删除元素，只删除第一个指定的值</span></span><br><span class="line">    <span class="keyword">if</span> <span class="number">1234</span> <span class="keyword">in</span> list1:  <span class="comment"># 进行优化</span></span><br><span class="line">        list1.remove(<span class="number">1234</span>)</span><br><span class="line">    <span class="keyword">del</span> list1[<span class="number">0</span>]</span><br><span class="line">    <span class="built_in">print</span>(list1)</span><br><span class="line">    <span class="comment"># 清空列表元素</span></span><br><span class="line">    <span class="comment"># list1 = []</span></span><br><span class="line">    list2 = list1</span><br><span class="line">    list1.clear()  <span class="comment"># 采用clear函数清理关联列表</span></span><br><span class="line">    <span class="built_in">print</span>(list1)</span><br><span class="line">    <span class="built_in">print</span>(list2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    list1 = [<span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;zoo&#x27;</span>, <span class="string">&#x27;internationalization&#x27;</span>, <span class="string">&#x27;blueberry&#x27;</span>]</span><br><span class="line">    <span class="comment"># sorted函数返回列表排序后的拷贝不会修改传入的列表</span></span><br><span class="line">    list2 = <span class="built_in">sorted</span>(list1)</span><br><span class="line">    <span class="comment"># 函数的设计就应该像sorted函数一样尽可能不产生副作用</span></span><br><span class="line">    list3 = <span class="built_in">sorted</span>(list1, reverse=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 通过key关键字参数指定根据字符串长度进行排序而不是默认的字母表顺序</span></span><br><span class="line">    list4 = <span class="built_in">sorted</span>(list1, key=<span class="built_in">len</span>)</span><br><span class="line">    <span class="built_in">print</span>(list1)</span><br><span class="line">    <span class="built_in">print</span>(list2)</span><br><span class="line">    <span class="built_in">print</span>(list3)</span><br><span class="line">    <span class="built_in">print</span>(list4)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 给列表对象发出排序消息直接在列表对象上进行排序</span></span><br><span class="line">    list1.sort(reverse=<span class="literal">True</span>)  <span class="comment"># 参数reverse=True按字母反向排序</span></span><br><span class="line">    list1.reverse()  <span class="comment"># 反转列表</span></span><br><span class="line">    <span class="comment"># list1[::-1]</span></span><br><span class="line">    <span class="built_in">print</span>(list1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="字典的索引"><a class="header-anchor" href="#字典的索引"></a>字典的索引</h3><p><code>&lt;值&gt; = &lt;字典变量&gt;[&lt;键&gt;]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;20101&#x27;</span>:<span class="string">&#x27;小明&#x27;</span>, <span class="string">&#x27;20102&#x27;</span>:<span class="string">&#x27;小红&#x27;</span>, <span class="string">&#x27;20103&#x27;</span>:<span class="string">&#x27;小白&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&#x27;20102&#x27;</span>])</span><br><span class="line"><span class="comment"># 小红</span></span><br></pre></td></tr></table></figure><p>大括号 { } 可以创建字典，索引和赋值可以增加元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t = &#123;&#125;</span><br><span class="line">t[<span class="string">&#x27;20104&#x27;</span>:<span class="string">&#x27;小新&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(t)</span><br><span class="line"><span class="comment"># &#123;&#x27;20104&#x27;:&#x27;小新&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p>字典是存储可变数量键值对的数据结构，<strong>键和值可以是任意数据类型</strong>。</p><p><strong>键必须是不可变的</strong>，如字符串，数字或元组。</p><h3 id="字典的操作"><a class="header-anchor" href="#字典的操作"></a>字典的操作</h3><h4 id="相关操作函数"><a class="header-anchor" href="#相关操作函数"></a>相关操作函数</h4><table><thead><tr><th style="text-align:center">函数</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>len(d)</code></td><td>字典 d 的元素个数（长度）</td></tr><tr><td style="text-align:center"><code>min(d)</code></td><td>字典 d 中键的最小值</td></tr><tr><td style="text-align:center"><code>max(d)</code></td><td>字典 d 中键的最大值</td></tr><tr><td style="text-align:center"><code>dict()</code></td><td>生成一个空字典</td></tr></tbody></table><h4 id="操作方法"><a class="header-anchor" href="#操作方法"></a>操作方法</h4><p><code>&lt;字典变量&gt;.&lt;方法名称&gt;(&lt;方法参数&gt;)</code></p><table><thead><tr><th style="text-align:center">方法</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>d.keys()</code></td><td>返回所有的键信息</td></tr><tr><td style="text-align:center"><code>d.values()</code></td><td>返回所有的值信息</td></tr><tr><td style="text-align:center"><code>d.items()</code></td><td>返回所有的键值对</td></tr><tr><td style="text-align:center"><code>d.get(key, default)</code></td><td>键存在则返回相应值，否则返回默认值</td></tr><tr><td style="text-align:center"><code>d.pop(key, default)</code></td><td>键存在则返回并删除值对，否则返回默认值</td></tr><tr><td style="text-align:center"><code>d.popitem()</code></td><td>随机从字典中去取出一个键值对，以元组(key, value)形式返回，并从字典中删除</td></tr><tr><td style="text-align:center"><code>d.clear()</code></td><td>删除所有的键值对</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;1&#x27;</span>:<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;2&#x27;</span>:<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;3&#x27;</span>:<span class="string">&#x27;C&#x27;</span>&#125;</span><br><span class="line">d.items()</span><br><span class="line"><span class="comment"># dict_items([(&#x27;1&#x27;,&#x27;A&#x27;), (&#x27;2&#x27;, &#x27;B&#x27;), (&#x27;3&#x27;, &#x27;C&#x27;)])</span></span><br><span class="line"></span><br><span class="line">d.get(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">d.get(<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;不存在&#x27;</span>)</span><br><span class="line"><span class="comment"># &#x27;不存在&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> d[<span class="string">&#x27;1&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="comment"># &#123;&#x27;2&#x27;:&#x27;B&#x27;, &#x27;3&#x27;:&#x27;C&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;1&#x27;</span> <span class="keyword">in</span> d</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;4&#x27;</span> <span class="keyword">in</span> d</span><br><span class="line"><span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> d:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;The key and value are &#123;&#125; and &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(k, d.get(k)))</span><br><span class="line"><span class="comment"># The key and value are 1 and A</span></span><br><span class="line"><span class="comment"># The key and value are 2 and B</span></span><br><span class="line"><span class="comment"># The key and value are 3 and C</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    scores = &#123;<span class="string">&#x27;骆昊&#x27;</span>: <span class="number">95</span>, <span class="string">&#x27;白元芳&#x27;</span>: <span class="number">78</span>, <span class="string">&#x27;狄仁杰&#x27;</span>: <span class="number">82</span>&#125;</span><br><span class="line">    <span class="comment"># 通过键可以获取字典中对应的值</span></span><br><span class="line">    <span class="built_in">print</span>(scores[<span class="string">&#x27;骆昊&#x27;</span>])</span><br><span class="line">    <span class="built_in">print</span>(scores[<span class="string">&#x27;狄仁杰&#x27;</span>])</span><br><span class="line">    <span class="comment"># 对字典进行遍历(遍历的其实是键再通过键取对应的值)</span></span><br><span class="line">    <span class="keyword">for</span> elem <span class="keyword">in</span> scores:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s\t---&gt;\t%d&#x27;</span> % (elem, scores[elem]))</span><br><span class="line">    <span class="comment"># 更新字典中的元素</span></span><br><span class="line">    scores[<span class="string">&#x27;白元芳&#x27;</span>] = <span class="number">65</span></span><br><span class="line">    scores[<span class="string">&#x27;诸葛王朗&#x27;</span>] = <span class="number">71</span></span><br><span class="line">    scores.update(冷面=<span class="number">67</span>, 方启鹤=<span class="number">85</span>)</span><br><span class="line">    <span class="built_in">print</span>(scores)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;武则天&#x27;</span> <span class="keyword">in</span> scores:</span><br><span class="line">        <span class="built_in">print</span>(scores[<span class="string">&#x27;武则天&#x27;</span>])</span><br><span class="line">    <span class="built_in">print</span>(scores.get(<span class="string">&#x27;武则天&#x27;</span>))</span><br><span class="line">    <span class="comment"># get方法也是通过键获取对应的值但是可以设置默认值</span></span><br><span class="line">    <span class="built_in">print</span>(scores.get(<span class="string">&#x27;武则天&#x27;</span>, <span class="number">60</span>))</span><br><span class="line">    <span class="comment"># 删除字典中的元素</span></span><br><span class="line">    <span class="built_in">print</span>(scores.popitem())</span><br><span class="line">    <span class="built_in">print</span>(scores.popitem())</span><br><span class="line">    <span class="built_in">print</span>(scores.pop(<span class="string">&#x27;骆昊&#x27;</span>, <span class="number">100</span>))</span><br><span class="line">    <span class="comment"># 清空字典</span></span><br><span class="line">    scores.clear()</span><br><span class="line">    <span class="built_in">print</span>(scores)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="实例解析——文本词频统计"><a class="header-anchor" href="#实例解析——文本词频统计"></a>实例解析——文本词频统计</h3><p>在很多情况下，会遇到这样的问题：对于一篇给定文章，希望统计其中多次出现的词语，进而概要分析文章的内容。这个问题的解决可用于对网络信息进行自动检索和归档。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">第一步：分解并提取英文文章的单词通过txt.lower()函数将字母变成小写，排除原文大小写差异对词频统计的干扰。为统一分隔方式，可以将各种特殊字符和标点符号使用txt.replace()方法替换成空格，再提取单词。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getText</span>():</span></span><br><span class="line">    txt = <span class="built_in">open</span>(<span class="string">&#x27;hamlet.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>).read()</span><br><span class="line">    txt = txt.lower()</span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> <span class="string">&#x27;!&quot;#$&amp;%()*+,-./:;&lt;=&gt;?@[\\]^_&#123;|&#125;~&#x27;</span>:</span><br><span class="line">        txt = txt.replace(ch, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> txt</span><br><span class="line"></span><br><span class="line">hamletTxt = getText()</span><br><span class="line">words = hamletTxt.split()</span><br><span class="line">counts = &#123;&#125;</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">第二步：对每个单词进行计数</span></span><br><span class="line"><span class="string">或者，这个处理逻辑可以更简洁的表示为如下代码：</span></span><br><span class="line"><span class="string">counts[word] = counts.get(word,0) + 1</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">    counts[word] = count.get(word, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">对单词的统计值从高到低进行排序由于字典类型没有顺序，</span></span><br><span class="line"><span class="string">需要将其转换为有顺序的列表类型，</span></span><br><span class="line"><span class="string">再使用sort()方法和lambda函数配合实现根据单词次数对元素进行排序。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">items = <span class="built_in">list</span>(counts.items()) <span class="comment"># 将字典转换为记录列表</span></span><br><span class="line">items.sort(key = <span class="keyword">lambda</span> x:x[<span class="number">1</span>], reverse = <span class="literal">True</span>) <span class="comment"># 以第2列排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    word, count = items[i]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#123;0:&lt;10&#125;&#123;1:&gt;5&#125;&#x27;</span>.<span class="built_in">format</span>(word, count))</span><br></pre></td></tr></table></figure><h2 id="文件和数据格式化"><a class="header-anchor" href="#文件和数据格式化"></a>文件和数据格式化</h2><h3 id="文件的使用"><a class="header-anchor" href="#文件的使用"></a>文件的使用</h3><p>两种类型：文本文件、二进制文件</p><p>存储在辅助存储器上的一组数据序列。</p><h4 id="文件的类型"><a class="header-anchor" href="#文件的类型"></a>文件的类型</h4><p>文本文件：由单一特定编码的字符组成；</p><p>二进制文件：直接由比特0和比特1组成，没有统一的字符编码，文件内部数据的组织格式与文件用途有关。</p><h4 id="打开和关闭"><a class="header-anchor" href="#打开和关闭"></a>打开和关闭</h4><p>文件的存储状态是默认状态，打开后变成占用状态，关闭后再次回到存储状态。</p><p><code>open()</code>函数：打开一个文件，并返回一个操作这个文件的变量</p><p><code>&lt;变量名&gt; = open(&lt;文件路径及文件名&gt;, &lt;打开模式&gt;)</code></p><table><thead><tr><th style="text-align:center">打开模式</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:center"><code>'r'</code></td><td>只读，如果文件不存在返回异常 FileNotFoundError，默认值</td></tr><tr><td style="text-align:center"><code>'w'</code></td><td>覆盖写，文件不存在则创建，存在则完全覆盖原文件</td></tr><tr><td style="text-align:center"><code>'x'</code></td><td>创建写，文件不存在则创建，存在则返回异常 FileExistsError</td></tr><tr><td style="text-align:center"><code>'a'</code></td><td>追加写，文件不存在则创建，存在则在源文件最后追加内容</td></tr><tr><td style="text-align:center"><code>'b'</code></td><td>二进制文件模式</td></tr><tr><td style="text-align:center"><code>'t'</code></td><td>文本文件模式，默认值</td></tr><tr><td style="text-align:center"><code>'+'</code></td><td>与 r w x d 一同使用，在原功能上增加读写功能</td></tr></tbody></table><p>&lt;变量名&gt;.close() 关闭文件，释放文件的使用授权。</p><p>**表示路径时，使用 <code>\\\</code> 或 / 代替  <code>\\</code> **</p><h4 id="文件的读写"><a class="header-anchor" href="#文件的读写"></a>文件的读写</h4><table><thead><tr><th style="text-align:center">读取方法</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:center"><code>f.read(size = -1)</code></td><td>从文件中读入整个文件内容。参数可选，读入前size长度的字符串或字节流</td></tr><tr><td style="text-align:center"><code>f.readline(size = -1)</code></td><td>从文件中读入一行内容。参数可选，读入该行前size长度的字符串或字节流</td></tr><tr><td style="text-align:center"><code>f.readlines(hint  = -1)</code></td><td>从文件中读入所有行，以每行为元素形成一个列表。参数可选，读入 hint 行</td></tr><tr><td style="text-align:center"><code>f.seek(offset)</code></td><td>改变当前文件操作指针的位置。offset : 0为文件开头；2为文件结尾</td></tr></tbody></table><table><thead><tr><th style="text-align:center">写入方法</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:center"><code>f.write(s)</code></td><td>向文件写入一个字符串或字节流</td></tr><tr><td style="text-align:center"><code>f.writelines(s)</code></td><td>将一个元素为字符串的列表整体写入文件</td></tr></tbody></table><p>f.write(s) 写入字符串 s，每次写入后，将会记录一个<strong>写入指针</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;d:/c.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">f.write(<span class="string">&#x27;123\n&#x27;</span>)</span><br><span class="line">f.write(<span class="string">&#x27;456\n&#x27;</span>)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>要显式地<strong>使用<code>\n</code>进行分行</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ls = [<span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;456&#x27;</span>, <span class="string">&#x27;789&#x27;</span>]</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;d:/d.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">f.writelinese(ls)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><h3 id="数据组织的维度"><a class="header-anchor" href="#数据组织的维度"></a>数据组织的维度</h3><h4 id="一维数据"><a class="header-anchor" href="#一维数据"></a>一维数据</h4><p>由对等关系的有序或无序数据构成，采用线性方式组织。</p><p>任何表现为序列或集合的内容都可以看作是一维数据。</p><h4 id="二维数据"><a class="header-anchor" href="#二维数据"></a>二维数据</h4><p>也称表格数据，由关联系数构成，采用二维表格方式组成。</p><h4 id="高维数据"><a class="header-anchor" href="#高维数据"></a>高维数据</h4><p>由键值对类型的数据组成，采用对象方式组织，可以多层嵌套。</p><p>高维数据在Web系统中十分常用，作为当今Internet组织内容的主要方式，高位数据衍生出HTML、XML、JSON等具体数据组织的语法结构。</p><h3 id="一维数据处理"><a class="header-anchor" href="#一维数据处理"></a>一维数据处理</h3><h4 id="表示"><a class="header-anchor" href="#表示"></a>表示</h4><p>由于是线性结构，因此主要采用列表形式表示。</p><h4 id="存储"><a class="header-anchor" href="#存储"></a>存储</h4><p>4种方法：</p><ol><li>采用空格分隔元素：A 12 数据</li><li>采用逗号分隔元素：A, 12, 数据</li><li>采用续行分隔元素：A<br>12<br>数据</li><li>其他特殊符号分隔，如分号：A; 12; 数据</li></ol><p>逗号分隔的存储格式为 CSV 格式（Comma_Separated Values），它是<strong>一种通用的、相对简单的文件格式</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ls = [<span class="string">&#x27;北京&#x27;</span>, <span class="string">&#x27;上海&#x27;</span>, <span class="string">&#x27;广州&#x27;</span>]</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;city.csv&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">f.write(<span class="string">&#x27;,&#x27;</span>.join(ls) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><h4 id="处理"><a class="header-anchor" href="#处理"></a>处理</h4><p>首先需要从 CSV 文件读入一维数据，并将其表示为列表对象。</p><p>默认包含了一个换行符 <code>\n</code>。<strong>采用 <code>.strip()</code> 去掉</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;city.csv&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">ls = f.read().strip(<span class="string">&#x27;\n&#x27;</span>).split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">f.close()</span><br><span class="line"><span class="built_in">print</span>(ls)</span><br></pre></td></tr></table></figure><h3 id="二维数据的处理"><a class="header-anchor" href="#二维数据的处理"></a>二维数据的处理</h3><h4 id="表示方法"><a class="header-anchor" href="#表示方法"></a>表示方法</h4><p>二维数据可以采用二维列表来表示。</p><p>二维数据一般采用相同的数据类型存储</p><h4 id="存储方式"><a class="header-anchor" href="#存储方式"></a>存储方式</h4><p>用 csv 文件存储</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ls 代表二维列表</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;cpi.csv&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> ls:</span><br><span class="line">    f.wrtie(<span class="string">&#x27;,&#x27;</span>.join(row) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><h4 id="处理代码"><a class="header-anchor" href="#处理代码"></a>处理代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;cpi.csv&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">ls = []</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f :</span><br><span class="line">    ls.append(line.strip(<span class="string">&#x27;\n&#x27;</span>).split(<span class="string">&#x27;,&#x27;</span>))</span><br><span class="line">f.close()</span><br><span class="line"><span class="built_in">print</span>(ls)</span><br></pre></td></tr></table></figure><p>与一维列表不同，二维列表一般需要借助<strong>循环遍历</strong>实现对每个数据的处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> ls :</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> row:</span><br><span class="line">对第 row 行第 item 列元素进行处理</span><br></pre></td></tr></table></figure><p>对二维数据进行格式化输出，打印成表格形状：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#此出省去从 CSV 获得的 ls</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> ls:</span><br><span class="line">    line = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> row:</span><br><span class="line">        line += <span class="string">&#x27;&#123;:10&#125;\t&#x27;</span>.<span class="built_in">format</span>(item) <span class="comment">#\t 横行制表符</span></span><br><span class="line">    <span class="built_in">print</span>(line)</span><br></pre></td></tr></table></figure><h4 id="zip-函数"><a class="header-anchor" href="#zip-函数"></a><code>zip()</code>函数</h4><p>用来获取两个组合数据类，并将它的元素交织返回</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">y = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">zip</span>(x, y))</span><br><span class="line"><span class="comment"># [(1, 4), (2, 5), (3, 6)]</span></span><br></pre></td></tr></table></figure><h3 id="实例解析–国家财政数据趋势演算"><a class="header-anchor" href="#实例解析–国家财政数据趋势演算"></a>实例解析–国家财政数据趋势演算</h3><p>由个别数据预测规律属于数值分析的内容，可以通过线性回归方程建立简单模型，</p><p>线性回归方程的公式为： $\hat y$ = b$\hat x$ + a</p><p>X代表年份，Y代表各年份对应的数值。Python实现的国家财政数据趋势演算，根据上述三个数值计算出更多年份的可能数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">means</span>(<span class="params">data</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(data) / <span class="built_in">len</span>(data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">linearRegression</span>(<span class="params">xlist, ylist</span>):</span></span><br><span class="line">    xmeans, ymeans = means(xlist), means(ylist)</span><br><span class="line">    bNumerator = -<span class="built_in">len</span>(xlist) * xmeans * ymeans</span><br><span class="line">    bDenominator = -<span class="built_in">len</span>(xlist) * xmeans ** <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">zip</span>(xlist, ylist):</span><br><span class="line">        bNumerator += x * y</span><br><span class="line">        bDenominator += x ** <span class="number">2</span></span><br><span class="line">    b = bNumerator / bDenominator</span><br><span class="line">    a = ymeas - b * xmeans</span><br><span class="line">    <span class="keyword">return</span> a, b</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parseCSV</span>(<span class="params">filename</span>):</span></span><br><span class="line">    dataNames, data = [], []</span><br><span class="line">    f = <span class="built_in">open</span>(filename, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        splitedLine = line.strip().split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;指标&#x27;</span> <span class="keyword">in</span> splitedLine[<span class="number">0</span>]:</span><br><span class="line">            years = [<span class="built_in">int</span>(x[:-<span class="number">1</span>]) <span class="keyword">for</span> x <span class="keyword">in</span> splitedLine[<span class="number">1</span>:]]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dataNames.append(<span class="string">&#x27;&#123;:10&#125;&#x27;</span>.<span class="built_in">format</span>(splitedLine[<span class="number">0</span>]))</span><br><span class="line">            data.append([<span class="built_in">float</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> splitedLine[<span class="number">1</span>:]])</span><br><span class="line">    f.close()</span><br><span class="line">    <span class="keyword">return</span> years, dataNames, data</span><br><span class="line"><span class="comment"># 线性回归代码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">means</span>(<span class="params">data</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(data) / <span class="built_in">len</span>(data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">linearRegression</span>(<span class="params">xlist, ylist</span>):</span></span><br><span class="line">    xmeans, ymeans = means(xlist), means(ylist)</span><br><span class="line">    bNumerator = - <span class="built_in">len</span>(xlist) * xmeans * ymeans</span><br><span class="line">    bDenominator =  - <span class="built_in">len</span>(xlist) * xmeans ** <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">zip</span>(xlist, ylist):</span><br><span class="line">        bNumerator += x * y</span><br><span class="line">        bDenominator += x ** <span class="number">2</span></span><br><span class="line">    b = bNumerator / bDenominator</span><br><span class="line">    a = ymeans - b * xmeans</span><br><span class="line">    <span class="keyword">return</span> a, b</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calNewData</span>(<span class="params">newyears, a, b</span>):</span></span><br><span class="line">    <span class="keyword">return</span> [(a + b * x) <span class="keyword">for</span> x <span class="keyword">in</span> newyears]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showResults</span>(<span class="params">years, dataNames, newDatas</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#123;:^60&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;国家财政收支线性估计&#x27;</span>))</span><br><span class="line">    header = <span class="string">&#x27;指标       &#x27;</span></span><br><span class="line">    <span class="keyword">for</span> year <span class="keyword">in</span> years:</span><br><span class="line">        header += <span class="string">&#x27;&#123;:10&#125;&#x27;</span>.<span class="built_in">format</span>(year)</span><br><span class="line">    <span class="built_in">print</span>(header)</span><br><span class="line">    <span class="keyword">for</span> name, lineData <span class="keyword">in</span> <span class="built_in">zip</span>(dataNames, newDatas):</span><br><span class="line">        line = name</span><br><span class="line">        <span class="keyword">for</span> data <span class="keyword">in</span> lineData:</span><br><span class="line">            line += <span class="string">&#x27;&#123;:&gt;10.1f&#125;&#x27;</span>.<span class="built_in">format</span>(data)</span><br><span class="line">        <span class="built_in">print</span>(line)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    newyears = [x+<span class="number">2010</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>)]</span><br><span class="line">    newDatas = []</span><br><span class="line">    years, dataNames, datas = parseCSV(<span class="string">&#x27;finance.csv&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> datas:</span><br><span class="line">        a, b = linearRegression(years, data)</span><br><span class="line">        newDatas.append(calNewData(newyears, a, b))</span><br><span class="line">    showResults(newyears, dataNames, newDatas)</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure><h2 id="Python-计算生态"><a class="header-anchor" href="#Python-计算生态"></a>Python 计算生态</h2><h3 id="计算思维"><a class="header-anchor" href="#计算思维"></a>计算思维</h3><p>程序设计是实践计算思维的重要手段</p><p>本质：抽象和自动化</p><p>算法（Algorithm）：<strong>解决问题的清晰指令</strong></p><h3 id="程序设计方法论"><a class="header-anchor" href="#程序设计方法论"></a>程序设计方法论</h3><p>一个解决复杂问题行之有效的方法被称作自顶而下的设计方法，其基本思想是以一个总问题开始，试图把它表达为很多小问题组成的解决方案。再用同样的技术依次攻破每个小问题，最终问题变得非常小，以至于可以很容易解决。然后只需把所有的碎片组合起来，就可以得到一个程序。</p><h4 id="自顶向下设计：最重要是顶层设计"><a class="header-anchor" href="#自顶向下设计：最重要是顶层设计"></a>自顶向下设计：最重要是顶层设计</h4><p>是一种开发复杂程序最具价值的设计理念和工具，设计过程自然且简单，自顶向下设计通过封装实现抽象，利用了模块化设计的思想。</p><h4 id="自底向上执行"><a class="header-anchor" href="#自底向上执行"></a>自底向上执行</h4><p>开展测试的更好办法也是将程序分成小部分逐个测试</p><p>执行中等规模程序的最好方法是从结构图最底层开始，而不是从顶部开始，然后逐步上升。或者说，先运行和测试每一个基本函数，再测试由基础函数组成的整体函数，这样有助于定位错误</p><h3 id="计算生态"><a class="header-anchor" href="#计算生态"></a>计算生态</h3><p>Python官方网站提供了第三方库索引功能<a href="https://pypi.python.org/pypi">PyPI</a></p><p>函数库并非都采用 Python 编写，很多采用 C 等语言编写的库可以通过简单的接口封装供 Python 程序调用。“胶水语言”。</p><p>Python 第三方程序包：</p><ul><li>库 library；</li><li>模块 module；</li><li>类 class；</li><li>程序包 package</li></ul><h3 id="实例解析–Web页面元素提取"><a class="header-anchor" href="#实例解析–Web页面元素提取"></a>实例解析–Web页面元素提取</h3><p>Web页面，一般是HTML页面，是Internet组织信息的基础元素。Web页面元素提取是一类常见问题，在网络爬虫、浏览器等程序中有着不可或缺的重要作用。</p><p>HTML指超文本标记语言，严格来说，HTML不是一种编程语言，而是一种对信息的标记语言，对Web的内容、格式进行描述。</p><p>自动地从一个链接获取HTML页面是网络爬虫的功能，本实例功能可以整体分成如下4个步骤：</p><ul><li>步骤1: 读取保存在本地的html文件；</li><li>步骤2：解析并提取其中的图片链接；</li><li>步骤3：输出提取结果到屏幕；</li><li>步骤4：保存提取结果为文件。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">根据上述步骤，可以写出主程序如下。</span></span><br><span class="line"><span class="string">其中设置了4个函数</span></span><br><span class="line"><span class="string">getHTMLlines()、extractImageUrls()、showResults()和saveResults()分别对应上述4个步骤。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHTMLlines</span>(<span class="params">htmlpath</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    getHTMLlines()函数读取HTML文件并内容，</span></span><br><span class="line"><span class="string">    并将结果转换为一个分行列表，</span></span><br><span class="line"><span class="string">    为了兼容不同编码，建议在open()函数中增加encoding字段，</span></span><br><span class="line"><span class="string">    设置采用UTF-8编码打开文件。</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    f = <span class="built_in">open</span>(htmlpath, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    ls = f.readlines()</span><br><span class="line">    f.close()</span><br><span class="line">    <span class="keyword">return</span> ls</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extractImageUrls</span>(<span class="params">htmllist</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    extractImageUrls()是程序的核心，用于解析文件并提取图像的URL。</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    urls = []</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> htmllist:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;img&#x27;</span> <span class="keyword">in</span> line:</span><br><span class="line">            url = line.split(<span class="string">&#x27;src=&#x27;</span>)[-<span class="number">1</span>].split(<span class="string">&#x27;&quot;&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;http&#x27;</span> <span class="keyword">in</span> url:</span><br><span class="line">                urls.append(url)</span><br><span class="line">    <span class="keyword">return</span> urls</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showResults</span>(<span class="params">urls</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    showResults()函数将获取的链接输出到屏幕上，</span></span><br><span class="line"><span class="string">    增加一个计数变量提供更好用户体验</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;第&#123;:2&#125;个URL:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(count, url))</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">saveResults</span>(<span class="params">filepath, urls</span>):</span> <span class="comment"># 保存结果到文件</span></span><br><span class="line">    f = <span class="built_in">open</span>(filepath, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">        f.write(url+<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    定义main()函数的目的是为了让代码更加清晰，</span></span><br><span class="line"><span class="string">    作为主程序，也可以不采用函数形式而直接编写。</span></span><br><span class="line"><span class="string">    main()前两行分别制定了拟获取HTML文件的路径和结果输出路径。</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    inputfile  = <span class="string">&#x27;nationalgeographic.html&#x27;</span></span><br><span class="line">    outputfile = <span class="string">&#x27;nationalgeographic-urls.txt&#x27;</span></span><br><span class="line">    htmlLines = getHTMLlines(inputfile)</span><br><span class="line">    imageUrls = extractImageUrls(htmlLines)</span><br><span class="line">    showResults(imageUrls)</span><br><span class="line">    saveResults(outputfile, imageUrls)</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure><h2 id="Python-标准库概览"><a class="header-anchor" href="#Python-标准库概览"></a>Python 标准库概览</h2><p>有一部分Python计算生态随Python安装包一起发布，用户可以随时使用，被称为Python标准库。</p><h3 id="turtle库概述"><a class="header-anchor" href="#turtle库概述"></a>turtle库概述</h3><p>turtle 是 Python 重要的标准库之一，它能够进行基本的图形绘制。概念诞生于1969年，成功应用于 LOGO 编程语言。</p><p>基本框架：一个龟在坐标系中爬行，其爬行轨迹形成了绘制图形。</p><p>刚开始时，位于正中央，前进方向为水平右方。</p><p>三种引用方式：</p><ol><li><pre><code class="language-python">import turtleturtle.&lt;函数名&gt;()<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. &#96;&#96;&#96;python</span><br><span class="line">   from turtle import *</span><br><span class="line">   &lt;函数名&gt;()</span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code class="language-python">import turtle as t(也可以是其他别名)t.&lt;函数名&gt;()<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### turtle库与基本绘图</span><br><span class="line"></span><br><span class="line">turtle库包含100多个功能函数，主要包括窗体函数、画笔状态函数、画笔运动函数等三类。</span><br><span class="line"></span><br><span class="line">#### 窗体函数：turtle.setup()</span><br><span class="line"></span><br><span class="line">&#96;turtle.setup(width, height, startx, starty)&#96;</span><br><span class="line"></span><br><span class="line">作用：设置主窗体的大小和位置。</span><br><span class="line"></span><br><span class="line">width：窗口宽度。整数：像素值；小数：窗口宽度与屏幕的比例。</span><br><span class="line"></span><br><span class="line">height：窗口高度。</span><br><span class="line"></span><br><span class="line">startx：窗口左侧与屏幕左侧的像素距离。None：水平中央。</span><br><span class="line"></span><br><span class="line">starty：窗口顶部与屏幕顶部的像素距离。None：垂直中央。</span><br><span class="line"></span><br><span class="line">#### 画笔状态函数</span><br><span class="line"></span><br><span class="line">|           函数            | 作用                                        |</span><br><span class="line">| :-----------------------: | ------------------------------------------- |</span><br><span class="line">|        &#96;pendown()&#96;        | 放下画笔                                    |</span><br><span class="line">|         &#96;penup()&#96;         | 提起画笔，与 pendown() 配对使用             |</span><br><span class="line">|        &#96;pensize()&#96;        | 设置画笔线条的粗细                          |</span><br><span class="line">|       &#96;pencolor()&#96;        | 设置颜色                                    |</span><br><span class="line">|      &#96;begin_fill()&#96;       | 填充前，调用                                |</span><br><span class="line">|       &#96;end_fill()&#96;        | 填充结束                                    |</span><br><span class="line">|        &#96;filling()&#96;        | 返回填充的状态，True 为填充，False 为未填充 |</span><br><span class="line">|         &#96;clear()&#96;         | 清空当前窗口，但不改变当前画笔位置          |</span><br><span class="line">|         &#96;reset()&#96;         | 清空并重置                                  |</span><br><span class="line">|      &#96;screensize()&#96;       | 设置画布的长与宽                            |</span><br><span class="line">|      &#96;showturtle()&#96;       | 显示画笔的 turtle 形状                      |</span><br><span class="line">|      &#96;hideturtle()&#96;       | 隐藏画笔的 turtle 形状                      |</span><br><span class="line">|       &#96;isvisible()&#96;       | 如果 turtle 可见，则返回 True               |</span><br><span class="line">| &#96;write(str, font &#x3D; None)&#96; | 输出 font 字体的 str                        |</span><br><span class="line"></span><br><span class="line">#### 画笔运动函数</span><br><span class="line"></span><br><span class="line">|        函数         | 作用                               |</span><br><span class="line">| :-----------------: | ---------------------------------- |</span><br><span class="line">|     &#96;forward()&#96;     | 前进指定距离                       |</span><br><span class="line">|    &#96;backward()&#96;     | 后退指定距离                       |</span><br><span class="line">|   &#96;right(angle)&#96;    | 向右旋转 angle 角度                |</span><br><span class="line">|    &#96;left(angle)&#96;    | 向左旋转 angle 角度                |</span><br><span class="line">|    &#96;goto(x, y)&#96;     | 移动到（x，y）处                   |</span><br><span class="line">|      &#96;setx()&#96;       | 将当前 x 轴移动到指定位置          |</span><br><span class="line">|      &#96;sety()&#96;       | 将当前 y 轴移动到指定位置          |</span><br><span class="line">| &#96;setheading(angle)&#96; | 设置当前朝向为 angle 角度          |</span><br><span class="line">|      &#96;home()&#96;       | 设置当前位置为原点，朝向东         |</span><br><span class="line">| &#96;circle(radius, e)&#96; | 绘制一个半径 r 和角度 e 的园或弧形 |</span><br><span class="line">|   &#96;dot(r, color)&#96;   | 绘制一个半径 r 和颜色的圆点        |</span><br><span class="line">|      &#96;undo()&#96;       | 撤销画笔最后一个动作               |</span><br><span class="line">|      &#96;speed()&#96;      | 设置绘制速度，参数为0~10           |</span><br><span class="line"></span><br><span class="line">### random 库概述</span><br><span class="line"></span><br><span class="line">用于产生各种分布的伪随机数序列。采用梅森旋转算法（Mersenne twiste）生成伪随机数序列，可用于除随机性要求更高的加密算法外大多数工程应用。</span><br><span class="line"></span><br><span class="line">最基本函数：&#96;random.random()&#96;，它生成 [0.0, 1.0)之间的小数</span><br><span class="line"></span><br><span class="line">### random 库与随机数应用</span><br><span class="line"></span><br><span class="line">|             函数              | 作用                                                |</span><br><span class="line">| :---------------------------: | --------------------------------------------------- |</span><br><span class="line">|        &#96;seed(a &#x3D; None)&#96;       | 初始化随机数种子，默认值为当前系统时间              |</span><br><span class="line">|           &#96;random()&#96;          | 生成 [0.0, 1.0] 之间的小数                          |</span><br><span class="line">|         &#96;randint(a, b)&#96;         | 生成一个 [a, b] 之间的整数                          |</span><br><span class="line">|        &#96;getrandbits(k)&#96;       | 生成一个 k 比特长度的随机整数                       |</span><br><span class="line">| &#96;randrange(start, stop [step])&#96; | 生成一个 [start, stop) 之间以 step 为步数的随机整数 |</span><br><span class="line">|       &#96;uniform(a, b)&#96;      | 生成一个 [a, b] 之间的随机小数                      |</span><br><span class="line">|          &#96;choice(seq)&#96;          | 从序列类型（如列表）中随机返回一个元素              |</span><br><span class="line">|         &#96;shuffle(seq)&#96;        | 将序列类型中元素随机排列，返回序列                  |</span><br><span class="line">|        &#96;sample(pop, k)&#96;       | 从 pop 类型中随机选取 k 个元素，以列表类型返回      |</span><br><span class="line"></span><br><span class="line">### time 库概述</span><br><span class="line"></span><br><span class="line">Python 提供的处理时间标准库。提供系统级精确计时器的计时功能，可以用来分析程序性能，也可以让程序暂停运行时间。</span><br><span class="line"></span><br><span class="line">3方面主要功能：</span><br><span class="line"></span><br><span class="line">1. 时间处理：&#96;time.time()&#96;、&#96;time.gmtime()&#96;、&#96;time.localtime()&#96;、&#96;time.ctime()&#96;</span><br><span class="line">2. 时间格式化：&#96;time.mktime()&#96;、&#96;time.strftime()&#96;、&#96;time.strptime()&#96;</span><br><span class="line">3. 计时：&#96;time.sleep()&#96;、&#96;time.monotonic()&#96;、&#96;time.perf_counter()&#96;</span><br><span class="line"></span><br><span class="line">|         函数          | 作用                                                         |</span><br><span class="line">| :-------------------: | ------------------------------------------------------------ |</span><br><span class="line">|     &#96;time.time()&#96;     | 获取当前的时间戳                                             |</span><br><span class="line">|    &#96;time.gmtime()&#96;    | 获取当前时间戳对应的 struct_time 对象                        |</span><br><span class="line">|  &#96;time.localtime()&#96;   | 获取当前时间戳对应的本地时间的 struct_time 对象              |</span><br><span class="line">|    &#96;time.ctime()&#96;     | 获取当前时间戳对应的易读字符串表示，内部会调用 time.localtime() |</span><br><span class="line">|    &#96;time.mktime()&#96;    | 将 srtuct_time 转换为时间戳                                  |</span><br><span class="line">|   &#96;time.strftime()&#96;   | 时间格式化最有效的方法，几乎可以以任何通用格式输出时间       |</span><br><span class="line">|   &#96;time.strptime()&#96;   | 提取字符串中的时间来生成 struct_time                         |</span><br><span class="line">| &#96;time.perf_counter()&#96; | 返回计时器的精准时间（系统的运行时间），包含整个系统的睡眠时间。由于返回值的基准点是未定义的，所以，只有连续调用的结果之间的差才是有效的。&lt;br &#x2F;&gt;调用一次 &#96;perf_counter()&#96;，从计算机系统里随机选一个时间点A，计算其距离当前时间点B1有多少秒。当第二次调用该函数时，默认从第一次调用的时间点A算起，距离当前时间点B2有多少秒。两个函数取差，即实现从时间点B1到B2的计时功能。 |</span><br><span class="line"></span><br><span class="line">&#96;struct_time&#96; 元素</span><br><span class="line"></span><br><span class="line">| 下标 |   属性   | 值                           |</span><br><span class="line">| :--: | :------: | ---------------------------- |</span><br><span class="line">|  0   | tm_year  | 年份，整数                   |</span><br><span class="line">|  1   |  tm_mon  | 月份 [1, 12]                 |</span><br><span class="line">|  2   | tm_mday  | 日期 [1, 31]                 |</span><br><span class="line">|  3   | tm_hour  | 小时 [0, 23]                 |</span><br><span class="line">|  4   |  tm_min  | 分钟 [0, 59]                 |</span><br><span class="line">|  5   |  tm_sec  | 秒 [0, 61]                   |</span><br><span class="line">|  6   | tm_wday  | 星期 [0, 6] （0 表示星期一） |</span><br><span class="line">|  7   | tm_yday  | 该年第几天 [1, 366]          |</span><br><span class="line">|  8   | tm_isdst | 是否夏令时，0否，1是，-1未知 |</span><br><span class="line"></span><br><span class="line">&#96;time.strftime()&#96;:</span><br><span class="line"></span><br><span class="line">&#96;time.strftime(&#39;&lt;参数&gt;&#39;, time)&#96;</span><br><span class="line"></span><br><span class="line">| 参数符号 |  日期&#x2F;时间  |       值范围       |</span><br><span class="line">| :------: | :---------: | :----------------: |</span><br><span class="line">|    %Y    |    年份     |    0001 - 9999     |</span><br><span class="line">|    %m    |    月份     |      01 - 12       |</span><br><span class="line">|    %B    |    月名     | January - December |</span><br><span class="line">|    %b    |  月名缩写   |    Jan. - Dec.     |</span><br><span class="line">|    %d    |    日期     |      01 - 31       |</span><br><span class="line">|    %A    |    星期     |  Monday - Sunday   |</span><br><span class="line">|    %a    |  星期缩写   |    Mon. - Sun.     |</span><br><span class="line">|    %H    | 小时（24h） |      00 - 23       |</span><br><span class="line">|    %I    |     12h     |      01 - 12       |</span><br><span class="line">|    %p    |   上&#x2F;下午   |       AM, PM       |</span><br><span class="line">|    %M    |    分钟     |       00 -59       |</span><br><span class="line">|    %S    |     秒      |      00 - 59       |</span><br><span class="line"></span><br><span class="line">### time 库与程序计时</span><br><span class="line"></span><br><span class="line">三要素：</span><br><span class="line"></span><br><span class="line">+ 程序开始&#x2F;结束时间</span><br><span class="line">+ 程序运行时间</span><br><span class="line">+ 程序各核心模块运行时间</span><br><span class="line"></span><br><span class="line">&#96;time.sleep(t)&#96;：推迟 t 秒执行</span><br><span class="line"></span><br><span class="line">&#96;time.perf_counter()&#96;：计时器，每次调用记录当前执行时间</span><br><span class="line"></span><br><span class="line">### 实例解析--雪景艺术绘图</span><br><span class="line"></span><br><span class="line">turtle图形艺术，指利用turtle库画笔创造性绘制绚丽多彩艺术图形的过程</span><br><span class="line"></span><br><span class="line">turtle图形艺术效果中隐含着很多随机元素，如随机颜色、尺寸、位置和数量等。在图形艺术绘制中需要引入随机函数库random。常用randint()函数，生成指定范围内的随机数</span><br><span class="line"></span><br><span class="line">绘制分为三个步骤:</span><br><span class="line"></span><br><span class="line">1. 构建图的背景</span><br><span class="line">2. 绘制雪花效果</span><br><span class="line">3. 绘制雪地效果</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">from turtle import *</span><br><span class="line">from random import *</span><br><span class="line"># 第二步，绘制雪花效果。</span><br><span class="line">def drawSnow():</span><br><span class="line">    hideturtle()</span><br><span class="line">    pensize(2)</span><br><span class="line">    for i in range(100):</span><br><span class="line">        r, g, b &#x3D; random(), random(), random()</span><br><span class="line">        pencolor(r,g,b)</span><br><span class="line">        penup()</span><br><span class="line">        setx(randint(-350,350))</span><br><span class="line">        sety(randint(1,270))</span><br><span class="line">        pendown()</span><br><span class="line">        dens &#x3D; randint(8,12)</span><br><span class="line">        snowsize &#x3D; randint(10,14)</span><br><span class="line">        for j in range(dens):</span><br><span class="line">            forward(snowsize)</span><br><span class="line">            backward(snowsize)</span><br><span class="line">            right(360&#x2F;dens)</span><br><span class="line"># 第三步，绘制雪地效果。</span><br><span class="line">def drawGround():</span><br><span class="line">    hideturtle()</span><br><span class="line">    for i in range(400):</span><br><span class="line">        pensize(randint(5,10))</span><br><span class="line">        x &#x3D; randint(-400,350)</span><br><span class="line">        y &#x3D; randint(-280,-1)</span><br><span class="line">        r, g, b &#x3D; -y&#x2F;280, -y&#x2F;280, -y&#x2F;280</span><br><span class="line">        pencolor((r,g,b))</span><br><span class="line">        penup()</span><br><span class="line">        goto(x,y)</span><br><span class="line">        pendown()</span><br><span class="line">        forward(randint(40,100))</span><br><span class="line"># 第一步，构建图的背景</span><br><span class="line">setup(800,600,200,200)</span><br><span class="line">tracer(False)</span><br><span class="line">bgcolor(&quot;black&quot;)</span><br><span class="line">drawSnow()</span><br><span class="line">drawGround()</span><br><span class="line">done()</span><br></pre></td></tr></table></figure></code></pre></li></ol><h2 id="Python-第三方库概览"><a class="header-anchor" href="#Python-第三方库概览"></a>Python 第三方库概览</h2><h3 id="获取和安装"><a class="header-anchor" href="#获取和安装"></a>获取和安装</h3><h4 id="pip-工具"><a class="header-anchor" href="#pip-工具"></a>pip 工具</h4><p>是 Python 官方提供并维护的在线第三方库安装工具。</p><p><code>pip install &lt;库名&gt;</code></p><h4 id="自定义安装"><a class="header-anchor" href="#自定义安装"></a>自定义安装</h4><p>一般适用于在 pip 中尚无登记或安装失败的第三方库</p><p>美国加州大学尔湾分校提供了一个页面，帮助Python用户获得Windows可直<br>接安装的第三方库文件，<a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/">链接地址</a></p><p>这里以scipy为例说明，首先在上述页面中找到scipy库对应的内容。选择其中的.whl文件下载，这里选择适用于Python 3.5版本解释器和32位系统的对应文件：scipy-0 . 1 7 . 1 - c p 3 5 - c p 3 5 m - w i n 3 2 . w h l ， 下载该文件到<br>D:\pycodes目录。</p><p>然后，采用pip命令安装该文件。</p><p><code>pip install D:\pycodes\scipy-0.17.1-cp35-cp35m-win32.whl</code></p><h4 id="pip-工具使用"><a class="header-anchor" href="#pip-工具使用"></a>pip 工具使用</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pip install &lt;库名&gt; <span class="comment">#安装</span></span><br><span class="line">pip uninstall &lt;库名&gt; <span class="comment">#卸载</span></span><br><span class="line">pip list <span class="comment">#列出当前系统以安装的第三方库</span></span><br><span class="line">pip show &lt;库名&gt; <span class="comment">#列出某个以安装库的详细信息</span></span><br><span class="line">pip download &lt;库名&gt; <span class="comment">#下载第三方库的安装包，但不安装</span></span><br><span class="line">pip search &lt;关键字&gt; <span class="comment">#联网搜索库名或摘要中的关键字</span></span><br><span class="line">pip <span class="literal">-h</span>  <span class="comment">#列出pip常用的子命令</span></span><br></pre></td></tr></table></figure><h3 id="PyInstaller-库"><a class="header-anchor" href="#PyInstaller-库"></a>PyInstaller 库</h3><p>将 Python 源文件（.py）打包，变成直接可运行的可执行文件。</p><p>使用PyInstaller库对Python源文件打包十分简单，使用方法如下：</p><p><code>PyInstaller &lt;程序文件名&gt;</code></p><p>生成 dist 和 build 文件夹。build 是存储临时文件的目录。最终的打包程序在dist内部与源文件同名的目录中。</p><p>注意问题：</p><ul><li>文件路径中不能出现空格和英文句号（.）</li><li>源文件必须是 UTF-8 编码</li></ul><table><thead><tr><th style="text-align:center">常用参数</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">-h, --help</td><td>查看帮助</td></tr><tr><td style="text-align:center">–clean</td><td>清理打包过程中的临时文件</td></tr><tr><td style="text-align:center">-D, --onedir</td><td>默认值，生成 dist 目录</td></tr><tr><td style="text-align:center">-F, --onefile</td><td>在 dist 文件夹中只生成独立的打包文件</td></tr><tr><td style="text-align:center">-i, &lt;图标.ico&gt;</td><td>指定打包程序使用的图标文件</td></tr></tbody></table><h3 id="jieba-库"><a class="header-anchor" href="#jieba-库"></a>jieba 库</h3><p>重要的第三方中文分词函数库</p><p>原理：是利用一个中文词库，将待分词的内容与分词词库进行比对，通过图结构和动态规划方法找到最大概率的词组。除了分词，jieba还提供增加自定义中文单词的功能。</p><p>三模式：</p><ol><li>精确模式：最精确地切开，适合文本分析；</li><li>全模式：把句子中所有可以成词的词语都扫描出来，但是不能解歧义；</li><li>搜索引擎模式：在精确模式的基础上，对长词再次切分，提高召回率，适合用于搜索引擎分词</li></ol><table><thead><tr><th style="text-align:center">函数</th><th>作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>lcut(s)</code></td><td>精确模式，返回列表</td></tr><tr><td style="text-align:center"><code>lcut(s, cut_all = True)</code></td><td>全模式</td></tr><tr><td style="text-align:center"><code>lcut_for_search(s)</code></td><td>搜索模式</td></tr><tr><td style="text-align:center"><code>add_word(w)</code></td><td>向词典中添加新词 w</td></tr></tbody></table><h3 id="wordcloud-库"><a class="header-anchor" href="#wordcloud-库"></a>wordcloud 库</h3><p>“关键词云层”、“关键词渲染”</p><table><thead><tr><th style="text-align:center">常用参数</th><th>功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>font_path</code></td><td>指定字体文件的完整路径，默认 None</td></tr><tr><td style="text-align:center"><code>width</code></td><td>生成图片宽度，默认400像素</td></tr><tr><td style="text-align:center"><code>height</code></td><td>生成图片高度，默认200像素</td></tr><tr><td style="text-align:center"><code>mask</code></td><td>词云形状，默认 None，方形图</td></tr><tr><td style="text-align:center"><code>min_font_size</code></td><td>词云中最小的字体字号，默认4号</td></tr><tr><td style="text-align:center"><code>font_step</code></td><td>字号步进间隔，默认1</td></tr><tr><td style="text-align:center"><code>stopwords</code></td><td>被排除词列表，排除词不再词云中显示</td></tr><tr><td style="text-align:center"><code>background_color</code></td><td>背景颜色，默认黑色</td></tr><tr><td style="text-align:center"><code>max_words</code></td><td>词云中最大词数，默认200</td></tr><tr><td style="text-align:center"><code>max_font_size</code></td><td>词云中最大的字体字号，默认 None，根据高度自动调整</td></tr></tbody></table><table><thead><tr><th style="text-align:center">常用方法</th><th>功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>generate(text)</code></td><td>生成词云</td></tr><tr><td style="text-align:center"><code>tofile(filename)</code></td><td>保存</td></tr></tbody></table><p>图像词云：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.misc <span class="keyword">import</span> imread</span><br><span class="line">mask = imread(<span class="string">&#x27;***.png&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="实例解析–《红楼梦》人物出场词云"><a class="header-anchor" href="#实例解析–《红楼梦》人物出场词云"></a>实例解析–《红楼梦》人物出场词云</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先输出排序前15的单词</span></span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;红楼梦.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">txt = f.read()</span><br><span class="line">f.close()</span><br><span class="line">words  = jieba.lcut(txt)</span><br><span class="line">counts = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(word) == <span class="number">1</span>:  <span class="comment">#排除单个字符的分词结果</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        counts[word] = counts.get(word,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">items = <span class="built_in">list</span>(counts.items())</span><br><span class="line">items.sort(key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">15</span>):</span><br><span class="line">    word, count = items[i]</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;&#123;0:&lt;10&#125;&#123;1:&gt;5&#125;&quot;</span>.<span class="built_in">format</span>(word, count))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要排除一些人名无关词汇，如“什么”、“一个”等</span></span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line">excludes = &#123;<span class="string">&quot;什么&quot;</span>,<span class="string">&quot;一个&quot;</span>,<span class="string">&quot;我们&quot;</span>,<span class="string">&quot;那里&quot;</span>,<span class="string">&quot;你们&quot;</span>,<span class="string">&quot;如今&quot;</span>, \</span><br><span class="line">            <span class="string">&quot;说道&quot;</span>,<span class="string">&quot;知道&quot;</span>,<span class="string">&quot;老太太&quot;</span>,<span class="string">&quot;起来&quot;</span>,<span class="string">&quot;姑娘&quot;</span>,<span class="string">&quot;这里&quot;</span>, \</span><br><span class="line">            <span class="string">&quot;出来&quot;</span>,<span class="string">&quot;他们&quot;</span>,<span class="string">&quot;众人&quot;</span>,<span class="string">&quot;自己&quot;</span>,<span class="string">&quot;一面&quot;</span>,<span class="string">&quot;太太&quot;</span>, \</span><br><span class="line">            <span class="string">&quot;只见&quot;</span>,<span class="string">&quot;怎么&quot;</span>,<span class="string">&quot;奶奶&quot;</span>,<span class="string">&quot;两个&quot;</span>,<span class="string">&quot;没有&quot;</span>,<span class="string">&quot;不是&quot;</span>, \</span><br><span class="line">            <span class="string">&quot;不知&quot;</span>,<span class="string">&quot;这个&quot;</span>,<span class="string">&quot;听见&quot;</span>&#125;</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;红楼梦.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">txt = f.read()</span><br><span class="line">f.close()</span><br><span class="line">words  = jieba.lcut(txt)</span><br><span class="line">counts = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(word) == <span class="number">1</span>:  <span class="comment">#排除单个字符的分词结果</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        counts[word] = counts.get(word,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> excludes:</span><br><span class="line">    <span class="keyword">del</span>(counts[word])</span><br><span class="line">items = <span class="built_in">list</span>(counts.items())</span><br><span class="line">items.sort(key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    word, count = items[i]</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;&#123;0:&lt;10&#125;&#123;1:&gt;5&#125;&quot;</span>.<span class="built_in">format</span>(word, count))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 结合已经将结果的词云效果，利用wordcloud库，将人物出场统计以词云的方式展现出来</span></span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">from</span> wordcloud <span class="keyword">import</span> WordCloud</span><br><span class="line"></span><br><span class="line">excludes = &#123;<span class="string">&quot;什么&quot;</span>,<span class="string">&quot;一个&quot;</span>,<span class="string">&quot;我们&quot;</span>,<span class="string">&quot;那里&quot;</span>,<span class="string">&quot;你们&quot;</span>,<span class="string">&quot;如今&quot;</span>, \</span><br><span class="line">            <span class="string">&quot;说道&quot;</span>,<span class="string">&quot;知道&quot;</span>,<span class="string">&quot;老太太&quot;</span>,<span class="string">&quot;起来&quot;</span>,<span class="string">&quot;姑娘&quot;</span>,<span class="string">&quot;这里&quot;</span>, \</span><br><span class="line">            <span class="string">&quot;出来&quot;</span>,<span class="string">&quot;他们&quot;</span>,<span class="string">&quot;众人&quot;</span>,<span class="string">&quot;自己&quot;</span>,<span class="string">&quot;一面&quot;</span>,<span class="string">&quot;太太&quot;</span>, \</span><br><span class="line">            <span class="string">&quot;只见&quot;</span>,<span class="string">&quot;怎么&quot;</span>,<span class="string">&quot;奶奶&quot;</span>,<span class="string">&quot;两个&quot;</span>,<span class="string">&quot;没有&quot;</span>,<span class="string">&quot;不是&quot;</span>, \</span><br><span class="line">            <span class="string">&quot;不知&quot;</span>,<span class="string">&quot;这个&quot;</span>,<span class="string">&quot;听见&quot;</span>&#125;</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;红楼梦.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">txt = f.read()</span><br><span class="line">f.close()</span><br><span class="line">words  = jieba.lcut(txt)</span><br><span class="line">newtxt = <span class="string">&#x27; &#x27;</span>.join(words)</span><br><span class="line">wordcloud = WordCloud(background_color=<span class="string">&quot;white&quot;</span>, \</span><br><span class="line">                          width=<span class="number">800</span>, \</span><br><span class="line">                          height=<span class="number">600</span>, \</span><br><span class="line">                          font_path=<span class="string">&quot;msyh.ttc&quot;</span>, \</span><br><span class="line">                          max_words=<span class="number">200</span>, \</span><br><span class="line">                          max_font_size=<span class="number">80</span>, \</span><br><span class="line">                          stopwords = excludes, \</span><br><span class="line">                          ).generate(newtxt)</span><br><span class="line">wordcloud.to_file(<span class="string">&#x27;红楼梦基本词云.png&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="Python-第三方库纵览"><a class="header-anchor" href="#Python-第三方库纵览"></a>Python 第三方库纵览</h2><h3 id="网络爬虫方向"><a class="header-anchor" href="#网络爬虫方向"></a>网络爬虫方向</h3><p>自动进行 HTTP 访问并捕获 HTML 页面的程序。</p><h4 id="requests"><a class="header-anchor" href="#requests"></a>requests</h4><p>简洁且简单</p><table><thead><tr><th style="text-align:center">函数</th><th>功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>request()</code></td><td>构建一个请求</td></tr><tr><td style="text-align:center"><code>get()</code></td><td>获取 HTML 网页的主要方法</td></tr><tr><td style="text-align:center"><code>head()</code></td><td>获取 HTML 网页头信息</td></tr><tr><td style="text-align:center"><code>post()</code></td><td>提交 POST 请求</td></tr><tr><td style="text-align:center"><code>patch()</code></td><td>提交局部修改请求</td></tr><tr><td style="text-align:center"><code>delete()</code></td><td>提交删除请求</td></tr><tr><td style="text-align:center"><code>put()</code></td><td>提交 PUT 请求</td></tr></tbody></table><h4 id="scrapy"><a class="header-anchor" href="#scrapy"></a>scrapy</h4><p>快速的、高层次的 web 获取框架</p><h3 id="数据分析方向"><a class="header-anchor" href="#数据分析方向"></a>数据分析方向</h3><h4 id="numpy"><a class="header-anchor" href="#numpy"></a>numpy</h4><p>开源数值计算扩展第三方库，用于处理数据类型相同的多维数据（ndarray），“数组”。</p><h4 id="scipy"><a class="header-anchor" href="#scipy"></a>scipy</h4><p>在 numpy 库的基础沈阳增加了众多的科学、数学以及工程计算中常用的库函数。包括统计、优化、整合、线性代数、傅里叶变换、信号分析、图像处理、常微分方程求解等众多模块。</p><h4 id="pandas"><a class="header-anchor" href="#pandas"></a>pandas</h4><p>基于 numpy 扩展。为解决数据分析任务。</p><h3 id="文本处理方向"><a class="header-anchor" href="#文本处理方向"></a>文本处理方向</h3><h4 id="pdfminer"><a class="header-anchor" href="#pdfminer"></a>pdfminer</h4><p>一个可以从 PDF 文档中提取各类信息的第三方库。</p><h4 id="openpyxl"><a class="header-anchor" href="#openpyxl"></a>openpyxl</h4><p>一个处理 Excel 文档的 Python 第三方库。</p><h4 id="python-docx"><a class="header-anchor" href="#python-docx"></a>python_docx</h4><p>一个处理 Word 文档的第三方库。</p><h4 id="beautifulsoup4"><a class="header-anchor" href="#beautifulsoup4"></a>beautifulsoup4</h4><p>用于解析和处理 HTML 和 XML。</p><h3 id="数据可视化方向"><a class="header-anchor" href="#数据可视化方向"></a>数据可视化方向</h3><p>指根据数据特点将其展示为易于理解的图形的过程。</p><h4 id="matplotlib"><a class="header-anchor" href="#matplotlib"></a>matplotlib</h4><p>主要进行二维图标数据展示，广泛用于科学计算的数据可视化。</p><h4 id="TVTK"><a class="header-anchor" href="#TVTK"></a>TVTK</h4><p>专业可编程的三维可视化工具。</p><h4 id="mayavi"><a class="header-anchor" href="#mayavi"></a>mayavi</h4><p>基于 VTK 开发，完全用 Python 编写。</p><h3 id="用户图形界面方向"><a class="header-anchor" href="#用户图形界面方向"></a>用户图形界面方向</h3><h4 id="PyQt5"><a class="header-anchor" href="#PyQt5"></a>PyQt5</h4><p>最成熟的商业级 GUI 第三方库。</p><h4 id="wxPython"><a class="header-anchor" href="#wxPython"></a>wxPython</h4><p>wxPython是Python语言的一套优秀的GUI图形库，它是跨平台GUI库wxWidgets的Python封装，可以使Python程序员能够轻松地创建健壮可靠、功能强大的图形用户界面的程序。</p><h4 id="PyGTK"><a class="header-anchor" href="#PyGTK"></a>PyGTK</h4><h3 id="机器学习方向"><a class="header-anchor" href="#机器学习方向"></a>机器学习方向</h3><h4 id="scikit-learn"><a class="header-anchor" href="#scikit-learn"></a>scikit-learn</h4><p>一个简单且高效的数据挖掘和数据分析工具。</p><h4 id="TensorFlow"><a class="header-anchor" href="#TensorFlow"></a>TensorFlow</h4><p>Google 基于 DistBelief 进行研发的第二代人工智能学习系统。</p><h4 id="Theano"><a class="header-anchor" href="#Theano"></a>Theano</h4><p>为执行深度学习中大规模神经网络算法而设计，擅长处理多维数组。</p><h3 id="Web-开发方向"><a class="header-anchor" href="#Web-开发方向"></a>Web 开发方向</h3><h4 id="Django"><a class="header-anchor" href="#Django"></a>Django</h4><p>最流行的开源 Web 应用框架。</p><h4 id="Pyramid"><a class="header-anchor" href="#Pyramid"></a>Pyramid</h4><p>相对小巧、快速、灵活的开源 Python Web 框架。</p><h4 id="Flask"><a class="header-anchor" href="#Flask"></a>Flask</h4><p>轻量级 Web 应用框架。</p><h3 id="8-游戏开发方向"><a class="header-anchor" href="#8-游戏开发方向"></a>8.游戏开发方向</h3><h4 id="Pygame"><a class="header-anchor" href="#Pygame"></a>Pygame</h4><p>在 SDL 库基础上进行封装的、面向游戏开发入门的 Python 第三方库。</p><h4 id="Panda3D"><a class="header-anchor" href="#Panda3D"></a>Panda3D</h4><p>一个开源、跨平台的3D渲染和游戏开发库。</p><h4 id="cocos2d"><a class="header-anchor" href="#cocos2d"></a>cocos2d</h4><p>一个构建2D游戏和图形界面交互式应用的框架。</p><h3 id="更多"><a class="header-anchor" href="#更多"></a>更多</h3><h4 id="PIL"><a class="header-anchor" href="#PIL"></a>PIL</h4><p>在图像处理方面的重要第三方库。</p><ul><li>图像归档：<ol><li>对图像进行批处理；</li><li>生成图像预览；</li><li>图像格式转换等。</li></ol></li><li>图像处理：<ol><li>基本处理；</li><li>像素处理；</li><li>颜色处理等。</li></ol></li></ul><h4 id="SymPY"><a class="header-anchor" href="#SymPY"></a>SymPY</h4><p>一个支持符号计算的第三方库。一个全功能的计算机代数系统。</p><h4 id="NLTK"><a class="header-anchor" href="#NLTK"></a>NLTK</h4><p>自然语言处理第三方库。</p><p>语料处理、文本统计、内容理解、情感分析等多种应用。</p><h4 id="WeRoBot"><a class="header-anchor" href="#WeRoBot"></a>WeRoBot</h4><p>一个微信公众号开发框架，也成为微信机器人框架。</p><h4 id="MyQR"><a class="header-anchor" href="#MyQR"></a>MyQR</h4><p>一个能够产生基本二维码、艺术二维码和动态二维码的第三方库。</p><h2 id="附录"><a class="header-anchor" href="#附录"></a>附录</h2><h3 id="常用-Unicode-编码表"><a class="header-anchor" href="#常用-Unicode-编码表"></a>常用 Unicode 编码表</h3><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">范围</th></tr></thead><tbody><tr><td style="text-align:center">基础汉字</td><td style="text-align:center">[0x4e00, 0x9fa5]</td></tr><tr><td style="text-align:center">数字</td><td style="text-align:center">[0x0030, 0x0039]</td></tr><tr><td style="text-align:center">小写字母</td><td style="text-align:center">[0x0061, 0x007a]</td></tr><tr><td style="text-align:center">大写字母</td><td style="text-align:center">[0x0041, 0x005a]</td></tr><tr><td style="text-align:center">箭头</td><td style="text-align:center">[0x2190, 0x21ff]</td></tr><tr><td style="text-align:center">数字运算符</td><td style="text-align:center">[0x2200, 0x22ff]</td></tr><tr><td style="text-align:center">封闭式字母数字</td><td style="text-align:center">[0x2460, 0x24ff]</td></tr><tr><td style="text-align:center">制表符</td><td style="text-align:center">[0x2500, 0x257f]</td></tr><tr><td style="text-align:center">方块元素</td><td style="text-align:center">[0x2580, 0x259f]</td></tr><tr><td style="text-align:center">几何图形</td><td style="text-align:center">[0x25A0, 0x25ff]</td></tr><tr><td style="text-align:center">一般标点符号</td><td style="text-align:center">[0x2000, 0x206f]</td></tr><tr><td style="text-align:center">韩文</td><td style="text-align:center">[0xAC00, 0xD7A3]</td></tr><tr><td style="text-align:center">货币</td><td style="text-align:center">[0x20a0, 0x20cf]</td></tr><tr><td style="text-align:center">泰文</td><td style="text-align:center">[0x0e00, 0x07f]</td></tr><tr><td style="text-align:center">中日韩符号</td><td style="text-align:center">[0x3000, 0x303f]</td></tr><tr><td style="text-align:center">中日韩括号数字</td><td style="text-align:center">[0x3200, 0x32ff]</td></tr></tbody></table><h3 id="转义字符"><a class="header-anchor" href="#转义字符"></a>转义字符</h3><table><thead><tr><th style="text-align:center">符号</th><th>作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>\</code></td><td>（在行尾时）续行符</td></tr><tr><td style="text-align:center"><code>\\</code></td><td>反斜杠符号</td></tr><tr><td style="text-align:center"><code>'</code></td><td>单引号</td></tr><tr><td style="text-align:center"><code>&quot;</code></td><td>双引号</td></tr><tr><td style="text-align:center"><code>\a</code></td><td>响铃</td></tr><tr><td style="text-align:center"><code>\b</code></td><td>退格（Backspace）</td></tr><tr><td style="text-align:center"><code>\e</code></td><td>转义</td></tr><tr><td style="text-align:center"><code>\000</code></td><td>空</td></tr><tr><td style="text-align:center"><code>\n</code></td><td>换行</td></tr><tr><td style="text-align:center"><code>\v</code></td><td>纵向制表符</td></tr><tr><td style="text-align:center"><code>\t</code></td><td>横向制表符</td></tr><tr><td style="text-align:center"><code>\r</code></td><td>回车</td></tr><tr><td style="text-align:center"><code>\f</code></td><td>换页</td></tr></tbody></table><h3 id="基本的Python内置函数"><a class="header-anchor" href="#基本的Python内置函数"></a>基本的Python内置函数</h3><p>Python解释器提供了68个内置函数</p><table><thead><tr><th>函数名称</th><th>函数说明</th></tr></thead><tbody><tr><td><code>abs(x)</code></td><td>x的绝对值，如果x是复数，返回复数的模</td></tr><tr><td><code>all(x)</code></td><td>组合类型变量x中所有元素都为真时返回True，否则返回False；若x为空，返回True</td></tr><tr><td><code>any(x)</code></td><td>组合类型变量x中任一元素都为真时返回True，否则返回False；若x为空，返回False</td></tr><tr><td><code>bin(x)</code></td><td>将整数x转换为等值的二进制字符串<br /><code>bin(1010)</code>的结果是’0b1111110010’</td></tr><tr><td><code>bool(x)</code></td><td>将x转换为Boolean类型，即True或False<br /><code>bool('')</code>的结果是False</td></tr><tr><td><code>chr(i)</code></td><td>返回Unicode为i的字符<br/><code>chr(9996)</code>的结果是’✌ ’</td></tr><tr><td><code>complex(r,i)</code></td><td>创建一个复数 r + i*1j，其中i可以省略<br/><code>complex(10,10)</code>的结果是10+10j</td></tr><tr><td><code>dict()</code></td><td>创建字典类型<br/><code>dict()</code>的结果是一个空字典{}</td></tr><tr><td><code>divmod(a,b)</code></td><td>返回a和b的商及余数<br/><code>divmod(10,3)</code>结果是一个(3,1)</td></tr><tr><td><code>eval(s)</code></td><td>计算字符串s作为Python表达式的值<br/><code>eval('1+99')</code>的结果是100</td></tr><tr><td><code>exec(s)</code></td><td>计算字符串s作为Python语句的值<br /><code>exec('a = 1+999')</code>运行后，变量a的值为1000</td></tr><tr><td><code>float(x)</code></td><td>将x转换成浮点数<br/><code>float(1010)</code>的结果是1010.0</td></tr><tr><td><code>hex(x)</code></td><td>将整数转换为16进制字符串<br/><code>hex(1010)</code>的结果是’0x3f2</td></tr><tr><td><code>input(s)</code></td><td>获取用户输入，其中s是字符串，作为提示信息可选</td></tr><tr><td><code>int(x)</code></td><td>将x转换成整数<br/>int(9.9)的结果是9</td></tr><tr><td><code>list(x)</code></td><td>创建或将变量x转换成一个列表类型<br/><code>list(&#123;10,9,8&#125;)</code>的结果是<code>[8,9,10]</code></td></tr><tr><td><code>max(a1,a2,…)</code></td><td>返回参数的最大值</td></tr><tr><td><code>min(a1,a2,…)</code></td><td>返回参数的最小值</td></tr><tr><td><code>oct(x)</code></td><td>将整数x转换成等值的八进制字符串形式<br /><code>oct(1010)</code>的结果是’0o1762’</td></tr><tr><td><code>open(fname, m)</code></td><td>打开文件，包括文本方式和二进制方式等<br/>其中，m部分可以省略，默认是以文本可读形式打开</td></tr><tr><td><code>ord(c)</code></td><td>返回一个字符的Unicode编码值<br/><code>ord('字')</code>的结果是23383</td></tr><tr><td><code>pow(x,y</code></td><td>返回x的y次幂<br/><code>pow(2,pow(2,2))</code>的结果是16</td></tr><tr><td><code>print(x)</code></td><td>打印变量或字符串x<br/><code>print()</code>的end参数用来表示输出的结尾字符</td></tr><tr><td><code>range(a,b,s)</code></td><td>从a到b(不含)以s为步长产生一个序列<br /><code>list(range(1,10,3))</code>的结果是[1, 4, 7]</td></tr><tr><td><code>reversed(r)</code></td><td>返回组合类型r的逆序迭代形式<br/><code>for i in reversed([1,2,3])</code>将逆序遍历列表</td></tr><tr><td><code>round(n)</code></td><td>四舍五入方式计算n<br/><code>round(10.6)</code>的结果是11</td></tr><tr><td><code>set(x)</code></td><td>将组合数据类型x转换成集合类型<br/><code>set([1,1,1,1])</code>的结果是{1}</td></tr><tr><td><code>sorted(x)</code></td><td>对组合数据类型x进行排序，默认从小到大<br/><code>sorted([1,3,5,2,4])</code>的结果是<code>[1,2,3,4,5]</code></td></tr><tr><td><code>str(x)</code></td><td>将x转换为等值的字符串类型<br/><code>str(0x1010)</code>的结果是’4112’</td></tr><tr><td><code>sum(x)</code></td><td>对组合数据类型x计算求和结果<br/><code>sum([1,3,5,2,4])</code>的结果是15</td></tr><tr><td><code>type(x)</code></td><td>返回变量x的数据类型<br/><code>type(&#123;1:2&#125;)</code>的结果是<code>&lt;class 'dict'&gt;</code></td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> Pyhton </tag>
            
            <tag> 计算机二级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS学习笔记</title>
      <link href="2019/08/13/CSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2019/08/13/CSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.w3school.com.cn/css/css_jianjie.asp">CSS</a>学习笔记</p><hr><h2 id="CSS-概述"><a class="header-anchor" href="#CSS-概述"></a>CSS 概述</h2><ul><li>CSS 指层叠样式表 (<strong>C</strong>ascading <strong>S</strong>tyle <strong>S</strong>heets)</li><li>样式定义<strong>如何显示</strong> HTML 元素</li><li>样式通常存储在<strong>样式表</strong>中</li><li>把样式添加到 HTML 4.0 中，是为了<strong>解决内容与表现分离的问题</strong></li><li><strong>外部样式表</strong>可以极大提高工作效率</li><li>外部样式表通常存储在 <strong>CSS 文件</strong>中</li><li>多个样式定义可<strong>层叠</strong>为一</li></ul><h3 id="样式解决了一个普遍的问题"><a class="header-anchor" href="#样式解决了一个普遍的问题"></a>样式解决了一个普遍的问题</h3><p>HTML 标签原本被设计为用于定义文档内容。通过使用 <code>&lt;h1&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;table&gt;</code> 这样的标签，HTML 的初衷是表达“这是标题”、“这是段落”、“这是表格”之类的信息。同时文档布局由浏览器来完成，而不使用任何的格式化标签。</p><p>由于两种主要的浏览器（Netscape 和 Internet Explorer）不断地将新的 HTML 标签和属性（比如字体标签和颜色属性）添加到 HTML 规范中，创建文档内容清晰地独立于文档表现层的站点变得越来越困难。</p><p>为了解决这个问题，万维网联盟（W3C），这个非营利的标准化联盟，肩负起了 HTML 标准化的使命，并在 HTML 4.0 之外创造出样式（Style）。</p><p>所有的主流浏览器均支持层叠样式表。</p><h3 id="样式表极大地提高了工作效率"><a class="header-anchor" href="#样式表极大地提高了工作效率"></a>样式表极大地提高了工作效率</h3><p>样式表定义如何显示 HTML 元素，就像 HTML 3.2 的字体标签和颜色属性所起的作用那样。样式通常保存在外部的 .css 文件中。通过仅仅编辑一个简单的 CSS 文档，外部样式表使你有能力同时改变站点中所有页面的布局和外观。</p><p>由于允许同时控制多重页面的样式和布局，CSS 可以称得上 WEB 设计领域的一个突破。作为网站开发者，你能够为每个 HTML 元素定义样式，并将之应用于你希望的任意多的页面中。如需进行全局的更新，只需简单地改变样式，然后网站中的所有元素均会自动地更新。</p><h3 id="多重样式将层叠为一个"><a class="header-anchor" href="#多重样式将层叠为一个"></a>多重样式将层叠为一个</h3><p>样式表允许以多种方式规定样式信息。样式可以规定在单个的 HTML 元素中，在 HTML 页的头元素中，或在一个外部的 CSS 文件中。甚至可以在同一个 HTML 文档内部引用多个外部样式表。</p><h4 id="层叠次序-优先顺序"><a class="header-anchor" href="#层叠次序-优先顺序"></a>层叠次序(优先顺序)</h4><p><strong>当同一个 HTML 元素被不止一个样式定义时，会使用哪个样式呢？</strong></p><p>一般而言，所有的样式会根据下面的规则层叠于一个新的虚拟样式表中，其中数字 4 拥有最高的优先权。</p><ol><li>浏览器缺省设置</li><li>外部样式表</li><li>内部样式表（位于 <code>&lt;head&gt; </code>标签内部）</li><li>内联样式（在 HTML 元素内部）</li></ol><p>因此，内联样式（在 HTML 元素内部）拥有最高的优先权，这意味着它将优先于以下的样式声明：<code>&lt;head&gt;</code> 标签中的样式声明，外部样式表中的样式声明，或者浏览器中的样式声明（缺省值）。</p><h2 id="CSS-基础语法"><a class="header-anchor" href="#CSS-基础语法"></a>CSS 基础语法</h2><h3 id="CSS-语法"><a class="header-anchor" href="#CSS-语法"></a>CSS 语法</h3><p>CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selector &#123;declaration1; declaration2; ... declarationN &#125;</span><br></pre></td></tr></table></figure><p>选择器通常是您需要改变样式的 HTML 元素。</p><p>每条声明由一个属性和一个值组成。</p><p>属性（property）是您希望设置的样式属性（style attribute）。每个属性有一个值。属性和值被冒号分开。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selector &#123;property: value&#125;</span><br></pre></td></tr></table></figure><p>下面这行代码的作用是将 h1 元素内的文字颜色定义为红色，同时将字体大小设置为 14 像素。</p><p>在这个例子中，h1 是选择器，color 和 font-size 是属性，red 和 14px 是值。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;<span class="attribute">color</span>:red; <span class="attribute">font-size</span>:<span class="number">14px</span>;&#125;</span><br></pre></td></tr></table></figure><h3 id="值的不同写法和单位"><a class="header-anchor" href="#值的不同写法和单位"></a>值的不同写法和单位</h3><p>除了英文单词 red，我们还可以使用十六进制的颜色值 #ff0000：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123; <span class="attribute">color</span>: <span class="number">#ff0000</span>; &#125;</span><br></pre></td></tr></table></figure><p>为了节约字节，我们可以使用 CSS 的缩写形式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123; <span class="attribute">color</span>: <span class="number">#f00</span>; &#125;</span><br></pre></td></tr></table></figure><p>我们还可以通过两种方法使用 RGB 值：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123; <span class="attribute">color</span>: <span class="built_in">rgb</span>(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>); &#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123; <span class="attribute">color</span>: <span class="built_in">rgb</span>(<span class="number">100%</span>,<span class="number">0%</span>,<span class="number">0%</span>); &#125;</span><br></pre></td></tr></table></figure><p>请注意，当使用 RGB 百分比时，即使当值为 0 时也要写百分比符号。但是在其他的情况下就不需要这么做了。比如说，当尺寸为 0 像素时，0 之后不需要使用 px 单位，因为 0 就是 0，无论单位是什么。</p><h3 id="记得写引号"><a class="header-anchor" href="#记得写引号"></a>记得写引号</h3><p>**提示：**如果值为若干单词，则要给值加引号：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">font-family</span>: <span class="string">&quot;sans serif&quot;</span>;&#125;</span><br></pre></td></tr></table></figure><h3 id="多重声明："><a class="header-anchor" href="#多重声明："></a>多重声明：</h3><p>**提示：**如果要定义不止一个声明，则需要用分号将每个声明分开。下面的例子展示出如何定义一个红色文字的居中段落。最后一条规则是不需要加分号的，因为分号在英语中是一个分隔符号，不是结束符号。然而，大多数有经验的设计师会在每条声明的末尾都加上分号，这么做的好处是，当你从现有的规则中增减声明时，会尽可能地减少出错的可能性。就像这样：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">text-align</span>:center; <span class="attribute">color</span>:red;&#125;</span><br></pre></td></tr></table></figure><p>你应该在每行只描述一个属性，这样可以增强样式定义的可读性，就像这样：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">color</span>: black;</span><br><span class="line">  <span class="attribute">font-family</span>: arial;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="空格和大小写"><a class="header-anchor" href="#空格和大小写"></a>空格和大小写</h3><p>大多数样式表包含不止一条规则，而大多数规则包含不止一个声明。多重声明和空格的使用使得样式表更容易被编辑：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">font-family</span>: Georgia, Palatino, serif;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>是否包含空格不会影响 CSS 在浏览器的工作效果，同样，与 XHTML 不同，CSS 对大小写不敏感。不过存在一个例外：如果涉及到与 HTML 文档一起工作的话，class 和 id 名称对大小写是敏感的。</p><h2 id="CSS-高级语法"><a class="header-anchor" href="#CSS-高级语法"></a>CSS 高级语法</h2><h3 id="选择器的分组"><a class="header-anchor" href="#选择器的分组"></a>选择器的分组</h3><p>你可以对选择器进行分组，这样，被分组的选择器就可以分享相同的声明。用逗号将需要分组的选择器分开。在下面的例子中，我们对所有的标题元素进行了分组。所有的标题元素都是绿色的。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span>,<span class="selector-tag">h2</span>,<span class="selector-tag">h3</span>,<span class="selector-tag">h4</span>,<span class="selector-tag">h5</span>,<span class="selector-tag">h6</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: green;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="继承及其问题"><a class="header-anchor" href="#继承及其问题"></a>继承及其问题</h3><p>根据 CSS，子元素从父元素继承属性。但是它并不总是按此方式工作。看看下面这条规则：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">     <span class="attribute">font-family</span>: Verdana, sans-serif;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>根据上面这条规则，站点的 body 元素将使用 Verdana 字体（假如访问者的系统中存在该字体的话）。</p><p>通过 CSS 继承，子元素将继承最高级元素（在本例中是 body）所拥有的属性（这些子元素诸如 p, td, ul, ol, ul, li, dl, dt,和 dd）。不需要另外的规则，所有 body 的子元素都应该显示 Verdana 字体，子元素的子元素也一样。并且在大部分的现代浏览器中，也确实是这样的。</p><p>但是在那个浏览器大战的血腥年代里，这种情况就未必会发生，那时候对标准的支持并不是企业的优先选择。比方说，Netscape 4 就不支持继承，它不仅忽略继承，而且也忽略应用于 body 元素的规则。IE/Windows 直到 IE6 还存在相关的问题，在表格内的字体样式会被忽略。我们又该如何是好呢？</p><h3 id="友善地对待Netscape-4"><a class="header-anchor" href="#友善地对待Netscape-4"></a>友善地对待Netscape 4</h3><p>幸运地是，你可以通过使用我们称为 “Be Kind to Netscape 4” 的冗余法则来处理旧式浏览器无法理解继承的问题。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>  &#123;</span><br><span class="line">     <span class="attribute">font-family</span>: Verdana, sans-serif;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span>, <span class="selector-tag">td</span>, <span class="selector-tag">ul</span>, <span class="selector-tag">ol</span>, <span class="selector-tag">li</span>, <span class="selector-tag">dl</span>, <span class="selector-tag">dt</span>, <span class="selector-tag">dd</span>  &#123;</span><br><span class="line">     <span class="attribute">font-family</span>: Verdana, sans-serif;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>4.0 浏览器无法理解继承，不过他们可以理解组选择器。这么做虽然会浪费一些用户的带宽，但是如果需要对 Netscape 4 用户进行支持，就不得不这么做。</p><h3 id="继承是一个诅咒吗？"><a class="header-anchor" href="#继承是一个诅咒吗？"></a>继承是一个诅咒吗？</h3><p>如果你不希望 “Verdana, sans-serif” 字体被所有的子元素继承，又该怎么做呢？比方说，你希望段落的字体是 Times。没问题。创建一个针对 p 的特殊规则，这样它就会摆脱父元素的规则：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>  &#123;</span><br><span class="line">     <span class="attribute">font-family</span>: Verdana, sans-serif;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">td</span>, <span class="selector-tag">ul</span>, <span class="selector-tag">ol</span>, <span class="selector-tag">ul</span>, <span class="selector-tag">li</span>, <span class="selector-tag">dl</span>, <span class="selector-tag">dt</span>, <span class="selector-tag">dd</span>  &#123;</span><br><span class="line">     <span class="attribute">font-family</span>: Verdana, sans-serif;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span>  &#123;</span><br><span class="line">     <span class="attribute">font-family</span>: Times, <span class="string">&quot;Times New Roman&quot;</span>, serif;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h2 id="CSS-派生选择器"><a class="header-anchor" href="#CSS-派生选择器"></a>CSS 派生选择器</h2><h3 id="派生选择器"><a class="header-anchor" href="#派生选择器"></a>派生选择器</h3><p><strong>通过依据元素在其位置的上下文关系来定义样式，你可以使标记更加简洁。</strong></p><p>在 CSS1 中，通过这种方式来应用规则的选择器被称为上下文选择器 (contextual selectors)，这是由于它们依赖于上下文关系来应用或者避免某项规则。在 CSS2 中，它们称为派生选择器，但是无论你如何称呼它们，它们的作用都是相同的。</p><p>派生选择器允许你根据文档的上下文关系来确定某个标签的样式。通过合理地使用派生选择器，我们可以使 HTML 代码变得更加整洁。</p><p>比方说，你希望列表中的 strong 元素变为斜体字，而不是通常的粗体字，可以这样定义一个派生选择器：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">li</span> <span class="selector-tag">strong</span> &#123;</span><br><span class="line">    <span class="attribute">font-style</span>: italic;</span><br><span class="line">    <span class="attribute">font-weight</span>: normal;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>请注意标记为 <code>&lt;strong&gt;</code> 的蓝色代码的上下文关系：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">p</span>&gt;&lt;<span class="selector-tag">strong</span>&gt;我是粗体字，不是斜体字，因为我不在列表当中，所以这个规则对我不起作用&lt;/<span class="selector-tag">strong</span>&gt;&lt;/<span class="selector-tag">p</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;<span class="selector-tag">ol</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">li</span>&gt;&lt;<span class="selector-tag">strong</span>&gt;我是斜体字。这是因为 <span class="selector-tag">strong</span> 元素位于 <span class="selector-tag">li</span> 元素内。&lt;/<span class="selector-tag">strong</span>&gt;&lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">li</span>&gt;我是正常的字体。&lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">ol</span>&gt;</span><br></pre></td></tr></table></figure><p>在上面的例子中，只有 li 元素中的 strong 元素的样式为斜体字，无需为 strong 元素定义特别的 class 或 id，代码更加简洁。</p><p>再看看下面的 CSS 规则：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">strong</span> &#123;</span><br><span class="line">     <span class="attribute">color</span>: red;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h2</span> &#123;</span><br><span class="line">     <span class="attribute">color</span>: red;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h2</span> <span class="selector-tag">strong</span> &#123;</span><br><span class="line">     <span class="attribute">color</span>: blue;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>下面是它施加影响的 HTML：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>The strongly emphasized word in this paragraph is<span class="tag">&lt;<span class="name">strong</span>&gt;</span>red<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>This subhead is also red.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>The strongly emphasized word in this subhead is<span class="tag">&lt;<span class="name">strong</span>&gt;</span>blue<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="CSS-id-选择器"><a class="header-anchor" href="#CSS-id-选择器"></a>CSS id 选择器</h2><h3 id="id-选择器"><a class="header-anchor" href="#id-选择器"></a>id 选择器</h3><p><strong>id 选择器可以为标有特定 id 的 HTML 元素指定特定的样式。</strong></p><p><strong>id 选择器以 “#” 来定义。</strong></p><p>下面的两个 id 选择器，第一个可以定义元素的颜色为红色，第二个定义元素的颜色为绿色：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#red</span> &#123;<span class="attribute">color</span>:red;&#125;</span><br><span class="line"><span class="selector-id">#green</span> &#123;<span class="attribute">color</span>:green;&#125;</span><br></pre></td></tr></table></figure><p>下面的 HTML 代码中，id 属性为 red 的 p 元素显示为红色，而 id 属性为 green 的 p 元素显示为绿色。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p id=&quot;red&quot;&gt;这个段落是红色。&lt;/p&gt;</span><br><span class="line">&lt;p id=&quot;green&quot;&gt;这个段落是绿色。&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>**注意：**id 属性只能在每个 HTML 文档中出现一次。想知道原因吗，请参阅 <a href="https://www.w3school.com.cn/xhtml/xhtml_structural_01.asp">XHTML:网站重构</a>。</p><h3 id="id-选择器和派生选择器"><a class="header-anchor" href="#id-选择器和派生选择器"></a>id 选择器和派生选择器</h3><p><strong>在现代布局中，id 选择器常常用于建立派生选择器。</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#sidebar</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line"><span class="attribute">font-style</span>: italic;</span><br><span class="line"><span class="attribute">text-align</span>: right;</span><br><span class="line"><span class="attribute">margin-top</span>: <span class="number">0.5em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的样式只会应用于出现在 id 是 sidebar 的元素内的段落。这个元素很可能是 div 或者是表格单元，尽管它也可能是一个表格或者其他块级元素。它甚至可以是一个内联元素，比如<code> &lt;em&gt;</code> <code>&lt;/em&gt;</code> 或者<code> &lt;span&gt;</code> <code>&lt;/span&gt;</code>，不过这样的用法是非法的，因为不可以在内联元素 <code>&lt;span&gt;</code> 中嵌入<code> &lt;p&gt;</code> （如果你忘记了原因，请参阅 <a href="https://www.w3school.com.cn/xhtml/xhtml_structural_01.asp">XHTML:网站重构</a>）。</p><h4 id="一个选择器，多种用法"><a class="header-anchor" href="#一个选择器，多种用法"></a>一个选择器，多种用法</h4><p><strong>即使被标注为 sidebar 的元素只能在文档中出现一次，这个 id 选择器作为派生选择器也可以被使用很多次：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#sidebar</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line"><span class="attribute">font-style</span>: italic;</span><br><span class="line"><span class="attribute">text-align</span>: right;</span><br><span class="line"><span class="attribute">margin-top</span>: <span class="number">0.5em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#sidebar</span> <span class="selector-tag">h2</span> &#123;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">1em</span>;</span><br><span class="line"><span class="attribute">font-weight</span>: normal;</span><br><span class="line"><span class="attribute">font-style</span>: italic;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">line-height</span>: <span class="number">1.5</span>;</span><br><span class="line"><span class="attribute">text-align</span>: right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，与页面中的其他 p 元素明显不同的是，sidebar 内的 p 元素得到了特殊的处理，同时，与页面中其他所有 h2 元素明显不同的是，sidebar 中的 h2 元素也得到了不同的特殊处理。</p><h3 id="单独的选择器"><a class="header-anchor" href="#单独的选择器"></a>单独的选择器</h3><p><strong>id 选择器即使不被用来创建派生选择器，它也可以独立发挥作用：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#sidebar</span> &#123;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> dotted <span class="number">#000</span>;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据这条规则，id 为 sidebar 的元素将拥有一个像素宽的黑色点状边框，同时其周围会有 10 个像素宽的内边距（padding，内部空白）。老版本的 Windows/IE 浏览器可能会忽略这条规则，除非你特别地定义这个选择器所属的元素：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> <span class="selector-id">#sidebar</span> &#123;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> dotted <span class="number">#000</span>;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CSS-类选择器"><a class="header-anchor" href="#CSS-类选择器"></a>CSS 类选择器</h3><p><strong>在 CSS 中，类选择器以一个点号显示：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.center</span> &#123;<span class="attribute">text-align</span>: center&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，所有拥有 center 类的 HTML 元素均为居中。</p><p>在下面的 HTML 代码中，h1 和 p 元素都有 center 类。这意味着两者都将遵守 “.center” 选择器中的规则。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 class=&quot;center&quot;&gt;</span><br><span class="line">This heading will be center-aligned</span><br><span class="line">&lt;/<span class="selector-tag">h1</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;p class=&quot;center&quot;&gt;</span><br><span class="line">This paragraph will also be center-aligned.</span><br><span class="line">&lt;/<span class="selector-tag">p</span>&gt;</span><br></pre></td></tr></table></figure><p>**注意：**类名的第一个字符不能使用数字！它无法在 Mozilla 或 Firefox 中起作用。</p><p><strong>和 id 一样，class 也可被用作派生选择器：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.fancy</span> <span class="selector-tag">td</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: <span class="number">#f60</span>;</span><br><span class="line"><span class="attribute">background</span>: <span class="number">#666</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面这个例子中，类名为 fancy 的更大的元素内部的表格单元都会以灰色背景显示橙色文字。（名为 fancy 的更大的元素可能是一个表格或者一个 div）</p><p><strong>元素也可以基于它们的类而被选择：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">td</span><span class="selector-class">.fancy</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: <span class="number">#f60</span>;</span><br><span class="line"><span class="attribute">background</span>: <span class="number">#666</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，类名为 fancy 的表格单元将是带有灰色背景的橙色。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;td class=&quot;fancy&quot;&gt;</span><br></pre></td></tr></table></figure><p>你可以将类 fancy 分配给任何一个表格元素任意多的次数。那些以 fancy 标注的单元格都会是带有灰色背景的橙色。那些没有被分配名为 fancy 的类的单元格不会受这条规则的影响。还有一点值得注意，class 为 fancy 的段落也不会是带有灰色背景的橙色，当然，任何其他被标注为 fancy 的元素也不会受这条规则的影响。这都是由于我们书写这条规则的方式，这个效果被限制于被标注为 fancy 的表格单元（即使用 td 元素来选择 fancy 类）。</p><h2 id="创建-CSS"><a class="header-anchor" href="#创建-CSS"></a>创建 CSS</h2><h3 id="如何插入样式表"><a class="header-anchor" href="#如何插入样式表"></a>如何插入样式表</h3><p><strong>当读到一个样式表时，浏览器会根据它来格式化 HTML 文档。插入样式表的方法有三种：</strong></p><h3 id="外部样式表"><a class="header-anchor" href="#外部样式表"></a>外部样式表</h3><p>当样式需要应用于很多页面时，外部样式表将是理想的选择。在使用外部样式表的情况下，你可以通过改变一个文件来改变整个站点的外观。每个页面使用 <code>&lt;link&gt; </code>标签链接到样式表。<code>&lt;link&gt;</code> 标签在（文档的）头部：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;mystyle.css&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器会从文件 mystyle.css 中读到样式声明，并根据它来格式文档。</p><p>外部样式表可以在任何文本编辑器中进行编辑。文件不能包含任何的 html 标签。样式表应该以 .css 扩展名进行保存。下面是一个样式表文件的例子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hr &#123;<span class="attribute">color</span>: sienna;&#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">margin-left</span>: <span class="number">20px</span>;&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;<span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&quot;images/back40.gif&quot;</span>);&#125;</span><br></pre></td></tr></table></figure><p>不要在属性值与单位之间留有空格。假如你使用 “margin-left: 20 px” 而不是 “margin-left: 20px” ，它仅在 IE 6 中有效，但是在 Mozilla/Firefox 或 Netscape 中却无法正常工作。</p><h3 id="内部样式表"><a class="header-anchor" href="#内部样式表"></a>内部样式表</h3><p>当单个文档需要特殊的样式时，就应该使用内部样式表。你可以使用 <code>&lt;style&gt;</code> 标签在文档头部定义内部样式表，就像这样:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"><span class="css">  hr &#123;<span class="attribute">color</span>: sienna;&#125;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">p</span> &#123;<span class="attribute">margin-left</span>: <span class="number">20px</span>;&#125;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">body</span> &#123;<span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&quot;images/back40.gif&quot;</span>);&#125;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="内联样式"><a class="header-anchor" href="#内联样式"></a>内联样式</h3><p>由于要将表现和内容混杂在一起，内联样式会损失掉样式表的许多优势。请慎用这种方法，例如当样式仅需要在一个元素上应用一次时。</p><p>要使用内联样式，你需要在相关的标签内使用样式（style）属性。Style 属性可以包含任何 CSS 属性。本例展示如何改变段落的颜色和左外边距：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color: sienna; margin-left: 20px&quot;</span>&gt;</span></span><br><span class="line">This is a paragraph</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="多重样式"><a class="header-anchor" href="#多重样式"></a>多重样式</h3><p>如果某些属性在不同的样式表中被同样的选择器定义，那么属性值将从更具体的样式表中被继承过来。</p><p>例如，外部样式表拥有针对 h3 选择器的三个属性：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h3</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  <span class="attribute">text-align</span>: left;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">8pt</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>而内部样式表拥有针对 h3 选择器的两个属性：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h3</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: right; </span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">20pt</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>假如拥有内部样式表的这个页面同时与外部样式表链接，那么 h3 得到的样式是：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">color</span>: red; </span><br><span class="line"><span class="attribute">text-align</span>: right; </span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">20pt</span>;</span><br></pre></td></tr></table></figure><p>即颜色属性将被继承于外部样式表，而文字排列（text-alignment）和字体尺寸（font-size）会被内部样式表中的规则取代。</p><h1>CSS样式</h1><h2 id="CSS-背景"><a class="header-anchor" href="#CSS-背景"></a>CSS 背景</h2><p><strong>CSS 允许应用纯色作为背景，也允许使用背景图像创建相当复杂的效果。</strong></p><p><strong>CSS 在这方面的能力远远在 HTML 之上。</strong></p><h3 id="背景色"><a class="header-anchor" href="#背景色"></a>背景色</h3><p>可以使用 <a href="https://www.w3school.com.cn/cssref/pr_background-color.asp">background-color 属性</a>为元素设置背景色。这个属性接受任何合法的颜色值。</p><p>这条规则把元素的背景设置为灰色：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">background-color</span>: gray;&#125;</span><br></pre></td></tr></table></figure><p>如果您希望背景色从元素中的文本向外少有延伸，只需增加一些内边距：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">background-color</span>: gray; <span class="attribute">padding</span>: <span class="number">20px</span>;&#125;</span><br></pre></td></tr></table></figure><p>可以为所有元素设置背景色，这包括 body 一直到 em 和 a 等行内元素。</p><p>background-color 不能继承，其默认值是 transparent。transparent 有“透明”之意。也就是说，如果一个元素没有指定背景色，那么背景就是透明的，这样其祖先元素的背景才能可见。</p><h3 id="背景图像"><a class="header-anchor" href="#背景图像"></a>背景图像</h3><p>要把图像放入背景，需要使用 <a href="https://www.w3school.com.cn/cssref/pr_background-image.asp">background-image 属性</a>。background-image 属性的默认值是 none，表示背景上没有放置任何图像。</p><p>如果需要设置一个背景图像，必须为这个属性设置一个 URL 值：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;<span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">/i/eg_bg_04.gif</span>);&#125;</span><br></pre></td></tr></table></figure><p>大多数背景都应用到 body 元素，不过并不仅限于此。</p><p>下面例子为一个段落应用了一个背景，而不会对文档的其他部分应用背景：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-class">.flower</span> &#123;<span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">/i/eg_bg_03.gif</span>);&#125;</span><br></pre></td></tr></table></figure><p>您甚至可以为行内元素设置背景图像，下面的例子为一个链接设置了背景图像：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-class">.radio</span> &#123;<span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">/i/eg_bg_07.gif</span>);&#125;</span><br></pre></td></tr></table></figure><p>理论上讲，甚至可以向 textareas 和 select 等替换元素的背景应用图像，不过并不是所有用户代理都能很好地处理这种情况。</p><p>另外还要补充一点，background-image 也不能继承。事实上，所有背景属性都不能继承。</p><h3 id="背景重复"><a class="header-anchor" href="#背景重复"></a>背景重复</h3><p>如果需要在页面上对背景图像进行平铺，可以使用 <a href="https://www.w3school.com.cn/cssref/pr_background-repeat.asp">background-repeat 属性</a>。</p><p>属性值 repeat 导致图像在水平垂直方向上都平铺，就像以往背景图像的通常做法一样。repeat-x 和 repeat-y 分别导致图像只在水平或垂直方向上重复，no-repeat 则不允许图像在任何方向上平铺。</p><p>默认地，背景图像将从一个元素的左上角开始。请看下面的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">body</span><br><span class="line">  &#123; </span><br><span class="line">  background-image: url(&#x2F;i&#x2F;eg_bg_03.gif);</span><br><span class="line">  background-repeat: repeat-y;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="背景定位"><a class="header-anchor" href="#背景定位"></a>背景定位</h3><p>可以利用 <a href="https://www.w3school.com.cn/cssref/pr_background-position.asp">background-position 属性</a>改变图像在背景中的位置。</p><p>下面的例子在 body 元素中将一个背景图像居中放置：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span></span><br><span class="line">  &#123; </span><br><span class="line">    <span class="attribute">background-image</span>:<span class="built_in">url</span>(<span class="string">&#x27;/i/eg_bg_03.gif&#x27;</span>);</span><br><span class="line">    <span class="attribute">background-repeat</span>:no-repeat;</span><br><span class="line">    <span class="attribute">background-position</span>:center;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>为 background-position 属性提供值有很多方法。首先，可以使用一些关键字：top、bottom、left、right 和 center。通常，这些关键字会成对出现，不过也不总是这样。还可以使用长度值，如 100px 或 5cm，最后也可以使用百分数值。不同类型的值对于背景图像的放置稍有差异。</p><h3 id="关键字"><a class="header-anchor" href="#关键字"></a>关键字</h3><p>图像放置关键字最容易理解，其作用如其名称所表明的。例如，top right 使图像放置在元素内边距区的右上角。</p><p>根据规范，位置关键字可以按任何顺序出现，只要保证不超过两个关键字 - 一个对应水平方向，另一个对应垂直方向。</p><p>如果只出现一个关键字，则认为另一个关键字是 center。</p><p>所以，如果希望每个段落的中部上方出现一个图像，只需声明如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span></span><br><span class="line">  &#123; </span><br><span class="line">    <span class="attribute">background-image</span>:<span class="built_in">url</span>(<span class="string">&#x27;bgimg.gif&#x27;</span>);</span><br><span class="line">    <span class="attribute">background-repeat</span>:no-repeat;</span><br><span class="line">    <span class="attribute">background-position</span>:top;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>下面是等价的位置关键字：</p><table><thead><tr><th style="text-align:left">单一关键字</th><th style="text-align:left">等价的关键字</th></tr></thead><tbody><tr><td style="text-align:left">center</td><td style="text-align:left">center center</td></tr><tr><td style="text-align:left">top</td><td style="text-align:left">top center 或 center top</td></tr><tr><td style="text-align:left">bottom</td><td style="text-align:left">bottom center 或 center bottom</td></tr><tr><td style="text-align:left">right</td><td style="text-align:left">right center 或 center right</td></tr><tr><td style="text-align:left">left</td><td style="text-align:left">left center 或 center left</td></tr></tbody></table><h3 id="百分数值"><a class="header-anchor" href="#百分数值"></a>百分数值</h3><p>百分数值的表现方式更为复杂。假设你希望用百分数值将图像在其元素中居中，这很容易：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span></span><br><span class="line">  &#123; </span><br><span class="line">    <span class="attribute">background-image</span>:<span class="built_in">url</span>(<span class="string">&#x27;/i/eg_bg_03.gif&#x27;</span>);</span><br><span class="line">    <span class="attribute">background-repeat</span>:no-repeat;</span><br><span class="line">    <span class="attribute">background-position</span>:<span class="number">50%</span> <span class="number">50%</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这会导致图像适当放置，其中心与其元素的中心对齐。**换句话说，百分数值同时应用于元素和图像。**也就是说，图像中描述为 50% 50% 的点（中心点）与元素中描述为 50% 50% 的点（中心点）对齐。</p><p>如果图像位于 0% 0%，其左上角将放在元素内边距区的左上角。如果图像位置是 100% 100%，会使图像的右下角放在右边距的右下角。</p><p>因此，如果你想把一个图像放在水平方向 2/3、垂直方向 1/3 处，可以这样声明：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span></span><br><span class="line">  &#123; </span><br><span class="line">    <span class="attribute">background-image</span>:<span class="built_in">url</span>(<span class="string">&#x27;/i/eg_bg_03.gif&#x27;</span>);</span><br><span class="line">    <span class="attribute">background-repeat</span>:no-repeat;</span><br><span class="line">    <span class="attribute">background-position</span>:<span class="number">66%</span> <span class="number">33%</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果只提供一个百分数值，所提供的这个值将用作水平值，垂直值将假设为 50%。这一点与关键字类似。</p><p>background-position 的默认值是 0% 0%，在功能上相当于 top left。这就解释了背景图像为什么总是从元素内边距区的左上角开始平铺，除非您设置了不同的位置值。</p><h3 id="长度值"><a class="header-anchor" href="#长度值"></a>长度值</h3><p>长度值解释的是元素内边距区左上角的偏移。偏移点是图像的左上角。</p><p>比如，如果设置值为 50px 100px，图像的左上角将在元素内边距区左上角向右 50 像素、向下 100 像素的位置上：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span></span><br><span class="line">  &#123; </span><br><span class="line">    <span class="attribute">background-image</span>:<span class="built_in">url</span>(<span class="string">&#x27;/i/eg_bg_03.gif&#x27;</span>);</span><br><span class="line">    <span class="attribute">background-repeat</span>:no-repeat;</span><br><span class="line">    <span class="attribute">background-position</span>:<span class="number">50px</span> <span class="number">100px</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>注意，这一点与百分数值不同，因为偏移只是从一个左上角到另一个左上角。也就是说，图像的左上角与 background-position 声明中的指定的点对齐。</p><h3 id="背景关联"><a class="header-anchor" href="#背景关联"></a>背景关联</h3><p>如果文档比较长，那么当文档向下滚动时，背景图像也会随之滚动。当文档滚动到超过图像的位置时，图像就会消失。</p><p>您可以通过 <a href="https://www.w3school.com.cn/cssref/pr_background-attachment.asp">background-attachment 属性</a>防止这种滚动。通过这个属性，可以声明图像相对于可视区是固定的（fixed），因此不会受到滚动的影响：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> </span><br><span class="line">  &#123;</span><br><span class="line">  <span class="attribute">background-image</span>:<span class="built_in">url</span>(<span class="string">/i/eg_bg_02.gif</span>);</span><br><span class="line">  <span class="attribute">background-repeat</span>:no-repeat;</span><br><span class="line">  <span class="attribute">background-attachment</span>:fixed</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="CSS-背景属性"><a class="header-anchor" href="#CSS-背景属性"></a>CSS 背景属性</h3><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/pr_background.asp">background</a></td><td style="text-align:left">简写属性，作用是将背景属性设置在一个声明中。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/pr_background-attachment.asp">background-attachment</a></td><td style="text-align:left">背景图像是否固定或者随着页面的其余部分滚动。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/pr_background-color.asp">background-color</a></td><td style="text-align:left">设置元素的背景颜色。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/pr_background-image.asp">background-image</a></td><td style="text-align:left">把图像设置为背景。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/pr_background-position.asp">background-position</a></td><td style="text-align:left">设置背景图像的起始位置。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/pr_background-repeat.asp">background-repeat</a></td><td style="text-align:left">设置背景图像是否及如何重复。</td></tr></tbody></table><h3 id="CSS-背景实例"><a class="header-anchor" href="#CSS-背景实例"></a>CSS 背景实例</h3><ul><li><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=csse_background-color">设置背景颜色</a></p><p>本例演示如何为元素设置背景颜色。</p></li><li><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=csse_text_background">设置文本的背景颜色</a></p><p>本例颜色如何设置部分文本的背景颜色。</p></li><li><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=csse_background-image">将图像设置为背景</a></p><p>本例演示如何将图像设置为背景。</p></li><li><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=csse_background-image_2">将图像设置为背景 2</a></p><p>本例演示如何为多个元素同时设置背景图像。</p></li><li><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=csse_background-repeat">如何重复背景图像</a></p><p>本例演示如何重复背景图像。</p></li><li><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=csse_background-repeaty">如何在垂直方向重复背景图像</a></p><p>本例演示如何垂直地重复背景图像。</p></li><li><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=csse_background-repeatx">如何在水平方向重复背景图像</a></p><p>本例演示如何水平地重复背景图像。</p></li><li><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=csse_background-repeat_no-repeat">如何仅显示一次背景图像</a></p><p>本例演示如何仅显示一次背景图像。</p></li><li><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=csse_background-position">如何放置背景图像</a></p><p>本例演示如何在页面上放置背景图像。</p></li><li><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=csse_background-position_percent">如何使用%来定位背景图像</a></p><p>本例演示如何使用百分比来在页面上定位背景图像。</p></li><li><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=csse_background-position_pixel">如何使用像素来定位背景图像</a></p><p>本例演示如何使用像素来在页面上定位背景图像。</p></li><li><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=csse_background-attachment">如何设置固定的背景图像</a></p><p>本例演示如何设置固定的背景图像。图像不会随着页面的其他部分滚动。</p></li><li><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=csse_background">所有背景属性在一个声明之中</a></p><p>本例演示如何使用简写属性来将所有背景属性设置在一个声明之中。</p></li></ul><h2 id="CSS-文本"><a class="header-anchor" href="#CSS-文本"></a><a href="https://www.w3school.com.cn/css/css_text.asp">CSS 文本</a></h2><p><strong>CSS 文本属性可定义文本的外观。</strong></p><p><strong>通过文本属性，您可以改变文本的颜色、字符间距，对齐文本，装饰文本，对文本进行缩进，等等。</strong></p><h2 id="CSS-文本属性"><a class="header-anchor" href="#CSS-文本属性"></a>CSS 文本属性</h2><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/pr_text_color.asp">color</a></td><td style="text-align:left">设置文本颜色</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/pr_text_direction.asp">direction</a></td><td style="text-align:left">设置文本方向。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/pr_dim_line-height.asp">line-height</a></td><td style="text-align:left">设置行高。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/pr_text_letter-spacing.asp">letter-spacing</a></td><td style="text-align:left">设置字符间距。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/pr_text_text-align.asp">text-align</a></td><td style="text-align:left">对齐元素中的文本。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/pr_text_text-decoration.asp">text-decoration</a></td><td style="text-align:left">向文本添加修饰。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/pr_text_text-indent.asp">text-indent</a></td><td style="text-align:left">缩进元素中文本的首行。</td></tr><tr><td style="text-align:left">text-shadow</td><td style="text-align:left">设置文本阴影。CSS2 包含该属性，但是 CSS2.1 没有保留该属性。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/pr_text_text-transform.asp">text-transform</a></td><td style="text-align:left">控制元素中的字母。</td></tr><tr><td style="text-align:left">unicode-bidi</td><td style="text-align:left">设置文本方向。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/pr_text_white-space.asp">white-space</a></td><td style="text-align:left">设置元素中空白的处理方式。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/pr_text_word-spacing.asp">word-spacing</a></td><td style="text-align:left">设置字间距。</td></tr></tbody></table><h2 id="CSS-字体"><a class="header-anchor" href="#CSS-字体"></a><a href="https://www.w3school.com.cn/css/css_font.asp">CSS 字体</a></h2><p><strong>CSS 字体属性定义文本的字体系列、大小、加粗、风格（如斜体）和变形（如小型大写字母）。</strong></p><h3 id="CSS-字体属性"><a class="header-anchor" href="#CSS-字体属性"></a>CSS 字体属性</h3><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/pr_font_font.asp">font</a></td><td style="text-align:left">简写属性。作用是把所有针对字体的属性设置在一个声明中。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/pr_font_font-family.asp">font-family</a></td><td style="text-align:left">设置字体系列。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/pr_font_font-size.asp">font-size</a></td><td style="text-align:left">设置字体的尺寸。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/pr_font_font-size-adjust.asp">font-size-adjust</a></td><td style="text-align:left">当首选字体不可用时，对替换字体进行智能缩放。（CSS2.1 已删除该属性。）</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/pr_font_font-stretch.asp">font-stretch</a></td><td style="text-align:left">对字体进行水平拉伸。（CSS2.1 已删除该属性。）</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/pr_font_font-style.asp">font-style</a></td><td style="text-align:left">设置字体风格。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/pr_font_font-variant.asp">font-variant</a></td><td style="text-align:left">以小型大写字体或者正常字体显示文本。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/pr_font_weight.asp">font-weight</a></td><td style="text-align:left">设置字体的粗细。</td></tr></tbody></table><h2 id="CSS-链接"><a class="header-anchor" href="#CSS-链接"></a><a href="https://www.w3school.com.cn/css/css_link.asp">CSS 链接</a></h2><p><strong>我们能够以不同的方法为链接设置样式。</strong></p><h3 id="设置链接的样式"><a class="header-anchor" href="#设置链接的样式"></a>设置链接的样式</h3><p>能够设置链接样式的 CSS 属性有很多种（例如 color, font-family, background 等等）。</p><p>链接的特殊性在于能够根据它们所处的状态来设置它们的样式。</p><p>链接的四种状态：</p><ul><li>a:link - 普通的、未被访问的链接</li><li>a:visited - 用户已访问的链接</li><li>a:hover - 鼠标指针位于链接的上方</li><li>a:active - 链接被点击的时刻</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span> &#123;<span class="attribute">color</span>:<span class="number">#FF0000</span>;&#125;<span class="comment">/* 未被访问的链接 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;<span class="attribute">color</span>:<span class="number">#00FF00</span>;&#125;<span class="comment">/* 已被访问的链接 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;<span class="attribute">color</span>:<span class="number">#FF00FF</span>;&#125;<span class="comment">/* 鼠标指针移动到链接上 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123;<span class="attribute">color</span>:<span class="number">#0000FF</span>;&#125;<span class="comment">/* 正在被点击的链接 */</span></span><br></pre></td></tr></table></figure><p>当为链接的不同状态设置样式时，请按照以下次序规则：</p><ul><li>a:hover 必须位于 a:link 和 a:visited 之后</li><li>a:active 必须位于 a:hover 之后</li></ul><h3 id="常见的链接样式"><a class="header-anchor" href="#常见的链接样式"></a>常见的链接样式</h3><p>在上面的例子中，链接根据其状态改变颜色。</p><p>让我们看看其他几种常见的设置链接样式的方法：</p><h4 id="文本修饰"><a class="header-anchor" href="#文本修饰"></a>文本修饰</h4><p>text-decoration 属性大多用于去掉链接中的下划线：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span> &#123;<span class="attribute">text-decoration</span>:none;&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;<span class="attribute">text-decoration</span>:none;&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;<span class="attribute">text-decoration</span>:underline;&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123;<span class="attribute">text-decoration</span>:underline;&#125;</span><br></pre></td></tr></table></figure><h3 id="背景色-v2"><a class="header-anchor" href="#背景色-v2"></a>背景色</h3><p>background-color 属性规定链接的背景色：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span> &#123;<span class="attribute">background-color</span>:<span class="number">#B2FF99</span>;&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;<span class="attribute">background-color</span>:<span class="number">#FFFF85</span>;&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;<span class="attribute">background-color</span>:<span class="number">#FF704D</span>;&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123;<span class="attribute">background-color</span>:<span class="number">#FF704D</span>;&#125;</span><br></pre></td></tr></table></figure><h2 id="CSS-列表"><a class="header-anchor" href="#CSS-列表"></a><a href="https://www.w3school.com.cn/css/css_list.asp">CSS 列表</a></h2><p><strong>CSS 列表属性允许你放置、改变列表项标志，或者将图像作为列表项标志。</strong></p><h3 id="CSS-列表属性"><a class="header-anchor" href="#CSS-列表属性"></a>CSS 列表属性</h3><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/pr_list-style.asp">list-style</a></td><td style="text-align:left">简写属性。用于把所有用于列表的属性设置于一个声明中。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/pr_list-style-image.asp">list-style-image</a></td><td style="text-align:left">将图象设置为列表项标志。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/pr_list-style-position.asp">list-style-position</a></td><td style="text-align:left">设置列表中列表项标志的位置。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/pr_list-style-type.asp">list-style-type</a></td><td style="text-align:left">设置列表项标志的类型。</td></tr></tbody></table><h2 id="CSS-表格"><a class="header-anchor" href="#CSS-表格"></a><a href="https://www.w3school.com.cn/css/css_table.asp">CSS 表格</a></h2><p><strong>CSS 表格属性可以帮助您极大地改善表格的外观。</strong></p><h3 id="CSS-表格属性"><a class="header-anchor" href="#CSS-表格属性"></a>CSS 表格属性</h3><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/pr_tab_border-collapse.asp">border-collapse</a></td><td style="text-align:left">设置是否把表格边框合并为单一的边框。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/pr_tab_border-spacing.asp">border-spacing</a></td><td style="text-align:left">设置分隔单元格边框的距离。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/pr_tab_caption-side.asp">caption-side</a></td><td style="text-align:left">设置表格标题的位置。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/pr_tab_empty-cells.asp">empty-cells</a></td><td style="text-align:left">设置是否显示表格中的空单元格。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/pr_tab_table-layout.asp">table-layout</a></td><td style="text-align:left">设置显示单元、行和列的算法。</td></tr></tbody></table><h2 id="CSS-轮廓"><a class="header-anchor" href="#CSS-轮廓"></a>CSS 轮廓</h2><p><strong>轮廓（outline）是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。</strong></p><p><strong>CSS outline 属性规定元素轮廓的样式、颜色和宽度。</strong></p><h3 id="CSS-边框属性"><a class="header-anchor" href="#CSS-边框属性"></a>CSS 边框属性</h3><p>“CSS” 列中的数字指示哪个 CSS 版本定义了该属性。</p><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">描述</th><th style="text-align:left">CSS</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/pr_outline.asp">outline</a></td><td style="text-align:left">在一个声明中设置所有的轮廓属性。</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/pr_outline-color.asp">outline-color</a></td><td style="text-align:left">设置轮廓的颜色。</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/pr_outline-style.asp">outline-style</a></td><td style="text-align:left">设置轮廓的样式。</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/cssref/pr_outline-width.asp">outline-width</a></td><td style="text-align:left">设置轮廓的宽度。</td><td style="text-align:left">2</td></tr></tbody></table><h1>CSS 框模型</h1><h2 id="CSS-框模型概述"><a class="header-anchor" href="#CSS-框模型概述"></a>CSS 框模型概述</h2><p><strong>CSS 框模型 (Box Model) 规定了元素框处理元素内容、内边距、边框 和 外边距 的方式。</strong></p><p>元素框的最内部分是实际的内容，直接包围内容的是内边距。内边距呈现了元素的背景。内边距的边缘是边框。边框以外是外边距，外边距默认是透明的，因此不会遮挡其后的任何元素。</p><p>**提示：**背景应用于由内容和内边距、边框组成的区域。</p><p>内边距、边框和外边距都是可选的，默认值是零。但是，许多元素将由用户代理样式表设置外边距和内边距。可以通过将元素的 margin 和 padding 设置为零来覆盖这些浏览器样式。这可以分别进行，也可以使用通用选择器对所有元素进行设置：</p><h2 id="背景与边框"><a class="header-anchor" href="#背景与边框"></a>背景与边框</h2>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML基本内容</title>
      <link href="2019/08/09/HTML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2019/08/09/HTML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>HTML是名词，CSS是形容词，JavaScript是动词</p><hr><h2 id="HTML-简介"><a class="header-anchor" href="#HTML-简介"></a>HTML 简介</h2><p>HTML 是用来描述网页的一种语言。</p><ul><li>HTML 指的是超文本标记语言 (<strong>H</strong>yper <strong>T</strong>ext <strong>M</strong>arkup <strong>L</strong>anguage)</li><li>HTML 不是一种编程语言，而是一种<strong>标记语言</strong> (markup language)</li><li>标记语言是一套<strong>标记标签</strong> (markup tag)</li><li>HTML 使用<strong>标记标签</strong>来描述网页</li></ul><h4 id="HTML-标签"><a class="header-anchor" href="#HTML-标签"></a>HTML 标签</h4><ul><li>HTML 标签是由<strong>尖括号</strong>包围的关键词，比如 <code>&lt;html&gt;</code></li><li>HTML 标签通常是<strong>成对出现</strong>的，比如<code>&lt;b&gt;</code>和 <code>&lt;/b&gt;</code></li><li>标签对中的第一个标签是<strong>开始标签</strong>，第二个标签是<strong>结束标签</strong></li><li>开始和结束标签也被称为<strong>开放标签</strong>和<strong>闭合标签</strong></li></ul><h4 id="HTML-文档-网页"><a class="header-anchor" href="#HTML-文档-网页"></a>HTML 文档 = 网页</h4><ul><li>HTML 文档<strong>描述网页</strong></li><li>HTML 文档<strong>包含 HTML 标签</strong>和纯文本</li><li>HTML 文档也被称为<strong>网页</strong></li></ul><h2 id="HTML基础"><a class="header-anchor" href="#HTML基础"></a>HTML基础</h2><h4 id="HTML-标题"><a class="header-anchor" href="#HTML-标题"></a>HTML 标题</h4><p>HTML 标题（Heading）是通过<code>&lt;h1&gt;</code> - <code>&lt;h6&gt;</code> 等标签进行定义的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is a heading<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>This is a heading<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>This is a heading<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="HTML-段落"><a class="header-anchor" href="#HTML-段落"></a>HTML 段落</h4><p>HTML 段落是通过 <code>&lt;p&gt;</code> 标签进行定义的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This is another paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="HTML-链接"><a class="header-anchor" href="#HTML-链接"></a>HTML 链接</h4><p>HTML 链接是通过 <code>&lt;a&gt; </code>标签进行定义的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.w3school.com.cn&quot;</span>&gt;</span>This is a link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="HTML-图像"><a class="header-anchor" href="#HTML-图像"></a>HTML 图像</h4><p>HTML 图像是通过 <code>&lt;img&gt;</code> 标签进行定义的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;xxxx.jpg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;104&quot;</span> <span class="attr">height</span>=<span class="string">&quot;142&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="HTML-元素"><a class="header-anchor" href="#HTML-元素"></a>HTML 元素</h2><p><strong>HTML 文档是由 HTML 元素定义的。</strong></p><p>HTML 元素指的是从开始标签（start tag）到结束标签（end tag）的所有代码。</p><blockquote><p>开始标签常被称为开放标签（opening tag），结束标签常称为闭合标签（closing tag）。</p></blockquote><p><strong>HTML 元素语法</strong></p><ul><li>HTML 元素以<strong>开始标签</strong>起始</li><li>HTML 元素以<strong>结束标签</strong>终止</li><li>元素的内容是开始标签与结束标签之间的内容</li><li>某些 HTML 元素具有<strong>空内容</strong>（empty content）</li><li>空元素<strong>在开始标签中进行关闭</strong>（以开始标签的结束而结束）</li><li>大多数 HTML 元素可拥有<strong>属性</strong></li><li>大多数 HTML 元素可以<strong>嵌套</strong>（可以包含其他 HTML 元素）。</li></ul><p><strong><code>&lt;p&gt;</code> 元素：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This is my first paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个 <code>&lt;p&gt;</code> 元素定义了 HTML 文档中的一个段落。</p><p>这个元素拥有一个开始标签 <code>&lt;p&gt;</code>，以及一个结束标签 <code>&lt;/p&gt;</code>。</p><p>元素内容是：This is my first paragraph。</p><p><strong><code>&lt;body&gt;</code> 元素：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This is my first paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;body&gt;</code> 元素定义了 HTML 文档的主体。</p><p>这个元素拥有一个开始标签 <code>&lt;body&gt;</code>，以及一个结束标签 <code>&lt;/body&gt;</code>。</p><p>元素内容是另一个 HTML 元素（<code>&lt;p&gt;</code>元素）。</p><p><strong><code>&lt;html&gt;</code> 元素：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This is my first paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;html&gt;</code> 元素定义了整个 HTML 文档。</p><p>这个元素拥有一个开始标签 <code>&lt;html&gt;</code>，以及一个结束标签 <code>&lt;/html&gt;</code>。</p><p>元素内容是另一个 HTML 元素（body 元素）。</p><p><strong>空的 HTML 元素</strong></p><p>没有内容的 HTML 元素被称为空元素。空元素是在开始标签中关闭的。</p><p><code>&lt;br&gt;</code> 就是没有关闭标签的空元素（<code>&lt;br&gt;</code> 标签定义换行）。在 XHTML、XML 以及未来版本的 HTML 中，所有元素都必须被关闭。</p><p>在开始标签中添加斜杠，比如 <code>&lt;br /&gt;</code>，是关闭空元素的正确方法，HTML、XHTML 和 XML 都接受这种方式。</p><p>即使 <code>&lt;br&gt;</code> 在所有浏览器中都是有效的，但使用 <code>&lt;br /&gt;</code> 其实是更长远的保障。</p><h2 id="HTML-属性"><a class="header-anchor" href="#HTML-属性"></a>HTML 属性</h2><ul><li>HTML 标签可以拥有<strong>属性</strong>。属性提供了有关 HTML 元素的<strong>更多的信息</strong>。</li><li>属性总是以名称/值对的形式出现，比如：<strong>name=“value”</strong>。</li><li>属性总是在 HTML 元素的<strong>开始标签</strong>中规定。</li><li>属性值应该始终被包括在引号内。双引号是最常用的，不过使用单引号也没有问题。（在某些个别的情况下，比如属性值本身就含有双引号，那么必须使用单引号）</li></ul><p><a href="https://www.w3school.com.cn/tags/html_ref_standardattributes.asp">HTML 标准属性参考手册</a></p><p><a href="https://www.w3school.com.cn/tags/html_ref_byfunc.asp">完整的 HTML 参考手册</a></p><h2 id="HTML标题"><a class="header-anchor" href="#HTML标题"></a>HTML标题</h2><p>标题（Heading）是通过 <code>&lt;h1&gt;</code> - <code>&lt;h6&gt; </code>等标签进行定义的。</p><p><code>&lt;h1&gt;</code> 定义最大的标题。<code>&lt;h6&gt;</code> 定义最小的标题。</p><blockquote><p>浏览器会自动地在标题的前后添加空行。</p><p>默认情况下，HTML 会自动地在块级元素前后添加一个额外的空行，比如段落、标题元素前后。</p></blockquote><p><strong>标题很重要</strong></p><p>请确保将 HTML heading 标签只用于标题。不要仅仅是为了产生粗体或大号的文本而使用标题。</p><p>搜索引擎使用标题为您的网页的结构和内容编制索引。</p><p>因为用户可以通过标题来快速浏览您的网页，所以用标题来呈现文档结构是很重要的。</p><p>应该将 h1 用作主标题（最重要的），其后是 h2（次重要的），再其次是 h3，以此类推。</p><h3 id="HTML-水平线"><a class="header-anchor" href="#HTML-水平线"></a>HTML 水平线</h3><p><code>&lt;hr/&gt; </code>标签在 HTML 页面中创建水平线。可用于分隔内容。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a paragraph<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a paragraph<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a paragraph<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>使用水平线 (<code>&lt;hr&gt;</code> 标签) 来分隔文章中的小节是一个办法（但并不是唯一的办法）。</p></blockquote><h3 id="HTML-注释"><a class="header-anchor" href="#HTML-注释"></a>HTML 注释</h3><p>可以将注释插入 HTML 代码中，这样可以提高其可读性，使代码更易被人理解。浏览器会忽略注释，也不会显示它们。</p><p><strong>注释标签</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- This is a comment --&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>开始括号之后（左边的括号）需要紧跟一个叹号，结束括号之前（右边的括号）不需要。</p><p>合理地使用注释可以对未来的代码编辑工作产生帮助</p></blockquote><p><strong>条件注释</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--[if IE 8]&gt;</span></span><br><span class="line"><span class="comment">    .... some HTML here ....</span></span><br><span class="line"><span class="comment">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>条件注释定义只有 Internet Explorer 执行的 HTML 标签。</p></blockquote><h2 id="HTML-段落-v2"><a class="header-anchor" href="#HTML-段落-v2"></a>HTML 段落</h2><p>段落是通过 <code>&lt;p&gt;</code> 标签定义的。</p><blockquote><p>浏览器会自动地在段落的前后添加空行。（<code>&lt;p&gt;</code> 是块级元素）</p><p>使用空的段落标记<code>&lt;p&gt;``&lt;/p&gt;</code>去插入一个空行是个坏习惯。用 <code>&lt;br/&gt;</code> 标签代替它！</p><p>不要用 <code>&lt;br/&gt;</code> 标签去创建列表</p></blockquote><h3 id="HTML-折行"><a class="header-anchor" href="#HTML-折行"></a>HTML 折行</h3><p>不产生一个新段落的情况下进行换行（新行），请使用 <code>&lt;br/&gt;</code> 标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This is<span class="tag">&lt;<span class="name">br</span> /&gt;</span>a para<span class="tag">&lt;<span class="name">br</span> /&gt;</span>graph with line breaks<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><code>&lt;br/&gt;</code> 元素是一个空的 HTML 元素。由于关闭标签没有任何意义，因此它没有结束标签。</p><p>无法通过在 HTML 代码中添加额外的空格或换行来改变输出的效果</p><p>所有连续的空格或空行都会被算作一个空格</p></blockquote><h2 id="HTML-样式"><a class="header-anchor" href="#HTML-样式"></a>HTML 样式</h2><p><code>style</code> 属性用于改变 HTML 元素的样式。</p><h2 id="不赞成使用的标签和属性"><a class="header-anchor" href="#不赞成使用的标签和属性"></a>不赞成使用的标签和属性</h2><p>在 HTML 4 中，有若干的标签和属性是被废弃的。被废弃（Deprecated）的意思是在未来版本的 HTML 和 XHTML 中将不支持这些标签和属性。</p><p>这里传达的信息很明确：请避免使用这些被废弃的标签和属性！</p><h3 id="应该避免使用下面这些标签和属性："><a class="header-anchor" href="#应该避免使用下面这些标签和属性："></a>应该避免使用下面这些标签和属性：</h3><table><thead><tr><th style="text-align:left">标签</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>&lt;center&gt;</code></td><td style="text-align:left">定义居中的内容。</td></tr><tr><td style="text-align:left"><code>&lt;font&gt;</code> 和<code> &lt;basefont&gt;</code></td><td style="text-align:left">定义 HTML 字体。</td></tr><tr><td style="text-align:left"><code>&lt;s&gt;</code> 和 <code>&lt;strike&gt;</code></td><td style="text-align:left">定义删除线文本</td></tr><tr><td style="text-align:left"><code>&lt;u&gt;</code></td><td style="text-align:left">定义下划线文本</td></tr><tr><td style="text-align:left"><strong>属性</strong></td><td style="text-align:left"><strong>描述</strong></td></tr><tr><td style="text-align:left">align</td><td style="text-align:left">定义文本的对齐方式</td></tr><tr><td style="text-align:left">bgcolor</td><td style="text-align:left">定义背景颜色</td></tr><tr><td style="text-align:left">color</td><td style="text-align:left">定义文本颜色</td></tr></tbody></table><p>对于以上这些标签和属性：请使用样式代替！</p><h3 id="背景颜色"><a class="header-anchor" href="#背景颜色"></a>背景颜色</h3><p><code>background-color</code> 属性为元素定义了背景颜色</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">style</span>=<span class="string">&quot;background-color:black&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">style</span>=<span class="string">&quot;background-color:red&quot;</span>&gt;</span>This is a heading<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;background-color:green&quot;</span>&gt;</span>This is a paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="字体、颜色和尺寸"><a class="header-anchor" href="#字体、颜色和尺寸"></a>字体、颜色和尺寸</h3><p><code>font-family</code>、<code>color</code> 以及<code> font-size</code> 属性分别定义元素中文本的字体系列、颜色和字体尺寸</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&quot;font-family:verdana&quot;</span>&gt;</span>A heading<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;font-family:arial;color:red;font-size:20px;&quot;</span>&gt;</span>A paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="文本对齐"><a class="header-anchor" href="#文本对齐"></a>文本对齐</h3><p><code>text-align </code>属性规定了元素中文本的水平对齐方式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&quot;text-align:center&quot;</span>&gt;</span>This is a heading<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>The heading above is aligned to the center of this page.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="HTML文本格式化"><a class="header-anchor" href="#HTML文本格式化"></a>HTML文本格式化</h2><h3 id="文本格式化标签"><a class="header-anchor" href="#文本格式化标签"></a>文本格式化标签</h3><table><thead><tr><th style="text-align:left">标签</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>&lt;b&gt;</code></td><td style="text-align:left">定义粗体文本。</td></tr><tr><td style="text-align:left"><code>&lt;big&gt;</code></td><td style="text-align:left">定义大号字。</td></tr><tr><td style="text-align:left"><code>&lt;em&gt;</code></td><td style="text-align:left">定义着重文字。</td></tr><tr><td style="text-align:left"><code>&lt;i&gt;</code></td><td style="text-align:left">定义斜体字。</td></tr><tr><td style="text-align:left"><code>&lt;small&gt;</code></td><td style="text-align:left">定义小号字。</td></tr><tr><td style="text-align:left"><code>&lt;strong&gt;</code></td><td style="text-align:left">定义加重语气。</td></tr><tr><td style="text-align:left"><code>&lt;sub&gt;</code></td><td style="text-align:left">定义下标字。</td></tr><tr><td style="text-align:left"><code>&lt;sup&gt;</code></td><td style="text-align:left">定义上标字。</td></tr><tr><td style="text-align:left"><code>&lt;ins&gt;</code></td><td style="text-align:left">定义插入字。</td></tr><tr><td style="text-align:left"><code>&lt;del&gt;</code></td><td style="text-align:left">定义删除字。</td></tr></tbody></table><h3 id="“计算机输出”标签"><a class="header-anchor" href="#“计算机输出”标签"></a>“计算机输出”标签</h3><table><thead><tr><th style="text-align:left">标签</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>&lt;code&gt;</code></td><td style="text-align:left">定义计算机代码。</td></tr><tr><td style="text-align:left"><code>&lt;kdd&gt;</code></td><td style="text-align:left">定义键盘码。</td></tr><tr><td style="text-align:left"><code>&lt;samp&gt;</code></td><td style="text-align:left">定义计算机代码样本</td></tr><tr><td style="text-align:left"><code>&lt;tt&gt;</code></td><td style="text-align:left">定义打字机代码。</td></tr><tr><td style="text-align:left"><code>&lt;var&gt;</code></td><td style="text-align:left">定义变量。</td></tr><tr><td style="text-align:left"><code>&lt;pre&gt;</code></td><td style="text-align:left">定义预格式文本。</td></tr></tbody></table><h3 id="引用、引用和术语定义"><a class="header-anchor" href="#引用、引用和术语定义"></a>引用、引用和术语定义</h3><table><thead><tr><th style="text-align:left">标签</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>&lt;abbr&gt;</code></td><td style="text-align:left">定义缩写。</td></tr><tr><td style="text-align:left"><code>&lt;acronym&gt;</code></td><td style="text-align:left">定义首字母缩写。</td></tr><tr><td style="text-align:left"><code>&lt;address&gt;</code></td><td style="text-align:left">定义地址。</td></tr><tr><td style="text-align:left"><code>&lt;bdo&gt;</code></td><td style="text-align:left">定义文字方向。</td></tr><tr><td style="text-align:left"><code>&lt;blockquote&gt;</code></td><td style="text-align:left">定义长的引用。</td></tr><tr><td style="text-align:left"><code>&lt;q&gt;</code></td><td style="text-align:left">定义短的引用语</td></tr><tr><td style="text-align:left"><code>&lt;cite&gt;</code></td><td style="text-align:left">定义引用、引证。</td></tr><tr><td style="text-align:left"><code>&lt;dfn&gt;</code></td><td style="text-align:left">定义一个定义项目。</td></tr></tbody></table><h2 id="HTML-引用"><a class="header-anchor" href="#HTML-引用"></a><a href="https://www.w3school.com.cn/html/html_quotation_elements.asp">HTML 引用</a></h2><h2 id="HTML-计算机代码"><a class="header-anchor" href="#HTML-计算机代码"></a><a href="https://www.w3school.com.cn/html/html_computercode_elements.asp">HTML 计算机代码</a></h2><h2 id="HTML-CSS"><a class="header-anchor" href="#HTML-CSS"></a>HTML CSS</h2><h3 id="外部样式表"><a class="header-anchor" href="#外部样式表"></a>外部样式表</h3><p>当样式需要被应用到很多页面的时候，外部样式表将是理想的选择。使用外部样式表，你就可以通过更改一个文件来改变整个站点的外观</p><h3 id="内部样式表"><a class="header-anchor" href="#内部样式表"></a>内部样式表</h3><p>当单个文件需要特别样式时，就可以使用内部样式表。你可以在 head 部分通过 <code>&lt;style&gt;</code> 标签定义内部样式表。</p><h3 id="内联样式"><a class="header-anchor" href="#内联样式"></a>内联样式</h3><p>当特殊的样式需要应用到个别元素时，就可以使用内联样式。 使用内联样式的方法是在相关的标签中使用样式属性。样式属性可以包含任何 CSS 属性。以下实例显示出如何改变段落的颜色和左外边距。</p><h2 id="HTML-链接-v2"><a class="header-anchor" href="#HTML-链接-v2"></a>HTML 链接</h2><h3 id="超链接"><a class="header-anchor" href="#超链接"></a>超链接</h3><p>超链接可以是一个字，一个词，或者一组词，也可以是一幅图像，您可以点击这些内容来跳转到新的文档或者当前文档中的某个部分。</p><p>当您把鼠标指针移动到网页中的某个链接上时，箭头会变为一只小手。</p><p>我们通过使用 <code>&lt;a&gt; </code>标签在 HTML 中创建链接。</p><p>有两种使用 <code>&lt;a&gt; </code>标签的方式：</p><ul><li>通过使用 <code>href </code>属性 - 创建指向另一个文档的链接</li><li>通过使用 <code>name</code> 属性 - 创建文档内的书签</li></ul><h3 id="链接语法"><a class="header-anchor" href="#链接语法"></a>链接语法</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.w3school.com.cn/&quot;</span>&gt;</span>Visit W3School<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="target-属性"><a class="header-anchor" href="#target-属性"></a>target 属性</h3><p>使用 Target 属性，你可以定义被链接的文档在何处显示。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.w3school.com.cn/&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>Visit W3School!<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--如果把链接的 target 属性设置为 &quot;_blank&quot;，该链接会在新窗口中打开。 --&gt;</span></span><br></pre></td></tr></table></figure><h3 id="name-属性"><a class="header-anchor" href="#name-属性"></a>name 属性</h3><p>name 属性规定锚（anchor）的名称</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;label&quot;</span>&gt;</span>锚（显示在页面上的文本）<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a href="http://www.w3school.com.cn/html/html_links.asp#tips">实例-锚</a></p><blockquote><p>假如浏览器找不到已定义的命名锚，那么就会定位到文档的顶端。不会有错误发生。</p></blockquote><h2 id="HTML-图像-v2"><a class="header-anchor" href="#HTML-图像-v2"></a><a href="https://www.w3school.com.cn/html/html_images.asp">HTML 图像</a></h2><h3 id="图像标签（-img-）和源属性（Src）"><a class="header-anchor" href="#图像标签（-img-）和源属性（Src）"></a>图像标签（<code>&lt;img&gt;</code>）和源属性（<code>Src</code>）</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;url&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="替换文本属性（Alt）"><a class="header-anchor" href="#替换文本属性（Alt）"></a>替换文本属性（<code>Alt</code>）</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;boat.gif&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Big Boat&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在浏览器无法载入图像时，替换文本属性告诉读者她们失去的信息</p><h2 id="HTML-表格"><a class="header-anchor" href="#HTML-表格"></a><a href="https://www.w3school.com.cn/html/html_tables.asp">HTML 表格</a></h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A[Hard edge] --&gt;|Link text| B(Round edge)</span><br><span class="line">    B --&gt; C&#123;Decision&#125;</span><br><span class="line">    C --&gt;|One| D[Result one]</span><br><span class="line">    C --&gt;|Two| E[Result two]</span><br></pre></td></tr></table></figure><pre><code>&lt;table&gt;    &lt;tr&gt;        &lt;th rowspan=&quot;2&quot;&gt;值班人员&lt;/th&gt;        &lt;th&gt;星期一&lt;/th&gt;        &lt;th&gt;星期二&lt;/th&gt;        &lt;th&gt;星期三&lt;/th&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;李强&lt;/td&gt;        &lt;td&gt;张明&lt;/td&gt;        &lt;td&gt;王平&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;</code></pre><table>    <tr>        <th rowspan="2">值班人员</th>        <th>星期一</th>        <th>星期二</th>        <th>星期三</th>    </tr>    <tr>        <td>李强</td>        <td>张明</td>        <td>王平</td>    </tr></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;th rowspan&#x3D;&quot;2&quot;&gt;值班人员&lt;&#x2F;th&gt;</span><br><span class="line">        &lt;th&gt;星期一&lt;&#x2F;th&gt;</span><br><span class="line">        &lt;th&gt;星期二&lt;&#x2F;th&gt;</span><br><span class="line">        &lt;th&gt;星期三&lt;&#x2F;th&gt;</span><br><span class="line">    &lt;&#x2F;tr&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;李强&lt;&#x2F;td&gt;</span><br><span class="line">        &lt;td&gt;张明&lt;&#x2F;td&gt;</span><br><span class="line">        &lt;td&gt;王平&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;&#x2F;tr&gt;</span><br><span class="line">&lt;&#x2F;table&gt;</span><br></pre></td></tr></table></figure><hr><p>二个注脚<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>的样例。</p><h2 id="HTML-列表"><a class="header-anchor" href="#HTML-列表"></a><a href="https://www.w3school.com.cn/html/html_lists.asp">HTML 列表</a></h2><h2 id="HTML块"><a class="header-anchor" href="#HTML块"></a><a href="https://www.w3school.com.cn/html/html_blocks.asp">HTML块</a></h2><h3 id="HTML-块元素"><a class="header-anchor" href="#HTML-块元素"></a>HTML 块元素</h3><p>块级元素在浏览器显示时，通常会以新行来开始（和结束）。</p><h3 id="HTML-div-元素"><a class="header-anchor" href="#HTML-div-元素"></a>HTML<code>&lt;div&gt;</code>元素</h3><p>HTML <code>&lt;div&gt; </code>元素是块级元素，它是可用于组合其他 HTML 元素的容器。</p><p><code>&lt;div&gt; </code>元素没有特定的含义。除此之外，由于它属于块级元素，浏览器会在其前后显示折行。</p><p>如果与 CSS 一同使用，<code>&lt;div&gt;</code> 元素可用于对大的内容块设置样式属性。</p><p><code>&lt;div&gt;</code> 元素的另一个常见的用途是文档布局。它取代了使用表格定义布局的老式方法。使用 <code>&lt;table&gt;</code> 元素进行文档布局不是表格的正确用法。<code>&lt;table&gt;</code> 元素的作用是显示表格化的数据。</p><h3 id="HTML-内联元素"><a class="header-anchor" href="#HTML-内联元素"></a>HTML 内联元素</h3><p>内联元素在显示时通常不会以新行开始。</p><p>HTML <code>&lt;span&gt;</code> 元素是内联元素，可用作文本的容器。</p><p><code>&lt;span&gt;</code> 元素也没有特定的含义。</p><p>当与 CSS 一同使用时，<code>&lt;span&gt; </code>元素可用于为部分文本设置样式属性。</p><h2 id="HTML类"><a class="header-anchor" href="#HTML类"></a><a href="https://www.w3school.com.cn/html/html_classes.asp">HTML类</a></h2><p>对 HTML 进行分类（设置类），使我们能够为元素的类定义 CSS 样式。</p><p>为相同的类设置相同的样式，或者为不同的类设置不同的样式。</p><h3 id="分类块级元素"><a class="header-anchor" href="#分类块级元素"></a>分类块级元素</h3><p>HTML <code>&lt;div&gt;</code> 元素是<em>块级元素</em>。它能够用作其他 HTML 元素的容器。</p><p>设置 <code>&lt;div&gt;</code> 元素的类，使我们能够为相同的<code>&lt;div&gt;</code>元素设置相同的类：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">.cities &#123;</span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>:black;</span></span><br><span class="line"><span class="css">    <span class="attribute">color</span>:white;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin</span>:<span class="number">20px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">padding</span>:<span class="number">20px</span>;</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cities&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>London<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>London is the capital city of England. </span><br><span class="line">It is the most populous city in the United Kingdom, </span><br><span class="line">with a metropolitan area of over 13 million inhabitants.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cities&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Paris<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Paris is the capital and most populous city of France.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cities&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Tokyo<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Tokyo is the capital of Japan, the center of the Greater Tokyo Area,</span><br><span class="line">and the most populous metropolitan area in the world.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="分类行内元素"><a class="header-anchor" href="#分类行内元素"></a>分类行内元素</h3><p>HTML <code>&lt;span&gt;</code> 元素是行内元素，能够用作文本的容器。</p><p>设置<code> &lt;span&gt;</code> 元素的类，能够为相同的<code>&lt;span&gt;</code>元素设置相同的样式。</p><h2 id="HTML-布局"><a class="header-anchor" href="#HTML-布局"></a><a href="https://www.w3school.com.cn/html/html_layout.asp">HTML 布局</a></h2><h3 id="使用-div-元素的-HTML-布局"><a class="header-anchor" href="#使用-div-元素的-HTML-布局"></a>使用 <code>&lt;div&gt; </code>元素的 HTML 布局</h3><h3 id="使用-HTML5-的网站布局"><a class="header-anchor" href="#使用-HTML5-的网站布局"></a>使用 HTML5 的网站布局</h3><table><thead><tr><th>HTML5</th><th>语义元素</th></tr></thead><tbody><tr><td>header</td><td>定义文档或节的页眉</td></tr><tr><td>nav</td><td>定义导航链接的容器</td></tr><tr><td>section</td><td>定义文档中的节</td></tr><tr><td>article</td><td>定义独立的自包含文章</td></tr><tr><td>aside</td><td>定义内容之外的内容（比如侧栏）</td></tr><tr><td>footer</td><td>定义文档或节的页脚</td></tr><tr><td>details</td><td>定义额外的细节</td></tr><tr><td>summary</td><td>定义 details 元素的标题</td></tr></tbody></table><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>123 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript ECMAScript</title>
      <link href="2019/08/09/JavaScript_ECMAScript/"/>
      <url>2019/08/09/JavaScript_ECMAScript/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.liaoxuefeng.com/wiki/1022910821149312">JavaScript</a>核心（ECMAScript），参考书籍《JavaScript高级程序设计》第三版</p><hr><h2 id="基本概念"><a class="header-anchor" href="#基本概念"></a>基本概念</h2><h3 id="script-元素"><a class="header-anchor" href="#script-元素"></a><code>&lt;script&gt;</code>元素</h3><p><code>&lt;script&gt;</code>元素具有6个属性：</p><ul><li><code>async</code>：可选。异步，表示应该立即下载脚本，但不应妨碍页面中的其他操作，比如下载其他资源或等待加载其他脚本。只对外部脚本文件有效。建议异步脚本不要在加载期间修改 DOM（属性设置为<code>async=&quot;async&quot;</code>）</li><li><code>charset</code>：可选。表示通过 src 属性指定的代码的字符集。由于大多数浏览器会忽略它的值，因此这个属性很少有人用。</li><li><code>defer</code>：可选。延迟，表示脚本可以<strong>延迟到文档完全被解析和显示之后再执行</strong>。只对外部脚本文件有效。IE7 及更早版本对嵌入脚本也支持这个属性。(属性设置为<code>defer=&quot;defer&quot;</code>)</li><li><code>language</code>：已废弃。原来用于表示编写代码使用的脚本语言（如 JavaScript、JavaScript1.2或 VBScript）。大多数浏览器会忽略这个属性，因此也没有必要再用了。</li><li><code>src</code>：可选。表示包含要执行代码的外部文件。</li><li><code>type</code>：可选。可以看成是<code>language </code>替代属性；表示编写代码使用的脚本语言的内容类型（也称为 MIME 类型）。如果没有指定这个属性，则其默认值为<code>text/javascript</code></li></ul><p><code>&lt;script&gt;</code>通常用以下两种<strong>使用方式</strong></p><ul><li>直接在页面中嵌入 JavaScript 代码</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    alert(<span class="string">&#x27;Hello, world&#x27;</span>);</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由<code>&lt;script&gt;</code>…<code>&lt;/script&gt;</code>包含的代码就是JavaScript代码，它将直接被浏览器执行</p><ul><li>把JavaScript代码放到一个单独的<code>.js</code>文件，然后在HTML中通过<code>&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;</code>引入这个文件</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/static/js/abc.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样，<code>/static/js/abc.js</code>就会被浏览器执行。</p><blockquote><p>带有<code>src</code>属性的<code>&lt;script&gt;</code>元素不应该在其<code>&lt;script&gt;</code>和<code>&lt;/script&gt;</code>标签之间再包含额外的 JavaScript 代码。如果包含了嵌入的代码，则只会下载并执行外部脚本文件，嵌入的代码会被忽略。</p></blockquote><h3 id="语法"><a class="header-anchor" href="#语法"></a>语法</h3><p>JavaScript的语法和Java语言类似，每个语句以<code>;</code>结束，语句块用<code>&#123;...&#125;</code>。</p><p>但是，JavaScript并不强制要求在每个语句的结尾加<code>;</code>，浏览器中负责执行JavaScript代码的引擎会自动在每个语句的结尾补上<code>;</code>。推荐语句使用分号结束。</p><p><a href="https://www.w3school.com.cn/js/js_reserved.asp">保留词</a></p><h3 id="注释"><a class="header-anchor" href="#注释"></a>注释</h3><p>以<code>//</code>开头直到行末的字符被视为单行注释</p><p>另一种块注释是用<code>/*...*/</code>把多行字符包裹起来，把一大“块”视为一个注释</p><h3 id="区分大小写"><a class="header-anchor" href="#区分大小写"></a>区分大小写</h3><p>JavaScript<strong>严格区分大小写</strong>，如果弄错了大小写，程序将报错或者运行不正常。</p><h3 id="标识符"><a class="header-anchor" href="#标识符"></a>标识符</h3><p>标识符是指变量、函数、属性的名字，或者函数的参数。</p><p>标识符可以是按照下列格式规则组合起来的一或多个字符：</p><ul><li>第一个字符必须是一个字母、下划线（_）或一个美元符号（$）；</li><li>其他字符可以是字母、下划线、美元符号或数字</li></ul><p>推荐采用驼峰大小写格式，也就是第一个字母小写，剩下的每个单词的首字母大写</p><h3 id="严格模式"><a class="header-anchor" href="#严格模式"></a>严格模式</h3><p>ECMAScript 5引入了严格模式的概念。 严格模式是为 JavaScript 定义了一种不同的解析与执行模型。</p><p>在严格模式下，ECMAScript3 中的一些不确定的行为将得到处理，而且对某些不安全的操作也会抛出错误。要在整个脚本中启用严格模式，可以在顶部添加如下代码： <code>&quot;use strict&quot;;</code></p><h3 id="变量"><a class="header-anchor" href="#变量"></a>变量</h3><p>ECMAScript 的变量是松散类型的，所谓松散类型就是可以用来保存任何类型的数据。与python变量类似</p><p>定义变量时要使用<code>var</code>操作符，后跟变量名（即一个标识符）：<code>var message;</code></p><p>用 var 操作符定义的变量将成为定义该变量的作用域中的局部变量，如果在函数中使用 var 定义一个变量，那么这个变量在函数退出后就会被销毁。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">&quot;world&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> message = <span class="string">&quot;hello&quot;</span>; <span class="comment">// 局部变量</span></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"><span class="built_in">console</span>.log(message) <span class="comment">//world</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">&quot;world&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    message = <span class="string">&quot;hello&quot;</span>; <span class="comment">// 全局变量</span></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"><span class="built_in">console</span>.log(message) <span class="comment">// hello</span></span><br></pre></td></tr></table></figure><blockquote><p>不推荐省略<code>var</code>操作符定义全局变量</p></blockquote><p>可以使用一条语句定义多个变量，变量间使用逗号分隔。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">&quot;hello&quot;</span>,found = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h2 id="数据类型"><a class="header-anchor" href="#数据类型"></a>数据类型</h2><p>ECMAScript 中有 5 种简单数据类型（也称为基本数据类型）：<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>和 <code>String</code>。还有 1 种复杂数据类型——Object，Object 本质上是由一组无序的名值对组成的。</p><p>JavaScript不区分整数和浮点数，统一用Number表示,以下都是合法的Number类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123</span>; <span class="comment">// 整数123</span></span><br><span class="line"><span class="number">0.456</span>; <span class="comment">// 浮点数0.456</span></span><br><span class="line"><span class="number">1.2345e3</span>; <span class="comment">// 科学计数法表示1.2345x1000，等同于1234.5</span></span><br><span class="line">-<span class="number">99</span>; <span class="comment">// 负数</span></span><br><span class="line"><span class="literal">NaN</span>; <span class="comment">// NaN表示Not a Number，当无法计算结果时用NaN表示</span></span><br><span class="line"><span class="literal">Infinity</span>; <span class="comment">// Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity</span></span><br></pre></td></tr></table></figure><blockquote><p>十六进制表示整数比较方便，十六进制用0x前缀和0-9，a-f表示，例如：<code>0xff00</code>，<code>0xa5b4c3d2</code>，等等，它们和十进制表示的数值完全一样。</p></blockquote><p>Number可以直接做四则运算，规则和数学一致</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="number">2</span>; <span class="comment">// 3</span></span><br><span class="line">(<span class="number">1</span> + <span class="number">2</span>) * <span class="number">5</span> / <span class="number">2</span>; <span class="comment">// 7.5</span></span><br><span class="line"><span class="number">2</span> / <span class="number">0</span>; <span class="comment">// Infinity</span></span><br><span class="line"><span class="number">0</span> / <span class="number">0</span>; <span class="comment">// NaN</span></span><br><span class="line"><span class="number">10</span> % <span class="number">3</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="number">10.5</span> % <span class="number">3</span>; <span class="comment">// 1.5</span></span><br><span class="line"><span class="comment">// 注意%是求余运算</span></span><br></pre></td></tr></table></figure><h3 id="typeof操作符"><a class="header-anchor" href="#typeof操作符"></a><code>typeof</code>操作符</h3><p><code>typeof</code>操作符用来检测给定变量的数据类型，返回以下字符串</p><ul><li>“undefined”——这个值未定义；</li><li>“boolean”——这个值是布尔值；</li><li>“string”——这个值是字符串；</li><li>“number”——这个值是数值；</li><li>“object”——这个值是对象或 null；</li><li>“function”——如果这个值是函数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">&quot;hello&quot;</span>,found = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> message) <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(found))  <span class="comment">// boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>)  <span class="comment">// object</span></span><br></pre></td></tr></table></figure><h3 id="null和undefined"><a class="header-anchor" href="#null和undefined"></a><code>null</code>和<code>undefined</code></h3><p><code>null</code>表示一个“空”的值，它和<code>0</code>以及空字符串<code>''</code>不同，<code>0</code>是一个数值，<code>''</code>表示长度为0的字符串，而<code>null</code>表示“空”。</p><p><code>null</code>值表示一个空对象指针，而这也正是使用<code>typeof</code>操作符检测<code>null</code>值时会返回&quot;object&quot;的原因</p><p>在其他语言中，也有类似JavaScript的<code>null</code>的表示，例如Java也用<code>null</code>，Swift用<code>nil</code>，Python用<code>None</code>表示。但是，在JavaScript中，还有一个和<code>null</code>类似的<code>undefined</code>，它表示“未定义”。</p><p>JavaScript的设计者希望用<code>null</code>表示一个空的值，而<code>undefined</code>表示值未定义。事实证明，这并没有什么用，区分两者的意义不大。大多数情况下，我们都应该用<code>null</code>。<code>undefined</code>仅仅在判断函数参数是否传递的情况下有用。</p><p>只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存<code>null</code>值。这样做不仅可以体现<code>null</code>作为空对象指针的惯例，而且也有助于进一步区分<code>null</code>和 <code>undefined</code>。****</p><h3 id="String类型"><a class="header-anchor" href="#String类型"></a><code>String</code>类型</h3><p>字符串是以单引号<code>'</code>或双引号<code>&quot;</code>括起来的任意文本，比如<code>'abc'</code>，<code>&quot;xyz&quot;</code>等等。<code>''</code>或<code>&quot;&quot;</code>本身只是一种表示方式，不是字符串的一部分，因此，字符串<code>'abc'</code>只有<code>a</code>，<code>b</code>，<code>c</code>这3个字符。</p><p>如果字符串内部既包含<code>'</code>又包含<code>&quot;</code>，可以用转义字符<code>\</code>来标识</p><p>字符字面量</p><table><thead><tr><th>字面量</th><th>含义</th></tr></thead><tbody><tr><td><code>\n</code></td><td>换行</td></tr><tr><td><code>\t</code></td><td>Tab制表</td></tr><tr><td><code>\b</code></td><td>空格</td></tr><tr><td><code>\r</code></td><td>回车</td></tr><tr><td><code>\f</code></td><td>换页</td></tr><tr><td><code>\\</code></td><td>转义斜杠</td></tr><tr><td><code>\xnn</code></td><td>以十六进制代码nn表示的一个字符（其中n为0～F）。例如，\x41表示&quot;A&quot;</td></tr><tr><td><code>\unnnn</code></td><td>以十六进制代码nnnn表示的一个Unicode字符（其中n为0～F）。例如，\u03a3表示希腊字符Σ</td></tr></tbody></table><h4 id="多行字符串"><a class="header-anchor" href="#多行字符串"></a>多行字符串</h4><p>由于多行字符串用<code>\n</code>写起来比较费事，所以最新的ES6标准新增了一种多行字符串的表示方法，用反引号表示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`这是一个</span></span><br><span class="line"><span class="string">多行</span></span><br><span class="line"><span class="string">字符串`</span>;</span><br></pre></td></tr></table></figure><h4 id="模板字符串"><a class="header-anchor" href="#模板字符串"></a>模板字符串</h4><p>要把多个字符串连接起来，可以用<code>+</code>号连接：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;小明&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> message = <span class="string">&#x27;你好, &#x27;</span> + name + <span class="string">&#x27;, 你今年&#x27;</span> + age + <span class="string">&#x27;岁了!&#x27;</span>;</span><br><span class="line">alert(message);</span><br></pre></td></tr></table></figure><p>如果有很多变量需要连接，用<code>+</code>号就比较麻烦。ES6新增了一种模板字符串，表示方法和上面的多行字符串一样，但是它会自动替换字符串中的变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;小明&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> message = <span class="string">`你好, <span class="subst">$&#123;name&#125;</span>, 你今年<span class="subst">$&#123;age&#125;</span>岁了!`</span>;</span><br><span class="line">alert(message);</span><br></pre></td></tr></table></figure><h4 id="操作字符串"><a class="header-anchor" href="#操作字符串"></a>操作字符串</h4><p>字符串常见的操作如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;Hello, world!&#x27;</span>;</span><br><span class="line">s.length; <span class="comment">// 13</span></span><br></pre></td></tr></table></figure><p>要获取字符串某个指定位置的字符，使用类似Array的下标操作，索引号从0开始：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;Hello, world!&#x27;</span>;</span><br><span class="line"></span><br><span class="line">s[<span class="number">0</span>]; <span class="comment">// &#x27;H&#x27;</span></span><br><span class="line">s[<span class="number">6</span>]; <span class="comment">// &#x27; &#x27;</span></span><br><span class="line">s[<span class="number">7</span>]; <span class="comment">// &#x27;w&#x27;</span></span><br><span class="line">s[<span class="number">12</span>]; <span class="comment">// &#x27;!&#x27;</span></span><br><span class="line">s[<span class="number">13</span>]; <span class="comment">// undefined 超出范围的索引不会报错，但一律返回undefined</span></span><br></pre></td></tr></table></figure><p><strong>需要特别注意的是</strong>，字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;Test&#x27;</span>;</span><br><span class="line">s[<span class="number">0</span>] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">alert(s); <span class="comment">// s仍然为&#x27;Test&#x27;</span></span><br></pre></td></tr></table></figure><p>JavaScript为字符串提供了一些常用方法，注意，调用这些方法本身不会改变原有字符串的内容，而是返回一个新字符串：</p><h5 id="toUpperCase"><a class="header-anchor" href="#toUpperCase"></a>toUpperCase</h5><p><code>toUpperCase()</code>把一个字符串全部变为大写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line">s.toUpperCase(); <span class="comment">// 返回&#x27;HELLO&#x27;</span></span><br></pre></td></tr></table></figure><h5 id="toLowerCase"><a class="header-anchor" href="#toLowerCase"></a>toLowerCase</h5><p><code>toLowerCase()</code>把一个字符串全部变为小写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> lower = s.toLowerCase(); <span class="comment">// 返回&#x27;hello&#x27;并赋值给变量lower</span></span><br><span class="line">lower; <span class="comment">// &#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure><h5 id="indexOf"><a class="header-anchor" href="#indexOf"></a>indexOf</h5><p><code>indexOf()</code>会搜索指定字符串出现的位置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;hello, world&#x27;</span>;</span><br><span class="line">s.indexOf(<span class="string">&#x27;world&#x27;</span>); <span class="comment">// 返回7</span></span><br><span class="line">s.indexOf(<span class="string">&#x27;World&#x27;</span>); <span class="comment">// 没有找到指定的子串，返回-1</span></span><br></pre></td></tr></table></figure><h5 id="substring"><a class="header-anchor" href="#substring"></a>substring</h5><p><code>substring()</code>返回指定索引区间的子串：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;hello, world&#x27;</span></span><br><span class="line">s.substring(<span class="number">0</span>, <span class="number">5</span>); <span class="comment">// 从索引0开始到5（不包括5），返回&#x27;hello&#x27;</span></span><br><span class="line">s.substring(<span class="number">7</span>); <span class="comment">// 从索引7开始到结束，返回&#x27;world&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="Boolean类型"><a class="header-anchor" href="#Boolean类型"></a><code>Boolean</code>类型</h3><p>布尔值和布尔代数的表示完全一致，一个布尔值只有<code>true</code>、<code>false</code>两种值，要么是<code>true</code>，要么是<code>false</code>，可以直接用<code>true</code>、<code>false</code>表示布尔值，也可以通过布尔运算计算出来</p><ul><li><code>&amp;&amp;</code>运算是与运算，只有所有都为<code>true</code>，<code>&amp;&amp;</code>运算结果才是<code>true</code></li><li><code>||</code>运算是或运算，只要其中有一个为<code>true</code>，<code>||</code>运算结果就是<code>true</code></li><li><code>!</code>运算是非运算，它是一个单目运算符，把<code>true</code>变成<code>false</code>，<code>false</code>变成<code>true</code></li></ul><p>其他数据类型对于布尔值转换</p><table><thead><tr><th>数据类型</th><th>true</th><th>false</th></tr></thead><tbody><tr><td>Boolean</td><td>true</td><td>false</td></tr><tr><td>String</td><td>非空字符串</td><td>” “</td></tr><tr><td>Number</td><td>非零数字（包括无穷大）</td><td>0和NaN</td></tr><tr><td>Object</td><td>任何对象</td><td>null</td></tr><tr><td>Undefined</td><td>N/A</td><td>undefined</td></tr></tbody></table><h3 id="Number类型"><a class="header-anchor" href="#Number类型"></a><code>Number</code>类型</h3><p>默认十进制</p><p>八进制前两位为0o</p><p>十六进制前两位为0x</p><p>NaN（Not a Number），0除以 0会返回NaN，因此不会影响其他代码的执行</p><p>NaN 与任何值都不相等，包括NaN本身，ECMAScript 定义了<code>isNaN()</code>函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">100</span>);  <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0o100</span>); <span class="comment">// 64</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0xAB</span>);  <span class="comment">// 171</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span>/<span class="number">0</span>);   <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>/<span class="number">0</span>);   <span class="comment">// Infinity</span></span><br><span class="line"><span class="built_in">console</span>.log(-<span class="number">1</span>/<span class="number">0</span>);  <span class="comment">// -Infinity</span></span><br></pre></td></tr></table></figure><h3 id="操作符"><a class="header-anchor" href="#操作符"></a>操作符</h3><p>一元操作符，只能操作一个值的操作符</p><p>自增和自减</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">29</span>;</span><br><span class="line"><span class="built_in">console</span>.log(++ age); <span class="comment">// 30; 与age = age + 1 效果相同</span></span><br><span class="line"><span class="built_in">console</span>.log(age ++); <span class="comment">// 30</span></span><br><span class="line"><span class="built_in">console</span>.log(age);    <span class="comment">// 31</span></span><br></pre></td></tr></table></figure><h3 id="关系操作符"><a class="header-anchor" href="#关系操作符"></a>关系操作符</h3><p>当我们对Number做比较时，可以通过比较运算符得到一个布尔值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> &gt; <span class="number">5</span>; <span class="comment">// false</span></span><br><span class="line"><span class="number">5</span> &gt;= <span class="number">2</span>; <span class="comment">// true</span></span><br><span class="line"><span class="number">7</span> == <span class="number">7</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>实际上，JavaScript允许对任意数据类型做比较：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">false</span> == <span class="number">0</span>; <span class="comment">// true</span></span><br><span class="line"><span class="literal">false</span> === <span class="number">0</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>要特别注意相等运算符<code>==</code>。JavaScript在设计时，有两种比较运算符：</p><p>第一种是<code>==</code>比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果；</p><p>第二种是<code>===</code>比较，它不会自动转换数据类型，如果数据类型不一致，返回<code>false</code>，如果一致，再比较。</p><p>由于JavaScript这个设计缺陷，<strong>不要</strong>使用<code>==</code>比较，始终坚持使用<code>===</code>比较。</p><p>另一个例外是<code>NaN</code>这个特殊的Number与所有其他值都不相等，包括它自己：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>唯一能判断<code>NaN</code>的方法是通过<code>isNaN()</code>函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>最后要注意浮点数的相等比较：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> / <span class="number">3</span> === (<span class="number">1</span> - <span class="number">2</span> / <span class="number">3</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>这不是JavaScript的设计缺陷。浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.abs(<span class="number">1</span> / <span class="number">3</span> - (<span class="number">1</span> - <span class="number">2</span> / <span class="number">3</span>)) &lt; <span class="number">0.0000001</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="数组"><a class="header-anchor" href="#数组"></a>数组</h3><p>数组是一组按顺序排列的集合，集合的每个值称为元素。JavaScript的数组可以包括任意数据类型。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3.14</span>, <span class="string">&#x27;Hello&#x27;</span>, <span class="literal">null</span>, <span class="literal">true</span>];</span><br></pre></td></tr></table></figure><p>上述数组包含6个元素。数组用<code>[]</code>表示，元素之间用<code>,</code>分隔。</p><p>另一种创建数组的方法是通过<code>Array()</code>函数实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 创建了数组[1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>然而，出于代码的可读性考虑，强烈建议直接使用<code>[]</code>。</p><p>数组的元素可以通过索引来访问。请注意，索引的起始值为<code>0</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3.14</span>, <span class="string">&#x27;Hello&#x27;</span>, <span class="literal">null</span>, <span class="literal">true</span>];</span><br><span class="line">arr[<span class="number">0</span>]; <span class="comment">// 返回索引为0的元素，即1</span></span><br><span class="line">arr[<span class="number">5</span>]; <span class="comment">// 返回索引为5的元素，即true</span></span><br><span class="line">arr[<span class="number">6</span>]; <span class="comment">// 索引超出了范围，返回undefined</span></span><br></pre></td></tr></table></figure><p>要取得<code>Array</code>的长度，直接访问<code>length</code>属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3.14</span>, <span class="string">&#x27;Hello&#x27;</span>, <span class="literal">null</span>, <span class="literal">true</span>];</span><br><span class="line">arr.length; <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p><strong>请注意</strong>，直接给<code>Array</code>的<code>length</code>赋一个新的值会导致<code>Array</code>大小的变化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.length; <span class="comment">// 3</span></span><br><span class="line">arr.length = <span class="number">6</span>;</span><br><span class="line">arr; <span class="comment">// arr变为[1, 2, 3, undefined, undefined, undefined]</span></span><br><span class="line">arr.length = <span class="number">2</span>;</span><br><span class="line">arr; <span class="comment">// arr变为[1, 2]</span></span><br></pre></td></tr></table></figure><p><code>Array</code>可以通过索引把对应的元素修改为新的值，因此，对<code>Array</code>的索引进行赋值会直接修改这个<code>Array</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>];</span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">99</span>;</span><br><span class="line">arr; <span class="comment">// arr现在变为[&#x27;A&#x27;, 99, &#x27;C&#x27;]</span></span><br></pre></td></tr></table></figure><p><strong>请注意</strong>，如果通过索引赋值时，索引超过了范围，同样会引起<code>Array</code>大小的变化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr[<span class="number">5</span>] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">arr; <span class="comment">// arr变为[1, 2, 3, undefined, undefined, &#x27;x&#x27;]</span></span><br></pre></td></tr></table></figure><p>大多数其他编程语言不允许直接改变数组的大小，越界访问索引会报错。然而，JavaScript的<code>Array</code>却不会有任何错误。在编写代码时，不建议直接修改<code>Array</code>的大小，访问索引时要确保索引不会越界。</p><h4 id="indexOf-v2"><a class="header-anchor" href="#indexOf-v2"></a>indexOf</h4><p>与String类似，<code>Array</code>也可以通过<code>indexOf()</code>来搜索一个指定的元素的位置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="string">&#x27;30&#x27;</span>, <span class="string">&#x27;xyz&#x27;</span>];</span><br><span class="line">arr.indexOf(<span class="number">10</span>); <span class="comment">// 元素10的索引为0</span></span><br><span class="line">arr.indexOf(<span class="number">20</span>); <span class="comment">// 元素20的索引为1</span></span><br><span class="line">arr.indexOf(<span class="number">30</span>); <span class="comment">// 元素30没有找到，返回-1</span></span><br><span class="line">arr.indexOf(<span class="string">&#x27;30&#x27;</span>); <span class="comment">// 元素&#x27;30&#x27;的索引为2</span></span><br></pre></td></tr></table></figure><p>注意了，数字<code>30</code>和字符串<code>'30'</code>是不同的元素。</p><h4 id="slice"><a class="header-anchor" href="#slice"></a>slice</h4><p><code>slice()</code>就是对应String的<code>substring()</code>版本，它截取<code>Array</code>的部分元素，然后返回一个新的<code>Array</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>];</span><br><span class="line">arr.slice(<span class="number">0</span>, <span class="number">3</span>); <span class="comment">// 从索引0开始，到索引3结束，但不包括索引3: [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span></span><br><span class="line">arr.slice(<span class="number">3</span>); <span class="comment">// 从索引3开始到结束: [&#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;]</span></span><br></pre></td></tr></table></figure><p>注意到<code>slice()</code>的起止参数包括开始索引，不包括结束索引。</p><p>如果不给<code>slice()</code>传递任何参数，它就会从头到尾截取所有元素。利用这一点，我们可以很容易地复制一个<code>Array</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> aCopy = arr.slice();</span><br><span class="line">aCopy; <span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;]</span></span><br><span class="line">aCopy === arr; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="push和pop"><a class="header-anchor" href="#push和pop"></a>push和pop</h4><p><code>push()</code>向<code>Array</code>的末尾添加若干元素，<code>pop()</code>则把<code>Array</code>的最后一个元素删除掉：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">arr.push(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>); <span class="comment">// 返回Array新的长度: 4</span></span><br><span class="line">arr; <span class="comment">// [1, 2, &#x27;A&#x27;, &#x27;B&#x27;]</span></span><br><span class="line">arr.pop(); <span class="comment">// pop()返回&#x27;B&#x27;</span></span><br><span class="line">arr; <span class="comment">// [1, 2, &#x27;A&#x27;]</span></span><br><span class="line">arr.pop(); arr.pop(); arr.pop(); <span class="comment">// 连续pop 3次</span></span><br><span class="line">arr; <span class="comment">// []</span></span><br><span class="line">arr.pop(); <span class="comment">// 空数组继续pop不会报错，而是返回undefined</span></span><br><span class="line">arr; <span class="comment">// []</span></span><br></pre></td></tr></table></figure><h4 id="unshift和shift"><a class="header-anchor" href="#unshift和shift"></a>unshift和shift</h4><p>如果要往<code>Array</code>的头部添加若干元素，使用<code>unshift()</code>方法，<code>shift()</code>方法则把<code>Array</code>的第一个元素删掉：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">arr.unshift(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>); <span class="comment">// 返回Array新的长度: 4</span></span><br><span class="line">arr; <span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;, 1, 2]</span></span><br><span class="line">arr.shift(); <span class="comment">// &#x27;A&#x27;</span></span><br><span class="line">arr; <span class="comment">// [&#x27;B&#x27;, 1, 2]</span></span><br><span class="line">arr.shift(); arr.shift(); arr.shift(); <span class="comment">// 连续shift 3次</span></span><br><span class="line">arr; <span class="comment">// []</span></span><br><span class="line">arr.shift(); <span class="comment">// 空数组继续shift不会报错，而是返回undefined</span></span><br><span class="line">arr; <span class="comment">// []</span></span><br></pre></td></tr></table></figure><h4 id="sort"><a class="header-anchor" href="#sort"></a>sort</h4><p><code>sort()</code>可以对当前<code>Array</code>进行排序，它会直接修改当前<code>Array</code>的元素位置，直接调用时，按照默认顺序排序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;A&#x27;</span>];</span><br><span class="line">arr.sort();</span><br><span class="line">arr; <span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span></span><br></pre></td></tr></table></figure><p>能否按照我们自己指定的顺序排序呢？完全可以，我们将在后面的函数中讲到。</p><h4 id="reverse"><a class="header-anchor" href="#reverse"></a>reverse</h4><p><code>reverse()</code>把整个<code>Array</code>的元素给掉个个，也就是反转：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>];</span><br><span class="line">arr.reverse(); </span><br><span class="line">arr; <span class="comment">// [&#x27;three&#x27;, &#x27;two&#x27;, &#x27;one&#x27;]</span></span><br></pre></td></tr></table></figure><h4 id="splice"><a class="header-anchor" href="#splice"></a>splice</h4><p><code>splice()</code>方法是修改<code>Array</code>的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;Microsoft&#x27;</span>, <span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;Yahoo&#x27;</span>, <span class="string">&#x27;AOL&#x27;</span>, <span class="string">&#x27;Excite&#x27;</span>, <span class="string">&#x27;Oracle&#x27;</span>];</span><br><span class="line"><span class="comment">// 从索引2开始删除3个元素,然后再添加两个元素:</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Facebook&#x27;</span>); <span class="comment">// 返回删除的元素 [&#x27;Yahoo&#x27;, &#x27;AOL&#x27;, &#x27;Excite&#x27;]</span></span><br><span class="line">arr; <span class="comment">// [&#x27;Microsoft&#x27;, &#x27;Apple&#x27;, &#x27;Google&#x27;, &#x27;Facebook&#x27;, &#x27;Oracle&#x27;]</span></span><br><span class="line"><span class="comment">// 只删除,不添加:</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// [&#x27;Google&#x27;, &#x27;Facebook&#x27;]</span></span><br><span class="line">arr; <span class="comment">// [&#x27;Microsoft&#x27;, &#x27;Apple&#x27;, &#x27;Oracle&#x27;]</span></span><br><span class="line"><span class="comment">// 只添加,不删除:</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">0</span>, <span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Facebook&#x27;</span>); <span class="comment">// 返回[],因为没有删除任何元素</span></span><br><span class="line">arr; <span class="comment">// [&#x27;Microsoft&#x27;, &#x27;Apple&#x27;, &#x27;Google&#x27;, &#x27;Facebook&#x27;, &#x27;Oracle&#x27;]</span></span><br></pre></td></tr></table></figure><h4 id="concat"><a class="header-anchor" href="#concat"></a>concat</h4><p><code>concat()</code>方法把当前的<code>Array</code>和另一个<code>Array</code>连接起来，并返回一个新的<code>Array</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> added = arr.concat([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">added; <span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, 1, 2, 3]</span></span><br><span class="line">arr; <span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span></span><br></pre></td></tr></table></figure><p><strong>请注意</strong>，<code>concat()</code>方法并没有修改当前<code>Array</code>，而是返回了一个新的<code>Array</code>。</p><p>实际上，<code>concat()</code>方法可以接收任意个元素和<code>Array</code>，并且自动把<code>Array</code>拆开，然后全部添加到新的<code>Array</code>里：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>];</span><br><span class="line">arr.concat(<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]); <span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, 1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><h4 id="join"><a class="header-anchor" href="#join"></a>join</h4><p><code>join()</code>方法是一个非常实用的方法，它把当前<code>Array</code>的每个元素都用指定的字符串连接起来，然后返回连接后的字符串：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.join(<span class="string">&#x27;-&#x27;</span>); <span class="comment">// &#x27;A-B-C-1-2-3&#x27;</span></span><br></pre></td></tr></table></figure><p>如果<code>Array</code>的元素不是字符串，将自动转换为字符串后再连接。</p><h4 id="多维数组"><a class="header-anchor" href="#多维数组"></a>多维数组</h4><p>如果数组的某个元素又是一个<code>Array</code>，则可以形成多维数组，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">400</span>, <span class="number">500</span>, <span class="number">600</span>], <span class="string">&#x27;-&#x27;</span>];</span><br></pre></td></tr></table></figure><h3 id="对象"><a class="header-anchor" href="#对象"></a>对象</h3><p>JavaScript的对象是一组由键-值组成的无序集合，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    tags: [<span class="string">&#x27;js&#x27;</span>, <span class="string">&#x27;web&#x27;</span>, <span class="string">&#x27;mobile&#x27;</span>],</span><br><span class="line">    city: <span class="string">&#x27;Beijing&#x27;</span>,</span><br><span class="line">    hasCar: <span class="literal">true</span>,</span><br><span class="line">    zipcode: <span class="literal">null</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>JavaScript对象的键都是字符串类型，值可以是任意数据类型。上述<code>person</code>对象一共定义了6个键值对，其中每个键又称为对象的属性，例如，<code>person</code>的<code>name</code>属性为<code>'Bob'</code>，<code>zipcode</code>属性为<code>null</code>。</p><p>要获取一个对象的属性，我们用<code>对象变量.属性名</code>的方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">person.name; <span class="comment">// &#x27;Bob&#x27;</span></span><br><span class="line">person.zipcode; <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p>JavaScript用一个<code>&#123;...&#125;</code>表示一个对象，键值对以<code>xxx: xxx</code>形式申明，用<code>,</code>隔开。注意，最后一个键值对不需要在末尾加<code>,</code>，如果加了，有的浏览器（如低版本的IE）将报错。</p><p>访问属性是通过<code>.</code>操作符完成的，但这要求属性名必须是一个有效的变量名。如果属性名包含特殊字符，就必须用<code>''</code>括起来：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaohong = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小红&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;middle-school&#x27;</span>: <span class="string">&#x27;No.1 Middle School&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>xiaohong</code>的属性名<code>middle-school</code>不是一个有效的变量，就需要用<code>''</code>括起来。访问这个属性也无法使用<code>.</code>操作符，必须用<code>['xxx']</code>来访问：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xiaohong[<span class="string">&#x27;middle-school&#x27;</span>]; <span class="comment">// &#x27;No.1 Middle School&#x27;</span></span><br><span class="line">xiaohong[<span class="string">&#x27;name&#x27;</span>]; <span class="comment">// &#x27;小红&#x27;</span></span><br><span class="line">xiaohong.name; <span class="comment">// &#x27;小红&#x27;</span></span><br></pre></td></tr></table></figure><p>如果访问一个不存在的属性会返回什么呢？JavaScript规定，访问不存在的属性不报错，而是返回<code>undefined</code></p><p>如果我们要检测<code>xiaoming</code>是否拥有某一属性，可以用<code>in</code>操作符：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    school: <span class="string">&#x27;No.1 Middle School&#x27;</span>,</span><br><span class="line">    height: <span class="number">1.70</span>,</span><br><span class="line">    weight: <span class="number">65</span>,</span><br><span class="line">    score: <span class="literal">null</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> xiaoming; <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;grade&#x27;</span> <span class="keyword">in</span> xiaoming; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>不过要小心，如果<code>in</code>判断一个属性存在，这个属性不一定是<code>xiaoming</code>的，它可能是<code>xiaoming</code>继承得到的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;toString&#x27;</span> <span class="keyword">in</span> xiaoming; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>因为<code>toString</code>定义在<code>object</code>对象中，而所有对象最终都会在原型链上指向<code>object</code>，所以<code>xiaoming</code>也拥有<code>toString</code>属性。</p><p>要判断一个属性是否是<code>xiaoming</code>自身拥有的，而不是继承得到的，可以用<code>hasOwnProperty()</code>方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.hasOwnProperty(<span class="string">&#x27;name&#x27;</span>); <span class="comment">// true</span></span><br><span class="line">xiaoming.hasOwnProperty(<span class="string">&#x27;toString&#x27;</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="变量-v2"><a class="header-anchor" href="#变量-v2"></a>变量</h3><p>变量的概念基本上和初中代数的方程变量是一致的，只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。</p><p>变量在JavaScript中就是用一个变量名表示，变量名是大小写英文、数字、<code>$</code>和<code>_</code>的组合，且不能用数字开头。变量名也不能是JavaScript的关键字，如<code>if</code>、<code>while</code>等。申明一个变量用<code>var</code>语句，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a; <span class="comment">// 申明了变量a，此时a的值为undefined</span></span><br><span class="line"><span class="keyword">var</span> $b = <span class="number">1</span>; <span class="comment">// 申明了变量$b，同时给$b赋值，此时$b的值为1</span></span><br><span class="line"><span class="keyword">var</span> s_007 = <span class="string">&#x27;007&#x27;</span>; <span class="comment">// s_007是一个字符串</span></span><br><span class="line"><span class="keyword">var</span> Answer = <span class="literal">true</span>; <span class="comment">// Answer是一个布尔值true</span></span><br><span class="line"><span class="keyword">var</span> t = <span class="literal">null</span>; <span class="comment">// t的值是null</span></span><br></pre></td></tr></table></figure><p>变量名也可以用中文，但是，请不要给自己找麻烦。</p><p>在JavaScript中，使用等号<code>=</code>对变量进行赋值。可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，但是要注意只能用<code>var</code>申明一次，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">123</span>; <span class="comment">// a的值是整数123</span></span><br><span class="line">a = <span class="string">&#x27;ABC&#x27;</span>; <span class="comment">// a变为字符串</span></span><br></pre></td></tr></table></figure><p>这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a = <span class="number">123</span>; <span class="comment">// a是整数类型变量，类型用int申明</span></span><br><span class="line">a = <span class="string">&quot;ABC&quot;</span>; <span class="comment">// 错误：不能把字符串赋给整型变量</span></span><br></pre></td></tr></table></figure><p>和静态语言相比，动态语言更灵活，就是这个原因。</p><p>请不要把赋值语句的等号等同于数学的等号。比如下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line">x = x + <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>如果从数学上理解<code>x = x + 2</code>那无论如何是不成立的，在程序中，赋值语句先计算右侧的表达式<code>x + 2</code>，得到结果<code>12</code>，再赋给变量<code>x</code>。由于<code>x</code>之前的值是<code>10</code>，重新赋值后，<code>x</code>的值变成<code>12</code>。</p><h3 id="strict模式"><a class="header-anchor" href="#strict模式"></a>strict模式</h3><p>JavaScript在设计之初，为了方便初学者学习，并不强制要求用<code>var</code>申明变量。这个设计错误带来了严重的后果：如果一个变量没有通过<code>var</code>申明就被使用，那么该变量就自动被申明为全局变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">10</span>; <span class="comment">// i现在是全局变量</span></span><br></pre></td></tr></table></figure><p>在同一个页面的不同的JavaScript文件中，如果都不用<code>var</code>申明，恰好都使用了变量<code>i</code>，将造成变量<code>i</code>互相影响，产生难以调试的错误结果。</p><p>使用<code>var</code>申明的变量则不是全局变量，它的范围被限制在该变量被申明的函数体内（函数的概念将稍后讲解），同名变量在不同的函数体内互不冲突。</p><p>为了修补JavaScript这一严重设计缺陷，ECMA在后续规范中推出了strict模式，在strict模式下运行的JavaScript代码，强制通过<code>var</code>申明变量，未使用<code>var</code>申明变量就使用的，将导致运行错误。</p><p>启用strict模式的方法是在JavaScript代码的第一行写上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;use strict&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这是一个字符串，不支持strict模式的浏览器会把它当做一个字符串语句执行，支持strict模式的浏览器将开启strict模式运行JavaScript。</p><h2 id="语句"><a class="header-anchor" href="#语句"></a>语句</h2><h3 id="条件判断"><a class="header-anchor" href="#条件判断"></a>条件判断</h3><p>JavaScript使用<code>if () &#123; ... &#125; else &#123; ... &#125;</code>来进行条件判断。例如，根据年龄显示不同内容，可以用<code>if</code>语句实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">if</span> (age &gt;= <span class="number">18</span>) &#123; <span class="comment">// 如果age &gt;= 18为true，则执行if语句块</span></span><br><span class="line">    alert(<span class="string">&#x27;adult&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则执行else语句块</span></span><br><span class="line">    alert(<span class="string">&#x27;teenager&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>else</code>语句是可选的。如果语句块只包含一条语句，那么可以省略<code>&#123;&#125;</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">if</span> (age &gt;= <span class="number">18</span>)</span><br><span class="line">    alert(<span class="string">&#x27;adult&#x27;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    alert(<span class="string">&#x27;teenager&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="多行条件判断"><a class="header-anchor" href="#多行条件判断"></a>多行条件判断</h4><p>如果还要更细致地判断条件，可以使用多个<code>if...else...</code>的组合：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span> (age &gt;= <span class="number">18</span>) &#123;</span><br><span class="line">    alert(<span class="string">&#x27;adult&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (age &gt;= <span class="number">6</span>) &#123;</span><br><span class="line">    alert(<span class="string">&#x27;teenager&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    alert(<span class="string">&#x27;kid&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述多个<code>if...else...</code>的组合实际上相当于两层<code>if...else...</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span> (age &gt;= <span class="number">18</span>) &#123;</span><br><span class="line">    alert(<span class="string">&#x27;adult&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (age &gt;= <span class="number">6</span>) &#123;</span><br><span class="line">        alert(<span class="string">&#x27;teenager&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        alert(<span class="string">&#x27;kid&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环"><a class="header-anchor" href="#循环"></a>循环</h3><p>JavaScript的循环有两种，一种是<code>for</code>循环，通过初始条件、结束条件和递增条件来循环执行语句块：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=<span class="number">10000</span>; i++) &#123;</span><br><span class="line">    x = x + i;</span><br><span class="line">&#125;</span><br><span class="line">x; <span class="comment">// 50005000</span></span><br></pre></td></tr></table></figure><h4 id="for"><a class="header-anchor" href="#for"></a>for</h4><p>让我们来分析一下<code>for</code>循环的控制条件：</p><ul><li>i=1 这是初始条件，将变量i置为1；</li><li>i&lt;=10000 这是判断条件，满足时就继续循环，不满足就退出循环；</li><li>i++ 这是每次循环后的递增条件，由于每次循环后变量i都会加1，因此它终将在若干次循环后不满足判断条件<code>i&lt;=10000</code>而退出循环。</li></ul><p><code>for</code>循环最常用的地方是利用索引来遍历数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Microsoft&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> i, x;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">    x = arr[i];</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>for</code>循环的3个条件都是可以省略的，如果没有退出循环的判断条件，就必须使用<code>break</code>语句退出循环，否则就是死循环：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123; <span class="comment">// 将无限循环下去</span></span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">100</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// 通过if判断来退出循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    x ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="for-…-in"><a class="header-anchor" href="#for-…-in"></a>for … in</h4><p><code>for</code>循环的一个变体是<code>for ... in</code>循环，它可以把一个对象的所有属性依次循环出来：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    city: <span class="string">&#x27;Beijing&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> o) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key); <span class="comment">// &#x27;name&#x27;, &#x27;age&#x27;, &#x27;city&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要过滤掉对象继承的属性，用<code>hasOwnProperty()</code>来实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    city: <span class="string">&#x27;Beijing&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> o) &#123;</span><br><span class="line">    <span class="keyword">if</span> (o.hasOwnProperty(key)) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(key); <span class="comment">// &#x27;name&#x27;, &#x27;age&#x27;, &#x27;city&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>Array</code>也是对象，而它的每个元素的索引被视为对象的属性，因此，<code>for ... in</code>循环可以直接循环出<code>Array</code>的索引：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> a) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">// &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;</span></span><br><span class="line">    <span class="built_in">console</span>.log(a[i]); <span class="comment">// &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>请注意</strong>，<code>for ... in</code>对<code>Array</code>的循环得到的是<code>String</code>而不是<code>Number</code>。</p><h4 id="while"><a class="header-anchor" href="#while"></a>while</h4><p><code>for</code>循环在已知循环的初始和结束条件时非常有用。而上述忽略了条件的<code>for</code>循环容易让人看不清循环的逻辑，此时用<code>while</code>循环更佳。</p><p><code>while</code>循环只有一个判断条件，条件满足，就不断循环，条件不满足时则退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> n = <span class="number">99</span>;</span><br><span class="line"><span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    x = x + n;</span><br><span class="line">    n = n - <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">x; <span class="comment">// 2500</span></span><br></pre></td></tr></table></figure><p>在循环内部变量<code>n</code>不断自减，直到变为<code>-1</code>时，不再满足<code>while</code>条件，循环退出。</p><h4 id="do-…-while"><a class="header-anchor" href="#do-…-while"></a>do … while</h4><p>最后一种循环是<code>do &#123; ... &#125; while()</code>循环，它和<code>while</code>循环的唯一区别在于，不是在每次循环开始的时候判断条件，而是在每次循环完成的时候判断条件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    n = n + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (n &lt; <span class="number">100</span>);</span><br><span class="line">n; <span class="comment">// 100</span></span><br></pre></td></tr></table></figure><p>用<code>do &#123; ... &#125; while()</code>循环要小心，循环体会至少执行1次，而<code>for</code>和<code>while</code>循环则可能一次都不执行。</p><h4 id="break和continue"><a class="header-anchor" href="#break和continue"></a>break和continue</h4><p>break 语句会立即退出循环， 强制继续执行循环后面的语句</p><p>continue 语句虽然也是立即退出循环，但退出循环后会从循环的顶部继续执行</p><h3 id="其他"><a class="header-anchor" href="#其他"></a>其他</h3><h4 id="with语句"><a class="header-anchor" href="#with语句"></a>with语句</h4><p>with 语句的作用是将代码的作用域设置到一个特定的对象中</p><p>由于大量使用 with 语句会导致性能下降，同时也会给调试代码造成困难，因此 在开发大型应用程序时，不建议使用 with 语句</p><h4 id="switch语句"><a class="header-anchor" href="#switch语句"></a>switch语句</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expression) &#123;</span><br><span class="line">    <span class="keyword">case</span> value: statement</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> value: statement</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> value: statement</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数"><a class="header-anchor" href="#函数"></a>函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">functionName</span>(<span class="params">arg0, arg1,...,argN</span>) </span>&#123;</span><br><span class="line">    statements</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>使用<code>return</code>返回<code>return</code>后语句的返回值</p><p>参数，ECMAScript 函数不介意传递进来多少个参数，也不在乎传进来参数是什么数据类型</p><p>ECMAScript 函数不能像传统意义上那样实现重载</p><p>如果在 ECMAScript 中定义了两个名字相同的函数，则该名字只属于后定义的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addSomeNumber</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num + <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addSomeNumber</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num + <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = addSomeNumber(<span class="number">100</span>); </span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">//300</span></span><br></pre></td></tr></table></figure><p>通过检查传入函数中参数的类型和数量并作出不同的反应，可以模仿方法的重载</p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机二级公共基础</title>
      <link href="2019/08/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BA%8C%E7%BA%A7%E5%85%AC%E5%85%B1%E5%9F%BA%E7%A1%80/"/>
      <url>2019/08/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BA%8C%E7%BA%A7%E5%85%AC%E5%85%B1%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>计算机二级公共基础知识</p><hr><p><img src="https://puui.qpic.cn/fans_admin/0/3_1409075683_1572058823439/0" alt="19"></p><h2 id="数据结构与算法"><a class="header-anchor" href="#数据结构与算法"></a>数据结构与算法</h2><h3 id="算法"><a class="header-anchor" href="#算法"></a>算法</h3><h4 id="算法的基本概念"><a class="header-anchor" href="#算法的基本概念"></a>算法的基本概念</h4><p>算法：是指<strong>解绝</strong>方案的<strong>准确</strong>而完整的描述。</p><blockquote><p>即是一组严谨地定义运算顺序的规则，并且每一个规则都是有效的，且是明确的，没有二义性，同时该规则将在有限次运算后可终止。</p></blockquote><p>算法不等于程序，也不等于计算机方法。程序的编制不可能优于算法的设计。</p><h5 id="算法的基本特征"><a class="header-anchor" href="#算法的基本特征"></a>算法的基本特征</h5><ul><li><strong>可行性</strong>：算法原则上能够精确地执行。</li><li><strong>确定性</strong>：算法中每一步骤都必须有明确定义，不允许有模棱两可的解释，不允许有多义性。设计的算法是计算工具所能够正常解决问题的过程。</li><li><strong>有穷性</strong>：算法必须能在有限的时间内做完，即能在执行<strong>有限个步骤</strong>后终止。</li><li><strong>拥有足够的情报</strong>：算法的执行与输入的数据和提供的初始条件相关，不同的输入或初始条件会有不同的输出结果，提供准确的初始条件和数据，才能使算法正确执行。</li></ul><h5 id="算法的基本要素"><a class="header-anchor" href="#算法的基本要素"></a>算法的基本要素</h5><p>一是对数据对象的运算和操作；二是算法的控制结构。</p><ul><li>算法中对数据的运算和操作<br>算法实际上是按解题要求从环境能进行的所有操作中选择合适的操作所组成的一组指令序列。即算法是计算机所能够处理的操作所组成的指令序列。</li><li>算法的控制结构<br>算法的功能不仅取决于所选用的操作，而且还与各操作之间的顺序有关。在算法中，操作的执行顺序又称算法的控制结构，一般的算法控制结构有三种：<strong>顺序结构</strong>、<strong>选择结构</strong>、<strong>循环结构</strong>。</li></ul><h5 id="算法基本设计方法"><a class="header-anchor" href="#算法基本设计方法"></a>算法基本设计方法</h5><ul><li><p>列举法<br>列举法的基本思想是，根据提出的问题，列举出所有可能的情况，并用问题中给定的条件检验哪些是满足条件的，哪些是不满足条件的。列举法通常用于解决“是否存在”或“有哪些可能”等问题</p></li><li><p>归纳法<br>归纳法的基本思想是，通过列举少量的特殊情况，经过分析，最后找出一般的关系。归纳是一种抽象，即从特殊现象中找出一般规律。但由于在归纳法中不可能对所有的情况进行列举，因此，该方法得到的结论只是一种猜测，还需要进行证明。</p></li><li><p>递推<br>递推，即是从已知的初始条件出发，逐次推出所要求的各个中间环节和最后结果。其中初始条件或问题本身已经给定，或是通过对问题的分析与化简而确定。</p></li><li><p>递归<br>在解决一些复杂问题时，为了降低问题的复杂程序，通常是将问题逐层分解，最后归结为一些最简单的问题。这种将问题逐层分解的过程，并没有对问题进行求解，而只是当解决了最后的问题那些最简单的问题后，再沿着原来分解的逆过程逐步进行综合，这就是递归的方法。</p></li><li><p>减斗递推技术<br>减半递推即将问题的规模减半，然后，重复相同的递推操作</p></li><li><p>回溯法。<br>有些实际的问题很难归纳出一组简单的递推公式或直观的求解步骤，也不能使用无限的列举。对于这类问题，只能采用试探的方法，通过对问题的分析，找出解决问题的线索，然后沿着这个线索进行试探，如果试探成功，就得到问题的解，如果不成功，再逐步回退，换别的路线进行试探。这种方法，即称为回溯法。</p></li></ul><h4 id="算法复杂度"><a class="header-anchor" href="#算法复杂度"></a>算法复杂度</h4><ol><li><strong>算法时间复杂度</strong>是指执行算法所需要的计算<strong>工作量</strong>。<br>通常，一个算法所用的时间包括编译时间和运行时间。</li><li><strong>算法空间复杂度</strong>是指执行这个算法所需要的<strong>内存空间</strong>。<br>包括算法程序所占的空间，输入的初始数据所占的空间，算法执行过程中所需的额外空间。</li></ol><p><strong>空间复杂度和时间复杂度并不相关。</strong></p><h3 id="数据结构的基本概念"><a class="header-anchor" href="#数据结构的基本概念"></a>数据结构的基本概念</h3><h4 id="概念"><a class="header-anchor" href="#概念"></a>概念</h4><p>数据结构是指相互有关联的数据元素的集合。它包括以下两个方面：</p><ul><li>表示数据元素的信息</li><li>表示各数据之间的前后件关系</li></ul><h5 id="数据的逻辑结构"><a class="header-anchor" href="#数据的逻辑结构"></a>数据的逻辑结构</h5><p>是指反映数据元素之间的逻辑关系结构。</p><p>数据的逻辑结构有两个要素：</p><ul><li><p><strong>数据元素的集合，通常记为D</strong></p></li><li><p>D上的关系，它反映了<strong>数据元素之间的前后件关系，通常记为R</strong>。</p></li></ul><p>一个数据结构可以表示成 B = (D, R)</p><h5 id="数据的存储结构"><a class="header-anchor" href="#数据的存储结构"></a>数据的存储结构</h5><p>数据的逻辑结构在计算机存储空间中的存放形式称为数据的存储结构，或数据的物理结构。</p><p>即数据存储时，不仅要存放数据元素的信息，而且要存储数据元素之间的前后件关系的信息。</p><p>通常的数据存储结构有顺序、链接、索引等存储结构。</p><h4 id="数据结构的图形表示"><a class="header-anchor" href="#数据结构的图形表示"></a>数据结构的图形表示</h4><p>数据结构的图形表示有两个元素：</p><ul><li>中间标有元素值的方框表示数据元素，称为数据结点</li><li>用有向线段表示数据元素之间的前后件关系，即有向线段从前件结点指向后件结点</li></ul><blockquote><p>注意：在结构图中，没有前件的结点称为根结点，没有后件的结点称为终端结点，也称叶子结点。</p></blockquote><h4 id="线性结构与非线性结构"><a class="header-anchor" href="#线性结构与非线性结构"></a>线性结构与非线性结构</h4><p>如果一个数据元素都没有，该数据结构称为空数据结构；在空数据结构中插入一个新的元素后数据结构变为非空数据结构；将数据结构中的所有元素均删除，则该数据结构变成空数据结构。</p><p>如果一个非空的数据结构满足如下条件，则该数据结构为线性结构：</p><ul><li>有且只有一个根结点</li><li>每一个结点最多只有一个前件，也最多只有一个后件</li></ul><blockquote><p>线性结构又称线性表。</p><p>注意：在线性结构表中插入或删除元素，该线性表仍然应满足线性结构。如果一个数据结构不满足线性结构，则称为非线性结构。</p></blockquote><h3 id="线性表及其顺序存储结构"><a class="header-anchor" href="#线性表及其顺序存储结构"></a>线性表及其顺序存储结构</h3><h4 id="基本概念"><a class="header-anchor" href="#基本概念"></a>基本概念</h4><p>线性表是最常用的数据结构，它由一组数据元素组成。</p><blockquote><p>注意：这里的数据元素是一个广义的数据元素，并不仅仅是指一个数据。如，矩阵、学 生记录表等。</p></blockquote><p>非空线性表的结构特征：</p><ul><li><p>有且只有一个根结点，它无前件</p></li><li><p>有且只有一个终端结点，它无后件</p></li><li><p>除根结点和终端结点之外，所有的结点有且只有一个前件和一个后件。线性表中结点的个数称为结点的长度 n 。当 n=0 时，称为空表。</p></li></ul><h4 id="顺序存储结构"><a class="header-anchor" href="#顺序存储结构"></a>顺序存储结构</h4><p>顺序存储结构的特点：</p><ul><li><p>线性表中所有的元素所占的存储空间是连续的</p></li><li><p>线性表中各数据元素在存储空间中是按逻辑顺序依次存放的</p></li></ul><p>通常，顺序存储结构中，线性表中每一个数据元素在计算机存储空间中的存储地址由该元素在线性表中的位置序号唯一确定。</p><p>线性表的顺序存储结构下的基本运算：</p><ul><li><p>在指定位置插入一个元素</p></li><li><p>删除线性表中的指定元素</p></li><li><p>查找某个或某些特定的元素</p></li><li><p>线性表的排序</p></li><li><p>按要求将一个线性表拆分为多个线性表</p></li><li><p>将多个线性表合并为一个线性表</p></li><li><p>复制线性表</p></li><li><p>逆转一个线性表</p></li></ul><h4 id="线性表的基本操作"><a class="header-anchor" href="#线性表的基本操作"></a>线性表的基本操作</h4><h5 id="顺序表的插入运算"><a class="header-anchor" href="#顺序表的插入运算"></a>顺序表的插入运算</h5><p>在顺序存储结构的线性表中插入一个元素。</p><blockquote><p>注意：找到插入位置后，将插入位置开始的所有元素从最后一个元素开始顺序后移。另外，在定义线性表时，一定要定义足够的空间，否则，将不允许插入元素。</p></blockquote><h5 id="顺序表的删除运算"><a class="header-anchor" href="#顺序表的删除运算"></a>顺序表的删除运算</h5><p>在顺序在存储结构的线性表中删除一个元素。</p><blockquote><p>注意：找到删除的数据元素后，从该元素位置开始，将后面的元素一一向前移动，在移动完成后，线性表的长度减 1</p></blockquote><h3 id="⭐⭐栈和队列"><a class="header-anchor" href="#⭐⭐栈和队列"></a>⭐⭐栈和队列</h3><h4 id="栈及其基本运算"><a class="header-anchor" href="#栈及其基本运算"></a>栈及其基本运算</h4><p>栈是一种特殊的线性表，它是限定在一端进行插入和删除的线性表。它的插入和删除只能在表的一端进行，而另一端是封闭的，不允许进行插入和删除操作。</p><p>在栈中，允许插入和删除操作一端称为栈顶，不允许插入和删除操作的一端则称为栈底。</p><p>栈顶的元素总是最后被插入的元素，也是最先被删除的元素。它遵循的原则是：先进后出或后进先出。</p><p>堆栈指针总是指向栈顶元素的。</p><h5 id="栈的顺序存储及其运算"><a class="header-anchor" href="#栈的顺序存储及其运算"></a>栈的顺序存储及其运算</h5><p>在栈的顺序存储空间 S （ 1 ： m ）中， S （ bottom ）通常为栈底元素， S （ top ）为栈顶元素。 Top=0 表示栈空； top=m 表示栈满。</p><h6 id="入栈运算"><a class="header-anchor" href="#入栈运算"></a>入栈运算</h6><p>即在栈的顶部插入一个新元素。操作方式是：将栈顶指针加 1 ，再将元素插入至指针所指的位置。</p><h6 id="退栈运算"><a class="header-anchor" href="#退栈运算"></a>退栈运算</h6><p>退栈运算即将栈顶元素取出并赋给一个指定的变量。</p><p>操作方式是：先将栈顶元素赋给指定的变量，再将栈顶指针减 1 。</p><h6 id="读栈顶元素"><a class="header-anchor" href="#读栈顶元素"></a>读栈顶元素</h6><p>将栈顶元素赋给某一指定变量，但栈顶指针不变。</p><h4 id="⭐队列及其基本运算"><a class="header-anchor" href="#⭐队列及其基本运算"></a>⭐队列及其基本运算</h4><h5 id="队列"><a class="header-anchor" href="#队列"></a>队列</h5><p>队列即是允许在一端进行插入，而在另一端进行删除的线性表。</p><p>允许插入的一端称为队尾，通常用一个尾指针指向队尾；</p><p>允许删除的一端称为队首，通常用一个队首指针指向排队元素的前一个位置。</p><p>队列遵循的规则是：<strong>先进先出或后进后出</strong></p><h5 id="循环队列及其运算"><a class="header-anchor" href="#循环队列及其运算"></a>循环队列及其运算</h5><p>队列的顺序存储结构一般采用循环队列的形式。</p><p>循环队列，即是次队列存储空间的最后一个位置绕到第一个位置，形成逻辑上的环状空间，供队列循环使用。</p><p>在循环队列中，用队尾指针 rear 指向队列中的队尾元素，用排头指针 front 指向排头元素的前一个位置，因此，从排头指针 front 指向的后一个位置到队尾指针 rear 指向的位置之间所有的元素均为队列中的元素。</p><p>循环队列的初始状态为空，即 rear=front=m 。这里 m 即为队列的存储空间。</p><p>循环队列的基本运算：入队运算和退队运算。</p><p><strong>入队运算</strong>：每进行一次入队运算，队尾指针加 1 。当队尾指针 rear=m+1 时，即表示队列空间的尾部已经放置了元素，则下一个元素应该旋转到队列空间的首部，即 rear=1</p><p><strong>退队运算</strong>：每退队一个元素，排头指针加 1 。当排头指针 front=m+1 时，即排头指针指向队列空间的尾部，退队后，排头指针指向队列空间的开始，即 front=1 。</p><p>在队列操作时，循环队列满时， front=rear ，队列空时，也有 rear=front ，即在队列空或满时，排头指针和队尾指针均指向同一个位置。</p><p>要判断队列空或满时，还应增加一个标志， s 值的定义：s = 0表示队列空;s = 1表示队列满</p><p>判断队列空与队列满的条件下：</p><p><strong>队列空的条件</strong>：s=0</p><p><strong>队列满的条件</strong>：s=1 、 front=rear</p><h6 id="入队运算"><a class="header-anchor" href="#入队运算"></a>入队运算</h6><p>即在队尾加入一个新元素。这个运算有两个基本操作：首先，将队尾指针加 1 ，即 rear=rear+1 ，当 rear=m+1 时，置 rear=1 ，然后，将新元素插入到队尾指针指向的位置。</p><p>当循环队列非空（ s=1 ），且 front=rear 时，队列满，不能进行入队操作。此情况称“上溢”。</p><h6 id="退队操作"><a class="header-anchor" href="#退队操作"></a>退队操作</h6><p>即将队首的元素赋给一个指定的变量。该运算也有两个基本操作：首先，将排头指针加 1 ，即 front=front+1 ，当 front=m+1 时，置 front=1 ，然后，将排头指针指向的元素赋给指定的变量。</p><p>当循环队列为空（ s=0 ）时，不能进行退队运算。此种情况称为“下溢”。</p><h3 id="线性链表"><a class="header-anchor" href="#线性链表"></a>线性链表</h3><h4 id="线性链表基本概念"><a class="header-anchor" href="#线性链表基本概念"></a>线性链表基本概念</h4><p>前面的线性表均是采用顺序存储结构及在顺序存储结构下的运算。</p><h5 id="顺序存储的优点"><a class="header-anchor" href="#顺序存储的优点"></a>顺序存储的优点</h5><ul><li><p>结构简单</p></li><li><p>运算方便</p></li></ul><h5 id="顺序存储结构的缺点"><a class="header-anchor" href="#顺序存储结构的缺点"></a>顺序存储结构的缺点</h5><ul><li><p>要在顺序存储的线性表中插入一个新元素或删除一个元素时，为了保证插入或删除后的线性表仍然为顺序存储。在插入或删除元素时，需要移动大量的数据元素，因此运算效率较低。</p></li><li><p>如果一个线性表分配顺序存储空间后，如果出现线性表的存储空间已满，但还需要插入元素时，会发生“上溢”错误。</p></li><li><p>在实际应用时，可能有多个线性表同时使用存储空间，这样给存储空间的分配带来问题，有可能使有的队列空间不够或过多造成浪费。</p></li></ul><p>基于上述情况，对于大的线性表或元素变动频繁的大线性表不宜采用顺序存储结构，而应采用链式存储结构。</p><h5 id="链式存储结构"><a class="header-anchor" href="#链式存储结构"></a>链式存储结构</h5><p>假设每一个数据结点对应一个存储单元，该存储单元称为存储结点，简称结点。</p><p>在链式存储方式中，要求每一个结点由两部分组成：一部分用于存放数据元素，你为数据域；另一部分用于存放指针，称为指针域。该指针用于指向该结点的前一个或后一个结点。</p><p>在链式存储结构中，存储数据结构的存储空间可以不连续，各数据结点的存储顺序与数据元素之间的逻辑关系不一致，而数据元素之间的逻辑关系是由指针域来确定的。</p><p>链式存储结构既可以用于线性结构，也可用于非线性结构。</p><h5 id="线性链表介绍"><a class="header-anchor" href="#线性链表介绍"></a>线性链表介绍</h5><p>线性表的链式存储结构称为线性链表。</p><p>将存储空间划分成若干的小块，每块占用若干个字节，这些小块称为存储结点。</p><p>将存储结点分为两个部分，一部分用于存储数据元素的值，称为数据域；另一部分用于存储元素之间的前后件关系，即存放下一个元素在存储序号（即存储地址），即指向后件结点，称为指针域。</p><p>在线性链表中用一个专门的指针 HEAD 指向线性链表中第一个数据元素的结点（即存放第一个元素的地址）。线性表中最后一个元素没有后件，因此，线性链表中的最后一个结点的指针域为空（用 Null 或 0 表示），表示链终结。</p><p>在线性链表中，各元素的存储序号是不连续的，元素间的前后件关系与位置关系也是不一致的。在线性链表中，前后件的关系依靠各结点的指针来指示，指向表的第一个元素的指针 HEAD 称为头指针，当 HEAD=NULL 时，表示该链表为空。</p><p>对于线性链表，可以从头指针开始，沿着各结点的指针扫描到链表中的所有结点。</p><p>这种线性链表称为线性单链表，即可以从表头开始向后扫描链表中的所有结点，而不能从中间或表尾结点向前扫描位于该结点之前的元素。</p><p>这种链表结构的缺点是不能任意地对链表中的元素按下同的方向进行扫描。在某些应用时，如果对链表中的元素设置两个指针域，一个为指向前件的指针域，称为左指针（ LLink ），一个为指向后件的指针域，称为右指针（ RLink ）。则这种链表是双向链表。</p><h5 id="⭐带链的栈"><a class="header-anchor" href="#⭐带链的栈"></a>⭐带链的栈</h5><p>带链的栈即是用来收集计算机存储空间中的所有空闲的存储结点，这种带链的栈称为可利用栈。</p><p>当需要存储结点时，即从可利用的栈的顶部取出栈顶结点；当系统要释放一个存储结点时，将该结点空间放回到可利用栈的栈顶。</p><p>即在计算机中所有空闲的空间，均可以以结点的方式链接到可利用栈中，随着其他线性链表中结点的插入与删除，可利用栈处于动态变化之中，即可利用栈经常要进行退栈和入栈操作。</p><h5 id="带链的队列"><a class="header-anchor" href="#带链的队列"></a>带链的队列</h5><p>队列也是线性表，也可利用链式存储结构来进行保存。</p><h4 id="线性链表的基本运算"><a class="header-anchor" href="#线性链表的基本运算"></a>线性链表的基本运算</h4><p>线性链表包括的基本运算：</p><ul><li><p>在链表中包含指定元素的结点之前插入一个新元素</p></li><li><p>在链表中删除包含指定元素的结点</p></li><li><p>将两个线性链表按要求合并成一个线性链表</p></li><li><p>将一个线性链表按要求进行分解</p></li><li><p>逆转线性链表</p></li><li><p>复制线性链表</p></li><li><p>线性链表的排序</p></li><li><p>线性链表的查找</p></li></ul><h5 id="线性链表中查找指定的元素"><a class="header-anchor" href="#线性链表中查找指定的元素"></a>线性链表中查找指定的元素</h5><p>在线性链表中查找元素 X ：从头指针指向的结点开始往后沿指针进行扫描，直到后面已没有结点或下一个结点的数据域为 X 为止。</p><p>元素的查找，经常是为了进行插入或删除操作而进行的，因此，在查找时，往往是需要记录下该结点的前一个结点。</p><h5 id="线性链表的插入"><a class="header-anchor" href="#线性链表的插入"></a>线性链表的插入</h5><p>线性链表的插入即在链式存储结构的线性表中插入一个新元素。</p><p>在线性链表中包含元素 x 的结点之前插入新元素 b ，插入过程：</p><ol><li>从可利用栈中取得一个结点，设该结点号为 p ，即取得的结点的存储序号存放在变量 p 中。并置结点 p 的数据域为插入的元素值 b 。</li><li>在线性链表中寻找包含元素 x 的前一个结点，该结点的存储序号为 q 。</li><li>将结点 p 插入到结点 q 之后。具体的操作：首先，使结点 p 插入到结点 q 之后（即结点 q 的后件结点），然后，使结点 q 的指针域 内容改为指向结点 p 。</li></ol><p>线性链表的插入操作，新结点是为来自于可利用栈，因此不会造成线性表的溢出。同样，由于可利用栈可被多个线性表利用，因此，不会造成存储空间的浪费，大家动态地共同使用存储空间。</p><h5 id="线性链表的删除"><a class="header-anchor" href="#线性链表的删除"></a>线性链表的删除</h5><p>线性链表的删除，即是在链式存储结构下的线性表中删除指定元素的结点。</p><p>操作方式：</p><ol><li>在线性表中找到包含指定元素 x 的前一个结点 p</li><li>将该结点 p 后的包含元素 x 的结点从线性链表中删除，然后将被删除结点的后一个结点 q 的地址提供给结点 p 的指针域，即将结点 p 指向结点 q 。</li><li>将删除的结点送回可利用栈。</li></ol><p>从以上的删除操作可见，删除一个指定的元素，不需要移动其他的元素即可实现，这是顺序存储的线性表所不能实现的。同时，此操作还可更有效地利用计算机的存储空间。</p><h4 id="循环链表及其基本操作"><a class="header-anchor" href="#循环链表及其基本操作"></a>循环链表及其基本操作</h4><p>在线性链表中，虽然对数据元素的插入和删除操作比较简单，但由于它对第一个结点和空表需要单独处理，使得空表与非空表的处理不一致。</p><p>循环链表，即是采用另一种链接方式，它的特点如下：</p><ol><li>在循环链表中增加一个表头结点，其数据域为任意或根据需要来设置，指针域指向线性表的第一个元素的结点。循环链表的头指针指向表头结点。</li><li>循环链表中最后一个结点的指针域不是空的，而是指向表头结点。在循环链表中，所有结点的指针构成一个环状链。</li></ol><p>在循环链表中，只要指出表中任何一个结点的位置，均可以从它开始扫描到所有的结点，而线性链表做不到，线性链表是一种单向的链表，只能按照指针的方向进行扫描。</p><p>循环链表中设置了一个表头结点，因此，在任何时候都至少有一个结点，因此空表与非空表的运算相统一。</p><h3 id="⭐树与二叉树"><a class="header-anchor" href="#⭐树与二叉树"></a>⭐树与二叉树</h3><h4 id="树的基本概念"><a class="header-anchor" href="#树的基本概念"></a>树的基本概念</h4><p>树是一种简单的非线性结构。在树结构中，数据元素之间有着明显的层次结构。在树的图形表示中，用直线连接两端的结点，上端点为前件，下端点为后件。</p><p>在树结构中，每一个结点只有一个前件，称为父结点。如 A 即为结点 B 、 C 、 D 的父结点。</p><p>没有父结点的结点只有一个，称为根结点。如上图所示，结点 A 即为根结点。</p><p>每一个结点可以有多个后件，它们均称为该结点的子结点。如结点 G 、 H 、 I 是结点 D 的子结点。</p><p>没有后件的结点，称为叶子结点。上图中，叶子结点有： J 、 M 、 N 、 L 、 C 、 G 、 H 、 I 。</p><p>在树结构中，一个结点所拥有的后件结点个数称为该结点的度。例如，结点 D 的度为 3 ，结点 E 的度为 1 等，按此原则，所有叶子结点的度均为 0 。</p><p>在树中，所有结点中最大的度称为该树的度。上图所示的树中，所有结点中最大的度是 3 ，所以该树的度为 3 。</p><p>树分层，根结点为第一层，往下依次类推。同一层结点的所有子结点均在下一层。如上图： A 结点在第 1 层， B 、 C 、 D 结点在第 2 层； E 、 F 、 G 、 H 、 I 在第 3 层； J 、 K 、 L 在第 4 层； M 、 N 在第 5 层。</p><p>树的最大层次称为树的深度。上图树的深度为 5 。</p><p>在树中，某结点的一个子结点为根构成的树称作该结点的子树。叶子结点没有子树。</p><p>在计算机中，可以用树来表示算术表达式。原则如下：</p><ol><li>表达式中每一个运算符在树中对应一个结点，称为运算符结点</li><li>运算符的每一个运算对象在树中为该运算符结点的子树（在树中的顺序为从左到右）</li><li>运算对象中的单变量均为叶子结点</li></ol><p>树在计算机中用多重链表表示。多重链表中的每个结点描述了树中对应结点的信息，而每个结点中的链域（即指针域）个数将随着树中该结点的度而定义。</p><p>如果在树中，每一个结点的子结点的个数不相同，因此在多重链中各结点的链域个数也不相同，会导致算法太复杂。因此，在树中，常采用定长结点来表示树中的每一个结点，即取树的度作为每个结点的链域的个数。这样，管理相对简化了，但会造成空间的浪费，因为有许多的结点存在空链域。</p><h4 id="二叉树及其基本性质"><a class="header-anchor" href="#二叉树及其基本性质"></a>二叉树及其基本性质</h4><h5 id="二叉树的定义"><a class="header-anchor" href="#二叉树的定义"></a>二叉树的定义</h5><p>二叉树的特点：</p><ul><li><p>非空二叉树只有一个根结点</p></li><li><p>每一个结点最多只有两个子结点，且结点分左右。则一个结点最多可以有两棵子树，分别称为左子树和右子树</p></li></ul><p>在二叉树中，每一个结点的度最大为 2 ，即二叉树的度为 2 。在二叉树中，任何的子树也均为二叉树。</p><p>在二叉树中，每一个结点的子树被分为左子树和右子树。在二叉树中，允许某一个结点只有左子树或只有右子树。如果一个结点既没有左子树，也没有右子树，则该结点为叶子结点。</p><h5 id="⭐二叉树的基本性质"><a class="header-anchor" href="#⭐二叉树的基本性质"></a>⭐二叉树的基本性质</h5><p>二叉树具有以下几个性质：</p><ol><li><strong>在二叉树的第k层上，最多有2<sup>k-1</sup>（k≥1）个结点</strong>；</li><li><strong>深度为m的二叉树最多有2<sup>m</sup>-1个结点</strong>；</li><li><strong>在任意一棵二叉树中，度为0的结点（即叶子结点）总是比度为2的结点多一个</strong>。</li><li><strong>具有n个结点的二叉树，其深度至少为［log<sub>2</sub>n］+1，其中［log<sub>2</sub>n］表示取log<sub>2</sub>n的整数部分</strong>。</li></ol><blockquote><p>在二叉树的遍历中，无论是前序遍历，中序遍历还是后序遍历，二叉树的叶子结点的先后顺序都是不变的。</p></blockquote><h5 id="满二叉树与完全二叉树"><a class="header-anchor" href="#满二叉树与完全二叉树"></a>满二叉树与完全二叉树</h5><p>（1）满二叉树</p><p>满二叉树的特点：</p><p>除最后一层外，每一层上的所有结点都有两个子结点。即在满二叉树中，每一层上的结点数都达到最大值，即在满二叉树上的第 k 层上有 2 k-1 个结点。如下即为一棵满二叉树。</p><p>（2）完全二叉树</p><p>特点：除最后一层外，每一层上的结点数均达到最大值，在最后一层上只缺少右边的若干个结点。</p><p>即如果从根结点开始，对二叉树的结点自上而下、自左而右用自然数进行连续编号，则深度为 m 、且有 n 个结点的二叉树，当且仅当其每一个结点都与深度为 m 的满二叉树中编号从 1 到 n 的结点一一对应，则是完全二叉树。</p><p>对于完全二叉树，叶子结点只能在层次最大的两层中出现；对于任何一个结点，若其右分支下的子树结点的最大层次为 p ，则其分支下的子孙结点的最大层次为 p 或 p+1 。</p><p>完全二叉树具有的性质：</p><p>性质 5 ：具有 n 个结点的完全二叉树的深度为 [log 2 n]+1</p><p>性质 6 ：设完全二叉树共有 n 个结点。如果从根结点开始，按层次（每一层从左到右）用自然数 1 、 2 ……、 n 给结点编号，对于编号为 k （ k=1,2, …… n ）的结点有如下结论：</p><ul><li><p>若 k=1 ，则该结点为根结点，它没有父结点；若 k&gt;1 ，则该结点的父结点编号为 INT(k/2) 。</p></li><li><p>若 2k ≤ n ，则编号为 k 的结点的左子结点编号为 2k ；否则该结点无左子结点（当然也 没有右子结点）</p></li><li><p>若 2k+1 ≤ n ，则编号为 k 的结点的右子结点编号为 2k+1 ；否则该结点无右子结点。</p></li></ul><h4 id="二叉树的存储结构"><a class="header-anchor" href="#二叉树的存储结构"></a>二叉树的存储结构</h4><p>二叉树的存储常采用链式存储结构。</p><p>存储二叉树中各元素的存储结点由两个部分组成：数据域和指针域。在二叉树中，由于每个结点可有两个子结点，则它的指针域有两个：一个用于存储该结点的左子结点的存储地址，即称为左指针域；一个用于存储指向该结点的右子结点的存储地址，称为右指针域。</p><p>存储结构如下：</p><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   Lchild   Value   Rchild</span><br><span class="line">i   L(i)     V(i)    R(i)</span><br></pre></td></tr></table></figure><hr><p>即二叉树的存储结构中每一个存储结点都有两个指针域，因此，二叉树的链式存储结构也称为二叉树的链表。在二叉树在存储中，用一个头指针指向二叉树的根结点的存储地址。</p><h4 id="二叉树的遍历"><a class="header-anchor" href="#二叉树的遍历"></a>二叉树的遍历</h4><p>二叉树的遍历即是不重复地访问二叉树的所有结点。</p><p>在遍历二叉树时，一般先遍历左子树，然后再遍历右子树。在先左后右的原则下，二叉树的遍历又可分为三种：前序遍历、中序遍历和后序遍历。</p><h5 id="前序遍历"><a class="header-anchor" href="#前序遍历"></a>前序遍历</h5><p>前序遍历即先访问根结点，然后遍历左子树，最后遍历右子树。</p><p>在遍历左子树和遍历右子树时，依然是先遍历根结点，然后是左子树，再是右子树。</p><p>操作的具体方式：</p><ul><li><p>若二叉树为空，则结束返回。</p></li><li><p>否则：访问根结点 前序遍历左子树 前序遍历右子树</p></li></ul><p>如上图所示的完全二叉树，它的前序遍历结果是： A 、 B 、 D 、 H 、 P 、 Q 、 I 、 R 、 E 、 J 、 K 、 C 、 F 、 L 、 M 、 G 、 N 、 O</p><h5 id="中序遍历"><a class="header-anchor" href="#中序遍历"></a>中序遍历</h5><p>中序遍历，即先遍历左子树，然后访问根结点，最后是遍历右子树。</p><p>具体的操作方式：</p><ul><li><p>若二叉树为空，则结束返回。</p></li><li><p>否则：中序遍历左子树 访问根结点 中序遍历右子树</p></li></ul><p>这里强调，在遍历左子树和右子树时，仍然要采用中序遍历的方法。</p><p>如上图所示的完全二叉树，它的中序遍历结果是： P 、 H 、 Q 、 D 、 R 、 I 、 B 、 J 、 E 、 K 、 A 、 L 、 F 、 M 、 C 、 N 、 G 、 O</p><h5 id="后序遍历"><a class="header-anchor" href="#后序遍历"></a>后序遍历</h5><p>后序遍历，即选遍历左子树，然后是遍历右子树，最后访问根结点。</p><p>具体的操作方式：</p><ul><li><p>若二叉树为空，则结束返回。</p></li><li><p>否则：前序遍历左子树 前序遍历右子树 访问根结点</p></li></ul><p>如上图所示的完全二叉树，它的后序遍历结果是： P 、 Q 、 H 、 R 、 I 、 D 、 J 、 K 、 E 、 B 、 L 、 M 、 F 、 N 、 O 、 G 、 C 、 A</p><h3 id="查找技术"><a class="header-anchor" href="#查找技术"></a>查找技术</h3><p>查找即是指在一个给定的数据结构中查找某个指定的元素。</p><h4 id="顺序查找"><a class="header-anchor" href="#顺序查找"></a>顺序查找</h4><p>顺序查找又称顺序搜索。一般是在线性表中查找指定的元素。</p><p>基本操作方法是：</p><p>从线性表的第一个元素开始，与被查元素进行比较，相等则查找成功，否则继续向后查找。如果所有的元素均查找完毕后都不相等，则该元素在指定的线性表中不存在。</p><p>顺序查找的最好情况：要查找的元素在线性表的第一个元素，则查找效率最高；如果要查找的元素在线性表的最后或根本不存在，则查找需要搜索所有的线性表元素，这种情况是 最差情况。</p><p>对于线性表而言，顺序查找效率很低。但对于以下的线性表，也只能采用顺序查找的方法：</p><ul><li><p>线性表为无序表，即表中的元素没有排列不是按大小顺序进行排列的，这类线性表不管它的存储方式是顺序存储还是链式存储，都只能按顺序查找方式进行查找</p></li><li><p>即使是有序线性表，如果采用链式存储，也只能采用顺序查找方式</p></li></ul><p>例如，现有线性表： 7 、 2 、 1 、 5 、 9 、 4 ，要在序列中查找元素 6 ，查找的过程是：</p><ul><li><p>整个线性表的长度为 5</p></li><li><p>查找计次 n=1 ，将元素 6 与序列的第一个 7 元素进行比较，不等，继续查找</p></li><li><p>n=2 ，将 6 与第二个元素 2 进行比较，不等，继续</p></li><li><p>n=3 ，将 6 与第三个元素 1 进行比较，不等，继续</p></li><li><p>n=4 ，将 6 与第四个元素 5 进行比较，不等，继续</p></li><li><p>n=5 ，将 6 与第五个元素 9 进行比较，不等，继续</p></li><li><p>n=6 ，将 6 与第六个元素 4 进行比较，不等，继续</p></li><li><p>n=7 ，超出线性表的长度，查找结束，则该表中不存在要查找的元素。</p></li></ul><h4 id="二分查找"><a class="header-anchor" href="#二分查找"></a>二分查找</h4><p>二分查找只适用于顺序存储的有序表。此处所述的有序表是指线性中的元素按值非递减排列（即由小到大，但允许相邻元素值相等）。</p><p>二分查找的方法如下：</p><p>将要查找的元素与有序序列的中间元素进行比较：</p><ul><li><p>如果该元素比中间元素大，则继续在线性表的后半部分（中间项以后的部分）进行查找</p></li><li><p>如果要查找的元素的值比中间元素的值小，则继续在线性表的前半部分（中间项以前的部分）进行查找</p></li></ul><p>这个查找过程一直按相同的顺序进行下去，一直到查找成功或子表长度为 0 （说明线性表中没有要查找的元素）</p><p>有序线性表的二分法查找，条件是必须这个有序线性表的存储方式是顺序存储的。它的查找效率比顺序查找要高得多， 二分查找的最坏情况的查找次数是 log 2 n 次，而顺序查找的最坏情况的查找次数是 n 次 。</p><p>当然，二分查找的方法也支持顺序存储的递减序列的线性表。</p><p>有非递减有序线性表： 1 、 2 、 4 、 5 、 7 、 9 ，要查找元素 6 。查找的方法是：</p><ul><li><p>序列长度为 n=6 ，中间元素的序号 m=[(n+1)/2]=3</p></li><li><p>查找计次 k=1 ，将元素 6 与中间元素即元素 4 进行比较，不等， 6&gt;4</p></li><li><p>查找计次 k=2 ，查找继续在后半部分进行，后半部分子表的长度为 3 ，计算中间元素的序号： m=3+[(3+1)/2]=5 ，将元素与后半部分的中间项进行比较，即第 5 个元素中的 7 进行比较，不等， 6&lt;7</p></li><li><p>查找计次 k=3 ，继续查找在后半部分序列的前半部分子序列中查找，子表长度为 1 ，则中间项序号即为 m=3+[(1+1)/2]=4 ，即与第 4 个元素 5 进行比较，不相等，继续查找的子表长度为 0 ，则查找结束</p></li></ul><h3 id="排序技术"><a class="header-anchor" href="#排序技术"></a>排序技术</h3><p>排序即是将一个无序的序列整理成按值非递减顺序排列的有序序列。在这里，我们讨论的是顺序存储的线性表的排序操作。</p><h4 id="交换类排序法"><a class="header-anchor" href="#交换类排序法"></a>交换类排序法</h4><p>交换类排序法，即是借助于数据元素之间的互相交换进行排序的方法。</p><h5 id="冒泡排序法"><a class="header-anchor" href="#冒泡排序法"></a>冒泡排序法</h5><p>冒泡排序法即是利用相邻数据元素之间的交换逐步将线性表变成有序序列的操作方法。</p><p>操作过程如下：</p><ul><li><p>从表头开始扫描线性表，在扫描过程中逐次比较相邻两个元素的大小，若相邻两个元素中前一个元素的值比后一个元素的值大，将两个元素位置进行交换，当扫描完成一遍时，则序列中最大的元素被放置到序列的最后。</p></li><li><p>再继续对序列从头进行扫描，这一次扫描的长度是序列长度减 1 ，因为最大的元素已经就位了，采用与前相同的方法，两两之间进行比较，将次大数移到子序列的末尾。</p></li><li><p>按相同的方法继续扫描，每次扫描的子序列的长度均比上一次减 1 ，直至子序列的长度为 1 时，排序结束。</p></li></ul><p>例如，有序列 5 、 2 、 9 、 4 、 1 、 7 、 6 ，将该序列从小到大进行排列。</p><p>采用冒泡排序法，具体操作步骤如下：</p><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">序列长度 n=7</span><br><span class="line">  原序列               5   2   9   4   1   7   6</span><br><span class="line">  第一遍（从前往后）     5   2   9   4   1   7   6</span><br><span class="line">                      2   5   9   4   1   7   6</span><br><span class="line">                      2   5   4   9   1   7   6</span><br><span class="line">                      2   3   4   1   9   7   6</span><br><span class="line">                      2   5   4   1   7   9   6</span><br><span class="line">  第一遍结束后          2   5   4   1   7   6   9</span><br><span class="line">  第二遍（从前往后）     2   5   4   1   7   6   9</span><br><span class="line">                      2   4   5   1   7   6   9</span><br><span class="line">                      2   4   1   5   7   6   9</span><br><span class="line">                      2   4   1   5   6   7   9</span><br><span class="line">  第二遍结束后          2   4   1   5   6   7   9</span><br><span class="line">  第三遍（从前往后）     2   4   1   5   6   7   9</span><br><span class="line">                      2   1   4   5   6   7   9</span><br><span class="line">  第三遍结束            2   1   4   5   6   7   9</span><br><span class="line">  第四遍（从前往后）     2   1   4   5   6   7   9</span><br><span class="line">                      1   2   4   5   6   7   9</span><br><span class="line">  第四遍结束            1   2   4   5   6   7   9</span><br><span class="line">  最后结果              1   2   4   5   6   7   9</span><br></pre></td></tr></table></figure><hr><p>扫描的次数，最多需要扫描 n-1 次，如果序列已经就位，则扫描结束。测试是否已经就位，可设置一个标志，如果该次扫描没有数据交换，则说明数据排序结束。</p><h5 id="快速排序法"><a class="header-anchor" href="#快速排序法"></a>快速排序法</h5><p>冒泡排序方法每次交换只能改变相邻两个元素之间的逆序，速度相对较慢。如果将两个不相邻的元素之间进行交换，可以消除多个逆序。</p><p>快速排序的方法是：</p><p>从线性表中选取一个元素，设为 T ，将线性表后面小于 T 的元素移到前面，而前面大于 T 的元素移到后面，结果将线性表分成两个部分（称为两个子表）， T 插入到其分界线的位置处，这个过程称为线性表的分割。对过对线性表的一次分割，就以 T 为分界线，将线性表分成前后两个子表，且前面子表中的所有元素均不大于 T ，而后面的所有元素均不小于 T 。</p><p>再将前后两个子表再进行相同的快速排序，将子表再进行分割，直到所有的子表均为空，则完成快速排序操作。</p><p>在快速排序过程中，随着对各子表不断的进行分割，划分出的子表会越来越多，但一次又只能对一个子表进行分割处理，需要将暂时不用的子表记忆起来，这里可用栈来实现。</p><p>对某个子表进行分割后，可以将分割出的后一个子表的第一个元素与最后一个元素的位置压入栈中，而继续对前一个子表进行再分割；当分割出的子表为空时，可以从栈中退出一个子表进行分割。</p><p>这个过程直到栈为空为止，说明所有子表为空，没有子表再需分割，排序就完成。</p><h4 id="插入类排序法"><a class="header-anchor" href="#插入类排序法"></a>插入类排序法</h4><h5 id="简单插入排序"><a class="header-anchor" href="#简单插入排序"></a>简单插入排序</h5><p>插入排序，是指将无序序列中的各元素依次插入到已经有序的线性表中。</p><p>插入排序操作的思路：在线性表中，只包含第 1 个元素的子表，作为该有序表。从线性表的第 2 个元素开始直到最后一个元素，逐次将其中的每一个元素插入到前面的有序的子表中。</p><p>该方法与冒泡排序方法的效率相同，最坏的情况下需要 n(n-1)/2 次比较。</p><p>例如，有序列 5 、 2 、 9 、 4 、 1 、 7 、 6 ，将该序列从小到大进行排列。</p><p>采用简单插入排序法，具体操作步骤如下：</p><p>序列长度 n=7</p><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">5   2     9     4     1     7     6</span><br><span class="line">    j=2</span><br><span class="line">2   5     9     4     1     7     6</span><br><span class="line">          j=3</span><br><span class="line">2   5     9     4     1     7     6</span><br><span class="line">                j=4</span><br><span class="line">2   4     5     9     1     7     6</span><br><span class="line">                      j=5</span><br><span class="line">1   2     4     5     9     7     6</span><br><span class="line">                            j=6</span><br><span class="line">1   2     4     5     7     9     6</span><br><span class="line">                                  j=7</span><br></pre></td></tr></table></figure><p>插入排序后的结果   1   2     4     5     6     7     9</p><hr><h5 id="希尔排序法"><a class="header-anchor" href="#希尔排序法"></a>希尔排序法</h5><p>希尔排序法的基本思想：</p><p>将整个无序序列分割成若干小的子序列分别进行插入排序。</p><p>子序列的分割方法：将相隔某个增量 h 的元素构成一个子序列，在排序的过程中，逐次减小这个增量，最后当 h 减小到 1 时，再进行一次插入排序操作，即完成排序。</p><p>增量序列一般取 h t =n/2 k (k=1,2, … ,[log 2 n]) ，其中 n 为待排序序列的长度。</p><h4 id="选择类排序法"><a class="header-anchor" href="#选择类排序法"></a>选择类排序法</h4><h5 id="简单选择排序法"><a class="header-anchor" href="#简单选择排序法"></a>简单选择排序法</h5><p>基本思路：扫描整个线性表，从中选出最小的元素，将它交换到表的最前面，然后对后面的子表采用相同的方法，直到子表为空为止。</p><p>对于长度为 n 的序列，需要扫描 n-1 次，每一次扫描均找出剩余的子表中最小的元素，然后将该最小元素与子表的第一个元素进行交换。</p><p>例如，有序列 5 、 2 、 9 、 4 、 1 、 7 、 6 ，将该序列从小到大进行排列。</p><p>采用简单选择排序法，具体操作步骤如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">原序列       5   2   9   4   1   7   6</span><br><span class="line">第一遍扫描   1   2   9   4   5   7   6</span><br><span class="line">第二遍扫描   1   2   9   4   5   7   6</span><br><span class="line">第三遍扫描   1   2   4   9   5   7   6</span><br><span class="line">第四遍扫描   1   2   4   5   9   7   6</span><br><span class="line">第五遍扫描   1   2   4   5   6   7   9</span><br><span class="line">第六遍扫描   1   2   4   5   6   7   9</span><br><span class="line">排序结果     1   2   4   5   6   7   9</span><br></pre></td></tr></table></figure><hr><h5 id="堆排序法-nlog2n"><a class="header-anchor" href="#堆排序法-nlog2n"></a>堆排序法 nlog2n</h5><p>堆排序法属于选择类排序方法。</p><p>堆的定义：具有 n 个元素的序列（ h 1 ,h 2 , … ,h n ），当且仅当满足 <img src="5.png" alt="堆">（ I=1,2, … ,n/2 ）时称之为堆。</p><p>本节只讨论满足前者条件的堆。</p><p>由堆的定义看，堆顶元素（即第一个元素）必为最大项。</p><p>可以用一维数组或完全二叉树来表示堆的结构。</p><p>用完全二叉树表示堆时，树中所有非叶子结点值均不小于其左右子树的根结点的值，因此堆顶（完全二叉树的根结点）元素必须为序列的 n 个元素中的最大项。</p><p>例如，有序列 5 、 2 、 9 、 4 、 1 、 7 、 6 ，将该序列从小到大进行排列。</p><p>利用堆排序法将该序列进行排序。</p><p>操作方式即：先将无序堆的根结点 5 与左右子树的根结点 2 、 9 进行比较， 5&lt;9 ，将 5 与 9 进行交换；整后，对左右子树进行堆调整，左子树的根结点 2 小于其左叶子结点 5 ，调整；右子树的根结点 5 小于其左右子结点 7 和 6 ，根据堆的要求，将 5 与 7 进行调整。</p><p>根据堆的定义，可以得到堆排序的方法：</p><ol><li>首先将一个无序序列建成堆</li><li>然后将堆顶元素（序列中的最大项）与堆中最后一个元素交换（最大项应该在序列的最后）。</li></ol><blockquote><p>本章应考点拨</p><p>本章内容在笔试中会出现 5-6 个题目，是公共基础知识部分出题量比较多的一章，所占分值也比较大，约 10 分。</p></blockquote><h2 id="程序设计基础"><a class="header-anchor" href="#程序设计基础"></a>程序设计基础</h2><h3 id="程序设计方法与风格"><a class="header-anchor" href="#程序设计方法与风格"></a>程序设计方法与风格</h3><p>程序设计方法：主要经过了面向过程的结构化程序设计和面向对象的程序设计方法。</p><p>程序设计风格，是指编写程序时所表现出来的特点、习惯和逻辑思路。通常，要求程序设计的风格应强调简单和清晰，必须是可以读的，可以理解的。</p><p>要形成良好的程序设计的风格，应考虑如下因素：</p><h4 id="源程序文档化"><a class="header-anchor" href="#源程序文档化"></a>源程序文档化</h4><ol><li><p>符号名的命名：符号名的命名要具有一定的实际含义，便于对程序的理解，即通常说的见名思义；</p></li><li><p>程序注释：正确的程序注释能够帮助他人理解程序。注释一般包括序言性注释和功能性注释；</p></li><li><p>视觉组织：为了使程序一目了然，可以对程序的格式进行设置，适当地通过空格、空行、缩进等使程序层次清晰。</p></li></ol><h4 id="数据说明方法"><a class="header-anchor" href="#数据说明方法"></a>数据说明方法</h4><ol><li>数据说明的次序规范化；</li><li>说明语句中变量安排有序化；</li><li>使用注释来说明复杂的数据结构。</li></ol><h4 id="语句的结构"><a class="header-anchor" href="#语句的结构"></a>语句的结构</h4><ol><li>在一行内只写一条语句；</li><li>程序的编写应该优先考虑清晰性；</li><li>除非对效率有特殊的要求，否则，应做到清晰第一，效率第二；</li><li>首先保证程序的正确，然后再要求速度；</li><li>避免使用临时变量使程序的可读性下降；</li><li>尽量使用库函数，即尽量使用系统提供的资源；</li><li>避免采用复杂的条件语句；</li><li>尽量减少使用“否定”条件的条件语句；</li><li>数据结构要有利于程序的简化；</li><li>要模块化，使模块功能尽可能单一化；</li><li>利用信息隐蔽，确保每一个模块的独立性；</li><li>从数据出发去构造程序；</li><li>不要修补不好的程序，要重新编写。</li></ol><h4 id="输入和输出"><a class="header-anchor" href="#输入和输出"></a>输入和输出</h4><ol><li>对所有的输入输出数据都要检验数据的合法性；</li><li>检查输入项的各种重要组合的合理性；</li><li>输入格式要简单，以使得输入的步骤和操作尽可能简单；</li><li>输入数据时，应允许自由格式；</li><li>应允许缺省值；</li><li>输入一批数据时，最好使用输入结束标志；</li><li>以交互式输入输出方式进行输入时，要在屏幕上使用提示符明确输入的请求，同时在数据输入过程中和输入结束时，应在屏幕上给出状态信息；</li><li>当程序设计语言对输入格式有严格要求时，应保持输入格式与输入语句的一致性；给所有的输出加注释，并设计输出报表格式。</li></ol><h3 id="⭐结构化程序设计"><a class="header-anchor" href="#⭐结构化程序设计"></a>⭐结构化程序设计</h3><h4 id="结构化程序设计的原则"><a class="header-anchor" href="#结构化程序设计的原则"></a>结构化程序设计的原则</h4><p>结构化程序设计方法的主要原则：<strong>自顶而下</strong>、<strong>逐步求精</strong>，<strong>模块化</strong>，<strong>限制使用goto 语句</strong>。</p><h5 id="⭐自顶而下"><a class="header-anchor" href="#⭐自顶而下"></a>⭐自顶而下</h5><p>程序设计时，应先考虑总体，后考虑细节；先考虑全局，后考虑局部目标。即先从最上层总目标开始设计，逐步使问题具体化。</p><h5 id="逐步求精"><a class="header-anchor" href="#逐步求精"></a>逐步求精</h5><p>对复杂问题，应设计一些子目标作为过渡，逐步细化。</p><h5 id="模块化处理"><a class="header-anchor" href="#模块化处理"></a>模块化处理</h5><p>一个复杂问题，都是由若干个稍简单的问题构成的。模块化即是将复杂问题进行分解，即将解决问题的总目标分解成若干个分目标，再进一步分解为具体的小目标，把每一个小目标称作一个模块。</p><h5 id="限制使用-goto-语句"><a class="header-anchor" href="#限制使用-goto-语句"></a>限制使用 goto 语句</h5><p>goto 语句可以提高效率，但对程序的可读性、维护性都造成影响，因此应尽量不用 goto 语句。</p><h4 id="结构化程序设计的基本结构与特点"><a class="header-anchor" href="#结构化程序设计的基本结构与特点"></a>结构化程序设计的基本结构与特点</h4><p>结构化程序设计是程序设计的先进方法和工具，采用结构化程序设计可以使程序结构良好、易读、易理解、易维护。</p><h5 id="顺序结构"><a class="header-anchor" href="#顺序结构"></a>顺序结构</h5><p>顺序结构即是顺序执行的结构，是按照程序语句行的自然顺序，一条一条语句地执行程序。</p><h5 id="选择结构"><a class="header-anchor" href="#选择结构"></a>选择结构</h5><p>选择结构又称分支结构，它包括简单选择和多分支选择结构。程序的执行是根据给定的条件，选择相应的分支来执行。</p><h5 id="重复结构"><a class="header-anchor" href="#重复结构"></a>重复结构</h5><p>重复结构又称循环结构，根据给定的条件，决定是否重复执行某一相同的或类似的程序段。利用重复结构可以大量简化程序行。</p><h4 id="结构化程序设计原则和方法的应用"><a class="header-anchor" href="#结构化程序设计原则和方法的应用"></a>结构化程序设计原则和方法的应用</h4><ol><li><p>使用程序设计语言中的顺序、选择、循环等有限的控制结构表示程序的控制逻辑；</p></li><li><p>选用的控制结构只允许有一个入口和一个出口；</p></li><li><p>程序语句组成容易识别的块，每块只有一个入口和一个出口；</p></li><li><p>复杂结构应该用嵌套的基本控制结构进行组合嵌套来实现；</p></li><li><p>语言中所有没有的控制结构，应该采用前后一致的方法来模拟；</p></li><li><p>严格控制 goto 语句的使用：</p><ul><li>用一个非结构化的程序设计语言去实现一个结构化的构造；</li><li>若不使用 goto 语句会使功能模糊；</li><li>在某种可以改善而不是损害程序可读性的情况下。</li></ul></li></ol><h3 id="面向对象的程序设计"><a class="header-anchor" href="#面向对象的程序设计"></a>面向对象的程序设计</h3><h4 id="关于面向对象方法"><a class="header-anchor" href="#关于面向对象方法"></a>关于面向对象方法</h4><p>面向对象方法的本质，是主张从客观世界固有的事物出发来构造系统，提倡用人类在现实生活中常用的思维方法来认识、理解和描述客观事物，强调最终建立的系统能够反映问题域，即系统中的对象以及对象之间的关系能够如实地反映问题域中固有事物及其关系。</p><p>面向对象的优点：</p><h5 id="与人类习惯的思维方法一致"><a class="header-anchor" href="#与人类习惯的思维方法一致"></a>与人类习惯的思维方法一致</h5><p>传统的程序设计方法是以算法作为核心，将程序与过程相互独立。</p><p>面向对象方法和技术是以对象为核心，对象是由数据和容许的操作组成的封装体，与客观实体有直接的对应关系。对象之间通过传递消息互相联系，以实现模拟世界中不同事物之间的联系。</p><h5 id="稳定性好"><a class="header-anchor" href="#稳定性好"></a>稳定性好</h5><p>面向对象方法基于构造问题领域的对象模型，以对象为中心构造软件系统。它的基本方法是用对象模拟问题领域中的实体，以对象间的联系刻画实体间的联系。</p><h5 id="可重用性好"><a class="header-anchor" href="#可重用性好"></a>可重用性好</h5><p>软件的重用性是指在不同的软件开发过程中重复使用相同或相似的软件元素的过程。</p><h5 id="易于开发大型软件产品"><a class="header-anchor" href="#易于开发大型软件产品"></a>易于开发大型软件产品</h5><p>在使用面向对象进行软件开发时，可以把大型产品看作是一系列本质上相互独立的小产品来处理，降低了技术难度，也使软件开发的管理变得容易。</p><h5 id="可维护性好"><a class="header-anchor" href="#可维护性好"></a>可维护性好</h5><ol><li>利用面向对象的方法开发的软件稳定性比较好</li><li>用面向对象的方法开发的软件比较容易修改</li><li>用面向对象的方法开发的软件比较容易理解</li><li>易于测试和调试</li></ol><h4 id="⭐面向对象方法的基本概念"><a class="header-anchor" href="#⭐面向对象方法的基本概念"></a>⭐面向对象方法的基本概念</h4><h5 id="⭐对象"><a class="header-anchor" href="#⭐对象"></a>⭐对象</h5><p>在面向对象程序设计方法中， 对象是系统中用来描述客观事物的一个实体，是构成系统的一个基本单位 ，它由一组表示其静态特征的属性和它执行的一组操作组成。</p><p>对象的基本特点：</p><ul><li><p>标识的唯一性：对象是可区分的，并且由对象的内在本质来区分，而不是通过描述来区分。</p></li><li><p>分类性：指可以将具有相同属性和操作的对象抽象成类。</p></li><li><p>多态性：指同一个操作可以是不同对象的行为。</p></li><li><p>封装性：从外面看只能看到对象的外部特征，即只需知道数据的取值范围和可以对该数据施加的操作，根本无需知道数据的具体结构以及实现操作的算法。</p></li><li><p>模块独立性好：对象是面向对象的软件的基本模块，它是由数据及可以对这些数据施加的操作所组成的统一体，而且对象是以数据为中心的，操作围绕对其数据所需做的处理来设置，没有无关的操作。从模块的独立性考虑，对象内容各种元素彼此相结合得很紧密，内聚性强。</p></li></ul><h5 id="类和实例"><a class="header-anchor" href="#类和实例"></a>类和实例</h5><p>将属性、操作相似的对象归为类。具有共同的属性、共同的方法的对象的集合，即是类。</p><p>类是对象的抽象，它描述了属于该对象的所有对象性质，而一个对象则是其对应类的一个实例。</p><h5 id="消息"><a class="header-anchor" href="#消息"></a>消息</h5><p>消息是一个实例与另一个实例之间传递的信息，它请求对象执行某一处理或回答某一个要求的信息，它统一了数据流和控制流。</p><p>消息只包含传递者的要求，它告诉接受者需要做哪些处理，并不指示接受者怎样去完成这些处理。</p><h5 id="继承"><a class="header-anchor" href="#继承"></a>继承</h5><p>继承是使用已有的类定义作为基础建立新类的定义技术。已有的类可当作基类来引用，则新类相应地可作为派生类来引用。</p><p>继承即是指能够直接获得已有的性质和特征，而不必重复定义它们。</p><h5 id="多态性"><a class="header-anchor" href="#多态性"></a>多态性</h5><p>对象根据所接受的消息而做出动作，同样的消息被不同的对象接受时可导致完全不同的行动，该现象称为多态性。</p><p>在面向对象技术中，多态性是指子类对象可以像父类对象那样使用，同样的消息可以发送给父类对象也可以发送给子类对象。</p><p>多态性机制增加了面向对象软件系统的灵活性，减少了信息冗余，而且显著提高了软件的可重用性可扩充性。</p><blockquote><p>本章应考点拨</p><p>本章在考试中会出现约 1 个题目，所占分值大约占 2 分，是出题量较小的一章。本章内容比较少，也很简单，掌握住基本的概念就可以轻松应对考试了，所以在这部分丢分，比较可惜。</p></blockquote><h2 id="软件工程基础"><a class="header-anchor" href="#软件工程基础"></a>软件工程基础</h2><h3 id="学习目标与要求"><a class="header-anchor" href="#学习目标与要求"></a>学习目标与要求</h3><ol><li>了解软件工程的基本概念；</li><li>了解软件工程过程与软件的生命周期，以及软件工程的目标和原则；</li><li>了解利用结构化分析法进行软件工程中的需求分析的方法，并了解需求分析的方法和需要完成的任务；</li><li>了解数据流图的使用方法；</li><li>了解如何利用结构化设计方法进行软件设计，并了解软件设计的一些常用用工具；</li><li>了解软件测试的目的和方法，以及软件测试的准则，了解常用的软件测试方法的区别和各自的功能与特点；</li><li>了解程序调试的方法和原则。</li></ol><h3 id="⭐软件工程基本概念"><a class="header-anchor" href="#⭐软件工程基本概念"></a>⭐软件工程基本概念</h3><h4 id="软件定义与软件特点"><a class="header-anchor" href="#软件定义与软件特点"></a>软件定义与软件特点</h4><h5 id="软件的定义"><a class="header-anchor" href="#软件的定义"></a>软件的定义</h5><p>与计算机系统的操作有关的计算机程序、规程、规则，以及可能有的文件、文档及数据。</p><h5 id="⭐软件的特点"><a class="header-anchor" href="#⭐软件的特点"></a>⭐软件的特点</h5><ol><li><strong>软件是一种逻辑实体</strong>，而不是物理实体，具有抽象性；</li><li>软件的生产与硬件不同，<strong>它没有明显的制作过程</strong>；</li><li><strong>软件在运行、使用期间不存在磨损、老化问题</strong>；但为了适应硬件、环境以及需求的变化要进行修改，会导致一些错误的引入，导致软件失效率升高，从而使得软件退化；</li><li>软件的开发、运行对计算机系统具有依赖性，<strong>受到计算机系统的限制</strong>，这导致了软件移植的问题；</li><li>软件复杂性高，成本昂贵。软件开发需要投入大量、高强度的脑力劳动，成本高，风险大；</li><li>软件开发涉及诸多的社会因素。许多软件的开发和运行涉及软件用户的机构设置，体制问题以及管理方式等，甚至涉及到人们的观念和心理，软件知识产权及法律等问题。</li></ol><h5 id="软件的分类"><a class="header-anchor" href="#软件的分类"></a>软件的分类</h5><p>按功能分，可分为：</p><ul><li><p>应用软件：为解决特定领域的应用而开发的软件</p></li><li><p>系统软件：是计算机管理自身资源，提高计算机使用效率并为计算机用户提供各种服务的软件</p></li><li><p>支撑软件（或工具软件）：介于系统软件和应用软件之间，协助用户开发软件的工具性软件，包括辅助和支持开发和维护应用软件的工具软件</p></li></ul><h4 id="软件危机与软件工程"><a class="header-anchor" href="#软件危机与软件工程"></a>软件危机与软件工程</h4><h5 id="软件危机"><a class="header-anchor" href="#软件危机"></a>软件危机</h5><p>泛指在计算机软件的开发和维护过程中所遇到的一系列严重问题。它主要表现在：</p><ol><li>软件需求的增长得不到满足，用户对系统不满意的情况经常发生；</li><li>软件开发成本和进度无法控制。开发的成本超预算和开发周期的超期经常出现；</li><li>软件质量难以保证；</li><li>软件不可维护或维护程度非常低；</li><li>软件成本不断提高；</li><li>软件开发生产率的提高赶不上硬件的发展和应用需求的增长。</li></ol><h5 id="⭐软件工程"><a class="header-anchor" href="#⭐软件工程"></a>⭐软件工程</h5><p>软件工程的定义：是应用于计算机软件的定义、开发和维护的一整套方法、工具、文档、实践标准和工序。</p><p>⭐软件工程包括 3 个要素：方法、工具和过程。</p><p>方法：完成软件工程项目的技术手段；</p><p>工具：支持软件的开发、管理、文档生成；</p><p>过程：支持软件开发的各个环节的控制、管理。</p><h4 id="软件工程过程与软件生命周期"><a class="header-anchor" href="#软件工程过程与软件生命周期"></a>软件工程过程与软件生命周期</h4><h5 id="软件工程过程"><a class="header-anchor" href="#软件工程过程"></a>软件工程过程</h5><p>软件工程过程把输入转化为输出的一组彼此相关的资源和活动。支持软件工程过程的两方面内涵：</p><ol><li><p>软件工程过程是指为获得软件产品，在软件工具支持下由软件工程师完成的一系列软件工程活动。它包括 4 种基本活动：</p><ul><li>P— 软件规格说明。规定软件的功能及其运行时的限制；</li><li>D— 软件开发。产生满足规格说明的软件；</li><li>C— 软件确认。确认软件能够满足客户提出的要求；</li><li>A— 软件演进过程。为满足客户的变更要求，软件必须在使用的过程中演进。</li></ul></li><li><p>使用适当的资源（包括人员、硬软件工具、时间等），为开发软件进行的一组开发活动，在过程结束时将输入（用户要求）转化为输出（软件产品）。</p></li></ol><p>软件工程过程是将软件工程的方法和工具综合起来，以达到合理、及时地进行计算机软件开发的目的。</p><h5 id="软件生命周期"><a class="header-anchor" href="#软件生命周期"></a>软件生命周期</h5><p>将软件产品从提出、实现、使用维护到停止使用退役的过程称为软件生命周期。即软件的生命周期就是软件产品从开始考虑其概念开始，到软件产品不能使用为止的整个时期都属于软件生命周期。一般包括可行性研究与需求分析、设计、实现、测试、交付使用以及维护等活动。这些活动可以有重复，执行时也可以有迭代。</p><p>生命周期的主要阶段：</p><ul><li><p>软件定义 ( 定义，可行性研究，需求分析 )</p></li><li><p>软件开发 （概要设计，详细设计，实施）</p></li><li><p>软件维护 ( 运行和维护 )</p></li></ul><p>软件生命周期的主要活动阶段是：</p><ol><li>可行性研究与计划制定：确定待开发软件系统的开发目标和总的要求，给出它的功能、性能、可靠性以及接口等方面的可能方案，制定完成开发任务的实话计划；</li><li>需要分析。对待开发软件提出的需求进行分析并给出详细的定义；</li><li>软件设计。系统设计人员和程序设计人员给出软件的结构、模块的划分、功能的分配以及处理流程；</li><li>软件实现。把软件设计转换成计算机可以接受的程序代码。即完成源程序的编码，编写用户手册、操作手册等面向用户的文档，编写单元测试计划；</li><li>软件测试。在设计测试用例的基础上，检验软件的各个组成部分，编写测试分析报告；</li><li>运行和维护。将已交付的软件投入运行，并在运行使用中不断地维护，根据新提出的需求进行必要且可能的扩充和删改。</li></ol><h4 id="软件工程的目标与原则"><a class="header-anchor" href="#软件工程的目标与原则"></a>软件工程的目标与原则</h4><h5 id="软件工程的目标"><a class="header-anchor" href="#软件工程的目标"></a>软件工程的目标</h5><p>软件工程的目标：在给定成本、进度的情况下，开发出具有有效性、可靠性、可理解性、可维护性、可重用性、可适应性、可移植性、可追踪性和可互操作性且满足用户需求的产品。</p><p>软件工程需要达到的基本目标：</p><ul><li><p>付出较低的开发成本</p></li><li><p>达到要求的软件功能</p></li><li><p>取得较好的软件性能</p></li><li><p>开发的软件易于移植</p></li><li><p>需要较低的维护费用</p></li><li><p>能按时完成开发，及时交付使用</p></li></ul><p>软件工程的理论和技术性研究的内容包括：软件开发技术和软件工程管理。</p><h6 id="软件开发技术"><a class="header-anchor" href="#软件开发技术"></a>软件开发技术</h6><p>软件开发方法学、开发过程、开发工具和软件工程环境，其主体内容是软件开发方法学。软件开发方法学是根据不同的软件类型，按不同的观点和原则，对软件开发中应遵循的策略、原则、步骤和必须产生的文档资料都做出规定，从而使软件开发能够进入规范化和工程化的阶段。</p><h6 id="软件工程管理"><a class="header-anchor" href="#软件工程管理"></a>软件工程管理</h6><p>软件工程管理：软件管理学、软件工程经济学、软件心理学等内容。</p><p>软件工程管理学包括：人员组织、进度安排、质量保证、配置管理、项目计划等。</p><p>软件工程经济学：是研究软件开发中成本的估算、成本效益分析的方法和技术，用经济学的基本原理事研究软件工程开发中的经济效益问题。</p><p>软件心理学：从个体心理、人类行为、组织行为和企业文化等角度来研究软件管理和软件工程。</p><h5 id="软件工程的原则"><a class="header-anchor" href="#软件工程的原则"></a>软件工程的原则</h5><ol><li>抽象。抽取事物取基本的特征和行为，忽略非本质细节。采用分层次抽象，自顶向下，逐层细化的办法控制软件开发过程的复杂性；</li><li>信息隐蔽。采用封装技术，将程序模块的实现细节隐藏起来，使模块接口尽量简单；</li><li>模块化。模块是程序中相对独立的成分，一个独立的编程单位，应有良好的接口定义。块太大会使模块内部过渡复杂，不利于对模块的理解和修改，也不利于模块的调试和重用；模块太小会使程序结构过于复杂，难于控制；</li><li>局部化。在同一个物理模块中集中逻辑上相互关联的计算资源，保证模块间具有松散的耦合关系，模块内部有较强的内聚性；</li><li>确定性。所有的概念表达应是确定的、无歧义且规范。</li><li>一致性。包括程序、数据和文档的整个软件系统的各模块应使用已知的概念、符号和术语；程序内外部接口保持一致，系统规格说明与系统行为应保持一致；</li><li>完备性。软件系统不丢失任何重要成份，完全实现系统所需要的功能；</li><li>可验证性。开发大型软件系统需要对系统自顶向下，逐层分解。</li></ol><h4 id="软件开发工具与软件开发环境"><a class="header-anchor" href="#软件开发工具与软件开发环境"></a>软件开发工具与软件开发环境</h4><h5 id="软件开发工具"><a class="header-anchor" href="#软件开发工具"></a>软件开发工具</h5><p>早期的软件开发，最早使用的是单一的程序设计语言，没有相应的开发工具，效率很低，随着软件开发工具的发展，提供了自动的或半自动的软件支撑环境，为软件开发提供了良好的环境。</p><h5 id="软件开发环境"><a class="header-anchor" href="#软件开发环境"></a>软件开发环境</h5><p>软件开发环境或称软件工程环境是全面支持软件开发全过程的软件工具集合。</p><p>计算机辅助软件工程将各种软件工具、开发机器和一个存放开发过程信息的中心数据库组成起来，形成软件工程环境。</p><h3 id="⭐⭐结构化分析方法"><a class="header-anchor" href="#⭐⭐结构化分析方法"></a>⭐⭐结构化分析方法</h3><h4 id="需求分析与需求分析方法"><a class="header-anchor" href="#需求分析与需求分析方法"></a>需求分析与需求分析方法</h4><h5 id="⭐⭐需求分析"><a class="header-anchor" href="#⭐⭐需求分析"></a>⭐⭐需求分析</h5><p><strong>软件需求分析是指用户对目标软件系统在功能、行为、性能、设计约束等方面的期望。</strong></p><p>需求分析的任务是发现需求、求精、建模和定义需求的过程。</p><h6 id="定义"><a class="header-anchor" href="#定义"></a>定义</h6><p>软件需求分析是指用户对目标软件系统在功能、行为、性能、设计约束等方面的期望。</p><h6 id="⭐需求分析阶段的工作"><a class="header-anchor" href="#⭐需求分析阶段的工作"></a>⭐需求分析阶段的工作</h6><ol><li>**需求获取。**需求获取的目的是确定对目标系统的各方面需求；</li><li>**需求分析。**对获取的需求进行分析和综合，最终给出系统的解决方案和目标系统的逻辑模型；</li><li>**编写需求规格说明书。**为用户、分析人员和设计人员之间进行交流提供方便。</li><li>**需求评审。**对需求分析阶段的工作进行复审，验证需求文档的一致性、可靠性、完事性和有效性。</li></ol><h5 id="需求分析方法"><a class="header-anchor" href="#需求分析方法"></a>需求分析方法</h5><ol><li><p>结构化分析方法包括：</p><ul><li>面向数据流的结构化分析方法</li><li>面向数据结构的 Jackson 方法</li><li>面向数据结构的结构化数据系统开发方法</li></ul></li><li><p>面向对象的分析方法</p></li></ol><p>从需求分析建立模型的特性分，需求分析方法又分为静态分析方法和动态分析方法。</p><h4 id="结构化分析方法"><a class="header-anchor" href="#结构化分析方法"></a>结构化分析方法</h4><h5 id="关于结构化分析方法"><a class="header-anchor" href="#关于结构化分析方法"></a>关于结构化分析方法</h5><p>结构化分析方法的实质是：着眼于数据流，自顶向下，逐层分解，建立系统的处理流程，以数据流图和数据字典为主要工具，建立系统的逻辑模型。</p><p>结构化分析的步骤：</p><ul><li><p>通过对用户的调查，以软件需求为线索，获得系统的具体模型；</p></li><li><p>去掉模型的非本质因素，抽象出系统的逻辑模型；</p></li><li><p>根据计算机的特点分析当前系统与目标系统的差别，建立目标系统的逻辑模型；</p></li><li><p>完善目标系统交补充细节，写出目标系统的软件需求规格说明；</p></li><li><p>评审直到确认完全符合用户对软件的需求。</p></li></ul><h5 id="⭐结构化分析的常用工具-（数据流图、数据字典、判定表、判定树）"><a class="header-anchor" href="#⭐结构化分析的常用工具-（数据流图、数据字典、判定表、判定树）"></a>⭐结构化分析的常用工具 （数据流图、数据字典、判定表、判定树）</h5><h6 id="数据流图"><a class="header-anchor" href="#数据流图"></a>数据流图</h6><p>数据流图从数据传递和加工的角度，来刻画数据流从输入到输出的移动变换过程。</p><p>数据流图下的图形元素：</p><p>（圆），加工（转换）。输入数据经过加工变换产生输出</p><p>（箭头），数据流。沿箭头方向传送数据的通道，一般在旁边标注数据流名</p><p>（平行的二条直线），存储文件（数据源）。表示处理过程中存放各种数据的文件。</p><p>（长方形），源，潭。表示系统和环境的接口，属于系统之外的实体。</p><h6 id="数据字典"><a class="header-anchor" href="#数据字典"></a>数据字典</h6><p>数据字典是结构化分析方法的核心。对数据流图中出现的被命名的图形元素的确切解释。通常包括：名称、别名、何处使用 / 如何使用、内容描述、补充信息等。</p><h6 id="判定树"><a class="header-anchor" href="#判定树"></a>判定树</h6><p>利用判定树，对数据结构中的数据之间的关系进行描述，弄清楚判定条件之间的从属关系、并列关系、选择关系。</p><h6 id="判定表"><a class="header-anchor" href="#判定表"></a>判定表</h6><p>在数据流图中的加工要依赖于多个条件的取值，即完成该加工的一组动作是由于某一组 条件取值的组合而引发的情况。它与判定树是相似的，但更适宜于较复杂的条件组合。</p><h4 id="⭐软件需求规格说明书"><a class="header-anchor" href="#⭐软件需求规格说明书"></a>⭐软件需求规格说明书</h4><p>是需求分析阶段的最后成果，是软件开发的重要文档之一。</p><h5 id="作用"><a class="header-anchor" href="#作用"></a>作用</h5><ul><li><p>便于用户、开发人员进行理解和交流</p></li><li><p>反映用户问题的结构，可以作为软件开发工作的基础和依据</p></li><li><p>作为确认测试和验收的依据</p></li></ul><h5 id="内容"><a class="header-anchor" href="#内容"></a>内容</h5><p>在软件计划中确定的软件范围加以展开，制定出完整的信息描述、详细的功能说明、恰当的检验标准以及其他与要求有关的数据。</p><h5 id="特点"><a class="header-anchor" href="#特点"></a>特点</h5><p>软件需求规格说明书是确保软件质量的措施，它的内涵是：</p><ul><li><p>正确性</p></li><li><p>无歧义性</p></li><li><p>完整性</p></li><li><p>可验证性</p></li><li><p>一致性</p></li><li><p>可理解性</p></li><li><p>可修改性</p></li><li><p>可追踪性</p></li></ul><h3 id="结构化设计方法"><a class="header-anchor" href="#结构化设计方法"></a>结构化设计方法</h3><h4 id="软件设计的基本概念"><a class="header-anchor" href="#软件设计的基本概念"></a>软件设计的基本概念</h4><h5 id="软件设计的基础"><a class="header-anchor" href="#软件设计的基础"></a>软件设计的基础</h5><p>软件设计包括软件结构设计、数据设计、接口设计、过程设计。其中，结构设计是定义软件系统各主要部件之间的关系；数据设计是将分析时创建的模型转化为数据结构的定义；接口设计是描述软件内部、软件和协作系统之间以及软件与人之间如何通信；过程设计是把系统结构部件转换成软件的过程性描述。</p><p>软件设计的一般过程：软件设计是一个迭代的过程；先进行高层次的结构设计；后进行低层次的过程设计；穿插进行数据设计和接口设计。</p><h5 id="软件设计的基本原理"><a class="header-anchor" href="#软件设计的基本原理"></a>软件设计的基本原理</h5><h6 id="抽象"><a class="header-anchor" href="#抽象"></a>抽象</h6><p>抽象的层次从概要设计到详细设计逐渐降低。在软件概要设计中的模块分层也是由抽象到具体逐步分析和构造出来的。</p><h6 id="模块化"><a class="header-anchor" href="#模块化"></a>模块化</h6><p>模块是指把一个待开发的软件分解成若干小的简单的部分。</p><p>模块化是指解决一个复杂问题时<strong>自顶向下</strong>逐层把软件系统划分成若干模块的过程。</p><h6 id="信息隐蔽"><a class="header-anchor" href="#信息隐蔽"></a>信息隐蔽</h6><p>在一个模块内包含的信息（过程或数据），对于不需要这些信息的其他模块来说是不能访问的。</p><h6 id="模块独立性"><a class="header-anchor" href="#模块独立性"></a>模块独立性</h6><p>独立性是指每个模块只完成系统要求的独立的子功能，并且与其他模块的联系最少且接口简单。</p><p>衡量软件的模块独立性的标准：</p><ul><li><p>内聚性：一个模块内部各个元素间彼此结合的紧密程度的度量</p></li><li><p>耦和性：模块间相互连接的紧密程序的度量</p></li></ul><h5 id="结构化的设计方法"><a class="header-anchor" href="#结构化的设计方法"></a>结构化的设计方法</h5><p>即将软件设计成相对独立、单一功能的模块组成结构。</p><h4 id="概要设计"><a class="header-anchor" href="#概要设计"></a>概要设计</h4><h5 id="概要设计的任务"><a class="header-anchor" href="#概要设计的任务"></a>概要设计的任务</h5><h6 id="设计软件系统结构"><a class="header-anchor" href="#设计软件系统结构"></a>设计软件系统结构</h6><p>即将系统划分成模块以及模块的层次结构。</p><h6 id="数据结构及数据库设计"><a class="header-anchor" href="#数据结构及数据库设计"></a>数据结构及数据库设计</h6><p>数据设计是实现需求定义和规格说明过程中提出的数据对象的逻辑表示。</p><p>数据设计的具体任务是：</p><ul><li><p>确定输入、输出文件的详细数据结构</p></li><li><p>结合算法设计，确定算法所必须的逻辑数据结构及其操作</p></li><li><p>确定对逻辑数据结构所必须的那些操作的程序模块，限制和确定各个数据设计决策的影响范围</p></li><li><p>需要与操作系统或调度程序接口所必须的控制表进行数据交换时，确定其详细的数据结构和使用规则</p></li><li><p>数据的保护性设计：防卫性、一致性、冗余性设计</p></li></ul><h6 id="编写概要设计文档"><a class="header-anchor" href="#编写概要设计文档"></a>编写概要设计文档</h6><p>需要编写的文档有：</p><ul><li><p>概要设计说明书</p></li><li><p>数据库设计说明书</p></li><li><p>集成测试计划</p></li></ul><h6 id="概要设计文档评审"><a class="header-anchor" href="#概要设计文档评审"></a>概要设计文档评审</h6><p>需要评审的内容：设计部分是否完整地实现了需求中规定的功能、性能等要求，设计方案的可行性，关键的处理及内外部接口定义的正确性、有效性，各部分之间的一致性等</p><p>软件结构设计工具是结构图，描述软件系统的层次和分块结构关系，它反映了整个系统的功能实现以及模块与模块之间的联系与通讯，是未来程序中的控制层次体系。</p><p>结构图的元素：</p><ul><li><p>矩形表示一个模块，在矩形内注明模块的功能和名字</p></li><li><p>箭头表示模块间的调用关系。带实心圆的箭头表示传递的是控制信息，带空心圆的箭头表示传递的是数据</p></li></ul><p>结构图中常有的模块类型：</p><ul><li><p>传入模块</p></li><li><p>传出模块</p></li><li><p>变换模块</p></li><li><p>协调模块</p></li></ul><h5 id="面向数据流的设计方法"><a class="header-anchor" href="#面向数据流的设计方法"></a>面向数据流的设计方法</h5><ol><li>数据流类型<ul><li>变换型。将数据流分成三个部分：输入数据、中心变换和输出数据三个部分。</li><li>事务型。在事务中心接收数据，分析数据以确定它的类型，再选取一条活动的通路</li></ul></li></ol><p>面向数据流设计方法的实施要点与设计过程</p><h5 id="设计的准则"><a class="header-anchor" href="#设计的准则"></a>设计的准则</h5><ul><li><p>提高模块的独立性</p></li><li><p>模块规模适中</p></li><li><p>深度、宽度、扇出和扇入适当</p></li><li><p>使模块的作用域在该模块的控制域内</p></li><li><p>应减少模块的接口和界面的复杂性</p></li><li><p>设计成单入口、单出口的模块</p></li><li><p>设计功能可预测的模块</p></li></ul><h4 id="详细设计"><a class="header-anchor" href="#详细设计"></a>详细设计</h4><p>详细设计，即为软件结构图中的每一个模块确定实现算法和局部数据结构，用某种工具表示算法和数据结构的细节。</p><p>常用的设计工具有：</p><ul><li><p>图形工具：程序流程图， N-S ， PAD ， HIPO</p></li><li><p>表格工具：判定表</p></li><li><p>语言工具： PDL （伪码）</p></li></ul><h3 id="⭐软件测试"><a class="header-anchor" href="#⭐软件测试"></a>⭐软件测试</h3><h4 id="软件测试的目的"><a class="header-anchor" href="#软件测试的目的"></a>软件测试的目的</h4><p>使用人工或自动手段来运行或测定某个系统的过程，其目的在于检验它是否满足规定的需求或是否弄清预期的结果与实际结果之间的差别。</p><h4 id="软件测试的准则"><a class="header-anchor" href="#软件测试的准则"></a>软件测试的准则</h4><ul><li><p>所有测试应追溯到需求</p></li><li><p>严格执行测试计划，排除测试的随意性</p></li><li><p>充分注意测试中的群集现象</p></li><li><p>程序员应避免检查自己的程序</p></li><li><p>穷举测试不可能</p></li><li><p>妥善保存测试计划、测试用例、出错统计和最终分析报告，为维护提供方便</p></li></ul><h4 id="软件测试技术与方法综述"><a class="header-anchor" href="#软件测试技术与方法综述"></a>软件测试技术与方法综述</h4><h5 id="静态测试与动态测试"><a class="header-anchor" href="#静态测试与动态测试"></a>静态测试与动态测试</h5><p>静态测试包括：代码检查、静态结构分析、代码质量度量等。</p><p>动态测试是基于计算机的测试，根据软件需求设计测试用例，利用这些用例去运行程序，以发现程序错误的过程。</p><h5 id="⭐白盒测试方法与测试用例设计（逻辑覆盖和基本路径测试）"><a class="header-anchor" href="#⭐白盒测试方法与测试用例设计（逻辑覆盖和基本路径测试）"></a>⭐白盒测试方法与测试用例设计（逻辑覆盖和基本路径测试）</h5><p>白盒测试也称结构测试或逻辑驱动测试。</p><p>白盒测试的原则：保证所有的测试模块中每一条独立路径至少执行一次；保证所有的判断分支至少执行一次；保证所有的模块中每一个循环都在边界条件和一般条件下至少各执行一次；验证所有内部数据结构的有效性</p><p>主要的方法有：<strong>逻辑覆盖（包括语句覆盖、路径覆盖、判定覆盖、条件覆盖和判断 — 条件覆盖）</strong>、<strong>基本路径测试</strong>等</p><h5 id="⭐黑盒测试方法与测试用例设计-等价划分、边界值测试、错误推测、因果图"><a class="header-anchor" href="#⭐黑盒测试方法与测试用例设计-等价划分、边界值测试、错误推测、因果图"></a>⭐黑盒测试方法与测试用例设计 ( 等价划分、边界值测试、错误推测、因果图 )</h5><p>黑盒测试方法也称功能测试或数据驱动测试，是对软件已经实现的功能是否满足需求进行测试和验证。</p><p>黑盒测试主要诊断功能不对或遗漏、界面错误、数据结构或外部数据库访问错误、性能错误、初始化和终止条件错。</p><p>黑盒测试方法主要有：<strong>等价类划分法（包括有效等价类和无效等价类）</strong>、<strong>边界值分析法</strong>、<strong>错误推测法</strong>、<strong>因果图</strong>等，主要用于软件确认测试。</p><h4 id="软件测试的实施-（单元测试、集成测试、确认测试、系统测试）"><a class="header-anchor" href="#软件测试的实施-（单元测试、集成测试、确认测试、系统测试）"></a>软件测试的实施 （单元测试、集成测试、确认测试、系统测试）</h4><h5 id="单元测试"><a class="header-anchor" href="#单元测试"></a>单元测试</h5><p>对模块进行测试，用于发现模块内部的错误</p><h5 id="集成测试"><a class="header-anchor" href="#集成测试"></a>集成测试</h5><p>测试和组装软件的过程，主要用于发现与接口有关的错误。</p><p>集成测试包括的内容：软件单元的接口测试、全局数据结构测试、边界条件和非法输入的测试等。</p><p>集成测试分为：增量方式组装（包括自顶而下、自底而上、自顶向下和自底向上的混合增量方式）与非增量方式组装。</p><h5 id="确认测试"><a class="header-anchor" href="#确认测试"></a>确认测试</h5><p>验证软件的功能和性能及其他特征是否满足了需求规格说明中确定的各种需求，以及软件配置是否完全、正确。</p><h5 id="系统测试"><a class="header-anchor" href="#系统测试"></a>系统测试</h5><p>将经过测试后的软件，与计算机的硬件、外设、支持软件、数据和人员等其他元素组合在一起，在实际运行环境中进行一系列的集成测试和确认测试。</p><h3 id="⭐程序的调试"><a class="header-anchor" href="#⭐程序的调试"></a>⭐程序的调试</h3><h4 id="程序调试基本概念"><a class="header-anchor" href="#程序调试基本概念"></a>程序调试基本概念</h4><p>程序调试活动包括：根据错误的迹象确定程序中错误的确切性质、原因和位置；对程序进行修改，排除错误。</p><h5 id="⭐基本步骤"><a class="header-anchor" href="#⭐基本步骤"></a>⭐基本步骤</h5><ul><li>错误定位</li><li>修改设计和代码，以排除错误</li><li>进行回溯测试，防止引进新的错误。</li></ul><h5 id="程序调试的原则"><a class="header-anchor" href="#程序调试的原则"></a>程序调试的原则</h5><ol><li><p>确定错误的性质和位置</p><ul><li>分析与错误有关的信息</li><li>避开死胡同</li><li>调试工具只是一种辅助手段，只能帮助思考，不能代替思考</li><li>避免用试探法</li></ul></li><li><p>修改错误的原则</p><ul><li>在出现错误的地方，有可能还有别的错误，在修改时，一定要观察和检查相关的代码，以防止其他的错误</li><li>一定要注意错误代码的修改，不要只注意表象，而要注意错误的本身，把问题解决</li><li>注意在修正错误时，可能代入新的错误，错误修改后，一定要进行回归测试，避免新的错误产生</li><li>修改错误也是程序设计的一种形式</li><li>修改源代码程序，不要改变目标代码</li></ul></li></ol><h4 id="软件调试方法"><a class="header-anchor" href="#软件调试方法"></a>软件调试方法</h4><h5 id="强行排错法"><a class="header-anchor" href="#强行排错法"></a>强行排错法</h5><p>通过内存全部打印来排错</p><p>在程序特定部位设置打印语句 — 即断点法</p><p>自动调试工具。</p><h5 id="回溯法"><a class="header-anchor" href="#回溯法"></a>回溯法</h5><p>适合小规模程序的排错。发现错误，分析错误表象，确定位置，再回溯到源程序代码，找到错误位置或确定错误范围。</p><h5 id="原因排除法"><a class="header-anchor" href="#原因排除法"></a>原因排除法</h5><p>原因排除法包括：演绎法、归纳法和二分法。</p><p>演绎法：是一种从一般原理或前提出法，经过排除和精化的过程来推导出结论的思考方法。</p><p>归纳法：从一种特殊推断出一般的系统化思考方法。其基本思想是从一些线索着手，通过分析寻找到潜在的原因，从而找出错误。</p><p>二分法：如果已知每个变量在程序中若干个关键点的正确值，则可以使用定值语句在程序中的某点附近给这些变量赋值，然后运行程序并检查程序的输出。</p><h2 id="数据库设计基础"><a class="header-anchor" href="#数据库设计基础"></a>数据库设计基础</h2><h3 id="⭐数据库系统的基本概念"><a class="header-anchor" href="#⭐数据库系统的基本概念"></a>⭐数据库系统的基本概念</h3><h4 id="数据、数据库、数据库管理系统"><a class="header-anchor" href="#数据、数据库、数据库管理系统"></a>数据、数据库、数据库管理系统</h4><h5 id="数据"><a class="header-anchor" href="#数据"></a>数据</h5><p>数据是指存储在某一种媒体上能够被识别的物理符号，即描述事物的符号记录。</p><p>数据是有结构的。首先，数据有型与值的区别，型即类型，值是符合指定类型的值。</p><p>数据的概念在数据处理领域中已经大大地拓宽了。数据不仅包括数字、字母、文字和其他特殊字符组成的文本形式的数据，而且还包括图形、图像、动画、影像、声音等多媒体数据。但是使用最多、最基本的仍然是文字数据。</p><h5 id="数据库"><a class="header-anchor" href="#数据库"></a>数据库</h5><p>数据库（ DataBase ， DB ），是存储在计算机存储设备上，结构化的相互关联的数据的集合。它不仅包括描述事物的数据本身，而且还包括相关事物之间的联系。</p><p>它用综合的方法组织和管理数据，具有较小的数据冗余，可供多个用户共享，具有较高的数据独立性，具有安全机制，能够保证数据的安全、可靠，允许并发地使用数据库，能有效、及时地处理数据，并能保证数据的一致性和完整性。</p><p>例如，某个学校的相关数据，如学生基本情况、选课情况、学籍管理等所涉及的相关数据的集合。</p><h5 id="数据库管理系统"><a class="header-anchor" href="#数据库管理系统"></a>数据库管理系统</h5><p>数据库管理系统（ DataBase Management System ， DBMS ）是对数据库进行管理的系统软件，它的职能是有效地组织和存储数据、获取和管理数据，接受和完成用户提出的访问数据的各种请求。同时还能保证数据的安全性、可靠性、完整性、一致性，还要保证数据的高度独立性。</p><p>数据库管理系统主要功能包括以下几个方面：</p><ol><li><p><strong>数据模式定义</strong><br>数据库管理系统负责为数据库构建模式，也为数据库构建其数据框架。</p></li><li><p><strong>数据存取的物理构建</strong><br>数据库管理系统负责为数据模式的物理存取及构建提供有效的存取方法和手段。</p></li><li><p><strong>数据操纵</strong><br>数据库管理系统为用户使用数据库中的数据提供方便，一般提供查询、插入、修改和删除数据的功能，此外，还具有简单的算术运算和统计功能，还具有专长强大的程序控制功能。</p></li><li><p><strong>数据的完整性、安全性定义与检查</strong><br>数据库中的数据具有内存语义上的关联性与一致性，即数据的完整性。数据的完整性是保证数据库中数据正确的必要条件。</p><p>数据库中的数据具有内存语义上的关联性与一致性，即数据的完整性。数据的完整性是保证数据库中数据正确的必要条件。</p></li><li><p><strong>数据的并发控制与故障恢复</strong><br>数据库是一个集成、共享的数据集合体，它能为多个应用程序服务，因此，当多个应用程序对数据库并发操作时，要保证数据不被破坏。</p></li><li><p><strong>数据的服务</strong><br>数据库管理系统提供了对数据库中数据的多种服务，如数据拷贝、转存、重组、性能监测、分析等。</p></li></ol><p>数据库管理系统提供的相应的数据语言包括如下：</p><ol><li><p><strong>数据定义语言</strong>（ Data Definition Language ， DDL ）<br>D 用户通过它可以方便地对数据库中的相关内容进行定义。例如，对数据库、表、索引进行定义。</p></li><li><p><strong>数据操纵语言</strong>（ Data Manipulation Language ， DML ）<br>用户通过它可以实现对数据库的基本操作。例如，对表中数据的查询、插入、删除和修改。</p></li><li><p><strong>数据控制语言</strong>（ Data Control Language ， DCL ）<br>负责数据完整性、安全性的定义与检查以及并发控制、故障恢复等功能，包括系统初启程序、文件读写与维护程序、存取路径管理程序、缓冲区管理程序、安全性控制程序、完整性检查程序、并发控制程序、事务管理程序、运行日志管理程序、数据库恢复程序等。</p></li></ol><p>目前流行的 DBMS 均为关系型数据库系统，发 ORACLE 、 Sybase 的 PowerBuilder 及 IBM 的 DB2 、微软件的 SQLServer 等。还有一些小型的数据库，如 Visual FoxPro 和 Access 等。</p><h5 id="数据库管理员"><a class="header-anchor" href="#数据库管理员"></a>数据库管理员</h5><p>数据库的管理员（ DataBase Administrator ， DBA ）：对数据库的规划、设计、维护、监视等进行管理。</p><p>主要工作如下：</p><ol><li><p>数据库设计</p></li><li><p>数据库维护</p></li><li><p>改善系统性能，提高系统效率</p></li></ol><h5 id="数据库系统"><a class="header-anchor" href="#数据库系统"></a>数据库系统</h5><p>数据库系统（ DataBase System ， DBS ）由如下几个部分组成：</p><ul><li><p>数据库（数据）</p></li><li><p>数据库管理系统（软件）</p></li><li><p>数据库管理员（人员）</p></li><li><p>系统平台（硬件平台和软件平台）</p></li></ul><p>硬件平台包括：</p><ul><li><p>计算机</p></li><li><p>网络</p></li></ul><p>软件平台包括：</p><ul><li><p>操作系统</p></li><li><p>数据库系统开发工具</p></li><li><p>接口软件</p></li></ul><h5 id="数据库应用系统"><a class="header-anchor" href="#数据库应用系统"></a>数据库应用系统</h5><p>数据库应用系统（ DataBase Application System ， DBAS ）是数据库系统再加上应用软件及应用界面而构成的。它包括：</p><ul><li><p>数据库</p></li><li><p>数据库管理系统</p></li><li><p>数据库管理员</p></li><li><p>硬件平台</p></li><li><p>软件平台</p></li><li><p>应用软件</p></li><li><p>应用界面</p></li></ul><h4 id="数据库系统的发展"><a class="header-anchor" href="#数据库系统的发展"></a>数据库系统的发展</h4><p>随着计算机软硬件技术的发展，数据处理方法也经历了从低级到高级的发展过程，按照数据管理的特点可将其划分为 人工管理、文件系统及数据库系统三个阶段。</p><h5 id="人工管理阶段"><a class="header-anchor" href="#人工管理阶段"></a>人工管理阶段</h5><p>在 20 世纪 50 年代，计算机主要用于数值计算。从当时的硬件看，外存只有纸带、卡片、磁带，没有直接存取设备；从软件看（实际上，当时还未形成软件的整体概念），没有操作系统以及管理数据的软件；从数据看，数据量小，数据无结构，由用户直接管理，且数据间缺乏逻辑组织，数据依赖于特定的应用程序，缺乏独立性。</p><h5 id="文件系统阶段"><a class="header-anchor" href="#文件系统阶段"></a>文件系统阶段</h5><p>是数据库系统发展的初级阶段，它提供了简单的数据共享和数据管理能力，但无法提供完整的、统一的、管理和数据共享的能力。</p><h5 id="层次数据库与网状数据库阶段"><a class="header-anchor" href="#层次数据库与网状数据库阶段"></a>层次数据库与网状数据库阶段</h5><p>20 世纪 60 年代末期，层次数据库与网状数据库开始发展，它们为统一管理和数据共享提供了支撑，即标志着数据库系统的真正来临。但它们有许多的不足，如受文件的物理影响较大，对数据库使用带来许多不便，数据结构复杂，不变于推广。</p><h5 id="关系数据库系统阶段"><a class="header-anchor" href="#关系数据库系统阶段"></a>关系数据库系统阶段</h5><p>关系数据库系统出现于 20 世界 70 年代，它的数据库结构简单，使用方便，逻辑性强物理性少，使用广泛。</p><p>由于应用的领域不同，它常分为：</p><ul><li><p>工程数据库系统</p></li><li><p>图形数据库系统</p></li><li><p>图像数据库系统</p></li><li><p>统计数据库系统</p></li><li><p>知识数据库系统</p></li><li><p>分布式数据库系统</p></li><li><p>并行数据库系统</p></li><li><p>面向对象数据库系统</p></li></ul><h4 id="数据库系统的基本特点"><a class="header-anchor" href="#数据库系统的基本特点"></a>数据库系统的基本特点</h4><h5 id="数据的集成性"><a class="header-anchor" href="#数据的集成性"></a>数据的集成性</h5><ul><li><p>在数据库系统中采用统一的数据结构方式</p></li><li><p>在数据库系统中按照多个应用程序的需要组织全局的统一的数据结构，数据模式可建立全局的数据结构，也可建立数据间的语义联系从而构成一个内存紧密联系的数据整体</p></li><li><p>数据模式是多个应用程序共同的、全局的数据结构，而每个应用的数据则是全局结构中的一部分</p></li></ul><h5 id="数据的高共享性与低冗余性"><a class="header-anchor" href="#数据的高共享性与低冗余性"></a>数据的高共享性与低冗余性</h5><p>数据的一致性是指系统中同一数据的不同出现应保持相同的值，而数据的不一致性是指同一数据在系统不同拷贝处有不同的值。减少数据的冗余性可以避免数据的不一致性。</p><h5 id="⭐数据的独立性"><a class="header-anchor" href="#⭐数据的独立性"></a>⭐数据的独立性</h5><p>数据的独立性是指数据与程序间的互不依赖性。即数据的逻辑结构、存储结构与存取方式的改变不会影响应用程序。</p><ol><li>物理独立性<br>即数据的物理结构（包括存储结构、存取方式）的改变，不会影响数据库的逻辑结构，即不会引起应用程序的变化。</li><li>逻辑的独立性</li></ol><h5 id="数据统一管理与控制"><a class="header-anchor" href="#数据统一管理与控制"></a>数据统一管理与控制</h5><ul><li><p>数据库总体逻辑结构的改变，不需要相应修改应用程序。</p></li><li><p>数据完整性检查：检查数据库中数据的正确性以保证数据的正确</p></li><li><p>数据的安全性保护：检查数据库访问者以防非法访问</p></li><li><p>并发控制：控制多个应用程序的并发访问所发生的相互干扰以保证其正确性</p></li></ul><h4 id="数据库系统的内部结构体系"><a class="header-anchor" href="#数据库系统的内部结构体系"></a>数据库系统的内部结构体系</h4><p>数据库系统的内部具有三级模式与二级映射。</p><h5 id="数据库系统的三级模式"><a class="header-anchor" href="#数据库系统的三级模式"></a>数据库系统的三级模式</h5><p>数据模式是数据库系统中数据结构的一种表示形式，它具有不同的层次与结构方式。</p><h6 id="概念模式"><a class="header-anchor" href="#概念模式"></a>概念模式</h6><p>概念模式是数据库系统中全局数据逻辑结构的描述，是全体用户公共数据视图。概念模式主要描述数据的概念记录类型以及它们之间的关系，还包括一些数据间的语义约束。</p><h6 id="外模式"><a class="header-anchor" href="#外模式"></a>外模式</h6><p>外模式又称子模式或用户模式，是用户的数据视图，即用户见到的数据模式。</p><p>概念模式给出系统全局的数据描述而外模式则给出每个用户的局部数据描述。</p><h6 id="内模式"><a class="header-anchor" href="#内模式"></a>内模式</h6><p>内模式又称物理模式，它给出数据库物理存储结构与物理存储方法，如数据存储的文件结构、索引、集簇及 hash 等存取方式与存取路径，内模式的物理性主要体现在操作系统及文件级上。</p><p>内模式对一般的用户是透明的，但它的设计直接影响到数据库系统的性能。</p><p>模式的三个级别层次反映了模式的三个不同环境以及它们的不同要求，其中内模式处于最底层，它反映数据在计算机物理结构中的实际存储形式，概念模式牌中层，它反映了设计者的数据全局逻辑要求，而外模式处于最外层，通过两种映射由物理数据库映射而成它反映用户对数据的要求。</p><h5 id="⭐⭐数据库系统的二级映射"><a class="header-anchor" href="#⭐⭐数据库系统的二级映射"></a>⭐⭐数据库系统的二级映射</h5><p>数据库系统的三级模式是对数据的三个级别抽象，它把数据的具体物理实现留给物理模式，使得全局设计者不必关心数据库的具体实现与物理背景；通过两级映射建立了模式间的 联系与转换，使得概念模式与外模式虽然并不物理存在，但也能通过映射获得实体。同时，<strong>两级映射也保证了数据库系统中数据的独立性</strong>。</p><p>两级模式的映射：</p><ul><li><p>概念模式到内模式的映射：该映射给出概念模式中数据的全局逻辑结构到数据的物理存储结构间的对应关系</p></li><li><p>外模式到概念模式的映射：该映射给出了外模式与概念模式之间的对应关系</p></li></ul><h3 id="⭐数据模型"><a class="header-anchor" href="#⭐数据模型"></a>⭐数据模型</h3><h4 id="数据模型的基本概念"><a class="header-anchor" href="#数据模型的基本概念"></a>数据模型的基本概念</h4><p>数据是现实世界符号的抽象，而数据模型是数据特征的抽象，它从抽象层次上描述了系统的静态特征、动态行为和约束条件，为数据库系统的信息表示与操作提供了一个抽象的框架。</p><p>数据模型描述的三个部分：数据结构、数据操作与数据约束。</p><ol><li>数据结构<br>描述数据的类型、内容、性质及数据间的联系等。</li><li>数据操作<br>主要描述在相应的数据结构上的操作类型与操作方式。</li><li>数据约束<br>主要描述数据结构内数据间的语法、语义联系，它们之间的制约与依存关系，以及数据动态变化的规则，以保证数据的正确、有效与相容。</li></ol><p>逻辑数据模型又称数据模型，较为成熟的有：层次模型、网状模型和关系模型。</p><p>物理数据模型又称物理模型，是面向计算机物理表示的模型。</p><h4 id="⭐E-R-模型-数据管理模型"><a class="header-anchor" href="#⭐E-R-模型-数据管理模型"></a>⭐E-R 模型(数据管理模型)</h4><h5 id="E-R-模型的基本概念"><a class="header-anchor" href="#E-R-模型的基本概念"></a>E-R 模型的基本概念</h5><p>E-R 模型（ Entity—Relationship model ），即实体联系模型。</p><h6 id="实体"><a class="header-anchor" href="#实体"></a>实体</h6><p>在现实生活中客观存在且又能相互区别的事物，称为实体。</p><p>具有共性的实体可组成一个集合称为实体集。</p><h6 id="属性"><a class="header-anchor" href="#属性"></a>属性</h6><p>属性是用来描述实体的特征。一个实体有许多个属性。</p><p>每个属性都可以有值，一个属性的取值范围称为该属性的值域或值集。</p><h6 id="联系"><a class="header-anchor" href="#联系"></a>联系</h6><p>反映事物之间的关联称为联系。</p><p>实体集之间的联系有多种，就实体集个数而言，有：</p><ul><li><p>两个实体集间的联系</p></li><li><p>多个实体集之间的联系</p></li><li><p>一个实体集内部的联系</p></li></ul><p>两个实体集间的联系即实体集间的函数关系，有如下几种关系：</p><ul><li><p><strong>一对一的联系</strong></p></li><li><p><strong>一对多的联系</strong></p></li><li><p><strong>多对多的联系</strong></p></li></ul><h5 id="E-R-模型三个基本概念之间的联系关系"><a class="header-anchor" href="#E-R-模型三个基本概念之间的联系关系"></a>E-R 模型三个基本概念之间的联系关系</h5><h6 id="实体集与属性之间的联接关系"><a class="header-anchor" href="#实体集与属性之间的联接关系"></a>实体集与属性之间的联接关系</h6><p>实体是概念世界中的基本单位，属性附属于实体，它本身并不构成独立性单位。</p><p>一个实体可以有若干个属性，实体与它所有属性构成了实体的一个完整描述。实体与属性间有一定的联系。</p><p>实体有型与值的区分，一个实体的所有属性的集合，称为实体型，而实体中属性值的集合，即构成该实体的值。</p><h6 id="实体与联系"><a class="header-anchor" href="#实体与联系"></a>实体与联系</h6><p>实体集之间通过联系建立联接关系。</p><h5 id="E-R-模型的图示法"><a class="header-anchor" href="#E-R-模型的图示法"></a>E-R 模型的图示法</h5><ul><li><p>用矩形表示实体集，在矩形内部标出实体集的名称</p></li><li><p>用椭圆形表示属性，在椭圆上标出属性的名称</p></li><li><p>用菱形表示联系，在菱形上标出联系名</p></li><li><p>属性依附于实体，它们之间用无向线段联接</p></li><li><p>属性也依附于联系，它们之间用无向线段联接</p></li><li><p>实体集与联系之间的联接关系，通过无向线段表示</p></li></ul><h4 id="层次模型"><a class="header-anchor" href="#层次模型"></a>层次模型</h4><p>若用图来表示，层次模型是一棵倒立的树。在数据库中，满足以下两个条件的数据模型称为层次模型：</p><p>有且仅有一个结点无父结点，这个结点称为根结点</p><p>其他结点有且仅有一个父结点</p><p>在层次模型中，结点层次从根开始定义，根为第一层，根的子结点为第二层，根为其子结点的父结点，同一父结点的子结点称为兄弟结点，没有子结点的结点称为叶结点。</p><p>层次模型表示的是一对多的关系，即一个父节点可以对应多个子节点。这种模型的优点是简单、直观、处理方便、算法规范；缺点是不能表达含有多对多关系的复杂结构。</p><p>R1 是根节点， R2 、 R3 是 R1 的子结点，它们互为兄弟结点； R4 、 R5 为 R2 的子结节点，它们也互为兄弟节点； R3 、 R4 、 R5 是叶子结点。</p><p>其中，每一个节点都代表一个实体型，各实体型由上而下是 1:n 的联系。</p><p>支持层次模型的 DBMS 称为层次数据库管理系统，在这种数据库系统中建立的数据库是层次数据库。</p><p>层次数据模型支持的操作主要有：查询、插入、删除和更新。</p><h4 id="网状模型"><a class="header-anchor" href="#网状模型"></a>网状模型</h4><p>若用图来表示，网状模型是一个网络。在数据库中，满足以下两个条件的数据模型称为网状模型。</p><p>允许一个以上的结点无父结点</p><p>一个结点可以有一个以上的父结点</p><p>允许两个结点间有两种以上的联系，即允许结点间有复合链，用网络表示某种联系</p><p>由于在网状模型中子结点与父结点的联系不是唯一的，所以要为每个联系命名，并指出与该联系有关的父结点和子结点。</p><p>网状模型的优点是可以表示复杂的数据结构，存取数据的效率比较高；缺点是结构复杂，每个问题都有其相对的特殊性，实现的算法难以规范化。</p><p>在抽象网状模型中， R1 与 R4 之间的联系被命名为 L1 ， R1 与 R3 之间的联系被命名为 L2 ， R2 与 R3 之间的联系被命名为 L3 ， R3 与 R5 之间的联系被命名为 L4 ， R4 与 R5 之间的联系被命名为 L5 。 R1 为 R3 和 R4 的父结点， R2 也是 R3 的父结点。 R1 和 R2 没有父结点。</p><p>网状模型是一个不加任何条件限制的无向图。它没有层次模型那样需要满足严格的条件，相对比较灵活。</p><p>通常的操作方式是将网状模型分解成若干个二级树，即只有两个层次的树。</p><p>在网状模型标准中，基本结构简单二级树叫做系，系的基本数据单位是记录，它相当于 E-R 模型中的实体集；记录又可由若干数据项组成，它相当于 E-R 模型中的属性。</p><h4 id="关系模型"><a class="header-anchor" href="#关系模型"></a>关系模型</h4><h5 id="关系的数据结构"><a class="header-anchor" href="#关系的数据结构"></a>关系的数据结构</h5><p>关系模型是利用二维表来表示，简称表 。</p><p>表头即属性的集合，在表中每一行存放数据，称为元组。</p><p>二维表要求满足的条件：</p><ul><li><p>二维表中元组的个数有限</p></li><li><p>元组在二维表中的唯一性，在同一个表中不存在完全相同的两个元组</p></li><li><p>二维表中元组的顺序无关，可以任意调换</p></li><li><p>元组中的各分量不能再分解</p></li><li><p>二维表中各属性名唯一</p></li><li><p>二维表中各属性的顺序无关</p></li><li><p>二维表属性的分量具有与该属性相同的值域</p></li></ul><p>键：能够唯一确定元组的属性或属性的组合。例如，在学生基本情况表中，可以用学号来唯一标识某个学生，即学号可以作为该表的键。键具有标识元组、建立元组间联系等重要作用。</p><p>在二维表中凡是能够唯一标识元组的最小属性集称为该表的键或码。二维表中可能有若干个键，称为候选码或候选健。从二维表的所有候选键中选取一个作为用户使用的键称为主键或主码。</p><p>外键：如果表中的一个字段不是本表的键或候选键，而是另外一个表的键或候选键，则称该字段为外键或外码。</p><p>表中一定有键。</p><p>在关系中一般支持空值，空值表示未知的值或不可能出现的值，一般用 NULL 表示。关系的主键中不允许出现空值，因为如主键为空值则失去了其元组标识的作用。</p><p>关系模式支持子模式，关系子模式是关系数据库模式中用户所见到的那部分数据模式描述。</p><h5 id="关系操作"><a class="header-anchor" href="#关系操作"></a>关系操作</h5><p>关系模型的数据操纵是建立在关系上的数据操纵，一般有查询、增加、删除和修改。</p><h6 id="数据查询"><a class="header-anchor" href="#数据查询"></a>数据查询</h6><p>在一个关系中查询数据，操作方式是先定位，然后再操作。</p><p>在多个关系中查询数据，先将多个关系合并为一个关系，再在合并后的新关系中进行定位，然后再操作。</p><h6 id="数据删除"><a class="header-anchor" href="#数据删除"></a>数据删除</h6><p>数据删除操作是在一个关系中删除元组的操作。操作方式也是先定位，然后再删除操作。</p><h6 id="数据插入"><a class="header-anchor" href="#数据插入"></a>数据插入</h6><p>数据插入也是仅对一个关系的操作。即在指定的关系中插入一个或多个元组。</p><h6 id="数据修改"><a class="header-anchor" href="#数据修改"></a>数据修改</h6><p>数据修改是在一个关系中修改指定的元组与属性。数据修改不是一个基本的操作，可分解为删除要修改的元组，再插入修改后的元组两个基本操作。</p><p>关系的基本操作：</p><ul><li><p>关系的属性指定</p></li><li><p>关系的元组选择</p></li><li><p>两个关系合并</p></li><li><p>一个或多个关系的查询</p></li><li><p>关系中元组的插入</p></li><li><p>关系中元组的删除</p></li></ul><h5 id="关系中的数据约束"><a class="header-anchor" href="#关系中的数据约束"></a>关系中的数据约束</h5><p>数据约束：实体完整性约束、参照完整性约束和用户定义的完整性约束。</p><ol><li><p>实体完整性约束<br>要求关系的主键中属性值不能为空值，主键的惟一决定元组的惟一性。</p></li><li><p>参照完整性约束<br>关系之间相关联的基本约束，不允许关系引用不存在的元组。</p></li><li><p>用户定义的完整性约束<br>用户根据具体的数据环境与应用环境具体设置约束。关系数据库系统提供完整性约束语言，用户利用该语言写出的约束条件，运行时由系统自动检查。</p></li></ol><h3 id="⭐关系代数"><a class="header-anchor" href="#⭐关系代数"></a>⭐关系代数</h3><h4 id="关系模型的基本操作"><a class="header-anchor" href="#关系模型的基本操作"></a>关系模型的基本操作</h4><p>关系是由若干个不同的元组组成的，因此关系可看作元组的集合。 N 元关系是一个 n 元有序组的集合。</p><p>设有一个 n 元关系 R ，它有 n 个域，分别是 D 1 、 D 2 、……、 D n ，此时，它们的笛卡尔集是：</p><p>集合可看作是域的笛卡尔积的子集，</p><p>关系模型的四种操作是：</p><ul><li><p>插入</p></li><li><p>删除</p></li><li><p>修改</p></li><li><p>查询</p></li></ul><p>可将它们分解为六种基本操作：</p><ul><li><p>关系的属性指定</p></li><li><p>关系的元组选择</p></li><li><p>两个关系的合并运算</p></li><li><p>关系的查询</p></li><li><p>关系元组的插入</p></li><li><p>关系元组的删除</p></li></ul><h4 id="关系模型的基本运算"><a class="header-anchor" href="#关系模型的基本运算"></a>关系模型的基本运算</h4><h5 id="插入"><a class="header-anchor" href="#插入"></a>插入</h5><p>插入操作可看作是集合的并运算。即在原有的关系 R 中并入要插入的元组 R’ ，是这两个元组的并运算:R∪R‘</p><h5 id="删除"><a class="header-anchor" href="#删除"></a>删除</h5><p>在关系 R 中删除元组 R’ ，可看作是两个关系的差运算： R-R’</p><h5 id="修改"><a class="header-anchor" href="#修改"></a>修改</h5><p>修改关系 R 中的元组的内容的操作：先将要修改的元组 R’ 从关系 R 中删除，再将修改后的元组 R ” 插入到关系 R 中，即操作为：（ R-R’）∪R’’</p><h5 id="查询"><a class="header-anchor" href="#查询"></a>查询</h5><p>查询运算无法通过传统的集合运算来表示，需要专门的关系运算来实现。</p><h6 id="投影运算"><a class="header-anchor" href="#投影运算"></a>投影运算</h6><p>投影运算，是从关系中指定若干个属性组合成一个新的关系的操作。投影操作后得到一个新的关系，其关系模式中包含的属性通常比原来的关系少，或者，与原来的关系具有不同的属性顺序。</p><p>投影是从垂直的角度进行运算，即从列的角度进行运算，投影运算基于一个关系，是一个一元运算。</p><h6 id="选择"><a class="header-anchor" href="#选择"></a>选择</h6><p>选择，是从关系中查找满足条件的元组。选择的条件是通过逻辑表达式进行描述，逻辑表达式值为真的元组被选出。</p><p>选择是从行的角度进行的运算，即从水平方向进行元组的抽取。选择基于一个关系，得到的结果可以形成一个新的关系，它的关系模式与原关系相同，但是原关系的一个子集。例如，从学生表中查找女同学的信息。</p><h6 id="笛卡尔积运算"><a class="header-anchor" href="#笛卡尔积运算"></a>笛卡尔积运算</h6><p>两个关系的合并操作可以用笛卡尔积表示。设有 n 元关系 R 及 m 元关系 S ，它们分别有 p 、 q 个元组，则关系 R 和关系 S 的笛卡尔积为 R × S ，新关系是一个 n+m 元关系，元组个数是 p × q ，由 R 和 S 的有序组合而成。</p><h4 id="关系代数中的扩充运算"><a class="header-anchor" href="#关系代数中的扩充运算"></a>关系代数中的扩充运算</h4><h5 id="交运算"><a class="header-anchor" href="#交运算"></a>交运算</h5><p>关系 R 与关系 S 经交运算后所得到的关系是既在 R 中又在 S 中的元组组成，记为R∩S</p><h5 id="除运算"><a class="header-anchor" href="#除运算"></a>除运算</h5><p>如果将笛卡尔积运算看作乘运算的话，除运算即是它的逆运算。当关系 T=R × S 时，则可将运算写成：</p><p>T ÷ R ＝ S 或 T ／ R ＝ S</p><p>S 称为 T 除以 R 的商。 T 能被除的充分与必要条件是： T 中的域包含 R 中的所有属性， T 中有一些域不出现在 R 中。</p><p>在除运算中 S 的域由 T 中那些不出现在 R 中的域所组成，对于 S 中任一有序组，由它与关系 R 中每个有序组所构成的有序组均出现在关系 T 中。</p><h5 id="连接与自然连接运算"><a class="header-anchor" href="#连接与自然连接运算"></a>连接与自然连接运算</h5><p>联接是关系的横向运算。联接运算将两个关系横向地拼接成一个更宽的关系，生成的新关系中有满足联接条件的所有元组。</p><p>联接运算通过联接条件来控制，联接条件中将出现两个关系中的公共属性，或者具有相同的域、可比的属性。</p><p>连接运算基于两个关系。如下图所示为联接运算的操作。</p><p>在联接运算中，按字段值相等的为条件进行的联接运算，即为等值联接。上例即为等值联接的运算。</p><p>自然联接，是去掉重复属性的等值联接。自然联接是最常用的联接方式。如果上例进行的是自然联接，则联接后的关系如下图所示。</p><h3 id="数据库设计与管理"><a class="header-anchor" href="#数据库设计与管理"></a>数据库设计与管理</h3><h4 id="数据库设计概述"><a class="header-anchor" href="#数据库设计概述"></a>数据库设计概述</h4><p>数据库设计的基本任务是根据用户对象的信息需求、处理需求和数据库的支持环境（包括硬件、操作系统与 DBMS ）设计出数据模式。</p><p>数据库设计的两种方法：</p><ul><li><p>面向数据的方法：以信息需求为主，兼顾处理需求。</p></li><li><p>面向过程的方法：以处理需求为主，兼顾信息需求。</p></li></ul><p>目前，面向数据的设计方法是数据库设计的主流方法。</p><p>数据库设计一般采用生命周期法，分为如下几个阶段：</p><ul><li><p>需求分析阶段</p></li><li><p>概念设计阶段</p></li><li><p>逻辑设计阶段</p></li><li><p>物理设计阶段</p></li><li><p>编码阶段</p></li><li><p>测试阶段</p></li><li><p>运行阶段</p></li><li><p>进一步修改阶段</p></li></ul><p>前四个阶段是数据库设计的主要阶段，重点以数据结构与模型的设计为主线。</p><h4 id="⭐数据库设计的需求分析"><a class="header-anchor" href="#⭐数据库设计的需求分析"></a>⭐数据库设计的需求分析</h4><p>第一阶段：需求收集和分析，收集基本数据和数据流图。</p><p>主要的任务是：通过详细调查现实世界要处理的对象（组织、部门、企业等），充分了解原系统的工作概况，明确用户的各种需求，在此基础上确定新系统的功能。</p><p>对数据库的要求：</p><ul><li><p>信息要求</p></li><li><p>处理要求</p></li><li><p>安全性和完整性的要求</p></li></ul><p>⭐数据字典是各类数据的集合，它包括五个部分：</p><ul><li><p>数据项，即数据的最小单位</p></li><li><p>数据结构，是若干数据项有意义的集合</p></li><li><p>数据流，可以是数据项，也可以是数据结构，用来表示某一处理过程的输入或输出</p></li><li><p>数据存储，处理过程中存取的数据，通常是手工凭证、手工文档或计算机文件</p></li><li><p>处理过程</p></li></ul><h4 id="数据库概念设计"><a class="header-anchor" href="#数据库概念设计"></a>数据库概念设计</h4><h5 id="概念设计概述"><a class="header-anchor" href="#概念设计概述"></a>概念设计概述</h5><ol><li><p>集中式模式设计法<br>根据需求由一个统一的机构或人员设计一个综合的全局模式。适合于小型或并不复杂的单位或部门。</p></li><li><p>视图集成设计法<br>将系统分解成若干个部分，对每个部分进行局部模式设计，建立各个部分的视图，再以各视图为基础进行集成。比较适合于大型与复杂的单位，是现在使用较多的方法。</p></li></ol><h5 id="数据库概念设计的过程"><a class="header-anchor" href="#数据库概念设计的过程"></a>数据库概念设计的过程</h5><h5 id="选择局部应用"><a class="header-anchor" href="#选择局部应用"></a>选择局部应用</h5><p>根据系统情况，在多层的数据流图中选择一个适当层次的数据流图，将这组图中每一部分对应一个局部应用，以该层数据流图为出发点，设计各自的 E-R 图。</p><h5 id="视图设计"><a class="header-anchor" href="#视图设计"></a>视图设计</h5><p>视图设计的三种次序：</p><ul><li><p>自顶向下：先从抽象级别高且普遍性强的对象开始逐步细化、具体化和特殊化。</p></li><li><p>由底向上：先从具体的对象开始，逐步抽象，普遍化和一般化，最后形成一个完整的视图设计</p></li><li><p>由内向外：先从最基本与最明显的对象开始，逐步扩充至非基本、不明显的对象。</p></li></ul><p>逻辑设计</p><p>学院（ 学院编号 ，学院名，学院地址，院长编号）</p><p>院长（ 院长编号 ，院长姓名，联系电话，办公地址）</p><p>系（ 系编号 ，系名，联系电话，系地址，学院编号，系主任职工号）</p><p>教师（ 职工号 ，姓名，性别，学历，职称，工资，联系电话，系编号）</p><p>班级（ 班级编号 ，班级名称，学生人数，系名）</p><p>学生（ 学号 ，身份证号，姓名，性别，出生日期，民族，籍贯，班级名）</p><p>课程（ 课程编号 ，课程名称，学分）</p><p>开课（ 系编号，课程号 ）</p><p>授课（ 职工号，课程号 ）</p><p>选课（ 学号，课程号 ，成绩）</p><h5 id="视图集成"><a class="header-anchor" href="#视图集成"></a>视图集成</h5><p>视图集成是将所有局部视图统一与合并成一个完整的数据模式。</p><p>视图集成的重点是解决局部设计中的冲突，常见的冲突主要有如下几种：</p><ul><li><p>命名冲突：有同名异义或同义异名</p></li><li><p>概念冲突：同一概念在一处为实体而在另一处为属性或联系</p></li><li><p>域冲突：相同的属性在不同视图中有不同的域</p></li><li><p>约束冲突：不同的视图可能有不同的约束</p></li></ul><p>视图经过合并生成 E-R 图时，其中还可能存在冗余的数据和冗余的实体间联系。冗余数据和冗余联系容易破坏数据库的完整性，给数据库维护带来困难。</p><p>对于视图集成后所形成的整体的数据库概念结构必须进行验证，满足下列要求：</p><ul><li><p>整体概念结构内部必须具有一致性，即不能存在互相矛盾的表达</p></li><li><p>整体概念结构能准确地反映原来的每个视图结构，包括属性、实体及实体间的联系</p></li><li><p>整体概念结构能满足需求分析阶段所确定的所有要求</p></li><li><p>整体概念结构还需要提交给用户，征求用户和有关人员的意见，进行评审、修改和优化，最后定稿</p></li></ul><h4 id="数据库的逻辑设计"><a class="header-anchor" href="#数据库的逻辑设计"></a>数据库的逻辑设计</h4><h5 id="从-E-R-模型向关系模式转换"><a class="header-anchor" href="#从-E-R-模型向关系模式转换"></a>从 E-R 模型向关系模式转换</h5><p>E-R 模型向关系模式的转换包括：</p><ul><li><p>E-R 模型中的属性转换为关系模式中的属性</p></li><li><p>E-R 模型中的实体转换为关系模式中的元组</p></li><li><p>E-R 模型中的实体集转换为关系模式中的关系</p></li><li><p>E-R 模型中的联系转换为关系模式中的关系</p></li></ul><p>转换中存在的一些问题：</p><ul><li><p>命名与属性域的处理。名称不要重复，同时，要用关系数据库中允许的数据类型来描述类型</p></li><li><p>非原子属性处理。在 E-R 模型中允许非原子属性存在，但在关系模式中不允许出现非原子属性，因此，要将非原子属性进行转换。</p></li><li><p>联系的转换。通常联系可转换为关系，但有的联系需要归并到相关联的实体中</p></li></ul><h5 id="逻辑模式规范化及调整、实现"><a class="header-anchor" href="#逻辑模式规范化及调整、实现"></a>逻辑模式规范化及调整、实现</h5><p>规范：对关系做规范化验证。</p><p>RDBMS：对逻辑模式进行调整以满足 RDBMS 的性能、存储空间等要求，包括如下内容：</p><ul><li><p>调整性能以减少连接运算</p></li><li><p>调整关系大小，使每个关系数量保持在合理水平，从而可以提高存取效率</p></li><li><p>尽量采取快照，提高查询速度</p></li></ul><h5 id="关系视图设计"><a class="header-anchor" href="#关系视图设计"></a>关系视图设计</h5><p>逻辑设计又称外模式设计。关系视图是关系模式基础上所设计的直接面向操作用户的视图。</p><p>关系视图的作用：</p><ul><li><p>提供数据逻辑独立性</p></li><li><p>能适应用户对数据的不同需求</p></li><li><p>有一定数据保密功能</p></li></ul><h4 id="数据库的物理设计"><a class="header-anchor" href="#数据库的物理设计"></a>数据库的物理设计</h4><p>物理设计的主要目标是对数据库内部物理结构作调整并选择合理的存取路径，以提高数据库访问速度及有效利用存储空间。</p><h4 id="数据库管理"><a class="header-anchor" href="#数据库管理"></a>数据库管理</h4><p>数据库管理包括：</p><h5 id="数据库的建立"><a class="header-anchor" href="#数据库的建立"></a>数据库的建立</h5><p>数据库建立包括：</p><ul><li><p>数据模式的建立。数据模式由 DBA 负责建立，定义数据库名、表及相应的属性，定义主关键字、索引、集簇、完整性约束、用户访问权限、申请空间资源，定义分区等。</p></li><li><p>数据加载。在数据模式定义后可加载数据， DBA 可以编制加载程序将外界的数据加载到数据模式内，完成数据库的建立。</p></li></ul><h5 id="数据库的调整"><a class="header-anchor" href="#数据库的调整"></a>数据库的调整</h5><p>在数据库库建立并运行一段时间后，对不适合的内容要进行调整，调整的内容包括：</p><ul><li><p>调整关系模式与视图使之更适应用户的需求</p></li><li><p>调整索引与集簇使数据库性能与效率更佳</p></li><li><p>调整分区、数据库缓冲区大小以及并发度使数据库物理性能更好</p></li></ul><h5 id="数据库的重组"><a class="header-anchor" href="#数据库的重组"></a>数据库的重组</h5><p>数据库运行一段时间后，由于数据的大量插入、删除和修改，使性能受到很大的影响，需要重新调整存贮空间，使数据的连续性更好，即通过数据库的重组来实现。</p><h5 id="数据库的故障校复"><a class="header-anchor" href="#数据库的故障校复"></a>数据库的故障校复</h5><p>保证数据不受非法盗用与破坏；保证数据的正确性。</p><h5 id="数据安全性控制与完整性控制"><a class="header-anchor" href="#数据安全性控制与完整性控制"></a>数据安全性控制与完整性控制</h5><p>一旦数据被破坏，要及时恢复。</p><h5 id="数据库监控"><a class="header-anchor" href="#数据库监控"></a>数据库监控</h5><p>DBA 需要随时观察数据库的动态变化，并在发生错误、故障或产生不适应情况时随时采取措施，并监控数据库的性能变化，必要时可对数据库进行调整。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机二级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>科学计算之NumPy</title>
      <link href="2019/07/22/%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97%E4%B9%8BNumPy/"/>
      <url>2019/07/22/%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97%E4%B9%8BNumPy/</url>
      
        <content type="html"><![CDATA[<p>NumPy库学习</p><hr><h2 id="数组"><a class="header-anchor" href="#数组"></a>数组</h2><p>NumPy的主要对象为同类型的多维数组<br>维度成为轴，轴的数目为rank</p><ol><li><p>一维数组</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure></li><li><p>二维数组</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]]</span><br></pre></td></tr></table></figure><blockquote><p>逻辑分割</p></blockquote></li></ol><p>NumPy的数组命名ndarray，简称array</p><blockquote><p>与标准Python库array.array不同，标准库内容少</p></blockquote><h3 id="数组属性"><a class="header-anchor" href="#数组属性"></a>数组属性</h3><ul><li><p><code>ndarray.ndim</code>  判断数组的轴的个数</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(x)  <span class="comment"># array([1, 2, 3], [4, 5, 6])</span></span><br><span class="line"><span class="built_in">print</span>(x.ndim)  <span class="comment"># 2</span></span><br></pre></td></tr></table></figure></li><li><p><code>ndarray.shape</code>  对n行m列的矩阵，shape返回(n, m)</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(x.shape)  <span class="comment"># (2, 3)</span></span><br></pre></td></tr></table></figure></li><li><p><code>ndarry.size</code> 数组元素的总数等于shape的乘积</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(x.size)  <span class="comment"># 6</span></span><br></pre></td></tr></table></figure></li><li><p><code>ndarry.dtype</code> 描述数组中元素类型的对象</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(x.dtype)  <span class="comment"># dtype(&#x27;int64&#x27;)</span></span><br><span class="line">y = np.array([<span class="number">1.</span>, <span class="number">2</span>, <span class="number">3</span>])  <span class="comment"># 向上转化浮点数优先级高</span></span><br><span class="line"><span class="built_in">print</span>(y)  <span class="comment"># array([1., 2., 3.])</span></span><br><span class="line"><span class="built_in">print</span>(y.dtype)  <span class="comment"># dtype(&#x27;float64&#x27;)</span></span><br></pre></td></tr></table></figure></li><li><p><code>ndarry.itemsize</code> 数组中每个元素的字节大小</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(x.itemsize)  <span class="comment"># 8</span></span><br></pre></td></tr></table></figure><blockquote><p>float64类型数组的itemsize为8(=64/8)<br>complex32类型数组的itemsize为4(=32/4)</p></blockquote></li><li><p><code>ndarray.strides</code> 步长幅度(有疑问，后续需要查资料)</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(x.strides)  <span class="comment"># (14, 4)</span></span><br><span class="line">y = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(y.strides)  <span class="comment"># (8, 4)</span></span><br><span class="line">z = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(z.strides)  <span class="comment"># (4,)</span></span><br></pre></td></tr></table></figure></li><li><p><code>ndarray.data</code> 指针(不用)</p></li><li><p><code>ndarray.flags</code> 存放数组自身相关属性</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(x.flags)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">F_CONTIGUOUS : False  #</span></span><br><span class="line"><span class="string">OWNDATA : True  # 是否属于自己</span></span><br><span class="line"><span class="string">WRITEABLE : True  # 是否可写</span></span><br><span class="line"><span class="string">ALIGNED : True  # 是否对齐</span></span><br><span class="line"><span class="string">WRITEBACKIFCOPY : False  </span></span><br><span class="line"><span class="string">UPDATEIFCOPY : False</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 修改属性</span></span><br><span class="line">x.flags.writable = <span class="literal">False</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="创建数组"><a class="header-anchor" href="#创建数组"></a>创建数组</h3><ol><li><p><code>numpy.array</code> 使用array函数从常规Python<strong>列表或元组</strong>中创建数组</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="built_in">print</span>(np.array(<span class="number">1</span>))  <span class="comment"># array(1)  0维占位用</span></span><br></pre></td></tr></table></figure></li><li><p><code>numpy.zeros()</code> 创建一个由0组成的数组<br><code>numpy.ones()</code>  创建一个由1组成的数组</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="built_in">print</span>(np.zeros((<span class="number">3</span>, <span class="number">4</span>)))  <span class="comment"># 3x4</span></span><br><span class="line"><span class="built_in">print</span>(np.ones(<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(np.zeros(<span class="number">3</span>, <span class="number">4</span>), dtype = <span class="built_in">bool</span>)  <span class="comment"># 指定类型</span></span><br></pre></td></tr></table></figure></li><li><p><code>numpy.empty()</code> 生成无用数据</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="built_in">print</span>(np.empty(<span class="number">2</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure></li><li><p><code>numpy.random.random()</code> 创建随机</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="built_in">print</span>(np.random.random((<span class="number">2</span>, <span class="number">3</span>)))</span><br></pre></td></tr></table></figure></li><li><p><code>numpy.arange()</code> 创建数字序列</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="built_in">print</span>(np.arange(<span class="number">0</span>, <span class="number">10</span>, <span class="number">2</span>))  <span class="comment"># 始，终，步长</span></span><br></pre></td></tr></table></figure></li><li><p><code>numpy.linspace()</code> 创建等步长的数字序列</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="built_in">print</span>(np.linspce(<span class="number">0</span>, <span class="number">2</span>, <span class="number">9</span>))  <span class="comment"># 始，终，个数</span></span><br></pre></td></tr></table></figure></li><li><p><code>numpy.fromfunction()</code> 从给定函数中创建数组</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*x+y</span><br><span class="line"><span class="built_in">print</span>(np.fromfunction(f,(<span class="number">3</span>, <span class="number">3</span>)))  </span><br></pre></td></tr></table></figure></li><li><p><code>numpy.eye()</code>和<code>numpy.identity()</code> 创建正方形矩阵，对角线是1，其余为零</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="built_in">print</span>(np.eye(<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(np.identity(<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(np.eye(<span class="number">4</span>), k = <span class="number">1</span>)   <span class="comment"># 向右偏移</span></span><br><span class="line"><span class="built_in">print</span>(np.eye(<span class="number">4</span>), k = -<span class="number">1</span>)  <span class="comment"># 向左偏移</span></span><br></pre></td></tr></table></figure></li><li><p><code>numpy.fromfile()</code>和<code>numpy.tofile()</code> 从文件中存取</p></li><li><p><code>numpy.load()</code>和<code>numpy.save()</code> NumPy专用二级制存储文件</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象编程</title>
      <link href="2019/06/30/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
      <url>2019/06/30/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>Python面向对象编程参考<a href="https://github.com/jackfrued/Python-100-Days">Python-100-Days</a></p><p><img src="https://pic.superbed.cn/item/5db304178b58bc7bf70c8b96.png" alt=""></p><hr><h3 id="property装饰器"><a class="header-anchor" href="#property装饰器"></a>@property装饰器</h3><p>之前我们讨论过Python中属性和方法访问权限的问题，虽然我们不建议将属性设置为私有的，但是如果直接将属性暴露给外界也是有问题的，比如我们没有办法检查赋给属性的值是否有效。我们之前的建议是将属性命名以单下划线开头，通过这种方式来暗示属性是受保护的，不建议外界直接访问，那么如果想访问属性可以通过属性的getter（访问器）和setter（修改器）方法进行对应的操作。如果要做到这点，就可以考虑使用@property包装器来包装getter和setter方法，使得对属性的访问既安全又方便，代码如下所示。</p><span id="more"></span><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age</span>):</span></span><br><span class="line">        self._name = name</span><br><span class="line">        self._age = age</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 访问器 - getter方法</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._name</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 访问器 - getter方法</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._age</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 修改器 - setter方法</span></span><br><span class="line"><span class="meta">    @age.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span>(<span class="params">self, age</span>):</span></span><br><span class="line">        self._age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">play</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self._age &lt;= <span class="number">16</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;%s正在玩飞行棋.&#x27;</span> % self._name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;%s正在玩斗地主.&#x27;</span> % self._name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    person = Person(<span class="string">&#x27;王大锤&#x27;</span>, <span class="number">12</span>)</span><br><span class="line">    person.play()</span><br><span class="line">    person.age = <span class="number">22</span></span><br><span class="line">    person.play()</span><br><span class="line">    <span class="comment"># person.name = &#x27;白元芳&#x27;  # AttributeError: can&#x27;t set attribute</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="slots-魔法"><a class="header-anchor" href="#slots-魔法"></a>__slots__魔法</h3><p>我们讲到这里，不知道大家是否已经意识到，Python是一门<a href="https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%AF%AD%E8%A8%80">动态语言</a>。通常，动态语言允许我们在程序运行时给对象绑定新的属性或方法，当然也可以对已经绑定的属性和方法进行解绑定。但是如果我们需要限定自定义类型的对象只能绑定某些属性，可以通过在类中定义__slots__变量来进行限定。需要注意的是__slots__的限定只对当前类的对象生效，对子类并不起任何作用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 限定Person对象只能绑定_name, _age和_gender属性</span></span><br><span class="line">    __slots__ = (<span class="string">&#x27;_name&#x27;</span>, <span class="string">&#x27;_age&#x27;</span>, <span class="string">&#x27;_gender&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age</span>):</span></span><br><span class="line">        self._name = name</span><br><span class="line">        self._age = age</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._age</span><br><span class="line"></span><br><span class="line"><span class="meta">    @age.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span>(<span class="params">self, age</span>):</span></span><br><span class="line">        self._age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">play</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self._age &lt;= <span class="number">16</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;%s正在玩飞行棋.&#x27;</span> % self._name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;%s正在玩斗地主.&#x27;</span> % self._name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    person = Person(<span class="string">&#x27;王大锤&#x27;</span>, <span class="number">22</span>)</span><br><span class="line">    person.play()</span><br><span class="line">    person._gender = <span class="string">&#x27;男&#x27;</span></span><br><span class="line">    <span class="comment"># AttributeError: &#x27;Person&#x27; object has no attribute &#x27;_is_gay&#x27;</span></span><br><span class="line">    <span class="comment"># person._is_gay = True</span></span><br></pre></td></tr></table></figure><h3 id="静态方法和类方法"><a class="header-anchor" href="#静态方法和类方法"></a>静态方法和类方法</h3><p>之前，我们在类中定义的方法都是对象方法，也就是说这些方法都是发送给对象的消息。实际上，我们写在类中的方法并不需要都是对象方法，例如我们定义一个“三角形”类，通过传入三条边长来构造三角形，并提供计算周长和面积的方法，但是传入的三条边长未必能构造出三角形对象，因此我们可以先写一个方法来验证三条边长是否可以构成三角形，这个方法很显然就不是对象方法，因为在调用这个方法时三角形对象尚未创建出来（因为都不知道三条边能不能构成三角形），所以这个方法是属于三角形类而并不属于三角形对象的。我们可以使用静态方法来解决这类问题，代码如下所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, a, b, c</span>):</span></span><br><span class="line">        self._a = a</span><br><span class="line">        self._b = b</span><br><span class="line">        self._c = c</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_valid</span>(<span class="params">a, b, c</span>):</span></span><br><span class="line">        <span class="keyword">return</span> a + b &gt; c <span class="keyword">and</span> b + c &gt; a <span class="keyword">and</span> a + c &gt; b</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">perimeter</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._a + self._b + self._c</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">area</span>(<span class="params">self</span>):</span></span><br><span class="line">        half = self.perimeter() / <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> sqrt(half * (half - self._a) *</span><br><span class="line">                    (half - self._b) * (half - self._c))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    a, b, c = <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span></span><br><span class="line">    <span class="comment"># 静态方法和类方法都是通过给类发消息来调用的</span></span><br><span class="line">    <span class="keyword">if</span> Triangle.is_valid(a, b, c):</span><br><span class="line">        t = Triangle(a, b, c)</span><br><span class="line">        <span class="built_in">print</span>(t.perimeter())</span><br><span class="line">        <span class="comment"># 也可以通过给类发消息来调用对象方法但是要传入接收消息的对象作为参数</span></span><br><span class="line">        <span class="comment"># print(Triangle.perimeter(t))</span></span><br><span class="line">        <span class="built_in">print</span>(t.area())</span><br><span class="line">        <span class="comment"># print(Triangle.area(t))</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;无法构成三角形.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>和静态方法比较类似，Python还可以在类中定义类方法，类方法的第一个参数约定名为cls，它代表的是当前类相关的信息的对象（类本身也是一个对象，有的地方也称之为类的元数据对象），通过这个参数我们可以获取和类相关的信息并且可以创建出类的对象，代码如下所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time, localtime, sleep</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;数字时钟&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, hour=<span class="number">0</span>, minute=<span class="number">0</span>, second=<span class="number">0</span></span>):</span></span><br><span class="line">        self._hour = hour</span><br><span class="line">        self._minute = minute</span><br><span class="line">        self._second = second</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">now</span>(<span class="params">cls</span>):</span></span><br><span class="line">        ctime = localtime(time())</span><br><span class="line">        <span class="keyword">return</span> cls(ctime.tm_hour, ctime.tm_min, ctime.tm_sec)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;走字&quot;&quot;&quot;</span></span><br><span class="line">        self._second += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self._second == <span class="number">60</span>:</span><br><span class="line">            self._second = <span class="number">0</span></span><br><span class="line">            self._minute += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self._minute == <span class="number">60</span>:</span><br><span class="line">                self._minute = <span class="number">0</span></span><br><span class="line">                self._hour += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> self._hour == <span class="number">24</span>:</span><br><span class="line">                    self._hour = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;显示时间&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;%02d:%02d:%02d&#x27;</span> % \</span><br><span class="line">               (self._hour, self._minute, self._second)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># 通过类方法创建对象并获取系统时间</span></span><br><span class="line">    clock = Clock.now()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(clock.show())</span><br><span class="line">        sleep(<span class="number">1</span>)</span><br><span class="line">        clock.run()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="类之间的关系"><a class="header-anchor" href="#类之间的关系"></a>类之间的关系</h3><p>简单的说，类和类之间的关系有三种：is-a、has-a和use-a关系。</p><ul><li>is-a关系也叫继承或泛化，比如学生和人的关系、手机和电子产品的关系都属于继承关系。</li><li>has-a关系通常称之为关联，比如部门和员工的关系，汽车和引擎的关系都属于关联关系；关联关系如果是整体和部分的关联，那么我们称之为聚合关系；如果整体进一步负责了部分的生命周期（整体和部分是不可分割的，同时同在也同时消亡），那么这种就是最强的关联关系，我们称之为合成关系。</li><li>use-a关系通常称之为依赖，比如司机有一个驾驶的行为（方法），其中（的参数）使用到了汽车，那么司机和汽车的关系就是依赖关系。</li></ul><p>利用类之间的这些关系，我们可以在已有类的基础上来完成某些操作，也可以在已有类的基础上创建新的类，这些都是实现代码复用的重要手段。复用现有的代码不仅可以减少开发的工作量，也有利于代码的管理和维护，这是我们在日常工作中都会使用到的技术手段。</p><h3 id="继承和多态"><a class="header-anchor" href="#继承和多态"></a>继承和多态</h3><p>刚才我们提到了，可以在已有类的基础上创建新类，这其中的一种做法就是让一个类从另一个类那里将属性和方法直接继承下来，从而减少重复代码的编写。提供继承信息的我们称之为父类，也叫超类或基类；得到继承信息的我们称之为子类，也叫派生类或衍生类。子类除了继承父类提供的属性和方法，还可以定义自己特有的属性和方法，所以子类比父类拥有的更多的能力，在实际开发中，我们经常会用子类对象去替换掉一个父类对象，这是面向对象编程中一个常见的行为，对应的原则称之为<a href="https://zh.wikipedia.org/wiki/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99">里氏替换原则</a>。下面我们先看一个继承的例子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;人&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age</span>):</span></span><br><span class="line">        self._name = name</span><br><span class="line">        self._age = age</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._age</span><br><span class="line"></span><br><span class="line"><span class="meta">    @age.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span>(<span class="params">self, age</span>):</span></span><br><span class="line">        self._age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">play</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s正在愉快的玩耍.&#x27;</span> % self._name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">watch_av</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self._age &gt;= <span class="number">18</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;%s正在观看爱情动作片.&#x27;</span> % self._name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;%s只能观看《熊出没》.&#x27;</span> % self._name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">Person</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;学生&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, grade</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(name, age)</span><br><span class="line">        self._grade = grade</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">grade</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._grade</span><br><span class="line"></span><br><span class="line"><span class="meta">    @grade.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">grade</span>(<span class="params">self, grade</span>):</span></span><br><span class="line">        self._grade = grade</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">study</span>(<span class="params">self, course</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s的%s正在学习%s.&#x27;</span> % (self._grade, self._name, course))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span>(<span class="params">Person</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;老师&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, title</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(name, age)</span><br><span class="line">        self._title = title</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">title</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._title</span><br><span class="line"></span><br><span class="line"><span class="meta">    @title.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">title</span>(<span class="params">self, title</span>):</span></span><br><span class="line">        self._title = title</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">teach</span>(<span class="params">self, course</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s%s正在讲%s.&#x27;</span> % (self._name, self._title, course))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    stu = Student(<span class="string">&#x27;王大锤&#x27;</span>, <span class="number">15</span>, <span class="string">&#x27;初三&#x27;</span>)</span><br><span class="line">    stu.study(<span class="string">&#x27;数学&#x27;</span>)</span><br><span class="line">    stu.watch_av()</span><br><span class="line">    t = Teacher(<span class="string">&#x27;骆昊&#x27;</span>, <span class="number">38</span>, <span class="string">&#x27;砖家&#x27;</span>)</span><br><span class="line">    t.teach(<span class="string">&#x27;Python程序设计&#x27;</span>)</span><br><span class="line">    t.watch_av()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>子类在继承了父类的方法后，可以对父类已有的方法给出新的实现版本，这个动作称之为方法重写（override）。通过方法重写我们可以让父类的同一个行为在子类中拥有不同的实现版本，当我们调用这个经过子类重写的方法时，不同的子类对象会表现出不同的行为，这个就是多态（poly-morphism）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pet</span>(<span class="params"><span class="built_in">object</span>, metaclass=ABCMeta</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;宠物&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, nickname</span>):</span></span><br><span class="line">        self._nickname = nickname</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_voice</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;发出声音&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params">Pet</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;狗&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_voice</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s: 汪汪汪...&#x27;</span> % self._nickname)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>(<span class="params">Pet</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;猫&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_voice</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s: 喵...喵...&#x27;</span> % self._nickname)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    pets = [Dog(<span class="string">&#x27;旺财&#x27;</span>), Cat(<span class="string">&#x27;凯蒂&#x27;</span>), Dog(<span class="string">&#x27;大黄&#x27;</span>)]</span><br><span class="line">    <span class="keyword">for</span> pet <span class="keyword">in</span> pets:</span><br><span class="line">        pet.make_voice()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们将<code>Pet</code>类处理成了一个抽象类，所谓抽象类就是不能够创建对象的类，这种类的存在就是专门为了让其他类去继承它。Python从语法层面并没有像Java或C#那样提供对抽象类的支持，但是我们可以通过<code>abc</code>模块的<code>ABCMeta</code>元类和<code>abstractmethod</code>包装器来达到抽象类的效果，如果一个类中存在抽象方法那么这个类就不能够实例化（创建对象）。上面的代码中，<code>Dog</code>和<code>Cat</code>两个子类分别对<code>Pet</code>类中的<code>make_voice</code>抽象方法进行了重写并给出了不同的实现版本，当我们在<code>main</code>函数中调用该方法时，这个方法就表现出了多态行为（同样的方法做了不同的事情）。</p><h3 id="综合案例"><a class="header-anchor" href="#综合案例"></a>综合案例</h3><h4 id="案例1：奥特曼打小怪兽"><a class="header-anchor" href="#案例1：奥特曼打小怪兽"></a>案例1：奥特曼打小怪兽</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint, randrange</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fighter</span>(<span class="params"><span class="built_in">object</span>, metaclass=ABCMeta</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;战斗者&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 通过__slots__魔法限定对象可以绑定的成员变量</span></span><br><span class="line">    __slots__ = (<span class="string">&#x27;_name&#x27;</span>, <span class="string">&#x27;_hp&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, hp</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化方法</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param name: 名字</span></span><br><span class="line"><span class="string">        :param hp: 生命值</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self._name = name</span><br><span class="line">        self._hp = hp</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hp</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._hp</span><br><span class="line"></span><br><span class="line"><span class="meta">    @hp.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hp</span>(<span class="params">self, hp</span>):</span></span><br><span class="line">        self._hp = hp <span class="keyword">if</span> hp &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">alive</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._hp &gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">attack</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;攻击</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param other: 被攻击的对象</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ultraman</span>(<span class="params">Fighter</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;奥特曼&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    __slots__ = (<span class="string">&#x27;_name&#x27;</span>, <span class="string">&#x27;_hp&#x27;</span>, <span class="string">&#x27;_mp&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, hp, mp</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化方法</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param name: 名字</span></span><br><span class="line"><span class="string">        :param hp: 生命值</span></span><br><span class="line"><span class="string">        :param mp: 魔法值</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(name, hp)</span><br><span class="line">        self._mp = mp</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">attack</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        other.hp -= randint(<span class="number">15</span>, <span class="number">25</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">huge_attack</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;究极必杀技(打掉对方至少50点或四分之三的血)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param other: 被攻击的对象</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :return: 使用成功返回True否则返回False</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self._mp &gt;= <span class="number">50</span>:</span><br><span class="line">            self._mp -= <span class="number">50</span></span><br><span class="line">            injury = other.hp * <span class="number">3</span> // <span class="number">4</span></span><br><span class="line">            injury = injury <span class="keyword">if</span> injury &gt;= <span class="number">50</span> <span class="keyword">else</span> <span class="number">50</span></span><br><span class="line">            other.hp -= injury</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.attack(other)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">magic_attack</span>(<span class="params">self, others</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;魔法攻击</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param others: 被攻击的群体</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :return: 使用魔法成功返回True否则返回False</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self._mp &gt;= <span class="number">20</span>:</span><br><span class="line">            self._mp -= <span class="number">20</span></span><br><span class="line">            <span class="keyword">for</span> temp <span class="keyword">in</span> others:</span><br><span class="line">                <span class="keyword">if</span> temp.alive:</span><br><span class="line">                    temp.hp -= randint(<span class="number">10</span>, <span class="number">15</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">resume</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;恢复魔法值&quot;&quot;&quot;</span></span><br><span class="line">        incr_point = randint(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">        self._mp += incr_point</span><br><span class="line">        <span class="keyword">return</span> incr_point</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;~~~%s奥特曼~~~\n&#x27;</span> % self._name + \</span><br><span class="line">            <span class="string">&#x27;生命值: %d\n&#x27;</span> % self._hp + \</span><br><span class="line">            <span class="string">&#x27;魔法值: %d\n&#x27;</span> % self._mp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monster</span>(<span class="params">Fighter</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;小怪兽&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    __slots__ = (<span class="string">&#x27;_name&#x27;</span>, <span class="string">&#x27;_hp&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">attack</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        other.hp -= randint(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;~~~%s小怪兽~~~\n&#x27;</span> % self._name + \</span><br><span class="line">            <span class="string">&#x27;生命值: %d\n&#x27;</span> % self._hp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_any_alive</span>(<span class="params">monsters</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;判断有没有小怪兽是活着的&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> monster <span class="keyword">in</span> monsters:</span><br><span class="line">        <span class="keyword">if</span> monster.alive &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_alive_one</span>(<span class="params">monsters</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;选中一只活着的小怪兽&quot;&quot;&quot;</span></span><br><span class="line">    monsters_len = <span class="built_in">len</span>(monsters)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        index = randrange(monsters_len)</span><br><span class="line">        monster = monsters[index]</span><br><span class="line">        <span class="keyword">if</span> monster.alive &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> monster</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">display_info</span>(<span class="params">ultraman, monsters</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;显示奥特曼和小怪兽的信息&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(ultraman)</span><br><span class="line">    <span class="keyword">for</span> monster <span class="keyword">in</span> monsters:</span><br><span class="line">        <span class="built_in">print</span>(monster, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    u = Ultraman(<span class="string">&#x27;骆昊&#x27;</span>, <span class="number">1000</span>, <span class="number">120</span>)</span><br><span class="line">    m1 = Monster(<span class="string">&#x27;狄仁杰&#x27;</span>, <span class="number">250</span>)</span><br><span class="line">    m2 = Monster(<span class="string">&#x27;白元芳&#x27;</span>, <span class="number">500</span>)</span><br><span class="line">    m3 = Monster(<span class="string">&#x27;王大锤&#x27;</span>, <span class="number">750</span>)</span><br><span class="line">    ms = [m1, m2, m3]</span><br><span class="line">    fight_round = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> u.alive <span class="keyword">and</span> is_any_alive(ms):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;========第%02d回合========&#x27;</span> % fight_round)</span><br><span class="line">        m = select_alive_one(ms)  <span class="comment"># 选中一只小怪兽</span></span><br><span class="line">        skill = randint(<span class="number">1</span>, <span class="number">10</span>)   <span class="comment"># 通过随机数选择使用哪种技能</span></span><br><span class="line">        <span class="keyword">if</span> skill &lt;= <span class="number">6</span>:  <span class="comment"># 60%的概率使用普通攻击</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;%s使用普通攻击打了%s.&#x27;</span> % (u.name, m.name))</span><br><span class="line">            u.attack(m)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;%s的魔法值恢复了%d点.&#x27;</span> % (u.name, u.resume()))</span><br><span class="line">        <span class="keyword">elif</span> skill &lt;= <span class="number">9</span>:  <span class="comment"># 30%的概率使用魔法攻击(可能因魔法值不足而失败)</span></span><br><span class="line">            <span class="keyword">if</span> u.magic_attack(ms):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;%s使用了魔法攻击.&#x27;</span> % u.name)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;%s使用魔法失败.&#x27;</span> % u.name)</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 10%的概率使用究极必杀技(如果魔法值不足则使用普通攻击)</span></span><br><span class="line">            <span class="keyword">if</span> u.huge_attack(m):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;%s使用究极必杀技虐了%s.&#x27;</span> % (u.name, m.name))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;%s使用普通攻击打了%s.&#x27;</span> % (u.name, m.name))</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;%s的魔法值恢复了%d点.&#x27;</span> % (u.name, u.resume()))</span><br><span class="line">        <span class="keyword">if</span> m.alive &gt; <span class="number">0</span>:  <span class="comment"># 如果选中的小怪兽没有死就回击奥特曼</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;%s回击了%s.&#x27;</span> % (m.name, u.name))</span><br><span class="line">            m.attack(u)</span><br><span class="line">        display_info(u, ms)  <span class="comment"># 每个回合结束后显示奥特曼和小怪兽的信息</span></span><br><span class="line">        fight_round += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\n========战斗结束!========\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> u.alive &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s奥特曼胜利!&#x27;</span> % u.name)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;小怪兽胜利!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h4 id="案例2：扑克游戏"><a class="header-anchor" href="#案例2：扑克游戏"></a>案例2：扑克游戏</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Card</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;一张牌&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, suite, face</span>):</span></span><br><span class="line">        self._suite = suite</span><br><span class="line">        self._face = face</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">face</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._face</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">suite</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._suite</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self._face == <span class="number">1</span>:</span><br><span class="line">            face_str = <span class="string">&#x27;A&#x27;</span></span><br><span class="line">        <span class="keyword">elif</span> self._face == <span class="number">11</span>:</span><br><span class="line">            face_str = <span class="string">&#x27;J&#x27;</span></span><br><span class="line">        <span class="keyword">elif</span> self._face == <span class="number">12</span>:</span><br><span class="line">            face_str = <span class="string">&#x27;Q&#x27;</span></span><br><span class="line">        <span class="keyword">elif</span> self._face == <span class="number">13</span>:</span><br><span class="line">            face_str = <span class="string">&#x27;K&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            face_str = <span class="built_in">str</span>(self._face)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;%s%s&#x27;</span> % (self._suite, face_str)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__str__()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Poker</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;一副牌&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._cards = [Card(suite, face)</span><br><span class="line">                       <span class="keyword">for</span> suite <span class="keyword">in</span> <span class="string">&#x27;♠♥♣♦&#x27;</span></span><br><span class="line">                       <span class="keyword">for</span> face <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">14</span>)]</span><br><span class="line">        self._current = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cards</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._cards</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shuffle</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;洗牌(随机乱序)&quot;&quot;&quot;</span></span><br><span class="line">        self._current = <span class="number">0</span></span><br><span class="line">        random.shuffle(self._cards)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;发牌&quot;&quot;&quot;</span></span><br><span class="line">        card = self._cards[self._current]</span><br><span class="line">        self._current += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> card</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_next</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;还有没有牌&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self._current &lt; <span class="built_in">len</span>(self._cards)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;玩家&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self._name = name</span><br><span class="line">        self._cards_on_hand = []</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cards_on_hand</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._cards_on_hand</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, card</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;摸牌&quot;&quot;&quot;</span></span><br><span class="line">        self._cards_on_hand.append(card)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">arrange</span>(<span class="params">self, card_key</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;玩家整理手上的牌&quot;&quot;&quot;</span></span><br><span class="line">        self._cards_on_hand.sort(key=card_key)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 排序规则-先根据花色再根据点数排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_key</span>(<span class="params">card</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (card.suite, card.face)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    p = Poker()</span><br><span class="line">    p.shuffle()</span><br><span class="line">    players = [Player(<span class="string">&#x27;东邪&#x27;</span>), Player(<span class="string">&#x27;西毒&#x27;</span>), Player(<span class="string">&#x27;南帝&#x27;</span>), Player(<span class="string">&#x27;北丐&#x27;</span>)]</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">13</span>):</span><br><span class="line">        <span class="keyword">for</span> player <span class="keyword">in</span> players:</span><br><span class="line">            player.get(p.<span class="built_in">next</span>)</span><br><span class="line">    <span class="keyword">for</span> player <span class="keyword">in</span> players:</span><br><span class="line">        <span class="built_in">print</span>(player.name + <span class="string">&#x27;:&#x27;</span>, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        player.arrange(get_key)</span><br><span class="line">        <span class="built_in">print</span>(player.cards_on_hand)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><blockquote><p><strong>说明：</strong> 大家可以自己尝试在上面代码的基础上写一个简单的扑克游戏，例如21点(Black Jack)，游戏的规则可以自己在网上找一找。</p></blockquote><h4 id="案例3：工资结算系统"><a class="header-anchor" href="#案例3：工资结算系统"></a>案例3：工资结算系统</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">某公司有三种类型的员工 分别是部门经理、程序员和销售员</span></span><br><span class="line"><span class="string">需要设计一个工资结算系统 根据提供的员工信息来计算月薪</span></span><br><span class="line"><span class="string">部门经理的月薪是每月固定15000元</span></span><br><span class="line"><span class="string">程序员的月薪按本月工作时间计算 每小时150元</span></span><br><span class="line"><span class="string">销售员的月薪是1200元的底薪加上销售额5%的提成</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span>(<span class="params"><span class="built_in">object</span>, metaclass=ABCMeta</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;员工&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        初始化方法</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param name: 姓名</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self._name = name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_salary</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        获得月薪</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :return: 月薪</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span>(<span class="params">Employee</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;部门经理&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_salary</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">15000.0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Programmer</span>(<span class="params">Employee</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;程序员&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, working_hour=<span class="number">0</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(name)</span><br><span class="line">        self._working_hour = working_hour</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">working_hour</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._working_hour</span><br><span class="line"></span><br><span class="line"><span class="meta">    @working_hour.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">working_hour</span>(<span class="params">self, working_hour</span>):</span></span><br><span class="line">        self._working_hour = working_hour <span class="keyword">if</span> working_hour &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_salary</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">150.0</span> * self._working_hour</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Salesman</span>(<span class="params">Employee</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;销售员&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, sales=<span class="number">0</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(name)</span><br><span class="line">        self._sales = sales</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sales</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._sales</span><br><span class="line"></span><br><span class="line"><span class="meta">    @sales.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sales</span>(<span class="params">self, sales</span>):</span></span><br><span class="line">        self._sales = sales <span class="keyword">if</span> sales &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_salary</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1200.0</span> + self._sales * <span class="number">0.05</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    emps = [</span><br><span class="line">        Manager(<span class="string">&#x27;刘备&#x27;</span>), Programmer(<span class="string">&#x27;诸葛亮&#x27;</span>),</span><br><span class="line">        Manager(<span class="string">&#x27;曹操&#x27;</span>), Salesman(<span class="string">&#x27;荀彧&#x27;</span>),</span><br><span class="line">        Salesman(<span class="string">&#x27;吕布&#x27;</span>), Programmer(<span class="string">&#x27;张辽&#x27;</span>),</span><br><span class="line">        Programmer(<span class="string">&#x27;赵云&#x27;</span>)</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">for</span> emp <span class="keyword">in</span> emps:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(emp, Programmer):</span><br><span class="line">            emp.working_hour = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入%s本月工作时间: &#x27;</span> % emp.name))</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(emp, Salesman):</span><br><span class="line">            emp.sales = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入%s本月销售额: &#x27;</span> % emp.name))</span><br><span class="line">        <span class="comment"># 同样是接收get_salary这个消息但是不同的员工表现出了不同的行为(多态)</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s本月工资为: ￥%s元&#x27;</span> %</span><br><span class="line">              (emp.name, emp.get_salary()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim简单使用</title>
      <link href="2019/06/27/Vim%E5%9F%BA%E7%A1%80/"/>
      <url>2019/06/27/Vim%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>Vim是从 vi 发展出来的一个文本编辑器。</p><hr><h2 id="打开-退出"><a class="header-anchor" href="#打开-退出"></a>打开/退出</h2><ul><li>vim -R file1 只读打开</li><li>:qall 退出所有文件</li><li>:wq 保存并退出</li><li>:q! 强制退出</li></ul><h2 id="插入"><a class="header-anchor" href="#插入"></a>插入</h2><ul><li>i 在当前位置生前插入</li><li>I 在当前行首插入</li><li>a 在当前位置后插入</li><li>A 在当前行尾插入</li><li>o 在当前行之后插入一行</li><li>O 在当前行之前插入一行</li></ul><h2 id="移动"><a class="header-anchor" href="#移动"></a>移动</h2><ul><li>h 左移一个字符</li><li>l 右移一个字符</li><li>k 上移一个字符</li><li>j 下移一个字符</li></ul><blockquote><p>**说明:**以上四个命令可以配合数字使用,比如20j就是向下移动20行，5h就是向左移动5个字符。</p></blockquote><h2 id="删除"><a class="header-anchor" href="#删除"></a>删除</h2><ul><li>dd 删除当前行</li><li>dj 删除当前行和上一行</li><li>dk 删除当前行和下一行</li><li>10dd 删除当前行开始的共10行</li><li>D 删除当前字符至行尾</li></ul><h2 id="跳转"><a class="header-anchor" href="#跳转"></a>跳转</h2><ul><li>gg 跳转到文件头</li><li>G 跳转到文件尾</li><li>Ctrl + d 向下滚动半屏</li><li>Ctrl + u 向上滚动半屏</li><li>Ctrl + f 向下滚动一屏</li><li>Ctrl + b 向上滚动一屏</li><li>冒号+行号，跳转到指定行；比如:120，跳转到120行；</li><li>$ 跳转到行尾</li><li>0 跳转到行首</li></ul><h2 id="编辑"><a class="header-anchor" href="#编辑"></a>编辑</h2><ul><li>u 撤销</li><li>yy 复制当前行</li><li>yaw 复制词</li><li>按v（逐字）或V（逐行）进入可视模式，然后用jklh命令移动即可选择某些行或字符，再按y即可复制任意部分</li><li>p 粘贴在当前位置</li></ul><blockquote><p>**说明:**另外，删除在vim里面就是剪切的意思，所以dd就是剪切当前行，可以用v或V选择特定部分再按d就是任意剪切了</p></blockquote><h2 id="查找"><a class="header-anchor" href="#查找"></a>查找</h2><ul><li>/text　　查找text，按n健查找下一个，按N健查找前一个</li><li>?text　　查找text，反向查找，按n健查找下一个，按N健查找前一个</li><li>:set ignorecase　　忽略大小写的查找</li><li>:set noignorecase　　不忽略大小写的查找</li></ul><h2 id="替换"><a class="header-anchor" href="#替换"></a>替换</h2><ul><li>:s/old/new/ 用old替换new，替换当前行的第一个匹配</li><li>:s/old/new/g 用old替换new，替换当前行的所有匹配</li><li>:%s/old/new/ 用old替换new，替换所有行的第一个匹配</li><li>:%s/old/new/g 用old替换new，替换整个文件的所有匹配</li></ul><blockquote><p>**提示:**也可以用v或V选择指定行，然后执行</p></blockquote><h2 id="多文件操作"><a class="header-anchor" href="#多文件操作"></a>多文件操作</h2><ul><li>vim file1 file2 file3 … 同时编辑多个文件</li><li>:split 将窗口分成上下两个子窗口，对应两个不同的文件</li><li>:vsplit 将窗口分成左右两个子窗口，对应两个不同的文件</li><li>:bn 切换到下一个文件（当前窗口）</li><li>:bp 切换到上一个文件（当前窗口）</li><li>Ctrl-w h    移动到窗口左边</li><li>Ctrl-w j    移动到窗口下边</li><li>Ctrl-w k    移动到窗口上边</li><li>Ctrl-w l    移动到窗口右边</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows常用快捷键及命令</title>
      <link href="2019/06/24/Windows%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%8F%8A%E5%91%BD%E4%BB%A4/"/>
      <url>2019/06/24/Windows%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%8F%8A%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>Windows常用快捷键及命令</p><hr><h2 id="Fn键"><a class="header-anchor" href="#Fn键"></a>Fn键</h2><p><kbd>F1</kbd>：帮助</p><p><kbd>F2</kbd>：重命名</p><p><kbd>F3</kbd>：打开搜索</p><p><kbd>F4</kbd>：打开地址栏常用地址</p><p><kbd>F5</kbd>刷新</p><p><kbd>F11</kbd>：全屏/退出全屏</p><h2 id="文件和文件夹"><a class="header-anchor" href="#文件和文件夹"></a>文件和文件夹</h2><p><kbd>Shift</kbd>：选择连续的内容（与鼠标左键配合使用）</p><p><kbd>Ctrl</kbd>：选择不连续的内容（与鼠标左键配合使用）</p><p><kbd>Ctrl</kbd>+<kbd>A</kbd>：选择全部内容</p><p><kbd>Ctrl</kbd>+<kbd>C</kbd>：复制选择的项目</p><p><kbd>Ctrl</kbd>+<kbd>X</kbd>：剪切选择的项目</p><p><kbd>Ctrl</kbd>+<kbd>V</kbd>：粘贴选择的项目</p><p><kbd>Ctrl</kbd>+<kbd>Z</kbd>：撤销操作</p><p><kbd>Ctrl</kbd>+<kbd>Y</kbd>：重新执行某项操作</p><p><kbd>Delete</kbd>：删除所选的项目并将其移动到“回收站”</p><p><kbd>Shift</kbd>+<kbd>Delete</kbd>：永久删除所选的项目（删除之后无法从回收站还原）</p><h2 id="Windows徽标键"><a class="header-anchor" href="#Windows徽标键"></a>Windows徽标键</h2><p><kbd>Win</kbd>：打开或者关闭开始菜单</p><p><kbd>Win</kbd>+<kbd>Pause</kbd>：显示系统属性对话框</p><p><kbd>Win</kbd>+<kbd>D</kbd>：显示桌面</p><p><kbd>Win</kbd>+<kbd>M</kbd>：最小化所有窗口</p><p><kbd>Win</kbd>+<kbd>Shift</kbd>+<kbd>M</kbd>：还原最小化窗口到桌面上</p><p><kbd>Win</kbd>+<kbd>E</kbd>：打开我的电脑，Win10系统为资源管理器</p><p><kbd>Win</kbd>+<kbd>L</kbd>：锁定您的计算机或切换用户</p><p><kbd>Win</kbd>+<kbd>R</kbd>：打开运行对话框</p><p><kbd>Win</kbd>+<kbd>↓</kbd>：小化窗口</p><p><kbd>Win</kbd>+<kbd>↑</kbd>：最大化当前窗口</p><p><kbd>Win</kbd>+<kbd>←</kbd>：最大化到窗口左侧的屏幕上</p><p><kbd>Win</kbd>+<kbd>→</kbd>：最大化到窗口右侧的屏幕上</p><p><kbd>Win</kbd>+<kbd>Home</kbd>：最小化所有窗口，除了当前激活窗口</p><h2 id="windows资源管理器"><a class="header-anchor" href="#windows资源管理器"></a>windows资源管理器</h2><p><kbd>Alt</kbd>+<kbd>P</kbd>：显示预览窗格</p><p><kbd>Alt</kbd>+<kbd>←</kbd>：切换到前一次打开的文件夹</p><p><kbd>Alt</kbd>+<kbd>→</kbd>：切换到下一次后打开的文件夹</p><p><kbd>Alt</kbd>+<kbd>↑</kbd>：打开上层文件夹</p><p><kbd>Backspace</kbd>：打开上层文件夹</p><p><kbd>Ctrl</kbd>+<kbd>Shift</kbd>+打开应用：以管理员身份运行</p><h2 id="windows对话框"><a class="header-anchor" href="#windows对话框"></a>windows对话框</h2><p><kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>Tab</kbd>：在选项卡上向后移动</p><p><kbd>Tab</kbd>：在选项上向后移动</p><p><kbd>shift</kbd>+<kbd>Tab</kbd>：在选项卡上向前移动</p><h2 id="屏幕程序切换"><a class="header-anchor" href="#屏幕程序切换"></a>屏幕程序切换</h2><p><kbd>Ctrl</kbd>+<kbd>Win</kbd>+<kbd>D</kbd>：创建虚拟座面</p><p><kbd>Ctrl</kbd>+<kbd>Win</kbd>+<kbd>→</kbd>&amp;<kbd>←</kbd>：切换虚拟屏幕</p><p><kbd>Alt</kbd>+<kbd>Tab</kbd>：在打开的项目之间来回切换</p><p><kbd>Alt</kbd>+<kbd>F4</kbd>：关闭活动的项目或者退出活动程序</p><p><kbd>Alt</kbd>+<kbd>Enter</kbd>：显示所选项的属性</p><p><kbd>Shift</kbd>+<kbd>F10</kbd>：显示选定项目的快捷菜单，相当于鼠标右击</p><p><kbd>Esc</kbd>：取消当前任务</p><p><kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>Esc</kbd>：打开任务管理器</p><p><kbd>Ctrl</kbd>+<kbd>鼠标滚轮</kbd>：更改桌面上的图标大小</p><h2 id="以-Chromium为的核心浏览器"><a class="header-anchor" href="#以-Chromium为的核心浏览器"></a>以 Chromium为的核心浏览器</h2><p><kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>B</kbd>：显示或关闭书签栏</p><p><kbd>Ctrl</kbd>+<kbd>T</kbd>：打开新标签</p><p><kbd>Ctrl</kbd> + <kbd>Tab</kbd>：跳转标签页</p><p><kbd>Ctrl</kbd>+<kbd>W</kbd>：关闭当前标签</p><p><kbd>Alt</kbd> + <kbd>空格键</kbd>，然后按 <kbd>N</kbd> 键：最小化当前窗口</p><p><kbd>Ctrl</kbd> + <kbd>J</kbd>：在新标签页中打开“下载内容”页</p><p><kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>T</kbd>：恢复标签页</p><h2 id="Win-R"><a class="header-anchor" href="#Win-R"></a>Win+R</h2><p>使用<kbd>Win</kbd>+<kbd>R</kbd>打开运行窗口执行命令</p><p>设置自动关机：shutdown -s -t 秒数</p><p>取消关机：shutdown -a</p><p>打开注册表：regedit</p><h2 id="其他软件自定义"><a class="header-anchor" href="#其他软件自定义"></a>其他软件自定义</h2><h3 id="QQ"><a class="header-anchor" href="#QQ"></a>QQ</h3><p><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>A</kbd>：打开截图</p><h3 id="网易云"><a class="header-anchor" href="#网易云"></a>网易云</h3><p><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>空格</kbd>：暂停网易云音乐</p><p><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>→</kbd>&amp;<kbd>←</kbd>：切换上下歌</p><p><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>L</kbd>：标记喜欢歌曲</p>]]></content>
      
      
      <categories>
          
          <category> 快捷键 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快捷键 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客搭建</title>
      <link href="2019/06/17/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>2019/06/17/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>介绍Hexo博客的搭建以及部署到GitHub上</p><hr><p><img src="https://puui.qpic.cn/fans_admin/0/3_1206436828_1572055658592/0" alt="Hexo博客搭建"></p><h2 id="框架安装"><a class="header-anchor" href="#框架安装"></a>框架安装</h2><ol><li><p>官网安装<a href="http://nodejs.cn/download/">Node.js</a></p></li><li><p>利用cnmp解决npm下载安装缓慢问题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><blockquote><p>在安装之前需要安装Git</p></blockquote></li><li><p>安装Hexo框架<code>cnpm install -g hexo-cli</code></p></li></ol><h2 id="框架配置"><a class="header-anchor" href="#框架配置"></a>框架配置</h2><ol><li>切换到新建博客目录下</li><li><code>hexo init</code>自动生成框架</li><li><code>hexo s</code>启动检验<blockquote><p>Hexo3将server独立需单独安装<br>命令npm install hexo-server --save<br>如果EADDRINUSE错误修改端口例如hexo s -p 8080</p></blockquote></li></ol><span id="more"></span><h2 id="框架目录"><a class="header-anchor" href="#框架目录"></a><a href="https://hexo.io/zh-cn/docs/setup">框架目录</a></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── theme</span><br></pre></td></tr></table></figure><h3 id="config-yml"><a class="header-anchor" href="#config-yml"></a>_config.yml</h3><p>修改配置信息</p><h3 id="package-json"><a class="header-anchor" href="#package-json"></a>package.json</h3><p>应用程序的信息</p><h3 id="scaffolds"><a class="header-anchor" href="#scaffolds"></a>scaffolds</h3><p>模版文件夹</p><h3 id="source"><a class="header-anchor" href="#source"></a>source</h3><p>资源文件夹是存放用户资源的地方</p><blockquote><p>除_posts文件夹之外，开头命名为_(下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public文件夹，而其他文件会被拷贝过去。</p></blockquote><h3 id="themes"><a class="header-anchor" href="#themes"></a>themes</h3><p>主题文件夹</p><h2 id="博客使用"><a class="header-anchor" href="#博客使用"></a>博客使用</h2><ol><li><p><code>hexo n &quot;title&quot;</code> 创建文章</p><blockquote><p>按照scaffolds文件夹模板创建<br>此外可以创建草稿<code>hexo new draft &quot;title&quot;</code></p></blockquote></li><li><p><code>hexo clean</code></p></li><li><p><code>hexo g</code>生成博客</p></li></ol><h2 id="远端部署"><a class="header-anchor" href="#远端部署"></a>远端部署</h2><ol><li><p>安装GitHub插件<code>cnpm install -g hexo-deployer-git --save</code></p></li><li><p>在Github上创建项目库</p><blockquote><p>项目库命名要是   <a href="http://xn--+-i68a184bfos.github.io">用户名+.github.io</a>   例如：<a href="http://lanqilu.github.io">lanqilu.github.io</a></p></blockquote></li><li><p>设置 _config.yml 文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">repo:</span> <span class="string">https://github.com/&lt;GitHub_name&gt;/&lt;GitHub_repositories&gt;.git</span></span><br><span class="line"><span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure></li><li><p>部署到远端<code>hexo d</code><br>填写github账号密码</p></li><li><p>常用部署命令<br>cmd<code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code><br>powershell<code>hexo clean '&amp;' hexo g '&amp;' hexo d</code></p></li></ol><h2 id="更换主题"><a class="header-anchor" href="#更换主题"></a>更换主题</h2><p>以<a href="https://github.com/theme-next/hexo-theme-next">Next</a>为例</p><ul><li><p>克隆到themes目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone  https://github.com/theme-next/hexo-theme-next.git</span><br></pre></td></tr></table></figure></li><li><p>配置<code>_config.yml</code></p> <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next-reloaded</span>  <span class="comment"># 主题名</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="问题"><a class="header-anchor" href="#问题"></a>问题</h2><h3 id="图片问题"><a class="header-anchor" href="#图片问题"></a>图片问题</h3><p>配置<code>_config.yml</code>里面的<code>post_asset_folder:false</code>这个选项设置为<code>true</code><br>默认在创建新文件时生成同名文件夹</p><blockquote><p>使用方法<code>![](xxx.jpg)</code></p></blockquote><p>推荐使用图床来在Markdown文本中插入图片</p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日语输入法的使用</title>
      <link href="2019/06/17/%E6%97%A5%E8%AF%AD%E8%BE%93%E5%85%A5%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>2019/06/17/%E6%97%A5%E8%AF%AD%E8%BE%93%E5%85%A5%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>微软日语输入法的简单使用来自该<a href="https://www.bilibili.com/video/av37827841">视频</a></p><hr><span id="more"></span><p><img src="https://pic.superbed.cn/item/5db3013b8b58bc7bf70c5c2b.jpg" alt="桜"></p><h2 id="切换输入模式"><a class="header-anchor" href="#切换输入模式"></a>切换输入模式</h2><ul><li><p>所有语言所有输入法之间切换Win+space（空格）</p></li><li><p>多语言默认输入法之间切换Alt+Shift</p></li><li><p>同一语言下输入法切换Ctrl+Shift</p></li><li><p>英文输入：快捷键Alt + ~（Esc键下边,数字1左边的那个键）<br>可以在直接输入【罗马字】（图标A）和当前假名输入法间切换</p></li><li><p>平假名：Ctrl + Caps Lock<br>日文模式下切换到【平假名】Hiragana（图标あ），<br>罗马字，英文输入（图标A）下则是切换回日文模式，如原先不在Hiragana，则必须多按一次。</p></li><li><p>片假名：Alt + Caps Lock<br>日文模式下切换到【片假名】，全角片假名Full-width Katakana</p></li></ul><blockquote><p>**说明:**罗马字，英文输入（图标A）下则是切换回日文模式，如原先不在Full-width Katakana，则必须多按一次。</p></blockquote><h2 id="字符选择快捷键"><a class="header-anchor" href="#字符选择快捷键"></a>字符选择快捷键</h2><p>敲完字母后<strong>不敲空格键或回车键</strong>，加按</p><ul><li>F5，转成字符集（选字或造字）</li><li>F6，恢复平假名（全角）</li><li>F7，转成片假名（全角）</li><li>F8，转成片假名（半角）</li><li>F9，转成罗马字母（全角），连续按击可以在全大写，全小写，首字母大写之间转换。</li><li>F10，转成罗马字母（半角），连续按击可以在全大写，全小写，首字母大写之间转换。</li></ul><h2 id="输入规则"><a class="header-anchor" href="#输入规则"></a>输入规则</h2><ol><li>促音的输入法：促音后的第一个字母连续输入两次。例: 設定　せってい　settei<br>单独输入促音也可以用ltu或xtu，<blockquote><p>同理 小写假名都是x或者l加原来的拼写如xaぁ 与aあ</p></blockquote></li><li>拨音的输入法:按两下&quot;n&quot;。例:　漫画　まんが　mannga</li><li>拗音的输入法:例:きゃきゅきょ kya kyu kyo （亦即是罗马字拼写法则）</li><li>长音输入法：片假名按数字0右边的-号键（减号键），平假名前面的元音多打一个</li><li>助词“を”的输入方法是“wo”</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 日语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown基本语法</title>
      <link href="2019/05/08/Markdown%E8%AF%AD%E6%B3%95/"/>
      <url>2019/05/08/Markdown%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p><p>Markdown具有一系列衍生版本，用于扩展Markdown的功能（如表格、脚注、内嵌HTML等等），这些功能原初的Markdown尚不具备，它们能让Markdown转换成更多的格式，例如LaTeX，Docbook。</p><p>Markdown增强版中比较有名的有Markdown Extra、MultiMarkdown、 Maruku等。这些衍生版本要么基于工具，如Pandoc；要么基于网站，如GitHub和Wikipedia，在语法上基本兼容，但在一些语法和渲染效果上有改动。</p><p>因为增强版等存在不同软件和网站有各自特殊的语法规则，本文档仅整理常用的通用规则。</p><hr><h2 id="Markdown-标题"><a class="header-anchor" href="#Markdown-标题"></a>Markdown 标题</h2><p>顶格使用 <code>#</code> 标记，并在<code>#</code>号后加入1个空格，根据空格前的<code>#</code>数量确定标题的级数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><p>标题分为四级：</p><ul><li>一级标题：文章的标题</li><li>二级标题：文章主要部分的大标题</li><li>三级标题：二级标题下面一级的小标题</li><li>四级标题：三级标题下面某一方面的小标题</li></ul><p>标题使用原则：</p><p>一级标题下，不能直接出现三级标题。示例：下面的文章结构，缺少二级标题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line"></span><br><span class="line">### 三级标题</span><br></pre></td></tr></table></figure><p>标题要避免孤立编号（即同级标题只有一个）。示例：下面的文章结构，<code>二级标题 A</code>只包含一个三级标题，完全可以省略<code>三级标题 A</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">## 二级标题 A</span><br><span class="line"></span><br><span class="line">### 三级标题 A</span><br><span class="line"></span><br><span class="line">## 二级标题 B</span><br></pre></td></tr></table></figure><p>下级标题不重复上一级标题的名字。示例：下面的文章结构，二级标题与下属的三级标题同名，建议避免。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">## 概述</span><br><span class="line"></span><br><span class="line">### 概述</span><br></pre></td></tr></table></figure><p>谨慎使用四级标题，尽量避免出现，保持层级的简单，防止出现过于复杂的章节。如果三级标题下有并列性的内容，建议只使用项目列表（Item list）。示例：下面的结构二要好于结构一。结构一适用的场景，主要是较长篇幅的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">结构一</span><br><span class="line"></span><br><span class="line">### 三级标题</span><br><span class="line"></span><br><span class="line">#### 四级标题 A</span><br><span class="line"></span><br><span class="line">#### 四级标题 B</span><br><span class="line"></span><br><span class="line">#### 四级标题 C</span><br><span class="line"></span><br><span class="line">结构二</span><br><span class="line"></span><br><span class="line">### 三级标题</span><br><span class="line"></span><br><span class="line">**（1）A**</span><br><span class="line"></span><br><span class="line">**（2）B**</span><br><span class="line"></span><br><span class="line">**（3）C**</span><br></pre></td></tr></table></figure><h2 id="Markdown-文本"><a class="header-anchor" href="#Markdown-文本"></a>Markdown 文本</h2><p>通过<code>*</code>和<code>_</code>对文本的包围使用可以实现以下几种效果</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">*斜体文本*</span></span><br><span class="line"><span class="emphasis">_斜体文本_</span></span><br><span class="line"><span class="strong">**粗体文本**</span></span><br><span class="line"><span class="strong">__粗体文本__</span></span><br><span class="line"><span class="strong">**<span class="emphasis">*粗斜体文本<span class="strong">**<span class="emphasis">*</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis"><span class="strong">__<span class="emphasis">_粗斜体文本<span class="strong">__<span class="emphasis">_</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis">~~删除线~~</span></span></span></span></span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis">`代码`</span></span></span></span></span></span></span></span></span><br></pre></td></tr></table></figure><p>若单使用<code>***</code> <code>---</code>可实现如下分隔线的效果</p><hr><p>此外使用Html标签中的<code>&lt;u&gt;下划线&lt;/u&gt;</code> 实现下划线效果</p><blockquote><p>该网站修改下划线效果，改成如下样式：<u>下划线</u>。以实现遮盖效果</p></blockquote><h2 id="Markdown-列表"><a class="header-anchor" href="#Markdown-列表"></a>Markdown 列表</h2><p>列表分为无序和有序两种，实现起来也非常简单</p><p>无序列表：使用星号(<code>*</code>)、加号(<code>+</code>)或是减号(<code>-</code>)作为列表标记：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span> 123</span><br><span class="line"><span class="bullet">+</span> 456</span><br><span class="line"><span class="bullet">-</span> 789</span><br></pre></td></tr></table></figure><blockquote><p>但为了方便修改，建议一篇文档只使用一种实现方式，推荐统一使用<code>+</code>来实现</p></blockquote><hr><p>有序列表：<code>1.</code>只需在数字后加上半角句号并添加一个空格即可实现</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> a</span><br><span class="line"><span class="bullet">2.</span> b</span><br><span class="line"><span class="bullet">3.</span> c</span><br></pre></td></tr></table></figure><blockquote><p>列表之间可以相互嵌套，但要注意层次间的缩进</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 第一项:</span><br><span class="line"><span class="bullet">   +</span> 第一项嵌套的第一个元素</span><br><span class="line"><span class="bullet">   +</span> 第一项嵌套的第二个元素</span><br></pre></td></tr></table></figure><h2 id="Markdown-区块"><a class="header-anchor" href="#Markdown-区块"></a>Markdown 区块</h2><p>区块使用<code>&gt;</code>符号加空格实现，同样可以进行嵌套</p><p><code>&gt; 最外层</code><br><code>&gt; &gt; 第一层嵌套</code><br><code>&gt; &gt; &gt; 第二层嵌套</code></p><blockquote><p>最外层</p><blockquote><p>第一层嵌套</p><blockquote><p>第二层嵌套</p></blockquote></blockquote></blockquote><h2 id="Markdown-代码"><a class="header-anchor" href="#Markdown-代码"></a>Markdown 代码</h2><p>如<code>printf()</code> 所示，表示代码，使用该符号`（键盘上在数字1前）将内容包裹</p><p>连续的3个反单引号包裹的片段就可以，实现代码块样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">```python</span></span><br><span class="line"><span class="code">print(&quot;Hello,world!&quot;)</span></span><br><span class="line"><span class="code">```</span></span><br></pre></td></tr></table></figure><h2 id="Markdown-链接"><a class="header-anchor" href="#Markdown-链接"></a>Markdown 链接</h2><p>使用该形式<code>[链接名称](链接地址)</code>可创建一个链接</p><p>这是一个链接<a href="http://www.baidu.com/">百度</a></p><h2 id="Markdown-图片"><a class="header-anchor" href="#Markdown-图片"></a>Markdown 图片</h2><p><img src="https://pic.downk.cc/item/5fe748a83ffa7d37b3ef621f.jpg" alt="Markdown" title="Hello"></p><p>上图的实现方法</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">Markdown</span>](<span class="link">https://pic.downk.cc/item/5fe748a83ffa7d37b3ef621f.jpg &quot;Hello&quot;</span>)</span><br></pre></td></tr></table></figure><p><code>![图名](图片地址)</code></p><p><code>![图名](图片地址 &quot;可选标题&quot;)</code></p><p>开头一个感叹号<code>!</code>,接着一个方括号，里面放上图片的替代文字,接着一个普通括号，里面放上图片的网址(或者本地文件地址)，最后还可以用引号包住并加上选择性的 ‘title’ 属性的文字。</p><p>Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 <code>&lt;img&gt;</code> 标签</p><h2 id="Markdown-表格"><a class="header-anchor" href="#Markdown-表格"></a>Markdown 表格</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|  表头   | 表头  |</span><br><span class="line">|  ----  | ----  |</span><br><span class="line">| 单元格  | 单元格 |</span><br><span class="line">| 单元格  | 单元格 |</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">表头</th><th style="text-align:center">表头</th></tr></thead><tbody><tr><td style="text-align:center">单元格</td><td style="text-align:center">单元格</td></tr><tr><td style="text-align:center">单元格</td><td style="text-align:center">单元格</td></tr></tbody></table><ul><li>-: 设置内容和标题栏居右对齐。</li><li>:- 设置内容和标题栏居左对齐。</li><li>:-: 设置内容和标题栏居中对齐。</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| 左对齐 | 右对齐 | 居中对齐 |</span><br><span class="line">| :----- | -----: | :------: |</span><br><span class="line">| 单元格 | 单元格 |  单元格  |</span><br><span class="line">| 单元格 | 单元格 |  单元格  |</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">左对齐</th><th style="text-align:right">右对齐</th><th style="text-align:center">居中对齐</th></tr></thead><tbody><tr><td style="text-align:left">单元格</td><td style="text-align:right">单元格</td><td style="text-align:center">单元格</td></tr><tr><td style="text-align:left">单元格</td><td style="text-align:right">单元格</td><td style="text-align:center">单元格</td></tr></tbody></table><p>参考资料：</p><ul><li>阮一峰，<a href="https://github.com/ruanyf/document-style-guide">中文技术文档的写作规范</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git的常见使用</title>
      <link href="2019/03/12/Git%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>2019/03/12/Git%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>Git的常见使用</p><hr><h2 id="配置GitHub"><a class="header-anchor" href="#配置GitHub"></a>配置GitHub</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;your_name&quot;</span><br><span class="line">git config --global user.email &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure><p>在windows系统中的<code>C:\Users\用户名\.ssh</code>中会产生<code>.ssh</code>文件夹中会生成一对密钥包括<code>id_rsa</code>私钥和<code>id_rsa.pub</code>公钥文件</p><p>如果不存在，在Git Bash使用以下命令生成</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure><p>将会弹出以下信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/c/Users/用户名/.ssh/id_rsa):  回车</span><br><span class="line">Created directory <span class="string">&#x27;/c/Users/用户名/.ssh&#x27;</span>.</span><br><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):    回车或输密码</span><br><span class="line">Enter same passphrase again:                   回车或再一次输密码</span><br><span class="line">Your identification has been saved <span class="keyword">in</span> /c/Users/用户名/.ssh/id_rsa</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> /c/Users/用户名/.ssh/id_rsa.pub</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:JAldGP+8XXXXXXXXXXXRhzaEpUd5hJfTn0zrJxhXbFYM your_email@example.com</span><br><span class="line">The key<span class="string">&#x27;s randomart image is:</span></span><br><span class="line"><span class="string">+---[RSA 3072]----+</span></span><br><span class="line"><span class="string">|    ..o=*..   .o |</span></span><br><span class="line"><span class="string">|     +o= +   E  o|</span></span><br><span class="line"><span class="string">|    . + = . . . .|</span></span><br><span class="line"><span class="string">|     . B + o . +.|</span></span><br><span class="line"><span class="string">|    + O S o o + .|</span></span><br><span class="line"><span class="string">|   = @ o . = =   |</span></span><br><span class="line"><span class="string">|  . B o   o B    |</span></span><br><span class="line"><span class="string">|     o     . .   |</span></span><br><span class="line"><span class="string">|                 |</span></span><br><span class="line"><span class="string">+----[SHA256]-----+</span></span><br></pre></td></tr></table></figure><p>将<code>id_rsa.pub</code>公钥文件放到Setting中的SSH and GPG keys中</p><p><img src="http://img.whl123456.top/image/GitHubSSH.png" alt="GitHub"></p><p>在Git Bash中输入以下命令，验证是否成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>如果成功则会显示以下消息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi your_name! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure><h3 id="创建版本库"><a class="header-anchor" href="#创建版本库"></a>创建版本库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir &lt;文件夹名&gt;</span><br><span class="line">cd &lt;文件名&gt;</span><br><span class="line">pwd</span><br></pre></td></tr></table></figure><p><code>git init</code> 把这个目录变成Git可以管理的仓库</p><p>结果生成.git 隐藏文件夹 （不要手动修改文件夹的内容）</p><blockquote><p>注意事项<br>不要使用Windows自带的记事本编辑任何文件<br>默认编码设置成UTF-8 without BOM</p></blockquote><p><img src="http://img.whl123456.top/image/image-20200613103720281.png" alt="image-20200613103720281"></p><h3 id="文件放到Git仓库目录下"><a class="header-anchor" href="#文件放到Git仓库目录下"></a>文件放到Git仓库目录下</h3><p><code>git status</code></p><p><code>git add &lt;file&gt;</code></p><p><code>git add .</code>提交新文件和被修改文件，不包括被删除文件</p><p><code>git add -u</code>提交被修改和被删除文件，不包括新文件</p><p><code>git add -A</code>提交所有变化</p><p><code>git add -i</code></p><blockquote><p>Unix哲学 “没有消息就是好消息”</p></blockquote><h3 id="把文件提交到仓库"><a class="header-anchor" href="#把文件提交到仓库"></a>把文件提交到仓库</h3><p><code>git commit -m &lt;message&gt;</code>-m 后面输入本次提交的说明</p><p><code>git commit --amend</code>修改最近一次提交的注释信息</p><h3 id="vim编辑器的使用"><a class="header-anchor" href="#vim编辑器的使用"></a>vim编辑器的使用</h3><p><code>vi &lt;filename&gt;</code></p><p>输入字母<code>i</code>或Insert键进入最常用的插入编辑模式<br>按下字母键 <code>c</code>（此时进入编辑状态），可以开始修改注释信息了<br>按下Esc (退出编辑状态)<br>接着连按两次大写字母<code>Z</code>，保存并退出<br>只想保存文件，则键入:<code>w</code><br>放弃所有文件修改：按下ESC键进入命令模式，键入:<code>q!</code>回车后放弃修改并退出vi<br><code>.</code>放弃所有文件修改，但不退出 vi:<br>按下ESC键进入命令模式，键入:<code>e!</code>，回车后回到命令模式</p><h3 id="修改文件后"><a class="header-anchor" href="#修改文件后"></a>修改文件后</h3><p><code>git stautus</code> 掌握仓库当前的状态</p><blockquote><p>On branch master<br>nothing to commit, working tree clean</p></blockquote><p><code>git diff &lt;file&gt;</code>#看具体修改了什么内容<br>再<code>git add &lt;file&gt;</code></p><p><code>git log</code>#历史记录 显示从最近到最远的提交日志</p><p><code>git log --pretty=oneline</code>oneline 压缩模式</p><h3 id="退回之前的版本"><a class="header-anchor" href="#退回之前的版本"></a>退回之前的版本</h3><p>就是HEAD<sup>，上上一个版本就是HEAD</sup><sup>，当然往上100个版本写100个</sup>比较容易数不过来，所以写成HEAD~100<br><code>git reset --hard HEAD^</code></p><p><code>git reflog</code>#记录你的每一次命令<br><code>git reset --hard &lt;commit id&gt;</code>（id不必写全）</p><h3 id="修改"><a class="header-anchor" href="#修改"></a>修改</h3><p><code>git checkout -- &lt;file&gt;</code><br>丢弃 工作区 的修改  在工作区的修改全部撤销，<br>让这个文件回到最近一次git commit或git add时的状态</p><p><code>git reset HEAD &lt;file&gt;</code><br>既可以回退版本，也可以把暂存区的修改回退到工作区</p><h3 id="删除文件"><a class="header-anchor" href="#删除文件"></a>删除文件</h3><p><code>rm &lt;file&gt;</code>     #删除工作区文件<br><code>git rm &lt;file&gt;</code> #从版本库中删除该文件</p><p>先手动删除文件，然后使用git add<file>效果是一样的<br>git checkout  – <file>   #把误删的文件恢复到最新版本（用版本库里的版本替换工作区的版本）</p><h3 id="分支"><a class="header-anchor" href="#分支"></a>分支</h3><p><code>git checkout -b &lt;branchname&gt;</code> #创建分支,然后切换到分支<br><code>git branch &lt;branchname&gt;</code>      #创建分支<br><code>git checkout &lt;branchname&gt;</code>    #切换到分支<br><code>git branch</code>                   #查看当前分支<br><code>git checkout master</code>          #换回master分支<br><code>git merge &lt;branchname&gt;</code>       #合并指定分支到当前分支<br><code>git branch -d &lt;branchname&gt;</code>   #删除分支<br><code>git branch -m &lt;branchname&gt;</code>   #重命名分支</p><h2 id="GitHub"><a class="header-anchor" href="#GitHub"></a>GitHub</h2><h3 id="推送"><a class="header-anchor" href="#推送"></a>推送</h3><p>关联一个远程库并推送</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@Lanqilu:path/&lt;repo-name&gt;.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><h3 id="克隆"><a class="header-anchor" href="#克隆"></a>克隆</h3><p><code>git clone &lt;url&gt;</code></p><h3 id="拉取"><a class="header-anchor" href="#拉取"></a>拉取</h3><p><code>git pull</code></p><ol><li><p>服务器代码合并本地代码</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git stash     //暂存当前正在进行的工作。</span><br><span class="line">git pull origin master //拉取服务器的代码</span><br><span class="line">git stash pop //合并暂存的代码</span><br></pre></td></tr></table></figure></li><li><p>服务器代码覆盖本地代码</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard  //回滚到上一个版本</span><br><span class="line">git pull origin master</span><br></pre></td></tr></table></figure></li></ol><h3 id="版本控制"><a class="header-anchor" href="#版本控制"></a>版本控制</h3><p><code>git log</code></p><p><code>git log --pretty=oneline</code></p><p><code>git log --oneline</code></p><p><code>git reflog</code></p><p><code>git reset --hard [部分索引值]</code></p><h3 id="隐藏文件"><a class="header-anchor" href="#隐藏文件"></a>隐藏文件</h3><p>exclude</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> git ls-files --others --exclude-from=.git/info/exclude</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Lines that start with <span class="string">&#x27;#&#x27;</span> are comments.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> For a project mostly <span class="keyword">in</span> C, the following would be a good <span class="built_in">set</span> of</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> exclude patterns (uncomment them <span class="keyword">if</span> you want to use them):</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> *.[oa]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> *~</span></span><br><span class="line">.*</span><br></pre></td></tr></table></figure><h3 id="忽略文件"><a class="header-anchor" href="#忽略文件"></a>忽略文件</h3><p><code>touch .gitignore</code><br><code>.git/info/exclude`` ``vi .git/info/exclude</code></p><ol><li>忽略文件中的空行或以井号( #告开始的行将会被忽略。</li><li>可以使用Linux通配符。例如:星号(* )代表任意多个字符,问号( ? ) 代表-一个字符 ,方括号( [abc] )代表可选字符范围,<br>大括号( {string1,string… )代表可选的字符串等。</li><li>如果名称的最前面有一一个感叹号(!) , 表示例外规则,将不被忽略。</li><li>如果名称的最前面是一个路径分隔符 (/ ) , 表示要忽略的文件在此目录下,而子目录中的文件不忽略。</li><li>如果名称的最后面是一个路径分隔符(/) , 表示要忽略的是此目录下该名称的子目录,而非文件(默认文件或目录都忽略)。</li></ol><h3 id="删除远程文件"><a class="header-anchor" href="#删除远程文件"></a>删除远程文件</h3><p>方法一<br>这里以删除 test文件夹为案例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached test //--cached不会把本地的test删除</span><br><span class="line">git commit -m &#x27;delete test &#x27;</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>方法二<br>如果误提交的文件夹比较多，方法一也较繁琐<br>直接修改.gitignore文件,将不需要的文件过滤掉，然后执行命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached .</span><br><span class="line">git add .</span><br><span class="line">git commit</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://blog.csdn.net/cui130/article/details/84033966">参考博客</a></p></blockquote><h3 id="下载文件"><a class="header-anchor" href="#下载文件"></a>下载文件</h3><p>单个文件<a href="https://minhaskamal.github.io/DownGit/#/home">DownGit</a>，国内访问较慢</p><p>将仓库克隆到码云上在下载</p><p>使用迅雷</p><h2 id="错误"><a class="header-anchor" href="#错误"></a>错误</h2><ol><li>原因是因为上传时间太长了，导致ssh连接超时断开</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fatal: sha1 file &#x27;&lt;stdout&gt;&#x27; write error: Broken pipe KiB/s</span><br><span class="line">fatal: the remote end hung up unexpectedly</span><br><span class="line">fatal: the remote end hung up unexpectedly</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><a href="https://blog.csdn.net/qq_31803503/article/details/88323527">解决方案</a></p></blockquote><h3 id="push问题"><a class="header-anchor" href="#push问题"></a>push问题</h3><h4 id="rejected-master-master-non-fast-forward"><a class="header-anchor" href="#rejected-master-master-non-fast-forward"></a>! [rejected] master -&gt; master (non-fast-forward)</h4><h5 id="错误-v2"><a class="header-anchor" href="#错误-v2"></a>错误</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push</span></span><br><span class="line">To github.com:Lanqilu/BiliBilil-Leaderboard.git</span><br><span class="line"> ! [rejected]        master -&gt; master (non-fast-forward)</span><br><span class="line">error: failed to push some refs to &#x27;git@github.com:Lanqilu/BiliBilil-Leaderboard.git&#x27;</span><br><span class="line">hint: Updates were rejected because the tip of your current branch is behind</span><br><span class="line">hint: its remote counterpart. Integrate the remote changes (e.g.</span><br><span class="line">hint: &#x27;git pull ...&#x27;) before pushing again.</span><br><span class="line">hint: See the &#x27;Note about fast-forwards&#x27; in &#x27;git push --help&#x27; for details.</span><br></pre></td></tr></table></figure><h5 id="问题"><a class="header-anchor" href="#问题"></a>问题</h5><p>git仓库中已经有一部分代码，所以它不允许你直接把你的代码覆盖上去</p><h5 id="解决方法"><a class="header-anchor" href="#解决方法"></a>解决方法</h5><p>利用强覆盖方式用你本地的代码替代git仓库内的内容</p><blockquote><p>不推荐使用，需要解决冲突再提交</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -f</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/lujinjian605894472/article/details/8443403">参考地址</a></p><!--hexo clean && hexo g && hexo d--><h3 id="pull问题"><a class="header-anchor" href="#pull问题"></a>pull问题</h3><h4 id="问题描述：本地内容有修改但要与pull"><a class="header-anchor" href="#问题描述：本地内容有修改但要与pull"></a>问题描述：本地内容有修改但要与pull</h4><h4 id="解决办法"><a class="header-anchor" href="#解决办法"></a>解决办法</h4><p>先git status暂存</p><p>再pull之后git status pop 选择修改</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
