<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HALO</title>
  
  <subtitle>HALO</subtitle>
  <link href="http://halo123.top/atom.xml" rel="self"/>
  
  <link href="http://halo123.top/"/>
  <updated>2021-05-04T06:30:47.868Z</updated>
  <id>http://halo123.top/</id>
  
  <author>
    <name>HALO</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构——栈和队列</title>
    <link href="http://halo123.top/2021/05/02/DataStructure/C_StacksAndQueues/"/>
    <id>http://halo123.top/2021/05/02/DataStructure/C_StacksAndQueues/</id>
    <published>2021-05-02T08:35:51.000Z</published>
    <updated>2021-05-04T06:30:47.868Z</updated>
    
    <content type="html"><![CDATA[<p>【考纲内容】</p><ul><li>栈和队列的基本概念</li><li>栈和队列的顺序存储结构</li><li>栈和队列的链式存储结构</li><li>栈和队列的应用</li><li>特殊矩阵的压缩存储</li></ul><p>【知识框架】</p><p>TODO 制作脑图</p><p>【复习提示】</p><p>本章通常以选择题的形式考查，题目不算难，但命题的形式比较灵活，其中栈（出入栈的过程、出栈序列的合法性）和队列的操作及其特征是重点。由于它们均是线性表的应用和推广，因此也容易出现在算法设计题中。此外，栈和队列的顺序存储、链式存储及其特点、双端队列的特点、栈和队列的常见应用，以及数组和特殊矩阵的压缩存储都是读者必须掌握的内容。</p><h2 id="栈"><a class="header-anchor" href="#栈"></a>栈</h2><h3 id="栈的基本概念"><a class="header-anchor" href="#栈的基本概念"></a>栈的基本概念</h3><h4 id="栈的定义"><a class="header-anchor" href="#栈的定义"></a>栈的定义</h4><p>栈（Stack）：只允许在一端进行插入或删除操作的线性表。首先栈是一种线性表，但限定这种线性表只能在某一端进行插入和删除操作。</p><p>栈顶（Top）：线性表允许进行插入删除的那一端。</p><p>栈底（Bottom）：固定的，不允许进行插入和删除的另一端。</p><p>空栈：不含任何元素的空表。</p><p>假设某个栈 $S = (a_{1},a_2, a_3,a_4,a_5)$，则 $a_1$ 为栈底元素，$a_5$ 为栈顶元素。由于栈只能在栈顶进行插入和删除操作，进栈次序依次为 $a_{1},a_2, a_3,a_4,a_5$ 而出栈次序为 $a_{5},a_4, a_3,a_2,a_1$。由此可见，栈的操作特性可以明显地概括为后进先出（Last In First Out，LIFO）。</p><p>栈的数学性质：$n$ 个不同元素进栈，出栈元素不同排列的个数为 $\frac{1}{n+1}C_{2n}^{n}  $。上述公式称为卡特兰（Catalan）数，可采用数学归纳法证明。</p><h4 id="找的基本操作"><a class="header-anchor" href="#找的基本操作"></a>找的基本操作</h4><ul><li><code>InitStack(&amp;S)</code>：初始化一个空栈 S。</li><li><code>StackEmpty(S)</code>：判断一个栈是否为空，若栈 S 为空则返回 true，否则返回 false。</li><li><code>Push(&amp;S,x)</code>：进栈，若栈 S 未满，则将 x 加入使之成为新栈顶。</li><li><code>Pop(&amp;S,&amp;x)</code>：出栈，若栈 S 非空，则弹出栈顶元素，并用 x 返回。</li><li><code>GetTop(S, &amp;x) </code>：读栈顶元素，若栈 S 非空，则用 x 返回栈项元素。</li><li><code>DestroyStack(&amp;S)</code>：销毁栈，并释放栈 S 占用的存储空间。</li></ul><h3 id="栈的顺序存储结构"><a class="header-anchor" href="#栈的顺序存储结构"></a>栈的顺序存储结构</h3><p>栈是一种操作受限的线性表，类似于线性表，它也有对应的两种存储方式。</p><h4 id="顺序栈的实现"><a class="header-anchor" href="#顺序栈的实现"></a>顺序栈的实现</h4><p>采用顺序存储的栈称为<font color="#ea66a6">顺序栈</font>，它利用一组地址连续的存储单元存放自栈底到栈顶的数据元素，同时附设一个指针（top）指示当前栈项元素的位置。栈的顺序存储类型可描述为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">&#125; SqStack;</span><br></pre></td></tr></table></figure><ul><li>栈顶指针：<code>S.top</code>，初始时设置 <code>S.top=-1</code>；</li><li>栈顶元素：<code>S.data[S.top]</code>；</li><li>进栈操作：栈不满时，栈顶指针先加1，再送值到栈顶元素。</li><li>出栈操作：栈非空时，先取栈顶元素值，再将栈项指针减 1。</li><li>栈空条件：<code>S.top==-1</code>；</li><li>栈满条件：<code>S.top==MaxSize-1</code></li><li>栈长：<code>S.top+1</code></li></ul><p>由于顺序栈的入栈操作受数组上界的约束，当对栈的最大使用空间估计不足时，有可能发生栈上溢，此时应及时向用户报告消息，以便及时处理，避免出错。</p><h4 id="顺序栈的基本运算"><a class="header-anchor" href="#顺序栈的基本运算"></a>顺序栈的基本运算</h4><p>初始化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    S.top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断栈空：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StackEmpty</span><span class="params">(SqStack S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进栈：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(SqStack &amp;S,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == MaxSize<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    S.data[++S.top] = x;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当找不满时， top 先加 1，再入栈。</p><p>出栈：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S,<span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    X = S.data[S.top--];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取栈顶元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S,<span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    X = S.data[S.top];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：这里 top 指向的是栈顶元素，所以进栈操作为 <code>S.data[++S.top]=x</code>，出栈操作为<code>x=S.data[S.top--]</code>。</p><p>若栈顶指针初始化为 <code>S.top=0</code>，即 top 指向栈顶元素的下一位置，则入栈操作变为<code>S.data[S.top++]=x</code>; 出栈操作变为 <code>x=S.data[--S.top]</code>。 相应的栈空、栈满条件也会发生变化。</p></blockquote><h4 id="共享栈"><a class="header-anchor" href="#共享栈"></a>共享栈</h4><p>利用栈底位置相对不变的特性，可让两个顺序栈共享一个维数组空间，将两个栈的栈底分<br>别设置在共享空间的<font color="#faa755">两端</font>，两个栈顶向共享空间的中间延伸。</p><p>两个栈的栈顶指针都指向栈顶元素，<code>top0=-1</code>时0号栈为空，<code>top1=MaxSize</code> 时1号栈为<br>空；仅当两个栈顶指针相邻（<code>top1-top0=1</code>） 时，判断为栈满。当0号栈进栈时 top0 先加1<br>再赋值，1号栈进栈时 top1 先减1再赋值；出栈时则刚好相反。</p><p>共享栈是为了更有效地利用存储空间，两个栈的空间相互调节，只有在整个存储空间被占满<br>时才发生溢。其存取数据的时间复杂度均为$O(1)$，所以对存取效率没有什么影响。</p><h3 id="栈的链式存储结构"><a class="header-anchor" href="#栈的链式存储结构"></a>栈的链式存储结构</h3><p>采用链式存储的栈称为链栈，链栈的优点是便于多个栈共享存储空间和提高其效率，且不存在栈满上溢的情况。通常采用单链表实现，并规定所有操作都是在单链表的表头进行的。拢的链式存储类型可描述为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; *LiStack;</span><br></pre></td></tr></table></figure><p>采用链式存储，便于结点的插入与删除。链栈的操作与链表类似，入栈和出栈的操作都在链表的表头进行。需要注意的是，对于带头结点和不带头结点的链栈，具体的实现会有所不同。</p><h2 id="队列"><a class="header-anchor" href="#队列"></a>队列</h2><h3 id="队列的基本概念"><a class="header-anchor" href="#队列的基本概念"></a>队列的基本概念</h3><h4 id="队列的定义"><a class="header-anchor" href="#队列的定义"></a>队列的定义</h4><p>队列（Queue）简称队，也是一种操作受限的线性表，只允许在表的一端进行插入，而在表的另一端进行删除。向队列中插入元素称为入队或进队；删除元素称为出队或离队。这和我们日常生活中的排队是一致的，最早排队的也是最早离队的，其操作的特性是先进先出（First In First Out，FIFO）。</p><ul><li>队头（Front）：允许删除的一端，又称队首。</li><li>队尾（Rear）：允许插入的一端。</li><li>空队列：不含任何元素的空表。</li></ul><h4 id="队列常见的基本操作"><a class="header-anchor" href="#队列常见的基本操作"></a>队列常见的基本操作</h4><ul><li><code>InitQueue(&amp;Q)</code>：初始化队列，构造一个空队列 Q。</li><li><code>QueueEmpty(Q)</code>：判队列空，若队列 Q 为空返回 true，否则返回 false。</li><li><code>EnQueue(&amp;Q,x)</code>：入队，若队列 Q 未满，将 x 加入，使之成为新的队尾。</li><li><code>DeQueue (&amp;Q, &amp;X)</code>：出队，若队列 Q 非空，删除队头元素，并用 x 返回。</li><li><code>GetHead(Q,&amp;x)</code>：读队头元素，若队列 Q 非空，则将队头元素赋值给 x。</li></ul><h3 id="队列的顺序存储结构"><a class="header-anchor" href="#队列的顺序存储结构"></a>队列的顺序存储结构</h3><h4 id="队列的顺序存储"><a class="header-anchor" href="#队列的顺序存储"></a>队列的顺序存储</h4><p>队列的顺序实现是指分配一块连续的存储单元存放队列中的元素，并附设两个指针：队头指<br>针 front 指向队头元素，队尾指针 rear 指向队尾元素的下一个位置（不同教材对 front 和 rear 的定义可能不同，例如，可以让 rear 指向队尾元素、front 指向队头元素。对于不同的定义，出队入队的操作是不同的）。队列的顺序存储类型可描述为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> front,rear;</span><br><span class="line">&#125; SqQueue;</span><br></pre></td></tr></table></figure><ul><li>初始状态（队空条件）：<code>Q.front==Q.rear==0</code>。</li><li>进队操作：队不满时，先送值到队尾元素，再将队尾指针加 1。</li><li>出队操作：队不空时，先取队头元素值，再将队头指针加 1。</li></ul><p>这样的顺序存储只能进行一次的排满队和出队的操作。</p><h4 id="循环队列"><a class="header-anchor" href="#循环队列"></a>循环队列</h4><p>这里引出循环队列的概念将顺序队列臆造为一个环状的空间，即把存储队列元素的表从逻辑上视为一个环，称为循环队列。当队首指针 <code>Q. front=MaxSize-1</code> 后，再前进一个位置就自动到 0，这可以利用除法取余运算来实现。</p><ul><li>初始时：<code>Q.front=Q.rear=0</code></li><li>队首指针进1：<code>Q.front=(Q.front+1)%MaxSize</code></li><li>队尾指针进1：<code>Q.rear=(Q.rear+1)%MaxSize</code></li><li>队列长度：<code>(Q.rear+MaxSize-Q.front)%MaxSize</code></li></ul><p>为了区分队空还是 队满的情况，有3种处理方式：</p><ol><li>牺牲一个单元来区分队空和队满，入队时少用一个队列单元，这是较为普遍的做法约定以“队头指针在队尾指针的下一位置作为队满的标志”。<ul><li>队满条件：<code>(Q.rear+1)%MaxSize==Q.front</code></li><li>队空条件：<code>Q.front==Q.rear</code></li><li>队中元素个数：<code>(Q.rear-Q.front+MaxSize)%MaxSize</code></li></ul></li><li>类型中增设表示元素个数的数据成员。这样，队空的条件为<code>Q.size==0</code>；队满的条件为   <code>Q.size==MaxSize</code>。这两种情况都有<code>Q.front==Q.rear</code>。</li><li>类型中增设 tag 数据成员，以区分是队满还是队空。每次删除操作成功，都令<code>tag=0</code>；每次插入操作成功时，都令<code>tag=1</code>。<ul><li>tag 等于 0 时，若因删除导致<code>Q.front==Q.rear</code>，则为队空；</li><li>tag 等于 1 时，若因插入导致<code>Q.front==Q.rear</code>，则为队满。</li></ul></li></ol><h4 id="循环队列的操作"><a class="header-anchor" href="#循环队列的操作"></a>循环队列的操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QueueEmpty</span><span class="params">(SqQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear==Q.front)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q.rear+<span class="number">1</span>)%MaxSize==Q.front)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Q.data[Q.rear]=x;</span><br><span class="line">    Q.rear=(Q.rear+<span class="number">1</span>)%MaxSize;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(SqQueue &amp;Q,<span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear==Q.front)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    Q.front = (Q.front+<span class="number">1</span>)%MaxSize;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得队头值</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetHeaf</span><span class="params">(SqQueue &amp;Q,<span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear==Q.front)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列的链式存储结构"><a class="header-anchor" href="#队列的链式存储结构"></a>队列的链式存储结构</h3><h4 id="队列的链式存储"><a class="header-anchor" href="#队列的链式存储"></a>队列的链式存储</h4><p>队列的链式表示称为链队列，它实际上是一个同时带有队头指针和队尾指针的单链表。头指针指向队头结点，尾指针指向队尾结点，即单链表的最后一个结点（注意与顺序存储的不同）。队列的链式存储类型可以描述为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span>  <span class="comment">// 链式队列结点</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>  <span class="comment">// 链式队列</span></span><br><span class="line">    LinkNode *front,*rear;</span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化（带头结点）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 初始时 front、rear 都指向头节点</span></span><br><span class="line">    Q.front = Q.rear = (LinkNode*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(LinkNode));</span><br><span class="line">    Q.front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">(LinkQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    LinkNode *s = (LinkNode *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(LinkNode));</span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Q.rear-&gt;next = s;</span><br><span class="line">    Q.rear = s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化（不带头结点）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    Q.front = <span class="literal">NULL</span>;</span><br><span class="line">    Q.rear = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">(LinkQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    LinkNode *s = (LinkNode *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(LinkNode));</span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        Q.front = s;</span><br><span class="line">        Q.rear = s;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Q.rear-&gt;next = s;</span><br><span class="line">        Q.rear = s</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">描述。</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>数据结构——线性表</title>
    <link href="http://halo123.top/2021/04/27/DataStructure/B_LinearList/"/>
    <id>http://halo123.top/2021/04/27/DataStructure/B_LinearList/</id>
    <published>2021-04-27T09:02:51.000Z</published>
    <updated>2021-04-27T09:02:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>【考纲内容】</p><ul><li>线性表的定义和基本操作</li><li>线性表的实现（顺序储存；链式储存；线性表的应用）</li></ul><p>【知识框架】</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-mind-map-a@master/DataStructure/%E7%BA%BF%E6%80%A7%E8%A1%A8.svg" alt="线性表"></p><p>【复习提示】</p><p>线性表是考研命题的重点。这类算法题实现起来比较容易而且代码量较少，但却要求具有最优的性能（时间、空间复杂度），才能获得满分。因此，应牢固掌握线性表的各种基本操作（基于两种存储结构），在平时的学习中多注重培养动手能力。另外，需要提醒的是，算法最重要的是思想！考场上的时间有限，在试卷上不一定要求代码具有实际的可执行性，因此应尽力表达出算法的思想和步骤，而不必过于拘泥每个细节。注意算法题只能用C/C++语言实现。</p><h2 id="线性表的定义和基本操作"><a class="header-anchor" href="#线性表的定义和基本操作"></a>线性表的定义和基本操作</h2><h3 id="线性表的定义"><a class="header-anchor" href="#线性表的定义"></a>线性表的定义</h3><p><font color="#ea66a6">线性表</font>是具有相同数据类型的 $n (n≥0)$ 个数据元素的有限序列，其中 $n$ 为表长，当 $n=0$ 时线性表是一个空表。若用 $L$ 命名线性表，则其一般表示为：$$L=(a_1,a_2,\cdots ,a_i,a_{i+1},\cdots ,a_n)$$ 式中，$a_1$ 是唯一的“第一个”数据元素，又称表头元素；$a_n$ 是唯一的“最后一个”数据元素，又称表尾元素。</p><ul><li>除第一个元素外，每个元素有且仅有一个直接前驱。</li><li>除最后一个元素外，每个元素有且仅有一个直接后继。</li></ul><p>以上就是线性表的逻辑特性，这种线性有序的逻辑结构正是线性表名字的由来。线性表的特点如下：</p><ul><li>表中元素的个数有限</li><li>表中元素具有逻辑上的顺序性，表中元素有其先后次序</li><li>表中元素都是<a href="https://halo123.top/2021/04/27/DataStructure/A_Introduction/#%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0">数据元素</a>，每个元素都是单个元素</li><li>表中元素的数据类型都相同，这意味着每个元素占有相同大小的存储空间</li><li>表中元素具有抽象性，即仅讨论元素间的逻辑关系，而不考虑元素究竟表示什么内容。</li></ul><div class="note danger no-icon flat"><p>注意：线性表是一种逻辑结构，表示元素之间一对一的相邻关系。顺序表和链表是指存储结构，两者属于不同层面的概念，因此不要将其混淆。</p></div><h3 id="线性表的基本操作"><a class="header-anchor" href="#线性表的基本操作"></a>线性表的基本操作</h3><p>一个数据结构的基本操作是指其最核心、最基本的操作。其他较复杂的操作可通过调用其基本操作来实现。线性表的主要操作如下：</p><ul><li><code>InitList(&amp;L)</code>：初始化表。构造一个空的线性表。</li><li><code>Length(L)</code>：求表长。返回线性表 L 的长度，即 L 中数据元素的个数。</li><li><code>LocateElem(L,e)</code>：按值查找操作。在表 L 中查找具有给定关键字值的元素。</li><li><code>GetElem(L,i)</code>：按位查找操作。获取表 L 中第 i 个位置的元素的值。</li><li><code>ListInsert(&amp;L,i,e)</code>：插入操作。在表 L 中的第 i 个位置上插入指定元素 e 。</li><li><code>ListDelete(&amp;L,i,&amp;e)</code>：删除操作。删除表 L 中第 i 个位置的元素，并用 e 返回删除元素的值。</li><li><code>PrintList(L)</code>：输出操作。按前后顺序输出线性表 L 的所有元素值。</li><li><code>Empty(L)</code>：判空操作。若 L 为空表，则返回 true，否则返回 false。</li><li><code>DestroyList(&amp;L)</code>：销毁操作。销毁线性表，并释放线性表 L 所占用的内存空间。</li></ul><h2 id="线性表的顺序表示"><a class="header-anchor" href="#线性表的顺序表示"></a>线性表的顺序表示</h2><h3 id="顺序表的定义"><a class="header-anchor" href="#顺序表的定义"></a>顺序表的定义</h3><p>线性表的顺序存储又称<font color="#ea66a6">顺序表</font>。它是用一组地址连续的存储单元依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。第1个元素存储在线性表的起始位置，第 $i$ 个元素的存储位置后面紧接着存储的是第 $i+1$ 个元素，称 $i$ 为元素 $a_i$ 在线性表中的位序。因此，顺序表的特点是表中元素的<wavy>逻辑顺序与其物理顺序相同</wavy>。</p><p>假设线性表 L 储存的起始位置为 <code>LOC(A)</code>，<code>sizeof(ElemType)</code> 是每个数据元素所占用储存空间的大小，则表 L 所对应的顺序存储如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt="线性表的顺序存储结构"></p><blockquote><p>注意：线性表中元素的位序是从 1 开始的，而数组中元素的下标是从 0 开始的。</p></blockquote><h3 id="顺序表的实现方式"><a class="header-anchor" href="#顺序表的实现方式"></a>顺序表的实现方式</h3><h4 id="静态分配"><a class="header-anchor" href="#静态分配"></a>静态分配</h4><p>假定线性表的元素类型为 <code>ElemType</code>（以下具体操作使用<code>int</code>类型），则线性表的顺序存储类型描述为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10             <span class="comment">// 定义线性表的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];    <span class="comment">// 顺序表的元素</span></span><br><span class="line">    <span class="keyword">int</span> length;                <span class="comment">// 顺序表的当前长度</span></span><br><span class="line">&#125; StaticSqList;                <span class="comment">// 顺序表的类型定义 Sq:sequence</span></span><br></pre></td></tr></table></figure><p>一维数组可以是静态分配的，也可以是动态分配的。在静态分配时，由于数组的大小和空间事先已经固定，一旦空间占满，再加入新的数据将会产生溢出，进而导致程序崩溃。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一个顺序表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(StaticSqList &amp;L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Maxsize; i++) &#123;</span><br><span class="line">        L.data[i] = <span class="number">0</span>;  <span class="comment">// 将所有数据元素设置默认值(可省略)</span></span><br><span class="line">    &#125;</span><br><span class="line">    L.length = <span class="number">0</span>;       <span class="comment">// 顺序表初始长度为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    StaticSqList L;     <span class="comment">// 声明一个顺序表</span></span><br><span class="line">    <span class="built_in">InitList</span>(L);        <span class="comment">// 初始化顺序表</span></span><br><span class="line">    <span class="comment">// ...  相关操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动态分配"><a class="header-anchor" href="#动态分配"></a>动态分配</h4><p>而在动态分配时，存储数组的空间是在程序执行过程中通过动态存储分配语句分配的，一旦数据空间占满，就另外开辟一块更大的存储空间，用以替换原来的存储空间，从而达到扩充存储数组空间的目的，而不需要为线性表一次性地划分所有空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InitSize 10           <span class="comment">// 表长度的初始定义</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType *data;           <span class="comment">// 指示动态分配数组的指针</span></span><br><span class="line">    <span class="keyword">int</span> MaxSize,length;       <span class="comment">// 数组的最大容量和当前个数</span></span><br><span class="line">&#125; DynamicSqList;              <span class="comment">// 动态分配数组顺序表的类型定义 </span></span><br></pre></td></tr></table></figure><p>C 的初始动态分配语句为：<code>L.data = (ElemType*)malloc(sizeof(ElemType) * InitSize);</code></p><p>C++ 的初始动态分配语句为：<code>L.data = new ElemType[InitSize];</code></p><blockquote><p>注意：动态分配并不是链式存储，它同样属于顺序存储结构，物理结构没有变化，依然是随机存取方式，只是分配的空间大小可以在运行时决定。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(DynamicSqList &amp;L)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用malloc函数申请一片连续的储存空间</span></span><br><span class="line">    L.data = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>(InitSize * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line">    L.MaxSize = InitSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态增加数组的长度</span></span><br><span class="line"><span class="comment"> * @param L 顺序表</span></span><br><span class="line"><span class="comment"> * @param len 在原基础上扩展的大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IncreaseSize</span><span class="params">(DynamicSqList &amp;L, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = L.data;</span><br><span class="line">    L.data = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>((L.MaxSize + len) * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; i++) &#123;     <span class="comment">// 将数据复制到新区域</span></span><br><span class="line">        L.data[i] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    L.MaxSize += len;    <span class="comment">// 增加顺序表的最大长度</span></span><br><span class="line">    <span class="built_in">free</span>(p);             <span class="comment">// 释放原来的内存空间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    DynamicSqList L;     <span class="comment">// 声明一个顺序表</span></span><br><span class="line">    <span class="built_in">InitList</span>(L);         <span class="comment">// 初始化顺序表</span></span><br><span class="line">    <span class="comment">// ... 插入操作</span></span><br><span class="line">    <span class="built_in">IncreaseSize</span>(L,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="顺序表的特点"><a class="header-anchor" href="#顺序表的特点"></a>顺序表的特点</h3><ul><li>随机访问，即通过首地址和元素序号可在时间 $O(1)$ 内找到指定的元素。</li><li>存储密度高，每个结点只存储数据元素。</li><li>拓展容量不方便（即便采用动态分配的方式实现，拓展长度的时间复杂度也比较高）</li><li>插入、删除操作不方便，逻辑上相邻的元素物理上也相邻，所以插入和删除操作需要移动大量元素。</li></ul><h3 id="顺序表上基本操作的实现"><a class="header-anchor" href="#顺序表上基本操作的实现"></a>顺序表上基本操作的实现</h3><h4 id="插入操作"><a class="header-anchor" href="#插入操作"></a>插入操作</h4><p>在顺序表 L 的第 i（1≤i≤<code>L.length+1</code>）个位置插入新元素 e。</p><ul><li>若 i 的输入不合法，则返回 false，表示插入失败；</li><li>否则，将顺序表的第 i 个元素及其后的所有元素右移一个位置，腾出一个空位置插入新元素 element，顺序表长度增加 1，插入成功，返回 true。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入操作</span></span><br><span class="line"><span class="comment"> * @param L 顺序表</span></span><br><span class="line"><span class="comment"> * @param i 位置</span></span><br><span class="line"><span class="comment"> * @param element 要插入的元素</span></span><br><span class="line"><span class="comment"> * @return 插入成功true,失败false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(StaticSqList &amp;L, <span class="keyword">int</span> i, <span class="keyword">int</span> element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断i的范围是否有效</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 储存已满不能插入</span></span><br><span class="line">    <span class="keyword">if</span> (L.length &gt;= Maxsize) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将第i个元素及之后的元素后移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = L.length; j &gt;= i; j--) &#123;</span><br><span class="line">        L.data[j] = L.data[j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在位置 i 处放入e</span></span><br><span class="line">    L.data[i - <span class="number">1</span>] = element;</span><br><span class="line">    <span class="comment">// 线性表长度加1</span></span><br><span class="line">    L.length++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最好情况：在表尾插入（即 $i = n+1$ ）,元素后移语句不执行，时间复杂度为 $O(1)$。</li><li>最坏情况：在表头插入（即 $i = 1$）,元素后移语句将执行 $n$ 次，时间复杂度为 $O(n)$。</li><li>平均情况：假设 $p_i \ (p_i=\frac{1}{n+1} )$ 是在第 $i$ 个位置上插入一个结点的概率，则在长度为 $n$ 的线性表中插入一个结点时，所需移动结点的平均次数为：</li></ul><p>$$\sum_{i=1}^{n+1}p_{i}\left(n-i+1\right) = \sum_{i=1}^{n+1}\frac{1}{n+1}\left(n-i+1\right) = \frac{1}{n+1}\sum_{i=1}^{n+1}\left(n-i+1\right) = \frac{1}{n+1}\frac{n\left(n+1\right)}{2}=\frac{n}{2}$$ 因此，线性表插入算法的平均时间复杂度为 $O(n)$。</p><h4 id="删除操作"><a class="header-anchor" href="#删除操作"></a>删除操作</h4><p>删除顺序表 L 中第 i（1≤i≤<code>L.length+1</code>）个位置的元素，若成功则返回 true，并将被删除的元素用引用变量 element 返回，否则返回 false。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除操作</span></span><br><span class="line"><span class="comment"> * @param L</span></span><br><span class="line"><span class="comment"> * @param i</span></span><br><span class="line"><span class="comment"> * @param element</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListDelete</span><span class="params">(StaticSqList &amp;L, <span class="keyword">int</span> i, <span class="keyword">int</span> &amp;element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断i的范围是否有效</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将被删除的元素赋值给element</span></span><br><span class="line">    element = L.data[i - <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 将第i个位置后的元素前移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; L.length; j++) &#123;</span><br><span class="line">        L.data[j - <span class="number">1</span>] = L.data[j];</span><br><span class="line">    &#125;</span><br><span class="line">    L.length--;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最好情况：删除表尾元素（即 $i = n$ ），无须移动元素，时间复杂度为 $O(1)$。</li><li>最坏情况：删除表头元素（即 $i = 1$），需移动除第一个元素外的所有元素，时间复杂度为 $O(n)$。</li><li>平均情况：假设 $p_i \ (p_i=\frac {1}{n} )$ 是删除第 $i$ 个位置上结点的概率，则在长度为 $n$ 的线性表中删除一个结点时，所需移动结点的平均次数为：</li></ul><p>$$\sum_{i=1}^{n}p_{i}\left(n-i\right) = \sum_{i=1}^{n}\frac{1}{n}\left(n-i\right) = \frac{1}{n}\sum_{i=1}^{n}\left(n-i\right) = \frac{1}{n}\frac{n\left(n-1\right)}{2}=\frac{n-1}{2}$$ 因此，线性表删除算法的平均时间复杂度为 $O(n)$。</p><h4 id="按位查找"><a class="header-anchor" href="#按位查找"></a>按位查找</h4><p>在顺序表 L 中，获取第 i 个位置的元素的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按位查找</span></span><br><span class="line"><span class="comment"> * @param L</span></span><br><span class="line"><span class="comment"> * @param i</span></span><br><span class="line"><span class="comment"> * @return 第i个位置的元素的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetElem</span><span class="params">(StaticSqList L, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> L.data[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(1)$</p><h4 id="按值查找"><a class="header-anchor" href="#按值查找"></a>按值查找</h4><p>在顺序表 L 中查找第一个元素值等于 element 的元素，并返回其位序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按值查找</span></span><br><span class="line"><span class="comment"> * @param L</span></span><br><span class="line"><span class="comment"> * @param element 需要查找的元素值</span></span><br><span class="line"><span class="comment"> * @return 查找到则返回位序(索引+1)，否则返回0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem</span><span class="params">(StaticSqList L, <span class="keyword">int</span> element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L.data[i] == element) &#123;</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>; <span class="comment">// 下标为 i 的元素值等于 element,返回其位序 i+1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最好情况：查找的元素就在表头，仅需比较一次，时间复杂度为 $O(1)$。</li><li>最坏情况：查找的元素在表尾（或不存在）时，需要比较 $n$ 次，时间复杂度为 $O(n)$。</li><li>平均情况：假设 $p_i \ (p_i=\frac {1}{n})$ 是查找的元素在第 i （1≤i≤L. length）个位置上的概率，则在长度为 $n$ 的线性表中查找值为 e 的元素所需比较的平均次数为：</li></ul><p>$$\sum_{i=1}^{n}p_{i}\times i = \sum_{i=1}^{n}\frac{1}{n}\times i  =  \frac{1}{n}\frac{n\left(n+1\right)}{2}=\frac{n+1}{2}$$ 因此，线性表按值查找算法的平均时间复杂度为$O(n)$。</p><h2 id="线性表的链式表示"><a class="header-anchor" href="#线性表的链式表示"></a>线性表的链式表示</h2><p>顺序表可以随时存取表中的任意一个元素，它的存储位置可以用一个简单直观的公式表示，但插入和删除操作需要移动大量元素。链式存储线性表时，不需要使用地址连续的存储单元，即不要求逻辑上相邻的元素在物理位置上也相邻，它通过“链”建立起数据元素之间的逻辑关系，因此插入和删除操作不需要移动元素，而只需修改指针，但也会失去顺序表可随机存取的优点。</p><h3 id="单链表的定义"><a class="header-anchor" href="#单链表的定义"></a>单链表的定义</h3><p>线性表的链式存储又称<font color="#ea66a6">单链表</font>，它是指通过一组任意的存储单元来存储线性表中的数据元素。为了建立数据元素之间的线性关系，对每个链表结点，除存放元素自身的信息外，还需要存放一个指向其后继的指针。单链表中结点类型的描述如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;             <span class="comment">// 每个结点存放的一个数据元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span>   <span class="comment">// 指针指向下一个结点</span></span><br><span class="line">&#125; LNode, *LinkList;</span><br></pre></td></tr></table></figure><ul><li><code>data</code>为数据域，存放数据元素;</li><li><code>next</code>为指针域，存放其后继结点的地址。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化不带头结点的空单链表函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    L = <span class="literal">NULL</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用单链表可以解决顺序表需要大量连续存储单元的缺点，但单链表附加指针域，也存在浪费存储空间的缺点。由于单链表的元素离散地分布在存储空间中，所以单链表是非随机存取的存储结构，即不能直接找到表中某个特定的结点。查找某个特定的结点时，需要从表头开始遍历，依次查找。</p><p>通常用头指针来标识一个单链表，如单链表 L，头指针为 NULL 时表示一个空表。此外，为了操作上的方便，在单链表第一个结点之前附加一个结点， 称为<font color="#ea66a6">头结点</font>。头结点的数据域可以不设任何信息，也可以记录表长等信息。头结点的指针域指向线性表的第一个元素结点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化带头结点的空单链表函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    L = (LNode *) <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(LNode)); <span class="comment">// 分配一个头结点</span></span><br><span class="line">    <span class="keyword">if</span>(L == <span class="literal">NULL</span>)&#123; <span class="comment">// 内存不足，分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 头结点之后暂时还没有结点 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>头结点和头指针的区分：不管带不带头结点，头指针始终指向链表的第一个结点， 而头结点是带头结点的链表中的第一个结点，结点内通常不存储信息。</p><p>引入头结点后，可以带来两个优点：</p><ol><li>由于第一个数据结点的位置被存放在头结点的指针域中，所以在链表的第一个位置上的操作和在表的其他位置上的操作一致，无须进行特殊处理。</li><li>无论链表是否为空，其头指针都指向头结点的非空指针（空表中头结点的指针域为空），因此空表和非空表的处理也就得到了统一。</li></ol><h3 id="单链表上基本操作的实现"><a class="header-anchor" href="#单链表上基本操作的实现"></a>单链表上基本操作的实现</h3><h4 id="按位序插入（带头结点）"><a class="header-anchor" href="#按位序插入（带头结点）"></a>按位序插入（带头结点）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按位序插入（带头结点）</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到第i-1个结点 GetElem</span></span><br><span class="line">    LNode *p;   <span class="comment">// 指针p指向当前扫描到的结点</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;  <span class="comment">// 当前p指向的是第几个结点</span></span><br><span class="line">    p = L;      <span class="comment">// L指向头结点，头结点是第0个结点</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span> &amp;&amp; j &lt; i - <span class="number">1</span>) &#123;  <span class="comment">// 循环找到第 i-1 个结点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) &#123;  <span class="comment">// i值不合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将e插入到i-1结点之后 InsertNextNode</span></span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(LNode));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;  <span class="comment">// 将结点s连接到p之后</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最好情况：插入的元素就在表头，时间复杂度为 $O(1)$。</li><li>最坏情况：插入的元素在表尾时，时间复杂度为 $O(n)$。</li><li>平均时间复杂度： $O(n)$。</li></ul><h4 id="按位序插入（不带头结点）"><a class="header-anchor" href="#按位序插入（不带头结点）"></a>按位序插入（不带头结点）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按位序插入（不带头结点）</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;  <span class="comment">// 插入第1个结点操作与其他结点操作不同</span></span><br><span class="line">        LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(LNode));</span><br><span class="line">        s-&gt;data = e;</span><br><span class="line">        s-&gt;next = L;</span><br><span class="line">        L = s;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LNode *p;   <span class="comment">// 指针p指向当前扫描到的结点</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;  <span class="comment">// 当前p指向的是第几个结点</span></span><br><span class="line">    p = L;      <span class="comment">// L指向头结点，头结点是第0个结点</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span> &amp;&amp; j &lt; i - <span class="number">1</span>) &#123;  <span class="comment">// 循环找到第 i-1 个结点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) &#123;  <span class="comment">// i值不合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(LNode));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;  <span class="comment">// 将结点s连接到p之后</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="指定结点的后插操作"><a class="header-anchor" href="#指定结点的后插操作"></a>指定结点的后插操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后插操作：在p结点之后插入元素e</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertNextNode</span><span class="params">(LNode *p, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(LNode));</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">nullptr</span>) &#123;  <span class="comment">// 内存分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;data = e; </span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(1)$。</p><h4 id="指定结点的前插操作"><a class="header-anchor" href="#指定结点的前插操作"></a>指定结点的前插操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前插操作</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertPriorNode</span><span class="params">(LNode *p, <span class="keyword">int</span> element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> *s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(LNode));</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;        <span class="comment">// 新结点s连到p之后 ⭐</span></span><br><span class="line">    s-&gt;data = p-&gt;data;  <span class="comment">// 将p中元素覆盖到s中 </span></span><br><span class="line">    p-&gt;data = element;  <span class="comment">// p中元素覆盖为e</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>指针后插，数据交换。</p></blockquote><p>时间复杂度：$O(1)$。</p><h4 id="按位序删除（带头结点）"><a class="header-anchor" href="#按位序删除（带头结点）"></a>按位序删除（带头结点）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按位序删除</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListDelete</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i, <span class="keyword">int</span> &amp;e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找</span></span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span> &amp;&amp; j &lt; i - <span class="number">1</span>) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span> || p-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    LNode *q = p-&gt;next;  <span class="comment">// 使q指向被删除的结点</span></span><br><span class="line">    e = q-&gt;data;         <span class="comment">// 用e返回元素的值</span></span><br><span class="line">    p-&gt;next = q-&gt;next;   <span class="comment">// 将*q结点从链中断开</span></span><br><span class="line">    <span class="built_in">free</span>(q);             <span class="comment">// 释放结点储存空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最好情况：删除的元素就在表头，时间复杂度为 $O(1)$。</li><li>最坏情况：删除的元素在表尾时，时间复杂度为 $O(n)$。</li><li>平均时间复杂度： $O(n)$。</li></ul><h4 id="删除指定结点"><a class="header-anchor" href="#删除指定结点"></a>删除指定结点</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteNode</span><span class="params">(LNode *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *q = p-&gt;next;      <span class="comment">// 使q指向*p的后继结点</span></span><br><span class="line">    p-&gt;data = p-&gt;next-&gt;data; <span class="comment">// 和后继结点交换数据域</span></span><br><span class="line">    p-&gt;next = q-&gt;next;       <span class="comment">// 将*q结点从链中断开</span></span><br><span class="line">    <span class="built_in">free</span>(q);                 <span class="comment">// 释放后继结点的储存空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(1)$。</p><blockquote><p>注意：上段代码无法解决 p 结点时尾结点时的删除问题，删除尾结点需要从头开始查找</p></blockquote><h4 id="按位查找（带头结点）"><a class="header-anchor" href="#按位查找（带头结点）"></a>按位查找（带头结点）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按位查找，返回第i个元素</span></span><br><span class="line"><span class="function">LNode *<span class="title">GetElement</span><span class="params">(LinkList L, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span> &amp;&amp; j &lt; i) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最好情况：查找的元素就在表头，时间复杂度为 $O(1)$。</li><li>最坏情况：查找的元素在表尾时，时间复杂度为 $O(n)$。</li><li>平均时间复杂度： $O(n)$。</li></ul><h4 id="按值查找-v2"><a class="header-anchor" href="#按值查找-v2"></a>按值查找</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LNode *<span class="title">LocateElem</span><span class="params">(LinkList L, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    LNode *p = L-&gt;next;</span><br><span class="line">    <span class="comment">// 从第一个结点开始查找数据域为e的结点</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span> &amp;&amp; p-&gt;data != e) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最好情况：查找的元素就在表头，时间复杂度为 $O(1)$。</li><li>最坏情况：查找的元素在表尾（或不存在）时，时间复杂度为 $O(n)$。</li><li>平均时间复杂度： $O(n)$。</li></ul><h4 id="求单链表的长度"><a class="header-anchor" href="#求单链表的长度"></a>求单链表的长度</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求表的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    LNode *p = L;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(n)$。</p><h4 id="头插法建立单链表"><a class="header-anchor" href="#头插法建立单链表"></a>头插法建立单链表</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkList <span class="title">List_HeadInsert</span><span class="params">(LinkList &amp;L)</span> </span>&#123;</span><br><span class="line">    LNode *s;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(LNode));</span><br><span class="line">    L-&gt;next = <span class="literal">nullptr</span>;  <span class="comment">// 初始空链表</span></span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    <span class="keyword">while</span> (x &gt; <span class="number">9999</span>) &#123;  <span class="comment">// 输入值大于9999表示结束</span></span><br><span class="line">        s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(LNode));  <span class="comment">// 后插操作</span></span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        s-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = s;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>重要应用：链表逆置</p></blockquote><h4 id="尾插法建立单链表"><a class="header-anchor" href="#尾插法建立单链表"></a>尾插法建立单链表</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkList <span class="title">List_TailInsert</span><span class="params">(LinkList &amp;L)</span> </span>&#123;</span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(LNode)); <span class="comment">// 建立头结点</span></span><br><span class="line">    LNode *s, *r = L;  <span class="comment">// r指针为表尾指针</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    cin &gt;&gt; x;  <span class="comment">// 输入结点的数据</span></span><br><span class="line">    <span class="keyword">while</span> (x &gt; <span class="number">9999</span>) &#123;   <span class="comment">// 输入值大于9999表示结束</span></span><br><span class="line">        s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(LNode));</span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        r-&gt;next = s;</span><br><span class="line">        r = s;    <span class="comment">// r指向新的表尾结点</span></span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(n)$</p><h3 id="双链表"><a class="header-anchor" href="#双链表"></a>双链表</h3><p>单链表结点中只有一个指向其后继的指针，使得单链表只能从头结点依次顺序地向后遍历。要访问某个结点的前驱结点（插入、删除操作时），只能从头开始遍历，访问后继结点的时间复杂度为 $O(1)$ ，访问前驱结点的时间复杂度为 $O(n)$。</p><p>为了克服单链表的上述缺点，引入了双链表，双链表结点中有两个指针 prior 和 next，分别指向其前驱结点和后继结点，双链表中结点类型的描述如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;  <span class="comment">// 数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>, *<span class="title">next</span>;</span>  <span class="comment">// 前驱指针和后继指针</span></span><br><span class="line">&#125; DNode, *DLinklist;</span><br></pre></td></tr></table></figure><p>双链表在单链表的结点中增加了一个指向其前驱的 prior 指针，因此双链表中的按值查找和按位查找的操作与单链表的相同。但双链表在插入和删除操作的实现上，与单链表有着较大的不同。这是因为“链”变化时也需要对 prior 指针做出修改，其关键是保证在修改的过程中不断链。此外，双链表可以很方便地找到其前驱结点，因此，插入、删除操作的时间复杂度仅为 $O(1)$。</p><h4 id="双链表的插入"><a class="header-anchor" href="#双链表的插入"></a>双链表的插入</h4><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E5%8F%8C%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E7%BB%93%E7%82%B9%E8%BF%87%E7%A8%8B.png" alt="双链表插入结点过程"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InertNextDNode</span><span class="params">(DNode *p, DNode *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span> || s == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;next = p-&gt;next;  <span class="comment">// ① 将结点*s插入到结点*p之后</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        p-&gt;next-&gt;prior = s; <span class="comment">// ②</span></span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;prior = p; <span class="comment">// ③</span></span><br><span class="line">    p-&gt;next = s;  <span class="comment">// ④</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的语句顺序不是唯一的， 但也不是任意的，① 和 ② 两步必须在 ④ 步之前，否则 <code>*p</code> 的后继结点的指针就会丢掉，导致插入失败。</p><h4 id="双链表的删除"><a class="header-anchor" href="#双链表的删除"></a>双链表的删除</h4><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E5%8F%8C%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9%E8%BF%87%E7%A8%8B.png" alt="双链表删除结点过程"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 双链表的删除操作</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteNextDNode</span><span class="params">(DNode *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DNode *q = p-&gt;next;  <span class="comment">// 找到p的后继结点q</span></span><br><span class="line">    <span class="keyword">if</span> (q == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// p没有后继结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next = q-&gt;next; <span class="comment">// ①</span></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        q-&gt;next-&gt;prior = p; <span class="comment">// ②</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双链表的循环"><a class="header-anchor" href="#双链表的循环"></a>双链表的循环</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后向遍历</span></span><br><span class="line"><span class="keyword">while</span>(p != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">    <span class="comment">// 相关处理...</span></span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前向遍历</span></span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">    <span class="comment">// 相关处理...</span></span><br><span class="line">    p = p-&gt;prior;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前向变量（跳过头结点）</span></span><br><span class="line"><span class="keyword">while</span> (p-&gt;prior != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">    <span class="comment">// 相关处理...</span></span><br><span class="line">    p = p-&gt;prior;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双链表不可随机存取，按位查找、按值查找操作都只能用遍历的方式实现。时间复杂度 $O(n)$。</p><h3 id="循环链表"><a class="header-anchor" href="#循环链表"></a>循环链表</h3><h4 id="循环单链表"><a class="header-anchor" href="#循环单链表"></a>循环单链表</h4><p>循环单链表和单链表的区别在于，表中最后一个结点的指针不是NULL，而改为指向头结点，从而整个链表形成一个环。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;             <span class="comment">// 每个结点存放的一个数据元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span>   <span class="comment">// 指针指向下一个结点</span></span><br><span class="line">&#125; LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化带头结点的空单链表函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    L = (LNode *) <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(LNode)); <span class="comment">// 分配一个头结点</span></span><br><span class="line">    <span class="keyword">if</span>(L == <span class="literal">NULL</span>)&#123; <span class="comment">// 内存不足，分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;next = L; <span class="comment">// 头结点next指向头结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断循环单链表是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next == L)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断结点p是否为循环单链表的表尾结点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isTail</span><span class="params">(LinkList L,LNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next == L)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="循环双链表"><a class="header-anchor" href="#循环双链表"></a>循环双链表</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化空的循环双链表</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitDLinkList</span><span class="params">(Dlinklist &amp;L)</span></span>&#123;</span><br><span class="line">    L = (DNode *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(DNode));</span><br><span class="line">    <span class="keyword">if</span>(L == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;prior = L;</span><br><span class="line">    L-&gt;next = L;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断循环双链表是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">(DLinkList L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next == L)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断结点p是否为循环双链表的表尾结点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isTail</span><span class="params">(DLinkList L,DNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next == L)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态链表"><a class="header-anchor" href="#静态链表"></a>静态链表</h3><p>静态链表借助数组来描述线性表的链式存储结构，结点也有数据域 data 和指针域 next，与前面所讲的链表中的指针不同的是，这里的指针是结点的相对地址（数组下标），又称游标。和顺序表一样，静态链表也要预先分配一块连续的内存空间。</p><p>静态链表结构类型的描述如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10  <span class="comment">// 静态链表的最大长度</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span>       <span class="comment">// 静态链表结构类型的定义</span></span><br><span class="line">    <span class="keyword">int</span> data;       <span class="comment">// 存储数据元素</span></span><br><span class="line">    <span class="keyword">int</span> next;       <span class="comment">// 下一个元素的数组下标</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>静态链表以 <code>next==-1</code> 作为其结束的标志。静态链表的插入、删除操作与动态链表的相同，只需要修改指针，而不需要移动元素。总体来说，静态链表没有单链表使用起来方便，但在一些不支持指针的高级语言（如Basic）中，这是一种非常巧妙的设计方法。</p><p>王道书中对静态链表定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10  <span class="comment">// 静态链表的最大长度</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span>       <span class="comment">// 静态链表结构类型的定义</span></span><br><span class="line">    <span class="keyword">int</span> data;       <span class="comment">// 存储数据元素</span></span><br><span class="line">    <span class="keyword">int</span> next;       <span class="comment">// 下一个元素的数组下标</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125; SLinkList[MaxSize];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testSLinkList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">x</span>;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size x = %d\n&quot;</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(x)); <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">a</span>[<span class="title">MaxSize</span>];</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size a = %d\n&quot;</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(a)); <span class="comment">// 80</span></span><br><span class="line"></span><br><span class="line">    SLinkList b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size b = %d\n&quot;</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(b));  <span class="comment">// 80</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">testSLinkList</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：增、删操作不需要大量移动元素</p><p>缺点：不能随机存取，只能从头结点开始依次往后查找；容量固定不可变</p><p>适用场景：不支持指针的语言；数据元素量固定不变的场景（如操作系统的文件分配表FAT）</p><h2 id="顺序表和链表的比较"><a class="header-anchor" href="#顺序表和链表的比较"></a>顺序表和链表的比较</h2><h3 id="逻辑结构与物理结构"><a class="header-anchor" href="#逻辑结构与物理结构"></a>逻辑结构与物理结构</h3><ul><li><p>采用顺序存储时，逻辑上相邻的元素，对应的物理存储位置也相邻。</p></li><li><p>采用链式存储时，逻辑上相邻的元素，物理存储位置则不一定相邻，对应的逻辑关系是通过指针链接来表示的。</p></li></ul><h3 id="存取（读写）方式"><a class="header-anchor" href="#存取（读写）方式"></a>存取（读写）方式</h3><p>顺序表可以顺序存取，也可以随机存取，链表只能从表头顺序存取元素。</p><p>例如在第 $i$ 个位置上执行存或取的操作，顺序表仅需一次访问，而链表则需从表头开始依次访问 $i$ 次。</p><h3 id="查找、插入和删除操作"><a class="header-anchor" href="#查找、插入和删除操作"></a>查找、插入和删除操作</h3><p>对于按值查找，顺序表无序时，两者的时间复杂度均为 $O(n)$ ；顺序表有序时，可采用折半查找，此时的时间复杂度为 $O(log_2n)$ 。</p><p>对于按序号查找，顺序表支持随机访问，时间复杂度仅为 $O(1)$ ，而链表的平均时间复杂度为 $O(n)$ 。</p><p>顺序表的插入、删除操作，平均需要移动半个表长的元素。链表的插入、删除操作，只需修改相关结点的指针域即可。</p><p>由于链表的每个结点都带有指针域，故而存储密度不够大。</p><h3 id="空间分配"><a class="header-anchor" href="#空间分配"></a>空间分配</h3><p>顺序存储在静态存储分配情形下，一旦存储空间装满就不能扩充，若再加入新元素，则会出<br>现内存溢出，因此需要预先分配足够大的存储空间。</p><p>预先分配过大，可能会导致顺序表后部大量闲置；预先分配过小，又会造成溢出。动态存储分配虽然存储空间可以扩充，但需要移动大量元素，导致操作效率降低，而且若内存中没有更大块的连续存储空间，则会导致分配失败。</p><p>链式存储的结点空间只在需要时申请分配，只要内存有空间就可以分配，操作灵活、高效。</p><h3 id="实际中选取存储结构"><a class="header-anchor" href="#实际中选取存储结构"></a>实际中选取存储结构</h3><h4 id="基于存储的考虑"><a class="header-anchor" href="#基于存储的考虑"></a>基于存储的考虑</h4><p>难以估计线性表的长度或存储规模时，不宜采用顺序表;链表不用事先估计存储规模，但链表的存储密度较低，显然链式存储结构的存储密度是小于 1 的。</p><h4 id="基于运算的考虑"><a class="header-anchor" href="#基于运算的考虑"></a>基于运算的考虑</h4><p>在顺序表中按序号访问 $a_1$ 的时间复杂度为 $O(1)$ ，而链表中按序号访问的时间复杂度为 $O(n)$，因此若经常做的运算是按序号访问数据元素，则显然顺序表优于链表。</p><p>在顺序表中进行插入、删除操作时，平均移动表中一半的元素，当数据元素的信息量较大且<br>表较长时，这一点是不应忽视的；在链表中进行插入、删除操作时，虽然也要找插入位置，但操作主要是比较操作，从这个角度考虑显然后者优于前者。</p><h3 id="基于环境的考虑"><a class="header-anchor" href="#基于环境的考虑"></a>基于环境的考虑</h3><p>顺序表容易实现，任何高级语言中都有数组类型；链表的操作是基于指针的，相对来讲，前者实现较为简单，这也是用户考虑的一个因素。</p><p>总之，两种存储结构各有长短，选择哪一种由实际问题的主要因素决定。通常较稳定的线性表选择顺序存储，而频繁进行插入、删除操作的线性表（即动态性较强）宜选择链式存储。</p>]]></content>
    
    
    <summary type="html">线性表是考研命题的重点。</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>数据结构——绪论</title>
    <link href="http://halo123.top/2021/04/27/DataStructure/A_Introduction/"/>
    <id>http://halo123.top/2021/04/27/DataStructure/A_Introduction/</id>
    <published>2021-04-27T05:57:51.000Z</published>
    <updated>2021-04-27T05:57:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考资料：《王道2021年数据结构》、《王道2022年数据结构》</p><p>考纲内容：</p><ul><li>数据结构相关的概念和术语</li><li>数据结构的三要素：逻辑结构、物理结构和数据运算</li><li>算法时间复杂度和空间复杂度的分析与计算</li></ul><p>知识框架【<a href="http://naotu.baidu.com/file/31bf2da9f8174f5094142a42bc93407d?token=ac53487f0f7b5d19">百度脑图链接</a>】：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-mind-map-a@master/DataStructure/%E7%BB%AA%E8%AE%BA.svg" alt="绪论"></p><h2 id="数据结构的基本概念"><a class="header-anchor" href="#数据结构的基本概念"></a>数据结构的基本概念</h2><h3 id="基本概念和术语"><a class="header-anchor" href="#基本概念和术语"></a>基本概念和术语</h3><h4 id="数据"><a class="header-anchor" href="#数据"></a>数据</h4><p>数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。数据是计算机程序加工的原料。</p><h4 id="数据元素"><a class="header-anchor" href="#数据元素"></a>数据元素</h4><p>数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。一个数据元素可由若干<font color="#ea66a6">数据项</font>组成，数据项是构成数据元素的不可分割的最小单位。例如，学生记录就是一个数据元素，它由学号、姓名、性别等数据项组成。</p><h4 id="数据对象"><a class="header-anchor" href="#数据对象"></a>数据对象</h4><p><font color="#ea66a6">数据对象</font>是具有<wavy>相同性质</wavy>的数据元素的集合，是数据的一个子集。例如，整数数据对象是集合 $N=\left \{ 0,\pm 1,\pm 2,\cdots   \right \} $。</p><h4 id="数据类型"><a class="header-anchor" href="#数据类型"></a>数据类型</h4><p>数据类型是一个值的集合和定义在此集合上的一组操作的总称。</p><ol><li><font color="#ea66a6">原子类型</font>。其值不可再分的数据类型。</li><li><font color="#ea66a6">结构类型</font>。其值可以再分解为若干成分（分量）的数据类型。</li><li><font color="#ea66a6">抽象数据类型</font>。抽象数据组织及与之相关的操作。</li></ol><h4 id="数据结构"><a class="header-anchor" href="#数据结构"></a>数据结构</h4><p><font color="#ea66a6">数据结构</font>是相互之间存在<wavy>一种或多种特定关系</wavy>的数据元素的集合。在任何问题中，数据元素都不是孤立存在的，它们之间存在某种关系，这种数据元素相互之间的关系称为结构（Structure）。数据结构包括三方面的内容：<wavy>逻辑结构</wavy>、<wavy>存储结构</wavy>和<wavy>数据的运算</wavy>。</p><p>数据的逻辑结构和存储结构是密不可分的两个方面，一个算法的设计取决于所选定的逻辑结构，而算法的实现依赖于所采用的存储结构。</p><h3 id="数据结构三要素"><a class="header-anchor" href="#数据结构三要素"></a>数据结构三要素</h3><h4 id="数据的逻辑结构"><a class="header-anchor" href="#数据的逻辑结构"></a>数据的逻辑结构</h4><p><font color="#ea66a6">逻辑结构</font>是指数据元素之间的逻辑关系，即从逻辑关系上描述数据。它与数据的存储无关，是独立于计算机的。数据的逻辑结构分为线性结构和非线性结构，线性表是典型的线性结构；集合、树和图是典型的非线性结构。数据的逻辑结构分类如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-mind-map-a@master/DataStructure/%E6%95%B0%E6%8D%AE%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84.1x5hbujljy9s.svg" alt="数据逻辑结构"></p><ul><li>集合。结构中的数据元素之间除“同属一个集合”外，别无其他关系。</li><li>线性结构。结构中的数据元素之间只存在一对一的关系。</li><li>树形结构。结构中的数据元素之间存在一对多的关系。</li><li>图状结构或网状结构。结构中的数据元素之间存在多对多的关系。</li></ul><h4 id="数据的存储结构"><a class="header-anchor" href="#数据的存储结构"></a>数据的存储结构</h4><p><font color="#ea66a6">存储结构</font>是指数据结构在计算机中的表示（又称映像），也称物理结构。它包括数据元素的表示和关系的表示。数据的存储结构是用计算机语言实现的逻辑结构，它依赖于计算机语言。数据的存储结构主要有顺序存储、链式存储、索引存储和散列存储。</p><ul><li><font color="#ea66a6">顺序存储</font>。把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。<ul><li>优点是可以实现随机存取，每个元素占用最少的存储空间；</li><li>缺点是只能使用相邻的一整块存储单元，因此可能产生较多的外部碎片。</li></ul></li><li><font color="#ea66a6">链式存储</font>。不要求逻辑上相邻的元素在物理位置上也相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系。<ul><li>优点是不会出现碎片现象，能充分利用所有存储单元；</li><li>缺点个元素因存储指针而占用额外的存储空间，且只能实现顺序存取。</li></ul></li><li><font color="#ea66a6">索引存储</font>。在存储元素信息的同时，还建立附加的索引表。索引表中的每项称为索引项，索引项的一般形式是（关键字，地址）。<ul><li>优点是检索速度快；</li><li>缺点是附加的索引表额外占用存储空间。另外，增加和删除数据时也要修改索引表，因而会花费较多的时间。</li></ul></li><li><font color="#ea66a6">散列存储</font>。根据元素的关键字直接计算出该元素的存储地址，又称哈希（Hash）存储。<ul><li>优点是检索、增加和删除结点的操作都很快；</li><li>缺点是若散列函数不好，则可能出现元素存储单元的冲突，而解决冲突会增加时间和空间开销。</li></ul></li></ul><h4 id="数据的运算"><a class="header-anchor" href="#数据的运算"></a>数据的运算</h4><p>施加在数据上的运算包括运算的定义和实现。运算的定义是针对逻辑结构的，指出运算的功能；运算的实现是针对存储结构的，指出运算的具体操作步骤。</p><h2 id="算法和算法评价"><a class="header-anchor" href="#算法和算法评价"></a>算法和算法评价</h2><h3 id="算法的基本概念"><a class="header-anchor" href="#算法的基本概念"></a>算法的基本概念</h3><p>算法（Algorithm）是对特定问题求解步骤的一种描述，它是指令的有限序列，其中的每条指令表示一个或多个操作。此外，一个算法还具有下列5个重要特性：</p><ol><li>有穷性。一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。</li><li>确定性。算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出。</li><li>可行性。算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。</li><li>输入。一个算法有零个或多个输入，这些输入取自于某个特定的对象的集合。</li><li>输出。一个算法有一个或多个输出，这些输出是与输入有着某种特定关系的量。</li></ol><p>通常，设计一个“好”的算法应考虑达到以下目标：</p><ol><li>正确性。算法应能够正确地解决求解问题。</li><li>可读性。算法应具有良好的可读性，以帮助人们理解。</li><li>健壮性。输入非法数据时，算法能适当地做出反应或进行处理，而不会产生莫名其妙的输出结果。</li><li>效率与低存储量需求。效率是指算法执行的时间，存储量需求是指算法执行过程中所需要的最大存储空间，这两者都与问题的规模有关。</li></ol><h3 id="算法效率的度量"><a class="header-anchor" href="#算法效率的度量"></a>算法效率的度量</h3><p>算法效率的度量是通过时间复杂度和 空间复杂度来描述的。</p><h4 id="时间复杂度"><a class="header-anchor" href="#时间复杂度"></a>时间复杂度</h4><p>一个语句的频度是指该语句在算法中被重复执行的次数。算法中所有语句的频度之和记为 $T(n)$ ，它是该算法问题规模 $n$ 的函数，时间复杂度主要分析 $T(n)$ 的<font color="#faa755">数量级</font>。算法中基本运算（最深层循环内的语句）的频度与 $T(n)$ 同数量级，因此通常采用算法中基本运算的频度 $f(n)$ 来分析算法的时间复杂度<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。因此，算法的时间复杂度记为: $$T(n)=O(f(n))$$式中，$O$的含义是$T(n)$的数量级，其严格的数学定义是：若 $T(n)$ 和 $f(n)$ 是定义在正整数集合上的两个函数，则存在正常数 $C$ 和 $n_0$ ,使得当 $n\ge n_0$ 时，都满足 $0 \le T(n) \le Cf(n)$ 。</p><p>算法的时间复杂度不仅依赖于问题的规模 $n$ ,也取决于待输入数据的性质（如输入数据元素的初始状态）。例如，在数组<code>A[0...n-1]</code>中，查找给定值 <code>k</code> 的算法大致如下：</p><ol><li><code>i = n-1;</code></li><li><code>while(i&gt;=0&amp;&amp;(A[i]!=k))</code></li><li><code>i--</code></li><li><code>return i;</code></li></ol><p>该算法中语句3（基本运算）的频度不仅与问题规模 $n$ 有关，而且与输入实例中<code>A</code>的各元素的取值及<code>k</code>的取值有关：</p><ul><li>若<code>A</code>中没有与<code>k</code>相等的元素，则语句3的频度 $f(n)=n$。</li><li>若 <code>A</code> 的最后一个元素等于 <code>k</code>，则语句3的频度 $f(n)$ 是常数 0。</li></ul><p><font color="#ea66a6">最坏时间复杂度</font>是指在最坏情况下，算法的时间复杂度。</p><p><font color="#ea66a6">平均时间复杂度</font>是指所有可能输入实例在等概率出现的情况下，算法的期望运行时间。</p><p><font color="#ea66a6">最好时间复杂度</font>是指在最好情况下，算法的时间复杂度。</p><p>一般总是考虑在最坏情况下的时间复杂度，以保证算法的运行时间不会比它更长。在分析一个程序的时间复杂性时，有以下两条规则：</p><ol><li>加法规则：$$T(n)=T_{1}(n)+T_{2}(n)=O(f(n))+O(g(n))=O(max(f(n),g(n)))$$</li><li>乘法规则：$$T(n)=T_{1}(n)\times  T_{2}(n)=O(f(n))\times O(g(n))=O(f(n)\times g(n))$$</li></ol><p>常见的渐进时间复杂度为$$O(1)&lt;O(log_{2}n)&lt;O(n)&lt;O(nlog_{2}n)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)$$</p><h4 id="空间复杂度"><a class="header-anchor" href="#空间复杂度"></a>空间复杂度</h4><p>算法的空间复杂度 $S(n)$ 定义为该算法所耗费的储存空间，它是问题规模 $n$ 的函数。记为：$$S(n)=O(g(n))$$一个程序在执行时除需要储存空间来存放本身所用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储一些为实现计算所需信息的辅助空间。若输入数据所占空间只取决于问题本身，和算法无关，则只需分析除输入和程序之外的额外空间。</p><blockquote><p>算法<font color="#ea66a6">原地工作</font>是指算法所需的辅助空间为常量，即 $O(1)$ 。</p></blockquote><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>取$f(n)$中随$n$增长最快的项，将其系数置为1作为时间复杂度的度量。例如，$f(n)=a{n}^{3}+b{n}^{2}+cn$的时间复杂度为$O({n}^{3})$。 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
    <summary type="html">描述</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>学习资源整理</title>
    <link href="http://halo123.top/2021/04/26/DataCollection/LearningResource/"/>
    <id>http://halo123.top/2021/04/26/DataCollection/LearningResource/</id>
    <published>2021-04-26T07:00:51.000Z</published>
    <updated>2021-04-30T15:11:51.345Z</updated>
    
    <content type="html"><![CDATA[<h2 id="课程学习计划"><a class="header-anchor" href="#课程学习计划"></a>课程学习计划</h2><h3 id="学习路线"><a class="header-anchor" href="#学习路线"></a>学习路线</h3><ul><li><a href="https://www.processon.com/view/link/60867464e401fd06e0b00d5e">前端学习路线</a></li><li><a href="https://www.processon.com/view/link/608677c85653bb2fcf8b46e3">Java后端学习路线</a></li><li><a href="https://github.com/kamranahmedse/developer-roadmap">开发者路线图</a></li><li><a href="https://zhuanlan.zhihu.com/p/339835359">前端开发者路线图翻译</a></li></ul><h2 id="视频课程"><a class="header-anchor" href="#视频课程"></a>视频课程</h2><h3 id="基础课程"><a class="header-anchor" href="#基础课程"></a>基础课程</h3><ul><li><a href="https://www.bilibili.com/video/BV1YE411D7nH">操作系统</a></li><li><a href="https://www.bilibili.com/video/BV1BE411D7ii">计算机组成原理</a></li><li><a href="https://www.bilibili.com/video/BV1b7411N798">数据结构</a></li><li><a href="https://www.bilibili.com/video/BV19E411D78Q">计算机网络</a></li><li><a href="https://www.bilibili.com/video/BV1aW411Q7x1">线性代数</a></li><li><a href="https://www.bilibili.com/video/BV1Eb411u7Fw">高等数学</a></li></ul><h3 id="后端技术课程"><a class="header-anchor" href="#后端技术课程"></a>后端技术课程</h3><ul><li><a href="https://www.bilibili.com/video/BV1G4411c7N4">设计模式(Java演示)</a></li><li><a href="https://www.bilibili.com/video/BV1gE411A7H8">ArrayList原理</a></li><li><a href="https://www.bilibili.com/video/BV1TE41177mP">Java核心编程思想</a></li></ul><h3 id="前端技术课程"><a class="header-anchor" href="#前端技术课程"></a>前端技术课程</h3><ul><li><a href="https://www.bilibili.com/video/BV1pE411q7FU">前端入门</a></li><li><a href="https://www.bilibili.com/video/BV1ux411d75J">JavaScript</a></li><li><a href="https://www.bilibili.com/video/BV1k4411w7sV">Js DOM BOM</a></li><li><a href="https://www.bilibili.com/video/BV1a4411w7Gx">jQuery</a></li><li><a href="https://www.bilibili.com/video/BV1YW411T7yy">Bootstrap</a></li><li><a href="https://www.bilibili.com/video/BV1YW411T7vd">less</a></li><li><a href="https://www.bilibili.com/video/BV18s411E7T5">Gulp</a></li><li><a href="https://www.bilibili.com/video/BV1VZ4y1M7ZC">ECharts</a></li><li><a href="https://www.bilibili.com/video/BV1ox411M7P2">Ajax上</a></li><li><a href="https://www.bilibili.com/video/BV15x411E7xH">Ajax下</a></li><li><a href="https://www.bilibili.com/video/BV19t411Q768">Node.js</a></li><li><a href="https://www.bilibili.com/video/BV14Z4y1u7pi">TypeScript</a></li><li><a href="https://www.bilibili.com/video/BV1wy4y1D7JT">React</a></li></ul><h2 id="技术书单"><a class="header-anchor" href="#技术书单"></a>技术书单</h2><ul><li><a href="https://book.douban.com/subject/35175321/">JavaScript高级程序设计 第4版</a></li><li><a href="https://book.douban.com/subject/26346017/">Java 8函数式编程</a></li></ul><h2 id="技术文章博客"><a class="header-anchor" href="#技术文章博客"></a>技术文章博客</h2><ul><li><a href="http://hollischuang.gitee.io/tobetopjavaer/#/">Java工程师成神之路</a></li><li><a href="https://github.com/ruanyf/weekly">科技爱好者周刊</a></li><li><a href="https://github.com/mqyqingfeng/Blog">前端冴羽的博客</a></li></ul><h2 id="项目学习计划"><a class="header-anchor" href="#项目学习计划"></a>项目学习计划</h2><ul><li><a href="https://www.bilibili.com/video/BV1dQ4y1A75e">谷粒学院</a></li><li><a href="https://www.bilibili.com/video/BV1np4y1C7Yf">谷粒商城</a></li></ul><h3 id="电商项目"><a class="header-anchor" href="#电商项目"></a>电商项目</h3><ul><li><a href="http://www.macrozheng.com/#/">mall</a></li></ul><h3 id="博客项目"><a class="header-anchor" href="#博客项目"></a>博客项目</h3><ul><li><a href="https://github.com/halo-dev/halo">halo</a></li><li><a href="https://docs.halo.run/">halo项目文档</a></li><li><a href="https://gitee.com/moxi159753/mogu_blog_v2">蘑菇博客</a></li></ul><h3 id="后台管理系统"><a class="header-anchor" href="#后台管理系统"></a>后台管理系统</h3><ul><li><a href="https://github.com/elunez/eladmin">EL-ADMIN 后台管理系统</a></li></ul><h3 id="基础技术项目"><a class="header-anchor" href="#基础技术项目"></a>基础技术项目</h3><ul><li><a href="https://github.com/judasn/IntelliJ-IDEA-Tutorial">IntelliJ IDEA 简体中文专题教程</a></li><li><a href="https://github.com/iluwatar/java-design-patterns">Java设计模式</a></li><li><a href="https://github.com/hansonwang99/JavaCollection">Java自学编程之路CodeSheep</a></li><li><a href="https://github.com/xkcoding/spring-boot-demo">SpringBootDemo</a></li><li><a href="https://github.com/jackzhenguo/python-small-examples">Python小例子</a></li><li><a href="https://github.com/MLEveryday/100-Days-Of-ML-Code">机器学习100天</a></li><li><a href="https://github.com/Snailclimb/JavaGuide">JavaGuide</a></li><li><a href="https://github.com/0voice/interview_internal_reference">大厂面试题</a></li><li><a href="https://github.com/kon9chunkit/GitHub-Chinese-Top-Charts">GitHub中文排行榜</a></li><li><a href="https://github.com/521xueweihan/HelloGitHub">HelloGitHub</a></li></ul><h3 id="大学课程共享"><a class="header-anchor" href="#大学课程共享"></a>大学课程共享</h3><ul><li><a href="https://github.com/QSCTech/zju-icicles">浙江大学课程攻略共享计划</a></li><li><a href="https://github.com/PKUanonym/REKCARC-TSC-UHT">清华大学计算机系课程攻略</a></li><li><a href="https://github.com/lib-pku/libpku">北京大学课程资料民间整理</a></li><li><a href="https://github.com/USTC-Resource/USTC-Course">中国科学技术大学课程资源</a></li><li><a href="https://github.com/c-hj/SJTU-Courses">上海交通大学课程资源分享</a></li><li><a href="https://www.yuque.com/0xffff.one/cs-learning/intro">华南师范大学0xFFFF CS </a></li></ul><h3 id="前端GitHub学习资源"><a class="header-anchor" href="#前端GitHub学习资源"></a>前端GitHub学习资源</h3><ul><li><a href="https://github.com/trekhleb/javascript-algorithms">javascript-algorithms</a>（基于javascript的算法和数据结构）</li><li><a href="https://github.com/goldbergyoni/nodebestpractices">nodebestpractices</a>（Node.js最佳实践）</li><li><a href="https://github.com/getify/You-Dont-Know-JS">You-Dont-Know-JS</a>（你不知道的js这本书的开源版本）</li><li><a href="https://github.com/ryanmcdermott/clean-code-javascript">clean-code-javascript</a>（教你如何写出更好可读性的js代码）</li><li><a href="https://github.com/30-seconds/30-seconds-of-code">30-seconds-of-code</a>（开发时常用的简短代码）</li><li><a href="https://github.com/30-seconds/30-seconds-of-css">30-seconds-of-css</a></li></ul><p>注：github后面加1s进入VScodeWeb可以更好的阅读代码，例如：<a href="https://github1s.com/trekhleb/javascript-algorithms">https://github1s.com/trekhleb/javascript-algorithms</a></p><h3 id="算法Github学习资源"><a class="header-anchor" href="#算法Github学习资源"></a>算法Github学习资源</h3><ul><li><a href="https://github.com/TheAlgorithms/Python">TheAlgorithms/Python</a>（Python 实现算法）</li><li><a href="https://github.com/TheAlgorithms/Java">TheAlgorithms/Java</a>（Java 实现算法）</li><li><a href="https://github.com/wangzheng0822/algo">数据结构和算法必知必会的50个代码实现</a></li><li><a href="https://github.com/halfrost/LeetCode-Go">LeetCode题解Go语言实现</a></li></ul><h2 id="在线工具网站"><a class="header-anchor" href="#在线工具网站"></a>在线工具网站</h2><blockquote><p>以下内容来自<a href="https://www.bilibili.com/video/BV1L64y1i7HY">CodeSheep</a>，浏览器书签导入文件：<a href="https://pan.baidu.com/s/1wtK-xsEHZoEWx-eo_rX_aQ">百度云盘</a>【提取码：3chy】</p></blockquote><h3 id="画图工具"><a class="header-anchor" href="#画图工具"></a>画图工具</h3><ul><li><a href="https://www.processon.com/">在线画图工具ProcessOn</a></li><li><a href="https://app.diagrams.net/">在线画图工具draw.io</a></li><li><a href="http://www.mindline.cn/webapp">在线思维导图工具</a></li><li><a href="http://haha98k.com/">PlantUML在线编辑器</a></li></ul><h3 id="开发辅助工具"><a class="header-anchor" href="#开发辅助工具"></a>开发辅助工具</h3><h4 id="在线编解码工具"><a class="header-anchor" href="#在线编解码工具"></a>在线编解码工具</h4><ul><li><a href="https://base64.supfree.net/">BASE64加密解密</a></li><li><a href="https://www.zxgj.cn/g/md5">MD5编码工具</a></li><li><a href="http://www.fly63.com/tool/cipher/">AES/DES加解密</a></li><li><a href="http://jwt.calebb.net/">JWT解码工具</a></li><li><a href="https://www.matools.com/code-convert-ascii">ASCII编解码工具</a></li><li><a href="https://www.zxgj.cn/g/unicode">Unicode编解码工具</a></li><li><a href="https://www.zxgj.cn/g/utf8">UTF-8编解码工具</a></li><li><a href="https://www.zxgj.cn/g/enstring">字符串编解码工具</a></li><li><a href="http://tool.chinaz.com/tools/urlencode.aspx?jdfwkey=lbixz1">URL编解码工具</a></li></ul><h4 id="在线转换工具"><a class="header-anchor" href="#在线转换工具"></a>在线转换工具</h4><ul><li><a href="http://www.fly63.com/tool/ascii/">在线ASCII码对照表</a></li><li><a href="https://www.zxgj.cn/g/jinzhi">通用进制转换工具</a></li><li><a href="http://www.binaryconvert.com/">在线浮点数十进制转换</a></li><li><a href="https://www.zxgj.cn/g/yansezhi">RGB颜色转换</a></li><li><a href="https://www.zxgj.cn/g/unix">时间戳转换工具</a></li><li><a href="http://www.fly63.com/tool/unitable/">计量单位换算工具</a></li><li><a href="http://www.json.cn/">在线JSON解析</a></li><li><a href="https://prettier.io/playground/">在线JS代码格式化工具</a></li><li><a href="https://www.zxgj.cn/g/sqlformat">SQL压缩/格式化工具</a></li><li><a href="https://www.zxgj.cn/g/jsonxml">JSON和XML在线转换</a></li><li><a href="http://www.fly63.com/tool/jsonyaml/">JSON/YAML在线转换</a></li><li><a href="http://www.fly63.com/tool/renmingbi/">人民币大小写转换工具</a></li></ul><h4 id="正则表达式工具"><a class="header-anchor" href="#正则表达式工具"></a>正则表达式工具</h4><ul><li><a href="https://jex.im/regulex/#!flags=&amp;re=%5E(a%7Cb)*%3F%24">正则表达式可视化工具</a></li><li><a href="https://regexr.com/">正则表达式调试工具</a></li></ul><h4 id="网络工具"><a class="header-anchor" href="#网络工具"></a>网络工具</h4><ul><li><a href="https://www.ip138.com/">IP地址归属地查询</a></li><li><a href="https://www.ipip.net/ip.html">IP地址查询</a></li><li><a href="http://www.fly63.com/php/http/">HTTP在线接口测试工具</a></li></ul><h4 id="在线编译运行工具"><a class="header-anchor" href="#在线编译运行工具"></a>在线编译运行工具</h4><ul><li><a href="https://c.runoob.com/">在线编译工具套装</a></li><li><a href="http://jsrun.net/">在线编译工具 JSRun</a></li><li><a href="https://rextester.com/">C#在线编译运行</a></li><li><a href="https://www.onlinegdb.com/">C/C–在线编译调试</a></li></ul><h4 id="可视化-格式化工具"><a class="header-anchor" href="#可视化-格式化工具"></a>可视化/格式化工具</h4><ul><li><a href="https://animpen.com/">在线前端编辑器 AnimPen</a></li><li><a href="https://codepen.io/">在线前端编辑器 CodePen</a></li><li><a href="https://flourish.studio/">在线数据可视化</a></li><li><a href="https://enjoycss.com/">在线CSS代码可视化工具</a></li><li><a href="https://www.zxgj.cn/g/xmlformat">XML格式化工具</a></li></ul><h4 id="在线生成器"><a class="header-anchor" href="#在线生成器"></a>在线生成器</h4><ul><li><a href="https://www.zxgj.cn/g/uuid">UUID在线生成器</a></li><li><a href="https://www.zxgj.cn/g/suijishu">随机数生成器</a></li></ul><h4 id="其他常用工具"><a class="header-anchor" href="#其他常用工具"></a>其他常用工具</h4><ul><li><a href="https://www.digitalocean.com/community/tools/nginx#?">在线Nginx配置工具</a></li><li><a href="http://www.fly63.com/tool/textdiff/">在线对比工具</a></li><li><a href="https://www.crx4chrome.com/">在线Chrome浏览器插件</a></li><li><a href="http://www.docway.net/">在线接口文档管理工具</a></li></ul><h3 id="在线素材库"><a class="header-anchor" href="#在线素材库"></a>在线素材库</h3><ul><li><a href="http://pngimg.com/">免费透明背景图片素材</a></li><li><a href="https://emoji.svend.cc/">Emoji表情搜索</a></li><li><a href="https://emojiisland.com/">Emoji表情包下载</a></li><li><a href="https://www.iconfinder.com/">ICON图标在线下载</a></li><li><a href="https://feathericons.com/">open source icons</a></li><li><a href="https://www.iconfont.cn/">阿里巴巴矢量图标库</a></li><li><a href="https://fabiaoqing.com/">表情包在线网站</a></li><li><a href="https://bz.zzzmh.cn/">极简壁纸</a></li><li><a href="https://wall.alphacoders.com/">Wallpaper Abyss壁纸</a></li><li><a href="https://pluspng.com/">免费PNG图片库</a></li><li><a href="https://pixabay.com/zh/">Pixabay图片素材库</a></li><li><a href="https://unsplash.com/">Unsplash图片素材库</a></li><li><a href="http://www.pexels.com/">Pexels图片素材库</a></li><li><a href="https://images.nasa.gov/">NASA图片视频素材库</a></li></ul><h3 id="设计制作类工具"><a class="header-anchor" href="#设计制作类工具"></a>设计制作类工具</h3><ul><li><a href="https://www.uupoop.com/#/old">在线PS</a></li><li><a href="https://www.weixinsyt.com/">在线音频剪辑</a></li><li><a href="https://www.kapwing.com/">在线视频剪辑</a></li><li><a href="http://www.uugai.com/">免费logo在线制作</a></li><li><a href="https://www.qt86.com/">艺术字体在线生成</a></li><li><a href="https://tableconvert.com/">在线表格转换工具</a></li><li><a href="https://www.designcap.com/">在线海报设计工具</a></li><li><a href="https://bigjpg.com/">图片智能放大工具</a></li><li><a href="https://mh.cli.im/">二维码美化器</a></li><li><a href="https://carbon.now.sh/">在线代码截图工具</a></li><li><a href="https://www.remove.bg/zh">在线抠图工具</a></li><li><a href="http://www.fly63.com/php/ico/">ICO图标在线生成</a></li><li><a href="http://www.fly63.com/tool/svg2img/">SVG转PNG工具</a></li><li><a href="http://www.fly63.com/tool/giftxt/">视频转GIF工具</a></li><li><a href="http://www.fly63.com/tool/ewm/">二维码在线生成器</a></li><li><a href="http://www.fly63.com/php/decoder/">二维码在线解码</a></li></ul><h3 id="写作辅助工具"><a class="header-anchor" href="#写作辅助工具"></a>写作辅助工具</h3><ul><li><a href="https://www.eteste.com/">在线字数统计</a></li><li><a href="https://mdnice.com/">mdnice markdown排版工具</a></li><li><a href="http://md.aclickall.com/">md2all markdown排版工具</a></li><li><a href="https://picx.xpoet.cn/">图片上传 | PicX 图床神器</a></li><li><a href="https://sm.ms/">在线免费图床</a></li><li><a href="https://imgkr.com/">图壳图床</a></li><li><a href="https://urlify.cn/">在线短链接工具</a></li><li><a href="http://www.fly63.com/tool/textreplace/">在线文本替换</a></li></ul><h3 id="在线办公工具"><a class="header-anchor" href="#在线办公工具"></a>在线办公工具</h3><ul><li><a href="https://tools.pdf24.org/zh/">pdf在线处理套装1</a></li><li><a href="https://smallpdf.com/cn/pdf-tools">pdf在线处理套装2</a></li><li><a href="https://cn.office-converter.com/">在线多媒体转换器合集</a></li><li><a href="https://ocr.wdku.net/">在线文字识别工具</a></li><li><a href="https://docsmall.com/">在线文件压缩工具</a></li></ul><h3 id="文档笔记工具"><a class="header-anchor" href="#文档笔记工具"></a>文档笔记工具</h3><ul><li><a href="https://www.yinxiang.com/">印象笔记</a></li><li><a href="https://note.youdao.com/">有道笔记</a></li><li><a href="https://www.onenote.com/">OneNote</a></li><li><a href="https://mubu.com/">幕布</a></li><li><a href="https://www.wiz.cn/">为知笔记</a></li><li><a href="https://shimo.im/">石墨文档</a></li><li><a href="https://simplenote.com/">Simplenote</a></li><li><a href="https://www.yuque.com/">语雀</a></li></ul><h3 id="在线编程学习"><a class="header-anchor" href="#在线编程学习"></a>在线编程学习</h3><ul><li><a href="https://www.bilibili.com/">哔哩哔哩</a></li><li><a href="https://www.dotcpp.com/">C语言网</a></li><li><a href="https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5">cppreference</a></li><li><a href="https://www.icourse163.org/">中国大学MOOC</a></li><li><a href="https://open.163.com/">网易公开课</a></li><li><a href="https://www.nowcoder.com/">牛客网</a></li><li><a href="https://codegym.cc/">CodeGym</a></li><li><a href="https://beginnersbook.com/">BeginnersBook</a></li><li><a href="http://www.javased.com/">JavaSED</a></li><li><a href="https://www.codecademy.com/">codecademy</a></li><li><a href="https://www.coursera.org/">Coursera</a></li><li><a href="https://stackoverflow.com/">StackOverFlow</a></li><li><a href="https://leetcode-cn.com/">LeetCode</a></li><li><a href="https://www.lintcode.com/">LintCode</a></li></ul><h3 id="在线教程和文档"><a class="header-anchor" href="#在线教程和文档"></a>在线教程和文档</h3><ul><li><a href="https://git-scm.com/book/zh/v2">Git中文教程</a></li><li><a href="http://svnbook.red-bean.com/nightly/zh/index.html">SVN中文手册</a></li><li><a href="https://jquery.cuishifeng.cn/">jQuery API中文文档</a></li><li><a href="https://www.nginx.cn/doc/index.html">Nginx中文文档</a></li><li><a href="https://kafka.apachecn.org/">Kafka中文文档</a></li><li><a href="https://mybatis.org/mybatis-3/zh/index.html">Mybatis中文文档</a></li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/">微信小程序官方文档</a></li><li><a href="http://nodejs.cn/learn/">Nodejs中文教程文档</a></li><li><a href="http://httpd.apache.org/docs/">Apache Web Server文档</a></li><li><a href="https://www.springcloud.cc/spring-reference.html">Spring文档中文版</a></li><li><a href="https://studygolang.com/pkgdoc">Golang标准库文档中文版</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/index.html">Java 8官方文档</a></li><li><a href="http://maven.apache.org/guides/">Maven官方文档</a></li><li><a href="http://tomcat.apache.org/tomcat-8.0-doc/index.html">Tomcat 8官方文档</a></li><li><a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/">Spring Boot官方文档</a></li><li><a href="https://www.rabbitmq.com/documentation.html">RabbitMQ官方文档</a></li><li><a href="http://rocketmq.apache.org/docs/quick-start/">RocketMQ官方文档</a></li><li><a href="https://dubbo.apache.org/zh/docs/">Dubbo中文文档</a></li><li><a href="https://netty.io/wiki/index.html">Netty官方文档</a></li><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html">Elasticsearch官方文档</a></li><li><a href="https://spring.io/projects/spring-cloud">Spring Cloud官方文档</a></li><li><a href="https://docs.docker.com/get-started/">Docker官方文档</a></li><li><a href="https://kubernetes.io/zh/docs/home/">kubernetes中文文档</a></li><li><a href="https://www.thymeleaf.org/documentation.html">thymeleaf官方文档</a></li><li><a href="https://cn.vuejs.org/v2/guide/">Vue.js中文文档</a></li><li><a href="https://reactjs.org/docs/getting-started.html">React.js官方文档</a></li><li><a href="https://www.jenkins.io/zh/doc/">Jenkins中文文档</a></li></ul><h2 id="资源下载"><a class="header-anchor" href="#资源下载"></a>资源下载</h2><h3 id="图书资源"><a class="header-anchor" href="#图书资源"></a>图书资源</h3><ul><li><a href="https://www.bookzz.ren/">Bookzz</a>（电子书下载网站）</li><li><a href="https://gitee.com/SnailClimb/awesome-cs">计算机优质书籍搜罗-学习路线推荐</a></li></ul>]]></content>
    
    
    <summary type="html">各种学习资源整理</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Flex布局</title>
    <link href="http://halo123.top/2021/04/24/WebFrontEnd/FlexLayout/"/>
    <id>http://halo123.top/2021/04/24/WebFrontEnd/FlexLayout/</id>
    <published>2021-04-24T15:59:51.000Z</published>
    <updated>2021-04-25T08:41:51.000Z</updated>
    
    <content type="html"><![CDATA[<details ><summary> 参考文章 </summary>              <div class='content'>              <div class="tag link"><a class="link-card" title="Flex布局语法教程——阮一峰" href="https://www.runoob.com/w3cnote/flex-grammar.html"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E7%BD%91%E7%AB%99.svg"/></div><div class="right"><p class="text">Flex布局语法教程——阮一峰</p><p class="url">https://www.runoob.com/w3cnote/flex-grammar.html</p></div></a></div><div class="tag link"><a class="link-card" title="flex 布局的基本概念——MDN教程" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E7%BD%91%E7%AB%99.svg"/></div><div class="right"><p class="text">flex 布局的基本概念——MDN教程</p><p class="url">https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox</p></div></a></div>              </div>            </details><h2 id="Flex布局是什么"><a class="header-anchor" href="#Flex布局是什么"></a>Flex布局是什么</h2><p>Flex 是 <code>Flexible Box</code> 的缩写，意为“弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>行内元素也可以使用 Flex 布局。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Webkit 内核的浏览器，必须加上<code>-webkit</code>前缀。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-flex; <span class="comment">/* Safari */</span></span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，设为 Flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效。</p><h2 id="基本概念"><a class="header-anchor" href="#基本概念"></a>基本概念</h2><p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称“<strong>容器</strong>”。</p><p>它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称“<strong>项目</strong>”。</p><p><img src="https://www.runoob.com/wp-content/uploads/2015/07/3791e575c48b3698be6a94ae1dbff79d.png" alt="Flex 布局"></p><p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做 main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。</p><p>项目默认沿主轴排列。单个项目占据的主轴空间叫做 main size，占据的交叉轴空间叫做 cross size。</p><h2 id="容器属性"><a class="header-anchor" href="#容器属性"></a>容器属性</h2><p>以下6个属性设置在容器上：</p><ul><li><a href="#flex-direction%E5%B1%9E%E6%80%A7">flex-direction</a></li><li><a href="#flex-wrap%E5%B1%9E%E6%80%A7">flex-wrap</a></li><li><a href="#flex-flow%E5%B1%9E%E6%80%A7">flex-flow</a></li><li><a href="#justify-content%E5%B1%9E%E6%80%A7">justify-content</a></li><li><a href="#align-items%E5%B1%9E%E6%80%A7">align-items</a></li><li><a href="#align-content%E5%B1%9E%E6%80%A7">align-content</a></li></ul><h3 id="flex-direction属性"><a class="header-anchor" href="#flex-direction属性"></a><code>flex-direction</code>属性</h3><p>flex-direction 属性决定主轴的方向（即项目的排列方向）。它可能有4个值：</p><ul><li>column-reverse：主轴为垂直方向，起点在下沿。</li><li>column：主轴为垂直方向，起点在上沿。</li><li>row（默认值）：主轴为水平方向，起点在左端。</li><li>row-reverse：主轴为水平方向，起点在右端。</li></ul><p><img src="https://www.runoob.com/wp-content/uploads/2015/07/0cbe5f8268121114e87d0546e53cda6e.png" alt="flex-direction 属性"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="flex-wrap属性"><a class="header-anchor" href="#flex-wrap属性"></a><code>flex-wrap</code>属性</h3><p>默认情况下，项目都排在一条线（又称“轴线”）上。flex-wrap 属性定义，如果一条轴线排不下，如何换行。</p><p><img src="https://www.runoob.com/wp-content/uploads/2015/07/903d5b7df55779c03f2687a7d4d6bcea.png" alt=""></p><p>它可能取三个值：</p><ul><li>nowrap（默认）：不换行</li><li>wrap：换行，第一行在上方</li><li>wrap-reverse：换行，第一行在下方</li></ul><p><img src="https://www.runoob.com/wp-content/uploads/2015/07/9da1f23965756568b4c6ea7124db7b9a.png" alt="nowrap"><br><img src="https://www.runoob.com/wp-content/uploads/2015/07/3c6b3c8b8fe5e26bca6fb57538cf72d9.jpg" alt="wrap"><br><img src="https://www.runoob.com/wp-content/uploads/2015/07/fb4cf2bab8b6b744b64f6d7a99cd577c.jpg" alt="wrap-reverse"></p><h3 id="flex-flow属性"><a class="header-anchor" href="#flex-flow属性"></a><code>flex-flow</code>属性</h3><p>flex-flow 属性是 flex-directio n属性和 flex-wrap 属性的简写形式，默认值为 row nowrap。</p><h3 id="justify-content属性"><a class="header-anchor" href="#justify-content属性"></a><code>justify-content</code>属性</h3><p>justify-content 属性定义了项目在主轴上的对齐方式。它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</p><ul><li>flex-start（默认值）：左对齐</li><li>flex-end：右对齐</li><li>center： 居中</li><li>space-between：两端对齐，项目之间的间隔都相等。</li><li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li></ul><p><img src="https://www.runoob.com/wp-content/uploads/2015/07/c55dfe8e3422458b50e985552ef13ba5.png" alt="justify-content 属性"></p><h3 id="align-items属性"><a class="header-anchor" href="#align-items属性"></a><code>align-items</code>属性</h3><p>align-items 属性定义项目在交叉轴上如何对齐。它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下：</p><ul><li>flex-start：交叉轴的起点对齐。</li><li>flex-end：交叉轴的终点对齐。</li><li>center：交叉轴的中点对齐。</li><li>baseline: 项目的第一行文字的基线对齐。</li><li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li></ul><p><img src="https://www.runoob.com/wp-content/uploads/2015/07/2b0c39c7e7a80d5a784c8c2ca63cde17.png" alt="align-items 属性"></p><h3 id="align-content属性"><a class="header-anchor" href="#align-content属性"></a><code>align-content</code>属性</h3><p>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。该属性可能取6个值：</p><ul><li>flex-start：与交叉轴的起点对齐。</li><li>flex-end：与交叉轴的终点对齐。</li><li>center：与交叉轴的中点对齐。</li><li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li><li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li><li>stretch（默认值）：轴线占满整个交叉轴。</li></ul><p><img src="https://www.runoob.com/wp-content/uploads/2015/07/f10918ccb8a13247c9d47715a2bd2c33.png" alt="align-content属性"></p><h2 id="项目属性"><a class="header-anchor" href="#项目属性"></a>项目属性</h2><p>以下6个属性设置在项目上：</p><ul><li><a href="#order%E5%B1%9E%E6%80%A7">order</a></li><li><a href="#flex-grow%E5%B1%9E%E6%80%A7">flex-grow</a></li><li><a href="#flex-shrink%E5%B1%9E%E6%80%A7">flex-shrink</a></li><li><a href="#flex-basis%E5%B1%9E%E6%80%A7">flex-basis</a></li><li><a href="#flex-basis%E5%B1%9E%E6%80%A7">flex</a></li><li><a href="#flex-basis%E5%B1%9E%E6%80%A7">align-self</a></li></ul><h3 id="order属性"><a class="header-anchor" href="#order属性"></a><code>order</code>属性</h3><p>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: &lt;integer&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.runoob.com/wp-content/uploads/2015/07/59e399c72daafcfcc20ede36bf32f266.png" alt="order 属性"></p><h3 id="flex-grow属性"><a class="header-anchor" href="#flex-grow属性"></a><code>flex-grow</code>属性</h3><p>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: &lt;number&gt;; <span class="comment">/* default 0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.runoob.com/wp-content/uploads/2015/07/f41c08bb35962ed79e7686f735d6cd78.png" alt="flex-grow 属性"></p><p>如果所有项目的 flex-grow 属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的 flex-grow 属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p><h3 id="flex-shrink属性"><a class="header-anchor" href="#flex-shrink属性"></a><code>flex-shrink</code>属性</h3><p>flex-shrink 属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: &lt;number&gt;; <span class="comment">/* default 1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.runoob.com/wp-content/uploads/2015/07/240d3e960043a729bb3ff5e34987904f.jpg" alt="flex-shrink 属性"></p><p>如果所有项目的 flex-shrink 属性都为1，当空间不足时，都将等比例缩小。如果一个项目的 flex-shrink 属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。</p><h3 id="flex-basis属性"><a class="header-anchor" href="#flex-basis属性"></a><code>flex-basis</code>属性</h3><p>flex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-basis</span>: &lt;length&gt; | auto; <span class="comment">/* default auto */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它可以设为跟 width 或 height 属性一样的值（比如350px），则项目将占据固定空间。</p><h3 id="flex属性"><a class="header-anchor" href="#flex属性"></a><code>flex</code>属性</h3><p>flex 属性是 flex-grow, flex-shrink 和 flex-basis 的简写，默认值为0 1 auto。后两个属性可选。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: none | [ &lt;<span class="string">&#x27;flex-grow&#x27;</span>&gt; &lt;<span class="string">&#x27;flex-shrink&#x27;</span>&gt;? || &lt;<span class="string">&#x27;flex-basis&#x27;</span>&gt; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。</p><p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p><h3 id="align-self属性"><a class="header-anchor" href="#align-self属性"></a><code>align-self</code>属性</h3><p>align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。默认值为 auto，表示继承父元素的align-items 属性，如果没有父元素，则等同于 stretch。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该属性可能取6个值，除了auto，其他都与 align-items 属性完全一致。</p><p><img src="https://www.runoob.com/wp-content/uploads/2015/07/55b19171b8b6b9487d717bf2ecbba6de.png" alt="align-self 属性"></p>]]></content>
    
    
    <summary type="html">Flex布局，可以简便、完整、响应式地实现各种页面布局</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>文本样式测试</title>
    <link href="http://halo123.top/2021/04/24/Blog/%E6%96%87%E6%9C%AC%E6%A0%B7%E5%BC%8F%E6%B5%8B%E8%AF%95/"/>
    <id>http://halo123.top/2021/04/24/Blog/%E6%96%87%E6%9C%AC%E6%A0%B7%E5%BC%8F%E6%B5%8B%E8%AF%95/</id>
    <published>2021-04-24T03:04:20.000Z</published>
    <updated>2021-05-04T07:12:53.848Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>该文章参考自 Akilar 的 《<a href="https://akilar.top/posts/615e2dec/">基于 Butterfly 的外挂标签引入</a>》，通过整理，便于个人相关样式开发</p></blockquote><h2 id="分栏"><a class="header-anchor" href="#分栏"></a>分栏</h2><h3 id="预设选择第一个-默认"><a class="header-anchor" href="#预设选择第一个-默认"></a>预设选择第一个(默认)</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">样式示例</button></li><li class="tab"><button type="button" data-href="#分栏-2">对应源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><div class="tabs" id="默认名称"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#默认名称-1">默认名称 1</button></li><li class="tab"><button type="button" data-href="#默认名称-2">默认名称 2</button></li><li class="tab"><button type="button" data-href="#默认名称-3">默认名称 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="默认名称-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="默认名称-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="默认名称-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs %&#125;</span><br><span class="line">&lt;!-- tab 默认名称 --&gt;</span><br><span class="line">**This is Tab 1.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**This is Tab 2.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**This is Tab 3.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="预设指定选择"><a class="header-anchor" href="#预设指定选择"></a>预设指定选择</h3><div class="tabs" id="预设指定选择"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#预设指定选择-1">样式示例</button></li><li class="tab"><button type="button" data-href="#预设指定选择-2">对应源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="预设指定选择-1"><div class="tabs" id="默认名称"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#默认名称-1">分栏1</button></li><li class="tab active"><button type="button" data-href="#默认名称-2">分栏2</button></li><li class="tab"><button type="button" data-href="#默认名称-3">分栏3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="默认名称-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content active" id="默认名称-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="默认名称-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="预设指定选择-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs 默认名称, 2 %&#125;</span><br><span class="line">&lt;!-- tab 分栏1 --&gt;</span><br><span class="line">**This is Tab 1.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 分栏2 --&gt;</span><br><span class="line">**This is Tab 2.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 分栏3 --&gt;</span><br><span class="line">**This is Tab 3.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="行内文本样式"><a class="header-anchor" href="#行内文本样式"></a>行内文本样式</h2><div class="tabs" id="行内文本样式"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#行内文本样式-1">样式示例</button></li><li class="tab"><button type="button" data-href="#行内文本样式-2">对应源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="行内文本样式-1"><ul><li><u>文本内容</u></li><li><emp>文本内容</emp></li><li><wavy>文本内容</wavy></li><li><del>文本内容</del></li><li><kbd>文本内容</kbd></li><li><psw>文本内容</psw></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="行内文本样式-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% u 文本内容 %&#125;</span><br><span class="line">&#123;% emp 文本内容 %&#125;</span><br><span class="line">&#123;% wavy 文本内容 %&#125;</span><br><span class="line">&#123;% del 文本内容 %&#125;</span><br><span class="line">&#123;% kbd 文本内容 %&#125;</span><br><span class="line">&#123;% psw 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="折叠框"><a class="header-anchor" href="#折叠框"></a>折叠框</h2><div class="tabs" id="折叠框"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#折叠框-1">样式示例</button></li><li class="tab"><button type="button" data-href="#折叠框-2">对应源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="折叠框-1"><details ><summary> 查看图片测试 </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg" alt=""></p>              </div>            </details><details green><summary> 查看代码测试 </summary>              <div class='content'>              <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello,World!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details yellow><summary> 查看列表测试 </summary>              <div class='content'>              <p>DONE 列表显示有偏移需要修改</p><ul><li>hello</li><li>hello</li></ul>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="折叠框-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;% folding 查看图片测试 %&#125;</span><br><span class="line"></span><br><span class="line">![](https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;volantis-x&#x2F;cdn-wallpaper&#x2F;abstract&#x2F;41F215B9-261F-48B4-80B5-4E86E165259E.jpeg)</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding green, 查看代码测试 %&#125;</span><br><span class="line">假装这里有代码块（代码块没法嵌套代码块）</span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding yellow, 查看列表测试 %&#125;</span><br><span class="line"></span><br><span class="line">- hello</span><br><span class="line">- hello</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><h3 id="simple-样式"><a class="header-anchor" href="#simple-样式"></a>simple 样式</h3><div class="tabs" id="simple-样式"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#simple-样式-1">样式示例</button></li><li class="tab"><button type="button" data-href="#simple-样式-2">对应源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="simple-样式-1"><div class="note simple"><p>默认 提示块标签</p></div><div class="note default simple"><p>default 提示块标签</p></div><div class="note primary simple"><p>primary 提示块标签</p></div><div class="note success simple"><p>success 提示块标签</p></div><div class="note info simple"><p>info 提示块标签</p></div><div class="note warning simple"><p>warning 提示块标签</p></div><div class="note danger simple"><p>danger 提示块标签</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="simple-样式-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note simple %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default simple %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary simple %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success simple %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info simple %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning simple %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger simple %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="modern-样式"><a class="header-anchor" href="#modern-样式"></a>modern 样式</h3><div class="tabs" id="modern-样式"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#modern-样式-1">样式示例</button></li><li class="tab"><button type="button" data-href="#modern-样式-2">对应源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="modern-样式-1"><div class="note modern"><p>默认 提示块标签</p></div><div class="note default modern"><p>default 提示块标签</p></div><div class="note primary modern"><p>primary 提示块标签</p></div><div class="note success modern"><p>success 提示块标签</p></div><div class="note info modern"><p>info 提示块标签</p></div><div class="note warning modern"><p>warning 提示块标签</p></div><div class="note danger modern"><p>danger 提示块标签</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="modern-样式-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note modern %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default modern %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary modern %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success modern %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info modern %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning modern %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger modern %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="flat-样式"><a class="header-anchor" href="#flat-样式"></a>flat 样式</h3><div class="tabs" id="flat-样式"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#flat-样式-1">样式示例</button></li><li class="tab"><button type="button" data-href="#flat-样式-2">对应源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="flat-样式-1"><div class="note flat"><p>默认 提示块标签</p></div><div class="note default flat"><p>default 提示块标签</p></div><div class="note primary flat"><p>primary 提示块标签</p></div><div class="note success flat"><p>success 提示块标签</p></div><div class="note info flat"><p>info 提示块标签</p></div><div class="note warning flat"><p>warning 提示块标签</p></div><div class="note danger flat"><p>danger 提示块标签</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="flat-样式-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note flat %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default flat %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary flat %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success flat %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info flat %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning flat %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger flat %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="disabled-样式"><a class="header-anchor" href="#disabled-样式"></a>disabled 样式</h3><div class="tabs" id="默认名称"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#默认名称-1">样式示例</button></li><li class="tab"><button type="button" data-href="#默认名称-2">对应源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="默认名称-1"><div class="note disabled"><p>默认 提示块标签</p></div><div class="note default disabled"><p>default 提示块标签</p></div><div class="note primary disabled"><p>primary 提示块标签</p></div><div class="note success disabled"><p>success 提示块标签</p></div><div class="note info disabled"><p>info 提示块标签</p></div><div class="note warning disabled"><p>warning 提示块标签</p></div><div class="note danger disabled"><p>danger 提示块标签</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="默认名称-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note disabled %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default disabled %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary disabled %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success disabled %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info disabled %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning disabled %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger disabled %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="no-icon-样式"><a class="header-anchor" href="#no-icon-样式"></a>no-icon 样式</h3><div class="tabs" id="默认名称"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#默认名称-1">样式示例</button></li><li class="tab"><button type="button" data-href="#默认名称-2">对应源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="默认名称-1"><div class="note no-icon flat"><p>默认 提示块标签</p></div><div class="note default no-icon flat"><p>default 提示块标签</p></div><div class="note primary no-icon flat"><p>primary 提示块标签</p></div><div class="note success no-icon flat"><p>success 提示块标签</p></div><div class="note info no-icon flat"><p>info 提示块标签</p></div><div class="note warning no-icon flat"><p>warning 提示块标签</p></div><div class="note danger no-icon flat"><p>danger 提示块标签</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="默认名称-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note no-icon %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default no-icon %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary no-icon %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success no-icon %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info no-icon %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning no-icon %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger no-icon %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="复选列表"><a class="header-anchor" href="#复选列表"></a>复选列表</h2><div class="tabs" id="默认名称"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#默认名称-1">样式示例</button></li><li class="tab"><button type="button" data-href="#默认名称-2">对应源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="默认名称-1"><div class='checkbox'><input type="checkbox" />            <p>纯文本测试</p>            </div><div class='checkbox checked'><input type="checkbox" checked="checked"/>            <p>支持简单的 <a href="https://guides.github.com/features/mastering-markdown/">markdown</a> 语法</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>支持自定义颜色</p>            </div><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>绿色 + 默认选中</p>            </div><div class='checkbox yellow checked'><input type="checkbox" checked="checked"/>            <p>黄色 + 默认选中</p>            </div><div class='checkbox cyan checked'><input type="checkbox" checked="checked"/>            <p>青色 + 默认选中</p>            </div><div class='checkbox blue checked'><input type="checkbox" checked="checked"/>            <p>蓝色 + 默认选中</p>            </div><div class='checkbox plus green checked'><input type="checkbox" checked="checked"/>            <p>增加</p>            </div><div class='checkbox minus yellow checked'><input type="checkbox" checked="checked"/>            <p>减少</p>            </div><div class='checkbox times red checked'><input type="checkbox" checked="checked"/>            <p>叉</p>            </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="默认名称-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% checkbox 纯文本测试 %&#125;</span><br><span class="line">&#123;% checkbox checked, 支持简单的 [markdown](https:&#x2F;&#x2F;guides.github.com&#x2F;features&#x2F;mastering-markdown&#x2F;) 语法 %&#125;</span><br><span class="line">&#123;% checkbox red, 支持自定义颜色 %&#125;</span><br><span class="line">&#123;% checkbox green checked, 绿色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox yellow checked, 黄色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox cyan checked, 青色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox blue checked, 蓝色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox plus green checked, 增加 %&#125;</span><br><span class="line">&#123;% checkbox minus yellow checked, 减少 %&#125;</span><br><span class="line">&#123;% checkbox times red checked, 叉 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="单选列表"><a class="header-anchor" href="#单选列表"></a>单选列表</h2><div class="tabs" id="默认名称"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#默认名称-1">样式示例</button></li><li class="tab"><button type="button" data-href="#默认名称-2">对应源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="默认名称-1"><div class='checkbox'><input type="radio" />            <p>纯文本测试</p>            </div><div class='checkbox checked'><input type="radio" checked="checked"/>            <p>支持简单的 <a href="https://guides.github.com/features/mastering-markdown/">markdown</a> 语法</p>            </div><div class='checkbox red'><input type="radio" />            <p>支持自定义颜色</p>            </div><div class='checkbox green'><input type="radio" />            <p>绿色</p>            </div><div class='checkbox yellow'><input type="radio" />            <p>黄色</p>            </div><div class='checkbox cyan'><input type="radio" />            <p>青色</p>            </div><div class='checkbox blue'><input type="radio" />            <p>蓝色</p>            </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="默认名称-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% radio 纯文本测试 %&#125;</span><br><span class="line">&#123;% radio checked, 支持简单的 [markdown](https:&#x2F;&#x2F;guides.github.com&#x2F;features&#x2F;mastering-markdown&#x2F;) 语法 %&#125;</span><br><span class="line">&#123;% radio red, 支持自定义颜色 %&#125;</span><br><span class="line">&#123;% radio green, 绿色 %&#125;</span><br><span class="line">&#123;% radio yellow, 黄色 %&#125;</span><br><span class="line">&#123;% radio cyan, 青色 %&#125;</span><br><span class="line">&#123;% radio blue, 蓝色 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="时间轴"><a class="header-anchor" href="#时间轴"></a>时间轴</h2><div class="tabs" id="默认名称"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#默认名称-1">样式示例</button></li><li class="tab"><button type="button" data-href="#默认名称-2">对应源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="默认名称-1"><div class="timeline"><div class="timenode"><div class="meta"><p><p>2020-07-24 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases">2.6.6 -&gt; 3.0</a></p></p></div><div class="body"><ol><li>如果有 <code>hexo-lazyload-image</code> 插件，需要删除并重新安装最新版本，设置 <code>lazyload.isSPA: true</code>。</li><li>2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 <code>use_cdn: true</code> 则需要删除。</li><li>2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。</li><li>2.x 版本的置顶 <code>top: true</code> 改为了 <code>pin: true</code>，并且同样适用于 <code>layout: page</code> 的页面。</li><li>如果使用了 <code>hexo-offline</code> 插件，建议卸载，3.0 版本默认开启了 pjax 服务。</li></ol></div></div><div class="timenode"><div class="meta"><p><p>2020-05-15 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.6">2.6.3 -&gt; 2.6.6</a></p></p></div><div class="body"><p>不需要额外处理。</p></div></div><div class="timenode"><div class="meta"><p><p>2020-04-20 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3">2.6.2 -&gt; 2.6.3</a></p></p></div><div class="body"><ol><li>全局搜索 <code>seotitle</code> 并替换为 <code>seo_title</code>。</li><li>group 组件的索引规则有变，使用 group 组件的文章内，<code>group: group_name</code> 对应的组件名必须是 <code>group_name</code>。</li><li>group 组件的列表名优先显示文章的 <code>short_title</code> 其次是 <code>title</code>。</li></ol></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="默认名称-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;% timeline %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% timenode 2020-07-24 [2.6.6 -&gt; 3.0](https:&#x2F;&#x2F;github.com&#x2F;volantis-x&#x2F;hexo-theme-volantis&#x2F;releases) %&#125;</span><br><span class="line"></span><br><span class="line">1. 如果有 &#96;hexo-lazyload-image&#96; 插件，需要删除并重新安装最新版本，设置 &#96;lazyload.isSPA: true&#96;。</span><br><span class="line">2. 2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 &#96;use_cdn: true&#96; 则需要删除。</span><br><span class="line">3. 2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。</span><br><span class="line">4. 2.x 版本的置顶 &#96;top: true&#96; 改为了 &#96;pin: true&#96;，并且同样适用于 &#96;layout: page&#96; 的页面。</span><br><span class="line">5. 如果使用了 &#96;hexo-offline&#96; 插件，建议卸载，3.0 版本默认开启了 pjax 服务。</span><br><span class="line"></span><br><span class="line">&#123;% endtimenode %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% timenode 2020-05-15 [2.6.3 -&gt; 2.6.6](https:&#x2F;&#x2F;github.com&#x2F;volantis-x&#x2F;hexo-theme-volantis&#x2F;releases&#x2F;tag&#x2F;2.6.6) %&#125;</span><br><span class="line"></span><br><span class="line">不需要额外处理。</span><br><span class="line"></span><br><span class="line">&#123;% endtimenode %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% timenode 2020-04-20 [2.6.2 -&gt; 2.6.3](https:&#x2F;&#x2F;github.com&#x2F;volantis-x&#x2F;hexo-theme-volantis&#x2F;releases&#x2F;tag&#x2F;2.6.3) %&#125;</span><br><span class="line"></span><br><span class="line">1. 全局搜索 &#96;seotitle&#96; 并替换为 &#96;seo_title&#96;。</span><br><span class="line">2. group 组件的索引规则有变，使用 group 组件的文章内，&#96;group: group_name&#96; 对应的组件名必须是 &#96;group_name&#96;。</span><br><span class="line">2. group 组件的列表名优先显示文章的 &#96;short_title&#96; 其次是 &#96;title&#96;。</span><br><span class="line"></span><br><span class="line">&#123;% endtimenode %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="链接卡片"><a class="header-anchor" href="#链接卡片"></a>链接卡片</h2><div class="tabs" id="默认名称"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#默认名称-1">样式示例</button></li><li class="tab"><button type="button" data-href="#默认名称-2">对应源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="默认名称-1"><div class="tag link"><a class="link-card" title="糖果屋教程贴" href="https://akilar.top/posts/615e2dec/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/Akilarlxh/akilarlxh.github.io/img/siteicon/favicon.ico"/></div><div class="right"><p class="text">糖果屋教程贴</p><p class="url">https://akilar.top/posts/615e2dec/</p></div></a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="默认名称-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% link 糖果屋教程贴, https:&#x2F;&#x2F;akilar.top&#x2F;posts&#x2F;615e2dec&#x2F;, https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;Akilarlxh&#x2F;akilarlxh.github.io&#x2F;img&#x2F;siteicon&#x2F;favicon.ico %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="github-卡片-ghcard"><a class="header-anchor" href="#github-卡片-ghcard"></a>github 卡片 ghcard</h2><h3 id="用户信息卡片"><a class="header-anchor" href="#用户信息卡片"></a>用户信息卡片</h3><div class="tabs" id="默认名称"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#默认名称-1">样式示例</button></li><li class="tab"><button type="button" data-href="#默认名称-2">对应源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="默认名称-1"><table><thead><tr><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/Lanqilu"><img src="https://github-readme-stats.vercel.app/api/?username=Lanqilu&show_owner=true"/></a></th><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/Lanqilu"><img src="https://github-readme-stats.vercel.app/api/?username=Lanqilu&theme=vue&show_owner=true"/></a></th></tr></thead><tbody><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/Lanqilu"><img src="https://github-readme-stats.vercel.app/api/?username=Lanqilu&theme=buefy&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/Lanqilu"><img src="https://github-readme-stats.vercel.app/api/?username=Lanqilu&theme=solarized-light&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/Lanqilu"><img src="https://github-readme-stats.vercel.app/api/?username=Lanqilu&theme=onedark&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/Lanqilu"><img src="https://github-readme-stats.vercel.app/api/?username=Lanqilu&theme=solarized-dark&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/Lanqilu"><img src="https://github-readme-stats.vercel.app/api/?username=Lanqilu&theme=algolia&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/Lanqilu"><img src="https://github-readme-stats.vercel.app/api/?username=Lanqilu&theme=calm&show_owner=true"/></a></td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="默认名称-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| &#123;% ghcard Lanqilu %&#125; | &#123;% ghcard Lanqilu, theme&#x3D;vue %&#125; |</span><br><span class="line">| -- | -- |</span><br><span class="line">| &#123;% ghcard Lanqilu, theme&#x3D;buefy %&#125; | &#123;% ghcard Lanqilu, theme&#x3D;solarized-light %&#125; |</span><br><span class="line">| &#123;% ghcard Lanqilu, theme&#x3D;onedark %&#125; | &#123;% ghcard Lanqilu, theme&#x3D;solarized-dark %&#125; |</span><br><span class="line">| &#123;% ghcard Lanqilu, theme&#x3D;algolia %&#125; | &#123;% ghcard Lanqilu, theme&#x3D;calm %&#125; |</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="仓库信息卡片"><a class="header-anchor" href="#仓库信息卡片"></a>仓库信息卡片</h3><div class="tabs" id="默认名称"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#默认名称-1">样式示例</button></li><li class="tab"><button type="button" data-href="#默认名称-2">对应源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="默认名称-1"><table><thead><tr><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/Lanqilu/JavaDemo"><img src="https://github-readme-stats.vercel.app/api/pin/?username=Lanqilu&repo=JavaDemo&show_owner=true"/></a></th><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/Lanqilu/JavaDemo"><img src="https://github-readme-stats.vercel.app/api/pin/?username=Lanqilu&repo=JavaDemo&theme=vue&show_owner=true"/></a></th></tr></thead><tbody><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/Lanqilu/JavaDemo"><img src="https://github-readme-stats.vercel.app/api/pin/?username=Lanqilu&repo=JavaDemo&theme=buefy&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/Lanqilu/JavaDemo"><img src="https://github-readme-stats.vercel.app/api/pin/?username=Lanqilu&repo=JavaDemo&theme=solarized-light&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/Lanqilu/JavaDemo"><img src="https://github-readme-stats.vercel.app/api/pin/?username=Lanqilu&repo=JavaDemo&theme=onedark&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/Lanqilu/JavaDemo"><img src="https://github-readme-stats.vercel.app/api/pin/?username=Lanqilu&repo=JavaDemo&theme=solarized-dark&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/Lanqilu/JavaDemo"><img src="https://github-readme-stats.vercel.app/api/pin/?username=Lanqilu&repo=JavaDemo&theme=algolia&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/Lanqilu/JavaDemo"><img src="https://github-readme-stats.vercel.app/api/pin/?username=Lanqilu&repo=JavaDemo&theme=calm&show_owner=true"/></a></td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="默认名称-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| &#123;% ghcard Lanqilu&#x2F;JavaDemo %&#125; | &#123;% ghcard Lanqilu&#x2F;JavaDemo, theme&#x3D;vue %&#125; |</span><br><span class="line">| -- | -- |</span><br><span class="line">| &#123;% ghcard Lanqilu&#x2F;JavaDemo, theme&#x3D;buefy %&#125; | &#123;% ghcard Lanqilu&#x2F;JavaDemo, theme&#x3D;solarized-light %&#125; |</span><br><span class="line">| &#123;% ghcard Lanqilu&#x2F;JavaDemo, theme&#x3D;onedark %&#125; | &#123;% ghcard Lanqilu&#x2F;JavaDemo, theme&#x3D;solarized-dark %&#125; |</span><br><span class="line">| &#123;% ghcard Lanqilu&#x2F;JavaDemo, theme&#x3D;algolia %&#125; | &#123;% ghcard Lanqilu&#x2F;JavaDemo, theme&#x3D;calm %&#125; |</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="音频"><a class="header-anchor" href="#音频"></a>音频</h2><div class="tabs" id="默认名称"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#默认名称-1">样式示例</button></li><li class="tab"><button type="button" data-href="#默认名称-2">对应源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="默认名称-1"><p>歌曲名：<a href="https://music.163.com/#/song?id=1398894062">从远方奔赴一场</a></p><div class="note danger no-icon flat"><p>danger 播放时注意调整音量</p></div><div class="audio"><audio controls preload><source src='http://onedrive.whl123456.top/video/%E6%88%91%E7%9A%84%E8%A7%86%E9%A2%91%E5%BA%93/%E4%BB%8E%E8%BF%9C%E6%96%B9%E5%A5%94%E8%B5%B4%E4%B8%80%E5%9C%BA.mp3' type='audio/mp3'>Your browser does not support the audio tag.</audio></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="默认名称-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% audio http:&#x2F;&#x2F;onedrive.whl123456.top&#x2F;video&#x2F;%E6%88%91%E7%9A%84%E8%A7%86%E9%A2%91%E5%BA%93&#x2F;%E4%BB%8E%E8%BF%9C%E6%96%B9%E5%A5%94%E8%B5%B4%E4%B8%80%E5%9C%BA.mp3 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="视频"><a class="header-anchor" href="#视频"></a>视频</h2><div class="tabs" id="默认名称"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#默认名称-1">样式示例</button></li><li class="tab"><button type="button" data-href="#默认名称-2">对应源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="默认名称-1"><div class="videos" col='1'><div class="video"><video controls preload><source src='http://onedrive.whl123456.top/video/%E6%88%91%E7%9A%84%E8%A7%86%E9%A2%91%E5%BA%93/%E7%BE%8E%E5%88%B0%E7%AA%92%E6%81%AF%E7%9A%84%E4%BA%AC%E9%98%BF%E5%B0%BC-Lifeisbeautiful.67833543.mp4' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='http://onedrive.whl123456.top/video/%E6%88%91%E7%9A%84%E8%A7%86%E9%A2%91%E5%BA%93/%E3%80%90RADWIMPS%E3%80%91%E3%80%8A%E5%A4%A9%E6%B0%94%E4%B9%8B%E5%AD%90%E3%80%8B%E7%89%87%E4%B8%AD%E6%9B%B2%E3%80%8E%E3%82%B0%E3%83%A9%E3%83%B3%E3%83%89%E3%82%A8%E3%82%B9%E3%82%B1%E3%83%BC%E3%83%97%E3%80%8F%E5%AE%8C%E6%95%B4%E7%89%88MV%E3%80%90%E4%B8%AD%E5%AD%97%E3%80%91.125772545.mp4' type='video/mp4'>Your browser does not support the video tag.</video></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="默认名称-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% videos, 1 %&#125;</span><br><span class="line">&#123;% video http:&#x2F;&#x2F;onedrive.whl123456.top&#x2F;video&#x2F;%E6%88%91%E7%9A%84%E8%A7%86%E9%A2%91%E5%BA%93&#x2F;%E7%BE%8E%E5%88%B0%E7%AA%92%E6%81%AF%E7%9A%84%E4%BA%AC%E9%98%BF%E5%B0%BC-Lifeisbeautiful.67833543.mp4 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% video http:&#x2F;&#x2F;onedrive.whl123456.top&#x2F;video&#x2F;%E6%88%91%E7%9A%84%E8%A7%86%E9%A2%91%E5%BA%93&#x2F;%E3%80%90RADWIMPS%E3%80%91%E3%80%8A%E5%A4%A9%E6%B0%94%E4%B9%8B%E5%AD%90%E3%80%8B%E7%89%87%E4%B8%AD%E6%9B%B2%E3%80%8E%E3%82%B0%E3%83%A9%E3%83%B3%E3%83%89%E3%82%A8%E3%82%B9%E3%82%B1%E3%83%BC%E3%83%97%E3%80%8F%E5%AE%8C%E6%95%B4%E7%89%88MV%E3%80%90%E4%B8%AD%E5%AD%97%E3%80%91.125772545.mp4 %&#125;</span><br><span class="line">&#123;% endvideos %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><div class="tabs" id="默认名称"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#默认名称-1">样式示例</button></li><li class="tab"><button type="button" data-href="#默认名称-2">对应源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="默认名称-1"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="默认名称-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
    
    
    <summary type="html">外挂标签测试使用</summary>
    
    
    
    <category term="测试" scheme="http://halo123.top/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="测试" scheme="http://halo123.top/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>线性代数——行列式</title>
    <link href="http://halo123.top/2021/04/23/LinearAlgebra/A_Determinant/"/>
    <id>http://halo123.top/2021/04/23/LinearAlgebra/A_Determinant/</id>
    <published>2021-04-23T03:26:54.000Z</published>
    <updated>2021-04-23T06:52:41.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二阶与三阶行列式"><a class="header-anchor" href="#二阶与三阶行列式"></a>二阶与三阶行列式</h2><p>二阶行列式，记作：</p><div>$$\begin{vmatrix}  a_{1} & a_{2}\\  b_{1} & b_{2}\end{vmatrix}$$</div><p>三阶行列式，记作：</p><div>$$\begin{vmatrix}a_{1} & a_{2} & a_{3}\\b_{1} & b_{2} & b_{3}\\c_{1} & c_{2} & c_{3}\end{vmatrix}$$</div><div>$$\begin{vmatrix} a_{1} & a_{2} & a_{3}\\ b_{1} & b_{2} & b_{3}\\ c_{1} & c_{2} & c_{3}\end{vmatrix}= a_{1}b_{2}c_{3}+a_{2}b_{3}c_{1}+a_{3}b_{1}c_{2}-a_{3}b_{2}c_{1}-a_{1}b_{3}c_{2}$$</div><p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E4%B8%89%E9%98%B6%E8%A1%8C%E5%88%97%E5%BC%8F%E7%9A%84%E8%AE%A1%E7%AE%97.png" alt="三阶行列式的计算"></p><h2 id="全排列和对换"><a class="header-anchor" href="#全排列和对换"></a>全排列和对换</h2><h3 id="排列及其逆序数"><a class="header-anchor" href="#排列及其逆序数"></a>排列及其逆序数</h3><p>把$n$个不同的元素排成一列，叫做这$n$个元素的全排列（也简称<font color="#ea66a6">排列</font>）<br>$n$个不同元素的所有排列的种数，通常用$P_{n}$表示：</p><span>$$P_{n}=n\cdot(n-1)\cdot\dots\cdot3\cdot2\cdot1=n!$$</span>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;二阶与三阶行列式&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#二阶与三阶行列式&quot;&gt;&lt;/a&gt;二阶与三阶行列式&lt;/h2&gt;
&lt;p&gt;二阶行列式，记作：&lt;/p&gt;
&lt;div&gt;
$$\begin{vmatrix}
  a_{1} &amp; a_{2}\\
  b</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>物理层</title>
    <link href="http://halo123.top/2021/04/22/ComputerNetworks/B_PhysicalLayer/"/>
    <id>http://halo123.top/2021/04/22/ComputerNetworks/B_PhysicalLayer/</id>
    <published>2021-04-22T14:22:00.631Z</published>
    <updated>2021-04-22T14:24:39.061Z</updated>
    
    <content type="html"><![CDATA[<h2 id="物理层的基本概念"><a class="header-anchor" href="#物理层的基本概念"></a>物理层的基本概念</h2><p>物理层解决如何在连接各种计算机的传输媒体上<font color="#FF666">传输数据比特流</font>，而不是指具体的传输媒体。</p><p>物理层主要任务:确定与传输媒体<font color="#faa755">接口</font>有关的一些特性(定义标准)</p><ol><li><p>机械特性:定义物理连接的特性，规定物理连接时所采用的规格、接口形状、<font color="#faa755">引线数目</font>、<font color="#faa755">引脚数量</font>和排列情况。</p></li><li><p>电气特性:规定传输二进制位时，线路上信号的<font color="#faa755">电压范围</font>、阻抗匹配、传输<font color="#faa755">速率</font>和<font color="#faa755">距离</font>限制等。</p><blockquote><p>某网络在物理层规定，信号的电平用+10V<sub>+15V表示二进制0，用-10V</sub>-15V表示二进制1，电线长度限于15m以内</p></blockquote></li><li><p>功能特性:指明某条线上出现的某一<font color="#faa755">电平表示何种意义</font>，接口部件的信号线的用途。</p><blockquote><p>描述一个物理层接口引脚处于高电平时的含义时</p></blockquote></li><li><p>规程特性:(过程特性) 定义各条物理线路的工作<font color="#faa755">规程和时序</font>关系。</p></li></ol><h1>通信基础</h1><h2 id="1-基本概念"><a class="header-anchor" href="#1-基本概念"></a>1 基本概念</h2><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B8%E5%9E%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B.png" alt="典型的数据通信模型" style="object-fit: cover; border-radius: 10px; width: 100%;" /><p>通信的目的是<font color="#faa755">传送信息</font>。</p><p><font color="#ea66a6">数据</font>:传送信息的实体，通常是有意义的符号序列。</p><p><font color="#ea66a6">信号</font>:数据的电气或电磁的表现，是数据在传输过程中的<font color="#faa755">存在形式</font>。</p><ul><li>数字信号:代表消息的参数取值是离散的。取值仅允许为有限的几个离散数值的数据(或信号)称为数字数据(或数字信号)。</li><li>模拟信号:代表消息的参数取值是连续的。连续变化的数据(或信号)称为模拟数据(或模拟信号);</li></ul><p><font color="#ea66a6">信源</font>:产生和发送数据的源头。</p><p><font color="#ea66a6">信宿</font>:接收数据的终点。</p><p><font color="#ea66a6">信道</font>:信号的传输媒介。一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接收信道。</p><ul><li><p>信道按传输<font color="#ef5b9c">信号形式</font>的不同可分为传送模拟信号的<font color="#faa755">模拟信道</font>和传送数字信号的<font color="#faa755">数字信道</font>两大类;</p></li><li><p>信道按传输<font color="#ef5b9c">介质</font>的不同可分为<font color="#faa755">无线信道</font>和<font color="#faa755">有线信道</font>。</p></li></ul><p>从通信双方信息的交互方式看，可分为三种基本方式:</p><ol><li><font color="#ea66a6">单工通信</font>。只有一个方向的通信而没有反方向的交互，仅需要<font color="#FF666">一条</font>信道。例如，无线电广播、电视广播就属于这种类型。</li><li><font color="#ea66a6">半双工通信</font>。通信的双方都可以发送或接收信息，但任何一方都<font color="#faa755">不能同时</font>发送和接收信息，此时需要<font color="#FF666">两条</font>信道。(对讲机)</li><li><font color="#ea66a6">全双工通信</font>。通信双方可以同时发送和接收信息，也需要<font color="#FF666">两条</font>信道。</li></ol><p>数据传输方式可分为串行传输和并行传输。</p><ul><li><font color="#ea66a6">串行传输</font>是指一个一个的比特按照时间顺序传输(出于经济上的考虑，远距离通信通常采用串行传输)</li><li><font color="#ea66a6">并行传输</font>是指多个比特通过多条通信信道同时传输。</li></ul><hr><p><font color="#ea66a6">码元</font>是指用一个<font color="#FF666">固定时长</font>的<font color="#FF666">信号波形</font>(数字脉冲)表示一位k进制数字，代表不同离散数值的基本波形，是数字通信中数字信号的计量单位，这个时长内的信号称为<font color="#ea66a6">k进制码元</font>，而该时长称为<font color="#ea66a6">码元宽度</font>。1码元可以携带多个比特的信息量。例如，在使用二进制编码时，只有两种不同的码元: 一种代表0状态，另一种代表1状态。</p><p>速率也称数据率，指的是数据的<font color="#FF666">传输速率</font>，表示单位时间内传输的数据量。可以用<font color="#faa755">码元传输速率</font>和<font color="#faa755">信息传输速率</font>表示。</p><ul><li><font color="#ea66a6">码元传输速率</font>。又称码元速率、波形速率、调制速率、符号速率等，它表示单位时间内数字通信系统所传输的码元个数(也可称为<font color="#faa755">脉冲个数或信号变化的次数</font>)，单位是<font color="#FF666">波特</font>(Baud)。 1波特表示数字通信系统每秒传输一个码元。这里的码元可以是多进制的，也可以是二进制的，但码元速率与进制数无关。<font color="#FF666">1s传输多少个码元</font></li><li><font color="#ea66a6">信息传输速率</font>。又称信息速率、比特率等，它表示单位时间内数字通信系统传输的二进制码元个数(即比特数)，单位是比特/秒(b/s)。<font color="#FF666">1s传输多少个比特</font></li></ul><blockquote><p>关系:<font color="#faa755">若一个码元携带n比特的信息量，则M波特率的码元传输速率所对应的信息传输速率为M×n bit/s</font>。</p></blockquote><p><font color="#ea66a6">带宽</font>:表示在单位时间内从网络中的某一点到另一点所能通过的“<font color="#faa755">最高数据率</font>”，常用来表示网络的通信线路所能传输数据的能力。单位是b/s。</p><h2 id="font-color-d9730d-2-奈奎斯特定理与香农定理-font"><a class="header-anchor" href="#font-color-d9730d-2-奈奎斯特定理与香农定理-font"></a><font color="#d9730d">2 奈奎斯特定理与香农定理</font></h2><p>影响失真程度的影响因素:</p><ol><li>码元传输速率,速率越快失真越严重</li><li>信号传输距离,距离越远失真越严重</li><li>噪声干扰,干扰越多失真越严重</li><li>传输媒体质量,质量越差失真越严重</li></ol><p>具体的信道所能通过的频率范围总是有限的(信道带宽).信号中的许多高频分量往往不能通过信道,否则在传输中会衰减,导致接收端收到的信号波形<font color="#faa755">失去码元之间清晰界限</font>,这种现象称为<font color="#ea66a6">码间串扰</font></p><p><font color="#ea66a6">信道带宽</font>:是信道能通过的最高频率和最低频率之差.</p><h3 id="奈奎斯特定理"><a class="header-anchor" href="#奈奎斯特定理"></a>奈奎斯特定理</h3><p>奈奎斯特(Nyquist)定理又称<font color="#ea66a6">奈氏准则</font>，它指出在理想低通(没有噪声、带宽有限)的信道中，极限码元传输率为2W波特，其中<font color="#faa755">W</font>是理想低通信道的带宽，单位为<font color="#FF666">Hz</font>。若用<font color="#faa755">V</font>表示每个码元离散电平的数目(码元的离散电平数目是指有多少种不同的码元，比如有16种不同的码元，则需要4位二进制位，因此数据传输率是码元传输率的4倍)，则极限数据率为</p><p>理想低通信道下的极限数据传输率= 2W log<sub>2</sub>V (单位为b/s)</p><p>对于奈氏准则，可以得出以下结论:</p><ol><li>在任何信道中，码元传输的速率是有上限的。若传输速率超过此上限，就会出现严重的码间串扰问题(指在接收端收到的信号波形失去了码元之间的清晰界限)，使得接收端不可能完全正确识别码元。</li><li>信道的频带越宽(即通过的信号高频分量越多)，就可用更高的速率进行码元的有效传输。</li><li>奈氏准则给出了码元传输速率的限制，但并未对信息传输速率给出限制，即未对一个码元可以对应多少个二进制位给出限制。</li></ol><p>由于码元的传输速率受奈氏准则的制约，所以要提高数据的传输速率，就必须设法使每个码元携带更多个比特的信息量，此时就需要采用多元制的调制方法。</p><h3 id="香农定理"><a class="header-anchor" href="#香农定理"></a>香农定理</h3><p><font color="#ea66a6">噪声</font>存在于所有的电子设备和通信信道中。由于噪声随机产生，它的瞬时值有时会很大，因此噪声会使接收端对码元的判决产生错误。但是噪声的影响是相对的，若信号较强，那么噪声影响相对较小。因此，<font color="#ea66a6">信噪比</font>就很重要。</p><p>香农(Shannon)定理给出了带宽受限且有高斯白噪声干扰的信道的极限数据传输率，当用此速率进行传输时，可以做到不产生误差。香农定理定义为</p><p><font color="#faa755">信道的极限数据传输率 = Wlog<sub>2</sub>(1+S/N) (单位为b/s)</font></p><p>式中，W为信道的带宽，S为信道所传输信号的平均功率，N为信道内部的高斯噪声功率。S/N为信噪比，即信号的平均功率与噪声的平均功率之比，<font color="#FF666">信噪比 = 10log<sub>10</sub>(S/N) (单位为dB)</font>，例如如当S/N= 10时，信噪比为10dB，而当S/N= 1000时，信噪比为30dB。</p><p>对于香农定理，可以得出以下结论:</p><ol><li>信道的带宽或信道中的信噪比越大，信息的极限传输速率越高。</li><li>对一定的传输带宽和一定的信噪比，信息传输速率的上限是确定的。</li><li>只要信息的传输速率低于信道的极限传输速率，就能找到某种方法来实现无差错的传输。</li><li>香农定理得出的是极限信息传输速率，实际信道能达到的传输速率要比它低不少。</li></ol><p>从香农定理可以看出，若信道带宽W或信噪比SIN没有上限(实际信道当然不可能这样)，则信道的极限信息传输速率也没有上限。</p><p>奈氏准则只考虑了带宽与极限码元传输速率的关系，而香农定理不仅考虑到了带宽，也考虑到了信噪比。这从另一个侧面表明，一个码元对应的二进制位数是有限的。</p><h2 id="3-编码与调制"><a class="header-anchor" href="#3-编码与调制"></a>3 编码与调制</h2><p>信道上传送信号的两种形式:基带信号和宽带信号</p><ul><li><p>基带信号:将数字信号1和0直接用两种不同的电压表示，再送到<font color="#faa755">数字信道</font>上去传输(<font color="#faa755">基带传输</font>)</p><blockquote><p><font color="#ef5b9c">来自信源的信号</font>，像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。基带信号就是发出的直接表达了要传输的信息的信号，比如我们说话的声波就是基带信号。</p></blockquote></li><li><p>宽带信号:将基带信号进行调制后形成的频分复用模拟信号，再传送到<font color="#faa755">模拟信道</font>上去传输(<font color="#faa755">宽带传输</font>)</p><blockquote><p>把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输(即仅在一段频率范围内能够通过信道)。</p></blockquote></li></ul><p>在传输距离较<font color="#faa755">近</font>时，计算机网络采用<font color="#ef5b9c">基带传输</font>方式(近距离衰减小，从而信号内容不易发生变化)</p><p>在传输距离较<font color="#faa755">远</font>时，计算机网络采用<font color="#ef5b9c">宽带传输</font>方式(远距离衰减大，即使信号变化大也能最后过滤出来基带信号)</p><h3 id="数字数据编码为数字信号"><a class="header-anchor" href="#数字数据编码为数字信号"></a>数字数据编码为数字信号</h3><p>数字数据编码用于基带传输中，即在基本不改变数字数据信号频率的情况下，直接传输数字信号。具体用什么样的数字信号表示0及用什么样的数字信号表示1就是所谓的编码。编码的规则有多种，只要能有效地把1和0区分开即可，常用的编码方式有以下几种，如下图所示。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E5%AD%97%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F.png" alt="常用的数字数据编码方式" style="object-fit: cover; border-radius: 10px; width: 80%;" /><ol><li><p>归零编码(RZ)</p><p>在归零编码中用高电平代表1、低电平代表0 (或者相反)，每个时钟周期的中间均跳变到低电平(归零)，接收方根据该跳变调整本方的时钟基准，这就为传输双方提供了自同步机制。由于归零需要占用一部分带宽，因此传输效率受到了一定的影响。</p></li><li><p>非归零编码(NRZ)</p><p>非归零编码与RZ编码的区别是不用归零,一个周期可以全部用来传输数据。但NRZ编码无法传递时钟信号，双方难以同步，因此若想传输高速同步数据，则需要都带有时钟线。</p></li><li><p>反向非归零编码(NRZI)</p><p>反向非归零码与NRZ编码的区别是用信号的翻转代表0、信号保持不变代表1。翻转的信号本身可以作为一种通知机制。这种编码方式集成了前两种编码的优点，既能传输时钟信号，又能尽量不损失系统带宽。USB2.0通信的编码方式就是NRZI编码。</p></li><li><p>曼彻斯特编码(Manchester Encoding)</p><p>曼彻斯特编码将一个码元分成两个相等的间隔，前一个间隔为高电平而后一个间隔为低电平表示码元1;码元0的表示方法则正好相反。当然，也可采用相反的规定。该编码的特点是，在每个码元的中间出现电平跳变，位中间的跳变既作为时钟信号(可用于同步)，又作为数据信号，但它所占的频带宽度是原始基带宽度的两倍。<font color="#faa755">以太网使用的编码方式就是曼彻斯特编码</font>。</p></li><li><p>差分曼彻斯特编码</p><p>差分曼彻斯特编码常用于局域网传输,其规则是,若码元为1,则前半个码元的电平与上一个码元的后半个码元的电平相同;若码元为0，则情形相反。该编码的特点是，在每个码元的中间都有一次电平的跳转，可以实现自同步，且<font color="#faa755">抗干扰性较好</font>。</p></li><li><p>4B/5B编码</p><p>将欲发送数据流的每4位作为一组，然后按照4B/5B编码规则将其转换成相应的5位码。5位码共32种组合，但只采用其中的16种对应16种不同的4位码，其他的16种作为控制码(帧的开始和结束、线路的状态信息等)或保留。</p></li></ol><h3 id="数字数据调制为模拟信号"><a class="header-anchor" href="#数字数据调制为模拟信号"></a>数字数据调制为模拟信号</h3><p>数字数据调制技术在发送端将数字信号转换为模拟信号,而在接收端将模拟信号还原为数字信号，分别对应于调制解调器的调制和解调过程。基本的调制方法有如下几种:</p><ol><li>幅移键控(ASK)。通过改变载波信号的振幅来表示数字信号1和0，而载波的频率和相位都不改变。比较容易实现，但抗干扰能力差。调幅(AM)</li><li>频移键控(FSK)。 通过改变载波信号的频率来表示数字信号1和0，而载波的振幅和相位都不改变。容易实现，抗干扰能力强，目前应用较为广泛。调频(FM)</li><li>相移键控(PSK)。 通过改变载波信号的相位来表示数字信号1和0，而载波的振幅和频率都不改变。它又分为绝对调相和相对调相。调相</li><li>正交振幅调制(QAM)。在频率相同的前提下，将ASK与PSK结合起来，形成叠加信号。设波特率为B,采用m个相位，每个相位有n种振幅，则该QAM技术的数据传输率R为:R= Blog<sub>2</sub>(mn) (单位为b/s).调幅+调相</li></ol><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E5%AD%97%E8%B0%83%E5%88%B6%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F.png" alt="数字调制的三种方式" style="object-fit: cover; border-radius: 10px; width: 900%;" /><h3 id="模拟数据编码为数字信号"><a class="header-anchor" href="#模拟数据编码为数字信号"></a>模拟数据编码为数字信号</h3><p>这种编码方式最典型的例子是常用于对音频信号进行编码的<font color="#ea66a6">脉码调制(PCM)</font>。它主要包括三个步骤，即采样、量化和编码。</p><p><font color="#ea66a6">采样定理</font>:在通信领域，带宽是指信号最高频率与最低频率之差，单位为Hz。因此，将模拟信号转换成数字信号时，假设原始信号中 的最大频率为$f$,那么采样频率$f_{采样}$必须大于等于最大频率$f$的两倍，才能保证采样后的数字信号完整保留原始模拟信号的信息(只需记住结论)。另外，采样定理又称奈奎斯特定理。</p><ol><li><font color="#ea66a6">采样</font>:是指对模拟信号进行周期性扫描，把时间上连续的信号变成时间上离散的信号。根据采样定理，当采样的频率大于等于模拟数据的频带带宽(最高变化频率)的两倍时，所得的离散信号可以无失真地代表被采样的模拟数据。</li><li><font color="#ea66a6">量化</font>:是把采样取得的电平幅值按照一定的分级标度转化为对应的数字值并取整数，这样就把连续的电平幅值转换为了离散的数字量。采样和量化的实质就是分割和转换。</li><li><font color="#ea66a6">编码</font>:是把量化的结果转换为与之对应的二进制编码。</li></ol><h3 id="模拟数据调制为模拟信号"><a class="header-anchor" href="#模拟数据调制为模拟信号"></a>模拟数据调制为模拟信号</h3><p>为了实现传输的有效性，可能需要较高的频率。这种调制方式还可以使用频分复用(FDM)技术，充分利用带宽资源。电话机和本地局交换机采用模拟信号传输模拟数据的编码方式;模拟的声音数据是加载到模拟的载波信号中传输的。</p><h3 id="4-电路交换、报文交换与分组交换"><a class="header-anchor" href="#4-电路交换、报文交换与分组交换"></a>4 电路交换、报文交换与分组交换</h3><p>P40</p><h1>传输介质</h1><p><font color="#ea66a6">传输介质</font>也称传输媒体，它是发送设备和接收设备之间的<font color="#faa755">物理通路</font>。</p><blockquote><p><font color="#faa755">传输媒体并不是物理层</font>。传输媒体在物理层的下面，因为物理层是体系结构的第一层， 因此有时称传输媒体为0层。在传输媒体中传输的是信号，但传输媒体并不知道所传输的信号代表什么意思。但物理层规定了电气特性，因此能够识别所传送的比特流。</p></blockquote><p>传输介质可分为导向传输介质和非导向传输介质。</p><ul><li><font color="#ea66a6">导向传输介质</font>中，电磁波被导向沿着固体媒介(铜线或光纤)传播</li><li><font color="#ea66a6">非导向传输介质</font>可以是空气、真空或海水等</li></ul><h2 id="双绞线、同轴电缆、光纤与无线传输介质"><a class="header-anchor" href="#双绞线、同轴电缆、光纤与无线传输介质"></a>双绞线、同轴电缆、光纤与无线传输介质</h2><h3 id="双绞线"><a class="header-anchor" href="#双绞线"></a>双绞线</h3><p>双绞线是最常用的古老传输介质,它由两根采用一定规则并排绞合的、相互绝缘的铜导线组成。<font color="#faa755">绞合可以减少对相邻导线的电磁干扰</font>。</p><p>为了进一步提高抗电磁干扰能力，可在双绞线的外面再加上一个由<font color="#faa755">金属丝</font>编织成的屏蔽层，这就是屏蔽双绞线(STP)。无屏蔽层的双绞线称为非屏蔽双绞线(UTP)。</p><p>它们的结构如图下所示。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%8F%8C%E7%BB%9E%E7%BA%BF%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="双绞线的结构" style="object-fit: cover; border-radius: 10px; width: 100%;" /><p>双绞线价格便宜，是最常用的传输介质之一，在局域网和传统电话网中普遍使用。</p><p>双绞线的带宽取决于铜线的粗细和传输的距离。</p><p>模拟传输和数字传输都可使用双绞线，其通信距离一般为几千米到数十千米。</p><p>距离太远时，对于<font color="#ef5b9c">模拟传输</font>，要用<font color="#ef5b9c">放大器</font>放大衰减的信号;对于<font color="#faa755">数字传输</font>，要用<font color="#faa755">中继器</font>将失真的信号整形。</p><h3 id="同轴电缆"><a class="header-anchor" href="#同轴电缆"></a>同轴电缆</h3><p>同轴电缆由内导体、绝缘层、网状编织屏蔽层和塑料外层构成，如下图所示。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%90%8C%E8%BD%B4%E7%94%B5%E7%BC%86%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="同轴电缆的结构" style="object-fit: cover; border-radius: 10px; width: 80%;" /><p>按特性阻抗数值的不同，通常将同轴电缆分为两类: 50Ω同轴电缆和75Ω同轴电缆。</p><ul><li>50Ω同轴电缆主要用于传送基带数字信号，又称<font color="#ea66a6">基带同轴电缆</font>，它在局域网中应用广泛;</li><li>75Ω同轴电缆主要用于传送宽带信号，又称<font color="#ea66a6">宽带同轴电缆</font>，主要用于有线电视系统。</li></ul><p>由于外导体屏蔽层的作用，同轴电缆具有良好的抗干扰特性，被广泛用于传输较高速率的数据，其传输距离更远，但价格较双绞线贵。</p><h3 id="光纤"><a class="header-anchor" href="#光纤"></a>光纤</h3><p>光纤通信就是利用光导纤维(简称光纤)传递光脉冲来进行通信。有光脉冲表示1，无光脉冲表示0。可见光的频率约为10<sup>8</sup>MHz，因此光纤通信系统的带宽范围极大。</p><p>光纤在发送端有光源，可以采用发光二极管或半导体激光器，它们在电脉冲作用下能产生出光脉冲;在接收端用光电二极管做成光检测器，在检测到光脉冲时可还原出电脉冲。</p><p>光纤主要由<font color="#faa755">纤心</font>和<font color="#faa755">包层</font>构成，光波通过纤心进行传导，包层较纤心有较低的折射率。当光线从高折射率的介质射向低折射率的介质时，其折射角大于入射角。因此，如果入射角足够大，那么就会出现全反射，即光线碰到包层时会折射回纤心，这个过程不断重复，光也就沿着光纤传输下去。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%89%E6%B3%A2%E5%9C%A8%E7%BA%A4%E5%BF%83%E4%B8%AD%E7%9A%84%E4%BC%A0%E6%92%AD.png" alt="光波在纤心中的传播" style="object-fit: cover; border-radius: 10px; width: 100%;" /><p>只要从纤心中射到纤心表面的光线的入射角大于某个临界角度，就会产生全反射。因此，从不同角，度入射的多束光线可在一条光纤中传输， 这种光纤称为<font color="#ea66a6">多模光纤</font>，多模光纤的光源为<font color="#faa755">发光二极管</font>。光脉冲在多模光纤中传输时会逐渐展宽，造成失真，因此多模光纤只适合于<font color="#faa755">近距离传输</font>。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%A4%9A%E6%A8%A1%E5%85%89%E7%BA%A4.png" alt="多模光纤" style="object-fit: cover; border-radius: 10px; width: 100%;" /><p>光纤的直径减小到仅一个光波长度时，光纤就像一根波导 那样，可使光线一直向前传播， 而不会产生多次反射，这样的光纤就是单模光纤。 单模光纤的纤心很细，直径只有几微米，制造成本较高。同时，单模光纤的光源为<font color="#faa755">定向性很好的激光二极管</font>，因此单模光纤的衰减较小，适合<font color="#faa755">远距离传输</font>。</p><p>光纤的特点:</p><ol><li>传输损耗小，中继距离长，对远距离传输特别经济。</li><li>抗雷电和电磁干扰性能好。</li><li>无串音干扰，保密性好，也不易被窃听或截取数据。</li><li>体积小，重量轻。</li></ol><h3 id="无线传输介质（非导向传播介质）"><a class="header-anchor" href="#无线传输介质（非导向传播介质）"></a>无线传输介质（非导向传播介质）</h3><p>无线通信已广泛应用于移动电话领域，构成蜂窝式无线电话网。随着便携式计算机的出现，以及在军事、野外等特殊场合下移动通信联网的需要，促进了数字化移动通信的发展，现在无线局域网产品的应用已非常普遍。</p><h4 id="无线电波"><a class="header-anchor" href="#无线电波"></a>无线电波</h4><p>无线电波具有<font color="#faa755">较强的穿透能力</font>，可以传输很长的距离，所以它被广泛应用于通信领域，如无线手机通信、计算机网络中的无线局域网(WLAN)等。因为无线电波使信号向所有方向散播,因此有效距离范围内的接收设备无须对准某个方向，就可与无线电波发射者进行通信连接，大大简化了通信连接。这也是无线电传输的最重要优点之一。</p><h4 id="微波、红外线和激光"><a class="header-anchor" href="#微波、红外线和激光"></a>微波、红外线和激光</h4><p>目前高带宽的无线通信主要使用三种技术:微波、红外线和激光。它们都需要发送方和接收方之间存在一条视线(Line-of-sight) 通路，有很强的方向性，都沿直线传播，有时统称这三者为视线介质。不同的是，红外通信和激光通信把要传输的信号分别转换为各自的信号格式，即红外光信号和激光信号，再直接在空间中传播。</p><p>微波通信的频率较高，频段范围也很宽，载波频率通常为2~40GHz,因而通信信道的容量大。例如，一个带宽为2MHz的频段可容纳500条语音线路，若用来传输数字信号，数据率可达数兆比特/秒。与通常的无线电波不同，微波通信的信号是沿直线传播的，因此在地面的传播距离有限，超过一定距离后就要用中继站来接力。</p><p>卫星通信利用地球同步卫星作为中继来转发微波信号，可以克服地面微波通信距离的限制。三颗相隔120°的同步卫星几乎能覆盖整个地球表面，因而基本能实现全球通信。卫星通信的优点是通信容量大、距离远、覆盖广、广播通信和多址通信，缺点是端到端传播时延长，一般为 250~270ms、受气候影响大（强风、太阳黑子爆发、日凌）、误码率较高、成本高。</p><h1>物理层设备</h1><h2 id="中继器"><a class="header-anchor" href="#中继器"></a>中继器</h2><p>诞生原因:由于存在损耗，在线路上传输的信号功率会逐渐衰减，衰减到一定程度时将造成信号失真，因此会导致接收错误。</p><p>中继器的功能:对信号进行<font color="#faa755">再生和还原</font>，对衰减的信号进行放大，保持与原数据相同，以增加信号传输的距离，延长网络的长度。<font color="#FF666">再生数字信号</font></p><p>中继器的两端:</p><ul><li>两端的网络部分是网段，而不是子网，适用于完全相同的两类网络的互连，且两个网段速率要相同。</li><li>中继器只将任何电缆段上的数据发送到另一段电缆上，它仅作用于信号的电气部分，并不管数据中是否有错误数据或不适于网段的数据。</li><li>两端可连相同媒体，也可连不同媒体。</li><li>中继器两端的网段一定要是同一个协议。</li></ul><p>中继器又称转发器，主要功能是将信号整形并放大再转发出去，以消除信号经过一长段电缆后，因噪声或其他原因而造成的失真和衰减，使信号的波形和强度达到所需要的要求，进而扩大网络传输的距离。其原理是信号再生(而非简单地将衰减的信号放大)。中继器有两个端口，数据从一个端口输入，再从另一个端口发出。端口仅作用于信号的电气部分，而不管数据中是否有错误数据或不适于网段的数据。</p><p>中继器是局域网环境下用来扩大网络规模的最简单、最廉价的互联设备。使用中继器连接的几个网段仍然是一个局域网。一般情况下，中继器的两端连接的是相同的媒体，但有的中继器也可以完成不同媒体的转接工作。但由于中继器工作在物理层，因此它不能连接两个具有不同速率的局域网。中继器两端的网络部分是网段，而不是子网。中继器若出现故障，对相邻两个网段的工作都将产生影响。</p><p>从理论上讲，中继器的使用数目是无限的，网络因而也可以无限延长。但事实上这不可能,因为网络标准中对信号的延迟范围做了具体的规定，<font color="#faa755">中继器只能在此规定范围内进行有效的工作，否则会引起网络故障</font>。例如，在采用粗同轴电缆的10BASE5 以太网规范中，互相串联的中继器的个数不能超过4个，而且用4个中继器串联的5段通信介质中只有3段可以挂接计算机，其余两段只能用作扩展通信范围的链路段，不能挂接计算机。这就是所谓的“<font color="#faa755">5-4-3规则</font>”。</p><blockquote><p>注意:放大器和中继器都起放大作用，只不过放大器放大的是模拟信号,原理是将衰减的信号放大，而中继器放大的是数字信号，原理是将衰减的信号整形再生。如果某个网络设备具有存储转发的功能，那么可以认为它能连接两个不同的协议，如果该网络设备没有存储转发功能，那么认为它不能连接两个不同的协议。中继器是没有存储转发功能的，因此它不能连接两个速率不同的网段，中继器两端的网段一定要使用同一个协议。</p></blockquote><h3 id="集线器-多口中继器"><a class="header-anchor" href="#集线器-多口中继器"></a>集线器(多口中继器)</h3><p>集线器(Hub)实质上是一个多端口的中继器，它也工作在物理层。当Hub工作时，一个端口接收到数据信号后，由于信号在从端口到Hub的传输过程中已有衰减，所以Hub便将该信号进行整形放大，使之<font color="#faa755">再生(恢复)到发送时的状态</font>，紧接着转发到其他所有(除输入端口外)处于工作状态的端口。如果同时有两个或多个端口输入，那么输出时会发生冲突，致使这些数据都无效。从Hub的工作方式可以看出，它在网络中只起信号放大和转发作用，目的是扩大网络的传输范围，而<font color="#faa755">不具备信号的定向传送能力</font>，即信号传输的方向是固定的，是一个标准的共享式设备。</p><p>Hub主要使用双绞线组建共享网络，是从服务器连接到桌面的最经济方案。在交换式网络中，Hub直接与交换机相连，将交换机端口的数据送到桌面上。使用Hub组网灵活，它把所有结点的通信集中在以其为中心的结点上，对结点相连的工作站进行集中管理，不让出问题的工作站影响整个网络的正常运行，并且用户的加入和退出也很自由。</p><p>由Hub组成的网络是共享式网络，但逻辑上仍是一个总线网。Hub的每个端口连接的网络部分是同一个网络的不同网段，同时Hub也只能在半双工状态下工作，网络的吞吐率因而受到限制.</p><blockquote><p>注意:多台计算机必须会发生同时通信的情形，因此集线器不能分割冲突域，所有集线器的端口都属于同一个冲突域。集线器在一个时钟周期中只能传输一组信息，如果一台集线器连接的机器数目较多，且多台机器经常需要同时通信，那么将导致信息碰撞，使得集线器的工作效率很差。比如，一个带宽为10Mb/s的集线器上连接了8台计算机，当这8台计算机同时工作时，每台计算机真正所拥有的带宽为10/8Mb/s = 1.25Mb/s.</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;物理层的基本概念&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#物理层的基本概念&quot;&gt;&lt;/a&gt;物理层的基本概念&lt;/h2&gt;
&lt;p&gt;物理层解决如何在连接各种计算机的传输媒体上&lt;font color=&quot;#FF666&quot;&gt;传输数据比特流&lt;/font&gt;，而不</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://halo123.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://halo123.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络体系结构</title>
    <link href="http://halo123.top/2021/04/22/ComputerNetworks/A_LayeredArchitecture/"/>
    <id>http://halo123.top/2021/04/22/ComputerNetworks/A_LayeredArchitecture/</id>
    <published>2021-04-22T14:09:39.308Z</published>
    <updated>2021-04-22T14:24:51.844Z</updated>
    
    <content type="html"><![CDATA[<h1>计算机网络概述</h1><h2 id="1-计算机网络的概念"><a class="header-anchor" href="#1-计算机网络的概念"></a>1 计算机网络的概念</h2><p>计算机网络：是一个将分散的、具有独立功能的<font color="#FF666">计算机系统</font>，通过<font color="#FF666">通信设备</font>与<font color="#FF666">线路</font>连接起来，由功能完善的<font color="#FF666">软件</font>实现<font color="#FF666">资源共享</font>和<font color="#FF666">信息传递</font>的系统。</p><p>简而言之，计算机网络就是一些<font color="#e03e3e">互联</font>的、<font color="#e03e3e">自治</font>的计算机系统的集合。（互联：互联互通；自治：无主从关系）</p><h2 id="2-计算机网络的功能"><a class="header-anchor" href="#2-计算机网络的功能"></a>2 计算机网络的功能</h2><h3 id="font-color-d9730d-数据通信-font"><a class="header-anchor" href="#font-color-d9730d-数据通信-font"></a><font color="#d9730d">数据通信</font></h3><p>它是计算机网络最基本和最重要的功能，用来实现联网计算机之间的各种信息的传输，并将将分散在不同地理位置的计算机联系起来，进行统一的调配、控制和管理。比如，文件传输、电子邮件等应用，离开了计算机网络将无法实现。</p><h3 id="font-color-d9730d-资源共享-font"><a class="header-anchor" href="#font-color-d9730d-资源共享-font"></a><font color="#d9730d">资源共享</font></h3><p>资源共享可以是软件共享、数据共享，也可以是硬件共享。使计算机网络中的资源互通有无分工协作，从而极大地提高硬件资源、软件资源和数据资源的利用率</p><h3 id="分布式处理"><a class="header-anchor" href="#分布式处理"></a>分布式处理</h3><p>当计算机网络中的某个计算机系统负荷过重时，可以将其处理的某个复杂任务分配给网络中的其他计算机系统，从而利用空闲计算机资源以提高整个系统的利用率。</p><h3 id="提高可靠性"><a class="header-anchor" href="#提高可靠性"></a>提高可靠性</h3><p>计算机网络中的各台计算机可以通过网络互为替代机。</p><h3 id="负载均衡"><a class="header-anchor" href="#负载均衡"></a>负载均衡</h3><p>将工作任务均衡地分配给计算机网络中的各台计算机。</p><hr><p>除以上几大主要功能外，计算机网络还可以实现电子化办公与服务、远程教育、娱乐等功能，满足了社会的需求，方便了人们学习、工作和生活，具有巨大的经济效益。</p><h2 id="3-计算机网络的组成"><a class="header-anchor" href="#3-计算机网络的组成"></a>3 计算机网络的组成</h2><h3 id="组成部分上来看"><a class="header-anchor" href="#组成部分上来看"></a>组成部分上来看</h3><p>一个完整的计算机网络主要由硬件、软件、协议三大部分组成，缺一不可。</p><ul><li>硬件主要由主机（也称端系统）、通信链路（如双绞线、光纤）、交换设备（如路由器、交换机等）和通信处理机（如网卡）等组成。</li><li>软件主要包括各种实现资源共享的软件和方便用户使用的各种工具软件（如网络操作系统、邮件收发程序、FTP程序、聊天程序等）。软件部分多属于应用层。</li><li><font color="#faa755">协议是计算机网络的核心</font>，如同交通规则制约汽车驾驶一样，协议规定了网络传输数据时所遵循的规范。</li></ul><h3 id="font-color-d9730d-从工作方式上看-font"><a class="header-anchor" href="#font-color-d9730d-从工作方式上看-font"></a><font color="#d9730d">从工作方式上看</font></h3><p>计算机网络（这里主要指 internet）可分为边缘部分和核心部分。</p><ul><li>边缘部分由所有连接到因特网上、供用户直接使用的主机组成，用来进行通信（如传输数据、音频或视频）和资源共享；（C/S方式和P2P方式）</li><li>核心部分由大量的网络和连接这些网络的路由器组成，它为边缘部分提供连通性和交换服务。</li></ul><p>图1.1给出了这两部分的示意图。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9B%A0%E7%89%B9%E7%BD%91%E7%9A%84%E6%A0%B8%E5%BF%83%E9%83%A8%E5%88%86%E4%B8%8E%E8%BE%B9%E7%BC%98%E9%83%A8%E5%88%86.png" alt="因特网的核心部分与边缘部分" style="object-fit: cover; border-radius: 10px; width: 80%; " /><h3 id="font-color-d9730d-从功能组成上看-font"><a class="header-anchor" href="#font-color-d9730d-从功能组成上看-font"></a><font color="#d9730d">从功能组成上看</font></h3><p>计算机网络由通信子网和资源子网组成。</p><ul><li>通信子网由各种传输介质、通信设备和相应的网络协议组成，它使网络具有数据传输、交换、控制和存储的能力，实现联网计算机之间的<font color="#faa755">数据通信</font>。</li><li>资源子网是实现<font color="#faa755">资源共享</font>功能的设备及其软件的集合，向网络用户提供共享其他计算机上的硬件资源、软件资源和数据资源的服务。</li></ul><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%B5%84%E6%BA%90%E5%AD%90%E7%BD%91%E5%92%8C%E9%80%9A%E4%BF%A1%E5%AD%90%E7%BD%91.png" alt="资源子网和通信子网" style="object-fit: cover; border-radius: 10px; width: 80%;" /><h2 id="4-计算机网络的分类"><a class="header-anchor" href="#4-计算机网络的分类"></a>4 计算机网络的分类</h2><h3 id="按分布范分类"><a class="header-anchor" href="#按分布范分类"></a>按分布范分类</h3><ul><li>广域网（WAN）。广域网的任务是提供长距离通信，运送主机所发送的数据，其覆盖范围通常为几十千米到几千千米的区域，因而有时也称远程网。广域网是因特网的核心部分。连接广域网的各结点交换机的链路一般都是高速链路，具有较大的通信容量。（交换技术）</li><li>城域网（MAN）。城域网的覆盖范围可以跨越几个街区甚至整个城市，覆盖范围约为5~50km。城域网大多采用以太网技术，因此有时也常并入局域网的范围进行讨论。</li><li>局域网（LAN）。局域网一般用微机或工作站通过高速线路相连，覆盖范围较小，通常为几十米到几千米的区域。局域网在计算机配置的数量上没有太多的限制，少的可以只有两台，多的可达几百台。传统上，局域网使用广播技术，而广域网使用交换技术。（广播技术）</li><li>个人区域网（PAN）。个人区域网是指在个人工作的地方将消费电子设备（如平板电脑、智能手机等）用无线技术连接起来的网络，也常称为无线个人区域网（WPAN），其覆盖的区域直径约为10m。</li></ul><blockquote><p>:bulb: 注意：若中央处理器之间的距离非常近（如仅1m的数量级或甚至更小），则一般就称之为多处理器系统，而不称它为计算机网络。</p></blockquote><h3 id="按使用者分类"><a class="header-anchor" href="#按使用者分类"></a>按使用者分类</h3><ul><li>公用网（ Public network）。指电信公司出资建造的大型网络。“公用”的意思是指所有愿意按电信公司的规定交纳费用的人都可以使用这种网络，因此也称公众网。</li><li>专用网（ Private Network）。指某个部门为满足本单位特殊业务的需要而建造的网络。这种网络不向本单位以外的人提供服务。例如铁路、电力、军队等部门的专用网。</li></ul><h3 id="按交换技术分类"><a class="header-anchor" href="#按交换技术分类"></a>按交换技术分类</h3><p>交换技术是指各台主机之间、各通信设备之间或主机与通信设备之间为交换信息所采用的数据格式和交换装置的方式。</p><p>按交换技术可将网络分为如下几种</p><ul><li><p>电路交换网络。在源结点和目的结点之间建立一条专用的通路用于传送数据，包括建立连接、传输数据和断开连接三个阶段。最典型的电路交换网是传统电话网络。</p><blockquote><p>该类网络的主要特点是整个报文的比特流连续地从源点直达终点，好像是在一条管道中传送。优点是数据直接传送、时延小。缺点是线路利用率低、不能充分利用线路容量、不便于进行差错控制</p></blockquote></li><li><p>报文交换网络。用户数据加上源地址、目的地址、校验码等辅助信息，然后封装成报文整个报文传送到相邻结点，全部存储后，再转发给下一个结点，重复这一过程直到到达目的结点。每个报文可以单独选择到达目的结点的路径。</p><blockquote><p>报文交换网络。用户数据加上源地址、目的地址、校验码等辅助信息，然后封装成报文整个报文传送到相邻结点，全部存储后，再转发给下一个结点，重复这一过程直到到达目的结点。每个报文可以单独选择到达目的结点的路径。</p></blockquote></li><li><p>分组交换网络，也称包交换网络。其原理是将数据分成较短的固定长度的数据块，在每个数据块中加上目的地址、源地址等辅助信息组成分组（包），以存储-转发方式传输其主要特点是单个分组（它只是整个报文的一部分）传送到相邻结点，存储后查找转发表，转发到下一个结点。除具备报文交换网络的优点外，分组交换网络还具有自身的优点：缓冲易于管理；包的平均时延更小，网络占用的平均缓冲区更少；更易于标准化；更适合应用。现在的主流网络基本上都可视为分组交换网络。</p></li></ul><h3 id="按拓扑结构分类"><a class="header-anchor" href="#按拓扑结构分类"></a>按拓扑结构分类</h3><p>网络拓扑结构是指由网中结点（路由器、主机等）与通信线路（网线）之间的几何关系（如总线形、环形）表示的网络结构，主要指通信子网的拓扑结构按网络的拓扑结构，主要分为总线形、星形、环形和网状形网络等。</p><p>星形、总线形和环形网络多用于局域网，网状形网络多用于广域网。</p><h3 id="按传输介质分类"><a class="header-anchor" href="#按传输介质分类"></a>按传输介质分类</h3><p>传输介质可分为有线和无线两大类，因此网络可以分为有线网络和无线网络。有线网络又分为双绞线网络、同轴电缆网络等。无线网络又可分为蓝牙、微波、无线电等类型</p><h3 id="按传输技术分类"><a class="header-anchor" href="#按传输技术分类"></a>按传输技术分类</h3><ul><li>广播式网络。所有联网计算机都共享一个公共通信信道。当一台计算机利用共享通信信道发送报文分组时，所有其他的计算机都会“收听”到这个分组。接收到该分组的计算机将通过检查目的地址来决定是否接收该分组局域网基本上都采用广播式通信技术，广域网中的无线、卫星通信网络也采用广播式通信技术。</li><li>点对点网络。每条物理线路连接一对计算机。如果通信的两台主机之间没有直接连接的线路，那么它们之间的分组传输就要通过中间结点的接收、存储和转发，直至目的结点。</li></ul><p><font color="#e03e3e">是否采用分组存储转发与路由选择机制是点对点式网络与广播式网络的重要区别</font>，广域网基本都属于点对点网络。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E7%AC%AC1%E8%8A%82%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.svg" alt="第一节思维导图" style="object-fit: cover; border-radius: 10px; width: 100%;"/><h2 id="5-计算机网络的标准化工作"><a class="header-anchor" href="#5-计算机网络的标准化工作"></a>5 计算机网络的标准化工作</h2><h3 id="标准的分类"><a class="header-anchor" href="#标准的分类"></a>标准的分类</h3><ol><li>法定标准，由权威机构制定的正式的、合法的标准（OSI）</li><li>事实标准，某些公司的产品在竞争中占据了主流，时间长了，这些产品中的协议和技术就成了标准（TCP/IP）</li></ol><p>计算机网络的标准化对计算机网络的发展和推广起到了极为重要的作用。</p><p>因特网的所有标准都以RFC（ Request For Comments）的形式在因特网上发布，但并非每个RFC都是因特网标准，RFC要上升为因特网的正式标准需经过以下4个阶段</p><ol><li>因特网草案（ Internet Draft）。这个阶段还不是RFC文档。</li><li>建议标准（ Proposed Standard）。从这个阶段开始就成为RFC文档。</li><li>草案标准（ Draft Standard）。</li><li>因特网标准（ Internet Standard）</li></ol><p>此外，还有实验的RFC和提供信息的RFC。各种RFC之间的关系如图1.3所示。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%90%84%E7%A7%8DRFC%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="各种RFC之间的关系" style="object-fit: cover; border-radius: 10px; width: 80%;" /><p>在国际上，负责制定、实施相关网络标准的标准化组织众多，主要有如下几个</p><ul><li>国际标准化组织（ISO）。制定的主要网络标准或规范有OSI参考模型、HDLC等。</li><li>国际电信联盟（ITU）。其前身为国际电话电报咨询委员会（CCITT），其下属机构ITU-T制定了大量有关远程通信的标准。</li><li>国际电气电子工程师协会（IEEE）。世界上最大的专业技术团体，由计算机和工程学专业人士组成。IEEE在通信领域最著名的研究成果是802标准</li></ul><h2 id="6-计算机网络的性能指标"><a class="header-anchor" href="#6-计算机网络的性能指标"></a>6 计算机网络的性能指标</h2><h3 id="速率-Speed"><a class="header-anchor" href="#速率-Speed"></a>速率(Speed)</h3><p>网络中的速率是指连接到计算机网络上的主机在数字信道上传送数据的速率，也称数据率或比特率，单位为b/s（比特秒）（或bit/s，有时也写为bps）。数据率较高时，可用kb/s（k=10<sup>3</sup>​）、Mbs（M=10<sup>5</sup>）或Gbs（G=10<sup>9</sup>）表示。在计算机网络中，通常把最高数据率称为带宽。</p><h3 id="带宽-Bandwidth"><a class="header-anchor" href="#带宽-Bandwidth"></a>带宽(Bandwidth)</h3><p>本来表示通信线路允许通过的信号频带范围，单位是赫兹（Hz）。而在计算机网络中，带宽表示网络的通信线路所能传送数据的能力，是数字信道所能传送的“<font color="#faa755">最高数据率</font>”的同义语，单位是比特/秒（bs）。</p><h3 id="吞吐量-Throughput"><a class="header-anchor" href="#吞吐量-Throughput"></a>吞吐量(Throughput)</h3><p>指<font color="#faa755">单位时间</font>内通过某个网络（或信道、接口）的数据量。吞吐量受网络带宽或网络额定速率的限制。</p><h3 id="时延-Delay"><a class="header-anchor" href="#时延-Delay"></a>时延(Delay)</h3><p>指数据（一个报文或分组）从网络（或链路）的一端传送到另一端所需要的总时间，它由4部分构成：发送时延、传播时延、处理时延和排队时延。</p><ul><li><p>发送时延。结点将分组的所有比特推向（传输）链路所需的时间，即从发送分组的第一个比特算起，到该分组的最后一个比特发送完毕所需的时间，因此也称传输时延。</p><blockquote><p>计算公式为：发送时延=分组长度/信道宽度(发送速率)</p></blockquote></li><li><p>传播时延。电磁波在信道中传播一定的距离需要花费的时间，即一个比特从链路的端传播到另一端所需的时间。</p><blockquote><p>计算公式为：传播时延=信道长度/电磁波在信道上的传播速率</p></blockquote></li><li><p>处理时延。数据在交换结点为存储转发而进行的一些必要的处理所花费的时间。例如，分析分组的首部、从分组中提取数据部分、进行差错检验或査找适当的路由等。</p></li><li><p>排队时延。分组在进入路由器后要先在输入队列中排队等待处理。路由器确定转发端口后，还要在输出队列中排队等待转发，这就产生了排队时延。</p></li></ul><p>因此，数据在网络中经历的总时延就是以上4部分时延之和：<font color="#faa755">总时延=发送时延+传播时延+处理时延+排队时延</font></p><blockquote><p>:bulb: 注意：做题时，排队时延和处理时延一般可忽略不计（除非题目另有说明）。另外，<font color="#faa755">对于高速链路，提高的仅是数据发送速率而非比特在链路上的传播速率</font>。提高数据的发送速率只是为了减少数据的发送时延</p></blockquote><p>类比车站机场安检过程</p><h3 id="时延带宽积"><a class="header-anchor" href="#时延带宽积"></a>时延带宽积</h3><p>指发送端发送的第一个比特即将到达终点时，发送端已经发出了多少个比特，因此又称以比特为单位的链路长度，即<font color="#faa755">时延带宽积=传播时延×信道带宽</font>。 考虑—个代表链路的圆柱形管道，其长度表示链路的传播时延，横截面积表示链路带宽，则时延带宽积表示该管道可以容纳的比特数量。以比特为单位的链路长度，即“某端链路现在有多少比特”（容量）</p><h3 id="往返时延-Round-Trip-Time-RTT"><a class="header-anchor" href="#往返时延-Round-Trip-Time-RTT"></a>往返时延(Round-Trip Time,RTT)</h3><p>指从发送端发送数据开始，到发送端收到来自接收端的确认(接收端收到数据后立即发送确认)，总共经历的时延。在互联网中，往返时延还包括各中间结点的处理时延、排队时延及转发数据时的发送时延。RTT越大，在收到确认之前，可以发送的数据越多。</p><h3 id="信道利用率"><a class="header-anchor" href="#信道利用率"></a>信道利用率</h3><p>指出某一信道有百分之多少的时间是有数据通过的，即<font color="#faa755">信道利用率 = 有数据通过时间/(有+无)数据通过时间</font>。</p><p>网络利用率：信道利用率加权平均值</p><h1>计算机网络体系结构与参考模型</h1><h2 id="1-计算机网络分层结构"><a class="header-anchor" href="#1-计算机网络分层结构"></a>1 计算机网络分层结构</h2><h3 id="为什么要分层"><a class="header-anchor" href="#为什么要分层"></a>为什么要分层</h3><p>对于发送文件前要完成的工作:</p><ol><li>发起通信的计算机必须将数据通信的通路进行激活。</li><li>要告诉网络如何识别目的主机。</li><li>发起通信的计算机要查明目的主机是否开机，并且与网络连接正常。</li><li>发起通信的计算机要弄清楚，对方计算机中文件管理程序是否已经做好准备工作。</li><li>确保差错和意外可以解决。</li></ol><p>两个系统中实体间的通信是一个很复杂的过程，为了降低协议设计和调试过程的复杂性，也为了便于对网络进行研究、实现和维护，促进标准化工作，通常对计算机网络的体系结构以分层的方式进行建模。</p><h3 id="分层的基本原则"><a class="header-anchor" href="#分层的基本原则"></a>分层的基本原则</h3><p>我们把计算机网络的各层及其协议的集合称为<font color="#ea66a6">网络的体系结构</font>(Architecture)。 换言之，计算机网络的体系结构就是这个计算机网络及其所应完成的<font color="#faa755">功能</font>的精确定义，它是计算机网络中的层次、各层的协议及层间接口的集合。需要强调的是，这些功能究竟是用何种硬件或软件完成的，则是一个遵循这种体系结构的实现（Implementation）问题。体系结构是抽象的，而实现是具体的，是真正在运行的计算机硬件和软件。。</p><p>计算机网络的体系结构通常都具有可分层的特性，它将复杂的大系统分成若干较容易实现的层次。分层的基本原则如下：</p><ol><li>每层都实现一种相对<font color="#faa755">独立</font>的功能，降低大系统的复杂度。</li><li>各层之间<font color="#faa755">界面自然清晰</font>，易于理解，相互交流尽可能少。</li><li>各层功能的精确定义独立于具体的实现方法，可以采用<font color="#faa755">最合适的技术</font>来实现。</li><li>保持<font color="#faa755">下层对上层的独立性</font>，<font color="#faa755">上层单向使用下层提供的服务</font>。</li><li>整个分层结构应能促进标准化工作。</li></ol><p>由于分层后各层之间相对独立，灵活性好，因而分层的体系结构易于更新(替换单个模块)，易于调试，易于交流，易于抽象，易于标准化。但<font color="#0f7b6c">层次越多</font>，有些功能在不同层中难免重复出现，产生额外的开销，导致整体运行效率越低。<font color="#0f7b6c">层次越少</font>，就会使每层的协议太复杂。因此，在分层时应考虑层次的清晰程度与运行效率间的折中、层次数量的折中。</p><h3 id="计算机网络层次结构"><a class="header-anchor" href="#计算机网络层次结构"></a>计算机网络层次结构</h3><p>依据一定的规则，将分层后的网络从低层到高层依次称为第1层、第2.层…第n层，通常还为每层取一个特定的名称，如第1层的名称为<font color="#faa755">物理层</font>。</p><p>在计算机网络的分层结构中，第n层中的活动元素通常称为n层实体。具体来说，<font color="#ea66a6">实体</font>指任何可发送或接收信息的硬件或软件进程，通常是一个特定的软件模块。不同机器上的同一层称为对等层，同一层的实体称为<font color="#ea66a6">对等实体</font>。n层实体实现的服务为 n+ 1 层所利用。在这种情况下，n层被称为服务提供者，n+1 层则服务于用户。</p><p>每一层还有自己传送的数据单位，其名称、大小、含义也各有不同。</p><p>在计算机网络体系结构的各个层次中，每个报文都分为两部分：一是<font color="#faa755">数据部分</font>， 即SDU；二是<font color="#faa755">控制信息部分</font>，即PCI，它们共同组成PDU。</p><ul><li><font color="#ea66a6">服务数据单元</font>(SDU)：为完成用户所要求的功能而应传送的数据。第n层的服务数据单元记为n-SDU。</li><li><font color="#ea66a6">协议控制信息</font>(PCI)：控制协议操作的信息。第n层的协议控制信息记为n-PCI。</li><li><font color="#ea66a6">协议数据单元</font>(PDU)：对等层次之间传送的数据单位称为该层的PDU。第n层的协议数据单元记为n-PDU。在实际的网络中，每层的协议数据单元都有一个通俗的名称，如物理层的PDU称为比特，链路层的PDU称为帧，网络层的PDU称为分组，传输层的PDU称为报文。</li></ul><p>在各层间传输数据时，把从第n+1层收到的PDU作为第n层的SDU，加上第n层的PCI，就变成了第n层的PDU，交给第n-1层后作为SDU发送，接收方接收时做相反的处理，因此可知三者的关系为n-SDU + n-PCI= n-PDU= (n-1)-SDU，其变换过程如图1.5所示。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E6%95%B0%E6%8D%AE%E5%8D%95%E5%85%83%E7%9A%84%E8%81%94%E7%B3%BB.png" alt="网络各层数据单元的联系" style="object-fit: cover; border-radius: 10px; width: 80%;" /><p>具体地，层次结构的含义包括以下几方面：</p><ol><li>第 n 层的实体不仅要使用第 n-1 层的服务来实现自身定义的功能，还要向第 n+1 层提供本层的服务，该服务是第 n 层及其下面各层提供的服务总和。</li><li>最低层只提供服务，是整个层次结构的基础；中间各层既是下一层的服务使用者，又是上一层的服务提供者；最高层面向用户提供服务。</li><li>上一层只能通过相邻层间的接口使用下一层的服务，而不能调用其他层的服务；下一层所提供服务的实现细节对上一层透明。</li><li>两台主机通信时，对等层在逻辑上有一条直接信道，表现为不经过下层就把信息传送到对方。</li></ol><h3 id="概念总结"><a class="header-anchor" href="#概念总结"></a>概念总结</h3><ol><li>网络体系结构是从功能上描述计算机网络结构。</li><li>计算机网络体系结构简称网络体系结构是分层结构。</li><li>每层遵循某个/些网络协议以完成本层功能。</li><li>计算机网络体系结构是计算机网络的各层及其协议的集合。</li><li>第 n 层在向 n+1 层提供服务时，此服务不仅包含第 n 层本身的功能，还包含由下层服务提供的功能。</li><li>仅仅在相邻层间有接口，且所提供服务的具体实现细节对上一层完全屏蔽。</li><li>体系结构是抽象的，而实现是指能运行的一些软件和硬件。</li></ol><h2 id="2-计算机网络协议、接口、服务的概念"><a class="header-anchor" href="#2-计算机网络协议、接口、服务的概念"></a>2 计算机网络协议、接口、服务的概念</h2><h3 id="协议"><a class="header-anchor" href="#协议"></a>协议</h3><p>协议，就是规则的集合。在网络中要做到有条不紊地交换数据，就必须遵循一些事先约定好的规则。这些规则明确规定了所交换的数据的格式及有关的同步问题。这些为进行网络中的数据交换而建立的规则、标准或约定称为网络协议（ Network Protocol ），它是控制两个(或多个)对等实体进行通信的规则的集合，是<font color="#e03e3e">水平</font>的。不对等实体之间是没有协议的，比如用 TCP/IP 协议栈通信的两个结点，结点A的传输层和结点 B 的传输层之间存在协议，但结点A的传输层和结点B的网络层之间不存在协议。网络协议也简称为协议。</p><p>协议由语法、语义和同步三部分组成。</p><ul><li>语法：规定了传输数据的格式；</li><li>语义：规定了所要完成的功能，即需要发出何种控制信息、完成何种动作及做出何种应答；</li><li>同步：规定了执行各种操作的条件、时序关系等，即事件实现顺序的详细说明。</li></ul><p>一个完整的协议通常应具有线路管理(建立、释放连接)、差错控制、数据转换等功能。</p><h3 id="接口"><a class="header-anchor" href="#接口"></a>接口</h3><p>接口是同一结点内相邻两层间交换信息的连接点，是一个系统内部的规定。每层只能为紧邻的层次之间定义接口，不能跨层定义接口。在典型的接口上，同一结点相邻两层的实体通过服务访问点（Service Access Point，SAP）进行交互。服务是通过 SAP 提供给上层使用的，第 n 层的 SAP 就是第 n+1 层可以访问第 n 层服务的地方（上层使用下层服务的入口，下层为上层提供的接口）。每个 SAP 都有一个能够标识它的地址。SAP 是一个抽象的概念，它实际上是一个逻辑接口（类似于邮政信箱），但和通常所说的两个设备之间的硬件接口是很不一样的。</p><h3 id="服务"><a class="header-anchor" href="#服务"></a>服务</h3><p>服务是指下层为紧邻的上层提供的功能调用（单向），它是<font color="#e03e3e">垂直</font>的。对等实体在协议的控制下，使得本层能为上一层提供服务，但要实现本层协议还需要使用下一层所提供的服务。</p><p>上层使用下层所提供的服务时必须与下层交换一些命令，这些命令在OSI中称为服务原语。</p><p>OSI将原语划分为4类:</p><ol><li>请求(Request)。 由服务用户发往服务提供者，请求完成某项工作。</li><li>指示( Indication)。由服务提供者发往服务用户，指示用户做某件事情。</li><li>响应(Response)。 由服务用户发往服务提供者，作为对指示的响应。</li><li>证实(Confirmation)。由服务提供者发往服务用户，作为对请求的证实。</li></ol><p>这4类原语用于不同的功能，如建立连接、传输数据和断开连接等。有应答服务包括全部4类原语，而无应答服务则只有请求和指示两类原语。</p><p>一定要注意，协议和服务在概念上是不一样的。</p><ul><li>首先，只有本层协议的实现才能保证向上一层提供服务。本层的服务用户只能看见服务而无法看见下面的协议，即下面的协议对上层的服务用户是透明的。</li><li>其次，协议是“水平的”，即协议是控制对等实体之间通信的规则。但服务是“垂直的”，即服务是由下层通过层间接口向上层提供的。</li><li>另外，并非在一层内完成的全部功能都称为服务，只有那些能够被高一层实体 “看得见”的功能才称为服务。</li></ul><p>协议、接口、服务三者之间的关系如图1.7所示。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%8D%8F%E8%AE%AE%E3%80%81%E6%8E%A5%E5%8F%A3%E3%80%81%E6%9C%8D%E5%8A%A1%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="协议、接口、服务三者之间的关系" style="object-fit: cover; border-radius: 10px; width: 80%;" /><hr><p>计算机网络提供的服务可按以下三种方式分类。</p><h4 id="面向连接服务与无连接服务"><a class="header-anchor" href="#面向连接服务与无连接服务"></a>面向连接服务与无连接服务</h4><p>在面向连接服务中，通信前双方必须先建立连接，分配相应的资源（如缓冲区），以保证通信能正常进行，传输结束后释放连接和所占用的资源。因此这种服务可以分为连接建立、数据传输和连接释放三个阶段。例如TCP就是一种面向连接服务的协议。</p><p>在无连接服务中，通信前双方不需要先建立连接，需要发送数据时可直接发送，把每个带有目的地址的包（报文分组）传送到线路上，由系统选定路线进行传输。这是一种不可靠的服务。这种服务常被描述为“尽最大努力交付”（Best-Effort-Delivery），它并不保证通信的可靠性。例如IP、UDP就是一种无连接服务的协议。</p><h4 id="可靠服务和不可靠服务"><a class="header-anchor" href="#可靠服务和不可靠服务"></a>可靠服务和不可靠服务</h4><p>可靠服务是指网络具有纠错、检错、应答机制，能保证数据正确、可靠地传送到目的地。不可靠服务是指网络只是尽量正确、可靠地传送，而不能保证数据正确、可靠地传送到目的地，是一种尽力而为的服务。</p><p>对于提供不可靠服务的网络，其网络的正确性、可靠性要由应用或用户来保障。例如，用户收到信息后要判断信息的正确性，如果不正确，那么用户要把出错信息报告给信息的发送者，以便发送者采取纠正措施。通过用户的这些措施，可以把不可靠的服务变成可靠的服务。</p><blockquote><p>注意：在一层内完成的全部功能并非都称之为服务，只有那些能够被高一层实体“看得见”的功能才能称为服务。</p></blockquote><h4 id="有应答服务和无应答服务"><a class="header-anchor" href="#有应答服务和无应答服务"></a>有应答服务和无应答服务</h4><p>有应答服务是指接收方在收到数据后向发送方给出相应的应答，该应答由传输系统内部自动实现，而不由用户实现。所发送的应答既可以是肯定应答，也可以是否定应答，通常在接收到的数据有错误时发送否定应答。例如，文件传输服务就是一种有应答服务。</p><p>无应答服务是指接收方收到数据后不自动给出应答。若需要应答，则由高层实现。例如，对于WWW服务，客户端收到服务器发送的页面文件后不给出应答。</p><h2 id="3-ISO-OSI参考模型"><a class="header-anchor" href="#3-ISO-OSI参考模型"></a>3 ISO/OSI参考模型</h2><p>国际标准化组织（ISO）提出的网络体系结构模型，称为开放系统互连参考模型（OSI/ RM）,通常简称为OSI参考模型。OSI有7层，自下而上依次为物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p><ul><li>高三层统称为<font color="#FF666">资源子网</font>，它相当于计算机系统，完成<font color="#faa755">数据的处理</font>等功能。</li><li>传输层承上启下。</li><li>低三层统称为<font color="#FF666">通信子网</font>，它是为了联网而附加的通信设备，完成<font color="#faa755">数据的传输</font>功能；</li></ul><p>OSI的层次结构如图1.8所示。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSI%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" alt="OSI的层次结构" style="object-fit: cover; border-radius: 10px; width: 100%;" /><p>下面详述OSI参考模型各层的功能。</p><h3 id="应用层（Application-Layer）"><a class="header-anchor" href="#应用层（Application-Layer）"></a>应用层（Application Layer）</h3><p>应用层是 OSI 模型的最高层，是用户与网络的界面。应用层为特定类型的网络应用提供访问 OSI 环境的手段。因为用户的实际应用多种多样，这就要求应用层采用不同的应用协议来解决不同类型的应用要求，因此应用层是最复杂的一层，使用的协议也最多。典型的协议有用于文件传：送的FTP、用于电子邮件的SMTP、用于万维网的HTTP等。</p><h3 id="表示层（Presentation-Layer）"><a class="header-anchor" href="#表示层（Presentation-Layer）"></a>表示层（Presentation Layer）</h3><p>表示层主要处理在两个通信系统中交换信息的表示方式。不同机器采用的编码和表示方法不同，使用的数据结构也不同。为了使不同表示方法的数据和信息之间能互相交换，表示层采用抽象的标准方法定义数据结构，并采用标准的编码形式。数据压缩、加密和解密也是表示层可提供的数据表示变换功能。</p><p>功能一：数据格式变换</p><p>功能二：数据加密解密</p><p>功能三：数据压缩和恢复</p><h3 id="会话层（Session-Layer）"><a class="header-anchor" href="#会话层（Session-Layer）"></a>会话层（Session Layer）</h3><p>会话层允许不同主机上的各个进程之间进行会话。会话层利用传输层提供的端到端的服务，向表示层提供它的增值服务。这种服务主要为表示层实体或用户进程建立连接并在连接上有序地传输数据，这就是会话，也称建立同步（SYN）。</p><p>会话层负责管理主机间的会话进程，包括建立、管理及终止进程间的会话。会话层可以使用校验点使通信会话在通信失效时从校验点继续恢复通信，实现数据同步。</p><p>功能一：建立、管理、终止会话</p><p>功能二：使用校验点可使会话在通信失效时从校验点/同步点继续恢复通信，实现数据同步。</p><h3 id="传输层（Transport-Layer）"><a class="header-anchor" href="#传输层（Transport-Layer）"></a>传输层（Transport Layer）</h3><p>传输层也称运输层，传输单位是报文段（TCP） 或用户数据报（UDP），传输层负责主机中两个进程之间的通信，功能是为端到端连接提供可靠的传输服务，为端到端连接提供流量控制、差错控制、服务质量、数据传输管理等服务。</p><p>数据链路层提供的是点到点的通信，传输层提供的是端到端的通信，两者不同。</p><p>通俗地说，点到点可以理解为主机到主机之间的通信，一个点是指一个硬件地址或IP地址，网络中参与通信的主机是通过硬件地址或IP地址标识的；端到端的通信是指运行在不同主机内的两个进程之间的通信，一个进程由一个端口来标识，所以称端到端通信。</p><p>使用传输层的服务，高层用户可以直接进行端到端的数据传输，从而忽略通信子网的存在。通过传输层的屏蔽，高层用户看不到子网的交替和变化。由于一台主机可同时运行多个进程，因此传输层具有复用和分用的功能。复用是指多个应用层进程可同时使用下面传输层的服务，分用是指传输层把收到的信息分别交付给上面应用层中相应的进程。</p><p>传输层的协议有TCP、UDP。</p><p>功能一：可靠传输、不可靠传输</p><p>功能二：差错控制</p><p>功能三：流量控制</p><p>功能四：复用分用</p><h3 id="网络层（Network-Layer）"><a class="header-anchor" href="#网络层（Network-Layer）"></a>网络层（Network Layer）</h3><p>主要任务是把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务。网络层传输单位是数据报。（分组是对数据报进行分割后的结果）</p><p>它关心的是通信子网的运行控制，主要任务是把网络层的协议数据单元（分组）从源端传到目的端，为分组交换网上的不同主机提供通信服务。关键问题是对分组进行路由选择，并实现流量控制、拥塞控制、差错控制和网际互联等功能。</p><p>如图1.10所示，结点A向结点B传输一个分组时，既可经过边a、c、g,也可经过边b、h，有很多条可以选择的路由，而网络层的作用就是根据网络的情况，利用相应的路由算法计算出一条合适的路径,使这个分组可以顺利到达结点B。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%9F%90%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="某网络结构图" style="object-fit: cover; border-radius: 10px; width: 80%;" /><p>流量控制与数据链路层的流量控制含义一样，都是协调 A 的发送速率和 B 的接收速率。</p><p>差错控制是通信两结点之间约定的特定检错规则，如奇偶校验码，接收方根据这个规则检查接收到的分组是否出现差错，如果出现了差错，那么能纠错就纠错，不能纠错就丢弃，确保向上层提交的数据都是无误的。</p><p>如果图1.9中的结点都处于来不及接收分组而要丢弃大量分组的情况，那么网络就处于拥塞状态，拥塞状态使得网络中的两个结点无法正常通信。网络层要采取一定的措施来缓解这种拥塞，这就是拥塞控制。</p><p>因特网是一个很大的互联网，它由大量异构网络通过路由器（Router）相互连接起来。因特网的主要网络层协议是无连接的网际协议（Internet Protocol，IP）和许多路由选择协议，因此因特网的网络层也称网际层或IP层。</p><p>注意，网络层中的“网络”一词并不是我们通常谈及的具体网络，而是在计算机网络体系结构中使用的专有名词。</p><p>网络层的协议有IP、IPX、ICMP、IGMP、ARP、 RARP和OSPF等。</p><p>功能一：路由选择</p><p>功能二：流量控制</p><p>功能三：差错控制</p><p>功能四：拥塞控制</p><h3 id="数据链路层（Data-Link-Layer）"><a class="header-anchor" href="#数据链路层（Data-Link-Layer）"></a>数据链路层（Data Link Layer）</h3><p>数据链路层的传输单位是帧，任务是将网络层传来的IP数据报组装成帧。数据链路层的功能可以概括为成帧、差错控制、流量控制和传输管理等。</p><p>由于外界噪声的干扰，原始的物理连接在传输比特流时可能发生错误。如图1.8 所示，左边结点想向右边结点传输数字0，于是发出了信号A；但传输过程中受到干扰，信号A变成了信号B，而信号B又刚好代表1，右边结点接收到信号B时，就会误以为左边结点传送了数字1，从而发生差错。两个结点之间如果规定了数据链路层协议，那么就可以检测出这些差错，然后把收到的错误信息丢弃，这就是差错控制功能。</p><p>如图1.8 所示，在两个相邻结点之间传送数据时，由于两个结点性能的不同，可能结点A发送数据的速率会比结点B接收数据的速率快,如果不加控制，那么结点B就会丢弃很多来不及接收的正确数据，造成传输线路效率的下降。流量控制可以协调两个结点的速率，使结点A发送数据的速率刚好是结点B可以接收的速率。</p><p>广播式网络在数据链路层还要处理新的问题，即如何控制对共享信道的访问。数据链路层的一个特殊的子层一介 质访问子层，就是专门处理这个问题的。</p><p>典型的数据链路层协议有SDLC、HDLC、PPP、STP和帧中继等。</p><p>功能一：成帧（定义帧的开始和结束）</p><p>功能二：差错控制（帧错、位错）</p><p>功能三：流量控制</p><p>功能四：访问（接入）控制 控制对信道的访问</p><h3 id="物理层（Physical-Layer）"><a class="header-anchor" href="#物理层（Physical-Layer）"></a>物理层（Physical Layer）</h3><p>物理层的传输单位是比特，任务是透明的传输比特流，功能是在物理媒体上为数据端设备透明地传输原始比特流。</p><p>透明传输：指不管所传数据是什么样的比特组合都应当能够在链路上传送。</p><p>物理层主要定义数据终端设备（DTE）和数据通信设备（DCE）的物理与逻辑连接方法，所以物理层协议也称物理层接口标准。由于在通信技术的早期阶段，通信规则称为规程（Procedure），因此物理层协议也称物理层规程。</p><p>物理层接口标准很多，如 EIA-232C、EIA/TIA RS-449、CCITT 的 X.21 等。在计算机网络的复习过程中，不要忽略对各层传输协议的记忆，到了后期，读者对链路层、网络层、传输层和应用层的协议会比较熟悉，但往往容易忽视物理层的协议。</p><p>物理层主要研究以下内容:</p><p>① 通信链路与通信结点的连接需要一些电路接口，物理层规定了这些接口的一些参数，如机械形状和尺寸、交换电路的数量和排列等，例如，笔记本电脑上的网线接口，就是物理层规定的内容之一。</p><p>② 物理层也规定了通信链路上传输的信号的意义和电气特征。例如物理层规定信号A代表数字0，那么当结点要传输数字0时，就会发出信号A，当结点接收到信号A时，就知道自己接收到的实际上是数字0。</p><p>注意，传输信息所利用的一些物理媒体，如双绞线、光缆、无线信道等，并不在物理层协议之内而在物理层协议下面。因此，有人把物理媒体当作第0层。</p><p>功能一：定义接口特性</p><p>功能二：定义传输模式（单工、半双工、双工）</p><p>功能三：定义传输速率</p><p>功能四：比特同步</p><p>功能五：比特编码</p><h2 id="4-TCP-IP模型与OSI参考模型的比较"><a class="header-anchor" href="#4-TCP-IP模型与OSI参考模型的比较"></a>4 TCP/IP模型与OSI参考模型的比较</h2><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%8D%E5%90%8C%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B.png" alt="不同参考模型" style="object-fit: cover; border-radius: 10px; width: 100%;" /><p>OSI参考模型与TCP/IP参考模型相同点</p><ol><li>首先，二者都采取分层的体系结构，将庞大且复杂的问题划分为若干较容易处理的、范围较小的问题，而且分层的功能也大体相似。</li><li>其次，二者都是基于独立的协议栈的概念。</li><li>最后，二者都可以解决异构网络的互联，实现世界上不同厂家生产的计算机之间的通信。</li></ol><p>OSI参考模型与TCP/IP参考模型不同点</p><ol><li>OSI参考模型的最大贡献就是精确定义了三个主要概念：服务、协议和接口，这与现代的面向对象程序设计思想非常吻合。而 TCP/IP 模型在这三个概念上却没有明确区分，不符合软件工程的思想。</li><li>OSI参考模型产生在协议发明之前，没有偏向于任何特定的协议，通用性良好。但设计者在协议方面没有太多经验，不知道把哪些功能放到哪一层更好。TCP/IP模型正好相反，首先出现的是协议，模型实际上是对已有协议的描述，因此不会出现协议不能匹配模型的情况，但该模型不适合于任何其他非TCP/IP的协议栈。</li><li>TCP/IP 模型在设计之初就考虑到了多种异构网的互联问题，并将网际协议（ IP ）作为一个单独的重要层次。OSI 参考模型最初只考虑到用一种标准的公用数据网将各种不同的系统互联。OSI参考模型认识到网际协议 IP 的重要性后，只好在网络层中划分出一个子层来完成类似于 TCP/IP 模型中的 IP 的功能。</li><li>OSI参考模型在网络层支持无连接和面向连接的通信，但在传输层仅有面向连接的通信。而 TCP/IP 模型认为可靠性是端到端的问题，因此它在网际层仅有一种无连接的通信模式，但传输层支持无连接和面向连接两种模式。这个不同点常常作为考查点。</li></ol><blockquote><p>面向连接分为三个阶段，第一是建立连接，在此阶段，发出一个建立连接的请求。只有在连接成功建立之后，才能开始数据传输，这是第二阶段。接着，当数据传输完毕，必须释放连接。而面向无连接没有这么多阶段，它直接进行数据传输。</p></blockquote><p>无连接和面向连接</p><table><thead><tr><th>模型</th><th>ISO/OSI参考模型</th><th>TCP/IP模型</th></tr></thead><tbody><tr><td>网络层</td><td>无连接+面向连接</td><td>无连接</td></tr><tr><td>传输层</td><td>面向连接</td><td>无连接+面向连接</td></tr></tbody></table><p>无论是 OSI 参考模型还是 TCP/IP 模型，都不是完美的，对二者的讨论和批评都很多。OSI 参考模型的设计者从工作的开始，就试图建立一个全世界的计算机网络都要遵循的统一标准。 从技术角度来看，他们希望追求一种完美的理想状态，这也导致基于 OSI 参考模型的软件效率极低。OSI参考模型缺乏市场与商业动力，结构复杂，实现周期长，运行效率低，这是它未能达到预期目标的重要原因</p><p>学习计算机网络时，我们往往采取折中的办法，即综合 OSI 和 TCP/IP 的优点，采用一种如图1.13所示的只有五层协议的体系结构，即我们所熟知的物理层、数据链路层、网络层、传输层和应用层。本书也采用这种体系结构进行讨论。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E7%9A%84%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E5%9E%8B.png" alt="图1.13 网络的五层协议结构模型" style="object-fit: cover; border-radius: 10px; width: 100%;" /><p>最后简单介绍使用通信协议栈进行通信的结点的数据传输过程。每个协议栈的最顶端都是一个面向用户的接口，下面各层是为通信服务的协议。用户传输一个数据报时，通常给出用户能够理解的自然语言，然后通过应用层，将自然语言会转化为用于通信的通信数据。通信数据到达传输层，作为传输层的数据部分（传输层SDU），加上传输层的控制信息（传输层PCI），组成传输层的 PDU ,然后交到网络层，传输层的PDU下放到网络层后，就成为网络层的SDU，然后加上网络层的 PCI ，又组成了网络层的PDU，下放到数据链路层，就这样层层下放，层层包裹，最后形成的数据报通过通信线路传输，到达接收方结点协议栈，接收方再逆向地逐层把“包裹”拆开，然后把收到的数据提交给用户，如下图所示。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E6%A0%88%E7%9A%84%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B%E7%A4%BA%E4%BE%8B.png" alt="图1.14 通信协议栈的通信过程示例" style="object-fit: cover; border-radius: 10px; width: 100%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;计算机网络概述&lt;/h1&gt;
&lt;h2 id=&quot;1-计算机网络的概念&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#1-计算机网络的概念&quot;&gt;&lt;/a&gt;1 计算机网络的概念&lt;/h2&gt;
&lt;p&gt;计算机网络：是一个将分散的、具有独立功能的&lt;font color=&quot;#F</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://halo123.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://halo123.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>处理机调度</title>
    <link href="http://halo123.top/2021/04/22/OperatingSystem/C_ProcessorDispatching/"/>
    <id>http://halo123.top/2021/04/22/OperatingSystem/C_ProcessorDispatching/</id>
    <published>2021-04-22T02:19:05.000Z</published>
    <updated>2021-04-30T10:05:39.932Z</updated>
    
    <content type="html"><![CDATA[<h2 id="调度概念"><a class="header-anchor" href="#调度概念"></a>调度概念</h2><h3 id="调度的基本概念"><a class="header-anchor" href="#调度的基本概念"></a>调度的基本概念</h3><p>在多道程序系统中，进程的数量往往多于处理机的个数，因此进程争用处理机的情况在所难免。处理机调度是对处理机进行<font color="#faa755">分配</font>，即从就绪队列中按照一定的算法(公平、高效)选择一个进程并将处理机分配给它运行，以实现进程并发地执行。</p><p><font color="#faa755">处理机调度是多道程序操作系统的基础，是操作系统设计的核心问题。</font></p><h3 id="调度的层次"><a class="header-anchor" href="#调度的层次"></a>调度的层次</h3><p>一个作业从提交开始直到完成，往往要经历以下三级调度：</p><ol><li><p><font color="#faa755">作业调度</font>。又称高级调度，其主要任务是按一定的原则从外存上处于后备状态的作业中挑选一个(或多个)作业，给它(们)分配内存、输入/输出设备等必要的资源，并<font color="#faa755">建立相应的进程</font>(建立PCB)，以使它(们)<font color="#faa755">获得竞争处理机的权利</font>。简言之，作业调度就是内存与辅存之间的调度。对于每个作业只调入一次、调出一次。多道批处理系统中大多配有作业调度，而其他系统中通常不需要配置作业调度。作业调度的执行频率较低，通常为几分钟一次。</p><blockquote><p>高级调度是辅存(外存)与内存之间的调度。每个作业只调入一次，调出一次。作业调入时会建立相应的PCB，作业调出时才撤销PCB。高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。</p></blockquote></li><li><p>中级调度。又称<font color="#faa755">内存调度</font>，其作用是<font color="#faa755">提高内存利用率</font>和<font color="#faa755">系统吞吐量</font>。为此，应将那些暂时不能运行的进程<font color="#faa755">调至外存等待</font>(虚拟内存)，把此时的进程状态称为<font color="#FF666">挂起态</font>。当它们已具备运行条件且内存又稍有空闲时，由中级调度来决定把外存上的那些已具备运行条件的就绪进程，再重新调入内存，并修改其状态为就绪态，挂在就绪队列上等待。</p><blockquote><p>暂时调到外存等待的进程状态为挂起状态。值得注意的是，PCB并不会一起调到外存，而是会常驻内存。PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。被挂起的进程PCB会被放到的<font color="#faa755">挂起队列</font>中。一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。</p></blockquote><blockquote><p>暂时调到外存等待的进程状态为挂起状态(挂起态，suspend)，挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态。五状态模型→七状态模型</p></blockquote><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%B8%83%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B.png" alt="七状态模型" style="object-fit: cover; border-radius: 10px; width: 100%;" /></li><li><p><font color="#faa755">进程调度</font>。又称低级调度，其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。进程调度是操作系统中<font color="#FF666">最基本的一种调度</font>，在一般的操作系统中都必须配置进程调度。进程调度的<font color="#faa755">频率很高</font>，一般几十毫秒一次。</p></li></ol><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%84%E7%90%86%E6%9C%BA%E7%9A%84%E4%B8%89%E7%BA%A7%E8%B0%83%E5%BA%A6.png" alt="处理机的三级调度" style="object-fit: cover; border-radius: 10px; width: 100%;" /><table><thead><tr><th></th><th>要做什么</th><th>调度发生在</th><th>发生频率</th><th>对进程状态的影响</th></tr></thead><tbody><tr><td>高级调度(作业调度)</td><td>按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程</td><td>外存→内存(面向作业)</td><td>最低</td><td>无→创建态→就绪态</td></tr><tr><td>中级调度(内存调度)</td><td>按照某种规则，从挂起队列中选择合适的进程将其数据调回内存</td><td>外存→内存(面向进程)</td><td>中等</td><td>挂起态→就绪态(阻塞挂起→阻塞态)</td></tr><tr><td>低级调度(进程调度)</td><td>按照某种规则，从就绪队列中选择一个进程为其分配处理机</td><td>内存→CPU</td><td>最高</td><td>就绪态→运行态</td></tr></tbody></table><h3 id="三级调度的联系"><a class="header-anchor" href="#三级调度的联系"></a>三级调度的联系</h3><p>作业调度从外存的后备队列中选择一批作业进入内存，为它们建立进程，这些进程被送入就绪队列，进程调度从就绪队列中选出一个进程，并把其状态改为运行态，把CPU分配给它。</p><p>中级调度是为了提高内存的利用率，系统将那些暂时不能运行的进程挂起来。当内存空间宽松时，通过中级调度选择具备运行条件的进程，将其唤醒。</p><ol><li>作业调度为进程活动做准备，进程调度使进程正常活动起来，中级调度将暂时不能运行的进程挂起，中级调度处于作业调度和进程调度之间。</li><li>作业调度次数少，中级调度次数略多，进程调度频率最高。</li><li>进程调度是最基本的，不可或缺。</li></ol><h2 id="调度的时机、切换与过程"><a class="header-anchor" href="#调度的时机、切换与过程"></a>调度的时机、切换与过程</h2><h3 id="调度的时机"><a class="header-anchor" href="#调度的时机"></a>调度的时机</h3><p>进程调度和切换程序是操作系统内核程序。</p><p><font color="#faa755">需要进行进程调度与切换的情况</font>：</p><ul><li>当前运行的进程<font color="#faa755">主动放弃</font>处理机：进程正常终止；运行过程中发生异常而终止；进程主动请求阻塞(如等待I/O)</li><li>当前运行的进程<font color="#faa755">被动放弃</font>处理机：分给进程的时间片用完；有更紧急的事需要处理(如I/O中断)；有更高优先级的进程进入就绪队列</li></ul><p>请求调度的事件发生后，才可能运行进程调度程序，调度了新的就绪进程后，才会进行进程间的切换。理论上这三件事情应该顺序执行，但在实际设计中，操作系统内核程序运行时，若某时发生了引起进程调度的因素，则不一定能够马上进行调度与切换。</p><p>现代操作系统中，<font color="#faa755">不能进行进程的调度与切换的情况</font>有以下几种：</p><ol><li><p><font color="#faa755">在处理中断的过程中</font>。中断处理过程复杂，在实现上很难做到进程切换，而且中断处理是系统工作的一部分，逻辑上不属于某一进程，不应被剥夺处理机资源。</p></li><li><p><font color="#faa755">进程在操作系统内核程序临界区中</font>。进入临界区后，需要独占式地访问共享数据，理论上必须加锁，以防止其他并行程序进入，在解锁前不应切换到其他进程运行，以加快该共享数据的释放。</p><blockquote><p>临界资源：一个时间段内只允许一个进程使用的资源。各进程需要<font color="#faa755">互斥</font>地访问临界资源</p><p>临界区：访问临界资源的那段代码。</p><p>内核程序临界区一般是用来访问某种内核数据结构的，比如进程的就绪队列(由各就绪进程的PCB组成)</p></blockquote><blockquote><p>如果还没退出内核程序临界区(还没解锁)就进行进程调度，但是进程调度相关的程序也需要访问就绪队列，但此时就绪队列被锁住了，因此又无法顺利进行进程调度，内核程序临界区访问的临界资源如果不尽快释放的话，极有可能<br>影响到操作系统内核的其他管理工作。因此在访问内核程序临界区期间不能进行调度与切换。</p><p>在打印机打印完成之前，进程一直处于临界区内，临界资源不会解锁。但打印机又是慢速设备，此时如果一直不允许进程调度的话就会导致CPU一直空闲，普通临界区访问的临界资源不会直接影响操作系统内核的管理工作。因此在访问普通临界区时可以进行调度与切换。</p></blockquote></li><li><p><font color="#faa755">其他需要完全屏蔽中断的原子操作过程中</font>。如加锁、解锁、中断现场保护、恢复等原子操作。在原子过程中，连中断都要屏蔽，更不应该进行进程调度与切换。</p></li></ol><p>若在上述过程中发生了引起调度的条件，则不能马上进行调度和切换，应置系统的请求调度标志，直到上述过程结束后才进行相应的调度与切换。应该进行进程调度与切换的情况如下：</p><ol><li>发生引起调度条件且当前进程无法继续运行下去时，可以马上进行调度与切换。若操作系统只在这种情况下进行进程调度，则是<font color="#faa755">非剥夺调度</font>。</li><li>中断处理结束或自陷处理结束后，返回被中断进程的用户态程序执行现场前，若置上请求调度标志，即可马上进行进程调度与切换。若操作系统支持这种情况下的运行调度程序，则实现了<font color="#faa755">剥夺方式</font>的调度。</li></ol><h3 id="调度的切换与过程"><a class="header-anchor" href="#调度的切换与过程"></a>调度的切换与过程</h3><p>进程切换往往在调度完成后立刻发生，它要求<font color="#faa755">保存原进程当前切换点的现场信息</font>，<font color="#faa755">恢复被调度进程的现场信息</font>。</p><ol><li>对原来运行进程各种数据的保存</li><li>对新的进程各种数据的恢复</li></ol><p>现场切换时，操作系统内核将原进程的现场信息推入当前进程的内核堆栈来保存它们，并更新堆栈指针。内核完成从新进程的内核栈中装入新进程的现场信息、更新当前运行进程空间指针、重设PC寄存器等相关工作之后，开始运行新的进程。</p><blockquote><p>注意：进程切换是<font color="#faa755">有代价的</font>，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。</p></blockquote><p>“狭义的进程调度”与“进程切换&quot;的区别：</p><ul><li><p>狭义的进程调度指的是从就绪队列中选中一个要运行的进程。(这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况就需要进程切换)</p></li><li><p>进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程。</p></li></ul><p>广义的进程调度包含了选择一个进程和进程切换两个步骤。</p><h2 id="进程调度方式"><a class="header-anchor" href="#进程调度方式"></a>进程调度方式</h2><p>所谓进程调度方式，是指当某个进程正在处理机上执行时，若有某个更为重要或紧迫的进程需要处理，即有优先权更高的进程进入就绪队列，此时应如何分配处理机。通常有以下两种进程调度方式:</p><ol><li><p>非剥夺调度方式，又称非抢占方式。非剥夺调度方式是指当-一个进程正在处理机上执行时，即使有某个更为重要或紧迫的进程进入就绪队列，仍然让正在执行的进程继续执行，直到该进程完成或发生某种事件而进入阻塞态时，才把处理机分配给更为重要或紧迫的进程。</p><blockquote><p>在非剥夺调度方式下，一旦把CPU分配给-一个进程，该进程就会保持CPU直到终止或转换到等待态。这种方式的优点是实现简单、系统开销小，适用于大多数的批处理系统，但它不能用于分时系统和大多数的实时系统。</p></blockquote></li><li><p>剥夺调度方式，又称抢占方式。剥夺调度方式是指当一个进程正在处理机上执行时，若有某个更为重要或紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给这个更为重要或紧迫的进程。</p><blockquote><p>采用剥夺式的调度，对提高系统吞吐率和响应效率都有明显的好处。但“剥夺”不是一种任意性行为，必须遵循一定的原则，主要有优先权、短进程优先和时间片原则等。</p></blockquote></li></ol><h2 id="调度的基本准则"><a class="header-anchor" href="#调度的基本准则"></a>调度的基本准则</h2><p>不同的调度算法具有不同的特性，在选择调度算法时，必须考虑算法的特性。为了比较处理机调度算法的性能，人们提出了很多评价准则，下 面介绍其中主要的几种:</p><ol><li><p>CPU利用率。CPU是计算机系统中最重要和昂贵的资源之一，所以应尽可能使CPU保持“忙”状态，使这一资源利用率最高。<font color="#faa755">利用率=忙碌的时间/总时间</font>。</p></li><li><p>系统吞吐量。表示单位时间内CPU完成作业的数量。长作业需要消耗较长的处理机时间，因此会降低系统的吞吐量。而对于短作业，它们所需要消耗的处理机时间较短，因此能提高系统的吞吐量 。调度算法和方式的不同，也会对系统的吞吐量产生较大的影响。<font color="#faa755">系统的吞吐量=总共完成了多少道作业/总共花了多少时间</font>。</p></li><li><p>周转时间。周转时间是指从作业提交到作业完成所经历的时间，是作业等待、在就绪队列中排队、在处理机上运行及进行输入/输出操作所花费时间的总和。</p><ul><li><font color="#ea66a6">周转时间</font><font color="#faa755">＝作业完成时间-作业提交时问</font>；</li><li><font color="#ea66a6">平均周转时间</font><font color="#faa755">＝各作业周转时间之和/作业数</font>；</li><li><font color="#ea66a6">带权周转时间</font><font color="#faa755">=作业周转时间/作业实际运行时间</font>；</li><li><font color="#ea66a6">平均带权周转时间</font><font color="#faa755">=各作业周转时间之和/作业数</font>；</li></ul></li><li><p>等待时间。等待时间指进程处于等处理机状态的时间之和，等待时间越长，用户满意度越低。处理机调度算法实际上并不影响作业执行或输入/输出操作的时间，只影响作业在就绪队列中等待所花的时间。因此，<font color="#faa755">衡量一个调度算法的优劣，常常只需简单地考察等待时间</font>。当然，与前面指标类似，也有“平均等待时间”来评价整体性能。</p><blockquote><p>对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在等待I/O完成的期间其实进程也是在被服务的，所以不计入等待时间。</p><p>对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。</p></blockquote></li><li><p>响应时间。响应时间指从用户提交请求到系统首次产生响应所用的时间。在交互式系统中，周转时间不可能是最好的评价准则，一般采用响应时间作为衡量调度算法的重要准则之一。从用户角度来看，调度策略应尽量降低响应时间，使响应时间处在用户能接受的范围之内。</p></li></ol><h2 id="典型的调度算法"><a class="header-anchor" href="#典型的调度算法"></a>典型的调度算法</h2><p>操作系统中存在多种调度算法，有的调度算法适用于作业调度，有的调度算法适用于进程调度 ，有的调度算法两者都适用。下面介绍几种常用的调度算法。</p><h3 id="先来先服务-FCFS-调度算法"><a class="header-anchor" href="#先来先服务-FCFS-调度算法"></a>先来先服务(FCFS)调度算法</h3><table><thead><tr><th>知识点</th><th>相关内容</th></tr></thead><tbody><tr><td>算法思想</td><td>主要从“公平”的角度考虑（类似于我们生活中排队买东西的例子）</td></tr><tr><td>算法规则</td><td>按照作业/进程到达的先后顺序进行服务</td></tr><tr><td>用于作业/进程调度</td><td>用于作业调度时，考虑的是哪个作业先到达后备队列<br/>用于进程调度时，考虑的是哪个进程先到达就绪队列</td></tr><tr><td>是否可抢占</td><td>非抢占式的算法</td></tr><tr><td>优点</td><td>公平、算法实现简单</td></tr><tr><td>缺点</td><td>排在长作业(进程)后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好。FCFS算法对长作业有利，对短作业不利</td></tr><tr><td>是否会导致饥饿</td><td>不会</td></tr></tbody></table><p>先来先服务（FCFS，First Come First Serve）调度算法是一种最简单的调度算法 ，它既可用于作业调度，又可用于进程调度。在作业调度中，算法每次从后备作业队列中选择最先进入该队列的一个或几个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列。</p><p>在进程调度中，FCFS 调度算法每次从就绪队列中选择最先进入该队列的进程，将处理机分配给它，使之投入运行，直到完成或因某种原因而阻塞时才释放处理机。</p><p>下面通过一个实例来说明FCFS调度算法的性能。假设系统中有4个作业，它们的提交时间分别是8、8.4、 8.8、 9，运行时间依次是2、 1、 0.5、 0.2，系统采用 FCFS 调度算法，这组作业的平均等待时间、平均周转时间和平均带权周转时间见下表。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/FCFS%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD.png" alt="FCFS调度算法的性能" style="object-fit: cover; border-radius: 10px; width: 100%;" /><ul><li>周转时间 = 完成时间 - 提交时间</li><li>带权周转时间 = 周转时间 / 运行时间</li><li>等待时间 = 周转时间 - 运行时间 ( - I/O操作时间）如果有I/O操作的进程</li></ul><p>FCFS调度算法属于不可剥夺算法。从表面上看，它对所有作业都是公平的，但若一个长作业先到达系统，就会使后面的许多短作业等待很长时间，因此它不能作为分时系统和实时系统的主要调度策略。但它常被结合在其他调度策略中使用。例如，在使用优先级作为调度策略的系统中，往往对多个具有相同优先级的进程按FCFS原则处理。</p><p>FCFS调度算法的特点是算法简单，但效率低；对长作业比较有利，但对短作业不利(相对SJF和高响应比) ；有利于CPU繁忙型作业，而不利于I/O繁忙型作业。</p><h3 id="短作业优先算法（SJF）"><a class="header-anchor" href="#短作业优先算法（SJF）"></a>短作业优先算法（SJF）</h3><table><thead><tr><th>知识点</th><th>相关内容</th></tr></thead><tbody><tr><td>算法思想</td><td>追求最少的平均等待时间、最少的平均周转时间、最少的平均平均带权周转时间</td></tr><tr><td>算法规则</td><td>最短的作业/进程优先得到服务（所谓“最短”，是指要求服务时间最短）</td></tr><tr><td>用于作业/进程调度</td><td>即可用于作业调度，也可用于进程调度。<br/>用于进程调度时称为“短进程优先（SPF，Shortest Process First）算法”</td></tr><tr><td>是否可抢占</td><td>SJF 和 SPF 是非抢占式的算法。<br/>但是也有抢占式的版本最短剩余时间优先算法（SRTN，Shortest Remaining Time Next）</td></tr><tr><td>优点</td><td>“ 最短的”平均等待时间、平均周转时间</td></tr><tr><td>缺点</td><td>不公平。对短作业有利，对长作业不利。可能产生饥饿现象。<br/>另外，作业/进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先</td></tr><tr><td>是否会导致饥饿</td><td>会。如果源源不断地有短作业/进程到来，可能使长作业/进程长时间得不到服务，产生“饥饿”现象。<br/>如果一直得不到服务，则称为“饿死</td></tr></tbody></table><blockquote><p>最短剩余时间优先算法（SRTN）：每当有进程加入<font color="#FF666">就绪队列改变</font>时就需要调度，如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，当前运行进程重新回到就绪队列。另外，当一个<font color="#FF666">进程完成</font>时也需要调度。</p></blockquote><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/SJF%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD.png" alt="SJF调度算法的性能" style="object-fit: cover; border-radius: 10px; width: 100%;" /><p>注意几个小细节：</p><ol><li><p>如果题目中未特别说明，所提到的“短作业/进程优先算法”默认是非抢占式的。</p></li><li><p>很多书上都会说“SJF调度算法的平均等待时间、平均周转时间最少”</p><blockquote><p>严格来说，这个表述是错误的，不严谨的。之前的例子表明，最短剩余时间优先算法得到的平均等待时间、平均周转时间还要更少。应该加上一个条件“在所有进程同时可运行时，采用SJF调度算法的平均等待时间、平均周转时间最少”；或者说“在所有进程都几乎同时到达时，采用SJF调度算法的平均等待时间、平均周转时间最少”；如果不加上述前提条件，则应该说“抢占式的短作业/进程优先调度算法（最短剩余时间优先，SRNT算法）的平均等待时间、平均周转时间最少”。</p></blockquote></li><li><p>虽然严格来说，SJF的平均等待时间、平均周转时间并不一定最少，但相比于其他算法（如FCFS） ，SJF依然可以获得较少的平均等待时间、平均周转时间</p></li><li><p>如果选择题中遇到“SJF 算法的平均等待时间、平均周转时间最少”的选项，那最好判断其他选项是不是有很明显的错误，如果没有更合适的选项，那也应该选择该选项</p></li></ol><hr><ul><li>FCFS算法是在每次调度的时候选择一个等待时间最长的作业(进程)为其服务。但是没有考虑到作业的运行时间，因此导致了对短作业不友好的问题。</li><li>SJF算法是选择一个执行时间最短的作业为其服务。但是又完全不考虑各个作业的等待时间，因此导致了对长作业不友好的问题，甚至还会造成饥饿问题。</li></ul><h3 id="高响应比优先调度算法（HRRN）"><a class="header-anchor" href="#高响应比优先调度算法（HRRN）"></a>高响应比优先调度算法（HRRN）</h3><table><thead><tr><th>知识点</th><th>相关内容</th></tr></thead><tbody><tr><td>算法思想</td><td>要综合考虑作业/进程的等待时间和要求服务的时间</td></tr><tr><td>算法规则</td><td>在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务。响应比=（等待时间 + 要求服务时间）/ 要求服务时间</td></tr><tr><td>用于作业/进程调度</td><td>即可用于作业调度，也可用于进程调度</td></tr><tr><td>是否可抢占</td><td>非抢占式的算法。因此只有当前运行的作业/进程主动放弃处理机时，才需要调度，才需要计算响应比</td></tr><tr><td>优点</td><td>综合考虑了等待时间和运行时间（要求服务时间）<br/>等待时间相同时，要求服务时间短的优先（SJF 的优点）<br/>要求服务时间相同时，等待时间长的优先（FCFS 的优点）<br/>对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题</td></tr><tr><td>是否会导致饥饿</td><td>不会</td></tr></tbody></table><p>根据响应比公式可知：</p><ol><li>作业的等待时间相同时，要求服务时间越短，响应比越高，有利于短作业</li><li>要求服务时间相同时，作业的响应比由其等待时间决定，等待时间越长，其响应比越高， 因而它实现的是先来先服务。</li><li>对于长作业，作业的响应比可以随等待时间的增加而提高， 等待时间足够长时，其响应 比便可升到很高，从而也可获得处理机。因此，克服了饥饿状态，兼顾了长作业。</li></ol><p>注：以上三种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标，但是不关心“响应时间”，也并不区分任务的紧急程度，因此对于用户来说，交互性很糟糕。因此这三种算法一般适合用于早期的批处理系统，当然，FCFS算法也常结合其他的算法使用，在现在也扮演着很重要的角色。</p><h3 id="时间片轮转调度算法（RR）"><a class="header-anchor" href="#时间片轮转调度算法（RR）"></a>时间片轮转调度算法（RR）</h3><table><thead><tr><th>知识点</th><th>相关内容</th></tr></thead><tbody><tr><td>算法思想</td><td>公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</td></tr><tr><td>算法规则</td><td>按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如100ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。</td></tr><tr><td>用于作业/进程调度</td><td>用于进程调度（只有作业放入内存建立了相应的进程后，才能被分配处理机时间片）</td></tr><tr><td>是否可抢占</td><td>若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法。由时钟装置发出时钟中断来通知CPU时间片已到</td></tr><tr><td>优点</td><td>公平；响应快，适用于分时操作系统;</td></tr><tr><td>缺点</td><td>由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度。</td></tr><tr><td>是否会导致饥饿</td><td>不会</td></tr></tbody></table><p>如果时间片太大，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间。因此时间片不能太大。</p><p>另一方面，进程调度、切换是有时间代价的(保存、恢复运行环境)，因此如果时间片太小，会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。可见时间片也不能太小。</p><p>一般来说，设计时间片时要让切换进程的开销占比不超过1%</p><h3 id="优先级调度算法"><a class="header-anchor" href="#优先级调度算法"></a>优先级调度算法</h3><table><thead><tr><th>知识点</th><th>相关内容</th></tr></thead><tbody><tr><td>算法思想</td><td>随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序</td></tr><tr><td>算法规则</td><td>每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程</td></tr><tr><td>用于作业/进程调度</td><td>既可用于作业调度，也可用于进程调度。甚至，还会用于I/O调度</td></tr><tr><td>是否可抢占</td><td>抢占式、非抢占式都有。做题时的区别在于：非抢占式只需在进程主动放弃处理机时进行调度即可，而抢占式还需在就绪队列变化时，检查是否会发生抢占。</td></tr><tr><td>优点</td><td>用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活地调整对各种作业/进程的偏好程度。</td></tr><tr><td>缺点</td><td>若源源不断地有高优先级进程到来，则可能导致饥饿</td></tr><tr><td>是否会导致饥饿</td><td>会</td></tr></tbody></table><p>非抢占式的优先级调度算法：每次调度时选择当前已到达且优先级最高的进程。当前进程主动放弃处理机时发生调度。</p><p>抢占式的优先级调度算法：每次调度时选择当前已到达且优先级最高的进程。当前进程主动放弃处理机时发生调度。另外，当就绪队列发生改变时也需要检查是会发生抢占。</p><p>就绪队列未必只有一个，可以按照不同优先级来组织。另外，也可以把优先级高的进程排在更靠近队头的位置。</p><p>根据优先级是否可以动态改变，可将优先级分为静态优先级和动态优先级两种：</p><ul><li>静态优先级：创建进程时确定，之后一直不变。</li><li>动态优先级：创建进程时有一个初始值，之后会根据情况动态地调整优先级。</li></ul><p>如何合理地设置各类进程的优先级? 通常：</p><ul><li><p>系统进程优先级高于用户进程</p></li><li><p>前台进程优先级高于后台进程</p></li><li><p>操作系统更偏好I/O型进程（或称I/O繁忙型进程），与I/O型进程相对的是计算型进程（或称CPU繁忙型进程）</p><blockquote><p>I/O设备和CPU可以并行工作。如果优先让I/O繁忙型进程优先运行的话，则越有可能让I/O设备尽早地投入工作，则资源利用率、系统吞吐量都会得到提升</p></blockquote></li></ul><p>如果采用的是动态优先级，什么时候应该调整? 可以从追求公平、提升资源利用率等角度考虑。</p><ul><li>如果某进程在就绪队列中等待了很长时间，则可以适当提升其优先级</li><li>如果某进程占用处理机运行了很长时间，则可适当降低其优先级</li><li>如果发现一个进程频繁地进行I/O操作，则可适当提升其优先级</li></ul><blockquote><p>Linux 中每个进程都有一个优先数，进程能否占用处理器的优先权取决于进程的优先数，优先数越小则优先权越高。Windows中每一个线程在内核中有一个优先级顺序，这个顺序的取值范围是0-31，数字越大优先级越高。</p></blockquote><h3 id="多级反馈队列调度算法（融合了前几种算法的优点）"><a class="header-anchor" href="#多级反馈队列调度算法（融合了前几种算法的优点）"></a>多级反馈队列调度算法（融合了前几种算法的优点）</h3><table><thead><tr><th>知识点</th><th>相关内容</th></tr></thead><tbody><tr><td>算法思想</td><td>对其他调度算法的折中权衡</td></tr><tr><td>算法规则</td><td>设置多级就绪队列，各级队列优先级从高到低，时间片从小到大<br/>新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾<br/>只有第k级队列为空时，才会为k+1级队头的进程分配时间片</td></tr><tr><td>用于作业/进程调度</td><td>用于进程调度</td></tr><tr><td>是否可抢占</td><td>抢占式的算法。在k级队列的进程运行过程中，若更上级的队列(1~k-1级)中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回k级队列队尾。</td></tr><tr><td>优点</td><td>对各类型进程相对公平（FCFS的优点）；<br/>每个新到达的进程都可以很快就得到响应（RR的优点）；<br/>短进程只用较少的时间就可完成（SPF的优点）；<br/>不必实现估计进程的运行时间（避免用户作假）<br/>可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I/O密集型进程（可以将因I/O而阻塞的进程重新放回原队列，这样I/O型讲程就可以保持较高优先级</td></tr><tr><td>是否会导致饥饿</td><td>会</td></tr></tbody></table><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95.png" alt="多级反馈队列调度算法" style="object-fit: cover; border-radius: 10px; width: 100%;" /><h2 id="进程同步、互斥"><a class="header-anchor" href="#进程同步、互斥"></a>进程同步、互斥</h2><ol><li>为什么要引入进程同步的概念？</li><li>不同的进程之间会存在什么关系？</li><li>当单纯用本节介绍的方法解决这些问题时会遇到什么新的问题吗？</li></ol><h3 id="进程同步的基本概念"><a class="header-anchor" href="#进程同步的基本概念"></a>进程同步的基本概念</h3><p>在多道程序环境下，进程是井发执行的，不同进程之间存在着不同的相互制约关系。为了协调进程之间的相互制约关系，引入了进程同步的概念。</p><h4 id="同步"><a class="header-anchor" href="#同步"></a>同步</h4><p><font color="#ea66a6">同步</font>亦称<font color="#FF666">直接制约关系</font>，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上<font color="#FF666">协调</font>它们的<font color="#FF666">工作次序</font>而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。</p><h4 id="互斥"><a class="header-anchor" href="#互斥"></a>互斥</h4><p><font color="#ea66a6">互斥</font>也称<font color="#FF666">间接制约关系</font>。当一个进程进入临界区使用临界资源时，另一个进程必须等待，当占用临界资源的进程退出临界区后，另一进程才允许去访问此临界资源。</p><p>例如，在仅有一台打印机的系统中，有两个进程A和进程B，若进程A需要打印时，系统已将打印机分配给进程B，则进程A必须阻塞。一旦进程B将打印机释放，系统便将进程A唤醒，并将其由阻塞态变为就绪态。</p><p>为禁止两个进程同时进入临界区，同步机制应遵循以下准则：</p><ol><li>空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区。</li><li>忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待。</li><li>有限等待。对请求访问的进程，应保证能在有限时间内进入临界区。</li><li>让权等待。当进程不能进入临界区时，应立即释放处理器，防止进程忙等待。</li></ol><h4 id="临界资源"><a class="header-anchor" href="#临界资源"></a>临界资源</h4><p>虽然多个进程可以共享系统中的各种资源，但其中许多资源一次只能为一个进程所用，我们将一次仅允许一个进程使用的资源称为临界资源。许多物理设备都属于临界资源，如打印机等。此外，还有许多变量、数据等都可以被若干进程共享，也属于临界资源。</p><p>对临界资源的访问，必须互斥地进行，在每个进程中，访问临界资源的那段代码称为临界区。为了保证临界资源的正确使用，可把临界资源的访问过程分成4个部分：</p><ol><li>进入区。为了进入临界区使用临界资源，在进入区要检查是否可以进入临界区，若能进入临界区，则应设置正在访问临界区的标志，以阻止其他进程同时进入临界区。（“上锁”）</li><li>临界区。进程中访问临界资源的那段代码，又称<font color="#FF666">临界段</font>。</li><li>退出区。将正在访问临界区的标志清除。（“解锁”）</li><li>剩余区。代码中的其余部分。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    entry section;     <span class="comment">// 进入区</span></span><br><span class="line">    critical section;  <span class="comment">// 临界区</span></span><br><span class="line">    exit section;      <span class="comment">// 退出区</span></span><br><span class="line">    remainder section; <span class="comment">// 剩余区</span></span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><h3 id="临界区互斥的软件实现方法"><a class="header-anchor" href="#临界区互斥的软件实现方法"></a>临界区互斥的软件实现方法</h3><ol><li>理解各个算法的思想、原理</li><li>结合上小节学习的“实现互斥的四个逻辑部分”，重点理解各算法在进入区、退出区都做了什么</li><li>分析各算法存在的缺陷（结合“实现互斥要遵循的四个原则”进行分析）</li></ol><p>在进入区设置并检查一些标志来标明是否有进程在临界区中，若已有进程在临界区，则在进入区通过循环检查进行等待，进程离开临界区后则在退出区修改标志。</p><h4 id="单标志法"><a class="header-anchor" href="#单标志法"></a>单标志法</h4><p>算法思想：两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予。</p><p>该算法设置一个公用整型变量 turn，用于指示被允许进入临界区的进程编号，即若 <code>turn=0</code> ,则允许 P<sub>0</sub> 进程进入临界区。该算法可确保每次只允许一个进程进入临界区。但两个进程必须交替进入临界区，若某个进程不再进入临界区，则另一个进程也将无法进入临界区（违背“空闲让进”）。这样很容易造成资源利用不充分。</p><p>若 P<sub>0</sub>  顺利进入临界区并从临界区离开，则此时临界区是空闲的，但 P<sub>1</sub> 并没有进入临界区的打算，<code>turn=1</code> 一直成立， P<sub>0</sub> 就无法再次进入临界区（一直被while死循环困住）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> turn = <span class="number">0</span>;      <span class="comment">// turn表示当前允许进入临界区的进程号</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// P0 进程</span></span><br><span class="line"><span class="keyword">while</span>(trun != <span class="number">0</span>);  <span class="comment">// 进入区</span></span><br><span class="line">critical section;  <span class="comment">// 临界区</span></span><br><span class="line">turn = <span class="number">1</span>;          <span class="comment">// 退出区</span></span><br><span class="line">remainder section; <span class="comment">// 剩余区</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// P1 进程</span></span><br><span class="line"><span class="keyword">while</span>(trun != <span class="number">1</span>);  <span class="comment">// 进入区</span></span><br><span class="line">critical section;  <span class="comment">// 临界区</span></span><br><span class="line">turn = <span class="number">0</span>;          <span class="comment">// 退出区</span></span><br><span class="line">remainder section; <span class="comment">// 剩余区</span></span><br></pre></td></tr></table></figure><h4 id="双标志法先检查"><a class="header-anchor" href="#双标志法先检查"></a>双标志法先检查</h4><p>算法思想：设置一个布尔型数组<code>flag[]</code>，数组中各个元素用来标记各进程想进入临界区的意愿，比如<code>flag[0] =true</code>意味着0号进程 P<sub>0</sub> 现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志<code>flag[i]</code>设为true，之后开始访问临界区。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> flag[<span class="number">2</span>];    <span class="comment">// 表示进入临界区意愿的数组</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>; <span class="comment">// 刚开始设置两个进程都不想进入临界区</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// P0 进程</span></span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>]);   <span class="comment">// ①</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;   <span class="comment">// ③</span></span><br><span class="line">critical section;  </span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;          </span><br><span class="line">remainder section; </span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// P1 进程</span></span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">0</span>]);    <span class="comment">// ② 如果此时P0想进入临界区，P1就一直循环等待</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;    <span class="comment">// ④</span></span><br><span class="line">critical section;  </span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;          </span><br><span class="line">remainder section; </span><br></pre></td></tr></table></figure><p>优点：不用交替进入，可连续使用</p><p>缺点： P<sub>0</sub> 和 P<sub>1</sub> 可能同时进入临界区。按序列①②③④执行时，执行时，会同时进入临界区（违背“忙则等待”）。即在检查对方的 flag 后和切换自己的 flag 前有一段时间，结果都检查通过。这里的问题出在检查和修改操作不能一次进行（不是原子性操作）。</p><h4 id="双标志法后检查"><a class="header-anchor" href="#双标志法后检查"></a>双标志法后检查</h4><p>算法思想：双标志先检查法的改版。前一个算法的问题是先“检查”后“上锁”，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题。因此，人们又想到先“上锁”后“检查”的方法，来避免上述问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> flag[<span class="number">2</span>];    <span class="comment">// 表示进入临界区意愿的数组</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>; <span class="comment">// 刚开始设置两个进程都不想进入临界区</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// P0 进程</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>; </span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>]);</span><br><span class="line">critical section;  </span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;          </span><br><span class="line">remainder section; </span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// P1 进程</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">0</span>]);    <span class="comment">// 如果此时P0想进入临界区，P1就一直循环等待</span></span><br><span class="line">critical section;  </span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;          </span><br><span class="line">remainder section; </span><br></pre></td></tr></table></figure><p>两个进程几乎同时都想进入临界区时，它们分别将自己的标志值 flag 设置为 true，并且同时检测对方的状态（执行while语句） ，发现对方也要进入临界区时，双方互相谦让，结果谁也进不了临界区，从而导致“饥饿”现象。</p><h4 id="Peterson’s-Algorithm"><a class="header-anchor" href="#Peterson’s-Algorithm"></a>Peterson’s Algorithm</h4><p>算法思想：双标志后检查法中，两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。Gary L. Peterson 想到了一种方法，如果双方都争着想进入临界区，那可以让进程尝试“谦让”，主动让对方先使用临界区。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> flag[<span class="number">2</span>];    <span class="comment">// 表示进入临界区意愿的数组</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>; <span class="comment">// 刚开始设置两个进程都不想进入临界区</span></span><br><span class="line"><span class="keyword">int</span> turn = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pi 进程</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>; </span><br><span class="line">turn = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>] &amp;&amp; turn==<span class="number">1</span>);</span><br><span class="line">critical section;  </span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;          </span><br><span class="line">remainder section; </span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pj 进程</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>                <span class="comment">// 表示自己想进入临界区</span></span><br><span class="line">turn = <span class="number">0</span>;                     <span class="comment">// 可以优先让对方进入临界区</span></span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">0</span>] &amp;&amp; turn==<span class="number">0</span>);    <span class="comment">// 对方想进，且最后一次是自己“让梨”，那自己就循环等待</span></span><br><span class="line">critical section;  </span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;          </span><br><span class="line">remainder section; </span><br></pre></td></tr></table></figure><p>具体如下：</p><ul><li>考虑进程 P<sub>0</sub> ，一旦设置<code>flag[0] = true</code>，就表示它想要进入临界区，同时<code>turn = 1</code>，此时若进程 P<sub>1</sub> ，已在临界区中，符合进程 P<sub>0</sub> 中的 while 循环条件，则 P<sub>0</sub> 不能进入临界区。</li><li>若 P<sub>1</sub> 不想要进入临界区，即<code>flag[1] = false</code>，循环条件不符合，则 P<sub>0</sub> 可以顺利进入，反之亦然。</li></ul><p>本算法的基本思想是算法一和算法三的结合。利用flag解决临界资源的互斥访问，而利用 turn 解决“饥饿”现象。</p><h3 id="临界区互斥的硬件实现方法"><a class="header-anchor" href="#临界区互斥的硬件实现方法"></a>临界区互斥的硬件实现方法</h3><p>理解本节介绍的硬件实现，对学习后面的信号量很有帮助。计算机提供了特殊的硬件指令，允许对一个字中的内容进行检测和修正，或对两个字的内容进行交换等。通过硬件支持实现临界段问题的方法称为低级方法，或称元方法。</p><h4 id="中断屏蔽方法"><a class="header-anchor" href="#中断屏蔽方法"></a>中断屏蔽方法</h4><p>利用“开/关中断指令”实现（与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况）</p><p>当一个进程正在使用处理机执行它的临界区代码时，防止其他进程进入其临界区进行访问的最简方法是，禁止一切中断发生，或称之为屏蔽中断、关中断。</p><p>因为CPU只在发生中断时引起进程切换，因此屏蔽中断能够保证当前运行的进程让临界区代码顺利地执行完，进而保证互斥的正确实现，然后执行开中断。其典型模式为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">关中断;  &#x2F;&#x2F; 关中断后即不允许当前进程被中断，也必然不会发生进程切换</span><br><span class="line">临界区;</span><br><span class="line">开中断;  &#x2F;&#x2F; 直到当前进程访问完临界区，再执行开中断指令，才有可能有别的进程上处理机并访问临界区</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>优点：简单、高效</p><p>缺点：不适用于多处理机；只适用于操作系统内核进程，不适用于用户进程（因为开/关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险）</p><p>这种方法限制了处理机交替执行程序的能力，因此执行的效率会明显降低。对内核来说，在它执行更新变量或列表的几条指令期间，关中断是很方便的，但将关中断的权力交给用户则很不明智，若一个进程关中断后不再开中断，则系统可能会因此终止。</p><h4 id="TestAndSet-指令"><a class="header-anchor" href="#TestAndSet-指令"></a>TestAndSet 指令</h4><p>简称TS指令，也有地方称为 TestAndSetLock 指令，或TSL指令。这条指令是原子操作，即执行该代码时不允许被中断 。其功能是读出指定标志后把该标志设置为真。指令的逻辑功能描述如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 布尔型共享变量 lock 表示当前临界区是否被加锁</span></span><br><span class="line"><span class="comment">// true表示已加锁，false 表示未加锁</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TestAndSet</span> <span class="params">(<span class="keyword">bool</span> *lock)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> old;</span><br><span class="line">    old = *lock;  <span class="comment">// old用来存放 lock 原来的值</span></span><br><span class="line">    *lock = <span class="literal">true</span>; <span class="comment">// 无论之前是否已加锁，都将 lock 设为 true</span></span><br><span class="line">    <span class="keyword">return</span> old;   <span class="comment">// 返回 lock 原来的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TSL 指令实现互斥的算法逻辑</span></span><br><span class="line"><span class="keyword">while</span> (TestAndSet (&amp;lock)); <span class="comment">// 上锁并检查</span></span><br><span class="line"><span class="comment">// 临界区代码</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">lock  <span class="literal">false</span>; <span class="comment">// 解锁</span></span><br><span class="line"><span class="comment">// 剩余区代码</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>若刚开始 lock 是 false ，则 TSL 返回的 old 值为 false ，while 循环条件不满足，直接跳过循环，进入临界区。若刚开始lock是 true，则执行 TLS 后 old 返回的值为 true，while 循环条件满足，会一直循环，直到当前访问临界区的进程在退出区进行“解锁”。</p><p>相比软件实现方法，TSL 指令把“上锁”和“检查”操作用硬件的方式变成了一气呵成的原子操作。</p><p>优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境</p><p>缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行 TSL 指令，从而导致“忙等”。</p><h4 id="Swap-指令"><a class="header-anchor" href="#Swap-指令"></a>Swap 指令</h4><p>有的地方也叫Exchange指令，或简称XCHG指令。</p><p>Swap指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。以下是用C语言描述的逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swap 指令：该指令的功能是交换两个字（字节）的内容</span></span><br><span class="line">Swap(<span class="keyword">bool</span> *a, <span class="keyword">bool</span> *b)&#123;</span><br><span class="line">    <span class="keyword">bool</span> temp;</span><br><span class="line">    temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Swap 指令实现互斥的算法逻辑</span></span><br><span class="line"><span class="comment">// lock 表示当前临界区是否被加锁</span></span><br><span class="line"><span class="keyword">bool</span> old = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (old == <span class="literal">true</span>)&#123;</span><br><span class="line">    Swap(&amp;lock, &amp;old);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 临界区代码</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">lock  <span class="literal">false</span>; <span class="comment">// 解锁</span></span><br><span class="line"><span class="comment">// 剩余区代码</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>逻辑上来看 Swap 和 TSL 并无太大区别，都是先记录下此时临界区是否已经被上锁（记录在old变量上)，再将上锁标记 lock 设置为 true，最后检查 old，如果 old 为 false 则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区。</p><p>优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境</p><p>缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”。</p><h3 id="⭐信号量机制（高频考点）"><a class="header-anchor" href="#⭐信号量机制（高频考点）"></a>⭐信号量机制（高频考点）</h3><p>信号量机制是一种功能较强的机制，可用来解决互斥与同步问题，它只能被两个标准的原语 wait(S) 和 signal(S) 访问，也可记为“P操作”和“V操作”。(来自荷兰语 proberen 检测 和 verhogen 释放 )</p><p>原语是指完成某种功能且<font color="#faa755">不被分割</font>、<font color="#faa755">不被中断</font>执行的操作序列，通常可由硬件来实现（关中断/开中断指令实现）。例如，前述的 Test-and-Set 和 Swap 指令就是由硬件实现的原子操作。原语功能的不被中断执行特性在单处理机上可由软件通过屏蔽中断方法实现。</p><p>原语之所以不能被中断执行，是因为原语对变量的操作过程若被打断，可能会去运行另一个对同一变量的操作过程，从而出现临界段问题。若能够找到一种解决临界段问题的元方法，就可以实现对共享变量操作的原子性。</p><p>用户进程可以通过使用操作系统提供的<font color="#FF666">一对原语</font>来对<font color="#FF666">信号量</font>进行操作，从而很方便的实现了进程互斥、进程同步。</p><p>一对原语：wait(S) 原语和 signal(S) 原语，可以把原语理解为我们自己写的函数，函数名分别为 wait 和 signal，括号里的信号量 S 其实就是函数调用时传入的一个参数。</p><p><font color="#ea66a6">信号量</font>其实就是一个变量（<font color="#33a3dc">可以是一个整数，也可以是更复杂的记录型变量</font>），可以用一个信号量来表示，<font color="#FF666">系统中某种资源的数量</font>，比如：系统中只有一台打印机，就可以设置一个初值为1的信号量。</p><h4 id="整型信号量"><a class="header-anchor" href="#整型信号量"></a>整型信号量</h4><p>用一个<font color="#FF666">整数型的变量</font>作为信号量，用来表示系统中某种资源的数量。</p><blockquote><p>与普通整数变量的区别：对信号量的操作只有三种，即初始化、P操作、V操作</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> S = <span class="number">1</span>; <span class="comment">// 初始化整形信号量S,表示当前系统中可用的某资源数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span> <span class="params">(<span class="keyword">int</span> S)</span> </span>&#123;     <span class="comment">// wait 原语,相当于“进入区”</span></span><br><span class="line">    <span class="keyword">while</span> (S &lt;= <span class="number">0</span>);    <span class="comment">// 如果资源数不够，就一直循环等待</span></span><br><span class="line">    S = S - <span class="number">1</span>;         <span class="comment">// 如果资源数够，则占用一个资源</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span> <span class="params">(<span class="keyword">int</span> S)</span> </span>&#123;  <span class="comment">// signal 原语，相当于“退出区”</span></span><br><span class="line">    S = S + <span class="number">1</span>;         <span class="comment">// 使用完资源后，在退出区释放资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：“检查”和“上锁”一气呵成，避免了并发、异步导致的问题</p><p>缺点：不满足“让权等待”原则，会发生“忙等”</p><h4 id="记录型信号量"><a class="header-anchor" href="#记录型信号量"></a>记录型信号量</h4><p>整型信号量的缺陷是存在“忙等”问题，因此人们又提出了“记录型信号量”，即用记录型数据结构表示的信号量。</p><p>记录型信号量是不存在“忙等”现象的进程同步机制。除需要一个用于代表资源数目的整型变量value外，再增加一个进程链表L，用于链接所有等待该资源的进程。记录型信号量得名于采用了记录型的数据结构。记录型信号量可描述为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*记录型信号量*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;         <span class="comment">// 剩余资源数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">L</span>;</span> <span class="comment">// 等待队列</span></span><br><span class="line">&#125; semaphore;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 某进程需要使用资源时，通过wait 原语申请</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span> <span class="params">(semaphore S)</span> </span>&#123;</span><br><span class="line">    S.value--;</span><br><span class="line">    <span class="keyword">if</span> (S.value &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 如果剩余资源数不够，使用block原语使进程从运行态进入阻塞态</span></span><br><span class="line">        <span class="comment">// 并把挂到信号量S的等待队列(即阻塞队列)中</span></span><br><span class="line">        add <span class="keyword">this</span> process to S.L; </span><br><span class="line">        block(S.L); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>wait 操作，<code>S.value--</code>表示进程请求一个 该类资源，当<code>S.value &lt; 0</code>时，表示该类资源已分配完毕，因此进程应调用block原语，进行自我阻塞，放弃处理机，并插入该类资源的等待队列<code>S.L</code>，可见该机制遵循了“让权等待”的准则。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进程使用完资源后，通过signal原语释放</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span> <span class="params">(semaphore S)</span> </span>&#123;</span><br><span class="line">    S.value++;</span><br><span class="line">    <span class="keyword">if</span> (S.value &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        remove a process P from S.L; </span><br><span class="line">        wakeup(P);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>signal操作，表示进程释放一个资源，使系统中可供分配的该类资源数增1，因此有<code>S.value++</code>。若加1后仍是<code>S.value≤0</code>，则表示在<code>S.L</code>中仍有等待该资源的进程被阻塞，因此还应调用 wakeup 原语，将<code>S.L</code>中的第一个等待进程唤醒。</p><h4 id="信号量机制实现进程互斥"><a class="header-anchor" href="#信号量机制实现进程互斥"></a>信号量机制实现进程互斥</h4><ol><li>分析并发进程的关键活动，划定临界区（如：对临界资源打印机的访问就应放在临界区）</li><li>设置互斥信号量 mutex ，初值为1</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*信号量机制实现互斥*/</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;  <span class="comment">// 初始化信号量</span></span><br><span class="line"></span><br><span class="line">P1()&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    P(mutex);  <span class="comment">// 准备开始访问临界资源，加锁</span></span><br><span class="line">    <span class="comment">// P1临界区代码段...</span></span><br><span class="line">    V(mutex);  <span class="comment">// 使用临界资源后需要解锁</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P2()&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    P(mutex);  <span class="comment">// 准备开始访问临界资源，加锁</span></span><br><span class="line">    <span class="comment">// P2临界区代码段...</span></span><br><span class="line">    V(mutex);  <span class="comment">// 使用临界资源后需要解锁</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当没有进程在临界区时，任意一个进程要进入临界区，就要执行P操作，把 mutex 的值减为0，然后进入临界区；</li><li>当有进程存在于临界区时，mutex 的值为0，再有进程要进入临界区，执行P操作时将会被阻塞，直至在临界区中的进程退出，这样便实现了临界区的互斥。</li></ul><p>互斥是不同进程对同一信号量进行P，V操作实现的，一个进程成功对信号量执行了P操作后进入临界区，并在退出临界区后，由该进程本身对该信号量执行 V 操作，表示当前没有进程进入临界区，可以让其他进程进入。</p><p>下面简单总结一下PV操作在同步互斥中的应用：在同步问题中，若某个行为要用到某种资源，则在这个行为前面P这种资源一下；若某个行为会提供某种资源，则在这个行为后面V这种资源一下。在互斥问题中, P，V操作要紧夹使用互斥资源的那个行为，中间不能有其他冗余代码。</p><p>注意：对不同的临界资源需要设置不同的互斥信号量。</p><p>P、V操作必须成对出现。缺少P(mutex)就不能保证临界资源的互斥访问。缺少V(mutex)会导致资源永不被释放，等待进程永不被唤醒。</p><h4 id="信号量机制实现进程同步"><a class="header-anchor" href="#信号量机制实现进程同步"></a>信号量机制实现进程同步</h4><p>进程同步：要让各并发进程按要求有序地推进。让本来异步并发的进程互相配合，有序推进。</p><ol><li>分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作（或两句代码）</li><li>设置同步信号量S，初始为0</li><li>在“前操作”之后执行V(S)</li><li>在“后操作”之前执行P(S)</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*信号量机制实现进程同步*/</span></span><br><span class="line">semaphore S = <span class="number">0</span>;  <span class="comment">// 初始化信号量</span></span><br><span class="line"></span><br><span class="line">P1()&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    x;    <span class="comment">// 语句x</span></span><br><span class="line">    V(S); <span class="comment">// 告诉进程P2，语句己经完成</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P2()&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    P(S); <span class="comment">// 检查语句x是否运行完成</span></span><br><span class="line">    y;    <span class="comment">// 检查无误，运行 语句</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>若先执行到 V(S) 操作，则 S++ 后 S=1 。之后当执行到 P(S) 操作时，由于S=1，表示有可用资源，会执行 S-- , S的值变回0，P2进程不会执行block原语，而是继续往下执行代码；</li><li>若先执行到 P(S) 操作，由于S=0，S-- 后S=-1，表示此时没有可用资源，因此P操作中会执行block原语，主动请求阻塞。之后当执行完代码x，继而执行 V(S) 操作，S++，使S变回0，由于此时有进程在该信号量对应的阻塞队列中，因此会在V操作中执行wakeup原语，唤醒P2进程。这样P2就可以继续执行代码y了</li></ul><h4 id="信号量机制实现前驱关系"><a class="header-anchor" href="#信号量机制实现前驱关系"></a>信号量机制实现前驱关系</h4><p>信号量也可用来描述程序之间或语句之间的前驱关系。下图给出了一个前驱图，其中S1、S2、S3…S6是最简单的程序段（只有一条语句）。为使各程序段能正确执行，应设置若干初始值为“ 0” 的信号量。 例如，为保证S1 → S2，S1 → S3 的前驱关系，应分别设置信号量a1，a2。同样，为保证S2 → S4，S2 → S5，S3 → S6，S4 → S6，S5 → S6，应设置信号量b1，b2，c，d，e。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%89%8D%E9%A9%B1%E5%9B%BE%E4%B8%BE%E4%BE%8B.png" alt="前驱图举例" style="object-fit: cover; border-radius: 10px; width: 70%;" /><ol><li>要为每一对前驱关系各设置一个同步变量</li><li>在“前操作”之后对相应的同步变量执行 V 操作</li><li>在“后操作”之前对相应的同步变量执行 P 操作</li></ol><p>实现算法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">semaphore a1=a2=b1=b2=c=d=e=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">P1()&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    S1;</span><br><span class="line">    V(a1);</span><br><span class="line">    V(a2);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P2()&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    P(a1);</span><br><span class="line">    S2;</span><br><span class="line">    V(b1);</span><br><span class="line">    V(b2);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P3()&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    P(a2);</span><br><span class="line">    S3;</span><br><span class="line">    V(e);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P4()&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    P(b1);</span><br><span class="line">    S4;</span><br><span class="line">    V(c);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P5()&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    P(b2);</span><br><span class="line">    S5;</span><br><span class="line">    V(d);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P6()&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    P(c);</span><br><span class="line">    P(d);</span><br><span class="line">    P(e);</span><br><span class="line">    S6;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分析进程同步和互斥问题的方法步骤"><a class="header-anchor" href="#分析进程同步和互斥问题的方法步骤"></a>分析进程同步和互斥问题的方法步骤</h3><ol><li>关系分析。找出问题中的进程数，并分析它们之间的同步和互斥关系。同步、互斥、前驱关系直接按照上面例子中的经典范式改写。</li><li>整理思路。找出解决问题的关键点，并根据做过的题目找出求解的思路。根据进程的操作流程确定P操作、V操作的大致顺序。</li><li>设置信号量。根据上面的两步，设置需要的信号量，确定初值，完善整理。(互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少)</li></ol><h4 id="生产者消费者问题"><a class="header-anchor" href="#生产者消费者问题"></a>生产者消费者问题</h4><p>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。（注: 这里的“产品”理解为某种数据）</p><ul><li>生产者、消费者共享一个初始为空、大小为n的缓冲区。</li><li>只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待。（同步关系。缓冲区满时，生产者要等待消费者取走产品）</li><li>只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。（同步关系。缓冲区空时，消费者要等待生产者放入产品）</li><li>缓冲区是临界资源，各进程必须互斥地访问。（互斥关系）</li></ul><p>如何用信号量机制(P、 V操作)实现生产者、消费者进程的这些功能呢？</p><p>思路：</p><ul><li>生产者每次要消耗§一个空闲缓冲区，并生产(V)一个产品。</li><li>消费者每次要消耗§一个产品，并释放一个空闲缓冲区(V)。</li><li>往缓冲区放入/取走产品需要互斥。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;  <span class="comment">// 互斥信号量，实现对缓冲区的互斥访问</span></span><br><span class="line">semaphore empty = n;  <span class="comment">// 同步信号量，表示空闲缓冲区的数量</span></span><br><span class="line">semaphore full = <span class="number">0</span>;   <span class="comment">// 同步信号量，表示产品的数量，也即非空缓冲区的数量</span></span><br><span class="line"></span><br><span class="line">producer()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 生产产品...</span></span><br><span class="line">        P(empty); <span class="comment">// 消耗一个空闲缓冲区</span></span><br><span class="line">        P(mutex);</span><br><span class="line">        <span class="comment">// 把产品放入缓冲区...</span></span><br><span class="line">        V(mutex);</span><br><span class="line">        V(full);  <span class="comment">// 增加一个产品</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">consumer()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(full); <span class="comment">// 消耗一个产品(非空缓冲区)</span></span><br><span class="line">        P(mutex);</span><br><span class="line">        <span class="comment">// 从缓冲区取走一个产品...</span></span><br><span class="line">        V(mutex);</span><br><span class="line">        V(empty); <span class="comment">// 增加一个空闲缓冲区</span></span><br><span class="line">        <span class="comment">// 使用产品...        </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现互斥是在同一进程中进行一对PV操作；</li><li>实现两进程的同步关系，是在其中一个进程中执行P，另进程中执行V</li><li>实现互斥的P操作一定要在实现同步的P操作之后。否则可能会产生“死锁”</li><li>V操作不会导致进程阻塞，因此两个V操作顺序可以交换。</li></ul><h4 id="多生产者多消费者问题"><a class="header-anchor" href="#多生产者多消费者问题"></a>多生产者多消费者问题</h4><p>桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放-一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。</p><p>多指多类，而不是多个</p><p>互斥关系：对缓冲区(盘子)的访问要互斥地进行</p><p>同步关系：</p><ol><li>父亲将苹果放入盘子后，女儿才能取苹果</li><li>母亲将橘子放入盘子后，儿子才能取橘子</li><li>只有盘子为空时， 父亲或母亲才能放入水果，“盘子为空”这个事件可以由儿子或女儿触发，事件发生后才允许父亲或母亲放水果</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore apple = <span class="number">0</span>;  <span class="comment">// 盘中中有几个苹果</span></span><br><span class="line">semaphore orange = <span class="number">0</span>; <span class="comment">// 盘中有几个橘子</span></span><br><span class="line">semaphore plate = <span class="number">1</span>;  <span class="comment">// 盘中还可以放多少个水果</span></span><br><span class="line"></span><br><span class="line">dad()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 准备苹果...</span></span><br><span class="line">        P(plate);  <span class="comment">// 检查盘子还可以放多少水果</span></span><br><span class="line">        P(mutex);</span><br><span class="line">        <span class="comment">// 把苹果放入盘子...</span></span><br><span class="line">        V(mutex);</span><br><span class="line">        V(apple);  <span class="comment">// 告诉女儿苹果数量+1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">mom()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 准备橘子...</span></span><br><span class="line">        P(plate);  <span class="comment">// 检查盘子还可以放多少水果</span></span><br><span class="line">        P(mutex);</span><br><span class="line">        <span class="comment">// 把橘子放入盘子...</span></span><br><span class="line">        V(mutex);</span><br><span class="line">        V(orange);  <span class="comment">// 告诉儿子橘子数量+1</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">daughter()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(apple);  <span class="comment">// 检查是否有苹果</span></span><br><span class="line">        P(mutex);</span><br><span class="line">        <span class="comment">// 从盘中取出苹果...</span></span><br><span class="line">        V(mutex);</span><br><span class="line">        V(plate);  <span class="comment">// 盘子水果数-1</span></span><br><span class="line">        <span class="comment">// 吃掉苹果...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">son()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(orange);  <span class="comment">// 检查是否有橘子</span></span><br><span class="line">        P(mutex);</span><br><span class="line">        <span class="comment">// 从盘中取出橘子...</span></span><br><span class="line">        V(mutex);</span><br><span class="line">        V(plate);  <span class="comment">// 盘子水果数-1</span></span><br><span class="line">        <span class="comment">// 吃掉橘子...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>本题可以不设置互斥变量mutex，因为本题缓冲区的大小为1，在任何时刻，apple、 orange、 plate 三个同步信号量中最多只有一个是1。因此在任何时刻，最多只有一个进程的P操作不会被阻塞，并顺利地进入临界区</p><p>总结：在生产者消费者问题中，如果缓冲区大小为1，那么有可能不需要设置互斥信号量就可以实现互斥访问缓冲区的功能。当然，这不是绝对的，要具体问题具体分析。</p></blockquote><h4 id="吸烟者问题"><a class="header-anchor" href="#吸烟者问题"></a>吸烟者问题</h4><p>假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一 支烟，抽烟者需要有三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料再桌上，这个过程一直重复（让三个抽烟者轮流地抽烟）</p><p>本质上这题也属于“生产者-消费者”问题，更详细的说应该是“可生产多种产品的单生产者——多消费者”。</p><p>桌子可以抽象为容量为1的缓冲区，要互斥访问。</p><p>同步关系(从事件的角度来分析)：</p><ul><li>桌上有组合一 → 第一个抽烟者取走东西</li><li>桌上有组合二 → 第二个抽烟者取走东西</li><li>桌上有组合三 → 第三个抽烟者取走东西</li><li>发出完成信号 → 供应者将下一个组合放到桌上</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">semaphore offer1 = <span class="number">0</span>;</span><br><span class="line">semaphore offer2 = <span class="number">0</span>;</span><br><span class="line">semaphore offer3 = <span class="number">0</span>;</span><br><span class="line">semaphore finish = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// 用于实现&quot;三个抽烟者轮流抽烟&quot;</span></span><br><span class="line"></span><br><span class="line">provider()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// offer1</span></span><br><span class="line">            V(offer1);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// offer2</span></span><br><span class="line">             V(offer2);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="comment">// offer3</span></span><br><span class="line">             V(offer3);</span><br><span class="line">        &#125;</span><br><span class="line">        i = (i+<span class="number">1</span>)%<span class="number">3</span>; </span><br><span class="line">        P(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">smoker1()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(offer1);</span><br><span class="line">        <span class="comment">// 拿offer1并处理...</span></span><br><span class="line">        V(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">smoker2()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(offer2);</span><br><span class="line">        <span class="comment">// 拿offer2并处理...</span></span><br><span class="line">        V(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">smoker3()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(offer3);</span><br><span class="line">        <span class="comment">// 拿offer3并处理...</span></span><br><span class="line">        V(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="读者写者问题"><a class="header-anchor" href="#读者写者问题"></a>读者写者问题</h4><p><strong>问题描述</strong>：有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程(读进程或写进程)同时访问共享数据时则可能导致数据不一致的错误。因此要求：</p><ol><li>允许多个读者可以同时对文件执行读操作；</li><li>只允许一个写者往文件中写信息；</li><li>任一写者在完成写操作之前不允许其他读者或写者工作；</li><li>写者执行写操作前，应让已有的读者和写者全部退出。</li></ol><p><strong>问题分析</strong>：</p><ol><li>关系分析。由题目分析读者和写者是互斥的，写者和写者也是互斥的，而读者和读者不存在互斥问题。</li><li>整理思路。两个进程，即读者和写者。写者是比较简单的，它和任何进程互斥，用互斥信号量的P操作、V操作即可解决。读者的问题比较复杂，它必须在实现与写者互斥的同时，实现与其他读者的同步，因此简单的一对P操作、V操作是无法解决问题的。这里用到了一个计数器，用它来判断当前是否有读者读文件。当有读者时，写者是无法写文件的，此时读者会一直占用文件，当没有读者时，写者才可以写文件。同时，这里不同读者对计数器的访问也应该是互斥的。</li><li>信号量设置。首先设置信号量count为计数器，用于记录当前读者的数量，初值为0；设置mutex为互斥信号量，用于保护更新count变量时的互斥；设置互斥信号量rw，用于保证读者和写者的互斥访问。</li></ol><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">semaphore rw = <span class="number">1</span>; <span class="comment">// 用于实现对文件的互斥访问。表示当前是否有进程在访问共享文件</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;    <span class="comment">// 记录当前有几个读进程在访问文件</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">writer()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(rw);</span><br><span class="line">        <span class="comment">// 写文件...</span></span><br><span class="line">        V(rw);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reader()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123; </span><br><span class="line">        P(mutex);  <span class="comment">// 各读进程互斥访问count</span></span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>)&#123; </span><br><span class="line">            P(rw); <span class="comment">// 第一个读进程负责“加锁”</span></span><br><span class="line">        &#125;</span><br><span class="line">        count++;   <span class="comment">// 访问文件的读进程数+1</span></span><br><span class="line">        V(mutex);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 读文件...</span></span><br><span class="line">        </span><br><span class="line">        P(mutex);  <span class="comment">// 各读进程互斥访问count</span></span><br><span class="line">        count--;   <span class="comment">// 访问文件的读进程数+1</span></span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">            V(rw); <span class="comment">// 最后一个读进程负责“解锁”</span></span><br><span class="line">        &#125;</span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>潜在的问题：只要有读进程还在读，写进程就要一直阻塞等待，可能“饿死”。因此，这种算法中，读进程是优先的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">semaphore rw = <span class="number">1</span>; <span class="comment">// 用于实现对文件的互斥访问。表示当前是否有进程在访问共享文件</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;    <span class="comment">// 记录当前有几个读进程在访问文件</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore w= <span class="number">1</span>; <span class="comment">// 用于实现&quot;写优先&quot;</span></span><br><span class="line"></span><br><span class="line">writer()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(w);</span><br><span class="line">        P(rw);</span><br><span class="line">        <span class="comment">// 写文件...</span></span><br><span class="line">        V(rw);</span><br><span class="line">        V(w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reader()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123; </span><br><span class="line">        P(w);</span><br><span class="line">        P(mutex);  <span class="comment">// 各读进程互斥访问count</span></span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>)&#123; </span><br><span class="line">            P(rw); <span class="comment">// 第一个读进程负责“加锁”</span></span><br><span class="line">        &#125;</span><br><span class="line">        count++;   <span class="comment">// 访问文件的读进程数+1</span></span><br><span class="line">        V(mutex);</span><br><span class="line">        V(w);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 读文件...</span></span><br><span class="line">        </span><br><span class="line">        P(mutex);  <span class="comment">// 各读进程互斥访问count</span></span><br><span class="line">        count--;   <span class="comment">// 访问文件的读进程数+1</span></span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">            V(rw); <span class="comment">// 最后一个读进程负责“解锁”</span></span><br><span class="line">        &#125;</span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结论：在这种算法中，连续进入的多个读者可以同时读文件；写者和其他进程不能同时访问文件；写者不会饥饿，但也并不<br>是真正的“写优先&quot;，而是相对公平的先来先服务原则。有些书上把这个算法称为读写公平法，即读写程具有样的优先级。</p><p>其核心思想在于设置了一个计数器count用来记录当前正在访问共享文件的读进程数。我们可以用count的值来判断当前进入的进程是否是第一个/最后一个读进程，从而做出不同的处理。</p><p>另外，对count变量的检查和赋值不能一气呵成导致了一些错误，如果需要实现“一气呵成”，自然应该想到用互斥信号量。</p><h4 id="哲学家进餐问题"><a class="header-anchor" href="#哲学家进餐问题"></a>哲学家进餐问题</h4><p><strong>问题描述</strong>：一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子（一根一根地拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。</p><p><strong>问题分析</strong>：</p><ol><li>关系分析。5名哲学家与左右邻居对其中间筷子的访问是互斥关系。</li><li>整理思路。显然，这里有5个进程。本题的关键是如何让一名哲学家拿到左右两根筷子而不造成死锁或饥饿现象。解决方法有两个：一是让他们同时拿两根筷子；二是对每名哲学家的动作制定规则，避免饥饿或死锁现象的发生。</li><li>信号量设置。定义互斥信号量数组<code>chopstick[5]= &#123;1,1,1,1,1&#125;</code>，用于对5个筷子的互斥访问。哲学家按顺序编号为0~4，哲学家<code>i</code>左边筷子的编号为<code>i</code>，哲学家右边筷子的编号为<code>(i + 1)%5</code>。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">Pi()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(chopstick[i]);       <span class="comment">// 拿左</span></span><br><span class="line">        P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]); <span class="comment">// 拿右</span></span><br><span class="line">        eat;</span><br><span class="line">        V(chopstick[i]);       <span class="comment">// 放左</span></span><br><span class="line">        V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]); <span class="comment">// 放右</span></span><br><span class="line">        think;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该算法存在以下问题：当5名哲学家都想要进餐并分别拿起左边的筷子时（都恰好执行完<code>wait(chopstick[i]); </code>）筷子已被拿光，等到他们再想拿右边的筷子时（执行<code>wait(chopstick[(i + 1)%5]);</code>）就全被阻塞，因此出现了死锁。</p><p>为防止死锁发生，可对哲学家进程施加一些限制条件，比如：</p><ul><li>至多允许4名哲学家同时进餐；这样可以保证至少有一个哲学家是可以拿到左右两只筷子的。设置初始值为4的信号量。</li><li>对哲学家顺序编号，要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子， 另一个会直接阻塞。这就避免了占有一支后再等待另一只的情况。判断序号奇偶</li><li>仅当一名哲学家左右两边的筷子都可用时，才允许他抓起筷子；</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">Pi()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(mutex);</span><br><span class="line">        P(chopstick[i]);       <span class="comment">// 拿左</span></span><br><span class="line">        P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]); <span class="comment">// 拿右</span></span><br><span class="line">        V(mutex);</span><br><span class="line">        eat;</span><br><span class="line">        V(chopstick[i]);       <span class="comment">// 放左</span></span><br><span class="line">        V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]); <span class="comment">// 放右</span></span><br><span class="line">        think;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些进程之间只存在互斥关系，但是与之前接触到的互斥关系不同的是，每个进程都需要同时持有两个临界资源，因此就有“死锁&quot;问题的隐患。</p><h3 id="管程"><a class="header-anchor" href="#管程"></a>管程</h3><p>在信号量机制中，每个要访问临界资源的进程都必须自备同步的PV操作，大量分散的同步操作给系统管理带来了麻烦，且容易因同步操作不当而导致系统死锁。于是，便产生了一种新的进程同步工具——管程。 管程的特性保证了进程互斥，无须程序员自己实现互斥，从而降低了死锁发生的可能性。同时管程提供了条件变量，可以让程序员灵活地实现进程同步。</p><h4 id="管程的定义和基本特征"><a class="header-anchor" href="#管程的定义和基本特征"></a>管程的定义和基本特征</h4><p>系统中的各种硬件资源和软件资源，均可用数据结构抽象地描述其资源特性，即用少量信息和对资源所执行的操作来表征该资源，而忽略它们的内部结构和实现细节。</p><p>利用共享数据结构抽象地表示系统中的共享资源，而把对该数据结构实施的操作定义为一组过程。进程对共享资源的申请、释放等操作，都通过这组过程来实现，这组过程还可以根据资源情况，或接受或阻塞进程的访问，确保每次仅有一个进程使用共享资源，这样就可以统一管理对共享资源的所有访问，实现进程互斥。</p><p>这个代表共享资源的数据结构，以及由对该共享数据结构实施操作的一组过程所组成的资源管理程序，称为管程（monitor）。</p><p>管程定义了一个数据结构和能为并发进程所执行(在该数据结构上)的一组操作，这组操作能同步进程和改变管程中的数据。</p><p>管程是一种特殊的软件模块，有这些部分组成：</p><ol><li>局部于管程的共享数据结构说明；</li><li>对该数据结构进行操作的一组过程；</li><li>对局部于管程的共享数据设置初始值的语句；</li><li>管程有一个名字。</li></ol><p>熟悉面向对象程序设计的读者看到管程的组成后，会立即联想到管程很像一个类 (class)。</p><p>管程的基本特征：</p><ol><li>局部于管程的数据只能被局部于管程的过程所访问；</li><li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据；</li><li>每次仅允许一个进程在管程内执行某个内部过程。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*管程伪代码*/</span></span><br><span class="line">monitor ProducerConsumer</span><br><span class="line">    condition full, empty;  <span class="comment">// 条件变量用来实现同步(排队)</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;  <span class="comment">// 缓冲区中的产品数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Item item)</span></span>&#123;  <span class="comment">// 把产品item 放入缓冲区 </span></span><br><span class="line">        <span class="keyword">if</span>(count==N)&#123;</span><br><span class="line">            wait(full);</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">        insert_item(item);</span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">1</span>)&#123;</span><br><span class="line">            signal(empty)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Item <span class="title">remove</span><span class="params">()</span></span>&#123;  <span class="comment">// 从缓冲区中取走一个产品</span></span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">            wait(empty);</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span>(count==N<span class="number">-1</span>)&#123;</span><br><span class="line">            signal(full);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> remove_item();</span><br><span class="line">    &#125;</span><br><span class="line">end monitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者进程</span></span><br><span class="line">producer()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        item = producer_item();</span><br><span class="line">        ProducerConsumer.insert(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者进程</span></span><br><span class="line">consumer()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        item = ProducerConsumer.remove();</span><br><span class="line">        consumer_item(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由编译器负责实现各进程互斥地进入管程中的过程</p><p>引入管程的目的无非就是要更方便地实现进程互斥和同步。</p><ol><li>需要在管程中定义共享数据（如生产者消费者问题的缓冲区）</li><li>需要在管程中定义用于访问这些共享数据的“入口”——其实就是一些函数（如生产者消费者问题中，可以定义一个函数用于将产品放入缓冲区，再定义一个函数用于从缓冲区取出产品）</li><li>只有通过这些特定的“入口”才能访问共享数据</li><li>管程中有很多“入口”，但是每次只能开放其中一个“入口”，并且只能让一个进程或线程进入（如生产者消费者问题中，各进程需要互斥地访问共享缓冲区。管程的这种特性即可保证一个时间段内最多只会有一个进程在访问缓冲区。注意：这种互斥特性是由编译器负责实现的，程序员不用关心）</li><li>可在管程中设置条件变量及等待/唤醒操作以解决同步问题。可以让一个进程或线程在条件变量上等待（此时，该进程应先释放管程的使用权，也就是让出“入口”）；可以通过唤醒操作将等待在条件变量上的进程或线程唤醒。</li></ol><p>Java中，如果用关键字 synchronized 来描述一个函数， 那么这个函数同一时间段内只能被一个线程调用</p><h2 id="死锁"><a class="header-anchor" href="#死锁"></a>死锁</h2><h3 id="死锁的概念"><a class="header-anchor" href="#死锁的概念"></a>死锁的概念</h3><h4 id="死锁的定义"><a class="header-anchor" href="#死锁的定义"></a>死锁的定义</h4><p>在多道程序系统中，由于多个进程的并发执行，改善了系统资源的利用率并提高了系统的处理能力。然而，多个进程的并发执行也带来了新的问题——死锁。 所谓<font color="#ea66a6">死锁</font>，是指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。</p><p>下面通过一些实例来说明死锁现象。</p><p>先看生活中的一个实例。在一条河上有一座桥，桥面很窄，只能容纳一辆汽车通行。若有两辆汽车分别从桥的左右两端驶上该桥，则会出现下述冲突情况：此时，左边的汽车占有桥面左边的一段，要想过桥还需等待右边的汽车让出桥面右边的一段；右边的汽车占有桥面右边的一段，要想过桥还需等待左边的汽车让出桥面左边的段。此时，若左右两边的汽车都只能向前行驶，则两辆汽车都无法过桥。</p><p>在计算机系统中也存在类似的情况。例如，某计算机系统中只有一台打印机和一台输入设备，进程P1正占用输入设备，同时又提出使用打印机的请求，但此时打印机正被进程P2所占用，而P2在未释放打印机之前，又提出请求使用正被P1占用的输入设备。这样，两个进程相互无休止地等待下去，均无法继续执行，此时两个进程陷入死锁状态。</p><h4 id="死锁、饥饿、死循环的区别"><a class="header-anchor" href="#死锁、饥饿、死循环的区别"></a>死锁、饥饿、死循环的区别</h4><p>死锁：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。</p><p>饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象。比如：在短进程优先(SPF) 算法中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程“饥饿”。</p><p>死循环：某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug导致的，有时是程序员故意设计的。</p><p>共同点：都是进程无法顺利向前推进的现象，(故意设计的死循环除外)</p><p>区别：</p><ol><li>死锁一定是“循环等待对方手里的资源”导致的，因此如果有死锁现象，那至少有两个或两个以上的进程同时发生死锁。另外，发生死锁的进程一定处于阻塞态。</li><li>可能只有一个进程发生饥饿。发生饥饿的进程既可能是阻塞态（如长期得不到需要的I/O设备），也可能是就绪态（长期得不到处理机）</li><li>可能只有一个进程发生死循环。死循环的进程可以上处理机运行（可以是运行态），只不过无法像期待的那样顺利推进。死锁和饥饿问题是由于操作系统分配资源的策略不合理导致的，而死循环是由代码逻辑的错误导致的。死锁和饥<br>饿是管理者（操作系统）的问题，死循环是被管理者的问题。</li></ol><h4 id="死锁产生的原因"><a class="header-anchor" href="#死锁产生的原因"></a>死锁产生的原因</h4><p><strong>系统资源的竞争</strong></p><p>通常系统中拥有的不可剥夺资源，其数量不足以满足多个进程运行的需要，使得进程在运行过程中，会因争夺资源而陷入僵局，如磁带机、打印机等。只有对不可剥夺资源的竞争才可能产生死锁，对可剥夺资源的竞争是不会引起死锁的。</p><p><strong>进程推进顺序非法</strong></p><p>进程在运行过程中，<font color="#faa755">请求和释放资源的顺序不当</font>，也同样会导致死锁。例如，并发进程P1，P2分别保持了资源R1，R2，而进程P1申请资源R2、进程P2申请资源R1时，两者都会因为所需资源被占用而阻塞。</p><p><font color="#faa755">信号量使用不当也会造成死锁</font>。进程间彼此相互等待对方发来的消息，也会使得这些进程间无法继续向前推进。例如，进程A等待进程B发的消息，进程B又在等待进程A发的消息，可以看出进程A和B不是因为竞争同一资源，而是在等待对方的资源导致死锁。</p><p><strong>死锁产生的必要条件</strong></p><p>产生死锁必须同时满足以下4个条件，只要其中任意一个条件不成立，死锁就不会发生。</p><ol><li><font color="#FF666">互斥条件</font>：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的（因为进程不用阻塞等待这种资源）。</li><li><font color="#FF666">不剥夺条件</font>：进程所获得的资源在未使用完之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放）。</li><li><font color="#FF666">请求并保持条件</font>：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</li><li><font color="#FF666">循环等待条件</font>：存在一种进程资源的循环等待链，链中每个进程已获得的资源同时被链中下一个进程所请求。</li></ol><blockquote><p>注意❗ 发生死锁时一定有循环等待，但是发生循环等待时未必死锁（循环等待是死锁的必要不充分条件）</p><p>如果同类资源数大于1，则即使有循环等待，也未必发生死锁。但如果系统中每类资源都只有一个，那循环等待就是死锁的充分必要条件了。</p></blockquote><p>总之，对不可剥夺资源的不合理分配，可能导致死锁。</p><h3 id="死锁的处理策略"><a class="header-anchor" href="#死锁的处理策略"></a>死锁的处理策略</h3><p>为使系统不发生死锁，必须设法破坏产生死锁的4个必要条件之一，或允许死锁产生，但当死锁发生时能检测出死锁，并有能力实现恢复。</p><ol><li>死锁预防。设置某些限制条件，破坏产生死锁的4个必要条件中的一个或几个，以防止发生死锁。</li><li>避免死锁。在资源的动态分配过程中，用某种方法防止系统进入不安全状态，从而避免死锁。</li><li>死锁的检测及解除。无须采取任何限制性措施，允许进程在运行过程中发生死锁。通过系统的检测机构及时地检<br>测出死锁的发生，然后采取某种措施解除死锁。</li></ol><p>预防死锁和避免死锁都属于事先预防策略，预防死锁的限制条件比较严格，实现起来较为简单，但往往导致系统的效率低，资源利用率低：避免死锁的限制条件相对宽松，资源分配后需要通过算法来判断是否进入不安全状态，实现起来较为复杂。</p><table><thead><tr><th>处理策略</th><th>资源分配策略</th><th>各种可能模式</th><th>主要优点</th><th>主要缺点</th></tr></thead><tbody><tr><td>死锁预防</td><td>保守，宁可资源闲置</td><td>一次请求所有资源，资源剥夺，资源按序分配</td><td>适用于突发式处理的进程，不必进行剥夺</td><td>效率低，进程初始化时间延长；剥夺次数过多；不便灵活申请新资源</td></tr><tr><td>死锁避免</td><td>是“预防”和“检测”的折中（在运行时判断是否可能死锁）</td><td>寻找可能的安全允许顺序</td><td>不必进行剥夺</td><td>必须知道将来的资源需求；进程不能被长时间阻塞</td></tr><tr><td>死锁检测</td><td>宽松，只要允许就分配资源</td><td>定期检查死锁是否已经发生</td><td>不延长进程初始化时间，允许对死锁进行现场处理</td><td>通过剥夺解除死锁，造成损失</td></tr></tbody></table><h3 id="死锁预防"><a class="header-anchor" href="#死锁预防"></a>死锁预防</h3><p>防止死锁的发生只需破坏死锁产生的4个必要条件之一即可。</p><p>1.<strong>破坏互斥条件</strong></p><p>若允许系统资源都能共享使用，则系统不会进入死锁状态。但有些资源根本不能同时访问，如打印机等临界资源只能互斥使用。所以，破坏互斥条件而预防死锁的方法不太可行，而且在有的场合应该保护这种互斥性。</p><p>比如: SPOOLing 技术。操作系统可以采用 SPOOLing 技术把独占设备在逻辑上改造成共享设备。比如，用 SPOOLing 技术将打印机改造为共享设备。</p><p>2.<strong>破坏不剥夺条件</strong></p><p>当一个已保持了某些不可剥夺资源的进程请求新的资源而得不到满足时，它<font color="#faa755">必须释放已经保持的所有资源</font>，待以后需要时再重新申请。这意味着，一个进程已占有的资源会被暂时释放，或者说是被剥夺，或从而破坏了不剥夺条件。</p><ol><li>该策略实现起来比较复杂；</li><li>释放已获得的资源可能造成前一阶段工作的失效；</li><li>反复地申请和释放资源会增加系统开销，降低系统吞吐量。</li></ol><p>这种方法常用于状态易于保存和恢复的资源，如CPU的寄存器及内存资源，一般不能用于打印机之类的资源。</p><p>3.<strong>破坏请求并保持条件</strong></p><p>采用预先静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不把它投入运行。一旦投入运行，这些资源就一直归它所有，不再提出其他资源请求，这样就可以保证系统不会发生死锁。</p><p>这种方式实现简单，但缺点也显而易见，系统资源被严重浪费，其中有些资源可能仅在运行初期或运行快结束时才使用，甚至根本不使用。而且还会导致“饥饿”现象，由于个别资源长期被其他进程占用时，将致使等待该资源的进程迟迟不能开始运行。</p><p>4.<strong>破坏循环等待条件</strong></p><p>为了破坏循环等待条件，可采用顺序资源分配法。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源一次申请完。</p><p>原理分析：一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象。</p><p>这种方法存在的问题是，编号必须相对稳定，这就限制了新类型设备的增加；尽管在为资源编号时己考虑到大多数作业实际使用这些资源的顺序，但也经常会发生作业使用资源的顺序与系统规定顺序不同的情况，造成资源的浪费；此外，这种按规定次序申请资源的方法，也必然会给用户的编程带来麻烦。</p><h3 id="死锁避免"><a class="header-anchor" href="#死锁避免"></a>死锁避免</h3><p>避免死锁同样属于事先预防策略，但并不是事先采取某种限制措施破坏死锁的必要条件，而是在资源动态分配过程中，防止系统进入不安全状态，以避免发生死锁。这种方法所施加的限制条件较弱，可以获得较好的系统性能。</p><h4 id="系统安全状态"><a class="header-anchor" href="#系统安全状态"></a>系统安全状态</h4><p>避免死锁的方法中，允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次分配的安全性。若此次分配不会导致系统进入不安全状态，则允许分配；否则让进程等待。</p><p>所谓<font color="#ea66a6">安全状态</font>，是指系统能按某种进程推进顺序（P1，P2，…，Pn）为每个进程 Pi 分配其所需的资源，直至满足每个进程对资源的最大需求，使每个进程都可顺序完成。此时称 P1，P2，…，Pn 为安全序列。若系统无法找到一个安全序列，则称系统处于不安全状态。</p><p>并非所有的不安全状态都是死锁状态，但当系统进入不安全状态后，便可能进入死锁状态；反之，只要系统处于安全状态，系统便可避免进入死锁状态。</p><p>如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，就可能发生死锁（<font color="#FF666">处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态</font>）</p><p>因此可以在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求。这也是“银行家算法”的核心思想。</p><h4 id="银行家算法"><a class="header-anchor" href="#银行家算法"></a>银行家算法</h4><p>银行家算法是最著名的死锁避免算法，其思想是：把操作系统视为银行家，操作系统管理的资源相当于银行家管理的资金，进程向操作系统请求分配资源相当于用户向银行家贷款。操作系统按照银行家制定的规则为进程分配资源。进程运行之前先声明对各种资源的最大需求量，当进程在执行中继续申请资源时，先测试该进程已占用的资源数与本次申请的资源数之和是否超过该进程声明的最大需求量。若超过则拒绝分配资源，若未超过则再测试系统现存的资源能否满足该进程尚需的最大资源量，若能满足则按当前的申请量分配资源，否则也要推迟分配。</p><p>核心思想：在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待。</p><p>假设系统中有n个进程，m种资源。每个进程在运行前先声明对各种资源的最大需求数，则可用一个n*m的矩阵（可用二维数组实现）表示所有进程对各种资源的最大需求数。不妨称为<font color="#FF666">最大需求矩阵Max</font>，<code>Max[i, j]=K</code>表示进程 P_i 最多需要K个资源R_j。同理，系统可以用一个n*m的<font color="#FF666">分配矩阵 Allocation</font>表示对所有进程的资源分配情况。Max - Allocation = Need矩阵，表示各进程最多还需要多少各类资源。另外，还要用一个长度为m的<font color="#FF666">一维数组Available</font>表示当前系统中还有多少可用资源。</p><p>某进程Pi向系统申请资源，可用一个长度为m的<font color="#FF666">一维数组Request</font>；表示本次申请的各种资源量。</p><p>数据结构：</p><ul><li>长度为m的一维数组Available表示还有多少可用资源；</li><li>n*m矩阵Max表示各进程对资源的最大需求数；</li><li>n*m矩阵Allocation表示已经给各进程分配了多少资源；</li><li>Max-Allocation=Need 矩阵表示各进程最多还需要多少资源；</li><li>用长度为m的一位数组Request表示进程此次申请的各种资源数</li></ul><p>可用银行家算法预判本次分配是否会导致系统进入不安全状态：</p><ol><li>如果 <code>Request_i[j] ≤ Need[i, j]</code> (0≤j≤m) 便转向第2步，否则认为出错。【检查此次申请是否超过了之前声明的最大需求数】</li><li>如果 <code>Request_i[j] ≤ Available[j]</code> (0≤j≤m) 便转向第3步，否则表示尚无足够资源，Pi必须等待。【检查此时系统剩余的可用资源是否还能满足这次请求】</li><li>系统试探着把资源分配给进程Pi，并修改相应的数据（并非真的分配，修改数值只是为了做预判）<code>Available = Available - Request_i;</code>、<code>Allocation[i, j] = Allocation[i, j] + Request_i[j];</code>【试探着分配，更改各数据结构】</li><li>操作系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态。若安全，才正式分配；否则，恢复相应数据，让进程阻塞等待。【用安全性算法检查此次分配是否会导致系统进入不安全状态】</li></ol><p>安全性算法步骤：检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列，并把该进程持有的资源全部回收。不断重复上述过程看是否能将所有进程都加入安全序列。</p><h3 id="死锁检测和解除"><a class="header-anchor" href="#死锁检测和解除"></a>死锁检测和解除</h3><h4 id="死锁检测"><a class="header-anchor" href="#死锁检测"></a>死锁检测</h4><p>为了能对系统是否已发生了死锁进行检测，必须：</p><ol><li>用某种数据结构来保存资源的请求和分配信息；</li><li>提供一种算法，利用上述信息来检测系统是否已进入死锁状态。</li></ol><h4 id="资源分配图"><a class="header-anchor" href="#资源分配图"></a>资源分配图</h4><p>系统死锁可利用资源分配图来描述。</p><p>资源分配图两种结点：</p><ul><li>进程节点：对应一个进程</li><li>资源节点：对应一类资源，一类资源可能有多个</li></ul><p>资源分配图两种边：</p><ul><li>进程节点 → 资源节点：表示进程申请几个资源（每条边代表一个）</li><li>资源节点 → 进程节点：表示已经为进程分配了几个资源（每条边代表一个）</li></ul><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E7%A4%BA%E4%BE%8B.png" alt="资源分配示例" style="object-fit: cover; border-radius: 10px; width: 50%;" /><h4 id="死锁定理"><a class="header-anchor" href="#死锁定理"></a>死锁定理</h4><p>简化资源分配图可检测系统状态 是否为死锁状态。简化方法如下：</p><p>在资源分配图中，找出既不阻塞又不孤点的进程P_i （即找出一条有向边与它相连，且该有向边对应资源的申请数量小于等于系统中已有的空闲资源数量，如上图在，R1没有空闲资源，R2 有一个空闲资源。若所有连接该进程的边均满足上述条件，则这个进程能继续运行直至完成，然后释放它所占有的所有资源)。消去它所有的请求边和分配边，使之成为孤立的结点。在图中，P1 是满足这一条件的进程结点， 将P1的所有边消去。</p><p>进程 P_i 所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程。进程P2就满足这样的条件。根据上面方法进行一系列简化后，若能消去图中所有的边，则称该图是可完全简化的。此时一定没有发生死锁（相当于能找到一个安全序列）。</p><p>S 为死锁的条件是当且仅当 S 状态的资源分配图是不可完全简化的，该条件为死锁定理。</p><h4 id="死锁解除"><a class="header-anchor" href="#死锁解除"></a>死锁解除</h4><p>一旦检测出死锁，就应立即采取相应的措施来解除死锁。死锁解除的主要方法有：</p><ol><li>资源剥夺法。挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源而处于资源匮乏的状态。</li><li>撤销进程法。强制撤销部分甚至全部死锁进程并剥夺这些进程的资源。撒销的原则可以按进程优先级和撤销进程代价的高低进行。</li><li>进程回退法。让一(或多)个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而非被剥夺。要求系统保持进程的历史信息，设置还原点。</li></ol><p>如何决定“对谁动手”？</p><ol><li>进程优先级</li><li>已执行多长时间</li><li>还要多久能完成</li><li>进程已经使用了多少资源</li><li>进程是交互式的还是批处理式的</li></ol>]]></content>
    
    
    <summary type="html">描述</summary>
    
    
    
    <category term="操作系统" scheme="http://halo123.top/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://halo123.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Unit 1</title>
    <link href="http://halo123.top/2021/04/21/EnglishVocabulary/Unit%201/"/>
    <id>http://halo123.top/2021/04/21/EnglishVocabulary/Unit%201/</id>
    <published>2021-04-21T14:45:40.000Z</published>
    <updated>2021-04-30T10:05:39.914Z</updated>
    
    <content type="html"><![CDATA[<h2 id="state"><a class="header-anchor" href="#state"></a>state</h2><p><strong>state</strong></p><ul><li>v. (尤指清楚谨慎地)声称，宣称，声明</li><li>n. 政府，国家，州；状态，情况</li><li>adj. 国有的，国家的</li></ul><p><strong>例句</strong></p><ul><li>He <font color="#33a3dc">stated</font> that “all hell will <font color="#faa755">break loose</font>, politically and morally, all over the world.”<ul><li>他宣称，“政治和道德混乱将在全球范围内发生”。</li></ul></li><li>to seek permission from <font color="#33a3dc">state</font> regulators  寻求州监管部门的批准</li><li>a <font color="#33a3dc">state</font> of mind 心境，心态</li><li>Happiness is a state of mind, and depends very little on outward circumstances.——Helen Keller</li></ul><p><strong>派生</strong></p><ul><li>statement n. 声明；陈述，叙述；报表，清单</li><li>state-owned adj. 国有的；国营的；州立的</li><li>state-owned enterprise 国有企业</li></ul><h3 id="派生词"><a class="header-anchor" href="#派生词"></a>派生词</h3><p><strong>understate</strong></p><ul><li>v. 轻描淡写地叙述；淡化[某事的重要性或严重性]（表述不充分）</li><li>underestimate 低估</li></ul><p><strong>overstate</strong></p><ul><li>v. 把…讲得过分；夸大，夸张(= exaggerate)  ex = e = out</li><li>overestimate 高估</li></ul><p><strong>例句</strong></p><ul><li>Despite the breathtakingly sad opening chapters, Tyler’s delicate perceptiveness gives the novel an <font color="#33a3dc">understated</font> warmth.<ul><li>breathtakingly adv. 惊人地；令人激动地；Tips：副词翻译成very</li><li>delicate  adj. 微妙的；精美的，雅致的；柔和的；易碎的；纤弱的；清淡可口的</li><li>perceptiveness  n. 洞察力；感知力；直觉</li></ul></li></ul><h3 id="近义词"><a class="header-anchor" href="#近义词"></a>近义词</h3><h4 id="v-声称，宣称，声明"><a class="header-anchor" href="#v-声称，宣称，声明"></a>v. 声称，宣称，声明</h4><hr><table><thead><tr><th>词汇</th><th>解释</th></tr></thead><tbody><tr><td>declare</td><td>v. 公布，宣布；宣称(…为事实)，表明(态度、意图等)；申报(因纳税物品、收入等)</td></tr></tbody></table><p><strong>例句</strong></p><ul><li><p>“Play is not frivolous,” the academy’s report declares.</p><ul><li>frivolous adj. 无聊的；轻佻的；琐碎的；</li><li>frivolity n. 轻浮；轻薄；轻率</li><li>fried chips</li><li>fry 浮</li></ul></li><li><p>to declare sex discrimination in jury selection to be unconstitutional</p><ul><li>sex discrimination 性别歧视</li><li>jury 陪审团</li><li>unconstitutional adj. 违反宪法的</li></ul></li><li><p>I <font color="#faa755">declare</font> after all there is no enjoyment like reading.——<em>Pride and Prejudice</em>, Jane Austen</p><ul><li>As Jane Austen said in <em>Pride and Prejudice</em>, …</li></ul></li></ul><p><strong>派生</strong></p><ul><li>declaration</li><li>declarative</li></ul><hr><table><thead><tr><th>词汇</th><th>解释</th></tr></thead><tbody><tr><td>claim</td><td>v. 自称，声称，断言(未经证明或可能错误的事)；<font color="#faa755">要求</font>(拥有)，认领；<font color="#faa755">索取</font>，索(款)；(战争、事故等)夺去(生命)</td></tr><tr><td></td><td>n. 声称，说法；(根据权利而提出的)要求，索赔；(对某事物的)权利，所有权</td></tr></tbody></table><p><strong>释义推导</strong>：索取，索款 → 求拿回某物，要求拥有某物 → 拥有某事物的所有权 → (战争、事故等)夺去(生命)  → 战争等要求拥有某人的生命</p><p><strong>形近</strong></p><ul><li>calm adj. 静的，平静的；沉着的 |  v. 使平静；使镇定</li></ul><p><strong>例句</strong></p><ul><li><p>despite some <font color="#33a3dc">claims</font> to the contrary</p><ul><li>to the contrary 相反地</li><li>by contrast 与……相反的是</li><li>in contrast to 与……形成对照</li><li>counter 对抗 contra-</li><li>Tips：词根词缀原则，元音替换，意思不变；(元音)顺序改变，意思不变；发音相近，意思相近。例如：center → centri-  （eccentric adj. 古怪的，反常的【中心的外围，就离谱】）</li></ul></li><li><p>They claim that the theory of video game violence <font color="#FF666">is built on</font> rotten foundations.</p><ul><li>is built on 建立在</li><li>rotten  adj. 腐烂的；堕落的；恶臭的；虚弱的；极坏的</li><li>rod n. 棒；→ rod- 腐蚀的</li><li>erode vt. 腐蚀，侵蚀 【暴露在外面受到腐蚀】erosion n.</li><li>corrode vt. 侵蚀；损害 【接触收到腐蚀】corrosion n.</li></ul></li><li><p>Love does not claim possession, but gives freedom.——Tagore</p></li></ul><p><strong>派生</strong></p><ul><li>claimant n. 原告；[贸易] 索赔人；提出要求者</li></ul><hr><table><thead><tr><th>词汇</th><th>解释</th></tr></thead><tbody><tr><td>proclaim</td><td>vt. (正式)宣告，公布；声明；明确显示</td></tr></tbody></table><p><strong>例句</strong></p><ul><li>Correlations which confidently <font color="#33a3dc">proclaimed</font> that gaming led to violent behavior <font color="#FF666">were shown to</font> likely be the spurious by-product of factors such as family violence.<ul><li>Correlations n. 相关性</li><li>spurious adj. 假的；伪造的；欺骗的</li></ul></li></ul><hr><table><thead><tr><th>词汇</th><th>解释</th></tr></thead><tbody><tr><td>pronounce</td><td>v. 发音；宣判；断言；正式宣布(或公布)</td></tr></tbody></table><p><strong>派生</strong></p><ul><li>pronunciation n. 发音；读法</li><li>pronouncement n. 声明；宣告；公告；判决</li></ul><p><strong>拓展</strong></p><ul><li>enounce vt. 宣言；声明；说出；发音清晰地读出</li><li>enunciate v. 发音；阐明；宣布</li><li>articulate v. 清晰地发（音）；明确有力地表达；用关节连接；使相互连贯 | adj. 发音清晰的；口才好的；有关节的</li><li>artisan n. 工匠，技工【偏技术】</li><li>craftman n. 工匠 【偏制造】</li></ul><hr><table><thead><tr><th>词汇</th><th>解释</th></tr></thead><tbody><tr><td>announce</td><td>v. 宣布，宣告；通知，告知；郑重</td></tr></tbody></table><p><strong>例句</strong></p><ul><li>Last month, Facebook <font color="#33a3dc">announced</font> partnerships with outside groups to help fact-check stories on its site and to more clearly <font color="#faa755">denote</font> which ones may be false.<ul><li>脸书于上月宣布与外部团队开展合作，目的是帮助对其网站信息内容进行事实核查，并更加明确地标注哪些可能是虚假内容。</li><li>note ，denote（vt. 表示，指示），de-、dis、di = away（开，分离）</li><li>false product、copycat product</li></ul></li></ul><p><strong>派生</strong></p><ul><li>announcement n.宣布，公布；通告，声明</li></ul><hr><table><thead><tr><th>词汇</th><th>解释</th></tr></thead><tbody><tr><td>assert</td><td>v. （肯定地）断言，坚称；维护（权利或权威）；坚持（主张）</td></tr></tbody></table><ul><li>cert-</li><li>certainty n. 确定性</li></ul><p><strong>考点</strong></p><ul><li>the administration was <font color="#faa755">in essence</font> <font color="#33a3dc">asserting</font> that …<ul><li>in essence  本质上；其实；大体上</li><li>政府实际上是在坚持这样的主张……</li></ul></li></ul><p><strong>派生</strong></p><ul><li>assertion n. 断言；肯定有力的主张</li><li>assertive adj. 坚定自信的；坚决主张的</li></ul><hr><table><thead><tr><th>词汇</th><th>解释</th></tr></thead><tbody><tr><td>affirm</td><td>v. 肯定属实，申明，断言</td></tr></tbody></table><p><strong>考点</strong></p><ul><li>to <font color="#33a3dc">affirm</font> the importance of the humanities and social sciences<ul><li>肯定人文学科和社会学科的重要性</li><li>humanities  人文学科</li><li>social sciences 社会学科</li></ul></li></ul><p><strong>派生</strong></p><ul><li>affirmative  [əˈfɜːmətɪv]  adj. 肯定的，同意的 | n. 肯定，同意</li><li>affirmation [ˌæfɜːˈmeɪʃ(ə)n] n. 肯定，确认；情感上的支持（或鼓励）</li></ul><hr><table><thead><tr><th>词汇</th><th>解释</th></tr></thead><tbody><tr><td>allege</td><td>v. （未提出证据）断言，声称</td></tr></tbody></table><p><strong>派生</strong></p><ul><li>allegation n. （无证据的）说法，指控</li><li>alleged adj. 声称的；被断言的；涉嫌的</li><li>allegiance  n. 效忠，忠诚；忠贞 = loyalty = fidelity</li></ul><p><strong>拓展</strong></p><ul><li>so-called adj. 所谓的；号称的</li><li>supposed adj. 据说的，所谓的</li><li>据说 should = be supposed to</li><li>What is that supposed to be 这什么鬼</li></ul><h4 id="n-状况，情况"><a class="header-anchor" href="#n-状况，情况"></a>n. 状况，情况</h4><table><thead><tr><th>词汇</th><th>解释</th></tr></thead><tbody><tr><td>condition</td><td>n. 状况，状态；处境；条件，条款；前提；疾病；健康状况； [~s]环境，条件</td></tr><tr><td></td><td>v. 使习惯于，使适应；养护（头发等）</td></tr></tbody></table><p><strong>考点</strong></p><ul><li>geographic conditions (which are) peculiar to America<ul><li>peculiar  adj. 特殊的；独特的；奇怪的；罕见的</li><li>美国特有的地理条件</li><li>geo- 地理</li></ul></li><li>weather conditions 天气情况</li></ul><p><strong>派生</strong></p><ul><li>conditional  adj. 有条件的，有前提的</li><li>conditioner n. 护发素；调节器</li><li>hair conditioner 护发素</li></ul><p><strong>拓展</strong></p><ul><li>lotion n. 洗液；洗涤剂</li><li>bath wash 沐浴液</li><li>shampoo n. 洗发；洗发液</li><li>air conditioning 空调</li></ul><hr><table><thead><tr><th>词汇</th><th>解释</th></tr></thead><tbody><tr><td>situation</td><td>n. 形势，情况，局面；所处位置，环境</td></tr></tbody></table><p><strong>扩展</strong></p><ul><li>create a situation 造成局面</li><li>assess/review a situation 评判局势，分析局势</li><li>assessment n. 评价；评定；鉴定；估价</li><li>deal with a situation 应付局面</li><li>copy with 应付</li></ul><h2 id="change"><a class="header-anchor" href="#change"></a>change</h2><table><thead><tr><th>词汇</th><th>解释</th></tr></thead><tbody><tr><td>change</td><td>v.改变，更改；转换，更换，替换；兑换；换乘</td></tr><tr><td></td><td>n.变化，变更，变革；零钱，硬币</td></tr><tr><td>exchange</td><td>v. 交换；[货币的]兑换；交流；互访</td></tr><tr><td></td><td>n. 短暂的交流；交流，互访</td></tr><tr><td>exchange rate</td><td>汇率；兑换率</td></tr></tbody></table><p><strong>考点</strong></p><ul><li>climate change 气候变化</li></ul><h3 id="近义词-v2"><a class="header-anchor" href="#近义词-v2"></a>近义词</h3><h4 id="v-改变，更改"><a class="header-anchor" href="#v-改变，更改"></a>v. 改变，更改</h4><table><thead><tr><th>词汇</th><th>解释</th></tr></thead><tbody><tr><td>move</td><td>v.（使）移动；改变；采取行动；搬家；影响；<font color="#faa755">感动</font>；动议，提议</td></tr><tr><td></td><td>n.移动；改变；步骤；<font color="#faa755">行动，举措</font></td></tr><tr><td>movement</td><td>n. 移动；运动；变化；发展；乐章</td></tr></tbody></table><p><strong>考点</strong></p><ul><li>to back such radical moves<ul><li>支持这样的激进行动</li><li>back v. 支持</li><li>backer  n. 支持者；赞助人；援助者 =  supporter = sponsor</li><li>radical  adj. 激进的；根本的；彻底的</li><li>radicalism n. 激进主义</li></ul></li></ul><p><strong>拓展</strong></p><ul><li>Who Moved My Cheese？《谁动了我的奶酪？》</li><li>Sometimes your whole life <font color="#faa755">boils down to</font> one insane move.——Avatar<ul><li>boil down to  归结为</li><li>insane adj. 疯狂的；</li><li>sane adj. 健全的；理智的；</li><li>sanity n. 明智；头脑清楚；精神健全；通情达理</li><li>insanity n. 疯狂；精神错乱；精神病；愚顽</li></ul></li></ul><hr><table><thead><tr><th>词汇</th><th>解释</th></tr></thead><tbody><tr><td>shift</td><td>v. 转移，移动；转移（注意力等）；转变，改变（意见等）；推卸</td></tr><tr><td></td><td>n. 转变；<font color="#faa755">轮班</font>；轮班职工</td></tr></tbody></table><p><strong>例句</strong></p><ul><li>The aim was to include enough features to <font color="#faa755">draw interest away from</font> iPhones and Android-supported phones, but the new BlackBerry devices failed to <font color="#faa755">catch on</font> and the company <font color="#33a3dc">shifted</font> its engineering resources <font color="#faa755">back to</font> its QNX division as car makers started developing software.<ul><li>features  n. 产品特点，特征；（杂志）特约专栏</li><li>draw interest away from 转移兴趣；（短语看介词）</li><li>draw interest into 将兴趣转移到</li><li>catch on 抓住，流行</li><li>division  n. [数] 除法；部门；分配；分割；师（军队）；赛区</li><li>divide v. （使）分开，分成；分配，分担；分隔；（道路）分叉；使产生分歧；（数）除，除以</li><li>黑莓公司的目标是包含足够多的特色(功能)来转移人们对苹果和安卓手机的关注，但新款黑莓手机未能流行起来，而且随着汽车制造商开始开发软件，黑莓将其设计资源转回到QNX系统研发部门。</li></ul></li></ul><hr><table><thead><tr><th>词汇</th><th>解释</th></tr></thead><tbody><tr><td>switch</td><td>v. 打开，关闭；改变；转换（职业、政策、生活方式等）；交换</td></tr><tr><td></td><td>n. 开关；彻底改变</td></tr></tbody></table><ul><li>switch A into B = turn A into B</li></ul><p><strong>考点</strong></p><ul><li>to switch to the nursing school 转到护理学院</li></ul><hr><table><thead><tr><th>词汇</th><th>解释</th></tr></thead><tbody><tr><td>transition</td><td>v. 转变；过渡</td></tr><tr><td></td><td>n. 转变，过渡；变革，变迁</td></tr><tr><td>transitional</td><td>adj. 变迁的；过渡期的</td></tr></tbody></table><p><strong>例句</strong></p><ul><li>But all energy transitions, such as that from coal to hydrocarbons in the 20th century, take many decades.<ul><li>但所有的能源过渡，比如20世纪从煤炭到碳氢化合物的过渡，都需要几十年的时间。</li><li>low-Carbon life 低碳生活</li></ul></li></ul><hr><table><thead><tr><th>词汇</th><th>解释</th></tr></thead><tbody><tr><td>transform</td><td>v. 使彻底改变（尤指变得更好）；改造；使改观</td></tr><tr><td>transformer</td><td>n. 变压器；改革者</td></tr><tr><td>transformation</td><td>n. 彻底的改变；巨变</td></tr></tbody></table><p><strong>考点</strong></p><ul><li>to transform their thought processes 彻底改变他们的思考过程</li></ul><p><strong>拓展</strong></p><ul><li>transform sb/sth (from sth) into sth</li><li>The movie transformed her almost overnight from an unknown schoolgirl into a megastar.<ul><li>megastar n. 超级巨星</li></ul></li><li>reform v. 改进，改革；（使）改过自新</li></ul><hr><table><thead><tr><th>词汇</th><th>解释</th></tr></thead><tbody><tr><td>alter</td><td>v. （尤指以相对细微但却显著的方式）改变（性质或成分）；修改（衣服使更合身）</td></tr><tr><td>alteration</td><td>n. 改变，变更</td></tr></tbody></table><p><strong>例句</strong></p><ul><li>You can remind yourself to notice your thoughts in a nonjudgmental manner, without trying to change or alter them right away.<ul><li>remind  sb to do sth 提醒某人做某事</li><li>remind sb of sth 提醒某人某事</li><li>right away = at once = instantly = immediately 立刻</li><li>你可以提醒自己以一种不加评判的方式去审视自己的想法，而不是试图立即转换或改变它们。</li></ul></li><li>Remember what should be remembered, and forget what should be forgotten. Alter what is changeable,<br>and accept what is mutable.——The Catcher in the Rye<ul><li>mute 哑巴；哑的 【 /mute all 】</li><li>mutable  adj. 可变的，易变的；反复无常的，用情不专的【说不出来，琢磨不定】</li></ul></li></ul><p><strong>拓展</strong></p><ul><li>alternate adj. 交替的，轮流的；间隔的，每隔（……天等）的；（一或多个事物）另外的，可供选择的；（两者）互不相容的；另类的，非传统的；（叶、芽）互生的 | v. （使）交替，（使）轮流</li><li>alternation n. 交替，轮流，间隔</li><li>alternative n. 二中择一；供替代的选择</li><li>option n. [计] 选项；选择权；买卖的特权</li></ul><hr><table><thead><tr><th>词汇</th><th>解释</th></tr></thead><tbody><tr><td>modify</td><td>v. （略微地）修改，更改，改进，改造；修饰，限定</td></tr><tr><td>modification</td><td>n. 修改，改进</td></tr><tr><td>modifier</td><td>n. 修饰语；修正的人</td></tr></tbody></table><hr><table><thead><tr><th>词汇</th><th>解释</th></tr></thead><tbody><tr><td>convert</td><td>[kənˈvɜːt ] v. （使形态、性质、功能）改变；改变（观点、原则或做事方式）；改建，改造；换算； （使）改变信仰</td></tr><tr><td></td><td>[ˈkɒnvɜːt] n. 改变信仰者</td></tr><tr><td>conversion</td><td>n. 转变；转换；（宗教或信仰的）改变，皈依</td></tr><tr><td>convertible</td><td>adj. 可改变的 n. 有活动折篷的汽车</td></tr></tbody></table><p>-vert、-vers 转变</p><p><strong>考点</strong></p><ul><li>to convert our lives to data 把我们的生活转化为数据</li></ul><hr><table><thead><tr><th>词汇</th><th>解释</th></tr></thead><tbody><tr><td>transfer</td><td>v.（使）转移，<font color="#faa755">（使）调职</font>；转移（感情）； 传染（疾病）； 转让（权力等）；<font color="#faa755">转乘，换乘</font></td></tr><tr><td>transference</td><td>n. 转移；调动；转让</td></tr></tbody></table><ul><li>transfer station 中转站</li><li>terminal station 终点站</li></ul><p><strong>例句</strong></p><ul><li>&quot;Someone was trying to set up a new payee and <font color="#33a3dc">transfer</font> a seven figure sum, &quot; he said.<ul><li>-ee 被……人 employee，payee</li><li>-or/-er ……人 employer，payer</li><li>figure 数字</li><li>summary；summarize</li></ul></li></ul><hr><table><thead><tr><th>词汇</th><th>解释</th></tr></thead><tbody><tr><td>transplant</td><td>n. （器官）移植</td></tr><tr><td></td><td>v. 移植；移栽；（使）移居</td></tr></tbody></table><ul><li>plant<ul><li>n. 植物；<font color="#faa755">工厂；发电厂</font></li><li>v. 播（种）；种植；<font color="#faa755">放置，使固定</font></li></ul></li></ul>]]></content>
    
    
    <summary type="html">描述</summary>
    
    
    
    <category term="英语词汇" scheme="http://halo123.top/categories/%E8%8B%B1%E8%AF%AD%E8%AF%8D%E6%B1%87/"/>
    
    
    <category term="英语" scheme="http://halo123.top/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>考研资料收集</title>
    <link href="http://halo123.top/2021/04/21/DataCollection/EntranceExaminationResource/"/>
    <id>http://halo123.top/2021/04/21/DataCollection/EntranceExaminationResource/</id>
    <published>2021-04-21T09:06:12.000Z</published>
    <updated>2021-04-21T13:40:07.000Z</updated>
    
    <content type="html"><![CDATA[<Script Language="JavaScript"> 　　var timedate= new Date("December 25,2021"); 　　var times="研究生考试"; 　　var now = new Date(); 　　var date = timedate.getTime() - now.getTime(); 　　var time = Math.floor(date / (1000 * 60 * 60 * 24)); 　　if (time >= 0) ; document.write("<div title='初试时间预测为2021年12月24日-25日，12月倒数第二周的周六周日，具体时间以教育局公布为准'><font color=#343a40>现在离2022年"+times+"还有: <font color=#dc3545><b>"+time +"</b></font> 天</font></div>"); </Script> <h2 id="📚考研资料"><a class="header-anchor" href="#📚考研资料"></a>📚考研资料</h2><p><a href="https://mp.weixin.qq.com/s/5TNZQG0QBWf1IrOd8L9NGA">好好考研公众号，网课推荐</a><br><a href="https://note.youdao.com/ynoteshare1/index.html?id=fcce8b92cbcedbcbe9b34e27c2275ea9&amp;type=note">好好考研公众号，每日更新资料</a></p><h3 id="考研英语资料"><a class="header-anchor" href="#考研英语资料"></a>考研英语资料</h3><table><thead><tr><th>2022资料</th><th>百度云盘链接</th><th>提取码</th></tr></thead><tbody><tr><td>2022英语唐迟资料合集</td><td><a href="https://pan.baidu.com/s/12KUkxOukT-QIBbpJgO6R7A">云盘链接</a></td><td>ufh6</td></tr><tr><td>2022英语刘晓燕资料合集（高教版）</td><td><a href="https://pan.baidu.com/s/1RLFcQ6KLDwsWk5euTmbv0A">云盘链接</a></td><td>fa7q</td></tr><tr><td>2022英语刘晓燕资料合集（启航版）</td><td><a href="https://pan.baidu.com/s/1XAkWIgmBG1vXdHkeC0e7dA">云盘链接</a></td><td>jbpg</td></tr><tr><td>2022英语朱伟资料合集</td><td><a href="http://pan.baidu.com/s/1rEFa8e0-7Qm11fJo9T0aNQ">云盘链接</a></td><td>u985</td></tr></tbody></table><hr><table><thead><tr><th>2021资料</th><th>百度云盘链接</th><th>提取码</th></tr></thead><tbody><tr><td>2021英语唐迟资料合集</td><td><a href="https://pan.baidu.com/s/1-bIRqHH_N6A6xuDX3eEw5Q">云盘链接</a></td><td>bgfa</td></tr><tr><td>2021英语刘晓燕资料合集（高教版）</td><td><a href="https://pan.baidu.com/s/1YneD1u3YhbXl5yKPVzM2CQ">云盘链接</a></td><td>4h97</td></tr><tr><td>2021英语刘晓燕资料合集（启航版）</td><td><a href="https://pan.baidu.com/s/1vmlzGjD4YwG_JcHoNW9Hmw">云盘链接</a></td><td>tbuh</td></tr></tbody></table><h3 id="考研政治资料"><a class="header-anchor" href="#考研政治资料"></a>考研政治资料</h3><table><thead><tr><th>2022资料</th><th>百度云盘链接</th><th>提取码</th></tr></thead><tbody><tr><td>2022政治徐涛资料合集</td><td><a href="https://pan.baidu.com/s/1oX7YB9pN5fRNnfHttEidwA">云盘链接</a></td><td>phyg</td></tr></tbody></table><hr><table><thead><tr><th>2021资料</th><th>百度云盘链接</th><th>提取码</th></tr></thead><tbody><tr><td>2021政治肖秀荣资料合集</td><td><a href="https://pan.baidu.com/s/1oL_EwF0WwOhYih0SVNqbXg">云盘链接</a></td><td>gbwk</td></tr><tr><td>2021政治徐涛资料合集</td><td><a href="https://pan.baidu.com/s/1jHTsjdSYc6qfhTtp0lE5KA">云盘链接</a></td><td>73rf</td></tr></tbody></table><h3 id="考研数学资料"><a class="header-anchor" href="#考研数学资料"></a>考研数学资料</h3><table><thead><tr><th>2022资料</th><th>百度云盘链接</th><th>提取码</th></tr></thead><tbody><tr><td>2022数学汤家凤资料合集（文都版）</td><td><a href="https://pan.baidu.com/s/1pSWXHJfDzou_5x7lMvjKuA">云盘链接</a></td><td>49sj</td></tr><tr><td>2022数学汤家凤资料合集（新文道版）</td><td><a href="https://pan.baidu.com/s/1KwaRNs0yLBEV9GgEgWIhWQ">云盘链接</a></td><td>a678</td></tr><tr><td>2022数学武忠祥资料合集</td><td><a href="https://pan.baidu.com/s/1QSwjqeTShMwf5uwUNykWRw">云盘链接</a></td><td>sjnp</td></tr><tr><td>2022数学张宇资料合集</td><td><a href="https://pan.baidu.com/s/1J81U7MXeBZUrJb-b2X3sYw">云盘链接</a></td><td>gshh</td></tr><tr><td>2022数学李永乐资料合集</td><td><a href="https://pan.baidu.com/s/1HPVw62L5B2X1fZ1rEqTyTg">云盘链接</a></td><td>u985</td></tr></tbody></table><hr><table><thead><tr><th>2021资料</th><th>百度云盘链接</th><th>提取码</th></tr></thead><tbody><tr><td>2021数学汤家凤资料合集</td><td><a href="https://pan.baidu.com/s/1Vcv3UWsxbBNopIqeyXQcwg">云盘链接</a></td><td>kxvq</td></tr></tbody></table><h3 id="计算机408资料"><a class="header-anchor" href="#计算机408资料"></a>计算机408资料</h3><table><thead><tr><th>2022资料</th><th>百度云盘链接</th><th>提取码</th></tr></thead><tbody><tr><td>2022年计算机资料合集</td><td><a href="https://pan.baidu.com/s/1ADIdKQ_xHOnhgetC1ZiRqA">云盘链接</a></td><td>gihh</td></tr></tbody></table><hr><table><thead><tr><th>2021资料</th><th>百度云盘链接</th><th>提取码</th></tr></thead><tbody><tr><td>2021年计算机资料合集</td><td><a href="https://pan.baidu.com/s/1PKi1g5N03f3nt40TUIX7uA">云盘链接</a></td><td>q5xg</td></tr><tr><td>2021年计算机资料合集</td><td><a href="https://pan.baidu.com/s/1Rcwo6MYwEJZQOvq7KzkXFA">云盘链接</a></td><td>3333</td></tr></tbody></table><br/><blockquote><p>资料来源：<a href="https://mp.weixin.qq.com/s/Knp9-UbYStQXAS3vjuDZrA">研料库公众号</a>、好好考研</p></blockquote><h3 id="其他资料"><a class="header-anchor" href="#其他资料"></a>其他资料</h3><p>微信公众号：</p><ul><li>给力考研资料</li><li>好好考研</li><li>槟果考研</li><li>小白考研</li><li>灰灰考研(计算机)</li></ul><p>官方<a href="https://yz.chsi.com.cn/">中国研究生招生信息网(研招网)</a></p><h2 id="🧭知乎有关问题及回答"><a class="header-anchor" href="#🧭知乎有关问题及回答"></a>🧭知乎有关问题及回答</h2><p><a href="https://zhuanlan.zhihu.com/p/352816017">2022考研全程复习规划</a><br><a href="https://www.zhihu.com/question/20462634/answer/728661676">考研规划，看这一篇就够了！</a><br><a href="https://zhuanlan.zhihu.com/p/72965483">考研资料书推荐大全+考研经验分享</a></p><h3 id="各大院校官网"><a class="header-anchor" href="#各大院校官网"></a>各大院校官网</h3><h2 id="📆考研公共课规划"><a class="header-anchor" href="#📆考研公共课规划"></a>📆考研公共课规划</h2>]]></content>
    
    
    <summary type="html">资料来源于公众号</summary>
    
    
    
    <category term="考研" scheme="http://halo123.top/categories/%E8%80%83%E7%A0%94/"/>
    
    
    <category term="考研" scheme="http://halo123.top/tags/%E8%80%83%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>Web前端入门之CSS</title>
    <link href="http://halo123.top/2021/04/19/WebFrontEnd/PrimerCSS/"/>
    <id>http://halo123.top/2021/04/19/WebFrontEnd/PrimerCSS/</id>
    <published>2021-04-19T15:51:35.000Z</published>
    <updated>2021-04-30T10:05:39.985Z</updated>
    
    <content type="html"><![CDATA[<details ><summary> 参考资料 </summary>              <div class='content'>              <div class="tag link"><a class="link-card" title="CSS参考手册" href="http://css.doyoe.com/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E7%BD%91%E7%AB%99.svg"/></div><div class="right"><p class="text">CSS参考手册</p><p class="url">http://css.doyoe.com/</p></div></a></div><div class="tag link"><a class="link-card" title="w3cschool" href="https://www.w3school.com.cn/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E7%BD%91%E7%AB%99.svg"/></div><div class="right"><p class="text">w3cschool</p><p class="url">https://www.w3school.com.cn/</p></div></a></div><div class="tag link"><a class="link-card" title="黑马程序员Web前端入门教程" href="https://www.bilibili.com/video/BV1pE411q7FU"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E7%BD%91%E7%AB%99.svg"/></div><div class="right"><p class="text">黑马程序员Web前端入门教程</p><p class="url">https://www.bilibili.com/video/BV1pE411q7FU</p></div></a></div>              </div>            </details><h2 id="CSS-简介"><a class="header-anchor" href="#CSS-简介"></a>CSS 简介</h2><ol><li>CSS 是层叠样式表 ( Cascading Style Sheets ) 的简称。有时我们也会称之为 CSS 样式表或级联样式表。</li><li>CSS 是也是一种标记语言。</li><li>CSS 主要用于设置 HTML 页面中的文本内容（字体、大小、对齐方式等）、图片的外形（宽高、边框样式、边距等）以及版面的布局和外观显示样式。</li><li>CSS 让我们的网页更加丰富多彩，布局更加灵活自如。简单理解：CSS 可以美化 HTML , 让 HTML 更漂亮， 让页面布局更简单。</li><li>CSS 最大价值: 由 HTML 专注去做结构呈现，样式交给 CSS，即 结构 ( HTML ) 与样式( CSS ) 相分离。</li></ol><h3 id="CSS-语法规范"><a class="header-anchor" href="#CSS-语法规范"></a>CSS 语法规范</h3><ol><li>使用 HTML 时，需要遵从一定的规范，CSS 也是如此。要想熟练地使用 CSS 对网页进行修饰，首先需要了解CSS 样式规</li><li>CSS 规则由两个主要的部分构成：选择器以及一条或多条声明。</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span>&#123;</span><br><span class="line"><span class="attribute">color</span>:red;</span><br><span class="line"><span class="attribute">font-size</span>:<span class="number">25px</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>选择器是用于指定 CSS 样式的 HTML 标签，花括号内是对该对象设置的具体样式</li><li>属性和属性值以“键值对”的形式出现</li><li>属性是对指定的对象设置的样式属性，例如字体大小、文本颜色等</li><li>属性和属性值之间用英文<code>:</code>分开</li><li>多个“键值对”之间用英文<code>;</code>进行区分</li></ol><p>所有的样式，都包含在 <code>&lt;style&gt;</code> 标签内，表示是样式表。<code>&lt;style&gt;</code> 一般写到 <code>&lt;/head&gt;</code> 上方，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">h4</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">color</span>: blue;</span></span><br><span class="line"><span class="css">      <span class="attribute">font-size</span>: <span class="number">100px</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="CSS代码风格"><a class="header-anchor" href="#CSS代码风格"></a>CSS代码风格</h3><p>样式空格风格</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*选择器（标签）和大括号中间保留空格*/</span></span><br><span class="line"><span class="selector-tag">h3</span> &#123;</span><br><span class="line">  <span class="comment">/*属性值前面，冒号后面，保留一个空格*/</span></span><br><span class="line">  <span class="attribute">color</span>: pink;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>样式格式书写</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*紧凑格式*/</span></span><br><span class="line"><span class="selector-tag">h3</span> &#123; <span class="attribute">color</span>: deeppink;<span class="attribute">font-size</span>: <span class="number">20px</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*展开格式(推荐,更直观)*/</span></span><br><span class="line"><span class="selector-tag">h3</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: pink;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">20px</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>样式大小写风格</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*小写格式(推荐)*/</span></span><br><span class="line"><span class="selector-tag">h3</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*大写格式*/</span></span><br><span class="line"><span class="selector-tag">H3</span> &#123;</span><br><span class="line">  <span class="attribute">COLOR</span>: PINK;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CSS选择器"><a class="header-anchor" href="#CSS选择器"></a>CSS选择器</h2><h3 id="选择器的作用"><a class="header-anchor" href="#选择器的作用"></a>选择器的作用</h3><p>选择器(选择符)就是根据不同需求把不同的标签选出来这就是选择器的作用。简单来说，就是选择标签用的。</p><p>选择器分为基础选择器和复合选择器两个大类。</p><h3 id="CSS-基础选择器"><a class="header-anchor" href="#CSS-基础选择器"></a>CSS 基础选择器</h3><p>基础选择器又包括：标签选择器、类选择器、id 选择器和通配符选择器</p><h4 id="标签选择器"><a class="header-anchor" href="#标签选择器"></a>标签选择器</h4><p>标签选择器（元素选择器）是指用 HTML 标签名称作为选择器，按标签名称分类，为页面中某一类标签指定统一的 CSS 样式。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">标签选择器&#123;</span><br><span class="line">  属性：属性值</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：能快速为页面中同类型的标签统一设置样式。<br>缺点：不能设计差异化样式,只能选择全部的当前标签。</p><h4 id="类选择器"><a class="header-anchor" href="#类选择器"></a>类选择器</h4><p>如果想要差异化选择不同的标签，单独选一个或者某几个标签，可以使用类选择器。</p><p>结构需要用class属性来调用class类的意思，<code>&lt;div class=&quot;类名&quot;&gt; 变红色 &lt;/div&gt;</code></p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.类名&#123;</span><br><span class="line">  属性：属性值</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果想要差异化选择不同的标签，单独选一个或者某几个标签，可以使用类选择器。</li><li>类选择器在 HTML 中以 class 属性表示，在 CSS 中，类选择器以一个点“.”号显示。</li><li>类选择器使用“.”（英文点号）进行标识，后面紧跟类名（自定义，我们自己命名的）。</li><li>可以理解为给这个标签起了一个名字，来表示。</li><li>长名称或词组可以使用中横线来为选择器命名。</li><li>不要使用纯数字、中文等命名，尽量使用英文字母来表示。</li><li>命名要有意义，尽量使别人一眼就知道这个类名的目的。</li><li>命名规范：见资料（<a href="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%B5%84%E6%96%99/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%E6%89%8B%E5%86%8C.doc">Web 前端开发规范手册.doc</a>）</li></ol><h4 id="多类名选择器"><a class="header-anchor" href="#多类名选择器"></a>多类名选择器</h4><p>我们可以给一个标签指定多个类名，从而达到更多的选择目的。 这些类名都可以选出这个标签。简单理解就是一个标签有多个名字。</p><p>多类名的具体使用，类名之间用空格隔开：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;red font20&quot;&gt;嘤嘤嘤&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>在标签class 属性中写多个类名</li><li>多个类名中间必须用空格分开</li><li>这个标签就可以分别具有这些类名的样式</li></ol><p>多类名开发中使用场景：</p><ol><li>可以把一些标签元素相同的样式(共同的部分)放到一个类里面。</li><li>这些标签都可以调用这个公共的类然后再调用自己独有的类。</li><li>从而节省CSS代码，统一修改也非常方便。</li></ol><h4 id="ID-选择器"><a class="header-anchor" href="#ID-选择器"></a>ID 选择器</h4><p>id 选择器可以为标有特定 id 的 HTML 元素指定特定的样式。</p><p>HTML 元素以 id 属性来设置 id 选择器，CSS 中 id 选择器以 “#” 来定义。语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#id名 &#123;</span><br><span class="line">  属性1: 属性值1;  </span><br><span class="line">  ...</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>注意：id 属性只能在每个 HTML 文档中出现一次</p><p>id 选择器和类选择器的区别：</p><ol><li>类选择器（class）好比人的名字，一个人可以有多个名字，同时一个名字也可以被多个人使用。</li><li>id 选择器好比人的身份证号码，全中国是唯一的，不得重复。</li><li>id 选择器和类选择器最大的不同在于使用次数上。</li><li>类选择器在修改样式中用的最多，id 选择器一般用于页面唯一性的元素上，经常和 JavaScript 搭配使用。</li></ol><h4 id="通配符选择器"><a class="header-anchor" href="#通配符选择器"></a>通配符选择器</h4><p>在 CSS 中，通配符选择器使用 “*” 定义，它表示选取页面中所有元素（标签）。语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  属性<span class="number">1</span>: 属性值<span class="number">1</span>;  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通配符选择器不需要调用，自动就给所有的元素使用样式，特殊情况才使用(如清除所有的元素标签的内外边距)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="基础选择器总结"><a class="header-anchor" href="#基础选择器总结"></a>基础选择器总结</h4><table><thead><tr><th>基础选择器</th><th>作用</th><th>特点</th><th>使用情况</th><th>用法</th></tr></thead><tbody><tr><td>标签选择器</td><td>可以选出所有相同的标签</td><td>不能差异化选择</td><td>较多</td><td><code>p &#123;color: red;&#125;</code></td></tr><tr><td>类选择器</td><td>可以选出1个或者多个标签</td><td>可以根据需求选择</td><td>非常多</td><td><code>.nav &#123;color: red;&#125;</code></td></tr><tr><td>id选择器</td><td>一次只能选择1个标签</td><td>相同id属性只能在每一个HTML文档中出现一次</td><td>一般和JavaScript搭配</td><td><code>#nav &#123;color: red;&#125;</code></td></tr><tr><td>通配符选择器</td><td>选择所有的标签</td><td>选择所有</td><td>特殊情况下使用</td><td><code>* &#123;color: red;&#125;</code></td></tr></tbody></table><h3 id="关系选择器"><a class="header-anchor" href="#关系选择器"></a>关系选择器</h3><p>简单的选择器包括标签选择器、类选择器、ID 选择器和通配符选择器。如果把两个选择器组合在一起，就形成了一个复杂关系的选择器。在 HTML5 文档结构中，通过关系选择器可以精确匹配结构中特定关系元素。</p><h4 id="包含选择器"><a class="header-anchor" href="#包含选择器"></a>包含选择器</h4><p>包含选择器通过空格连接两个选择器，前面选择器表示包含的祖先元素，后面选择器表示被包含的后代元素。</p><ul><li>优点：可以匹配特定的结构内指定对象，用于缩小匹配范围。</li><li>缺点： 匹配范围较大，影响的层级不受限制。</li></ul><p>案例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 网页模板 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span> 网页标题 <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span> 页脚标题 <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure><p>实现以下目标：</p><ul><li>定义网页标题的字体大小为 18px</li><li>定义页脚标题的字体大小为 12px</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">header</span> <span class="selector-tag">h1</span>&#123;<span class="attribute">font-size</span>:<span class="number">18px</span>;&#125;</span><br><span class="line"><span class="selector-tag">footer</span> <span class="selector-tag">h1</span>&#123;<span class="attribute">font-size</span>:<span class="number">12px</span>;&#125;</span><br></pre></td></tr></table></figure><h4 id="子选择器"><a class="header-anchor" href="#子选择器"></a>子选择器</h4><p>子选择器使用尖括号（<code>&gt;</code>）连接两个选择器，前面选择器表示要匹配的父元素，后面选择器表示被包含的匹配子对象。</p><ul><li>优点：比包含选择器匹配的范围更小，从层级结构上来看匹配目标更明确。</li><li>缺点：与包含选择器相比，匹配范围优先，用户需要熟悉文档结构。</li></ul><iframe width="100%" height="300" src="//jsrun.net/9e3Kp/embedded/html,css,result/dark" allowfullscreen="allowfullscreen" frameborder="0"></iframe><h4 id="相邻选择器"><a class="header-anchor" href="#相邻选择器"></a>相邻选择器</h4><p>相邻选择器使用加号（<code>+</code>）连接两个选择器，前面选择器匹配特定元素，后面选择器根据结构关系，指定同级、相邻的匹配元素。</p><ul><li>优点：在结构中能够准确找到同级、相邻的元素。</li><li>缺点：需要熟悉文档结构。</li></ul><h4 id="兄弟选择器"><a class="header-anchor" href="#兄弟选择器"></a>兄弟选择器</h4><p>兄弟选择器使用波浪线（<code>~</code>）连接两个选择器，前面</p><iframe height="400" style="width: 100%;" scrolling="no" title="Swiper.js实现响应式博客卡片滑块轮播" src="https://animpen.com/embed/oMbZtH?tab=rlt,html" frameborder="no"  allowtransparency="true" allowfullscreen="true"></iframe><h2 id="CSS字体属性"><a class="header-anchor" href="#CSS字体属性"></a>CSS字体属性</h2><p>CSS Fonts (字体)属性用于定义字体系列、大小、粗细、和文字样式(如斜体)。</p><h3 id="字体系列"><a class="header-anchor" href="#字体系列"></a>字体系列</h3><p>CSS使用<code>font-family</code>属性定义文本的字体系列。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123; </span><br><span class="line">  <span class="attribute">font</span>- family: Arial, <span class="string">&quot;Microsoft Yahei&quot;</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>各种字体之间必须使用英文状态下的逗号隔开</li><li>般情况下，如果有空格隔开的多个单词组成的字体加引号。</li><li>尽量使用系统默认自带字体，保证在任何用户的浏览器中都能正确显示</li></ul><h3 id="字体大小"><a class="header-anchor" href="#字体大小"></a>字体大小</h3><p>CSS 使用 <code>font-size</code> 属性定义字体大小。 语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;  </span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">20px</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>px（像素）大小是我们网页的最常用的单位</li><li>谷歌浏览器默认的文字大小为16px</li><li>不同浏览器可能默认显示的字号大小不一致，我们尽量给一个明确值大小，不要默认大小</li><li>可以给 body 指定整个页面文字的大小</li></ol><h3 id="字体粗细"><a class="header-anchor" href="#字体粗细"></a>字体粗细</h3><p>CSS 使用 <code>font-weight</code> 属性设置文本字体的粗细。语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;  </span><br><span class="line">  <span class="attribute">font-weight</span>: bold; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>normal</td><td>默认值（不加粗）</td></tr><tr><td>bold</td><td>定义加粗</td></tr><tr><td>100-900</td><td>400等同于normal，700等同于bold，注意这个数字后面不加单位</td></tr></tbody></table><h3 id="字体样式"><a class="header-anchor" href="#字体样式"></a>字体样式</h3><p>CSS 使用 <code>font-style</code> 属性设置文本的风格。语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;  </span><br><span class="line">  <span class="attribute">font-style</span>: normal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性值</th><th>作用</th></tr></thead><tbody><tr><td>normal</td><td>默认值，浏览器会显示标准的字体样式<code>font- style: normal;</code></td></tr><tr><td>italic</td><td>浏览器会显示斜体的字体样式。</td></tr></tbody></table><h3 id="字体的综合写法"><a class="header-anchor" href="#字体的综合写法"></a>字体的综合写法</h3><p>字体属性可以把以上文字样式综合来写, 这样可以更节约代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123; </span><br><span class="line">  <span class="attribute">font</span>: font-style  font-weight  font-size/line-height  font-family;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 font 属性时，必须按上面语法格式中的顺序书写，<font color="#FF666">不能更换顺序</font>，并且各个属性间以空格隔开 不需要设置的属性可以省略（取默认值），但必须保留 <code>font-size</code> 和 <code>font-family</code> 属性，否则 font 属性将不起作用。</p><h3 id="字体总结"><a class="header-anchor" href="#字体总结"></a>字体总结</h3><table><thead><tr><th>属性</th><th>表示</th><th>注意点</th></tr></thead><tbody><tr><td><code>font-size</code></td><td>字号</td><td>通常用的单位是 px 像素，一定要跟上单位</td></tr><tr><td><code>font-family</code></td><td>字体</td><td>实际工作中按照团队约定来写字体</td></tr><tr><td><code>font-weight</code></td><td>字体粗细</td><td>记住加粗是700或者bold，不加粗是normal或者400记住数字不要跟单位</td></tr><tr><td><code>font-style</code></td><td>字体样式</td><td>记住倾斜是italic，不倾斜是normal。工作中我们最常用normal</td></tr><tr><td><code>font</code></td><td>字体连写</td><td>字体连写是有顺序的不能随意换位置；其中字号和字体必须同时出现</td></tr></tbody></table><h2 id="CSS文本属性"><a class="header-anchor" href="#CSS文本属性"></a>CSS文本属性</h2><p>CSS Text (文本)属性可定义文本的外观，比如文本的颜色、对齐文本、装饰文本、文本缩进、行间距等。</p><h3 id="文本颜色"><a class="header-anchor" href="#文本颜色"></a>文本颜色</h3><p>color 属性用于定义文本的颜色。语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123; </span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>表示</th><th>属性值</th></tr></thead><tbody><tr><td>预定义的颜色</td><td>red、green、blue等</td></tr><tr><td>十六进制(常用)</td><td>#FF0000、#FF6600等</td></tr><tr><td>RGB代码</td><td>rgb(255,0,0)、rgb(100%,0%,0%)</td></tr></tbody></table><h3 id="文本对齐"><a class="header-anchor" href="#文本对齐"></a>文本对齐</h3><p><code>text-align</code> 属性用于设置元素内文本内容的<font color="#FF666">水平</font>对齐方式。语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123; </span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性值</th><th>解释</th></tr></thead><tbody><tr><td>left</td><td>左对齐（默认值）</td></tr><tr><td>right</td><td>右对齐</td></tr><tr><td>center</td><td>居中对齐</td></tr></tbody></table><h3 id="修饰文本"><a class="header-anchor" href="#修饰文本"></a>修饰文本</h3><p><code>text-decoration</code>属性规定添加到文本的修饰。可以给文本添加下划线、删除线、上划线等。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123; </span><br><span class="line">  <span class="attribute">text-decoration</span>：underline；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>none</td><td>默认，没有装饰线</td></tr><tr><td>underline</td><td>下划线</td></tr><tr><td>overline</td><td>上划线</td></tr><tr><td>line-through</td><td>删除线</td></tr></tbody></table><h3 id="文本缩进"><a class="header-anchor" href="#文本缩进"></a>文本缩进</h3><p><code>text-indent</code>属性用来指定文本的第一行的缩进，通常是将段落的首行缩进。语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123; </span><br><span class="line">  <span class="attribute">text-indent</span>：<span class="number">20px</span>；</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span> &#123; </span><br><span class="line">  <span class="attribute">text-indent</span>：<span class="number">2em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>em</code> 是一个相对单位，就是当前元素（font-size) 1 个文字的大小，如果当前元素没有设置大小，则会按照父元素的 1 个文字大小。</p></blockquote><h3 id="行间距"><a class="header-anchor" href="#行间距"></a>行间距</h3><p><code>line-height</code> 属性用于设置行间的距离（行高）。可以控制文字行与行之间的距离。语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123; </span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">26px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>行高的文本分为：上间距、文本高度和下间距，这三者大小之和 = 行间距</p><h3 id="文本属性总结"><a class="header-anchor" href="#文本属性总结"></a>文本属性总结</h3><table><thead><tr><th>属性</th><th>表示</th><th>注意点</th></tr></thead><tbody><tr><td>color</td><td>文本颜色</td><td>常用十六进制表示颜色</td></tr><tr><td>text-align</td><td>文本对齐</td><td>设定文字水平对齐方式</td></tr><tr><td>text-indent</td><td>文本缩进</td><td>可以设置首行缩进</td></tr><tr><td>text-decoration</td><td>文本修饰</td><td>添加或去除下划线</td></tr><tr><td>line-height</td><td>行高</td><td>控制行间距</td></tr></tbody></table><h2 id="CSS样式表"><a class="header-anchor" href="#CSS样式表"></a>CSS样式表</h2><p>按照 CSS 样式书写的位置（或者引入的方式），CSS 样式表可以分为三大类：行内样式表（行内式）、内部样式表（嵌入式）、外部样式表（链接式）。</p><h3 id="行内样式表（行内式）"><a class="header-anchor" href="#行内样式表（行内式）"></a>行内样式表（行内式）</h3><p>行内样式表（内联样式表）是在元素标签内部的 <code>style</code> 属性中设定 CSS 样式。适合于修改简单样式。语法：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;color: red; font-size: 12px;&quot;&gt;一拳一个嘤嘤怪&lt;/div&gt;</span><br></pre></td></tr></table></figure><ol><li>style 其实就是标签的属性，在双引号中间，写法要符合 CSS 规范</li><li>可以控制当前的标签设置样式</li><li>由于书写繁琐，并且没有体现出结构与样式相分离的思想，所以不推荐大量使用，只有对当前元素添加简单样式的时候，可以考虑使用</li><li>使用行内样式表设定 CSS，通常也被称为行内式引入</li></ol><h3 id="内部样式表（嵌入式）"><a class="header-anchor" href="#内部样式表（嵌入式）"></a>内部样式表（嵌入式）</h3><p>内部样式表（内嵌样式表）是写到html页面内部. 是将所有的 CSS 代码抽取出来，单独放到一个 <code>&lt;style&gt;</code> 标签中，语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  <span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><ol><li><code>&lt;style&gt;</code> 标签理论上可以放在 HTML 文档的任何地方，但一般会放在文档的<code>&lt;head&gt;</code>标签中</li><li>通过此种方式，可以方便控制当前整个页面中的元素样式设置</li><li>代码结构清晰，但是并没有实现结构与样式完全分离</li><li>使用内部样式表设定 CSS，通常也被称为嵌入式引入，这种方式是我们练习时常用的方式</li></ol><h3 id="外部样式表（链接式）"><a class="header-anchor" href="#外部样式表（链接式）"></a>外部样式表（链接式）</h3><p>实际开发都是外部样式表. 适合于样式比较多的情况. 核心是:样式单独写到CSS 文件中，之后把CSS文件引入到 HTML 页面中使用.<br>引入外部样式表分为两步：</p><ol><li>新建一个后缀名为 .css 的样式文件，把所有 CSS 代码都放入此文件中。</li><li>在 HTML 页面中，使用<code>&lt;link&gt;</code> 标签引入这个文件。<br>语法：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel&#x3D;&quot;stylesheet&quot;  href&#x3D;&quot;css文件路径&quot;&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;details &gt;&lt;summary&gt; 参考资料 &lt;/summary&gt;
              &lt;div class=&#39;content&#39;&gt;
              &lt;div class=&quot;tag link&quot;&gt;&lt;a class=&quot;link-card&quot; title=&quot;CSS参</summary>
      
    
    
    
    <category term="Web前端" scheme="http://halo123.top/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="CSS" scheme="http://halo123.top/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>知识Tips</title>
    <link href="http://halo123.top/2021/04/19/KnowledgeTips/%E7%9F%A5%E8%AF%86Tips/"/>
    <id>http://halo123.top/2021/04/19/KnowledgeTips/%E7%9F%A5%E8%AF%86Tips/</id>
    <published>2021-04-19T14:04:03.000Z</published>
    <updated>2021-04-30T10:05:39.928Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为何众多计算机语言要从1970年1月1日开始算起？"><a class="header-anchor" href="#为何众多计算机语言要从1970年1月1日开始算起？"></a>为何众多计算机语言要从1970年1月1日开始算起？</h2><p>最初计算机操作系统是32位，而时间也是用32位表示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Integer.MAX_VALUE);</span><br><span class="line"><span class="comment">// OutPut: 2147483647</span></span><br></pre></td></tr></table></figure><p>Integer 在JAVA内用32位表示，因此32位能表示的值是2147483647。</p><p>另外1年365天的总秒数是 31536000s，2147483647/31536000 = 68.1，也就是说32位能表示的最长时间是68年，从1970年开始的话，加上68.1，实际最终到2038年01月19日03时14分07秒，便会到达时间，过了这个时间点，所有32位操作系统时间便会变为10000000 00000000 00000000 00000000，算下来也就是1901年12月13日20时45分52秒，这样便会出现时间回归的现象，很多软件便会运行异常了。</p><p>到这里，问题的答案已经显现出来了，那就是：因为用32位来表示时间的间隔是68年，而最早出现的UNIX操作系统考虑到计算机产生的年代和应用的时限综合取了1970年1月1日作为UNIX TIME的纪元时间(开始时间)。</p><p>至于时间回归的现象相信随着64为操作系统的产生逐渐得到解决，因为用64位操作系统可以表示到 292,277,026,596年12月4日15时30分08秒，相信我们的N代子孙，哪怕地球毁灭那天都不用愁不够用了，因为这个时间已经是千亿年以后了。</p><blockquote><p>来源：<a href="https://developer.51cto.com/art/201508/488060.htm">为何众多计算机语言要从1970年1月1日开始算起？</a></p></blockquote>]]></content>
    
    
    <summary type="html">一些小知识</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Web前端入门之HTML</title>
    <link href="http://halo123.top/2021/04/18/WebFrontEnd/PrimerHTML/"/>
    <id>http://halo123.top/2021/04/18/WebFrontEnd/PrimerHTML/</id>
    <published>2021-04-18T14:11:16.000Z</published>
    <updated>2021-04-19T15:50:55.000Z</updated>
    
    <content type="html"><![CDATA[<details ><summary> 参考资料 </summary>              <div class='content'>              <div class="tag link"><a class="link-card" title="Web前端入门教程" href="https://www.bilibili.com/video/BV1pE411q7FU"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E7%BD%91%E7%AB%99.svg"/></div><div class="right"><p class="text">Web前端入门教程</p><p class="url">https://www.bilibili.com/video/BV1pE411q7FU</p></div></a></div><div class="tag link"><a class="link-card" title="W3CSchool" href="http://www.w3school.com.cn/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E7%BD%91%E7%AB%99.svg"/></div><div class="right"><p class="text">W3CSchool</p><p class="url">http://www.w3school.com.cn/</p></div></a></div><div class="tag link"><a class="link-card" title="MDN" href="https://developer.mozilla.org"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E7%BD%91%E7%AB%99.svg"/></div><div class="right"><p class="text">MDN</p><p class="url">https://developer.mozilla.org</p></div></a></div>              </div>            </details><h2 id="概念"><a class="header-anchor" href="#概念"></a>概念</h2><h3 id="什么是网页"><a class="header-anchor" href="#什么是网页"></a>什么是网页?</h3><ol><li>网站是指在因特网上根据一定的规则，使用 HTML 等制作的用于展示特定内容相关的网页集合。</li><li>网页是网站中的一“页”，通常是 HTML 格式的文件，它要通过浏览器来阅读。</li><li>网页是构成网站的基本元素，它通常由图片、链接、文字、声音、视频等元素组成。通常我们看到的网页，常见以 .htm 或 .html 后缀结尾的文件，因此将其俗称为 HTML 文件。</li></ol><h3 id="什么是HTML？"><a class="header-anchor" href="#什么是HTML？"></a>什么是HTML？</h3><ol><li>HTML 指的是超文本标记语言 (Hyper Text Markup Language) ，它是用来描述网页的一种语言。</li><li>HTML 不是一种编程语言，而是一种标记语言 (markup language)。 标记语言是一套标记标签 (markup tag)。</li></ol><h3 id="浏览器"><a class="header-anchor" href="#浏览器"></a>浏览器</h3><p>浏览器是网页显示、运行的平台。常用的浏览器：Google Chrome、Microsoft Edge、IE、Apple Safari、FireFox、Opera</p><p>负责读取网页内容，整理讯息，计算网页的显示方式并显示页面</p><table><thead><tr><th>浏览器</th><th>内核</th><th>备注</th></tr></thead><tbody><tr><td>IE</td><td>Trident</td><td>IE及一些具有双核的浏览器如360极速浏览器等</td></tr><tr><td>FireFox</td><td>Gecko</td><td>火狐浏览器内核</td></tr><tr><td>Safari</td><td>Webkit</td><td>苹果浏览器内核</td></tr><tr><td>Chromium</td><td>Blink</td><td>Chrome、Opera、新版Edge浏览器内核。Blink是WebKit的分支</td></tr></tbody></table><p>目前国内一般浏览器都会采用 Webkit/Blink 内核，如 360、UC、QQ、搜狗等。</p><h3 id="Web标准"><a class="header-anchor" href="#Web标准"></a>Web标准</h3><p>Web 标准是由 <a href="https://www.w3.org/">W3C 组织</a>和其他标准化组织制定的一系列标准的集合。W3C（万维网联盟）是国际最著名的标准化组织。</p><p>遵循 Web 标准除了可以让不同的开发人员写出的页面更标准、更统一外，还有以下优点：</p><ol><li>让 Web 的发展前景更广阔。</li><li>内容能被更广泛的设备访问。</li><li>更容易被搜寻引擎搜索。</li><li>降低网站流量费用。</li><li>使网站更易于维护。</li><li>提高页面浏览速度。</li></ol><p>Web标准的构成：主要包括结构(Structure)、表现(Presentation)和行为(Behavior)三个方面。</p><table><thead><tr><th>标准</th><th>说明</th></tr></thead><tbody><tr><td>结构</td><td>结构用于对网页元素进行整理和分类。如HTML</td></tr><tr><td>表现</td><td>表现用于设置网页元素的版式、颜色、大小等外观样式。主要指的是CSS</td></tr><tr><td>行为</td><td>行为是指网页模型的定义及交互的编写。如Javascript</td></tr></tbody></table><p><strong>结构写到 HTML 文件中， 表现写到 CSS 文件中， 行为写到 JavaScript 文件中</strong></p><h2 id="HTML-标签的导读"><a class="header-anchor" href="#HTML-标签的导读"></a>HTML 标签的导读</h2><h3 id="HTML语法规则"><a class="header-anchor" href="#HTML语法规则"></a>HTML语法规则</h3><ol><li>HTML 标签是由尖括号包围的关键词，例如 <code>&lt;html&gt;</code>。</li><li>HTML 标签通常是成对出现的，例如 <code>&lt;html&gt;</code> 和 <code>&lt;/html&gt;</code> ，我们称为<strong>双标签</strong>。标签对中的第一个标签是开始标签，第二个标签是结束标签。</li><li>有些特殊的标签必须是单个标签（极少情况），例如 <code>&lt;br /&gt;</code>，我们称为<strong>单标签</strong>。</li></ol><h3 id="标签的关系"><a class="header-anchor" href="#标签的关系"></a>标签的关系</h3><p>双标签关系可以分为两类：包含关系和并列关系</p><p>包含关系：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span> <span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p>并列关系：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="基本结构标签"><a class="header-anchor" href="#基本结构标签"></a>基本结构标签</h3><p>每个网页都会有一个基本的结构标签（也称为骨架标签），页面内容也是在这些基本标签上书写</p><table><thead><tr><th>标签名</th><th>定义</th><th>说明</th></tr></thead><tbody><tr><td><code>&lt;html&gt;&lt;/html&gt;</code></td><td>HTML标签</td><td>页面中最大的标签，我们称之为根标签</td></tr><tr><td><code>&lt;head&gt;&lt;/head&gt;</code></td><td>文档的头部</td><td>注意在head标签中我们必须要设置的标签是title</td></tr><tr><td><code>&lt;title&gt;&lt;/title&gt;</code></td><td>文档的标题</td><td>让页面拥有一个属于自己的网页标题</td></tr><tr><td><code>&lt;body&gt;&lt;/body&gt;</code></td><td>文档的主体</td><td>元素包含文档的所有内容，页面内容基本都是放到body里面的</td></tr></tbody></table><h3 id="HTML基本骨架"><a class="header-anchor" href="#HTML基本骨架"></a>HTML基本骨架</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;!DOCTYPE html&gt;</code>：文档类型声明标签，告诉浏览器这个页面采取 HTML 5 版本来显示页面。</li><li><code>&lt;html lang=&quot;en&quot;&gt;</code>：<code>lang</code> 语言种类，用来定义当前文档显示的语言。en定义语言为英语，zh-CN定义语言为中文。简单来说,定义为 en 就是英文网页，定义为 zh-CN 就是中文网页。其实对于文档显示来说，定义成 en 的文档也可以显示中文，定义成 zh-CN 的文档也可以显示英文，这个属性对浏览器和搜索引擎(百度.谷歌等)还是有作用的。</li><li><code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code>：设置字符集，charset 常用的值有：GB2312 、BIG5 、GBK 和 UTF-8，其中 UTF-8 也被称为万国码，基本包含了全世界所有国家需要用到的字符。尽量统一写成标准的 “UTF-8”，不要写成  “utf8” 或 “UTF8”。</li></ul><h2 id="HTML常用的标签"><a class="header-anchor" href="#HTML常用的标签"></a>HTML常用的标签</h2><h3 id="标题标签"><a class="header-anchor" href="#标题标签"></a>标题标签</h3><p>为了使网页更具有语义化，我们经常会在页面中用到标题标签。HTML 提供了 6 个等级的网页标题，即<code>&lt;h1&gt;</code> - <code>&lt;h6&gt;</code> 。具体实现：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>标题一共六级选,<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>文字加粗一行显。<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>由大到小依次减，<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>从重到轻随之变。<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span>语法规范书写后，<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h6</span>&gt;</span>具体效果刷新见。<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br></pre></td></tr></table></figure><p>特点：</p><ol><li>加了标题的文字会变的加粗，字号也会依次变大。</li><li>一个标题独占一行。</li></ol><h3 id="段落标签"><a class="header-anchor" href="#段落标签"></a>段落标签</h3><p>在网页中，要把文字有条理地显示出来，就需要将这些文字分段显示。在 HTML 标签中，<code>&lt;p&gt;</code> (paragraph)标签用于定义段落，它可以将整个网页分为若干个段落。具体实现：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span> 我是一个段落标签 <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>特点：</p><ol><li>文本在一个段落中会根据浏览器窗口的大小自动换行。</li><li>段落和段落之间保有空隙。</li></ol><h3 id="换行标签"><a class="header-anchor" href="#换行标签"></a>换行标签</h3><p>在 HTML 中，一个段落中的文字会从左到右依次排列，直到浏览器窗口的右端，然后才自动换行。如果希望某段文本强制换行显示，就需要使用换行标签 <code>&lt;br /&gt;</code>(break)。具体实现：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>特点：</p><ol><li><code>&lt;br /&gt;</code> 是个单标签。</li><li><code>&lt;br /&gt;</code> 标签只是简单地开始新的一行，跟段落不一样，段落之间会插入一些垂直的间距。</li></ol><h3 id="文本格式化标签"><a class="header-anchor" href="#文本格式化标签"></a>文本格式化标签</h3><p>在网页中，有时需要为文字设置粗体、斜体 或下划线等效果，这时就需要用到 HTML 中的文本格式化标签，使文字以特殊的方式显示。</p><table><thead><tr><th>语义</th><th>标签</th></tr></thead><tbody><tr><td>加粗</td><td><code>&lt;strong&gt;&lt;/strong&gt;</code>或者<code>&lt;b&gt;&lt;/b&gt;</code></td></tr><tr><td>倾斜</td><td><code>&lt;em&gt;&lt;/em&gt;</code>或者<code>&lt;i&gt;&lt;/i&gt;</code></td></tr><tr><td>删除线</td><td><code>&lt;del&gt;&lt;/del&gt;</code>或者<code>&lt;s&gt;&lt;/s&gt;</code></td></tr><tr><td>下划线</td><td><code>&lt;ins&gt;&lt;/ins&gt;</code>或者<code>&lt;u&gt;&lt;/u&gt;</code></td></tr></tbody></table><h3 id="div和span标签"><a class="header-anchor" href="#div和span标签"></a><code>div</code>和<code>span</code>标签</h3><p><code>&lt;div&gt;</code> (division)和 <code>&lt;span&gt;</code>是没有语义的，它们就是一个盒子，用来装内容的。</p><p>特点：</p><ol><li><code>&lt;div&gt;</code> 标签用来布局，但是现在<font color="#FF666">一行只能放一个</font><code>&lt;div&gt;</code>。 大盒子</li><li><code>&lt;span&gt;</code> 标签用来布局，<font color="#FF666">一行上可以多个</font> <code>&lt;span&gt;</code>。小盒子</li></ol><h3 id="图片标签"><a class="header-anchor" href="#图片标签"></a>图片标签</h3><p>在 HTML 标签中，<code>&lt;img&gt;</code>(image)标签用于定义 HTML 页面中的图像。具体实现：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;图像URL&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><code>src</code> 是<code>&lt;img&gt;</code>标签的必须属性，它用于指定图像文件的路径和文件名。</p><p>图像标签的其他属性：</p><table><thead><tr><th>属性</th><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>src</td><td>图片路径</td><td>规定显示图像的 URL</td></tr><tr><td>alt</td><td>文本</td><td>替换文本。图像不能显示的文字</td></tr><tr><td>title</td><td>文本</td><td>提示文本。鼠标放到图像上，显示的文字</td></tr><tr><td>width</td><td>像素</td><td>设置图像的宽度</td></tr><tr><td>height</td><td>像素</td><td>设置图像的高度</td></tr><tr><td>border</td><td>像素</td><td>设置图像的边框粗细</td></tr></tbody></table><p>图像标签注意点：</p><ol><li>图像标签可以拥有多个属性，必须写在标签名的后面。</li><li>属性之间不分先后顺序，标签名与属性、属性与属性之间均以空格分开。</li><li>属性采取键值对的格式，即 key=“value&quot; 的格式，属性 =“属性值”。</li></ol><h3 id="路径"><a class="header-anchor" href="#路径"></a>路径</h3><p>分为相对路径和绝对路径：</p><p>相对路径：以引用文件所在位置为参考基础，而建立出的目录路径。简单来说，图片相对于 HTML 页面的位置。</p><table><thead><tr><th>相对路径分类</th><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>同一级目录</td><td></td><td>图像文件位于HTML文件同-级如<code>&lt;img src=&quot;baidu.gif&quot; /&gt;</code></td></tr><tr><td>下一级目录</td><td><code>/</code></td><td>图像文件位于HTML文件下一级如<code>&lt;img src=&quot;images/baidu.gif&quot; /&gt;</code></td></tr><tr><td>上一级目录</td><td><code>../</code></td><td>图像文件位于HTML文件上一级如<code>&lt;img src=&quot;../baidu.gif&quot; /&gt;</code></td></tr></tbody></table><p>特点：相对路径是从代码所在的这个文件出发，去寻找目标文件的，而我们这里所说的上一级 、下一级和同一级就是 图片相对于 HTML 页面的位置。</p><p>绝对路径：是指目录下的绝对位置，直接到达目标位置，通常是从盘符开始的路径。</p><p>例如，<code>&quot;D:\web\img\logo.gif&quot;</code>或完整的网络地址<code>&quot;http://www.xxx.cn/images/logo.gif&quot;</code></p><h3 id="链接标签"><a class="header-anchor" href="#链接标签"></a>链接标签</h3><p>ahchor 链接的语法格式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;跳转目标&quot;</span> <span class="attr">target</span>=<span class="string">&quot;目标窗口的弹出方式&quot;</span>&gt;</span> 文本或图像 <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>属性：</p><ol><li><code>href</code>：用于指定链接目标的url地址，必须属性</li><li>target:用于指定链接页面的打开方式<code>_self</code>默认值，<code>_blank</code>新窗口打开</li><li><code>#</code>：空链接</li></ol><p>链接分类：</p><ol><li>外部链接: 例如 <code>&lt;a href=&quot;http://www.baidu.com&quot;&gt; 百度&lt;/a&gt;</code></li><li>内部链接:网站内部页面之间的相互链接. 直接链接内部页面名称即可，例如 <code>&lt;a href=&quot;index.html&quot;&gt; 首页 &lt;/a&gt;</code></li><li>空链接: 如果当时没有确定链接目标时，<code>&lt;a href=&quot;#&quot;&gt; 首页 &lt;/a&gt;</code></li><li>下载链接: 如果 href 里面地址是一个文件或者压缩包，会下载这个文件。</li><li>网页元素链接: 在网页中的各种网页元素，如文本、图像、表格、音频、视频等都可以添加超链接.</li><li>锚点链接:  点我们点击链接,可以快速定位到页面中的某个位置.<ul><li>在链接文本的 href 属性中，设置属性值为 #名字 的形式，如<code>&lt;a href=&quot;#two&quot;&gt; 第2集 &lt;/a&gt;</code></li><li>找到目标位置标签，里面添加一个 id 属性 = 刚才的名字 ，如：<code>&lt;h3 id=&quot;two&quot;&gt;第2集介绍&lt;/h3&gt;</code></li></ul></li></ol><h3 id="注释"><a class="header-anchor" href="#注释"></a>注释</h3><p>如果需要在 HTML 文档中添加一些便于阅读和理解但又不需要显示在页面中的注释文字，就需要使用注释标签。<br>HTML中的注释以<code>&lt;!--</code>开头，以<code>--&gt;</code>结束。</p><p>具体实现：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注释语句 快捷键: ctrl +  /  --&gt;</span>      </span><br></pre></td></tr></table></figure><p>添加注释是为了更好地解释代码的功能，便于相关开发人员理解和阅读代码，程序是不会执行注释内容的。</p><h3 id="特殊字符"><a class="header-anchor" href="#特殊字符"></a>特殊字符</h3><p>在 HTML 页面中，一些特殊的符号很难或者不方便直接使用，此时我们就可以使用下面的字符来替代。</p><table><thead><tr><th>特殊字符</th><th>描述</th><th>字符的代码</th></tr></thead><tbody><tr><td> </td><td>空格符</td><td><code>&amp;nbsp;</code></td></tr><tr><td>&lt;</td><td>小于号</td><td><code>&amp;lt;</code></td></tr><tr><td>&gt;</td><td>大于号</td><td><code>&amp;gt;</code></td></tr><tr><td>&amp;</td><td>and</td><td><code>&amp;amp;</code></td></tr><tr><td>¥</td><td>人民币</td><td><code>&amp;yen;</code></td></tr><tr><td>©</td><td>版权</td><td><code>&amp;copy;</code></td></tr><tr><td>®</td><td>注册商标</td><td><code>&amp;reg;</code></td></tr><tr><td>°</td><td>摄氏度</td><td><code>&amp;deg;</code></td></tr><tr><td>±</td><td>正负号</td><td><code>&amp;plusmn;</code></td></tr><tr><td>×</td><td>乘号</td><td><code>&amp;times;</code></td></tr><tr><td>÷</td><td>除号</td><td><code>&amp;divide;</code></td></tr><tr><td>²</td><td>平方</td><td><code>&amp;sup2;</code></td></tr><tr><td>³</td><td>立方</td><td><code>&amp;sup3;</code></td></tr></tbody></table><p>重点记住：空格 、大于号、 小于号 这三个， 其余的使用很少，如果需要回头查阅即可。</p><h2 id="表格"><a class="header-anchor" href="#表格"></a>表格</h2><ol><li>表格主要用于显示、展示数据，因为它可以让数据显示的非常的规整，可读性非常好。特别是后台展示数据的时候，能够熟练运用表格就显得很重要。一个清爽简约的表格能够把繁杂的数据表现得很有条理。</li><li>表格不是用来布局页面的,而是用来展示数据的。</li></ol><h3 id="表格的具体用法"><a class="header-anchor" href="#表格的具体用法"></a>表格的具体用法</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>单元格内的文字<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><code>&lt;table&gt; &lt;/table&gt;</code> 是用于定义表格的标签。</li><li><code>&lt;tr&gt; &lt;/tr&gt;</code> 标签用于定义表格中的行，必须嵌套在 <code>&lt;table&gt; &lt;/table&gt;</code>标签中。</li><li><code>&lt;td&gt; &lt;/td&gt; 用于定义表格中的单元格，必须嵌套在</code><tr></tr>`标签中。</li><li>字母 <code>td</code> 指表格数据（table data），即数据单元格的内容。</li></ol><h3 id="表头单元格标签"><a class="header-anchor" href="#表头单元格标签"></a>表头单元格标签</h3><p>表头标签的具体实现：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>一般表头单元格位于表格的第一行或第一列，表头单元格里面的文本内容加粗居中显示。<code>&lt;th&gt;</code> 标签表示 HTML 表格的表头部分（table head 的缩写）</li><li>表头单元格也是单元格，常用于表格第一行突出重要性，表头单元格里面的文字会加粗居中</li></ol><h3 id="表格属性"><a class="header-anchor" href="#表格属性"></a>表格属性</h3><p>表格标签<code>&lt;table&gt;</code>这部分属性我们实际开发我们不常用，后面通过 CSS 来设置</p><table><thead><tr><th>属性名</th><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>align</td><td>left、center、right</td><td>规定表格相对周围元素的对齐方式</td></tr><tr><td>border</td><td>1或&quot;&quot;</td><td>规定表格单元是否拥有边框，默认为&quot;&quot;，表示没有边框</td></tr><tr><td>cellpadding</td><td>像素值</td><td>规定单元边沿与其内容之间的空白，默认1像素</td></tr><tr><td>cellspacing</td><td>像素值</td><td>规定单元格之间的空白，默认2像素</td></tr><tr><td>width</td><td>像素值或百分比</td><td>规定表格的宽度</td></tr></tbody></table><h3 id="表格结构标签"><a class="header-anchor" href="#表格结构标签"></a>表格结构标签</h3><p>使用场景:因为表格可能很长,为了更好的表示表格的语义，可以将表格分割成 表格头部和表格主体两大部分。在表格标签中，分别用：<code>&lt;thead&gt;</code>标签 表格的头部区域、<code>&lt;tbody&gt;</code>标签 表格的主体区域. 这样可以更好的分清表格结构。</p><p>总结:</p><ol><li><code>&lt;thead&gt;&lt;/thead&gt;</code>：用于定义表格的头部。<code>&lt;thead&gt;</code> 内部必须拥有 <code>&lt;tr&gt;</code> 标签。 一般是位于第一行。</li><li><code>&lt;tbody&gt;&lt;/tbody&gt;</code>：用于定义表格的主体，主要用于放数据本体 。</li><li>以上标签都是放在 <code>&lt;table&gt;&lt;/table&gt;</code> 标签中。</li></ol><h3 id="合并单元格"><a class="header-anchor" href="#合并单元格"></a>合并单元格</h3><p>合并单元格方式：</p><ol><li>跨行合并：<code>rowspan=&quot;合并单元格的个数&quot;</code>，最上侧单元格为目标单元格, 写合并代码</li><li>跨列合并：<code>colspan=&quot;合并单元格的个数&quot;</code>，最左侧单元格为目标单元格, 写合并代码</li></ol><p>合并单元格三步曲：</p><ol><li>先确定是跨行还是跨列合并。</li><li>找到目标单元格。写上合并方式 = 合并的单元格数量。比如：<code>&lt;td colspan=&quot;2&quot;&gt;&lt;/td&gt;</code>。</li><li>删除多余的单元格。</li></ol><h2 id="列表"><a class="header-anchor" href="#列表"></a>列表</h2><p>表格是用来显示数据的，那么列表就是用来布局的。 列表最大的特点就是整齐、整洁、有序，它作为布局会更加自由和方便。</p><p>根据使用情景不同，列表可以分为三大类：无序列表、有序列表和自定义列表。</p><h3 id="无序列表"><a class="header-anchor" href="#无序列表"></a>无序列表</h3><p><code>&lt;ul&gt;</code> 标签表示 HTML 页面中项目的无序列表，一般会以项目符号呈现列表项，而列表项使用 <code>&lt;li&gt;</code> 标签定义。无序列表的基本语法格式如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  ... </span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>无序列表的各个列表项之间没有顺序级别之分，是并列的。</li><li><code>&lt;ul&gt;&lt;/ul&gt;</code> 中只能嵌套 <code>&lt;li&gt;&lt;/li&gt;</code>，直接在 <code>&lt;ul&gt;&lt;/ul&gt;</code> 标签中输入其他标签或者文字的做法是不被允许的。</li><li><code>&lt;li&gt;</code> 与 <code>&lt;/li&gt;</code> 之间相当于一个容器，可以容纳所有元素。</li><li>无序列表会带有自己的样式属性，但在实际使用时，我们会使用 CSS 来设置。</li></ol><h3 id="有序列表"><a class="header-anchor" href="#有序列表"></a>有序列表</h3><p>有序列表即为有排列顺序的列表，其各个列表项会按照一定的顺序排列定义。在 HTML 标签中，<code>&lt;ol&gt;</code> 标签用于定义有序列表，列表排序以数字来显示，并且使用 <code>&lt;li&gt;</code> 标签来定义列表项。有序列表的基本语法格式如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  ... </span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><code>&lt;ol&gt;&lt;/ol&gt;</code>中只能嵌套<code>&lt;li&gt;&lt;/li&gt;</code>，直接在<code>&lt;ol&gt;&lt;/ol&gt;</code>标签中输入其他标签或者文字的做法是不被允许的。</li><li><code>&lt;li&gt;</code> 与 <code>&lt;/li&gt;</code>之间相当于一个容器，可以容纳所有元素。</li><li>有序列表会带有自己样式属性，但在实际使用时，我们会使用 CSS 来设置。</li></ol><h3 id="自定义列表"><a class="header-anchor" href="#自定义列表"></a>自定义列表</h3><p>自定义列表的使用场景:自定义列表常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号。在 HTML 标签中，<code>&lt;dl&gt;</code> 标签用于定义描述列表（或定义列表），该标签会与 <code>&lt;dt&gt;</code>（定义项目/名字）和 <code>&lt;dd&gt;</code>（描述每一个项目/名字）一起使用。语法如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span>名词1<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>名词1解释1<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>名词1解释2<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用规则同上</p><h2 id="表单"><a class="header-anchor" href="#表单"></a>表单</h2><p>使用表单目的是为了收集用户信息。在我们网页中， 我们也需要跟用户进行交互，收集用户资料，此时就需要表单。</p><p>在 HTML 中，一个完整的表单通常由<font color="#FF666">表单域</font>、<font color="#FF666">表单控件</font>（也称为表单元素）和 提示信息3个部分构成。</p><h3 id="表单域"><a class="header-anchor" href="#表单域"></a>表单域</h3><p>表单域是一个包含表单元素的区域。</p><p>在 HTML 标签中， <code>&lt;form&gt;</code> 标签用于定义表单域，以实现用户信息的收集和传递。</p><p><code>&lt;form&gt;</code> 会把它范围内的表单元素信息提交给服务器。实现代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">“url地址”</span> <span class="attr">method</span>=<span class="string">“提交方式”</span> <span class="attr">name</span>=<span class="string">“表单域名称</span>&quot;&gt;</span></span><br><span class="line">  各种表单元素控件</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>表单域的常用属性：</p><table><thead><tr><th>属性名</th><th>属性值</th><th>作用</th></tr></thead><tbody><tr><td>action</td><td>URL地址</td><td>用于指定接收并处理表单数据的服务器程序的url地址</td></tr><tr><td>method</td><td>get/p</td><td>用于设置表单数据的提交方式，其取值为get或post</td></tr><tr><td>name</td><td>名称</td><td>用于指定表单的名称，以区分同一个页面中的多个表单域</td></tr></tbody></table><h3 id="表单控件-表单元素"><a class="header-anchor" href="#表单控件-表单元素"></a>表单控件(表单元素)</h3><p><code>&lt;input&gt;</code> 表单元素</p><p>在英文单词中，input 是输入的意思，而在表单元素中 <code>&lt;input&gt;</code> 标签用于收集用户信息。在 <code>&lt;input&gt;</code> 标签中，包含一个 type 属性，根据不同的 type 属性值，输入字段拥有很多种形式（可以是文本字段、复选框、掩码后的文本控件、单选按钮、按钮等）。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;属性值&quot;</span>  /&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;input /&gt;</code> 标签为单标签 type 属性设置不同的属性值用来指定不同的控件类型，type 属性的属性值及其描述如下：</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>button</td><td>定义可点击按钮（多数情况下，用于通过 JavaScript 启动脚本）。</td></tr><tr><td>checkbox</td><td>定义复选框。</td></tr><tr><td>file</td><td>定义输入字段和 &quot;浏览&quot;按钮，供文件上传。</td></tr><tr><td>hidden</td><td>定义隐藏的输入字段。</td></tr><tr><td>image</td><td>定义图像形式的提交按钮。</td></tr><tr><td>password</td><td>定义密码字段。该字段中的字符被掩码。</td></tr><tr><td>radio</td><td>定义单选按钮。</td></tr><tr><td>reset</td><td>定义重置按钮。重置按钮会清除表单中的所有数据。</td></tr><tr><td>submit</td><td>定义提交按钮。提交按钮会把表单数据发送到服务器。</td></tr><tr><td>text</td><td>定义单行的输入字段，用户可在其中输入文本。默认宽度为 20 个字符。</td></tr></tbody></table><p>除 type 属性外，<code>&lt;input/&gt;</code>标签还有其他很多属性，其常用属性如下：</p><table><thead><tr><th>属性</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://www.w3school.com.cn/tags/att_input_name.asp">name</a></td><td>field_name</td><td>定义 input 元素的名称</td></tr><tr><td><a href="https://www.w3school.com.cn/tags/att_input_value.asp">value</a></td><td>value</td><td>规定 input 元素的值</td></tr><tr><td><a href="https://www.w3school.com.cn/tags/att_input_checked.asp">checked</a></td><td>checked</td><td>规定此 input 元素首次加载时应当被选中</td></tr><tr><td><a href="https://www.w3school.com.cn/tags/att_input_maxlength.asp">maxlength</a></td><td>number</td><td>规定输入字段中的字符的最大长度</td></tr></tbody></table><ol><li>name 和 value 是每个表单元素都有的属性值，主要给后台人员使用。</li><li>name 表单元素的名字，要求单选按钮和复选框要有相同的name值。</li><li>checked属性主要针对于单选按钮和复选框主要作用一打开页面，就要可以默认选中某个表单元素。</li></ol><h3 id="标签"><a class="header-anchor" href="#标签"></a>标签</h3><p><code>&lt;label&gt;</code> 标签为 input 元素定义标注（标签）。</p><p><code>&lt;label&gt;</code> 标签用于绑定一个表单元素, 当点击<code>&lt;label&gt;</code> 标签内的文本时，浏览器就会自动将焦点(光标)转到或者选择对应的表单元素上，用来增加用户体验。语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;sex&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span>  <span class="attr">id</span>=<span class="string">&quot;sex&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>核心：<code>&lt;label&gt;</code> 标签的 for 属性应当与相关元素的 id 属性相同。</p><h3 id="下拉框"><a class="header-anchor" href="#下拉框"></a>下拉框</h3><p><code>&lt;select&gt;</code> 下拉框，使用场景: 在页面中，如果有多个选项让用户选择，并且想要节约页面空间时，我们可以使用<code>&lt;select&gt;</code>标签控件定义下拉列表。</p><p>语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">option</span>&gt;</span>选项1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">option</span>&gt;</span>选项2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">option</span>&gt;</span>选项3<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">   ...</span><br><span class="line"> <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><code>&lt;select&gt;</code> 中至少包含一对<code>&lt;option&gt;</code></li><li>在<code>&lt;optioq&gt;</code>中定义<code>selected =&quot;selected&quot;</code>时，当前项即为默认选中项</li></ol><h3 id="文本域"><a class="header-anchor" href="#文本域"></a>文本域</h3><p><code>&lt;textarea&gt;</code> 文本域</p><ol><li>使用场景: 当用户输入内容较多的情况下，我们就不能使用文本框表单了，此时我们可以使用 <code>&lt;textarea&gt;</code> 标签。</li><li>在表单元素中，<code>&lt;textarea&gt;</code> 标签是用于定义多行文本输入的控件。</li><li>使用多行文本输入控件，可以输入更多的文字，该控件常见于留言板，评论。</li></ol><p>语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">rows</span>=<span class="string">&quot;3&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;20&quot;</span>&gt;</span> 文本内容 <span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过 <code>&lt;textarea&gt;</code> 标签可以轻松地创建多行文本输入框。<code>cols=&quot;每行中的字符数&quot;</code> ，<code>rows=&quot;显示的行数&quot;</code>。我们在实际开发中不会使用，都是用 CSS 来改变大小。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;details &gt;&lt;summary&gt; 参考资料 &lt;/summary&gt;
              &lt;div class=&#39;content&#39;&gt;
              &lt;div class=&quot;tag link&quot;&gt;&lt;a class=&quot;link-card&quot; title=&quot;Web前</summary>
      
    
    
    
    <category term="Web前端" scheme="http://halo123.top/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="HTML" scheme="http://halo123.top/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>计划与记录</title>
    <link href="http://halo123.top/2021/04/18/Plan/%E8%AE%A1%E5%88%92%E4%B8%8E%E8%AE%B0%E5%BD%95/"/>
    <id>http://halo123.top/2021/04/18/Plan/%E8%AE%A1%E5%88%92%E4%B8%8E%E8%AE%B0%E5%BD%95/</id>
    <published>2021-04-18T12:09:48.846Z</published>
    <updated>2021-04-22T16:15:37.838Z</updated>
    
    <content type="html"><![CDATA[<h2 id="⏳自律的人有多可怕"><a class="header-anchor" href="#⏳自律的人有多可怕"></a>⏳自律的人有多可怕</h2><ul><li>我的梦想到底是什么，我有为此付出过什么吗</li><li>无特殊情况，一天至少8小时考研学习时间</li><li>其中每天原神时间不超过40分钟</li><li>不许带手机到床上</li><li>1点前要睡觉</li><li>锻炼？</li></ul><h2 id="专业课待办事项"><a class="header-anchor" href="#专业课待办事项"></a>专业课待办事项</h2><ul><li>TODO 补上一期的思想汇报</li><li>TODO 进化生物学翻译论文</li><li>TODO 进化生物学汇报</li><li>TODO 形式与政策论文</li><li>TODO 观赏植物培育实验报告8份</li></ul><h2 id="考研事项"><a class="header-anchor" href="#考研事项"></a>考研事项</h2><ul><li>TODO 完成数据结构栈和队列</li></ul><h2 id="博客样式Bug待办事项"><a class="header-anchor" href="#博客样式Bug待办事项"></a>博客样式Bug待办事项</h2><ul><li>TODO 增加哔哩哔哩春Banner【已完成】</li><li>TODO 修改博客detail标签内的文本排版格式</li><li>TODO 修改友链样式</li><li>TODO 整理常用工具链接</li><li>TODO 修改链接下拉栏样式</li><li>TODO 修复哔哩哔哩春Banner中屏下右滑图片显示有问题的Bug</li><li>TODO 修复butterfly主题下markdown复选框<code>- [ ]</code>不渲染的问题</li></ul><h2 id="博客文章待办事项"><a class="header-anchor" href="#博客文章待办事项"></a>博客文章待办事项</h2><ul><li>TODO 整理 VSCode 常用插件</li><li>TODO 整理 Java 笔记</li><li>TODO 整理 C 笔记</li><li>TODO 整理 Python 笔记</li><li>TODO 继续完成前端学习笔记</li><li>TODO 整理代码，制作 CodeBase 仓库</li></ul><h2 id="📝每日计划及记录"><a class="header-anchor" href="#📝每日计划及记录"></a>📝每日计划及记录</h2><h3 id="2021年5月4日"><a class="header-anchor" href="#2021年5月4日"></a>2021年5月4日</h3><details ><summary> 2021年5月4日小结 </summary>              <div class='content'>              <p>看到《<a href="https://www.bilibili.com/video/BV1cf4y1W771">3000块全没了！各位喝醉了一定要管好自己，我真服了！</a>》这个视频，这承包了我一年的笑点。但“太弱小了，因为我们没有力量……”</p><p>对娱乐与学习之间的简单思考</p><p>娱乐与学习的方式有多种，但它们之间对人有着不同的刺激，刺激从两方面考虑：一方面是产生刺激的内容；另一方面是人对刺激的感受情况。<br>无论娱乐还是学习它们对人是从已知的模式（方式）中带来未知的内容，但娱乐刺激通过多种方式多种感官，通过互动（无论是人机还是人人）获取社会共同感，满足归属感，而且对于游戏还有成就、角色等可以激励的奖励。与之相对的学习的过程同样是面对未知的过程，且因其产生的激励感受不明显，或者认为获得激励理所应当的，而淡化刺激感受，导致学习动力不足。<br>通过对以上两者的简单思考，对于学习方式还是要保证学、记、思、反，相较传统教学模式，学校提供了学和反，教学和作业考试等反馈。而自学这两个需要自己寻找，教学可以通过视频书籍网络等多种方式学习，但缺乏一定的系统型，且对于书籍还需要个人对重点的把握。反馈可以</p>              </div>            </details><h3 id="2021年5月3日"><a class="header-anchor" href="#2021年5月3日"></a>2021年5月3日</h3><details ><summary> 2021年5月3日小结 </summary>              <div class='content'>              <p>今天吃晚饭时看了《<a href="https://www.bilibili.com/bangumi/play/ep399376">致不灭的你</a>》啊这，不要虐我啊。</p>              </div>            </details><h3 id="2021年5月2日"><a class="header-anchor" href="#2021年5月2日"></a>2021年5月2日</h3><details ><summary> 2021年5月2日小结 </summary>              <div class='content'>              <p>今天在知乎中看到这样一句话：“听过一个故事，说有人问一个挑夫，皇帝有多富贵，挑夫说皇上肯定用的金扁担。这些说过度解读的，可不就是挑夫么。”</p><p>永远要对未知保持尊敬。</p>              </div>            </details><h3 id="2021年5月1日"><a class="header-anchor" href="#2021年5月1日"></a>2021年5月1日</h3><details ><summary> 2021年5月1日小结 </summary>              <div class='content'>              <p>明日方舟卡池沉了</p>              </div>            </details><h3 id="2021年4月30日"><a class="header-anchor" href="#2021年4月30日"></a>2021年4月30日</h3><details ><summary> 2021年4月30日小结 </summary>              <div class='content'>              <p>有一段时间未写小结了，主要是这段时间没有按照规律进行学习任务，需要反思。前几天躺床上睡着前，虽然也考虑过，但一觉醒来就全部忘记了。</p><p>从事件起因来看是原神更新了1.5版本，尝试新版本内容费了些时间，之后看到明日方舟要两周年，更新了凯尔西，从去年年的那个版本退坑后，看到凯尔西忍不住想回归看看，在为了敢在活动前多攒一些源石，费了些时间。</p><p>但从本质来看是我经不住诱惑，好在现在回归到了节奏中。</p><p>今天回家坐公交车的路中，虽特意错开高峰但人还是很多，站了一车程，在车中我就思考能否像弹性云计算一样，对客运进行弹性运载，虽从技术考虑并不太难，但如果考虑上人力成本就比较复杂，毕竟公共交通是个亏本服务，或许未来无人驾驶技术成熟，可以投入使用或许可以解决这两者之间的矛盾，还可以增加资源了利用率。</p><p>公交车我可是做了好多年了，也遇到许多难点，就比如高中时候到每周回校时间段，这一时间内的从起始站到学校的这段路程完全被学生包了，中途站台有人也因为车满而不停，而站台等车的人因为不知道而白白的浪费时间，曾经我在淮南看到公交站台上就有标公交车现在所处的实时位置，在宁波的地铁也会计算出下一班车到达的时刻，这样做是个直观的方式，现在许多城市用手机地图也可以查询到公交车的实时位置，但也止步于此。</p><p>我设想过如果拥有站台人数检查功能（但考虑到坐公交车的人群不同，选择合适的方式比较重要），以此来安排车辆。或者根据之前运行的数据来合理调整派车频次。而这些对于公交车的思考不止于此，整个物流行业可能都会有类似的问题，以后有机会再好好研究一下，实际生活中的一些模式，在保证双方都满意的条件下，经济效益怎么提高。</p>              </div>            </details><h3 id="2021年4月26日"><a class="header-anchor" href="#2021年4月26日"></a>2021年4月26日</h3><details ><summary> 2021年4月26日小结 </summary>              <div class='content'>              <p>今天发现了一个好网站</p><div class="tag link"><a class="link-card" title="CodePen" href="https://codepen.io/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E7%BD%91%E7%AB%99.svg"/></div><div class="right"><p class="text">CodePen</p><p class="url">https://codepen.io/</p></div></a></div><p>也不算是首次知道，之前我在看文章的时候也遇到过，只是当时因为网络加载比较慢就放弃了继续探索，网站主要是前端的在线编辑和分享，有许多大佬的一些代码创意。</p><p>只不过是国外网站，速度是真的慢，于是我也找到了国内的类似网站，但相对的社区活跃度不高</p><div class="tag link"><a class="link-card" title="AnimPen" href="https://animpen.com/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E7%BD%91%E7%AB%99.svg"/></div><div class="right"><p class="text">AnimPen</p><p class="url">https://animpen.com/</p></div></a></div><div class="tag link"><a class="link-card" title="JSRun" href="http://jsrun.net/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E7%BD%91%E7%AB%99.svg"/></div><div class="right"><p class="text">JSRun</p><p class="url">http://jsrun.net/</p></div></a></div>              </div>            </details><h3 id="2021年4月25日"><a class="header-anchor" href="#2021年4月25日"></a>2021年4月25日</h3><details ><summary> 2021年4月25日小结 </summary>              <div class='content'>              <p>今天主要处理了博客的移动端的适配</p>              </div>            </details><h3 id="2021年4月24日"><a class="header-anchor" href="#2021年4月24日"></a>2021年4月24日</h3><div class='checkbox checked'><input type="checkbox" checked="checked"/>            <p>17:30，一号楼二阶二，党日活动</p>            </div><details ><summary> 4月24日小结 </summary>              <div class='content'>              <p>今天从8点又开始弄样式，看到了这位博主的<a href="https://blog.zhheo.com/">主页</a>，看来还有好多要学的</p>              </div>            </details><h3 id="2021年4月23日"><a class="header-anchor" href="#2021年4月23日"></a>2021年4月23日</h3><table><thead><tr><th>内容</th><th>备注</th><th>用时</th><th>完成情况</th></tr></thead><tbody><tr><td>数据结构完成前两章整理学习内容</td><td></td><td></td><td></td></tr><tr><td>线性代数矩阵整理学习</td><td></td><td></td><td></td></tr><tr><td>高等数学复习函数</td><td></td><td></td><td></td></tr><tr><td>学习英语7000词1P</td><td></td><td></td><td></td></tr></tbody></table><details ><summary> 4月23日小结 </summary>              <div class='content'>              <p>昨天弄博客主题结果上头了，弄到了3点</p>              </div>            </details><h3 id="2021年4月22日"><a class="header-anchor" href="#2021年4月22日"></a>2021年4月22日</h3><p><strong>待办事项</strong></p><div class='checkbox checked'><input type="checkbox" checked="checked"/>            <p>17:30-18:55，一号楼204，形势与政策</p>            </div><div class='checkbox checked'><input type="checkbox" checked="checked"/>            <p>进化生物学作业</p>            </div><p><strong>考研规划表</strong></p><table><thead><tr><th>内容</th><th>备注</th><th>用时</th><th>完成情况</th></tr></thead><tbody><tr><td>学完操作系统第2章</td><td>学到<a href="https://www.bilibili.com/video/BV1YE411D7nH?t=4&amp;p=33">P33</a></td><td>5h</td><td>✔</td></tr><tr><td>学1P题源7000词</td><td>学完<a href="https://www.bilibili.com/video/BV12E411B7A5?p=3&amp;spm_id_from=pageDriver">P2</a></td><td>2.5h</td><td>✔</td></tr><tr><td>对计算机网络前两章进行复习整理</td><td></td><td>20min</td><td>✔</td></tr><tr><td>对数据结构前两章进行复习整理</td><td></td><td></td><td>❌</td></tr><tr><td>对计算机组成原理前两章进行复习整理</td><td></td><td></td><td>❌</td></tr><tr><td>可以的话对线性代数第一章进行复习整理</td><td></td><td></td><td>❌</td></tr></tbody></table><p><strong>时间统计</strong></p><table><thead><tr><th>项目</th><th>时间</th><th>备注</th></tr></thead><tbody><tr><td>Typora</td><td>5:59:20</td><td>写文档</td></tr><tr><td>浏览器</td><td>4:34:39</td><td>学习课程</td></tr><tr><td>原神</td><td>0:46:09</td><td>日常任务，9次火本</td></tr><tr><td>进化生物学作业</td><td>40min左右</td><td></td></tr></tbody></table><details ><summary> 2021年4月22日小结 </summary>              <div class='content'>              <p>今天学了不少内容，但是通过做题发现学的不够深，还需要及时复习。</p><p>至于下一阶段，我觉得先开始复习数据结构，数学，以及英语，这些数据结构和数学对计组、网络和操作系统记忆内容相对较少，可以先复习，英语要坚持下去。政治等这些课程一轮复习完成后在开始背吧。</p>              </div>            </details><h3 id="2021年4月21日"><a class="header-anchor" href="#2021年4月21日"></a>2021年4月21日</h3><table><thead><tr><th>内容</th><th>备注</th><th>用时</th><th>完成情况</th></tr></thead><tbody><tr><td>学习操作系统并进行相关资料整理</td><td>从<a href="https://www.bilibili.com/video/BV1YE411D7nH?p=22&amp;spm_id_from=pageDriver">P16-P22</a></td><td>4h</td><td>✔</td></tr><tr><td>学习数据结构</td><td></td><td></td><td>❌</td></tr><tr><td>学单词</td><td><a href="https://www.bilibili.com/video/BV12E411B7A5?t=2948">P1 50:00</a></td><td></td><td>✔</td></tr></tbody></table><p><strong>时间统计</strong></p><table><thead><tr><th>项目</th><th>时间</th><th>备注</th></tr></thead><tbody><tr><td>浏览器</td><td>8:05:25</td><td>整理资料，学习课程</td></tr><tr><td>Typora</td><td>4:15:40</td><td>写文档</td></tr><tr><td>原神</td><td>0:15:09</td><td>日常任务</td></tr></tbody></table><details ><summary> 2021年4月21日小结 </summary>              <div class='content'>              <p>今天整理了有关<a href="http://blog.halo123.top:8090/archives/%E8%80%83%E7%A0%94%E8%B5%84%E6%96%99%E6%94%B6%E9%9B%86">考研资料</a>，也对考研计划进行了细化，还有有好多任务需要完成</p><blockquote><p>Doctor，您还有许多事要处理，现在还不能休息（阿米娅_严肃）</p></blockquote><p>时间主要花在了收集和整理资料中，也是通过对资料的整理才更清楚自己要学些什么，对于基础相对薄弱的科目(说的就是你英语)，还是要老老实实看视频跟着老师去学，一些规律还是要有一定经验的人教授才更方便理解。</p><p>而学不在于学多少，在于有多少被吸收成为自己的知识。之前没注意考研时间，现在发现只剩下246天，对我来说时间是有些紧张了。</p><p>最近有关的一些社会新闻，就如特斯拉维权频频出现在消息中。<a href="https://t.bilibili.com/516161348504803949?tab=2">中消协对此事回应</a></p><p>顺便一提，今天发布的 M1 芯片的 Ipad Pro 确实有些在我的意料之外，但也是情理之中，打通各平台的生态圈，这是其他品牌难以做到的一件事，这也会成为苹果公司一张大牌，只能说技术是产品竞争的关键。</p>              </div>            </details><h3 id="2021年4月20日"><a class="header-anchor" href="#2021年4月20日"></a>2021年4月20日</h3><p><strong>每日计划</strong></p><div class='checkbox checked'><input type="checkbox" checked="checked"/>            <p>学习前端，<a href="https://www.bilibili.com/video/BV1pE411q7FU?p=84&amp;spm_id_from=pageDriver">Web前端入门教程 P61-P84</a></p>            </div><div class='checkbox'><input type="checkbox" />            <p>学习操作系统并整理资料</p>            </div><div class='checkbox'><input type="checkbox" />            <p>学习数据结构</p>            </div><div class='checkbox'><input type="checkbox" />            <p>背单词</p>            </div><div class='checkbox checked'><input type="checkbox" checked="checked"/>            <p>15:00至16:00，红船边的思政课主题直播活动。今晚10点前上交一份观后感（字数不得少于400字）</p>            </div><p><strong>时间统计</strong></p><table><thead><tr><th>项目</th><th>时间</th><th>备注</th></tr></thead><tbody><tr><td>浏览器</td><td>6:07:42</td><td>看视频，学前端课程，写博客，看B站动态，看知乎</td></tr><tr><td>Typora</td><td>1:03:26</td><td>写观后感，写博客</td></tr><tr><td>原神</td><td>0:48:09</td><td>日常任务，龙，4浓缩树脂，9层深渊</td></tr><tr><td>Word</td><td>0:12:20</td><td>写观后感</td></tr></tbody></table><details ><summary> 2021年4月20日小结 </summary>              <div class='content'>              <p>几天晚上上完课回来，写了观后感后，在b站看到央视新闻的<a href="https://t.bilibili.com/515733926241528411">动态</a>，被评论区@到一个<a href="https://space.bilibili.com/23947287">UP</a>，为了吃瓜看了些视频，结果越看越深，看的视频如下：</p><ul><li><a href="https://www.bilibili.com/video/BV11i4y1L7QQ">苏联为何而强大？【小约翰】</a></li><li><a href="https://www.bilibili.com/video/BV1zZ4y1H7h2">你真的了解切格瓦拉吗？带你走进精神领袖伟大的一生【历史故事会】</a></li><li><a href="https://www.bilibili.com/video/BV1Z54y1m7FB">美国是如何走向世界舞台的【财经故事会】</a></li><li><a href="https://www.bilibili.com/video/BV1fk4y1B7tv">兔子的大布局：人民币国际化</a></li><li><a href="https://www.bilibili.com/video/BV1NT4y1j7J8">何以成为苏联争议最大的领导人？带你走进斯大林波澜壮阔的一生【有机社会Vol.16】</a></li><li><a href="https://www.bilibili.com/video/BV1m54y1Y7r3">我们到底在走一条什么路？共同富裕最终能实现吗？【有机社会32】</a></li></ul><p>对于视频中的一些观点需要辩证的看待，从侧面也反映出我的历史知识的匮乏，在感想中我写到</p><blockquote><p>学党史，学的不仅是历史，更是精神，而很多精神难以从黑白纸张中感受到，当与物与人与环境，多方面多角度的“对话”，一件历史中发生的某些事的细节可能会忘记，但是历史带给我们的激励作用将会一直伴随。</p></blockquote><p>历史的重要性不言而喻，而我想要了解真实的历史是一件非常难的事，仅从现在来看，我们正处于未来的历史当中，疫情、日本核排放这些事终将会写入历史书中，但身处历史中也难以了解全貌，更何况用十多分钟的视频来概括一个世纪的故事。我们站在制高点俯瞰和中山底仰视看到的风景是截然不同的。</p><p>突然想到，我之前也这样写过总结，打开看竟是去年9月开始的时候，emm只坚持了两天，话说也过去了怎么久了，当再次看到当时的总结，感觉回忆突然涌了上来，这是真的。相比较不知不觉中过日子，不如让每天都有纪念意义，我曾经以为仪式是虚的，但现在就当做开始记录的小仪式吧。感觉有点自言自语有些奇怪。</p><p>正经人谁写日记啊，我又不是什么正经人，ko no ya rou ！</p>              </div>            </details><h3 id="2021年4月19日"><a class="header-anchor" href="#2021年4月19日"></a>2021年4月19日</h3><ul><li>DONE 学习前端，<a href="https://www.bilibili.com/video/BV1pE411q7FU?p=61&amp;spm_id_from=pageDriver">Web前端入门教程 P42-P61</a></li><li>TIMEOUT 学习操作系统并整理资料</li><li>TIMEOUT 学习数据结构</li><li>TIMEOUT 背单词</li></ul><details ><summary> 2021年4月19日小结 </summary>              <div class='content'>              <ul><li>打疫苗</li><li>看《哥斯拉大战金刚》体验不是很好，声音太大了，3D还是带夹片吧，对近视很不友好</li></ul>              </div>            </details><h3 id="2021年4月18日"><a class="header-anchor" href="#2021年4月18日"></a>2021年4月18日</h3><ul><li>DONE 学习前端，<a href="https://www.bilibili.com/video/BV1pE411q7FU?p=42&amp;spm_id_from=pageDriver">Web前端入门教程 P1-P41 </a></li></ul><details ><summary> 2021年4月18日小结 </summary>              <div class='content'>              <p>知乎上看到的中科院自动化所的博士论文致谢的消息。<a href="https://www.zhihu.com/question/454961393">网站链接</a></p><p>看完后也是十分触动，我也是农村出来的，不富裕，而生活在现在的环境中让我产生了逃避的想法，一箪食一瓢饮的生活对我来说并没有什么不好，但对于社会环境来说，只是要活的体面，照成贫穷原因有很多，与环境与自身，当上一辈人确实因为环境等因素制约了发展，但对于我来说，有着足够的条件来过上好生活，但如果还不向上努力，便是自身的因素。我可以选择过平淡的人生，但是我也从来不是没有独立思想，随波逐流的人。</p><p>屈原与渔夫的故事我印象非常深，选择“宁赴湘流，葬于江鱼之腹中。安能以皓皓之白，而蒙世俗之尘埃乎”与“沧浪之水清兮，可以濯吾缨；沧浪之水浊兮，可以濯吾足。”那时候我的答案是屈原，当别人多数人选择了渔夫时，我是有些不解，但这快4年下来，我也渐渐被“磨平棱角”，这件事没有谁对谁错，如果以马原来选择那就是”因地制宜“，总之有些晚了我要碎觉了。</p>              </div>            </details><h2 id="考研各项目规划"><a class="header-anchor" href="#考研各项目规划"></a>考研各项目规划</h2><h3 id="操作系统"><a class="header-anchor" href="#操作系统"></a>操作系统</h3><table><thead><tr><th>学习内容</th><th>开始时间</th><th>结束时间</th><th>学习结果</th></tr></thead><tbody><tr><td>计算机系统概述</td><td>2021年3月29日</td><td>2021年3月31日</td><td><a href="http://blog.halo123.top:8090/archives/overviewofcomputersystems">文章链接</a></td></tr><tr><td>进程管理</td><td>2021年4月1日</td><td>2021年4月22日</td><td><a href="http://blog.halo123.top:8090/archives/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86">文章链接</a></td></tr><tr><td>内存管理</td><td></td><td></td><td></td></tr><tr><td>文件管理</td><td></td><td></td><td></td></tr><tr><td>I/O管理</td><td></td><td></td><td></td></tr></tbody></table><h3 id="数据结构"><a class="header-anchor" href="#数据结构"></a>数据结构</h3><table><thead><tr><th>学习内容</th><th>开始时间</th><th>结束时间</th><th>学习结果</th></tr></thead><tbody><tr><td>绪论</td><td>3月</td><td>3月</td><td></td></tr><tr><td>线性表</td><td>3月</td><td>3月</td><td>5月2日</td></tr><tr><td>栈和队列</td><td>5月2日</td><td></td><td></td></tr><tr><td>串</td><td></td><td></td><td></td></tr><tr><td>树和二叉树</td><td></td><td></td><td></td></tr><tr><td>图</td><td></td><td></td><td></td></tr><tr><td>查找</td><td></td><td></td><td></td></tr><tr><td>排序</td><td></td><td></td><td></td></tr></tbody></table><h3 id="计算机组成原理"><a class="header-anchor" href="#计算机组成原理"></a>计算机组成原理</h3><table><thead><tr><th>学习内容</th><th>开始时间</th><th>结束时间</th><th>学习结果</th></tr></thead><tbody><tr><td>计算机系统概述</td><td>3月</td><td>3月</td><td></td></tr><tr><td>数据的表示和运算</td><td>3月</td><td></td><td></td></tr><tr><td>储存系统</td><td></td><td></td><td></td></tr><tr><td>指令系统</td><td></td><td></td><td></td></tr><tr><td>中央处理器</td><td></td><td></td><td></td></tr><tr><td>总线</td><td></td><td></td><td></td></tr><tr><td>输入/输出系统</td><td></td><td></td><td></td></tr></tbody></table><h3 id="计算机网络"><a class="header-anchor" href="#计算机网络"></a>计算机网络</h3><table><thead><tr><th>学习内容</th><th>开始时间</th><th>结束时间</th><th>学习结果</th></tr></thead><tbody><tr><td>计算机网络体系结构</td><td>3月</td><td>3月</td><td></td></tr><tr><td>物理层</td><td>3月</td><td>3月</td><td></td></tr><tr><td>数据链路层</td><td></td><td></td><td></td></tr><tr><td>网络层</td><td></td><td></td><td></td></tr><tr><td>传输层</td><td></td><td></td><td></td></tr><tr><td>应用层</td><td></td><td></td><td></td></tr></tbody></table><h3 id="线性代数"><a class="header-anchor" href="#线性代数"></a>线性代数</h3><table><thead><tr><th>学习内容</th><th>开始时间</th><th>结束时间</th><th>学习结果</th></tr></thead><tbody><tr><td>行列式</td><td>3月</td><td>3月</td><td></td></tr><tr><td>矩阵</td><td>3月</td><td></td><td></td></tr><tr><td>向量</td><td></td><td></td><td></td></tr><tr><td>线性方程组</td><td></td><td></td><td></td></tr><tr><td>特征值和特征向量</td><td></td><td></td><td></td></tr><tr><td>二次型</td><td></td><td></td><td></td></tr></tbody></table><h3 id="概率论与梳理统计"><a class="header-anchor" href="#概率论与梳理统计"></a>概率论与梳理统计</h3><table><thead><tr><th>学习内容</th><th>开始时间</th><th>结束时间</th><th>学习结果</th></tr></thead><tbody><tr><td>随机时间和概率</td><td></td><td></td><td></td></tr><tr><td>随机变量及其概论分布</td><td></td><td></td><td></td></tr><tr><td>多维随机变量及其分布</td><td></td><td></td><td></td></tr><tr><td>随机变量的数字特征</td><td></td><td></td><td></td></tr><tr><td>大数定理和中心极限定理</td><td></td><td></td><td></td></tr><tr><td>数理统计的基本概念</td><td></td><td></td><td></td></tr><tr><td>参数估计</td><td></td><td></td><td></td></tr><tr><td>假设检验</td><td></td><td></td><td></td></tr></tbody></table><h3 id="高等数学"><a class="header-anchor" href="#高等数学"></a>高等数学</h3><table><thead><tr><th>学习内容</th><th>开始时间</th><th>结束时间</th><th>学习结果</th></tr></thead><tbody><tr><td>函数、极限、连续</td><td></td><td></td><td></td></tr><tr><td>导数与微分</td><td></td><td></td><td></td></tr><tr><td>微分中值定理及导数应用</td><td></td><td></td><td></td></tr><tr><td>不定积分</td><td></td><td></td><td></td></tr><tr><td>定积分与反常积分</td><td></td><td></td><td></td></tr><tr><td>定积分的应用</td><td></td><td></td><td></td></tr><tr><td>微分方程</td><td></td><td></td><td></td></tr><tr><td>多元函数微分学</td><td></td><td></td><td></td></tr><tr><td>二重积分</td><td></td><td></td><td></td></tr><tr><td>无穷级数</td><td></td><td></td><td></td></tr><tr><td>向量代数与空间解析几何及多元微分学在几何上的应用</td><td></td><td></td><td></td></tr><tr><td>多元积分学及其应用</td><td></td><td></td><td></td></tr></tbody></table><h3 id="思想道德修养与法律基础"><a class="header-anchor" href="#思想道德修养与法律基础"></a>思想道德修养与法律基础</h3><h3 id="毛泽东思想和中国特色社会主义理论体系概论"><a class="header-anchor" href="#毛泽东思想和中国特色社会主义理论体系概论"></a>毛泽东思想和中国特色社会主义理论体系概论</h3><h3 id="马克思主义基本原理概论"><a class="header-anchor" href="#马克思主义基本原理概论"></a>马克思主义基本原理概论</h3><h3 id="中国近代史纲要"><a class="header-anchor" href="#中国近代史纲要"></a>中国近代史纲要</h3><h3 id="英语词汇"><a class="header-anchor" href="#英语词汇"></a>英语词汇</h3><table><thead><tr><th>学习内容</th><th>开始时间</th><th>结束时间</th><th>学习结果</th></tr></thead><tbody><tr><td>题源报刊7000词Unit 1</td><td>2021年4月21日</td><td></td><td></td></tr></tbody></table><h3 id="英语语法"><a class="header-anchor" href="#英语语法"></a>英语语法</h3><h3 id="英语核心长难句"><a class="header-anchor" href="#英语核心长难句"></a>英语核心长难句</h3><h3 id="英语强化练习"><a class="header-anchor" href="#英语强化练习"></a>英语强化练习</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;⏳自律的人有多可怕&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#⏳自律的人有多可怕&quot;&gt;&lt;/a&gt;⏳自律的人有多可怕&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;我的梦想到底是什么，我有为此付出过什么吗&lt;/li&gt;
&lt;li&gt;无特殊情况，一天至少8小时考研学习时间&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>《人类简史》读书笔记</title>
    <link href="http://halo123.top/2021/04/18/ReadingNotes/Sapiens/"/>
    <id>http://halo123.top/2021/04/18/ReadingNotes/Sapiens/</id>
    <published>2021-04-18T12:03:56.000Z</published>
    <updated>2021-05-04T06:29:54.401Z</updated>
    
    <content type="html"><![CDATA[<h2 id="📖文摘"><a class="header-anchor" href="#📖文摘"></a>📖文摘</h2><p>赫拉利在说起历史上和现实中只对强者有利的自由市场资本主义、殖民主义、帝国主义、消费主义、男性霸权，以及总是在为帝国主义和资本主义服务的科学时，自然也没有好气，基本上都是揶揄和批判。总之，他认为迄今为止的智人历史，大行其道的都是这些乱七八糟、一无是处的东西，因而“历史从无公正”，而所谓的“智人”呢，其实一点也不明智，相反是一个非常糟糕、令人失望的物种。</p><p>他对智人的所有批评，说到底只是一种“恨铁不成钢”的埋怨，而深藏于其中的，其实还是一种对人类命运的深深忧虑，以及对智人幡然悔悟、痛改前非的殷切期待。</p><h2 id="第一部分-认识革命"><a class="header-anchor" href="#第一部分-认识革命"></a>第一部分 认识革命</h2><h3 id="第一章-人类-一种也没什么特别的动物"><a class="header-anchor" href="#第一章-人类-一种也没什么特别的动物"></a>第一章 人类:一种也没什么特别的动物</h3><p>物理学 → 化学 → 生物学 → 历史学</p><p>7万年前 认知革命 → 1万2千年前 农业革命 → 500年前 科学革命</p><p>讲述了智人是如何起源的，在起源初存在多种人例如：“直立人”、“尼安德特人”、“丹尼索瓦人”、“梭罗人”等，然而现在只存在智人。</p><p>人类物种的代价，为了大脑，牺牲了许多，产出的婴儿是“早产儿”，为此需要抚养诞生了基本的社会关系，学会了用火，退化了消化功能，在更有效率的获取能量的同时退化了消化系统减少能量的消耗。这一切反作用于大脑的进化，身体机能与大脑社交相辅相成</p><p>但对于明确只剩下智人这一原因，有两种猜测：混种繁衍理论和替代理论，目前发现两者理论都有可取之处。</p><h3 id="第二章-知善恶树"><a class="header-anchor" href="#第二章-知善恶树"></a>第二章 知善恶树</h3><blockquote><p>大约就是在距今7万到3万年前，出现了新的思维和沟通方式，这也正是所谓的认知革命。会发生认知革命的原因为何？我们无从得知。得到普遍认可的理论认为，某次偶然的基因突变，改变了智人的大脑内部连接方式，让他们以前所未有的方式来思考，用完全新式的语言来沟通。这次突变，几乎就像是吃了《圣经》里那棵知善恶树的果实一样。</p></blockquote><ul><li>“河边有只狮子”理论，认为人类语言最为灵活。虽然我们只能发出有限的声音，但组合起来却能产生无限多的句子，各有不同的含义。</li><li>八卦理论的理论，语言发展成了一种八卦的工具。根据这一理论，智人主要是一种社会性的动物，社会合作是我们得以生存和繁衍的关键。</li></ul><p>然而，人类语言真正最独特的功能，并不在于能够传达关于人或狮子的信息，而是能够传达关于一些根本不存在的事物的信息。</p>]]></content>
    
    
    <summary type="html">描述</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>创建型模式之简单工厂模式</title>
    <link href="http://halo123.top/2021/04/18/DesignPatterns/B_SimpleFactoryPattern/"/>
    <id>http://halo123.top/2021/04/18/DesignPatterns/B_SimpleFactoryPattern/</id>
    <published>2021-04-18T10:04:00.612Z</published>
    <updated>2021-04-18T10:10:47.571Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单工厂模式概述"><a class="header-anchor" href="#简单工厂模式概述"></a>简单工厂模式概述</h2><p>简单工厂模式并不属于GoF 23个经典设计模式，但通常将它作为学习其他工厂模式的基础，它的设计思想很简单，其基本流程如下：</p><ol><li>首先将需要创建的各种不同对象（例如各种不同的Chart对象）的相关代码封装到不同的类中，这些类称为具体产品类，而将它们公共的代码进行抽象和提取后封装在一个抽象产品类中，每一个具体产品类都是抽象产品类的子类；</li><li>然后提供一个工厂类用于创建各种产品，在工厂类中提供一个创建产品的工厂方法，该方法可以根据所传入的参数不同创建不同的具体产品对象；</li><li>客户端只需调用工厂类的工厂方法并传入相应的参数即可得到一个产品对象。</li></ol><p>简单工厂模式定义如下：</p><p>简单工厂模式(Simple Factory Pattern)：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。</p><p>因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。</p><p>简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。</p><h2 id="简单工厂模式结构"><a class="header-anchor" href="#简单工厂模式结构"></a>简单工厂模式结构</h2><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84.png" alt="简单工厂模式结构" style="object-fit: cover; border-radius: 10px; width: 100%;" /><p>在简单工厂模式结构中包含如下几个角色：</p><ul><li>Factory（工厂角色）：工厂角色即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂方法<code>factoryMethod()</code>，它的返回类型为抽象产品类型Product。</li><li>Product（抽象产品角色）：它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法，它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。</li><li>ConcreteProduct（具体产品角色）：它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法。</li></ul><h2 id="简单工厂模式实现"><a class="header-anchor" href="#简单工厂模式实现"></a>简单工厂模式实现</h2><p>在简单工厂模式中，客户端通过工厂类来创建一个产品类的实例，而无须直接使用<code>new</code>关键字来创建对象，它是工厂模式家族中最简单的一员。</p><p>在使用简单工厂模式时，首先需要对产品类进行重构，不能设计一个包罗万象的产品类，而需根据实际情况设计一个产品层次结构，将所有产品类公共的代码移至抽象产品类，并在抽象产品类中声明一些抽象方法，以供不同的具体产品类来实现，典型的抽象产品类代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="comment">//所有产品类的公共业务方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodSame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//公共方法的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//声明抽象业务方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">methodDiff</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在具体产品类中实现了抽象产品类中声明的抽象业务方法，不同的具体产品类可以提供不同的实现，典型的具体产品类代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实现业务方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodDiff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//业务方法的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单工厂模式的核心是工厂类，在没有工厂类之前，客户端一般会使用<code>new</code>关键字来直接创建产品对象，而在引入工厂类之后，客户端可以通过工厂类来创建产品，在简单工厂模式中，工厂类提供了一个静态工厂方法供客户端使用，根据所传入的参数不同可以创建不同的产品对象，典型的工厂类代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//静态工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title">getProduct</span><span class="params">(String arg)</span> </span>&#123;</span><br><span class="line">        Product product = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (arg.equalsIgnoreCase(<span class="string">&quot;A&quot;</span>)) &#123;</span><br><span class="line">            product = <span class="keyword">new</span> ConcreteProductA();</span><br><span class="line">            <span class="comment">//初始化设置product</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arg.equalsIgnoreCase(<span class="string">&quot;B&quot;</span>)) &#123;</span><br><span class="line">            product = <span class="keyword">new</span> ConcreteProductB();</span><br><span class="line">            <span class="comment">//初始化设置product</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在客户端代码中，我们通过调用工厂类的工厂方法即可得到产品对象，典型代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Product product;</span><br><span class="line">        product = Factory.getProduct(<span class="string">&quot;A&quot;</span>); <span class="comment">//通过工厂类创建产品对象</span></span><br><span class="line">        product.methodSame();</span><br><span class="line">        product.methodDiff();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单工厂模式应用实例"><a class="header-anchor" href="#简单工厂模式应用实例"></a>简单工厂模式应用实例</h2><p>通过设置不同参数即可得到不同类型的图表，且能易扩展。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B%E7%BB%93%E6%9E%84.png" alt="简单工厂模式应用实例结构" style="object-fit: cover; border-radius: 20px; width: 100%;" /><p><code>Chart</code>接口充当抽象产品类，其子类<code>HistogramChart</code>、<code>PieChart</code>和<code>LineChart</code>充当具体产品类，<code>ChartFactory</code>充当工厂类。完整代码如下所示：</p><ol><li><p><code>Chart</code>：抽象图表接口，充当抽象产品类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Chart</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>HistogramChart</code>：柱状图类，充当具体产品类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HistogramChart</span> <span class="keyword">implements</span> <span class="title">Chart</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HistogramChart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;创建柱状图！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;显示柱状图！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>PieChart</code>：饼状图类，充当具体产品类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PieChart</span> <span class="keyword">implements</span> <span class="title">Chart</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PieChart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;创建饼状图！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;显示饼状图！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>LineChart</code>：折线图类，充当具体产品类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineChart</span> <span class="keyword">implements</span> <span class="title">Chart</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LineChart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;创建折线图！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;显示折线图！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>ChartFactory</code>：图表工厂类，充当工厂类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChartFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//静态工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Chart <span class="title">getChart</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        Chart chart = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">&quot;histogram&quot;</span>)) &#123;</span><br><span class="line">            chart = <span class="keyword">new</span> HistogramChart();</span><br><span class="line">            System.out.println(<span class="string">&quot;初始化设置柱状图！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">&quot;pie&quot;</span>)) &#123;</span><br><span class="line">            chart = <span class="keyword">new</span> PieChart();</span><br><span class="line">            System.out.println(<span class="string">&quot;初始化设置饼状图！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">&quot;line&quot;</span>)) &#123;</span><br><span class="line">            chart = <span class="keyword">new</span> LineChart();</span><br><span class="line">            System.out.println(<span class="string">&quot;初始化设置折线图！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chart;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>Client</code>：客户端测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Chart chart;</span><br><span class="line">        chart = ChartFactory.getChart(<span class="string">&quot;histogram&quot;</span>); <span class="comment">//通过静态工厂方法创建产品</span></span><br><span class="line">        chart.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>编译并运行程序，输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">创建柱状图！</span><br><span class="line">初始化设置柱状图！</span><br><span class="line">显示柱状图！</span><br></pre></td></tr></table></figure><p>在客户端测试类中，我们使用工厂类的静态工厂方法创建产品对象，如果需要更换产品，只 需修改静态工厂方法中的参数即可，例如将柱状图改为饼状图，只需将代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chart = ChartFactory.getChart(<span class="string">&quot;histogram&quot;</span>);</span><br></pre></td></tr></table></figure><p>改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chart = ChartFactory.getChart(<span class="string">&quot;pie&quot;</span>);</span><br></pre></td></tr></table></figure><p>编译并运行程序，输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">创建饼状图！</span><br><span class="line">初始化设置饼状图！</span><br><span class="line">显示饼状图！</span><br></pre></td></tr></table></figure><p>不难发现在创建具体<code>Chart</code>对象时，每更换一个<code>Chart</code>对象都需要修改客户端代码中静态工厂方法的参数，客户端代码将要重新编译，这对于客户端而言，违反了“开闭原则”，有没有一种方法能够在不修改客户端代码的前提下更换具体产品对象呢？答案是肯定的，下面将介绍一种常用的实现方式。</p><p>我们可以将静态工厂方法的参数存储在XML或properties格式的配置文件中，如下config.xml所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">chartType</span>&gt;</span>histogram<span class="tag">&lt;/<span class="name">chartType</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>再通过一个工具类XMLUtil来读取配置文件中的字符串参数，XMLUtil类的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.xml.parsers.*;</span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.*;</span><br><span class="line"><span class="keyword">import</span> org.xml.sax.SAXException;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XMLUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">//该方法用于从XML配置文件中提取图表类型，并返回类型名</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getChartType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建文档对象</span></span><br><span class="line">            DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance();</span><br><span class="line">            DocumentBuilder builder = dFactory.newDocumentBuilder();</span><br><span class="line">            Document doc;</span><br><span class="line">            doc = builder.parse(<span class="keyword">new</span> File(<span class="string">&quot;config.xml&quot;</span>));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//获取包含图表类型的文本节点</span></span><br><span class="line">            NodeList nl = doc.getElementsByTagName(<span class="string">&quot;chartType&quot;</span>);</span><br><span class="line">            Node classNode = nl.item(<span class="number">0</span>).getFirstChild();</span><br><span class="line">            String chartType = classNode.getNodeValue().trim();</span><br><span class="line">            <span class="keyword">return</span> chartType;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在引入了配置文件和工具类<code>XMLUtil</code>之后，客户端代码修改如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Chart chart;</span><br><span class="line">        String type = XMLUtil.getChartType(); <span class="comment">//读取配置文件中的参数</span></span><br><span class="line">        chart = ChartFactory.getChart(type); <span class="comment">//创建产品对象</span></span><br><span class="line">        chart.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难发现，在上述客户端代码中不包含任何与具体图表对象相关的信息，如果需要更换具体图表对象，只需修改配置文件config.xml，无须修改任何源代码，符合“开闭原则”。</p><h2 id="简单工厂模式的简化"><a class="header-anchor" href="#简单工厂模式的简化"></a>简单工厂模式的简化</h2><p>有时候，为了简化简单工厂模式，我们可以将抽象产品类和工厂类合并，将静态工厂方法移至抽象产品类中，如图所示：</p><p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%AE%80%E5%8C%96%E7%BB%93%E6%9E%84.png" alt="简单工厂模式的简化结构"></p><p>客户端可以通过产品父类的静态工厂方法，根据参数的不同创建不同类型的产品子 类对象，这种做法在JDK等类库和框架中也广泛存在。</p><h2 id="简单工厂模式总结"><a class="header-anchor" href="#简单工厂模式总结"></a>简单工厂模式总结</h2><h3 id="简单工厂模式优点"><a class="header-anchor" href="#简单工厂模式优点"></a>简单工厂模式优点</h3><ol><li>工厂类包含必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的职责，而仅仅“消费”产品，简单工厂模式<font color="#faa755">实现了对象创建和使用的分离</font>。</li><li>客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以在一定程度减少使用者的记忆量。</li><li>通过引入配置文件，可以在<font color="#faa755">不修改任何客户端代码的情况下更换和增加新的具体产品类</font>，在一定程度上提高了系统的灵活性。</li></ol><h3 id="简单工厂模式缺点"><a class="header-anchor" href="#简单工厂模式缺点"></a>简单工厂模式缺点</h3><ol><li>由于工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响。</li><li>使用简单工厂模式势必会增加系统中类的个数（引入了新的工厂类），增加了系统的复杂度和理解难度。</li><li>系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。</li><li>简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。</li></ol><h3 id="模式适用环境"><a class="header-anchor" href="#模式适用环境"></a>模式适用环境</h3><ol><li>工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。</li><li>客户端只知道传入工厂类的参数，对于如何创建对象并不关心。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简单工厂模式概述&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#简单工厂模式概述&quot;&gt;&lt;/a&gt;简单工厂模式概述&lt;/h2&gt;
&lt;p&gt;简单工厂模式并不属于GoF 23个经典设计模式，但通常将它作为学习其他工厂模式的基础，它的设计思想很简单，其基本流程如</summary>
      
    
    
    
    <category term="设计模式" scheme="http://halo123.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://halo123.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式概述及面向对象设计原则</title>
    <link href="http://halo123.top/2021/04/18/DesignPatterns/A_OverviewOfDesignPatterns/"/>
    <id>http://halo123.top/2021/04/18/DesignPatterns/A_OverviewOfDesignPatterns/</id>
    <published>2021-04-18T10:01:08.455Z</published>
    <updated>2021-04-18T10:11:29.770Z</updated>
    
    <content type="html"><![CDATA[<h1>设计模式概述</h1><h2 id="掌握设计模式的层次"><a class="header-anchor" href="#掌握设计模式的层次"></a>掌握设计模式的层次</h2><ol><li>第 1 层：刚开始学编程不久，听说过什么是设计模式</li><li>第 2 层：有很长时间的编程经验，自己写了很多代码，其中用到了设计模式，但是自己却不知道</li><li>第 3 层：学习过了设计模式，发现自己已经在使用了，并且发现了一些新的模式挺好用的</li><li>第 4 层：阅读了很多别人写的源码和框架，在其中看到别人设计模式，并且能够领会设计模式的精妙和带来的好处。</li><li>第 5 层：代码写着写着，自己都没有意识到使用了设计模式，并且熟练的写了出来</li></ol><h2 id="设计模式介绍"><a class="header-anchor" href="#设计模式介绍"></a>设计模式介绍</h2><ol><li>设计模式是程序员在面对同类软件工程设计问题所总结出来的有用的经验，模式不是代码，而是某类问题的通用解决方案，设计模式（Design pattern）代表了最佳的实践。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</li><li>设计模式的本质提高 软件的维护性，通用性和扩展性，并降低软件的复杂度。</li></ol><h2 id="设计模式类型"><a class="header-anchor" href="#设计模式类型"></a>设计模式类型</h2><p>设计模式分为三种类型，共 <strong>23</strong> 种</p><ol><li>创建型模式：<font color="#faa755">单例模式</font>、抽象工厂模式、原型模式、建造者模式、<font color="#faa755">工厂模式</font>。</li><li>结构型模式：适配器模式、桥接模式、<font color="#faa755">装饰模式</font>、组合模式、外观模式、享元模式、<font color="#faa755">代理模式</font>。</li><li>行为型模式：模版方法模式、命令模式、访问者模式、迭代器模式、<font color="#faa755">观察者模式</font>、中介者模式、备忘录模式、解释器模式（Interpreter 模式）、状态模式、策略模式、职责链模式(责任链模式)。</li></ol><table><thead><tr><th>模式名称</th><th>定义</th><th>学习难度</th><th>使用频率</th></tr></thead><tbody><tr><td>简单工厂模式 (Simple Factory Pattern)</td><td>定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。</td><td>★★☆☆☆</td><td>★★★☆☆</td></tr><tr><td>工厂方法模式 (Factory Method Pattern)</td><td>定义一个用于创建对象的接口，但是让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。</td><td>★★☆☆☆</td><td>★★★★★</td></tr><tr><td>抽象工厂模式 (Abstract Factory Pattern)</td><td>提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。</td><td>★★★★☆</td><td>★★★★★</td></tr><tr><td>建造者模式 (Builder Pattern)</td><td>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</td><td>★★★★☆</td><td>★★☆☆☆</td></tr><tr><td>原型模式 (Prototype Pattern)</td><td>使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象。</td><td>★★★☆☆</td><td>★★★☆☆</td></tr><tr><td>单例模式 (Singleton Pattern)</td><td>确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一实例。</td><td>★☆☆☆☆</td><td>★★★★☆</td></tr></tbody></table><h1>面向对象设计原则</h1><p>编写软件过程中，程序员面临着来自耦合性，内聚性以及可维护性，可扩展性，重用性，灵活性等多方面的挑战，设计模式是为了让程序(软件)，具有更好的：</p><ol><li>代码重用性 (即：相同功能的代码，不用多次编写)</li><li>可读性 (即：编程规范性, 便于其他程序员的阅读和理解)</li><li>可扩展性 (即：当需要增加新的功能时，非常的方便，称为可维护)</li><li>可靠性 (即：当我们增加新的功能后，对原来的功能没有影响）</li><li>使程序呈现高内聚，低耦合的特性</li></ol><h2 id="设计模式七大原则介绍"><a class="header-anchor" href="#设计模式七大原则介绍"></a>设计模式七大原则介绍</h2><p>设计模式原则，其实就是程序员在编程时，应当遵守的原则，也是各种设计模式的基础(即：设计模式为什么这样设计的依据)</p><p>设计模式常用的七大原则有:</p><ol><li>单一职责原则</li><li>接口隔离原则</li><li>依赖倒转(倒置)原则</li><li>里氏替换原则</li><li>开闭原则</li><li>迪米特法则</li><li>合成复用原则</li></ol><h2 id="单一职责原则"><a class="header-anchor" href="#单一职责原则"></a>单一职责原则</h2><h3 id="基本介绍"><a class="header-anchor" href="#基本介绍"></a>基本介绍</h3><p>单一职责原则是最简单的面向对象设计原则，它用于控制类的粒度大小。</p><p>单一职责原则(Single Responsibility Principle, SRP)：一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中。就一个类而言，应该仅有一个引起它变化的原因。</p><p>在软件系统中，一个类（大到模块，小到方法） 承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将它们封装在同一类中。</p><p>如类 A 负责两个不同职责：职责 1，职责 2。当职责 1 需求变更而改变 A 时，可能造成职责 2 执行错误，所以需要将类 A 的粒度分解为 A1，A2。</p><p>单一职责原则是实现高内聚、低耦合的指导方针，它是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关实践经验。</p><h3 id="应用实例"><a class="header-anchor" href="#应用实例"></a>应用实例</h3><h4 id="方案1"><a class="header-anchor" href="#方案1"></a>方案1</h4><ol><li>在方案1的<code>run</code>方法中，违反了单一职责原则</li><li>解决的方案非常的简单，根据交通工具运行方法不同，分解成不同类即可</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleResponsibility1</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Vehicle vehicle = <span class="keyword">new</span> Vehicle();</span><br><span class="line">vehicle.run(<span class="string">&quot;摩托车&quot;</span>);</span><br><span class="line">vehicle.run(<span class="string">&quot;汽车&quot;</span>);</span><br><span class="line">vehicle.run(<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交通工具类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123;</span><br><span class="line">System.out.println(vehicle + <span class="string">&quot; 在公路上运行....&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方案2"><a class="header-anchor" href="#方案2"></a>方案2</h4><ol><li>遵守单一职责原则</li><li>但是这样做的改动很大，即将类分解，同时修改客户端</li><li>改进：直接修改<code>Vehicle</code> 类，改动的代码会比较少=&gt;方案3</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleResponsibility2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">RoadVehicle roadVehicle = <span class="keyword">new</span> RoadVehicle();</span><br><span class="line">roadVehicle.run(<span class="string">&quot;摩托车&quot;</span>);</span><br><span class="line">roadVehicle.run(<span class="string">&quot;汽车&quot;</span>);</span><br><span class="line"></span><br><span class="line">AirVehicle airVehicle = <span class="keyword">new</span> AirVehicle();</span><br><span class="line">airVehicle.run(<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoadVehicle</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123;</span><br><span class="line">System.out.println(vehicle + <span class="string">&quot;公路运行&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AirVehicle</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123;</span><br><span class="line">System.out.println(vehicle + <span class="string">&quot;天空运行&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaterVehicle</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123;</span><br><span class="line">System.out.println(vehicle + <span class="string">&quot;水中运行&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方案3"><a class="header-anchor" href="#方案3"></a>方案3</h4><ol><li>这种修改方法没有对原来的类做大的修改，只是增加方法</li><li>这里虽然没有在类这个级别上遵守单一职责原则，但是在方法级别上，仍然是遵守单一职责</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleResponsibility3</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Vehicle vehicle  = <span class="keyword">new</span> Vehicle();</span><br><span class="line">vehicle.run(<span class="string">&quot;汽车&quot;</span>);</span><br><span class="line">vehicle.runWater(<span class="string">&quot;轮船&quot;</span>);</span><br><span class="line">vehicle.runAir(<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123;</span><br><span class="line">System.out.println(vehicle + <span class="string">&quot; 在公路上运行....&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runAir</span><span class="params">(String vehicle)</span> </span>&#123;</span><br><span class="line">System.out.println(vehicle + <span class="string">&quot; 在天空上运行....&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runWater</span><span class="params">(String vehicle)</span> </span>&#123;</span><br><span class="line">System.out.println(vehicle + <span class="string">&quot; 在水中行....&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单一职责原则注意事项和细节"><a class="header-anchor" href="#单一职责原则注意事项和细节"></a>单一职责原则注意事项和细节</h3><ol><li>降低类的复杂度，一个类只负责一项职责。</li><li>提高类的可读性，可维护性</li><li>降低变更引起的风险</li><li>通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则</li></ol><h2 id="接口隔离原则"><a class="header-anchor" href="#接口隔离原则"></a>接口隔离原则</h2><h3 id="基本介绍-v2"><a class="header-anchor" href="#基本介绍-v2"></a>基本介绍</h3><p>接口隔离原则(Interface Segregation Principle)：客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上</p><h3 id="应用实例-v2"><a class="header-anchor" href="#应用实例-v2"></a>应用实例</h3><p>类 A 通过接口 Interface1 依赖类 B，类 C 通过接口 Interface1 依赖类 D，如果接口 Interface1 对于类 A 和类 C 来说不是最小接口，那么类 B 和类 D 必须去实现他们不需要的方法。</p><p><img src="../../../../Image/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%991.svg" alt="接口隔离原则1"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Segregation1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation4</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation5</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">Interface1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B 实现了 operation1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B 实现了 operation2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B 实现了 operation3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B 实现了 operation4&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B 实现了 operation5&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">Interface1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;D 实现了 operation1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;D 实现了 operation2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;D 实现了 operation3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;D 实现了 operation4&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;D 实现了 operation5&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; <span class="comment">//A 类通过接口Interface1 依赖(使用) B类，但是只会用到1,2,3方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(Interface1 i)</span> </span>&#123;</span><br><span class="line">        i.operation1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(Interface1 i)</span> </span>&#123;</span><br><span class="line">        i.operation2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(Interface1 i)</span> </span>&#123;</span><br><span class="line">        i.operation3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123; <span class="comment">//C 类通过接口Interface1 依赖(使用) D类，但是只会用到1,4,5方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(Interface1 i)</span> </span>&#123;</span><br><span class="line">        i.operation1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend4</span><span class="params">(Interface1 i)</span> </span>&#123;</span><br><span class="line">        i.operation4();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend5</span><span class="params">(Interface1 i)</span> </span>&#123;</span><br><span class="line">        i.operation5();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>按隔离原则应当这样处理：将接口 <strong>Interface1</strong> 拆分为独立的几个接口**(<strong>这里我们拆分成 <strong>3</strong> 个接口</strong>)**，类 A 和类 C 分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则</p><p><img src="../../../../Image/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99.svg" alt="接口隔离原则"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Segregation1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">A a = <span class="keyword">new</span> A();</span><br><span class="line">a.depend1(<span class="keyword">new</span> B()); <span class="comment">// A类通过接口去依赖B类</span></span><br><span class="line">a.depend2(<span class="keyword">new</span> B());</span><br><span class="line">a.depend3(<span class="keyword">new</span> B());</span><br><span class="line"></span><br><span class="line">C c = <span class="keyword">new</span> C();</span><br><span class="line"></span><br><span class="line">c.depend1(<span class="keyword">new</span> D()); <span class="comment">// C类通过接口去依赖(使用)D类</span></span><br><span class="line">c.depend4(<span class="keyword">new</span> D());</span><br><span class="line">c.depend5(<span class="keyword">new</span> D());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口1</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface1</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口2</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口3</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface3</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operation4</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operation5</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">Interface1</span>, <span class="title">Interface2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;B 实现了 operation1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;B 实现了 operation2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;B 实现了 operation3&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">Interface1</span>, <span class="title">Interface3</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;D 实现了 operation1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;D 实现了 operation4&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;D 实现了 operation5&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; <span class="comment">// A 类通过接口Interface1,Interface2 依赖(使用) B类，但是只会用到1,2,3方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(Interface1 i)</span> </span>&#123;</span><br><span class="line">i.operation1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(Interface2 i)</span> </span>&#123;</span><br><span class="line">i.operation2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(Interface2 i)</span> </span>&#123;</span><br><span class="line">i.operation3();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123; <span class="comment">// C 类通过接口Interface1,Interface3 依赖(使用) D类，但是只会用到1,4,5方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(Interface1 i)</span> </span>&#123;</span><br><span class="line">i.operation1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend4</span><span class="params">(Interface3 i)</span> </span>&#123;</span><br><span class="line">i.operation4();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend5</span><span class="params">(Interface3 i)</span> </span>&#123;</span><br><span class="line">i.operation5();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="依赖倒转原则"><a class="header-anchor" href="#依赖倒转原则"></a>依赖倒转原则</h2><h3 id="基本原则"><a class="header-anchor" href="#基本原则"></a>基本原则</h3><p>依赖倒转原则(Dependence Inversion Principle)是指：</p><ol><li>高层模块不应该依赖低层模块，二者都应该依赖其抽象</li><li>抽象不应该依赖细节，细节应该依赖抽象</li><li>依赖倒转(倒置)的中心思想是<font color="#faa755">面向接口编程</font></li><li>依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在 java 中，抽象指的是接口或抽象类，细节就是具体的实现类</li><li>使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成</li></ol><h3 id="应用实例-v3"><a class="header-anchor" href="#应用实例-v3"></a>应用实例</h3><h4 id="方式1"><a class="header-anchor" href="#方式1"></a>方式1</h4><ol><li>简单，比较容易想到</li><li>如果我们获取的对象是 微信，短信等等，则新增类，同时<code>Perons</code>也要增加相应的接收方法</li><li>解决思路：引入一个抽象的接口<code>IReceiver</code>, 表示接收者, 这样<code>Person</code>类与接口<code>IReceiver</code>发生依赖。因为<code>Email</code>, <code>WeiXin</code> 等等属于接收的范围，他们各自实现<code>IReceiver</code> 接口就ok, 这样我们就符号依赖倒转原则</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyInversion</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.receive(<span class="keyword">new</span> Email());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Email</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;电子邮件信息: hello,world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Email email)</span> </span>&#123;</span><br><span class="line">        System.out.println(email.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方式2"><a class="header-anchor" href="#方式2"></a>方式2</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyInversion</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//客户端无需改变</span></span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.receive(<span class="keyword">new</span> Email());</span><br><span class="line"></span><br><span class="line">        person.receive(<span class="keyword">new</span> WeiXin());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IReceiver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Email</span> <span class="keyword">implements</span> <span class="title">IReceiver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;电子邮件信息: hello,world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加微信</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeiXin</span> <span class="keyword">implements</span> <span class="title">IReceiver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;微信信息: hello,ok&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里我们是对接口的依赖</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(IReceiver receiver)</span> </span>&#123;</span><br><span class="line">        System.out.println(receiver.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="依赖关系传递的三种方式和应用案例"><a class="header-anchor" href="#依赖关系传递的三种方式和应用案例"></a>依赖关系传递的三种方式和应用案例</h3><p>方式1：通过接口传递实现依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开关的接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(ITV tv)</span></span>; <span class="comment">//抽象方法,接收接口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ITV</span> </span>&#123; <span class="comment">//ITV接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenAndClose</span> <span class="keyword">implements</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(ITV tv)</span> </span>&#123;</span><br><span class="line">        tv.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//============使用============</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChangHong</span> <span class="keyword">implements</span> <span class="title">ITV</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;长虹电视机，打开&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyPass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ChangHong changHong = <span class="keyword">new</span> ChangHong();</span><br><span class="line">        OpenAndClose openAndClose = <span class="keyword">new</span> OpenAndClose();</span><br><span class="line">openAndClose.open(changHong);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>方式2：通过构造方法依赖传递</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>; <span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ITV</span> </span>&#123; <span class="comment">//ITV接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenAndClose</span> <span class="keyword">implements</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ITV tv; <span class="comment">//成员</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OpenAndClose</span><span class="params">(ITV tv)</span> </span>&#123; <span class="comment">//构造器</span></span><br><span class="line">        <span class="keyword">this</span>.tv = tv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tv.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//============使用============</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChangHong</span> <span class="keyword">implements</span> <span class="title">ITV</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;长虹电视机，打开&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyPass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ChangHong changHong = <span class="keyword">new</span> ChangHong();</span><br><span class="line">OpenAndClose openAndClose = <span class="keyword">new</span> OpenAndClose(changHong);</span><br><span class="line">openAndClose.open();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>方式3：通过setter方法传递</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>; <span class="comment">// 抽象方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTv</span><span class="params">(ITV tv)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ITV</span> </span>&#123; <span class="comment">// ITV接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenAndClose</span> <span class="keyword">implements</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ITV tv;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTv</span><span class="params">(ITV tv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tv = tv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tv.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//============使用============</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChangHong</span> <span class="keyword">implements</span> <span class="title">ITV</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;长虹电视机，打开&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyPass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ChangHong changHong = <span class="keyword">new</span> ChangHong();</span><br><span class="line">        OpenAndClose openAndClose = <span class="keyword">new</span> OpenAndClose();</span><br><span class="line">        openAndClose.setTv(changHong);</span><br><span class="line">        openAndClose.open();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="依赖倒转原则的注意事项和细节"><a class="header-anchor" href="#依赖倒转原则的注意事项和细节"></a>依赖倒转原则的注意事项和细节</h3><ol><li>低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好.</li><li>变量的声明类型尽量是抽象类或接口, 这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化</li><li>继承时遵循里氏替换原则</li></ol><h2 id="里氏替换原则"><a class="header-anchor" href="#里氏替换原则"></a>里氏替换原则</h2><h3 id="面向对象中的继承性的思考和说明"><a class="header-anchor" href="#面向对象中的继承性的思考和说明"></a>面向对象中的继承性的思考和说明</h3><ol><li>继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。</li><li>继承在给程序设计带来便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低， 增加对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障</li><li>问题提出：在编程中，如何正确的使用继承? =&gt; 里氏替换原则</li></ol><h3 id="基本原理"><a class="header-anchor" href="#基本原理"></a>基本原理</h3><ol><li>如果对每个类型为 T1 的对象 o1，都有类型为 T2 的对象 o2，使得以 T1 定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。换句话说，所有引用基类的地方必须能透明地使用其子类的对象。</li><li>在使用继承时，遵循里氏替换原则，在<font color="#faa755">子类中尽量不要重写父类的方法</font></li><li>里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过<font color="#faa755">聚合，组合，依赖</font>来解决问题。</li></ol><h3 id="应用案例"><a class="header-anchor" href="#应用案例"></a>应用案例</h3><p>错误示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Liskov</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        System.out.println(<span class="string">&quot;11-3=&quot;</span> + a.func1(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;1-8=&quot;</span> + a.func1(<span class="number">1</span>, <span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        System.out.println(<span class="string">&quot;11-3=&quot;</span> + b.func1(<span class="number">11</span>, <span class="number">3</span>));<span class="comment">//这里本意是求出11-3</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1-8=&quot;</span> + b.func1(<span class="number">1</span>, <span class="number">8</span>));<span class="comment">// 1-8</span></span><br><span class="line">        System.out.println(<span class="string">&quot;11+3+9=&quot;</span> + b.func2(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回两个数的差</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 - num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B类继承了A</span></span><br><span class="line"><span class="comment">// 增加了一个新功能：完成两个数相加,然后和9求和</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里，重写了A类的方法, 可能是无意识</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> func1(a, b) + <span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Liskov</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        System.out.println(<span class="string">&quot;11-3=&quot;</span> + a.func1(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;1-8=&quot;</span> + a.func1(<span class="number">1</span>, <span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        <span class="comment">//因为B类不再继承A类，因此调用者，不会再func1是求减法</span></span><br><span class="line">        <span class="comment">//调用完成的功能就会很明确</span></span><br><span class="line">        System.out.println(<span class="string">&quot;11+3=&quot;</span> + b.func1(<span class="number">11</span>, <span class="number">3</span>));<span class="comment">//这里本意是求出11+3</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1+8=&quot;</span> + b.func1(<span class="number">1</span>, <span class="number">8</span>));<span class="comment">// 1+8</span></span><br><span class="line">        System.out.println(<span class="string">&quot;11+3+9=&quot;</span> + b.func2(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用组合仍然可以使用到A类相关方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;11-3=&quot;</span> + b.func3(<span class="number">11</span>, <span class="number">3</span>));<span class="comment">// 这里本意是求出11-3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个更加基础的基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="comment">//把更加基础的方法和成员写到Base类</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回两个数的差</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 - num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B类继承了A</span></span><br><span class="line"><span class="comment">// 增加了一个新功能：完成两个数相加,然后和9求和</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果B需要使用A类的方法,使用组合关系</span></span><br><span class="line">    <span class="keyword">private</span> A a = <span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里，重写了A类的方法, 可能是无意识</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> func1(a, b) + <span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//我们仍然想使用A的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func3</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.a.func1(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="开闭原则"><a class="header-anchor" href="#开闭原则"></a>开闭原则</h2><h3 id="基本介绍-v3"><a class="header-anchor" href="#基本介绍-v3"></a>基本介绍</h3><p>开闭原则是面向对象的可复用设计的第一块基石，它是最重要的面向对象设计原则。</p><p>开闭原则(Open-Closed Principle, OCP)：一个软件实体应当对扩展开放(对提供方)，对修改关闭(对使用方)。即软件实体应尽量在不修改原有代码的情况下进行扩展。</p><p>用抽象构建框架，用实现扩展细节。</p><ol start="3"><li>当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。</li><li>编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。</li></ol><h3 id="应用案例-v2"><a class="header-anchor" href="#应用案例-v2"></a>应用案例</h3><h4 id="方式一"><a class="header-anchor" href="#方式一"></a>方式一</h4><ol><li>优点是比较好理解，简单易操作。</li><li>缺点是违反了设计模式的开闭原则，即对扩展开放(提供方)，对修改关闭(使用方)。即当我们给类增加新功能的时候，尽量不修改代码，或者尽可能少修改代码.</li><li>比如我们这时要新增加一个图形种类 三角形，我们需要做如下修改，修改的地方较多</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ocp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用看看存在的问题</span></span><br><span class="line">        GraphicEditor graphicEditor = <span class="keyword">new</span> GraphicEditor();</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> Rectangle());</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> Circle());</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> Triangle());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是一个用于绘图的类 [使用方]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphicEditor</span> </span>&#123;</span><br><span class="line">    <span class="comment">//接收Shape对象，然后根据type，来绘制不同的图形</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawShape</span><span class="params">(Shape s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s.m_type == <span class="number">1</span>) &#123;</span><br><span class="line">drawRectangle(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s.m_type == <span class="number">2</span>) &#123;</span><br><span class="line">drawCircle(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s.m_type == <span class="number">3</span>) &#123;</span><br><span class="line">drawTriangle(s);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绘制矩形</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawRectangle</span><span class="params">(Shape r)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 绘制矩形 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绘制圆形</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawCircle</span><span class="params">(Shape r)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 绘制圆形 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绘制三角形</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawTriangle</span><span class="params">(Shape r)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 绘制三角形 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Shape类，基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    Rectangle() &#123;</span><br><span class="line">        <span class="keyword">super</span>.m_type = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    Circle() &#123;</span><br><span class="line">        <span class="keyword">super</span>.m_type = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增画三角形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    Triangle() &#123;</span><br><span class="line">        <span class="keyword">super</span>.m_type = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>改进的思路分析：把创建 <strong>Shape</strong> 类做成抽象类，并提供一个抽象的 <strong>draw</strong> 方法，让子类去实现即可，这样我们有新的图形种类时，只需要让新的图形类继承 Shape，并实现 draw 方法即可，使用方的代码就不需要修  -&gt;  满足了开闭原则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.principle.ocp.improve;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ocp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用看看存在的问题</span></span><br><span class="line">        GraphicEditor graphicEditor = <span class="keyword">new</span> GraphicEditor();</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> Rectangle());</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> Circle());</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> Triangle());</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> OtherGraphic());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是一个用于绘图的类 [使用方]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphicEditor</span> </span>&#123;</span><br><span class="line">    <span class="comment">//接收Shape对象，调用draw方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawShape</span><span class="params">(Shape s)</span> </span>&#123;</span><br><span class="line">        s.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Shape类，基类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m_type;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;<span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    Rectangle() &#123;</span><br><span class="line">        <span class="keyword">super</span>.m_type = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">&quot; 绘制矩形 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    Circle() &#123;</span><br><span class="line">        <span class="keyword">super</span>.m_type = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 绘制圆形 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增画三角形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    Triangle() &#123;</span><br><span class="line">        <span class="keyword">super</span>.m_type = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 绘制三角形 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增一个图形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OtherGraphic</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    OtherGraphic() &#123;</span><br><span class="line">        <span class="keyword">super</span>.m_type = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 绘制其它图形 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迪米特法则"><a class="header-anchor" href="#迪米特法则"></a>迪米特法则</h2><h3 id="基本介绍-v4"><a class="header-anchor" href="#基本介绍-v4"></a>基本介绍</h3><ol><li><p>一个对象应该对其他对象保持最少的了解</p></li><li><p>类与类关系越密切，耦合度越大</p></li><li><p>迪米特法则(Demeter Principle)又叫最少知道原则，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的 public 方法，不对外泄露任何信息</p></li><li><p>迪米特法则还有个更简单的定义：只与直接的朋友通信</p><blockquote><p>直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。</p></blockquote></li></ol><h3 id="应用示例"><a class="header-anchor" href="#应用示例"></a>应用示例</h3><p>有一个学校，下属有各个学院和总部，现要求打印出学校总部员工 ID 和学院员工的 id</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demeter1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建了一个 SchoolManager 对象</span></span><br><span class="line">        SchoolManager schoolManager = <span class="keyword">new</span> SchoolManager();</span><br><span class="line">        <span class="comment">//输出学院的员工id 和 学校总部的员工信息</span></span><br><span class="line">        schoolManager.printAllEmployee(<span class="keyword">new</span> CollegeManager());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学校总部员工类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//学院的员工类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeEmployee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//管理学院员工的管理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回学院的所有员工</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;CollegeEmployee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;CollegeEmployee&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; <span class="comment">//这里我们增加了10个员工到 list</span></span><br><span class="line">            CollegeEmployee emp = <span class="keyword">new</span> CollegeEmployee();</span><br><span class="line">            emp.setId(<span class="string">&quot;学院员工id= &quot;</span> + i);</span><br><span class="line">            list.add(emp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学校管理类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//分析 SchoolManager 类的直接朋友类有哪些 Employee、CollegeManager</span></span><br><span class="line"><span class="comment">//CollegeEmployee 不是 直接朋友 而是一个陌生类，这样违背了 迪米特法则</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SchoolManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回学校总部的员工</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Employee&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; <span class="comment">//这里我们增加了5个员工到 list</span></span><br><span class="line">            Employee emp = <span class="keyword">new</span> Employee();</span><br><span class="line">            emp.setId(<span class="string">&quot;学校总部员工id= &quot;</span> + i);</span><br><span class="line">            list.add(emp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该方法完成输出学校总部和学院员工信息(id)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printAllEmployee</span><span class="params">(CollegeManager sub)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分析问题</span></span><br><span class="line">        <span class="comment">//1. 这里的 CollegeEmployee 不是  SchoolManager的直接朋友</span></span><br><span class="line">        <span class="comment">//2. CollegeEmployee 是以局部变量方式出现在 SchoolManager</span></span><br><span class="line">        <span class="comment">//3. 违反了 迪米特法则</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取到学院员工</span></span><br><span class="line">        List&lt;CollegeEmployee&gt; list1 = sub.getAllEmployee();</span><br><span class="line">        System.out.println(<span class="string">&quot;------------学院员工------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (CollegeEmployee e : list1) &#123;</span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取到学校总部员工</span></span><br><span class="line">        List&lt;Employee&gt; list2 = <span class="keyword">this</span>.getAllEmployee();</span><br><span class="line">        System.out.println(<span class="string">&quot;------------学校总部员工------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Employee e : list2) &#123;</span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用实例改进分析：前面设计的问题在于 <code>SchoolManager</code> 中，<code>CollegeEmployee</code> 类并不是 <code>SchoolManager</code> 类的直接朋友 (分析)，按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demeter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;~~~使用迪米特法则的改进~~~&quot;</span>);</span><br><span class="line">        <span class="comment">//创建了一个 SchoolManager 对象</span></span><br><span class="line">        SchoolManager schoolManager = <span class="keyword">new</span> SchoolManager();</span><br><span class="line">        <span class="comment">//输出学院的员工id 和  学校总部的员工信息</span></span><br><span class="line">        schoolManager.printAllEmployee(<span class="keyword">new</span> CollegeManager());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//学校总部员工类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//学院的员工类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeEmployee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//管理学院员工的管理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回学院的所有员工</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;CollegeEmployee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;CollegeEmployee&gt; list = <span class="keyword">new</span> ArrayList&lt;CollegeEmployee&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; <span class="comment">//这里我们增加了10个员工到 list</span></span><br><span class="line">            CollegeEmployee emp = <span class="keyword">new</span> CollegeEmployee();</span><br><span class="line">            emp.setId(<span class="string">&quot;学院员工id= &quot;</span> + i);</span><br><span class="line">            list.add(emp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出学院员工的信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取到学院员工</span></span><br><span class="line">        List&lt;CollegeEmployee&gt; list1 = getAllEmployee();</span><br><span class="line">        System.out.println(<span class="string">&quot;------------学院员工------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (CollegeEmployee e : list1) &#123;</span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学校管理类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//分析 SchoolManager 类的直接朋友类有哪些 Employee、CollegeManager</span></span><br><span class="line"><span class="comment">//CollegeEmployee 不是 直接朋友 而是一个陌生类，这样违背了 迪米特法则 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SchoolManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回学校总部的员工</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Employee&gt; list = <span class="keyword">new</span> ArrayList&lt;Employee&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; <span class="comment">//这里我们增加了5个员工到 list</span></span><br><span class="line">            Employee emp = <span class="keyword">new</span> Employee();</span><br><span class="line">            emp.setId(<span class="string">&quot;学校总部员工id= &quot;</span> + i);</span><br><span class="line">            list.add(emp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该方法完成输出学校总部和学院员工信息(id)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printAllEmployee</span><span class="params">(CollegeManager sub)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分析问题</span></span><br><span class="line">        <span class="comment">//1. 将输出学院的员工方法，封装到CollegeManager</span></span><br><span class="line">        sub.printEmployee();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取到学校总部员工</span></span><br><span class="line">        List&lt;Employee&gt; list2 = <span class="keyword">this</span>.getAllEmployee();</span><br><span class="line">        System.out.println(<span class="string">&quot;------------学校总部员工------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Employee e : list2) &#123;</span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="迪米特法则注意事项和细节"><a class="header-anchor" href="#迪米特法则注意事项和细节"></a>迪米特法则注意事项和细节</h3><ol><li>迪米特法则的核心是降低类之间的耦合</li><li>但是注意：由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间(对象间)耦合关系， 并不是要求完全没有依赖关系</li></ol><h2 id="合成复用原则"><a class="header-anchor" href="#合成复用原则"></a>合成复用原则</h2><h3 id="基本介绍-v5"><a class="header-anchor" href="#基本介绍-v5"></a>基本介绍</h3><p>原则是尽量使用合成/聚合的方式，而不是使用继承</p><h2 id="设计原则核心思想"><a class="header-anchor" href="#设计原则核心思想"></a>设计原则核心思想</h2><ol><li>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。</li><li>针对接口编程，而不是针对实现编程。</li><li>为了交互对象之间的松耦合设计而努力</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;设计模式概述&lt;/h1&gt;
&lt;h2 id=&quot;掌握设计模式的层次&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#掌握设计模式的层次&quot;&gt;&lt;/a&gt;掌握设计模式的层次&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;第 1 层：刚开始学编程不久，听说过什么是设计模式&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    <category term="设计模式" scheme="http://halo123.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式 | 面向对象编程" scheme="http://halo123.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>进程与线程</title>
    <link href="http://halo123.top/2021/04/18/OperatingSystem/B_ProcessAndThread/"/>
    <id>http://halo123.top/2021/04/18/OperatingSystem/B_ProcessAndThread/</id>
    <published>2021-04-18T09:19:05.000Z</published>
    <updated>2021-04-30T10:05:39.930Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程的概念和特征"><a class="header-anchor" href="#进程的概念和特征"></a>进程的概念和特征</h2><h3 id="进程的概念"><a class="header-anchor" href="#进程的概念"></a>进程的概念</h3><p>在多道程序环境下，允许多个程序井发执行，此时它们将失去封闭性，并具有间断性及不可再现性的特征。为此引入了进程（ Process ）的概念，以便更好地描述和控制程序的并发执行，实现操作系统的并发性和共享性（最基本的两个特性）。</p><p>为了使参与并发执行的程序（含数据）能独立地运行，必须为之配置一个专门的数据结构，称为<font color="#faa755">进程控制块</font> （Process Control Block，PCB）。</p><p>系统利用PCB来描述进程的基本情况和运行状态，进而控制和管理进程。相应地，由<font color="#faa755">程序段、相关数据段和PCB</font>三部分构成了<font color="#ea66a6">进程映像（进程实体）</font>。</p><p>所谓创建进程，实质上是创建进程映像中的PCB；而撤销进程,实质上是撤销进程的PCB。值得注意的是，进程映像是<font color="#faa755">静态</font>的，进程则是<font color="#faa755">动态</font>的。</p><p>⚠ 注意： PCB 是进程存在的唯一标志!</p><p>从不同的角度，进程可以有不同的定义，比较典型的定义有：</p><ol><li>进程是程序的一次执行过程。</li><li>进程是一个程序及其数据在处理机.上顺序执行时所发生的活动。</li><li>进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。</li></ol><p>引入进程实体的概念后，我们可以把传统操作系统中的进程定义为：“进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。”</p><p>读者要准确理解这里说的系统资源。它指处理机、存储器和其他设备服务于某个进程的“时间”，例如把处理机资源理解为处理机的时间片才是准确的。因为进程是这些资源分配和调度的独立单位，即“时间片”分配的独立单位，这就决定了进程一定是一个动态的、过程性的概念。</p><h3 id="进程的特征"><a class="header-anchor" href="#进程的特征"></a>进程的特征</h3><p>进程是由多道程序的并发执行而引出的，它和程序是两个截然不同的概念。进程的基本特征是对比单个程序的顺序执行提出的，也是对进程管理提出的基本要求。</p><ol><li>动态性。进程是程序的一次执行，它有着创建、活动、暂停、终止等过程，具有一定的生命周期，是动态地产生、变化和消亡的。动态性是进程最基本的特征。</li><li>并发性。指多个进程实体同时存于内存中，能在一段时间内同时运行。并发性是进程的重要特征，同时也是操作系统的重要特征。引入进程的目的就是为了使程序能与其他进程的程序并发执行，以提高资源利用率。</li><li>独立性。指进程实体是一个能<font color="#faa755">独立运行</font>、<font color="#faa755">独立获得资源</font>和<font color="#faa755">独立接受调度</font>的<font color="#faa755">基本单位</font>。凡未建立PCB的程序，都不能作为一个独立的单位参与运行。</li><li>异步性。由于进程的相互制约，使得进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进。异步性会导致执行结果的不可再现性，为此在操作系统中必须配置相应的进程同步机制。</li><li>结构性。每个进程都配置一一PCB对其进行描述。从结构上看，进程实体是由程序段、数据段和进程控制块三部分组成的。</li></ol><h2 id="进程的组织"><a class="header-anchor" href="#进程的组织"></a>进程的组织</h2><p>进程是一个独立的运行单位，也是操作系统进行资源分配和调度的基本单位。它由以下三部分组成，其中最核心的是进程控制块（PCB）。</p><p>进程的管理者(操作系统)所需的数据都在PCB中，程序本身的运行所需的数据在程序段和数据段中。</p><h3 id="进程控制块"><a class="header-anchor" href="#进程控制块"></a>进程控制块</h3><p>进程创建时，操作系统为它新建一个 PCB，该结构之后常驻内存，任意时刻都可以存取，并在进程结束时删除。PCB 是进程实体的一部分，<font color="#FF666">是进程存在的唯一标志</font>。</p><p>进程执行时，系统通过其PCB了解进程的现行状态信息，以便对其进行控制和管理；进程结束时，系统收回其PCB，该进程随之消亡。操作系统通过PCB表来管理和控制进程。</p><p>当操作系统欲调度某进程运行时，要从该进程的PCB中查出其现行状态及优先级；在调度到某进程后，要根据其PCB中所保存的处理机状态信息，设置该进程恢复运行的现场，并根据其PCB中的程序和数据的内存始址，找到其程序和数据:进程在运行过程中，当需要和与之合作的进程实现同步、通信或访问文件时，也需要访问PCB;当进程由于某种原因而暂停运行时，又需将其断点的处理机环境保存在PCB中。可见，在进程的整个生命期中，系统总是通过PCB对进程进行控制的，亦即系统唯有通过进程的PCB才能感知到该进程的存在。</p><p>下表是一个 PCB 的实例。 PCB 主要包括进程描述信息、进程控制和管理信息、资源分配清单和处理机相关信息等。各部分的主要说明如下：</p><table><thead><tr><th>进程描述信息</th><th>进程控制和管理信息</th><th>资源分配清单</th><th>处理机相关信息</th></tr></thead><tbody><tr><td>进程标识符（PID）</td><td>进程当前状态</td><td>代码段指针</td><td>通用寄存器值</td></tr><tr><td>用户标识符（UID)</td><td>进程优先级</td><td>数据段指针</td><td>地址寄存器值</td></tr><tr><td></td><td>代码运行入口地址</td><td>堆栈段指针</td><td>控制寄存器值</td></tr><tr><td></td><td>程序的外存地址</td><td>文件描述符</td><td>标志寄存器值</td></tr><tr><td></td><td>进入内存时间</td><td>键盘</td><td>状态字</td></tr><tr><td></td><td>处理机占用时间</td><td>鼠标</td><td></td></tr><tr><td></td><td>信号量使用</td><td></td><td></td></tr></tbody></table><ol><li>进程描述信息。<ol><li>进程标识符：标志各个进程，每个进程都有一个唯一的标识号 。</li><li>用户标识符：进程归属的用户，用户标识符主要为共享和保护服务。</li></ol></li><li>进程控制和管理信息。<ol><li>进程当前状态：描述进程的状态信息，作为处理机分配调度的依据。</li><li>进程优先级：描述进程抢占处理机的优先级，优先级高的进程可优先获得处理机。</li></ol></li><li>资源分配清单，用于说明有关内存地址空间或虚拟地址空间的状况，所打开文件的列表和所使用的输入/输出设备信息。</li><li>处理机相关信息，主要指处理机中各寄存器的值，当进程被切换时，处理机状态信息都必须保存在相应的 PCB 中，以便在该进程重新执行时，能从断点继续执行。</li></ol><p>在一个系统中，通常存在着许多进程的PCB，有的处于就绪态，有的处于阻塞态，而且阻塞的原因各不相同。为了方便进程的调度和管理，需要将各进程的PCB用适当的方法组织起来。</p><p>目前，常用的组织方式有<font color="#faa755">链接方式</font>和<font color="#faa755">索引方式</font>两种。</p><ol><li>链接方式将同一状态的PCB链接成一个<font color="#faa755">队列</font>，不同状态对应不同的队列，也可把处于阻塞态的进程的PCB，根据其阻塞原因的不同，排成多个阻塞队列。</li><li>索引方式将同一状态的进程组织在一个<font color="#faa755">索引表</font>中，索引表的表项指向相应的PCB，不同状态对应不同的索引表，如就绪索引表和阻塞索引表等。</li></ol><h3 id="程序段"><a class="header-anchor" href="#程序段"></a>程序段</h3><p>程序段就是能被进程调度程序，调度到 CPU 执行的程序代码段。</p><p>注意 ，程序可被多个进程共享，即多个进程可以运行同一个程序。</p><h3 id="数据段"><a class="header-anchor" href="#数据段"></a>数据段</h3><p>一个进程的数据段，可以是进程对应的程序加工处理的原始数据，也可以是程序执行时产生的中间或最终结果 。</p><h2 id="进程的状态与转换"><a class="header-anchor" href="#进程的状态与转换"></a>进程的状态与转换</h2><h3 id="进程的状态"><a class="header-anchor" href="#进程的状态"></a>进程的状态</h3><p>进程在其生命周期内，由于系统中各进程之间的相互制约关系及系统的运行环境的变化，使得进程的状态也在不断地发生变化(一个进程会经历若干不同状态)。通常进程有以下五种状态，前<font color="#faa755">三种是进程的基本状态</font>。</p><ol><li>运行态。进程正在处理机上运行。在单处理机环境下，每个时刻最多只有一个进程处于运行态。</li><li>就绪态。进程获得了除处理机外的一切所需资源，一旦得到处理机，便可立即运行。系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列。</li><li>阻塞态，又称等待态。进程正在等待某一事件而暂停运行，如等待某资源为可用(不包括处理机)或等待输入/输出完成。即使处理机空闲，该进程也不能运行。</li><li>创建态。进程正在被创建，尚未转到就绪态。创建进程通常需要多个步骤：首先申请一个空白的PCB，并向PCB中填写一些控制和管理进程的信息;然后由系统为该进程分配运行时所必需的资源；最后把该进程转入就绪态。</li><li>结束态。进程正从系统中消失，可能是进程正常结束或其他原因中断退出运行。进程需要结束运行时，系统首先必须置该进程为结束态，然后再进一步<font color="#faa755">处理资源释放和回收等工作</font>。</li></ol><p>注意区别就绪态和等待态：</p><ul><li>就绪态是指进程仅缺少处理机，只要获得处理机资源就立即运行</li><li>而等待态是指进程需要其他资源(除了处理机)或等待某一事件。</li></ul><blockquote><p>之所以把处理机和其他资源划分开，是因为在分时系统的时间片轮转机制中，每个进程分到的时间片是若干毫秒。也就是说，进程得到处理机的时间很短且非常频繁，进程在运行过程中实际上是频繁地转换到就绪态的；而其他资源(如外设)的使用和分配或某一事件的发生(如I/O操作的完成)对应的时间相对来说很长，进程转换到等待态的次数也相对较少。这样来看，就绪态和等待态是进程生命周期中两个完全不同的状态，显然需要加以区分。</p></blockquote><h3 id="font-color-33a3dc-进程状态的转换-font"><a class="header-anchor" href="#font-color-33a3dc-进程状态的转换-font"></a><font color="#33a3dc">进程状态的转换</font></h3><p>说明了 5 种进程状态的转换，而三种基本状态之间的转换如下：</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5%20%E7%A7%8D%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E8%BD%AC%E6%8D%A2.png" alt="5种进程状态的转换" style="object-fit: cover; border-radius: 10px; width: 100%;" /><ul><li>就绪态→运行态：处于就绪态的进程被调度后，获得处理机资源（分派处理机时间片），于是进程由就绪态转换为运行态。</li><li>运行态→就绪态：处于运行态的进程在时间片用完后，不得不让出处理机，从而进程由运行态转换为就绪态。此外，在可剥夺的操作系统中，当有更高优先级的进程就绪时，调度程度将正在执行的进程转换为就绪态，让更高优先级的进程执行。</li><li>运行态→阻塞态：进程请求某一资源（如外设）的使用和分配或等待某一事件的发生 (如I/O操作的完成)时，它就从运行态转换为阻塞态。进程以系统调用的形式请求操作系统提供服务，这是一种特殊的、由运行用户态程序调用操作系统内核过程的形式。</li><li>阻塞态→就绪态：进程等待的事件到来时，如I/O 操作结束或中断结束时，中断处理程序必须把相应进程的状态由阻塞态转换为就绪态。</li></ul><p>需要注意的是，一个进程<font color="#faa755">从运行态变成阻塞态是主动的行为</font>，而<font color="#faa755">从阻塞态变成就绪态是被动的</font>行为，需要其他相关进程的协助。</p><h2 id="进程控制"><a class="header-anchor" href="#进程控制"></a>进程控制</h2><p>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销己有进程、实现进程状态转换等功能。</p><p>在操作系统中， 一般把进程控制用的程序段称为原语，原语的特点是执行期间不允许中断（<font color="#faa755">原子操作</font>），它是一个不可分割的基本单位 。原语“关中断指令”和“开中断指令”实现，只允许在核心态下执行的特权指令。</p><p>进程控制会导致进程状态的转换。无论哪个原语，要做的无非三类事情:</p><ol><li>更新PCB中的信息(如修改进程状态标志、将运行环境保存到PCB、从PCB恢复运行环境)<ol><li>所有的进程控制原语一定都会修改进程状态标志</li><li>剥夺当前运行进程的CPU使用权必然需要保存其运行环境</li><li>某进程开始运行前必然要恢复期运行环境</li></ol></li><li>将PCB插入合适的队列</li><li>分配/回收资源</li></ol><h3 id="进程的创建"><a class="header-anchor" href="#进程的创建"></a>进程的创建</h3><p><font color="#faa755">无→创建态→就绪态</font></p><p>允许一个进程创建另一个进程。 此时创建者称为父进程，被创建的进程称为子进程。子进程可以继承父进程所拥有的资源。当子进程被撤销时，应将其从父进程那里获得的资源归还给父进程。此外，在撤销父进程时，必须同时撤销其所有的子进程。</p><p>在操作系统中，终端用户登录系统、作业调度、系统提供服务、用户程序的应用请求等都会引起进程的创建 。</p><ul><li>用户登录：分时系统中，用户登录成功，系统会建立为其建立一个新的进程。</li><li>作业调度：多道批处理系统中，有新的作业放入内存时，会为其建立一个新的进程。</li><li>提供服务：用户向操作系统提出某些请求时，会新建一个进程处理该请求。</li><li>应用请求：由用户进程主动请求创建一个子进程。</li></ul><p>操作系统创建一个新进程的过程如下（<font color="#faa755">创建原语</font>）：</p><ol><li><p>为新进程分配一个唯一的进程标识号，并申请一个空白的PCB(PCB是有限的)。若PCB申请失败，则创建失败。</p></li><li><p>为进程分配资源，为新进程的程序和数据及用户栈分配必要的内存空间(在PCB中体现)。</p><blockquote><p>注意，若资源不足(如内存空间)，则并不是创建失败，而是处于阻塞态，等待内存资源。</p></blockquote></li><li><p>初始化PCB，主要包括初始化标志信息、初始化处理机状态信息和初始化处理机控制信息，以及设置进程的优先级等。</p></li><li><p>若进程就绪队列能够接纳新进程，则将新进程插入就绪队列，等待被调度运行。</p></li></ol><h3 id="进程的终止"><a class="header-anchor" href="#进程的终止"></a>进程的终止</h3><p><font color="#faa755">就绪态/阻塞态/运行态→终止态→无</font></p><p>引起进程终止的事件主要有：</p><ol><li>正常结束，表示进程的任务已完成并准备退出运行。</li><li>异常结束，表示进程在运行时，发生了某种异常事件，使程序无法继续运行，如存储区越界、保护错、非法指令、特权指令错、运行超时、算术运算错、I/O 故障等。</li><li>外界干预，指进程应外界的请求而终止运行，如操作员或操作系统干预、父进程请求和父进程终止。</li></ol><p>操作系统终止进程的过程如下(<font color="#faa755">撤销原语</font>) ：</p><ol><li>根据被终止进程的标识符，检索PCB，从中读出该进程的状态。</li><li>若被终止进程处于执行状态，立即终止该进程的执行，将处理机资源分配给其他进程。</li><li>若该进程还有子孙进程，则应将其所有子孙进程终止。</li><li>将该进程所拥有的全部资源，或归还给其父进程，或归还给操作系统。</li><li>将该PCB从所在队列(链表)中删除。</li></ol><h3 id="进程的阻塞和唤醒"><a class="header-anchor" href="#进程的阻塞和唤醒"></a>进程的阻塞和唤醒</h3><p><font color="#faa755">运行态→阻塞态</font></p><p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作可做等，由系统自动执行<font color="#faa755">阻塞原语(Block)</font>，使自己由运行态变为阻塞态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程(获得CPU)，才可能将其转为阻塞态。阻塞原语的执行过程如下:</p><ol><li>找到将要被阻塞进程的标识号对应的PCB。</li><li>若该进程为运行态，则保护其现场，将其状态转为阻塞态，停止运行。</li><li>把该PCB插入相应事件的等待队列，将处理机资源调度给其他就绪进程。</li></ol><p><font color="#faa755">阻塞态→运行态</font></p><p>当被阻塞进程所期待的事件出现时，如它所启动的I/O操作已完成或其所期待的数据已到达，由有关进程(比如，释放该I/O设备的进程，或提供数据的进程)调用<font color="#faa755">唤醒原语(Wakeup)</font>，将等待该事件的进程唤醒。唤醒原语的执行过程如下:</p><ol><li>在该事件的等待队列中找到相应进程的PCB。</li><li>将其从等待队列中移出，并置其状态为就绪态。</li><li>把该PCB插入就绪队列，等待调度程序调度。</li></ol><p>需要注意的是，Block原语和Wakeup原语是一对作用刚好相反的原语，必须成对使用。Block原语是由被阻塞进程自我调用实现的，而Wakeup原语则是由一个与被唤醒进程合作或被其他相关的进程调用实现的。</p><h3 id="进程切换"><a class="header-anchor" href="#进程切换"></a>进程切换</h3><p><font color="#faa755">运行态→阻塞态/就绪态；就绪态→运行态</font></p><p>对于通常的进程而言，其创建、撤销及要求由系统设备完成的I/O操作，都是利用系统调用而进入内核，再由内核中的相应处理程序予以完成的。进程切换同样是在内核的支持下实现的，因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。进程切换是指处理机从一个进程的运行转到<font color="#faa755">另一个进程</font>上运行，在这个过程中，进程的运行环境产生了实质性的变化。进程切换的过程如下:</p><ol><li>保存处理机上下文，包括程序计数器和其他寄存器。</li><li>更新PCB信息。</li><li>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。</li><li>选择另一个进程执行，并更新其PCB。</li><li>更新内存管理的数据结构。</li><li>恢复处理机上下文。</li></ol><p>注意，进程切换与处理机模式切换是不同的，模式切换时，处理机逻辑上可能还在同一进程中运行。若进程因中断或异常进入核心态运行，执行完后又回到用户态刚被中断的程序运行，则操作系统只需恢复进程进入内核时所保存的CPU现场，而无须改变当前进程的环境信息。但若要切换进程，当前运行进程改变了，则当前进程的环境信息也需要改变。</p><blockquote><p>注意：“调度”和“切换”的区别。调度是指决定资源分配给哪个进程的行为，是一种决策行为；切换是指实际分配的行为，是执行行为。一般来说，先有资源的调度，然后才有进程的切换。</p></blockquote><h2 id="进程的通信"><a class="header-anchor" href="#进程的通信"></a>进程的通信</h2><p>进程通信是指进程之间的信息交换。</p><p>注意，用户进程空间一般都是独立的，进程运行期间一般不能访问其他进程的空间，要想让两个用户进程共享空间，必须通过特殊的系统调用实现，而进程内的线程是自然共享进程空间的。简单理解就是，甲和乙中间有一个大布袋，甲和乙交换物品是通过大布袋进行的，甲把物品放在大布袋里，乙拿走。但乙不能直接到甲的手中拿东西，甲也不能直接到乙的手中拿东西。</p><p>PV操作是低级通信方式，高级通信方式是指以较高的效率传输大量数据的通信方式。高级通信方法主要有以下三类。</p><h3 id="共享存储"><a class="header-anchor" href="#共享存储"></a>共享存储</h3><p>在通信的进程之间存在一块可直接访问的共享空间，通过对这片共享空间进行写/读操作实现进程之间的信息交换。在对共享空间进行写/读操作时，需要使用<font color="#faa755">同步互斥</font>工具(如P操作、V操作)，对共享空间的写/读进行控制。</p><p>共享存储又分为两种：</p><ol><li>低级方式的共享是基于数据结构的共享；</li><li>高级方式的共享则是基于存储区的共享。</li></ol><p>操作系统只负责为通信进程提供可共享使用的存储空间和同步互斥工具，而数据交换则由用户自己安排读/写指令完成。</p><h3 id="管道通信"><a class="header-anchor" href="#管道通信"></a>管道通信</h3><p>管道通信是消息传递的一种特殊方式。所谓“<font color="#ea66a6">管道</font>”，是指用于连接一个读进程和一个写进程以实现它们之间的通信的一个共享文件，又名pipe文件。为了协调双方的通信，管道机制必须提供以下三方面的协调能力：互斥、同步和确定对方的存在。</p><ol><li>管道只能采用<font color="#ea66a6">半双工通信</font>，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道。</li><li>各进程要<font color="#faa755">互斥</font>地访问管道。</li><li>数据以<font color="#faa755">字符流</font>的形式写入管道，当管道<font color="#faa755">写满</font>时，写进程系统调用将被阻塞，等待读进程将数据取走。当读进程将数据<font color="#faa755">全部取走</font>后，管道变空，此时读进程系统调用将被阻塞。</li><li><font color="#faa755">如果没写满，就不允许读。如果没读空，就不允许写</font>。</li><li>数据一旦被读出，就从管道中<font color="#faa755">被抛弃</font>，这就意味着读进程最多只能有一个，否则可能会有读错数据的情况。</li></ol><p>下面以Linux中的管道为例进行说明。在Linux中，管道是一种使用非常频繁的通信机制。从本质上说，管道也是一种文件，但它又和一般的文件有所不同，管道可以克服使用文件进行通信的两个问题，具体表现如下:</p><ol><li>限制管道的大小。实际上，管道是一个固定大小的缓冲区。在Linux中，该缓冲区的大小为<font color="#faa755">4KB</font>，这使得它的大小不像文件那样不加检验地增长。使用单个固定缓冲区也会带来问题，比如在写管道时可能变满，这种情况发生时，随后对管道的write()调用将默认地被阻塞，等待某些数据被读取，以便腾出足够的空间供write()调用写。</li><li>读进程也可能工作得比写进程快。当所有当前进程数据已被读取时，管道变空。当这种情况发生时,一个随后的read()调用将默认地被阻塞，等待某些数据被写入，这解决了read()调用返回文件结束的问题。</li></ol><blockquote><p>注意：从管道读数据是一次性操作，数据一旦被读取， 它就从管道中被抛弃，释放空间以便写更多的数据。管道只能采用半双工通信，即某一时刻只能单向传输。要实现父子进程双方互动通信，需要定义两个管道。</p></blockquote><p>管道可以理解为共享存储的优化和发展，因为在共享存储中，若某进程要访问共享存储空间，则必须没有其他进程在该共享存储空间中进行写操作，否则访问行为就会被阻塞。而管道通信中，存储空间进化成了缓冲区，缓冲区只允许一边写入、另一边读出，因此只要缓冲区中有数据，进程就能从缓冲区中读出，而不必担心会因为其他进程在其中进行写操作而遭到阻塞，因为写进程会先把缓冲区写满，然后才让读进程读，当缓冲区中还有数据时，写进程不会往缓冲区写数据。当然，这也决定了管道通信必然是半双工通信。</p><h3 id="消息传递"><a class="header-anchor" href="#消息传递"></a>消息传递</h3><p>在消息传递系统中，进程间的数据交换是以格式化的消息(Message)为单位的。若通信的进程之间不存在可直接访问的共享空间，则必须利用操作系统提供的消息传递方法实现进程通信。进程通过系统提供的发送消息和接收消息两个原语进行数据交换。</p><ol><li><font color="#faa755">直接通信方式</font>。发送进程直接把消息发送给接收进程，并将它挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中取得消息。</li><li><font color="#faa755">间接通信方式</font>。发送进程把消息发送到某个中间实体，接收进程从中间实体取得消息。这种中间实体一般称为信箱， 这种通信方式又称信箱通信方式。该通信方式广泛应用于计算机网络中，相应的通信系统称为电子邮件系统。</li></ol><p>简单理解就是，甲要告诉乙某些事情，就要写信，然后通过邮差送给乙。直接通信就是邮差把信直接送到乙的手上；间接通信就是乙家门口有一个邮箱，邮差把信放到邮箱里。</p><h2 id="线程概念和多线程模型"><a class="header-anchor" href="#线程概念和多线程模型"></a>线程概念和多线程模型</h2><h3 id="线程的基本概念"><a class="header-anchor" href="#线程的基本概念"></a>线程的基本概念</h3><p>引入进程的目的是为了更好地使多道程序并发执行，提高资源利用率和系统吞吐量；而引入线程的目的则是为了减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。</p><p>线程最直接的理解就是“轻量级进程”，它是一个<font color="#faa755">基本的CPU执行单元</font>，也是<font color="#faa755">程序执行流的最小单元</font>，由线程ID、程序计数器、寄存器集合和堆栈组成。</p><p>线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程，同一进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程在运行中呈现出间断性。线程也有就绪、阻塞和运行三种基本状态。</p><p>引入线程后，进程的内涵发生了改变，进程只作为除CPU外的系统资源的分配单元，而线程则作为处理机的分配单元。由于一个进程内部有多个线程，若线程的切换发生在同一个进程内部，则只需要很少的时空开销。</p><ul><li>资源分配、调度：<ul><li>传统进程机制中，进程是资源分配、调度的基本单位；</li><li>引入线程后，进程是资源分配的基本单位，线程是调度的基本单位</li></ul></li><li>并发性：<ul><li>传统进程机制中，只能进程间并发</li><li>引入线程后，各线程间也能并发，提升了并发度</li></ul></li><li>系统开销：<ul><li>传统的进程间并发，需要切换进程的运行环境，系统开销很大</li><li>线程间并发，如果是同一进程内的线程切换，则不需要切换进程环境，系统开销小。引入线程后，并发所带来的系统开销减小</li></ul></li></ul><h3 id="线程与进程的比较"><a class="header-anchor" href="#线程与进程的比较"></a>线程与进程的比较</h3><p><font color="#FF666">线程是处理机调度的单位，进程是资源分配的单位</font>。</p><ol><li>调度。在传统的操作系统中，拥有资源和独立调度的基本单位都是进程。在引入线程的操作系统中，线程是独立调度的基本单位，进程是拥有资源的基本单位。在同一进程中，线程的切换不会引起进程切换。在不同进程中进行线程切换，如从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换。</li><li>拥有资源。不论是传统操作系统还是设有线程的操作系统，进程都是拥有资源的基本单位，而线程不拥有系统资源(也有一点儿必不可少的资源)，但线程可以访问其隶属进程的系统资源。要知道，若线程也是拥有资源的单位，则切换线程就需要较大的时空开销，线程这个概念的提出就没有意义。</li><li>并发性。在引入线程的操作系统中，不仅进程之间可以并发执行，而且多个线程之间也可以并发执行，从而使操作系统具有更好的并发性，提高了系统的吞吐量。</li><li>系统开销。由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，因此操作系统所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程CPU环境的保存及新调度到进程CPU环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。此外，由于同一进程内的多个线程共享进程的地址空间，因此这些线程之间的同步与通信非常容易实现，甚至无须操作系统的干预。</li><li>地址空间和其他资源(如打开的文件)。进程的地址空间之间互相独立，同一进程的各线程间共享进程的资源，某进程内的线程对于其他进程不可见。</li><li>通信方面。进程间通信(IPC) 需要进程同步和互斥手段的辅助，以保证数据的一致性，而线程间可以直接读/写进程数据段(如全局变量)来进行通信。</li></ol><h3 id="线程的属性"><a class="header-anchor" href="#线程的属性"></a>线程的属性</h3><p>多线程操作系统把线程作为独立运行(或调度)的基本单位，此时的进程已不再是一个基本的可执行实体，但它仍具有与执行相关的状态。所谓进程处于“执行”状态，实际上是指该进程中的某线程正在执行。线程的主要属性如下:</p><ol><li>线程是一个轻型实体，它<font color="#faa755">(几乎)不拥有系统资源</font>，但每个线程都应有<font color="#faa755">一个唯一的标识符</font>和<font color="#faa755">一个线程控制块</font>，线程控制块记录了线程执行的寄存器和栈等现场状态。</li><li>不同的线程可以执行相同的程序，即同一个服务程序被不同的用户调用时，操作系统把它们创建成不同的线程。</li><li>同一进程中的各个线程<font color="#faa755">共享该进程所拥有的资源</font>。</li><li>由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预。</li><li>同一进程中的线程切换，不会引起进程切换</li><li>不同进程中的线程切换，会引起进程切换</li><li>切换同进程内的线程，系统开销很小</li><li>线程是<font color="#faa755">处理机的独立调度单位</font>，多个线程是可以并发执行的。在单CPU的计算机系统中，各线程可交替地占用CPU；在多CPU的计算机系统中，<font color="#faa755">各线程可同时占用不同的CPU</font>，若各个CPU同时为一个进程内的各线程服务，则可缩短进程的处理时间。</li><li>一个线程被创建后，便开始了它的生命周期，直至终止。线程在生命周期内会经历<font color="#faa755">阻塞态</font>、<font color="#faa755">就绪态</font>和<font color="#faa755">运行态</font>等各种状态&lt;变化。</li></ol><p>为什么线程的提出有利于提高系统并发性?可以这样来理解：由于有了线程，线程切换时，有可能会发生进程切换，也有可能不发生进程切换，平均而言每次切换所需的开销就变小了，因此能够让更多的线程参与并发，而不会影响到响应时间等问题。</p><h3 id="线程的实现方式"><a class="header-anchor" href="#线程的实现方式"></a>线程的实现方式</h3><p>线程的实现可以分为两类:用户级线程(User-Level Thread, ULT)和内核级线程(Kernel-Level Thread, KLT)。内核级线程又称内核支持的线程。</p><p>在<font color="#ea66a6">用户级线程</font>中，有关线程管理(线程的创建、撤消和切换等)的所有工作都由应用程序完成，内核意识不到线程的存在。应用程序可以通过使用线程库设计成多线程程序。通常，应用程序从单线程开始，在该线程中开始运行，在其运行的任何时刻，可以通过调用线程库中的派生例程创建一个在相同进程中运行的新线程。图2.5(a)说明了用户级线程的实现方式。</p><p>在<font color="#ea66a6">内核级线程</font>中，线程管理的所有工作由内核完成，应用程序没有进行线程管理的代码，只有一个到内核级线程的编程接口。内核为进程及其内部的每个线程维护上下文信息，调度也在内核基于线程架构的基础上完成。图2.5(b)说明了内核级线程的实现方式。</p><p>有些系统中使用组合方式的多线程实现。线程创建完全在用户空间中完成，线程的调度和同步也在应用程序中进行。一个应用程序中的多个用户级线程被映射到一些(小于等于用户级线程的数目)内核级线程上。图2.5©说明了用户级与内核级的组合实现方式。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%94%A8%E6%88%B7%E7%BA%A7%E5%92%8C%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BA%BF%E7%A8%8B.png" alt="用户级和内核级线程" style="object-fit: cover; border-radius: 10px; width: 100%;" /><p>操作系统只“看得见”内核级线程，因此<font color="#FF666">只有内核级线程才是处理机分配的单位</font>。</p><h3 id="多线程模型"><a class="header-anchor" href="#多线程模型"></a>多线程模型</h3><p>有些系统同时支持用户线程和内核线程，由此产生了不同的多线程模型，即实现用户级线程和内核级线程的连接方式。</p><ol><li>多对一模型。将多个用户级线程映射到一个内核级线程，线程管理在用户空间完成。此模式中，用户级线程对操作系统不可见(即透明)。<ul><li>优点：线程管理是在用户空间进行的，因而效率比较高。</li><li>缺点：一个线程在使用内核服务时被阻塞，整个进程都会被阻塞；多个线程不能并行地运行在多处理机上。</li></ul></li><li>一对一模型。将每个用户级线程映射到一个内核级线程。<ul><li>优点：当一个线程被阻塞后，允许另一个线程继续执行，所以并发能力较强。</li><li>缺点：每创建一个用户级线程都需要创建一个内核级线程与其对应，这样创建线程的开销比较大，会影响到应用程序的性能。</li></ul></li><li>多对多模型。将$n$个用户级线程映射到$m$个内核级线程上，要求$m$≤$n$。<ul><li>特点：多对多模型是多对一模型和一对一模型的折中，既克服了多对一模型并发度不高的缺点，又克服了一对一模型的一个用户进程占用太多内核级线程而开销太大的缺点。此外，还拥有多对一模型和一对一模型各自的优点，可谓集两者之所长。</li></ul></li></ol>]]></content>
    
    
    <summary type="html">描述</summary>
    
    
    
    <category term="操作系统" scheme="http://halo123.top/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://halo123.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
