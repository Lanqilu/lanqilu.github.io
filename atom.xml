<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HALO</title>
  
  <subtitle>HALO</subtitle>
  <link href="http://halo123.top/atom.xml" rel="self"/>
  
  <link href="http://halo123.top/"/>
  <updated>2021-04-25T08:41:51.000Z</updated>
  <id>http://halo123.top/</id>
  
  <author>
    <name>HALO</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Flex布局</title>
    <link href="http://halo123.top/2021/04/24/Web%E5%89%8D%E7%AB%AF/Flex%E5%B8%83%E5%B1%80/"/>
    <id>http://halo123.top/2021/04/24/Web%E5%89%8D%E7%AB%AF/Flex%E5%B8%83%E5%B1%80/</id>
    <published>2021-04-24T15:59:51.000Z</published>
    <updated>2021-04-25T08:41:51.000Z</updated>
    
    <content type="html"><![CDATA[<details ><summary> 参考文章 </summary>              <div class='content'>              <table style="text-align:center;">  <tr>    <td style="border:0;"><div class="tag link"><a class="link-card" title="Flex布局语法教程——阮一峰" href="https://www.runoob.com/w3cnote/flex-grammar.html"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E7%BD%91%E7%AB%99.svg"/></div><div class="right"><p class="text">Flex布局语法教程——阮一峰</p><p class="url">https://www.runoob.com/w3cnote/flex-grammar.html</p></div></a></div></td>  </tr>  <tr>    <td style="border:0;"><div class="tag link"><a class="link-card" title="flex 布局的基本概念——MDN教程" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E7%BD%91%E7%AB%99.svg"/></div><div class="right"><p class="text">flex 布局的基本概念——MDN教程</p><p class="url">https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox</p></div></a></div></td>  </tr></table>              </div>            </details><h2 id="Flex布局是什么"><a class="header-anchor" href="#Flex布局是什么"></a>Flex布局是什么</h2><p>Flex 是 <code>Flexible Box</code> 的缩写，意为“弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>行内元素也可以使用 Flex 布局。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Webkit 内核的浏览器，必须加上<code>-webkit</code>前缀。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-flex; <span class="comment">/* Safari */</span></span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，设为 Flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效。</p><h2 id="基本概念"><a class="header-anchor" href="#基本概念"></a>基本概念</h2><p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称“<strong>容器</strong>”。</p><p>它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称“<strong>项目</strong>”。</p><p><img src="https://www.runoob.com/wp-content/uploads/2015/07/3791e575c48b3698be6a94ae1dbff79d.png" alt="Flex 布局"></p><p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做 main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。</p><p>项目默认沿主轴排列。单个项目占据的主轴空间叫做 main size，占据的交叉轴空间叫做 cross size。</p><h2 id="容器属性"><a class="header-anchor" href="#容器属性"></a>容器属性</h2><p>以下6个属性设置在容器上：</p><ul><li><a href="#flex-direction%E5%B1%9E%E6%80%A7">flex-direction</a></li><li><a href="#flex-wrap%E5%B1%9E%E6%80%A7">flex-wrap</a></li><li><a href="#flex-flow%E5%B1%9E%E6%80%A7">flex-flow</a></li><li><a href="#justify-content%E5%B1%9E%E6%80%A7">justify-content</a></li><li><a href="#align-items%E5%B1%9E%E6%80%A7">align-items</a></li><li><a href="#align-content%E5%B1%9E%E6%80%A7">align-content</a></li></ul><h3 id="flex-direction属性"><a class="header-anchor" href="#flex-direction属性"></a><code>flex-direction</code>属性</h3><p>flex-direction 属性决定主轴的方向（即项目的排列方向）。它可能有4个值：</p><ul><li>column-reverse：主轴为垂直方向，起点在下沿。</li><li>column：主轴为垂直方向，起点在上沿。</li><li>row（默认值）：主轴为水平方向，起点在左端。</li><li>row-reverse：主轴为水平方向，起点在右端。</li></ul><p><img src="https://www.runoob.com/wp-content/uploads/2015/07/0cbe5f8268121114e87d0546e53cda6e.png" alt="flex-direction 属性"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="flex-wrap属性"><a class="header-anchor" href="#flex-wrap属性"></a><code>flex-wrap</code>属性</h3><p>默认情况下，项目都排在一条线（又称“轴线”）上。flex-wrap 属性定义，如果一条轴线排不下，如何换行。</p><p><img src="https://www.runoob.com/wp-content/uploads/2015/07/903d5b7df55779c03f2687a7d4d6bcea.png" alt=""></p><p>它可能取三个值：</p><ul><li>nowrap（默认）：不换行</li><li>wrap：换行，第一行在上方</li><li>wrap-reverse：换行，第一行在下方</li></ul><p><img src="https://www.runoob.com/wp-content/uploads/2015/07/9da1f23965756568b4c6ea7124db7b9a.png" alt="nowrap"><br><img src="https://www.runoob.com/wp-content/uploads/2015/07/3c6b3c8b8fe5e26bca6fb57538cf72d9.jpg" alt="wrap"><br><img src="https://www.runoob.com/wp-content/uploads/2015/07/fb4cf2bab8b6b744b64f6d7a99cd577c.jpg" alt="wrap-reverse"></p><h3 id="flex-flow属性"><a class="header-anchor" href="#flex-flow属性"></a><code>flex-flow</code>属性</h3><p>flex-flow 属性是 flex-directio n属性和 flex-wrap 属性的简写形式，默认值为 row nowrap。</p><h3 id="justify-content属性"><a class="header-anchor" href="#justify-content属性"></a><code>justify-content</code>属性</h3><p>justify-content 属性定义了项目在主轴上的对齐方式。它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</p><ul><li>flex-start（默认值）：左对齐</li><li>flex-end：右对齐</li><li>center： 居中</li><li>space-between：两端对齐，项目之间的间隔都相等。</li><li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li></ul><p><img src="https://www.runoob.com/wp-content/uploads/2015/07/c55dfe8e3422458b50e985552ef13ba5.png" alt="justify-content 属性"></p><h3 id="align-items属性"><a class="header-anchor" href="#align-items属性"></a><code>align-items</code>属性</h3><p>align-items 属性定义项目在交叉轴上如何对齐。它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下：</p><ul><li>flex-start：交叉轴的起点对齐。</li><li>flex-end：交叉轴的终点对齐。</li><li>center：交叉轴的中点对齐。</li><li>baseline: 项目的第一行文字的基线对齐。</li><li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li></ul><p><img src="https://www.runoob.com/wp-content/uploads/2015/07/2b0c39c7e7a80d5a784c8c2ca63cde17.png" alt="align-items 属性"></p><h3 id="align-content属性"><a class="header-anchor" href="#align-content属性"></a><code>align-content</code>属性</h3><p>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。该属性可能取6个值：</p><ul><li>flex-start：与交叉轴的起点对齐。</li><li>flex-end：与交叉轴的终点对齐。</li><li>center：与交叉轴的中点对齐。</li><li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li><li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li><li>stretch（默认值）：轴线占满整个交叉轴。</li></ul><p><img src="https://www.runoob.com/wp-content/uploads/2015/07/f10918ccb8a13247c9d47715a2bd2c33.png" alt="align-content属性"></p><h2 id="项目属性"><a class="header-anchor" href="#项目属性"></a>项目属性</h2><p>以下6个属性设置在项目上：</p><ul><li><a href="#order%E5%B1%9E%E6%80%A7">order</a></li><li><a href="#flex-grow%E5%B1%9E%E6%80%A7">flex-grow</a></li><li><a href="#flex-shrink%E5%B1%9E%E6%80%A7">flex-shrink</a></li><li><a href="#flex-basis%E5%B1%9E%E6%80%A7">flex-basis</a></li><li><a href="#flex-basis%E5%B1%9E%E6%80%A7">flex</a></li><li><a href="#flex-basis%E5%B1%9E%E6%80%A7">align-self</a></li></ul><h3 id="order属性"><a class="header-anchor" href="#order属性"></a><code>order</code>属性</h3><p>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: &lt;integer&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.runoob.com/wp-content/uploads/2015/07/59e399c72daafcfcc20ede36bf32f266.png" alt="order 属性"></p><h3 id="flex-grow属性"><a class="header-anchor" href="#flex-grow属性"></a><code>flex-grow</code>属性</h3><p>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: &lt;number&gt;; <span class="comment">/* default 0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.runoob.com/wp-content/uploads/2015/07/f41c08bb35962ed79e7686f735d6cd78.png" alt="flex-grow 属性"></p><p>如果所有项目的 flex-grow 属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的 flex-grow 属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p><h3 id="flex-shrink属性"><a class="header-anchor" href="#flex-shrink属性"></a><code>flex-shrink</code>属性</h3><p>flex-shrink 属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: &lt;number&gt;; <span class="comment">/* default 1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.runoob.com/wp-content/uploads/2015/07/240d3e960043a729bb3ff5e34987904f.jpg" alt="flex-shrink 属性"></p><p>如果所有项目的 flex-shrink 属性都为1，当空间不足时，都将等比例缩小。如果一个项目的 flex-shrink 属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。</p><h3 id="flex-basis属性"><a class="header-anchor" href="#flex-basis属性"></a><code>flex-basis</code>属性</h3><p>flex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-basis</span>: &lt;length&gt; | auto; <span class="comment">/* default auto */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它可以设为跟 width 或 height 属性一样的值（比如350px），则项目将占据固定空间。</p><h3 id="flex属性"><a class="header-anchor" href="#flex属性"></a><code>flex</code>属性</h3><p>flex 属性是 flex-grow, flex-shrink 和 flex-basis 的简写，默认值为0 1 auto。后两个属性可选。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: none | [ &lt;<span class="string">&#x27;flex-grow&#x27;</span>&gt; &lt;<span class="string">&#x27;flex-shrink&#x27;</span>&gt;? || &lt;<span class="string">&#x27;flex-basis&#x27;</span>&gt; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。</p><p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p><h3 id="align-self属性"><a class="header-anchor" href="#align-self属性"></a><code>align-self</code>属性</h3><p>align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。默认值为 auto，表示继承父元素的align-items 属性，如果没有父元素，则等同于 stretch。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该属性可能取6个值，除了auto，其他都与 align-items 属性完全一致。</p><p><img src="https://www.runoob.com/wp-content/uploads/2015/07/55b19171b8b6b9487d717bf2ecbba6de.png" alt="align-self 属性"></p>]]></content>
    
    
    <summary type="html">Flex布局，可以简便、完整、响应式地实现各种页面布局</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>文本样式测试</title>
    <link href="http://halo123.top/2021/04/24/%E5%8D%9A%E5%AE%A2/%E6%96%87%E6%9C%AC%E6%A0%B7%E5%BC%8F%E6%B5%8B%E8%AF%95/"/>
    <id>http://halo123.top/2021/04/24/%E5%8D%9A%E5%AE%A2/%E6%96%87%E6%9C%AC%E6%A0%B7%E5%BC%8F%E6%B5%8B%E8%AF%95/</id>
    <published>2021-04-24T03:04:20.000Z</published>
    <updated>2021-04-25T12:21:02.849Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>该文章参考自 Akilar 的 《<a href="https://akilar.top/posts/615e2dec/">基于 Butterfly 的外挂标签引入</a>》，通过整理，便于个人相关样式开发</p></blockquote><h2 id="分栏"><a class="header-anchor" href="#分栏"></a>分栏</h2><h3 id="预设选择第一个-默认"><a class="header-anchor" href="#预设选择第一个-默认"></a>预设选择第一个(默认)</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">样式示例</button></li><li class="tab"><button type="button" data-href="#分栏-2">对应源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><div class="tabs" id="默认名称"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#默认名称-1">默认名称 1</button></li><li class="tab"><button type="button" data-href="#默认名称-2">默认名称 2</button></li><li class="tab"><button type="button" data-href="#默认名称-3">默认名称 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="默认名称-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="默认名称-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="默认名称-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs %&#125;</span><br><span class="line">&lt;!-- tab 默认名称 --&gt;</span><br><span class="line">**This is Tab 1.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**This is Tab 2.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**This is Tab 3.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="预设指定选择"><a class="header-anchor" href="#预设指定选择"></a>预设指定选择</h3><div class="tabs" id="预设指定选择"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#预设指定选择-1">样式示例</button></li><li class="tab"><button type="button" data-href="#预设指定选择-2">对应源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="预设指定选择-1"><div class="tabs" id="默认名称"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#默认名称-1">分栏1</button></li><li class="tab active"><button type="button" data-href="#默认名称-2">分栏2</button></li><li class="tab"><button type="button" data-href="#默认名称-3">分栏3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="默认名称-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content active" id="默认名称-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="默认名称-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="预设指定选择-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs 默认名称, 2 %&#125;</span><br><span class="line">&lt;!-- tab 分栏1 --&gt;</span><br><span class="line">**This is Tab 1.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 分栏2 --&gt;</span><br><span class="line">**This is Tab 2.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 分栏3 --&gt;</span><br><span class="line">**This is Tab 3.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="行内文本样式"><a class="header-anchor" href="#行内文本样式"></a>行内文本样式</h2><div class="tabs" id="行内文本样式"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#行内文本样式-1">样式示例</button></li><li class="tab"><button type="button" data-href="#行内文本样式-2">对应源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="行内文本样式-1"><ul><li><u>文本内容</u></li><li><emp>文本内容</emp></li><li><wavy>文本内容</wavy></li><li><del>文本内容</del></li><li><kbd>文本内容</kbd></li><li><psw>文本内容</psw></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="行内文本样式-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% u 文本内容 %&#125;</span><br><span class="line">&#123;% emp 文本内容 %&#125;</span><br><span class="line">&#123;% wavy 文本内容 %&#125;</span><br><span class="line">&#123;% del 文本内容 %&#125;</span><br><span class="line">&#123;% kbd 文本内容 %&#125;</span><br><span class="line">&#123;% psw 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="折叠框"><a class="header-anchor" href="#折叠框"></a>折叠框</h2><div class="tabs" id="折叠框"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#折叠框-1">样式示例</button></li><li class="tab"><button type="button" data-href="#折叠框-2">对应源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="折叠框-1"><details ><summary> 查看图片测试 </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg" alt=""></p>              </div>            </details><details green><summary> 查看代码测试 </summary>              <div class='content'>              <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello,World!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details yellow><summary> 查看列表测试 </summary>              <div class='content'>              <p>TODO: 列表显示有偏移需要修改</p><ul><li>hello</li><li>hello</li></ul>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="折叠框-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;% folding 查看图片测试 %&#125;</span><br><span class="line"></span><br><span class="line">![](https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;volantis-x&#x2F;cdn-wallpaper&#x2F;abstract&#x2F;41F215B9-261F-48B4-80B5-4E86E165259E.jpeg)</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding green, 查看代码测试 %&#125;</span><br><span class="line">假装这里有代码块（代码块没法嵌套代码块）</span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding yellow, 查看列表测试 %&#125;</span><br><span class="line"></span><br><span class="line">- hello</span><br><span class="line">- hello</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><h3 id="simple-样式"><a class="header-anchor" href="#simple-样式"></a>simple 样式</h3><div class="tabs" id="simple-样式"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#simple-样式-1">样式示例</button></li><li class="tab"><button type="button" data-href="#simple-样式-2">对应源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="simple-样式-1"><div class="note simple"><p>默认 提示块标签</p></div><div class="note default simple"><p>default 提示块标签</p></div><div class="note primary simple"><p>primary 提示块标签</p></div><div class="note success simple"><p>success 提示块标签</p></div><div class="note info simple"><p>info 提示块标签</p></div><div class="note warning simple"><p>warning 提示块标签</p></div><div class="note danger simple"><p>danger 提示块标签</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="simple-样式-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note simple %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default simple %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary simple %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success simple %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info simple %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning simple %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger simple %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="modern-样式"><a class="header-anchor" href="#modern-样式"></a>modern 样式</h3><div class="tabs" id="modern-样式"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#modern-样式-1">样式示例</button></li><li class="tab"><button type="button" data-href="#modern-样式-2">对应源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="modern-样式-1"><div class="note modern"><p>默认 提示块标签</p></div><div class="note default modern"><p>default 提示块标签</p></div><div class="note primary modern"><p>primary 提示块标签</p></div><div class="note success modern"><p>success 提示块标签</p></div><div class="note info modern"><p>info 提示块标签</p></div><div class="note warning modern"><p>warning 提示块标签</p></div><div class="note danger modern"><p>danger 提示块标签</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="modern-样式-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note modern %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default modern %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary modern %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success modern %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info modern %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning modern %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger modern %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="flat-样式"><a class="header-anchor" href="#flat-样式"></a>flat 样式</h3><div class="tabs" id="flat-样式"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#flat-样式-1">样式示例</button></li><li class="tab"><button type="button" data-href="#flat-样式-2">对应源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="flat-样式-1"><div class="note flat"><p>默认 提示块标签</p></div><div class="note default flat"><p>default 提示块标签</p></div><div class="note primary flat"><p>primary 提示块标签</p></div><div class="note success flat"><p>success 提示块标签</p></div><div class="note info flat"><p>info 提示块标签</p></div><div class="note warning flat"><p>warning 提示块标签</p></div><div class="note danger flat"><p>danger 提示块标签</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="flat-样式-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note flat %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default flat %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary flat %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success flat %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info flat %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning flat %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger flat %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="disabled-样式"><a class="header-anchor" href="#disabled-样式"></a>disabled 样式</h3><div class="tabs" id="默认名称"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#默认名称-1">样式示例</button></li><li class="tab"><button type="button" data-href="#默认名称-2">对应源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="默认名称-1"><div class="note disabled"><p>默认 提示块标签</p></div><div class="note default disabled"><p>default 提示块标签</p></div><div class="note primary disabled"><p>primary 提示块标签</p></div><div class="note success disabled"><p>success 提示块标签</p></div><div class="note info disabled"><p>info 提示块标签</p></div><div class="note warning disabled"><p>warning 提示块标签</p></div><div class="note danger disabled"><p>danger 提示块标签</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="默认名称-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note disabled %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default disabled %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary disabled %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success disabled %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info disabled %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning disabled %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger disabled %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="no-icon-样式"><a class="header-anchor" href="#no-icon-样式"></a>no-icon 样式</h3><div class="tabs" id="默认名称"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#默认名称-1">样式示例</button></li><li class="tab"><button type="button" data-href="#默认名称-2">对应源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="默认名称-1"><div class="note no-icon flat"><p>默认 提示块标签</p></div><div class="note default no-icon flat"><p>default 提示块标签</p></div><div class="note primary no-icon flat"><p>primary 提示块标签</p></div><div class="note success no-icon flat"><p>success 提示块标签</p></div><div class="note info no-icon flat"><p>info 提示块标签</p></div><div class="note warning no-icon flat"><p>warning 提示块标签</p></div><div class="note danger no-icon flat"><p>danger 提示块标签</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="默认名称-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note no-icon %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default no-icon %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary no-icon %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success no-icon %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info no-icon %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning no-icon %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger no-icon %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="复选列表"><a class="header-anchor" href="#复选列表"></a>复选列表</h2><div class="tabs" id="默认名称"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#默认名称-1">样式示例</button></li><li class="tab"><button type="button" data-href="#默认名称-2">对应源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="默认名称-1"><div class='checkbox'><input type="checkbox" />            <p>纯文本测试</p>            </div><div class='checkbox checked'><input type="checkbox" checked="checked"/>            <p>支持简单的 <a href="https://guides.github.com/features/mastering-markdown/">markdown</a> 语法</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>支持自定义颜色</p>            </div><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>绿色 + 默认选中</p>            </div><div class='checkbox yellow checked'><input type="checkbox" checked="checked"/>            <p>黄色 + 默认选中</p>            </div><div class='checkbox cyan checked'><input type="checkbox" checked="checked"/>            <p>青色 + 默认选中</p>            </div><div class='checkbox blue checked'><input type="checkbox" checked="checked"/>            <p>蓝色 + 默认选中</p>            </div><div class='checkbox plus green checked'><input type="checkbox" checked="checked"/>            <p>增加</p>            </div><div class='checkbox minus yellow checked'><input type="checkbox" checked="checked"/>            <p>减少</p>            </div><div class='checkbox times red checked'><input type="checkbox" checked="checked"/>            <p>叉</p>            </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="默认名称-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% checkbox 纯文本测试 %&#125;</span><br><span class="line">&#123;% checkbox checked, 支持简单的 [markdown](https:&#x2F;&#x2F;guides.github.com&#x2F;features&#x2F;mastering-markdown&#x2F;) 语法 %&#125;</span><br><span class="line">&#123;% checkbox red, 支持自定义颜色 %&#125;</span><br><span class="line">&#123;% checkbox green checked, 绿色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox yellow checked, 黄色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox cyan checked, 青色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox blue checked, 蓝色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox plus green checked, 增加 %&#125;</span><br><span class="line">&#123;% checkbox minus yellow checked, 减少 %&#125;</span><br><span class="line">&#123;% checkbox times red checked, 叉 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="单选列表"><a class="header-anchor" href="#单选列表"></a>单选列表</h2><div class="tabs" id="默认名称"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#默认名称-1">样式示例</button></li><li class="tab"><button type="button" data-href="#默认名称-2">对应源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="默认名称-1"><div class='checkbox'><input type="radio" />            <p>纯文本测试</p>            </div><div class='checkbox checked'><input type="radio" checked="checked"/>            <p>支持简单的 <a href="https://guides.github.com/features/mastering-markdown/">markdown</a> 语法</p>            </div><div class='checkbox red'><input type="radio" />            <p>支持自定义颜色</p>            </div><div class='checkbox green'><input type="radio" />            <p>绿色</p>            </div><div class='checkbox yellow'><input type="radio" />            <p>黄色</p>            </div><div class='checkbox cyan'><input type="radio" />            <p>青色</p>            </div><div class='checkbox blue'><input type="radio" />            <p>蓝色</p>            </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="默认名称-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% radio 纯文本测试 %&#125;</span><br><span class="line">&#123;% radio checked, 支持简单的 [markdown](https:&#x2F;&#x2F;guides.github.com&#x2F;features&#x2F;mastering-markdown&#x2F;) 语法 %&#125;</span><br><span class="line">&#123;% radio red, 支持自定义颜色 %&#125;</span><br><span class="line">&#123;% radio green, 绿色 %&#125;</span><br><span class="line">&#123;% radio yellow, 黄色 %&#125;</span><br><span class="line">&#123;% radio cyan, 青色 %&#125;</span><br><span class="line">&#123;% radio blue, 蓝色 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="时间轴"><a class="header-anchor" href="#时间轴"></a>时间轴</h2><div class="tabs" id="默认名称"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#默认名称-1">样式示例</button></li><li class="tab"><button type="button" data-href="#默认名称-2">对应源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="默认名称-1"><div class="timeline"><div class="timenode"><div class="meta"><p><p>2020-07-24 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases">2.6.6 -&gt; 3.0</a></p></p></div><div class="body"><ol><li>如果有 <code>hexo-lazyload-image</code> 插件，需要删除并重新安装最新版本，设置 <code>lazyload.isSPA: true</code>。</li><li>2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 <code>use_cdn: true</code> 则需要删除。</li><li>2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。</li><li>2.x 版本的置顶 <code>top: true</code> 改为了 <code>pin: true</code>，并且同样适用于 <code>layout: page</code> 的页面。</li><li>如果使用了 <code>hexo-offline</code> 插件，建议卸载，3.0 版本默认开启了 pjax 服务。</li></ol></div></div><div class="timenode"><div class="meta"><p><p>2020-05-15 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.6">2.6.3 -&gt; 2.6.6</a></p></p></div><div class="body"><p>不需要额外处理。</p></div></div><div class="timenode"><div class="meta"><p><p>2020-04-20 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3">2.6.2 -&gt; 2.6.3</a></p></p></div><div class="body"><ol><li>全局搜索 <code>seotitle</code> 并替换为 <code>seo_title</code>。</li><li>group 组件的索引规则有变，使用 group 组件的文章内，<code>group: group_name</code> 对应的组件名必须是 <code>group_name</code>。</li><li>group 组件的列表名优先显示文章的 <code>short_title</code> 其次是 <code>title</code>。</li></ol></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="默认名称-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;% timeline %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% timenode 2020-07-24 [2.6.6 -&gt; 3.0](https:&#x2F;&#x2F;github.com&#x2F;volantis-x&#x2F;hexo-theme-volantis&#x2F;releases) %&#125;</span><br><span class="line"></span><br><span class="line">1. 如果有 &#96;hexo-lazyload-image&#96; 插件，需要删除并重新安装最新版本，设置 &#96;lazyload.isSPA: true&#96;。</span><br><span class="line">2. 2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 &#96;use_cdn: true&#96; 则需要删除。</span><br><span class="line">3. 2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。</span><br><span class="line">4. 2.x 版本的置顶 &#96;top: true&#96; 改为了 &#96;pin: true&#96;，并且同样适用于 &#96;layout: page&#96; 的页面。</span><br><span class="line">5. 如果使用了 &#96;hexo-offline&#96; 插件，建议卸载，3.0 版本默认开启了 pjax 服务。</span><br><span class="line"></span><br><span class="line">&#123;% endtimenode %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% timenode 2020-05-15 [2.6.3 -&gt; 2.6.6](https:&#x2F;&#x2F;github.com&#x2F;volantis-x&#x2F;hexo-theme-volantis&#x2F;releases&#x2F;tag&#x2F;2.6.6) %&#125;</span><br><span class="line"></span><br><span class="line">不需要额外处理。</span><br><span class="line"></span><br><span class="line">&#123;% endtimenode %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% timenode 2020-04-20 [2.6.2 -&gt; 2.6.3](https:&#x2F;&#x2F;github.com&#x2F;volantis-x&#x2F;hexo-theme-volantis&#x2F;releases&#x2F;tag&#x2F;2.6.3) %&#125;</span><br><span class="line"></span><br><span class="line">1. 全局搜索 &#96;seotitle&#96; 并替换为 &#96;seo_title&#96;。</span><br><span class="line">2. group 组件的索引规则有变，使用 group 组件的文章内，&#96;group: group_name&#96; 对应的组件名必须是 &#96;group_name&#96;。</span><br><span class="line">2. group 组件的列表名优先显示文章的 &#96;short_title&#96; 其次是 &#96;title&#96;。</span><br><span class="line"></span><br><span class="line">&#123;% endtimenode %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="链接卡片"><a class="header-anchor" href="#链接卡片"></a>链接卡片</h2><div class="tabs" id="默认名称"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#默认名称-1">样式示例</button></li><li class="tab"><button type="button" data-href="#默认名称-2">对应源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="默认名称-1"><div class="tag link"><a class="link-card" title="糖果屋教程贴" href="https://akilar.top/posts/615e2dec/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/Akilarlxh/akilarlxh.github.io/img/siteicon/favicon.ico"/></div><div class="right"><p class="text">糖果屋教程贴</p><p class="url">https://akilar.top/posts/615e2dec/</p></div></a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="默认名称-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% link 糖果屋教程贴, https:&#x2F;&#x2F;akilar.top&#x2F;posts&#x2F;615e2dec&#x2F;, https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;Akilarlxh&#x2F;akilarlxh.github.io&#x2F;img&#x2F;siteicon&#x2F;favicon.ico %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="github-卡片-ghcard"><a class="header-anchor" href="#github-卡片-ghcard"></a>github 卡片 ghcard</h2><h3 id="用户信息卡片"><a class="header-anchor" href="#用户信息卡片"></a>用户信息卡片</h3><div class="tabs" id="默认名称"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#默认名称-1">样式示例</button></li><li class="tab"><button type="button" data-href="#默认名称-2">对应源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="默认名称-1"><table><thead><tr><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/Lanqilu"><img src="https://github-readme-stats.vercel.app/api/?username=Lanqilu&show_owner=true"/></a></th><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/Lanqilu"><img src="https://github-readme-stats.vercel.app/api/?username=Lanqilu&theme=vue&show_owner=true"/></a></th></tr></thead><tbody><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/Lanqilu"><img src="https://github-readme-stats.vercel.app/api/?username=Lanqilu&theme=buefy&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/Lanqilu"><img src="https://github-readme-stats.vercel.app/api/?username=Lanqilu&theme=solarized-light&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/Lanqilu"><img src="https://github-readme-stats.vercel.app/api/?username=Lanqilu&theme=onedark&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/Lanqilu"><img src="https://github-readme-stats.vercel.app/api/?username=Lanqilu&theme=solarized-dark&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/Lanqilu"><img src="https://github-readme-stats.vercel.app/api/?username=Lanqilu&theme=algolia&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/Lanqilu"><img src="https://github-readme-stats.vercel.app/api/?username=Lanqilu&theme=calm&show_owner=true"/></a></td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="默认名称-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| &#123;% ghcard Lanqilu %&#125; | &#123;% ghcard Lanqilu, theme&#x3D;vue %&#125; |</span><br><span class="line">| -- | -- |</span><br><span class="line">| &#123;% ghcard Lanqilu, theme&#x3D;buefy %&#125; | &#123;% ghcard Lanqilu, theme&#x3D;solarized-light %&#125; |</span><br><span class="line">| &#123;% ghcard Lanqilu, theme&#x3D;onedark %&#125; | &#123;% ghcard Lanqilu, theme&#x3D;solarized-dark %&#125; |</span><br><span class="line">| &#123;% ghcard Lanqilu, theme&#x3D;algolia %&#125; | &#123;% ghcard Lanqilu, theme&#x3D;calm %&#125; |</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="仓库信息卡片"><a class="header-anchor" href="#仓库信息卡片"></a>仓库信息卡片</h3><div class="tabs" id="默认名称"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#默认名称-1">样式示例</button></li><li class="tab"><button type="button" data-href="#默认名称-2">对应源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="默认名称-1"><table><thead><tr><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/Lanqilu/JavaDemo"><img src="https://github-readme-stats.vercel.app/api/pin/?username=Lanqilu&repo=JavaDemo&show_owner=true"/></a></th><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/Lanqilu/JavaDemo"><img src="https://github-readme-stats.vercel.app/api/pin/?username=Lanqilu&repo=JavaDemo&theme=vue&show_owner=true"/></a></th></tr></thead><tbody><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/Lanqilu/JavaDemo"><img src="https://github-readme-stats.vercel.app/api/pin/?username=Lanqilu&repo=JavaDemo&theme=buefy&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/Lanqilu/JavaDemo"><img src="https://github-readme-stats.vercel.app/api/pin/?username=Lanqilu&repo=JavaDemo&theme=solarized-light&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/Lanqilu/JavaDemo"><img src="https://github-readme-stats.vercel.app/api/pin/?username=Lanqilu&repo=JavaDemo&theme=onedark&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/Lanqilu/JavaDemo"><img src="https://github-readme-stats.vercel.app/api/pin/?username=Lanqilu&repo=JavaDemo&theme=solarized-dark&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/Lanqilu/JavaDemo"><img src="https://github-readme-stats.vercel.app/api/pin/?username=Lanqilu&repo=JavaDemo&theme=algolia&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/Lanqilu/JavaDemo"><img src="https://github-readme-stats.vercel.app/api/pin/?username=Lanqilu&repo=JavaDemo&theme=calm&show_owner=true"/></a></td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="默认名称-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| &#123;% ghcard Lanqilu&#x2F;JavaDemo %&#125; | &#123;% ghcard Lanqilu&#x2F;JavaDemo, theme&#x3D;vue %&#125; |</span><br><span class="line">| -- | -- |</span><br><span class="line">| &#123;% ghcard Lanqilu&#x2F;JavaDemo, theme&#x3D;buefy %&#125; | &#123;% ghcard Lanqilu&#x2F;JavaDemo, theme&#x3D;solarized-light %&#125; |</span><br><span class="line">| &#123;% ghcard Lanqilu&#x2F;JavaDemo, theme&#x3D;onedark %&#125; | &#123;% ghcard Lanqilu&#x2F;JavaDemo, theme&#x3D;solarized-dark %&#125; |</span><br><span class="line">| &#123;% ghcard Lanqilu&#x2F;JavaDemo, theme&#x3D;algolia %&#125; | &#123;% ghcard Lanqilu&#x2F;JavaDemo, theme&#x3D;calm %&#125; |</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="音频"><a class="header-anchor" href="#音频"></a>音频</h2><div class="tabs" id="默认名称"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#默认名称-1">样式示例</button></li><li class="tab"><button type="button" data-href="#默认名称-2">对应源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="默认名称-1"><div class="audio"><audio controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/Lumia1020.mp3' type='audio/mp3'>Your browser does not support the audio tag.</audio></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="默认名称-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% audio https:&#x2F;&#x2F;github.com&#x2F;volantis-x&#x2F;volantis-docs&#x2F;releases&#x2F;download&#x2F;assets&#x2F;Lumia1020.mp3 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="视频"><a class="header-anchor" href="#视频"></a>视频</h2><div class="tabs" id="默认名称"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#默认名称-1">样式示例</button></li><li class="tab"><button type="button" data-href="#默认名称-2">对应源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="默认名称-1"><div class="video"><video controls preload><source src='http://onedrive.whl123456.top/video/%E6%88%91%E7%9A%84%E8%A7%86%E9%A2%91%E5%BA%93/%E7%BE%8E%E5%88%B0%E7%AA%92%E6%81%AF%E7%9A%84%E4%BA%AC%E9%98%BF%E5%B0%BC-Lifeisbeautiful.67833543.mp4' type='video/mp4'>Your browser does not support the video tag.</video></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="默认名称-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% video http:&#x2F;&#x2F;onedrive.whl123456.top&#x2F;video&#x2F;%E6%88%91%E7%9A%84%E8%A7%86%E9%A2%91%E5%BA%93&#x2F;%E7%BE%8E%E5%88%B0%E7%AA%92%E6%81%AF%E7%9A%84%E4%BA%AC%E9%98%BF%E5%B0%BC-Lifeisbeautiful.67833543.mp4 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><div class="tabs" id="默认名称"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#默认名称-1">样式示例</button></li><li class="tab"><button type="button" data-href="#默认名称-2">对应源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="默认名称-1"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="默认名称-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
    
    
    <summary type="html">外挂标签测试使用</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>线性代数-行列式</title>
    <link href="http://halo123.top/2021/04/23/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E8%A1%8C%E5%88%97%E5%BC%8F/"/>
    <id>http://halo123.top/2021/04/23/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E8%A1%8C%E5%88%97%E5%BC%8F/</id>
    <published>2021-04-23T03:26:54.000Z</published>
    <updated>2021-04-23T06:52:41.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二阶与三阶行列式"><a class="header-anchor" href="#二阶与三阶行列式"></a>二阶与三阶行列式</h2><p>二阶行列式，记作：</p><div>$$\begin{vmatrix}  a_{1} & a_{2}\\  b_{1} & b_{2}\end{vmatrix}$$</div><p>三阶行列式，记作：</p><div>$$\begin{vmatrix}a_{1} & a_{2} & a_{3}\\b_{1} & b_{2} & b_{3}\\c_{1} & c_{2} & c_{3}\end{vmatrix}$$</div><div>$$\begin{vmatrix} a_{1} & a_{2} & a_{3}\\ b_{1} & b_{2} & b_{3}\\ c_{1} & c_{2} & c_{3}\end{vmatrix}= a_{1}b_{2}c_{3}+a_{2}b_{3}c_{1}+a_{3}b_{1}c_{2}-a_{3}b_{2}c_{1}-a_{1}b_{3}c_{2}$$</div><p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E4%B8%89%E9%98%B6%E8%A1%8C%E5%88%97%E5%BC%8F%E7%9A%84%E8%AE%A1%E7%AE%97.png" alt="三阶行列式的计算"></p><h2 id="全排列和对换"><a class="header-anchor" href="#全排列和对换"></a>全排列和对换</h2><h3 id="排列及其逆序数"><a class="header-anchor" href="#排列及其逆序数"></a>排列及其逆序数</h3><p>把$n$个不同的元素排成一列，叫做这$n$个元素的全排列（也简称<font color="#ea66a6">排列</font>）<br>$n$个不同元素的所有排列的种数，通常用$P_{n}$表示：</p><span>$$P_{n}=n\cdot(n-1)\cdot\dots\cdot3\cdot2\cdot1=n!$$</span><span>$$\left( \sum_{k=1}^n a_k b_k \right)^{\!\!2}\leq   \left( \sum_{k=1}^n a_k^2 \right) \left( \sum_{k=1}^n b_k^2 \right)  $$</span>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;二阶与三阶行列式&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#二阶与三阶行列式&quot;&gt;&lt;/a&gt;二阶与三阶行列式&lt;/h2&gt;
&lt;p&gt;二阶行列式，记作：&lt;/p&gt;
&lt;div&gt;
$$\begin{vmatrix}
  a_{1} &amp; a_{2}\\
  b</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>物理层</title>
    <link href="http://halo123.top/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/02_%E7%89%A9%E7%90%86%E5%B1%82/"/>
    <id>http://halo123.top/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/02_%E7%89%A9%E7%90%86%E5%B1%82/</id>
    <published>2021-04-22T14:22:00.631Z</published>
    <updated>2021-04-22T14:24:39.061Z</updated>
    
    <content type="html"><![CDATA[<h2 id="物理层的基本概念"><a class="header-anchor" href="#物理层的基本概念"></a>物理层的基本概念</h2><p>物理层解决如何在连接各种计算机的传输媒体上<font color="#FF666">传输数据比特流</font>，而不是指具体的传输媒体。</p><p>物理层主要任务:确定与传输媒体<font color="#faa755">接口</font>有关的一些特性(定义标准)</p><ol><li><p>机械特性:定义物理连接的特性，规定物理连接时所采用的规格、接口形状、<font color="#faa755">引线数目</font>、<font color="#faa755">引脚数量</font>和排列情况。</p></li><li><p>电气特性:规定传输二进制位时，线路上信号的<font color="#faa755">电压范围</font>、阻抗匹配、传输<font color="#faa755">速率</font>和<font color="#faa755">距离</font>限制等。</p><blockquote><p>某网络在物理层规定，信号的电平用+10V<sub>+15V表示二进制0，用-10V</sub>-15V表示二进制1，电线长度限于15m以内</p></blockquote></li><li><p>功能特性:指明某条线上出现的某一<font color="#faa755">电平表示何种意义</font>，接口部件的信号线的用途。</p><blockquote><p>描述一个物理层接口引脚处于高电平时的含义时</p></blockquote></li><li><p>规程特性:(过程特性) 定义各条物理线路的工作<font color="#faa755">规程和时序</font>关系。</p></li></ol><h1>通信基础</h1><h2 id="1-基本概念"><a class="header-anchor" href="#1-基本概念"></a>1 基本概念</h2><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B8%E5%9E%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B.png" alt="典型的数据通信模型" style="object-fit: cover; border-radius: 10px; width: 100%;" /><p>通信的目的是<font color="#faa755">传送信息</font>。</p><p><font color="#ea66a6">数据</font>:传送信息的实体，通常是有意义的符号序列。</p><p><font color="#ea66a6">信号</font>:数据的电气或电磁的表现，是数据在传输过程中的<font color="#faa755">存在形式</font>。</p><ul><li>数字信号:代表消息的参数取值是离散的。取值仅允许为有限的几个离散数值的数据(或信号)称为数字数据(或数字信号)。</li><li>模拟信号:代表消息的参数取值是连续的。连续变化的数据(或信号)称为模拟数据(或模拟信号);</li></ul><p><font color="#ea66a6">信源</font>:产生和发送数据的源头。</p><p><font color="#ea66a6">信宿</font>:接收数据的终点。</p><p><font color="#ea66a6">信道</font>:信号的传输媒介。一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接收信道。</p><ul><li><p>信道按传输<font color="#ef5b9c">信号形式</font>的不同可分为传送模拟信号的<font color="#faa755">模拟信道</font>和传送数字信号的<font color="#faa755">数字信道</font>两大类;</p></li><li><p>信道按传输<font color="#ef5b9c">介质</font>的不同可分为<font color="#faa755">无线信道</font>和<font color="#faa755">有线信道</font>。</p></li></ul><p>从通信双方信息的交互方式看，可分为三种基本方式:</p><ol><li><font color="#ea66a6">单工通信</font>。只有一个方向的通信而没有反方向的交互，仅需要<font color="#FF666">一条</font>信道。例如，无线电广播、电视广播就属于这种类型。</li><li><font color="#ea66a6">半双工通信</font>。通信的双方都可以发送或接收信息，但任何一方都<font color="#faa755">不能同时</font>发送和接收信息，此时需要<font color="#FF666">两条</font>信道。(对讲机)</li><li><font color="#ea66a6">全双工通信</font>。通信双方可以同时发送和接收信息，也需要<font color="#FF666">两条</font>信道。</li></ol><p>数据传输方式可分为串行传输和并行传输。</p><ul><li><font color="#ea66a6">串行传输</font>是指一个一个的比特按照时间顺序传输(出于经济上的考虑，远距离通信通常采用串行传输)</li><li><font color="#ea66a6">并行传输</font>是指多个比特通过多条通信信道同时传输。</li></ul><hr><p><font color="#ea66a6">码元</font>是指用一个<font color="#FF666">固定时长</font>的<font color="#FF666">信号波形</font>(数字脉冲)表示一位k进制数字，代表不同离散数值的基本波形，是数字通信中数字信号的计量单位，这个时长内的信号称为<font color="#ea66a6">k进制码元</font>，而该时长称为<font color="#ea66a6">码元宽度</font>。1码元可以携带多个比特的信息量。例如，在使用二进制编码时，只有两种不同的码元: 一种代表0状态，另一种代表1状态。</p><p>速率也称数据率，指的是数据的<font color="#FF666">传输速率</font>，表示单位时间内传输的数据量。可以用<font color="#faa755">码元传输速率</font>和<font color="#faa755">信息传输速率</font>表示。</p><ul><li><font color="#ea66a6">码元传输速率</font>。又称码元速率、波形速率、调制速率、符号速率等，它表示单位时间内数字通信系统所传输的码元个数(也可称为<font color="#faa755">脉冲个数或信号变化的次数</font>)，单位是<font color="#FF666">波特</font>(Baud)。 1波特表示数字通信系统每秒传输一个码元。这里的码元可以是多进制的，也可以是二进制的，但码元速率与进制数无关。<font color="#FF666">1s传输多少个码元</font></li><li><font color="#ea66a6">信息传输速率</font>。又称信息速率、比特率等，它表示单位时间内数字通信系统传输的二进制码元个数(即比特数)，单位是比特/秒(b/s)。<font color="#FF666">1s传输多少个比特</font></li></ul><blockquote><p>关系:<font color="#faa755">若一个码元携带n比特的信息量，则M波特率的码元传输速率所对应的信息传输速率为M×n bit/s</font>。</p></blockquote><p><font color="#ea66a6">带宽</font>:表示在单位时间内从网络中的某一点到另一点所能通过的“<font color="#faa755">最高数据率</font>”，常用来表示网络的通信线路所能传输数据的能力。单位是b/s。</p><h2 id="font-color-d9730d-2-奈奎斯特定理与香农定理-font"><a class="header-anchor" href="#font-color-d9730d-2-奈奎斯特定理与香农定理-font"></a><font color="#d9730d">2 奈奎斯特定理与香农定理</font></h2><p>影响失真程度的影响因素:</p><ol><li>码元传输速率,速率越快失真越严重</li><li>信号传输距离,距离越远失真越严重</li><li>噪声干扰,干扰越多失真越严重</li><li>传输媒体质量,质量越差失真越严重</li></ol><p>具体的信道所能通过的频率范围总是有限的(信道带宽).信号中的许多高频分量往往不能通过信道,否则在传输中会衰减,导致接收端收到的信号波形<font color="#faa755">失去码元之间清晰界限</font>,这种现象称为<font color="#ea66a6">码间串扰</font></p><p><font color="#ea66a6">信道带宽</font>:是信道能通过的最高频率和最低频率之差.</p><h3 id="奈奎斯特定理"><a class="header-anchor" href="#奈奎斯特定理"></a>奈奎斯特定理</h3><p>奈奎斯特(Nyquist)定理又称<font color="#ea66a6">奈氏准则</font>，它指出在理想低通(没有噪声、带宽有限)的信道中，极限码元传输率为2W波特，其中<font color="#faa755">W</font>是理想低通信道的带宽，单位为<font color="#FF666">Hz</font>。若用<font color="#faa755">V</font>表示每个码元离散电平的数目(码元的离散电平数目是指有多少种不同的码元，比如有16种不同的码元，则需要4位二进制位，因此数据传输率是码元传输率的4倍)，则极限数据率为</p><p>理想低通信道下的极限数据传输率= 2W log<sub>2</sub>V (单位为b/s)</p><p>对于奈氏准则，可以得出以下结论:</p><ol><li>在任何信道中，码元传输的速率是有上限的。若传输速率超过此上限，就会出现严重的码间串扰问题(指在接收端收到的信号波形失去了码元之间的清晰界限)，使得接收端不可能完全正确识别码元。</li><li>信道的频带越宽(即通过的信号高频分量越多)，就可用更高的速率进行码元的有效传输。</li><li>奈氏准则给出了码元传输速率的限制，但并未对信息传输速率给出限制，即未对一个码元可以对应多少个二进制位给出限制。</li></ol><p>由于码元的传输速率受奈氏准则的制约，所以要提高数据的传输速率，就必须设法使每个码元携带更多个比特的信息量，此时就需要采用多元制的调制方法。</p><h3 id="香农定理"><a class="header-anchor" href="#香农定理"></a>香农定理</h3><p><font color="#ea66a6">噪声</font>存在于所有的电子设备和通信信道中。由于噪声随机产生，它的瞬时值有时会很大，因此噪声会使接收端对码元的判决产生错误。但是噪声的影响是相对的，若信号较强，那么噪声影响相对较小。因此，<font color="#ea66a6">信噪比</font>就很重要。</p><p>香农(Shannon)定理给出了带宽受限且有高斯白噪声干扰的信道的极限数据传输率，当用此速率进行传输时，可以做到不产生误差。香农定理定义为</p><p><font color="#faa755">信道的极限数据传输率 = Wlog<sub>2</sub>(1+S/N) (单位为b/s)</font></p><p>式中，W为信道的带宽，S为信道所传输信号的平均功率，N为信道内部的高斯噪声功率。S/N为信噪比，即信号的平均功率与噪声的平均功率之比，<font color="#FF666">信噪比 = 10log<sub>10</sub>(S/N) (单位为dB)</font>，例如如当S/N= 10时，信噪比为10dB，而当S/N= 1000时，信噪比为30dB。</p><p>对于香农定理，可以得出以下结论:</p><ol><li>信道的带宽或信道中的信噪比越大，信息的极限传输速率越高。</li><li>对一定的传输带宽和一定的信噪比，信息传输速率的上限是确定的。</li><li>只要信息的传输速率低于信道的极限传输速率，就能找到某种方法来实现无差错的传输。</li><li>香农定理得出的是极限信息传输速率，实际信道能达到的传输速率要比它低不少。</li></ol><p>从香农定理可以看出，若信道带宽W或信噪比SIN没有上限(实际信道当然不可能这样)，则信道的极限信息传输速率也没有上限。</p><p>奈氏准则只考虑了带宽与极限码元传输速率的关系，而香农定理不仅考虑到了带宽，也考虑到了信噪比。这从另一个侧面表明，一个码元对应的二进制位数是有限的。</p><h2 id="3-编码与调制"><a class="header-anchor" href="#3-编码与调制"></a>3 编码与调制</h2><p>信道上传送信号的两种形式:基带信号和宽带信号</p><ul><li><p>基带信号:将数字信号1和0直接用两种不同的电压表示，再送到<font color="#faa755">数字信道</font>上去传输(<font color="#faa755">基带传输</font>)</p><blockquote><p><font color="#ef5b9c">来自信源的信号</font>，像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。基带信号就是发出的直接表达了要传输的信息的信号，比如我们说话的声波就是基带信号。</p></blockquote></li><li><p>宽带信号:将基带信号进行调制后形成的频分复用模拟信号，再传送到<font color="#faa755">模拟信道</font>上去传输(<font color="#faa755">宽带传输</font>)</p><blockquote><p>把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输(即仅在一段频率范围内能够通过信道)。</p></blockquote></li></ul><p>在传输距离较<font color="#faa755">近</font>时，计算机网络采用<font color="#ef5b9c">基带传输</font>方式(近距离衰减小，从而信号内容不易发生变化)</p><p>在传输距离较<font color="#faa755">远</font>时，计算机网络采用<font color="#ef5b9c">宽带传输</font>方式(远距离衰减大，即使信号变化大也能最后过滤出来基带信号)</p><h3 id="数字数据编码为数字信号"><a class="header-anchor" href="#数字数据编码为数字信号"></a>数字数据编码为数字信号</h3><p>数字数据编码用于基带传输中，即在基本不改变数字数据信号频率的情况下，直接传输数字信号。具体用什么样的数字信号表示0及用什么样的数字信号表示1就是所谓的编码。编码的规则有多种，只要能有效地把1和0区分开即可，常用的编码方式有以下几种，如下图所示。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E5%AD%97%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F.png" alt="常用的数字数据编码方式" style="object-fit: cover; border-radius: 10px; width: 80%;" /><ol><li><p>归零编码(RZ)</p><p>在归零编码中用高电平代表1、低电平代表0 (或者相反)，每个时钟周期的中间均跳变到低电平(归零)，接收方根据该跳变调整本方的时钟基准，这就为传输双方提供了自同步机制。由于归零需要占用一部分带宽，因此传输效率受到了一定的影响。</p></li><li><p>非归零编码(NRZ)</p><p>非归零编码与RZ编码的区别是不用归零,一个周期可以全部用来传输数据。但NRZ编码无法传递时钟信号，双方难以同步，因此若想传输高速同步数据，则需要都带有时钟线。</p></li><li><p>反向非归零编码(NRZI)</p><p>反向非归零码与NRZ编码的区别是用信号的翻转代表0、信号保持不变代表1。翻转的信号本身可以作为一种通知机制。这种编码方式集成了前两种编码的优点，既能传输时钟信号，又能尽量不损失系统带宽。USB2.0通信的编码方式就是NRZI编码。</p></li><li><p>曼彻斯特编码(Manchester Encoding)</p><p>曼彻斯特编码将一个码元分成两个相等的间隔，前一个间隔为高电平而后一个间隔为低电平表示码元1;码元0的表示方法则正好相反。当然，也可采用相反的规定。该编码的特点是，在每个码元的中间出现电平跳变，位中间的跳变既作为时钟信号(可用于同步)，又作为数据信号，但它所占的频带宽度是原始基带宽度的两倍。<font color="#faa755">以太网使用的编码方式就是曼彻斯特编码</font>。</p></li><li><p>差分曼彻斯特编码</p><p>差分曼彻斯特编码常用于局域网传输,其规则是,若码元为1,则前半个码元的电平与上一个码元的后半个码元的电平相同;若码元为0，则情形相反。该编码的特点是，在每个码元的中间都有一次电平的跳转，可以实现自同步，且<font color="#faa755">抗干扰性较好</font>。</p></li><li><p>4B/5B编码</p><p>将欲发送数据流的每4位作为一组，然后按照4B/5B编码规则将其转换成相应的5位码。5位码共32种组合，但只采用其中的16种对应16种不同的4位码，其他的16种作为控制码(帧的开始和结束、线路的状态信息等)或保留。</p></li></ol><h3 id="数字数据调制为模拟信号"><a class="header-anchor" href="#数字数据调制为模拟信号"></a>数字数据调制为模拟信号</h3><p>数字数据调制技术在发送端将数字信号转换为模拟信号,而在接收端将模拟信号还原为数字信号，分别对应于调制解调器的调制和解调过程。基本的调制方法有如下几种:</p><ol><li>幅移键控(ASK)。通过改变载波信号的振幅来表示数字信号1和0，而载波的频率和相位都不改变。比较容易实现，但抗干扰能力差。调幅(AM)</li><li>频移键控(FSK)。 通过改变载波信号的频率来表示数字信号1和0，而载波的振幅和相位都不改变。容易实现，抗干扰能力强，目前应用较为广泛。调频(FM)</li><li>相移键控(PSK)。 通过改变载波信号的相位来表示数字信号1和0，而载波的振幅和频率都不改变。它又分为绝对调相和相对调相。调相</li><li>正交振幅调制(QAM)。在频率相同的前提下，将ASK与PSK结合起来，形成叠加信号。设波特率为B,采用m个相位，每个相位有n种振幅，则该QAM技术的数据传输率R为:R= Blog<sub>2</sub>(mn) (单位为b/s).调幅+调相</li></ol><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E5%AD%97%E8%B0%83%E5%88%B6%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F.png" alt="数字调制的三种方式" style="object-fit: cover; border-radius: 10px; width: 900%;" /><h3 id="模拟数据编码为数字信号"><a class="header-anchor" href="#模拟数据编码为数字信号"></a>模拟数据编码为数字信号</h3><p>这种编码方式最典型的例子是常用于对音频信号进行编码的<font color="#ea66a6">脉码调制(PCM)</font>。它主要包括三个步骤，即采样、量化和编码。</p><p><font color="#ea66a6">采样定理</font>:在通信领域，带宽是指信号最高频率与最低频率之差，单位为Hz。因此，将模拟信号转换成数字信号时，假设原始信号中 的最大频率为$f$,那么采样频率$f_{采样}$必须大于等于最大频率$f$的两倍，才能保证采样后的数字信号完整保留原始模拟信号的信息(只需记住结论)。另外，采样定理又称奈奎斯特定理。</p><ol><li><font color="#ea66a6">采样</font>:是指对模拟信号进行周期性扫描，把时间上连续的信号变成时间上离散的信号。根据采样定理，当采样的频率大于等于模拟数据的频带带宽(最高变化频率)的两倍时，所得的离散信号可以无失真地代表被采样的模拟数据。</li><li><font color="#ea66a6">量化</font>:是把采样取得的电平幅值按照一定的分级标度转化为对应的数字值并取整数，这样就把连续的电平幅值转换为了离散的数字量。采样和量化的实质就是分割和转换。</li><li><font color="#ea66a6">编码</font>:是把量化的结果转换为与之对应的二进制编码。</li></ol><h3 id="模拟数据调制为模拟信号"><a class="header-anchor" href="#模拟数据调制为模拟信号"></a>模拟数据调制为模拟信号</h3><p>为了实现传输的有效性，可能需要较高的频率。这种调制方式还可以使用频分复用(FDM)技术，充分利用带宽资源。电话机和本地局交换机采用模拟信号传输模拟数据的编码方式;模拟的声音数据是加载到模拟的载波信号中传输的。</p><h3 id="4-电路交换、报文交换与分组交换"><a class="header-anchor" href="#4-电路交换、报文交换与分组交换"></a>4 电路交换、报文交换与分组交换</h3><p>P40</p><h1>传输介质</h1><p><font color="#ea66a6">传输介质</font>也称传输媒体，它是发送设备和接收设备之间的<font color="#faa755">物理通路</font>。</p><blockquote><p><font color="#faa755">传输媒体并不是物理层</font>。传输媒体在物理层的下面，因为物理层是体系结构的第一层， 因此有时称传输媒体为0层。在传输媒体中传输的是信号，但传输媒体并不知道所传输的信号代表什么意思。但物理层规定了电气特性，因此能够识别所传送的比特流。</p></blockquote><p>传输介质可分为导向传输介质和非导向传输介质。</p><ul><li><font color="#ea66a6">导向传输介质</font>中，电磁波被导向沿着固体媒介(铜线或光纤)传播</li><li><font color="#ea66a6">非导向传输介质</font>可以是空气、真空或海水等</li></ul><h2 id="双绞线、同轴电缆、光纤与无线传输介质"><a class="header-anchor" href="#双绞线、同轴电缆、光纤与无线传输介质"></a>双绞线、同轴电缆、光纤与无线传输介质</h2><h3 id="双绞线"><a class="header-anchor" href="#双绞线"></a>双绞线</h3><p>双绞线是最常用的古老传输介质,它由两根采用一定规则并排绞合的、相互绝缘的铜导线组成。<font color="#faa755">绞合可以减少对相邻导线的电磁干扰</font>。</p><p>为了进一步提高抗电磁干扰能力，可在双绞线的外面再加上一个由<font color="#faa755">金属丝</font>编织成的屏蔽层，这就是屏蔽双绞线(STP)。无屏蔽层的双绞线称为非屏蔽双绞线(UTP)。</p><p>它们的结构如图下所示。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%8F%8C%E7%BB%9E%E7%BA%BF%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="双绞线的结构" style="object-fit: cover; border-radius: 10px; width: 100%;" /><p>双绞线价格便宜，是最常用的传输介质之一，在局域网和传统电话网中普遍使用。</p><p>双绞线的带宽取决于铜线的粗细和传输的距离。</p><p>模拟传输和数字传输都可使用双绞线，其通信距离一般为几千米到数十千米。</p><p>距离太远时，对于<font color="#ef5b9c">模拟传输</font>，要用<font color="#ef5b9c">放大器</font>放大衰减的信号;对于<font color="#faa755">数字传输</font>，要用<font color="#faa755">中继器</font>将失真的信号整形。</p><h3 id="同轴电缆"><a class="header-anchor" href="#同轴电缆"></a>同轴电缆</h3><p>同轴电缆由内导体、绝缘层、网状编织屏蔽层和塑料外层构成，如下图所示。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%90%8C%E8%BD%B4%E7%94%B5%E7%BC%86%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="同轴电缆的结构" style="object-fit: cover; border-radius: 10px; width: 80%;" /><p>按特性阻抗数值的不同，通常将同轴电缆分为两类: 50Ω同轴电缆和75Ω同轴电缆。</p><ul><li>50Ω同轴电缆主要用于传送基带数字信号，又称<font color="#ea66a6">基带同轴电缆</font>，它在局域网中应用广泛;</li><li>75Ω同轴电缆主要用于传送宽带信号，又称<font color="#ea66a6">宽带同轴电缆</font>，主要用于有线电视系统。</li></ul><p>由于外导体屏蔽层的作用，同轴电缆具有良好的抗干扰特性，被广泛用于传输较高速率的数据，其传输距离更远，但价格较双绞线贵。</p><h3 id="光纤"><a class="header-anchor" href="#光纤"></a>光纤</h3><p>光纤通信就是利用光导纤维(简称光纤)传递光脉冲来进行通信。有光脉冲表示1，无光脉冲表示0。可见光的频率约为10<sup>8</sup>MHz，因此光纤通信系统的带宽范围极大。</p><p>光纤在发送端有光源，可以采用发光二极管或半导体激光器，它们在电脉冲作用下能产生出光脉冲;在接收端用光电二极管做成光检测器，在检测到光脉冲时可还原出电脉冲。</p><p>光纤主要由<font color="#faa755">纤心</font>和<font color="#faa755">包层</font>构成，光波通过纤心进行传导，包层较纤心有较低的折射率。当光线从高折射率的介质射向低折射率的介质时，其折射角大于入射角。因此，如果入射角足够大，那么就会出现全反射，即光线碰到包层时会折射回纤心，这个过程不断重复，光也就沿着光纤传输下去。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%89%E6%B3%A2%E5%9C%A8%E7%BA%A4%E5%BF%83%E4%B8%AD%E7%9A%84%E4%BC%A0%E6%92%AD.png" alt="光波在纤心中的传播" style="object-fit: cover; border-radius: 10px; width: 100%;" /><p>只要从纤心中射到纤心表面的光线的入射角大于某个临界角度，就会产生全反射。因此，从不同角，度入射的多束光线可在一条光纤中传输， 这种光纤称为<font color="#ea66a6">多模光纤</font>，多模光纤的光源为<font color="#faa755">发光二极管</font>。光脉冲在多模光纤中传输时会逐渐展宽，造成失真，因此多模光纤只适合于<font color="#faa755">近距离传输</font>。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%A4%9A%E6%A8%A1%E5%85%89%E7%BA%A4.png" alt="多模光纤" style="object-fit: cover; border-radius: 10px; width: 100%;" /><p>光纤的直径减小到仅一个光波长度时，光纤就像一根波导 那样，可使光线一直向前传播， 而不会产生多次反射，这样的光纤就是单模光纤。 单模光纤的纤心很细，直径只有几微米，制造成本较高。同时，单模光纤的光源为<font color="#faa755">定向性很好的激光二极管</font>，因此单模光纤的衰减较小，适合<font color="#faa755">远距离传输</font>。</p><p>光纤的特点:</p><ol><li>传输损耗小，中继距离长，对远距离传输特别经济。</li><li>抗雷电和电磁干扰性能好。</li><li>无串音干扰，保密性好，也不易被窃听或截取数据。</li><li>体积小，重量轻。</li></ol><h3 id="无线传输介质（非导向传播介质）"><a class="header-anchor" href="#无线传输介质（非导向传播介质）"></a>无线传输介质（非导向传播介质）</h3><p>无线通信已广泛应用于移动电话领域，构成蜂窝式无线电话网。随着便携式计算机的出现，以及在军事、野外等特殊场合下移动通信联网的需要，促进了数字化移动通信的发展，现在无线局域网产品的应用已非常普遍。</p><h4 id="无线电波"><a class="header-anchor" href="#无线电波"></a>无线电波</h4><p>无线电波具有<font color="#faa755">较强的穿透能力</font>，可以传输很长的距离，所以它被广泛应用于通信领域，如无线手机通信、计算机网络中的无线局域网(WLAN)等。因为无线电波使信号向所有方向散播,因此有效距离范围内的接收设备无须对准某个方向，就可与无线电波发射者进行通信连接，大大简化了通信连接。这也是无线电传输的最重要优点之一。</p><h4 id="微波、红外线和激光"><a class="header-anchor" href="#微波、红外线和激光"></a>微波、红外线和激光</h4><p>目前高带宽的无线通信主要使用三种技术:微波、红外线和激光。它们都需要发送方和接收方之间存在一条视线(Line-of-sight) 通路，有很强的方向性，都沿直线传播，有时统称这三者为视线介质。不同的是，红外通信和激光通信把要传输的信号分别转换为各自的信号格式，即红外光信号和激光信号，再直接在空间中传播。</p><p>微波通信的频率较高，频段范围也很宽，载波频率通常为2~40GHz,因而通信信道的容量大。例如，一个带宽为2MHz的频段可容纳500条语音线路，若用来传输数字信号，数据率可达数兆比特/秒。与通常的无线电波不同，微波通信的信号是沿直线传播的，因此在地面的传播距离有限，超过一定距离后就要用中继站来接力。</p><p>卫星通信利用地球同步卫星作为中继来转发微波信号，可以克服地面微波通信距离的限制。三颗相隔120°的同步卫星几乎能覆盖整个地球表面，因而基本能实现全球通信。卫星通信的优点是通信容量大、距离远、覆盖广、广播通信和多址通信，缺点是端到端传播时延长，一般为 250~270ms、受气候影响大（强风、太阳黑子爆发、日凌）、误码率较高、成本高。</p><h1>物理层设备</h1><h2 id="中继器"><a class="header-anchor" href="#中继器"></a>中继器</h2><p>诞生原因:由于存在损耗，在线路上传输的信号功率会逐渐衰减，衰减到一定程度时将造成信号失真，因此会导致接收错误。</p><p>中继器的功能:对信号进行<font color="#faa755">再生和还原</font>，对衰减的信号进行放大，保持与原数据相同，以增加信号传输的距离，延长网络的长度。<font color="#FF666">再生数字信号</font></p><p>中继器的两端:</p><ul><li>两端的网络部分是网段，而不是子网，适用于完全相同的两类网络的互连，且两个网段速率要相同。</li><li>中继器只将任何电缆段上的数据发送到另一段电缆上，它仅作用于信号的电气部分，并不管数据中是否有错误数据或不适于网段的数据。</li><li>两端可连相同媒体，也可连不同媒体。</li><li>中继器两端的网段一定要是同一个协议。</li></ul><p>中继器又称转发器，主要功能是将信号整形并放大再转发出去，以消除信号经过一长段电缆后，因噪声或其他原因而造成的失真和衰减，使信号的波形和强度达到所需要的要求，进而扩大网络传输的距离。其原理是信号再生(而非简单地将衰减的信号放大)。中继器有两个端口，数据从一个端口输入，再从另一个端口发出。端口仅作用于信号的电气部分，而不管数据中是否有错误数据或不适于网段的数据。</p><p>中继器是局域网环境下用来扩大网络规模的最简单、最廉价的互联设备。使用中继器连接的几个网段仍然是一个局域网。一般情况下，中继器的两端连接的是相同的媒体，但有的中继器也可以完成不同媒体的转接工作。但由于中继器工作在物理层，因此它不能连接两个具有不同速率的局域网。中继器两端的网络部分是网段，而不是子网。中继器若出现故障，对相邻两个网段的工作都将产生影响。</p><p>从理论上讲，中继器的使用数目是无限的，网络因而也可以无限延长。但事实上这不可能,因为网络标准中对信号的延迟范围做了具体的规定，<font color="#faa755">中继器只能在此规定范围内进行有效的工作，否则会引起网络故障</font>。例如，在采用粗同轴电缆的10BASE5 以太网规范中，互相串联的中继器的个数不能超过4个，而且用4个中继器串联的5段通信介质中只有3段可以挂接计算机，其余两段只能用作扩展通信范围的链路段，不能挂接计算机。这就是所谓的“<font color="#faa755">5-4-3规则</font>”。</p><blockquote><p>注意:放大器和中继器都起放大作用，只不过放大器放大的是模拟信号,原理是将衰减的信号放大，而中继器放大的是数字信号，原理是将衰减的信号整形再生。如果某个网络设备具有存储转发的功能，那么可以认为它能连接两个不同的协议，如果该网络设备没有存储转发功能，那么认为它不能连接两个不同的协议。中继器是没有存储转发功能的，因此它不能连接两个速率不同的网段，中继器两端的网段一定要使用同一个协议。</p></blockquote><h3 id="集线器-多口中继器"><a class="header-anchor" href="#集线器-多口中继器"></a>集线器(多口中继器)</h3><p>集线器(Hub)实质上是一个多端口的中继器，它也工作在物理层。当Hub工作时，一个端口接收到数据信号后，由于信号在从端口到Hub的传输过程中已有衰减，所以Hub便将该信号进行整形放大，使之<font color="#faa755">再生(恢复)到发送时的状态</font>，紧接着转发到其他所有(除输入端口外)处于工作状态的端口。如果同时有两个或多个端口输入，那么输出时会发生冲突，致使这些数据都无效。从Hub的工作方式可以看出，它在网络中只起信号放大和转发作用，目的是扩大网络的传输范围，而<font color="#faa755">不具备信号的定向传送能力</font>，即信号传输的方向是固定的，是一个标准的共享式设备。</p><p>Hub主要使用双绞线组建共享网络，是从服务器连接到桌面的最经济方案。在交换式网络中，Hub直接与交换机相连，将交换机端口的数据送到桌面上。使用Hub组网灵活，它把所有结点的通信集中在以其为中心的结点上，对结点相连的工作站进行集中管理，不让出问题的工作站影响整个网络的正常运行，并且用户的加入和退出也很自由。</p><p>由Hub组成的网络是共享式网络，但逻辑上仍是一个总线网。Hub的每个端口连接的网络部分是同一个网络的不同网段，同时Hub也只能在半双工状态下工作，网络的吞吐率因而受到限制.</p><blockquote><p>注意:多台计算机必须会发生同时通信的情形，因此集线器不能分割冲突域，所有集线器的端口都属于同一个冲突域。集线器在一个时钟周期中只能传输一组信息，如果一台集线器连接的机器数目较多，且多台机器经常需要同时通信，那么将导致信息碰撞，使得集线器的工作效率很差。比如，一个带宽为10Mb/s的集线器上连接了8台计算机，当这8台计算机同时工作时，每台计算机真正所拥有的带宽为10/8Mb/s = 1.25Mb/s.</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;物理层的基本概念&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#物理层的基本概念&quot;&gt;&lt;/a&gt;物理层的基本概念&lt;/h2&gt;
&lt;p&gt;物理层解决如何在连接各种计算机的传输媒体上&lt;font color=&quot;#FF666&quot;&gt;传输数据比特流&lt;/font&gt;，而不</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://halo123.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://halo123.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络体系结构</title>
    <link href="http://halo123.top/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <id>http://halo123.top/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</id>
    <published>2021-04-22T14:09:39.308Z</published>
    <updated>2021-04-22T14:24:51.844Z</updated>
    
    <content type="html"><![CDATA[<h1>计算机网络概述</h1><h2 id="1-计算机网络的概念"><a class="header-anchor" href="#1-计算机网络的概念"></a>1 计算机网络的概念</h2><p>计算机网络：是一个将分散的、具有独立功能的<font color="#FF666">计算机系统</font>，通过<font color="#FF666">通信设备</font>与<font color="#FF666">线路</font>连接起来，由功能完善的<font color="#FF666">软件</font>实现<font color="#FF666">资源共享</font>和<font color="#FF666">信息传递</font>的系统。</p><p>简而言之，计算机网络就是一些<font color="#e03e3e">互联</font>的、<font color="#e03e3e">自治</font>的计算机系统的集合。（互联：互联互通；自治：无主从关系）</p><h2 id="2-计算机网络的功能"><a class="header-anchor" href="#2-计算机网络的功能"></a>2 计算机网络的功能</h2><h3 id="font-color-d9730d-数据通信-font"><a class="header-anchor" href="#font-color-d9730d-数据通信-font"></a><font color="#d9730d">数据通信</font></h3><p>它是计算机网络最基本和最重要的功能，用来实现联网计算机之间的各种信息的传输，并将将分散在不同地理位置的计算机联系起来，进行统一的调配、控制和管理。比如，文件传输、电子邮件等应用，离开了计算机网络将无法实现。</p><h3 id="font-color-d9730d-资源共享-font"><a class="header-anchor" href="#font-color-d9730d-资源共享-font"></a><font color="#d9730d">资源共享</font></h3><p>资源共享可以是软件共享、数据共享，也可以是硬件共享。使计算机网络中的资源互通有无分工协作，从而极大地提高硬件资源、软件资源和数据资源的利用率</p><h3 id="分布式处理"><a class="header-anchor" href="#分布式处理"></a>分布式处理</h3><p>当计算机网络中的某个计算机系统负荷过重时，可以将其处理的某个复杂任务分配给网络中的其他计算机系统，从而利用空闲计算机资源以提高整个系统的利用率。</p><h3 id="提高可靠性"><a class="header-anchor" href="#提高可靠性"></a>提高可靠性</h3><p>计算机网络中的各台计算机可以通过网络互为替代机。</p><h3 id="负载均衡"><a class="header-anchor" href="#负载均衡"></a>负载均衡</h3><p>将工作任务均衡地分配给计算机网络中的各台计算机。</p><hr><p>除以上几大主要功能外，计算机网络还可以实现电子化办公与服务、远程教育、娱乐等功能，满足了社会的需求，方便了人们学习、工作和生活，具有巨大的经济效益。</p><h2 id="3-计算机网络的组成"><a class="header-anchor" href="#3-计算机网络的组成"></a>3 计算机网络的组成</h2><h3 id="组成部分上来看"><a class="header-anchor" href="#组成部分上来看"></a>组成部分上来看</h3><p>一个完整的计算机网络主要由硬件、软件、协议三大部分组成，缺一不可。</p><ul><li>硬件主要由主机（也称端系统）、通信链路（如双绞线、光纤）、交换设备（如路由器、交换机等）和通信处理机（如网卡）等组成。</li><li>软件主要包括各种实现资源共享的软件和方便用户使用的各种工具软件（如网络操作系统、邮件收发程序、FTP程序、聊天程序等）。软件部分多属于应用层。</li><li><font color="#faa755">协议是计算机网络的核心</font>，如同交通规则制约汽车驾驶一样，协议规定了网络传输数据时所遵循的规范。</li></ul><h3 id="font-color-d9730d-从工作方式上看-font"><a class="header-anchor" href="#font-color-d9730d-从工作方式上看-font"></a><font color="#d9730d">从工作方式上看</font></h3><p>计算机网络（这里主要指 internet）可分为边缘部分和核心部分。</p><ul><li>边缘部分由所有连接到因特网上、供用户直接使用的主机组成，用来进行通信（如传输数据、音频或视频）和资源共享；（C/S方式和P2P方式）</li><li>核心部分由大量的网络和连接这些网络的路由器组成，它为边缘部分提供连通性和交换服务。</li></ul><p>图1.1给出了这两部分的示意图。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9B%A0%E7%89%B9%E7%BD%91%E7%9A%84%E6%A0%B8%E5%BF%83%E9%83%A8%E5%88%86%E4%B8%8E%E8%BE%B9%E7%BC%98%E9%83%A8%E5%88%86.png" alt="因特网的核心部分与边缘部分" style="object-fit: cover; border-radius: 10px; width: 80%; " /><h3 id="font-color-d9730d-从功能组成上看-font"><a class="header-anchor" href="#font-color-d9730d-从功能组成上看-font"></a><font color="#d9730d">从功能组成上看</font></h3><p>计算机网络由通信子网和资源子网组成。</p><ul><li>通信子网由各种传输介质、通信设备和相应的网络协议组成，它使网络具有数据传输、交换、控制和存储的能力，实现联网计算机之间的<font color="#faa755">数据通信</font>。</li><li>资源子网是实现<font color="#faa755">资源共享</font>功能的设备及其软件的集合，向网络用户提供共享其他计算机上的硬件资源、软件资源和数据资源的服务。</li></ul><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%B5%84%E6%BA%90%E5%AD%90%E7%BD%91%E5%92%8C%E9%80%9A%E4%BF%A1%E5%AD%90%E7%BD%91.png" alt="资源子网和通信子网" style="object-fit: cover; border-radius: 10px; width: 80%;" /><h2 id="4-计算机网络的分类"><a class="header-anchor" href="#4-计算机网络的分类"></a>4 计算机网络的分类</h2><h3 id="按分布范分类"><a class="header-anchor" href="#按分布范分类"></a>按分布范分类</h3><ul><li>广域网（WAN）。广域网的任务是提供长距离通信，运送主机所发送的数据，其覆盖范围通常为几十千米到几千千米的区域，因而有时也称远程网。广域网是因特网的核心部分。连接广域网的各结点交换机的链路一般都是高速链路，具有较大的通信容量。（交换技术）</li><li>城域网（MAN）。城域网的覆盖范围可以跨越几个街区甚至整个城市，覆盖范围约为5~50km。城域网大多采用以太网技术，因此有时也常并入局域网的范围进行讨论。</li><li>局域网（LAN）。局域网一般用微机或工作站通过高速线路相连，覆盖范围较小，通常为几十米到几千米的区域。局域网在计算机配置的数量上没有太多的限制，少的可以只有两台，多的可达几百台。传统上，局域网使用广播技术，而广域网使用交换技术。（广播技术）</li><li>个人区域网（PAN）。个人区域网是指在个人工作的地方将消费电子设备（如平板电脑、智能手机等）用无线技术连接起来的网络，也常称为无线个人区域网（WPAN），其覆盖的区域直径约为10m。</li></ul><blockquote><p>:bulb: 注意：若中央处理器之间的距离非常近（如仅1m的数量级或甚至更小），则一般就称之为多处理器系统，而不称它为计算机网络。</p></blockquote><h3 id="按使用者分类"><a class="header-anchor" href="#按使用者分类"></a>按使用者分类</h3><ul><li>公用网（ Public network）。指电信公司出资建造的大型网络。“公用”的意思是指所有愿意按电信公司的规定交纳费用的人都可以使用这种网络，因此也称公众网。</li><li>专用网（ Private Network）。指某个部门为满足本单位特殊业务的需要而建造的网络。这种网络不向本单位以外的人提供服务。例如铁路、电力、军队等部门的专用网。</li></ul><h3 id="按交换技术分类"><a class="header-anchor" href="#按交换技术分类"></a>按交换技术分类</h3><p>交换技术是指各台主机之间、各通信设备之间或主机与通信设备之间为交换信息所采用的数据格式和交换装置的方式。</p><p>按交换技术可将网络分为如下几种</p><ul><li><p>电路交换网络。在源结点和目的结点之间建立一条专用的通路用于传送数据，包括建立连接、传输数据和断开连接三个阶段。最典型的电路交换网是传统电话网络。</p><blockquote><p>该类网络的主要特点是整个报文的比特流连续地从源点直达终点，好像是在一条管道中传送。优点是数据直接传送、时延小。缺点是线路利用率低、不能充分利用线路容量、不便于进行差错控制</p></blockquote></li><li><p>报文交换网络。用户数据加上源地址、目的地址、校验码等辅助信息，然后封装成报文整个报文传送到相邻结点，全部存储后，再转发给下一个结点，重复这一过程直到到达目的结点。每个报文可以单独选择到达目的结点的路径。</p><blockquote><p>报文交换网络。用户数据加上源地址、目的地址、校验码等辅助信息，然后封装成报文整个报文传送到相邻结点，全部存储后，再转发给下一个结点，重复这一过程直到到达目的结点。每个报文可以单独选择到达目的结点的路径。</p></blockquote></li><li><p>分组交换网络，也称包交换网络。其原理是将数据分成较短的固定长度的数据块，在每个数据块中加上目的地址、源地址等辅助信息组成分组（包），以存储-转发方式传输其主要特点是单个分组（它只是整个报文的一部分）传送到相邻结点，存储后查找转发表，转发到下一个结点。除具备报文交换网络的优点外，分组交换网络还具有自身的优点：缓冲易于管理；包的平均时延更小，网络占用的平均缓冲区更少；更易于标准化；更适合应用。现在的主流网络基本上都可视为分组交换网络。</p></li></ul><h3 id="按拓扑结构分类"><a class="header-anchor" href="#按拓扑结构分类"></a>按拓扑结构分类</h3><p>网络拓扑结构是指由网中结点（路由器、主机等）与通信线路（网线）之间的几何关系（如总线形、环形）表示的网络结构，主要指通信子网的拓扑结构按网络的拓扑结构，主要分为总线形、星形、环形和网状形网络等。</p><p>星形、总线形和环形网络多用于局域网，网状形网络多用于广域网。</p><h3 id="按传输介质分类"><a class="header-anchor" href="#按传输介质分类"></a>按传输介质分类</h3><p>传输介质可分为有线和无线两大类，因此网络可以分为有线网络和无线网络。有线网络又分为双绞线网络、同轴电缆网络等。无线网络又可分为蓝牙、微波、无线电等类型</p><h3 id="按传输技术分类"><a class="header-anchor" href="#按传输技术分类"></a>按传输技术分类</h3><ul><li>广播式网络。所有联网计算机都共享一个公共通信信道。当一台计算机利用共享通信信道发送报文分组时，所有其他的计算机都会“收听”到这个分组。接收到该分组的计算机将通过检查目的地址来决定是否接收该分组局域网基本上都采用广播式通信技术，广域网中的无线、卫星通信网络也采用广播式通信技术。</li><li>点对点网络。每条物理线路连接一对计算机。如果通信的两台主机之间没有直接连接的线路，那么它们之间的分组传输就要通过中间结点的接收、存储和转发，直至目的结点。</li></ul><p><font color="#e03e3e">是否采用分组存储转发与路由选择机制是点对点式网络与广播式网络的重要区别</font>，广域网基本都属于点对点网络。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E7%AC%AC1%E8%8A%82%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.svg" alt="第一节思维导图" style="object-fit: cover; border-radius: 10px; width: 100%;"/><h2 id="5-计算机网络的标准化工作"><a class="header-anchor" href="#5-计算机网络的标准化工作"></a>5 计算机网络的标准化工作</h2><h3 id="标准的分类"><a class="header-anchor" href="#标准的分类"></a>标准的分类</h3><ol><li>法定标准，由权威机构制定的正式的、合法的标准（OSI）</li><li>事实标准，某些公司的产品在竞争中占据了主流，时间长了，这些产品中的协议和技术就成了标准（TCP/IP）</li></ol><p>计算机网络的标准化对计算机网络的发展和推广起到了极为重要的作用。</p><p>因特网的所有标准都以RFC（ Request For Comments）的形式在因特网上发布，但并非每个RFC都是因特网标准，RFC要上升为因特网的正式标准需经过以下4个阶段</p><ol><li>因特网草案（ Internet Draft）。这个阶段还不是RFC文档。</li><li>建议标准（ Proposed Standard）。从这个阶段开始就成为RFC文档。</li><li>草案标准（ Draft Standard）。</li><li>因特网标准（ Internet Standard）</li></ol><p>此外，还有实验的RFC和提供信息的RFC。各种RFC之间的关系如图1.3所示。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%90%84%E7%A7%8DRFC%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="各种RFC之间的关系" style="object-fit: cover; border-radius: 10px; width: 80%;" /><p>在国际上，负责制定、实施相关网络标准的标准化组织众多，主要有如下几个</p><ul><li>国际标准化组织（ISO）。制定的主要网络标准或规范有OSI参考模型、HDLC等。</li><li>国际电信联盟（ITU）。其前身为国际电话电报咨询委员会（CCITT），其下属机构ITU-T制定了大量有关远程通信的标准。</li><li>国际电气电子工程师协会（IEEE）。世界上最大的专业技术团体，由计算机和工程学专业人士组成。IEEE在通信领域最著名的研究成果是802标准</li></ul><h2 id="6-计算机网络的性能指标"><a class="header-anchor" href="#6-计算机网络的性能指标"></a>6 计算机网络的性能指标</h2><h3 id="速率-Speed"><a class="header-anchor" href="#速率-Speed"></a>速率(Speed)</h3><p>网络中的速率是指连接到计算机网络上的主机在数字信道上传送数据的速率，也称数据率或比特率，单位为b/s（比特秒）（或bit/s，有时也写为bps）。数据率较高时，可用kb/s（k=10<sup>3</sup>​）、Mbs（M=10<sup>5</sup>）或Gbs（G=10<sup>9</sup>）表示。在计算机网络中，通常把最高数据率称为带宽。</p><h3 id="带宽-Bandwidth"><a class="header-anchor" href="#带宽-Bandwidth"></a>带宽(Bandwidth)</h3><p>本来表示通信线路允许通过的信号频带范围，单位是赫兹（Hz）。而在计算机网络中，带宽表示网络的通信线路所能传送数据的能力，是数字信道所能传送的“<font color="#faa755">最高数据率</font>”的同义语，单位是比特/秒（bs）。</p><h3 id="吞吐量-Throughput"><a class="header-anchor" href="#吞吐量-Throughput"></a>吞吐量(Throughput)</h3><p>指<font color="#faa755">单位时间</font>内通过某个网络（或信道、接口）的数据量。吞吐量受网络带宽或网络额定速率的限制。</p><h3 id="时延-Delay"><a class="header-anchor" href="#时延-Delay"></a>时延(Delay)</h3><p>指数据（一个报文或分组）从网络（或链路）的一端传送到另一端所需要的总时间，它由4部分构成：发送时延、传播时延、处理时延和排队时延。</p><ul><li><p>发送时延。结点将分组的所有比特推向（传输）链路所需的时间，即从发送分组的第一个比特算起，到该分组的最后一个比特发送完毕所需的时间，因此也称传输时延。</p><blockquote><p>计算公式为：发送时延=分组长度/信道宽度(发送速率)</p></blockquote></li><li><p>传播时延。电磁波在信道中传播一定的距离需要花费的时间，即一个比特从链路的端传播到另一端所需的时间。</p><blockquote><p>计算公式为：传播时延=信道长度/电磁波在信道上的传播速率</p></blockquote></li><li><p>处理时延。数据在交换结点为存储转发而进行的一些必要的处理所花费的时间。例如，分析分组的首部、从分组中提取数据部分、进行差错检验或査找适当的路由等。</p></li><li><p>排队时延。分组在进入路由器后要先在输入队列中排队等待处理。路由器确定转发端口后，还要在输出队列中排队等待转发，这就产生了排队时延。</p></li></ul><p>因此，数据在网络中经历的总时延就是以上4部分时延之和：<font color="#faa755">总时延=发送时延+传播时延+处理时延+排队时延</font></p><blockquote><p>:bulb: 注意：做题时，排队时延和处理时延一般可忽略不计（除非题目另有说明）。另外，<font color="#faa755">对于高速链路，提高的仅是数据发送速率而非比特在链路上的传播速率</font>。提高数据的发送速率只是为了减少数据的发送时延</p></blockquote><p>类比车站机场安检过程</p><h3 id="时延带宽积"><a class="header-anchor" href="#时延带宽积"></a>时延带宽积</h3><p>指发送端发送的第一个比特即将到达终点时，发送端已经发出了多少个比特，因此又称以比特为单位的链路长度，即<font color="#faa755">时延带宽积=传播时延×信道带宽</font>。 考虑—个代表链路的圆柱形管道，其长度表示链路的传播时延，横截面积表示链路带宽，则时延带宽积表示该管道可以容纳的比特数量。以比特为单位的链路长度，即“某端链路现在有多少比特”（容量）</p><h3 id="往返时延-Round-Trip-Time-RTT"><a class="header-anchor" href="#往返时延-Round-Trip-Time-RTT"></a>往返时延(Round-Trip Time,RTT)</h3><p>指从发送端发送数据开始，到发送端收到来自接收端的确认(接收端收到数据后立即发送确认)，总共经历的时延。在互联网中，往返时延还包括各中间结点的处理时延、排队时延及转发数据时的发送时延。RTT越大，在收到确认之前，可以发送的数据越多。</p><h3 id="信道利用率"><a class="header-anchor" href="#信道利用率"></a>信道利用率</h3><p>指出某一信道有百分之多少的时间是有数据通过的，即<font color="#faa755">信道利用率 = 有数据通过时间/(有+无)数据通过时间</font>。</p><p>网络利用率：信道利用率加权平均值</p><h1>计算机网络体系结构与参考模型</h1><h2 id="1-计算机网络分层结构"><a class="header-anchor" href="#1-计算机网络分层结构"></a>1 计算机网络分层结构</h2><h3 id="为什么要分层"><a class="header-anchor" href="#为什么要分层"></a>为什么要分层</h3><p>对于发送文件前要完成的工作:</p><ol><li>发起通信的计算机必须将数据通信的通路进行激活。</li><li>要告诉网络如何识别目的主机。</li><li>发起通信的计算机要查明目的主机是否开机，并且与网络连接正常。</li><li>发起通信的计算机要弄清楚，对方计算机中文件管理程序是否已经做好准备工作。</li><li>确保差错和意外可以解决。</li></ol><p>两个系统中实体间的通信是一个很复杂的过程，为了降低协议设计和调试过程的复杂性，也为了便于对网络进行研究、实现和维护，促进标准化工作，通常对计算机网络的体系结构以分层的方式进行建模。</p><h3 id="分层的基本原则"><a class="header-anchor" href="#分层的基本原则"></a>分层的基本原则</h3><p>我们把计算机网络的各层及其协议的集合称为<font color="#ea66a6">网络的体系结构</font>(Architecture)。 换言之，计算机网络的体系结构就是这个计算机网络及其所应完成的<font color="#faa755">功能</font>的精确定义，它是计算机网络中的层次、各层的协议及层间接口的集合。需要强调的是，这些功能究竟是用何种硬件或软件完成的，则是一个遵循这种体系结构的实现（Implementation）问题。体系结构是抽象的，而实现是具体的，是真正在运行的计算机硬件和软件。。</p><p>计算机网络的体系结构通常都具有可分层的特性，它将复杂的大系统分成若干较容易实现的层次。分层的基本原则如下：</p><ol><li>每层都实现一种相对<font color="#faa755">独立</font>的功能，降低大系统的复杂度。</li><li>各层之间<font color="#faa755">界面自然清晰</font>，易于理解，相互交流尽可能少。</li><li>各层功能的精确定义独立于具体的实现方法，可以采用<font color="#faa755">最合适的技术</font>来实现。</li><li>保持<font color="#faa755">下层对上层的独立性</font>，<font color="#faa755">上层单向使用下层提供的服务</font>。</li><li>整个分层结构应能促进标准化工作。</li></ol><p>由于分层后各层之间相对独立，灵活性好，因而分层的体系结构易于更新(替换单个模块)，易于调试，易于交流，易于抽象，易于标准化。但<font color="#0f7b6c">层次越多</font>，有些功能在不同层中难免重复出现，产生额外的开销，导致整体运行效率越低。<font color="#0f7b6c">层次越少</font>，就会使每层的协议太复杂。因此，在分层时应考虑层次的清晰程度与运行效率间的折中、层次数量的折中。</p><h3 id="计算机网络层次结构"><a class="header-anchor" href="#计算机网络层次结构"></a>计算机网络层次结构</h3><p>依据一定的规则，将分层后的网络从低层到高层依次称为第1层、第2.层…第n层，通常还为每层取一个特定的名称，如第1层的名称为<font color="#faa755">物理层</font>。</p><p>在计算机网络的分层结构中，第n层中的活动元素通常称为n层实体。具体来说，<font color="#ea66a6">实体</font>指任何可发送或接收信息的硬件或软件进程，通常是一个特定的软件模块。不同机器上的同一层称为对等层，同一层的实体称为<font color="#ea66a6">对等实体</font>。n层实体实现的服务为 n+ 1 层所利用。在这种情况下，n层被称为服务提供者，n+1 层则服务于用户。</p><p>每一层还有自己传送的数据单位，其名称、大小、含义也各有不同。</p><p>在计算机网络体系结构的各个层次中，每个报文都分为两部分：一是<font color="#faa755">数据部分</font>， 即SDU；二是<font color="#faa755">控制信息部分</font>，即PCI，它们共同组成PDU。</p><ul><li><font color="#ea66a6">服务数据单元</font>(SDU)：为完成用户所要求的功能而应传送的数据。第n层的服务数据单元记为n-SDU。</li><li><font color="#ea66a6">协议控制信息</font>(PCI)：控制协议操作的信息。第n层的协议控制信息记为n-PCI。</li><li><font color="#ea66a6">协议数据单元</font>(PDU)：对等层次之间传送的数据单位称为该层的PDU。第n层的协议数据单元记为n-PDU。在实际的网络中，每层的协议数据单元都有一个通俗的名称，如物理层的PDU称为比特，链路层的PDU称为帧，网络层的PDU称为分组，传输层的PDU称为报文。</li></ul><p>在各层间传输数据时，把从第n+1层收到的PDU作为第n层的SDU，加上第n层的PCI，就变成了第n层的PDU，交给第n-1层后作为SDU发送，接收方接收时做相反的处理，因此可知三者的关系为n-SDU + n-PCI= n-PDU= (n-1)-SDU，其变换过程如图1.5所示。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E6%95%B0%E6%8D%AE%E5%8D%95%E5%85%83%E7%9A%84%E8%81%94%E7%B3%BB.png" alt="网络各层数据单元的联系" style="object-fit: cover; border-radius: 10px; width: 80%;" /><p>具体地，层次结构的含义包括以下几方面：</p><ol><li>第 n 层的实体不仅要使用第 n-1 层的服务来实现自身定义的功能，还要向第 n+1 层提供本层的服务，该服务是第 n 层及其下面各层提供的服务总和。</li><li>最低层只提供服务，是整个层次结构的基础；中间各层既是下一层的服务使用者，又是上一层的服务提供者；最高层面向用户提供服务。</li><li>上一层只能通过相邻层间的接口使用下一层的服务，而不能调用其他层的服务；下一层所提供服务的实现细节对上一层透明。</li><li>两台主机通信时，对等层在逻辑上有一条直接信道，表现为不经过下层就把信息传送到对方。</li></ol><h3 id="概念总结"><a class="header-anchor" href="#概念总结"></a>概念总结</h3><ol><li>网络体系结构是从功能上描述计算机网络结构。</li><li>计算机网络体系结构简称网络体系结构是分层结构。</li><li>每层遵循某个/些网络协议以完成本层功能。</li><li>计算机网络体系结构是计算机网络的各层及其协议的集合。</li><li>第 n 层在向 n+1 层提供服务时，此服务不仅包含第 n 层本身的功能，还包含由下层服务提供的功能。</li><li>仅仅在相邻层间有接口，且所提供服务的具体实现细节对上一层完全屏蔽。</li><li>体系结构是抽象的，而实现是指能运行的一些软件和硬件。</li></ol><h2 id="2-计算机网络协议、接口、服务的概念"><a class="header-anchor" href="#2-计算机网络协议、接口、服务的概念"></a>2 计算机网络协议、接口、服务的概念</h2><h3 id="协议"><a class="header-anchor" href="#协议"></a>协议</h3><p>协议，就是规则的集合。在网络中要做到有条不紊地交换数据，就必须遵循一些事先约定好的规则。这些规则明确规定了所交换的数据的格式及有关的同步问题。这些为进行网络中的数据交换而建立的规则、标准或约定称为网络协议（ Network Protocol ），它是控制两个(或多个)对等实体进行通信的规则的集合，是<font color="#e03e3e">水平</font>的。不对等实体之间是没有协议的，比如用 TCP/IP 协议栈通信的两个结点，结点A的传输层和结点 B 的传输层之间存在协议，但结点A的传输层和结点B的网络层之间不存在协议。网络协议也简称为协议。</p><p>协议由语法、语义和同步三部分组成。</p><ul><li>语法：规定了传输数据的格式；</li><li>语义：规定了所要完成的功能，即需要发出何种控制信息、完成何种动作及做出何种应答；</li><li>同步：规定了执行各种操作的条件、时序关系等，即事件实现顺序的详细说明。</li></ul><p>一个完整的协议通常应具有线路管理(建立、释放连接)、差错控制、数据转换等功能。</p><h3 id="接口"><a class="header-anchor" href="#接口"></a>接口</h3><p>接口是同一结点内相邻两层间交换信息的连接点，是一个系统内部的规定。每层只能为紧邻的层次之间定义接口，不能跨层定义接口。在典型的接口上，同一结点相邻两层的实体通过服务访问点（Service Access Point，SAP）进行交互。服务是通过 SAP 提供给上层使用的，第 n 层的 SAP 就是第 n+1 层可以访问第 n 层服务的地方（上层使用下层服务的入口，下层为上层提供的接口）。每个 SAP 都有一个能够标识它的地址。SAP 是一个抽象的概念，它实际上是一个逻辑接口（类似于邮政信箱），但和通常所说的两个设备之间的硬件接口是很不一样的。</p><h3 id="服务"><a class="header-anchor" href="#服务"></a>服务</h3><p>服务是指下层为紧邻的上层提供的功能调用（单向），它是<font color="#e03e3e">垂直</font>的。对等实体在协议的控制下，使得本层能为上一层提供服务，但要实现本层协议还需要使用下一层所提供的服务。</p><p>上层使用下层所提供的服务时必须与下层交换一些命令，这些命令在OSI中称为服务原语。</p><p>OSI将原语划分为4类:</p><ol><li>请求(Request)。 由服务用户发往服务提供者，请求完成某项工作。</li><li>指示( Indication)。由服务提供者发往服务用户，指示用户做某件事情。</li><li>响应(Response)。 由服务用户发往服务提供者，作为对指示的响应。</li><li>证实(Confirmation)。由服务提供者发往服务用户，作为对请求的证实。</li></ol><p>这4类原语用于不同的功能，如建立连接、传输数据和断开连接等。有应答服务包括全部4类原语，而无应答服务则只有请求和指示两类原语。</p><p>一定要注意，协议和服务在概念上是不一样的。</p><ul><li>首先，只有本层协议的实现才能保证向上一层提供服务。本层的服务用户只能看见服务而无法看见下面的协议，即下面的协议对上层的服务用户是透明的。</li><li>其次，协议是“水平的”，即协议是控制对等实体之间通信的规则。但服务是“垂直的”，即服务是由下层通过层间接口向上层提供的。</li><li>另外，并非在一层内完成的全部功能都称为服务，只有那些能够被高一层实体 “看得见”的功能才称为服务。</li></ul><p>协议、接口、服务三者之间的关系如图1.7所示。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%8D%8F%E8%AE%AE%E3%80%81%E6%8E%A5%E5%8F%A3%E3%80%81%E6%9C%8D%E5%8A%A1%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="协议、接口、服务三者之间的关系" style="object-fit: cover; border-radius: 10px; width: 80%;" /><hr><p>计算机网络提供的服务可按以下三种方式分类。</p><h4 id="面向连接服务与无连接服务"><a class="header-anchor" href="#面向连接服务与无连接服务"></a>面向连接服务与无连接服务</h4><p>在面向连接服务中，通信前双方必须先建立连接，分配相应的资源（如缓冲区），以保证通信能正常进行，传输结束后释放连接和所占用的资源。因此这种服务可以分为连接建立、数据传输和连接释放三个阶段。例如TCP就是一种面向连接服务的协议。</p><p>在无连接服务中，通信前双方不需要先建立连接，需要发送数据时可直接发送，把每个带有目的地址的包（报文分组）传送到线路上，由系统选定路线进行传输。这是一种不可靠的服务。这种服务常被描述为“尽最大努力交付”（Best-Effort-Delivery），它并不保证通信的可靠性。例如IP、UDP就是一种无连接服务的协议。</p><h4 id="可靠服务和不可靠服务"><a class="header-anchor" href="#可靠服务和不可靠服务"></a>可靠服务和不可靠服务</h4><p>可靠服务是指网络具有纠错、检错、应答机制，能保证数据正确、可靠地传送到目的地。不可靠服务是指网络只是尽量正确、可靠地传送，而不能保证数据正确、可靠地传送到目的地，是一种尽力而为的服务。</p><p>对于提供不可靠服务的网络，其网络的正确性、可靠性要由应用或用户来保障。例如，用户收到信息后要判断信息的正确性，如果不正确，那么用户要把出错信息报告给信息的发送者，以便发送者采取纠正措施。通过用户的这些措施，可以把不可靠的服务变成可靠的服务。</p><blockquote><p>注意：在一层内完成的全部功能并非都称之为服务，只有那些能够被高一层实体“看得见”的功能才能称为服务。</p></blockquote><h4 id="有应答服务和无应答服务"><a class="header-anchor" href="#有应答服务和无应答服务"></a>有应答服务和无应答服务</h4><p>有应答服务是指接收方在收到数据后向发送方给出相应的应答，该应答由传输系统内部自动实现，而不由用户实现。所发送的应答既可以是肯定应答，也可以是否定应答，通常在接收到的数据有错误时发送否定应答。例如，文件传输服务就是一种有应答服务。</p><p>无应答服务是指接收方收到数据后不自动给出应答。若需要应答，则由高层实现。例如，对于WWW服务，客户端收到服务器发送的页面文件后不给出应答。</p><h2 id="3-ISO-OSI参考模型"><a class="header-anchor" href="#3-ISO-OSI参考模型"></a>3 ISO/OSI参考模型</h2><p>国际标准化组织（ISO）提出的网络体系结构模型，称为开放系统互连参考模型（OSI/ RM）,通常简称为OSI参考模型。OSI有7层，自下而上依次为物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p><ul><li>高三层统称为<font color="#FF666">资源子网</font>，它相当于计算机系统，完成<font color="#faa755">数据的处理</font>等功能。</li><li>传输层承上启下。</li><li>低三层统称为<font color="#FF666">通信子网</font>，它是为了联网而附加的通信设备，完成<font color="#faa755">数据的传输</font>功能；</li></ul><p>OSI的层次结构如图1.8所示。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSI%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" alt="OSI的层次结构" style="object-fit: cover; border-radius: 10px; width: 100%;" /><p>下面详述OSI参考模型各层的功能。</p><h3 id="应用层（Application-Layer）"><a class="header-anchor" href="#应用层（Application-Layer）"></a>应用层（Application Layer）</h3><p>应用层是 OSI 模型的最高层，是用户与网络的界面。应用层为特定类型的网络应用提供访问 OSI 环境的手段。因为用户的实际应用多种多样，这就要求应用层采用不同的应用协议来解决不同类型的应用要求，因此应用层是最复杂的一层，使用的协议也最多。典型的协议有用于文件传：送的FTP、用于电子邮件的SMTP、用于万维网的HTTP等。</p><h3 id="表示层（Presentation-Layer）"><a class="header-anchor" href="#表示层（Presentation-Layer）"></a>表示层（Presentation Layer）</h3><p>表示层主要处理在两个通信系统中交换信息的表示方式。不同机器采用的编码和表示方法不同，使用的数据结构也不同。为了使不同表示方法的数据和信息之间能互相交换，表示层采用抽象的标准方法定义数据结构，并采用标准的编码形式。数据压缩、加密和解密也是表示层可提供的数据表示变换功能。</p><p>功能一：数据格式变换</p><p>功能二：数据加密解密</p><p>功能三：数据压缩和恢复</p><h3 id="会话层（Session-Layer）"><a class="header-anchor" href="#会话层（Session-Layer）"></a>会话层（Session Layer）</h3><p>会话层允许不同主机上的各个进程之间进行会话。会话层利用传输层提供的端到端的服务，向表示层提供它的增值服务。这种服务主要为表示层实体或用户进程建立连接并在连接上有序地传输数据，这就是会话，也称建立同步（SYN）。</p><p>会话层负责管理主机间的会话进程，包括建立、管理及终止进程间的会话。会话层可以使用校验点使通信会话在通信失效时从校验点继续恢复通信，实现数据同步。</p><p>功能一：建立、管理、终止会话</p><p>功能二：使用校验点可使会话在通信失效时从校验点/同步点继续恢复通信，实现数据同步。</p><h3 id="传输层（Transport-Layer）"><a class="header-anchor" href="#传输层（Transport-Layer）"></a>传输层（Transport Layer）</h3><p>传输层也称运输层，传输单位是报文段（TCP） 或用户数据报（UDP），传输层负责主机中两个进程之间的通信，功能是为端到端连接提供可靠的传输服务，为端到端连接提供流量控制、差错控制、服务质量、数据传输管理等服务。</p><p>数据链路层提供的是点到点的通信，传输层提供的是端到端的通信，两者不同。</p><p>通俗地说，点到点可以理解为主机到主机之间的通信，一个点是指一个硬件地址或IP地址，网络中参与通信的主机是通过硬件地址或IP地址标识的；端到端的通信是指运行在不同主机内的两个进程之间的通信，一个进程由一个端口来标识，所以称端到端通信。</p><p>使用传输层的服务，高层用户可以直接进行端到端的数据传输，从而忽略通信子网的存在。通过传输层的屏蔽，高层用户看不到子网的交替和变化。由于一台主机可同时运行多个进程，因此传输层具有复用和分用的功能。复用是指多个应用层进程可同时使用下面传输层的服务，分用是指传输层把收到的信息分别交付给上面应用层中相应的进程。</p><p>传输层的协议有TCP、UDP。</p><p>功能一：可靠传输、不可靠传输</p><p>功能二：差错控制</p><p>功能三：流量控制</p><p>功能四：复用分用</p><h3 id="网络层（Network-Layer）"><a class="header-anchor" href="#网络层（Network-Layer）"></a>网络层（Network Layer）</h3><p>主要任务是把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务。网络层传输单位是数据报。（分组是对数据报进行分割后的结果）</p><p>它关心的是通信子网的运行控制，主要任务是把网络层的协议数据单元（分组）从源端传到目的端，为分组交换网上的不同主机提供通信服务。关键问题是对分组进行路由选择，并实现流量控制、拥塞控制、差错控制和网际互联等功能。</p><p>如图1.10所示，结点A向结点B传输一个分组时，既可经过边a、c、g,也可经过边b、h，有很多条可以选择的路由，而网络层的作用就是根据网络的情况，利用相应的路由算法计算出一条合适的路径,使这个分组可以顺利到达结点B。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%9F%90%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="某网络结构图" style="object-fit: cover; border-radius: 10px; width: 80%;" /><p>流量控制与数据链路层的流量控制含义一样，都是协调 A 的发送速率和 B 的接收速率。</p><p>差错控制是通信两结点之间约定的特定检错规则，如奇偶校验码，接收方根据这个规则检查接收到的分组是否出现差错，如果出现了差错，那么能纠错就纠错，不能纠错就丢弃，确保向上层提交的数据都是无误的。</p><p>如果图1.9中的结点都处于来不及接收分组而要丢弃大量分组的情况，那么网络就处于拥塞状态，拥塞状态使得网络中的两个结点无法正常通信。网络层要采取一定的措施来缓解这种拥塞，这就是拥塞控制。</p><p>因特网是一个很大的互联网，它由大量异构网络通过路由器（Router）相互连接起来。因特网的主要网络层协议是无连接的网际协议（Internet Protocol，IP）和许多路由选择协议，因此因特网的网络层也称网际层或IP层。</p><p>注意，网络层中的“网络”一词并不是我们通常谈及的具体网络，而是在计算机网络体系结构中使用的专有名词。</p><p>网络层的协议有IP、IPX、ICMP、IGMP、ARP、 RARP和OSPF等。</p><p>功能一：路由选择</p><p>功能二：流量控制</p><p>功能三：差错控制</p><p>功能四：拥塞控制</p><h3 id="数据链路层（Data-Link-Layer）"><a class="header-anchor" href="#数据链路层（Data-Link-Layer）"></a>数据链路层（Data Link Layer）</h3><p>数据链路层的传输单位是帧，任务是将网络层传来的IP数据报组装成帧。数据链路层的功能可以概括为成帧、差错控制、流量控制和传输管理等。</p><p>由于外界噪声的干扰，原始的物理连接在传输比特流时可能发生错误。如图1.8 所示，左边结点想向右边结点传输数字0，于是发出了信号A；但传输过程中受到干扰，信号A变成了信号B，而信号B又刚好代表1，右边结点接收到信号B时，就会误以为左边结点传送了数字1，从而发生差错。两个结点之间如果规定了数据链路层协议，那么就可以检测出这些差错，然后把收到的错误信息丢弃，这就是差错控制功能。</p><p>如图1.8 所示，在两个相邻结点之间传送数据时，由于两个结点性能的不同，可能结点A发送数据的速率会比结点B接收数据的速率快,如果不加控制，那么结点B就会丢弃很多来不及接收的正确数据，造成传输线路效率的下降。流量控制可以协调两个结点的速率，使结点A发送数据的速率刚好是结点B可以接收的速率。</p><p>广播式网络在数据链路层还要处理新的问题，即如何控制对共享信道的访问。数据链路层的一个特殊的子层一介 质访问子层，就是专门处理这个问题的。</p><p>典型的数据链路层协议有SDLC、HDLC、PPP、STP和帧中继等。</p><p>功能一：成帧（定义帧的开始和结束）</p><p>功能二：差错控制（帧错、位错）</p><p>功能三：流量控制</p><p>功能四：访问（接入）控制 控制对信道的访问</p><h3 id="物理层（Physical-Layer）"><a class="header-anchor" href="#物理层（Physical-Layer）"></a>物理层（Physical Layer）</h3><p>物理层的传输单位是比特，任务是透明的传输比特流，功能是在物理媒体上为数据端设备透明地传输原始比特流。</p><p>透明传输：指不管所传数据是什么样的比特组合都应当能够在链路上传送。</p><p>物理层主要定义数据终端设备（DTE）和数据通信设备（DCE）的物理与逻辑连接方法，所以物理层协议也称物理层接口标准。由于在通信技术的早期阶段，通信规则称为规程（Procedure），因此物理层协议也称物理层规程。</p><p>物理层接口标准很多，如 EIA-232C、EIA/TIA RS-449、CCITT 的 X.21 等。在计算机网络的复习过程中，不要忽略对各层传输协议的记忆，到了后期，读者对链路层、网络层、传输层和应用层的协议会比较熟悉，但往往容易忽视物理层的协议。</p><p>物理层主要研究以下内容:</p><p>① 通信链路与通信结点的连接需要一些电路接口，物理层规定了这些接口的一些参数，如机械形状和尺寸、交换电路的数量和排列等，例如，笔记本电脑上的网线接口，就是物理层规定的内容之一。</p><p>② 物理层也规定了通信链路上传输的信号的意义和电气特征。例如物理层规定信号A代表数字0，那么当结点要传输数字0时，就会发出信号A，当结点接收到信号A时，就知道自己接收到的实际上是数字0。</p><p>注意，传输信息所利用的一些物理媒体，如双绞线、光缆、无线信道等，并不在物理层协议之内而在物理层协议下面。因此，有人把物理媒体当作第0层。</p><p>功能一：定义接口特性</p><p>功能二：定义传输模式（单工、半双工、双工）</p><p>功能三：定义传输速率</p><p>功能四：比特同步</p><p>功能五：比特编码</p><h2 id="4-TCP-IP模型与OSI参考模型的比较"><a class="header-anchor" href="#4-TCP-IP模型与OSI参考模型的比较"></a>4 TCP/IP模型与OSI参考模型的比较</h2><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%8D%E5%90%8C%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B.png" alt="不同参考模型" style="object-fit: cover; border-radius: 10px; width: 100%;" /><p>OSI参考模型与TCP/IP参考模型相同点</p><ol><li>首先，二者都采取分层的体系结构，将庞大且复杂的问题划分为若干较容易处理的、范围较小的问题，而且分层的功能也大体相似。</li><li>其次，二者都是基于独立的协议栈的概念。</li><li>最后，二者都可以解决异构网络的互联，实现世界上不同厂家生产的计算机之间的通信。</li></ol><p>OSI参考模型与TCP/IP参考模型不同点</p><ol><li>OSI参考模型的最大贡献就是精确定义了三个主要概念：服务、协议和接口，这与现代的面向对象程序设计思想非常吻合。而 TCP/IP 模型在这三个概念上却没有明确区分，不符合软件工程的思想。</li><li>OSI参考模型产生在协议发明之前，没有偏向于任何特定的协议，通用性良好。但设计者在协议方面没有太多经验，不知道把哪些功能放到哪一层更好。TCP/IP模型正好相反，首先出现的是协议，模型实际上是对已有协议的描述，因此不会出现协议不能匹配模型的情况，但该模型不适合于任何其他非TCP/IP的协议栈。</li><li>TCP/IP 模型在设计之初就考虑到了多种异构网的互联问题，并将网际协议（ IP ）作为一个单独的重要层次。OSI 参考模型最初只考虑到用一种标准的公用数据网将各种不同的系统互联。OSI参考模型认识到网际协议 IP 的重要性后，只好在网络层中划分出一个子层来完成类似于 TCP/IP 模型中的 IP 的功能。</li><li>OSI参考模型在网络层支持无连接和面向连接的通信，但在传输层仅有面向连接的通信。而 TCP/IP 模型认为可靠性是端到端的问题，因此它在网际层仅有一种无连接的通信模式，但传输层支持无连接和面向连接两种模式。这个不同点常常作为考查点。</li></ol><blockquote><p>面向连接分为三个阶段，第一是建立连接，在此阶段，发出一个建立连接的请求。只有在连接成功建立之后，才能开始数据传输，这是第二阶段。接着，当数据传输完毕，必须释放连接。而面向无连接没有这么多阶段，它直接进行数据传输。</p></blockquote><p>无连接和面向连接</p><table><thead><tr><th>模型</th><th>ISO/OSI参考模型</th><th>TCP/IP模型</th></tr></thead><tbody><tr><td>网络层</td><td>无连接+面向连接</td><td>无连接</td></tr><tr><td>传输层</td><td>面向连接</td><td>无连接+面向连接</td></tr></tbody></table><p>无论是 OSI 参考模型还是 TCP/IP 模型，都不是完美的，对二者的讨论和批评都很多。OSI 参考模型的设计者从工作的开始，就试图建立一个全世界的计算机网络都要遵循的统一标准。 从技术角度来看，他们希望追求一种完美的理想状态，这也导致基于 OSI 参考模型的软件效率极低。OSI参考模型缺乏市场与商业动力，结构复杂，实现周期长，运行效率低，这是它未能达到预期目标的重要原因</p><p>学习计算机网络时，我们往往采取折中的办法，即综合 OSI 和 TCP/IP 的优点，采用一种如图1.13所示的只有五层协议的体系结构，即我们所熟知的物理层、数据链路层、网络层、传输层和应用层。本书也采用这种体系结构进行讨论。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E7%9A%84%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E5%9E%8B.png" alt="图1.13 网络的五层协议结构模型" style="object-fit: cover; border-radius: 10px; width: 100%;" /><p>最后简单介绍使用通信协议栈进行通信的结点的数据传输过程。每个协议栈的最顶端都是一个面向用户的接口，下面各层是为通信服务的协议。用户传输一个数据报时，通常给出用户能够理解的自然语言，然后通过应用层，将自然语言会转化为用于通信的通信数据。通信数据到达传输层，作为传输层的数据部分（传输层SDU），加上传输层的控制信息（传输层PCI），组成传输层的 PDU ,然后交到网络层，传输层的PDU下放到网络层后，就成为网络层的SDU，然后加上网络层的 PCI ，又组成了网络层的PDU，下放到数据链路层，就这样层层下放，层层包裹，最后形成的数据报通过通信线路传输，到达接收方结点协议栈，接收方再逆向地逐层把“包裹”拆开，然后把收到的数据提交给用户，如下图所示。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E6%A0%88%E7%9A%84%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B%E7%A4%BA%E4%BE%8B.png" alt="图1.14 通信协议栈的通信过程示例" style="object-fit: cover; border-radius: 10px; width: 100%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;计算机网络概述&lt;/h1&gt;
&lt;h2 id=&quot;1-计算机网络的概念&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#1-计算机网络的概念&quot;&gt;&lt;/a&gt;1 计算机网络的概念&lt;/h2&gt;
&lt;p&gt;计算机网络：是一个将分散的、具有独立功能的&lt;font color=&quot;#F</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://halo123.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://halo123.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>考研资料收集</title>
    <link href="http://halo123.top/2021/04/21/%E8%80%83%E7%A0%94/%E8%80%83%E7%A0%94%E8%B5%84%E6%96%99%E6%94%B6%E9%9B%86/"/>
    <id>http://halo123.top/2021/04/21/%E8%80%83%E7%A0%94/%E8%80%83%E7%A0%94%E8%B5%84%E6%96%99%E6%94%B6%E9%9B%86/</id>
    <published>2021-04-21T09:06:12.000Z</published>
    <updated>2021-04-21T13:40:07.000Z</updated>
    
    <content type="html"><![CDATA[<Script Language="JavaScript"> 　　var timedate= new Date("December 25,2021"); 　　var times="研究生考试"; 　　var now = new Date(); 　　var date = timedate.getTime() - now.getTime(); 　　var time = Math.floor(date / (1000 * 60 * 60 * 24)); 　　if (time >= 0) ; document.write("<div title='初试时间预测为2021年12月24日-25日，12月倒数第二周的周六周日，具体时间以教育局公布为准'><font color=#343a40>现在离2022年"+times+"还有: <font color=#dc3545><b>"+time +"</b></font> 天</font></div>"); </Script> <h2 id="📚考研资料"><a class="header-anchor" href="#📚考研资料"></a>📚考研资料</h2><p><a href="https://mp.weixin.qq.com/s/5TNZQG0QBWf1IrOd8L9NGA">好好考研公众号，网课推荐</a><br><a href="https://note.youdao.com/ynoteshare1/index.html?id=fcce8b92cbcedbcbe9b34e27c2275ea9&amp;type=note">好好考研公众号，每日更新资料</a></p><h3 id="考研英语资料"><a class="header-anchor" href="#考研英语资料"></a>考研英语资料</h3><table><thead><tr><th>2022资料</th><th>百度云盘链接</th><th>提取码</th></tr></thead><tbody><tr><td>2022英语唐迟资料合集</td><td><a href="https://pan.baidu.com/s/12KUkxOukT-QIBbpJgO6R7A">云盘链接</a></td><td>ufh6</td></tr><tr><td>2022英语刘晓燕资料合集（高教版）</td><td><a href="https://pan.baidu.com/s/1RLFcQ6KLDwsWk5euTmbv0A">云盘链接</a></td><td>fa7q</td></tr><tr><td>2022英语刘晓燕资料合集（启航版）</td><td><a href="https://pan.baidu.com/s/1XAkWIgmBG1vXdHkeC0e7dA">云盘链接</a></td><td>jbpg</td></tr><tr><td>2022英语朱伟资料合集</td><td><a href="http://pan.baidu.com/s/1rEFa8e0-7Qm11fJo9T0aNQ">云盘链接</a></td><td>u985</td></tr></tbody></table><hr><table><thead><tr><th>2021资料</th><th>百度云盘链接</th><th>提取码</th></tr></thead><tbody><tr><td>2021英语唐迟资料合集</td><td><a href="https://pan.baidu.com/s/1-bIRqHH_N6A6xuDX3eEw5Q">云盘链接</a></td><td>bgfa</td></tr><tr><td>2021英语刘晓燕资料合集（高教版）</td><td><a href="https://pan.baidu.com/s/1YneD1u3YhbXl5yKPVzM2CQ">云盘链接</a></td><td>4h97</td></tr><tr><td>2021英语刘晓燕资料合集（启航版）</td><td><a href="https://pan.baidu.com/s/1vmlzGjD4YwG_JcHoNW9Hmw">云盘链接</a></td><td>tbuh</td></tr></tbody></table><h3 id="考研政治资料"><a class="header-anchor" href="#考研政治资料"></a>考研政治资料</h3><table><thead><tr><th>2022资料</th><th>百度云盘链接</th><th>提取码</th></tr></thead><tbody><tr><td>2022政治徐涛资料合集</td><td><a href="https://pan.baidu.com/s/1oX7YB9pN5fRNnfHttEidwA">云盘链接</a></td><td>phyg</td></tr></tbody></table><hr><table><thead><tr><th>2021资料</th><th>百度云盘链接</th><th>提取码</th></tr></thead><tbody><tr><td>2021政治肖秀荣资料合集</td><td><a href="https://pan.baidu.com/s/1oL_EwF0WwOhYih0SVNqbXg">云盘链接</a></td><td>gbwk</td></tr><tr><td>2021政治徐涛资料合集</td><td><a href="https://pan.baidu.com/s/1jHTsjdSYc6qfhTtp0lE5KA">云盘链接</a></td><td>73rf</td></tr></tbody></table><h3 id="考研数学资料"><a class="header-anchor" href="#考研数学资料"></a>考研数学资料</h3><table><thead><tr><th>2022资料</th><th>百度云盘链接</th><th>提取码</th></tr></thead><tbody><tr><td>2022数学汤家凤资料合集（文都版）</td><td><a href="https://pan.baidu.com/s/1pSWXHJfDzou_5x7lMvjKuA">云盘链接</a></td><td>49sj</td></tr><tr><td>2022数学汤家凤资料合集（新文道版）</td><td><a href="https://pan.baidu.com/s/1KwaRNs0yLBEV9GgEgWIhWQ">云盘链接</a></td><td>a678</td></tr><tr><td>2022数学武忠祥资料合集</td><td><a href="https://pan.baidu.com/s/1QSwjqeTShMwf5uwUNykWRw">云盘链接</a></td><td>sjnp</td></tr><tr><td>2022数学张宇资料合集</td><td><a href="https://pan.baidu.com/s/1J81U7MXeBZUrJb-b2X3sYw">云盘链接</a></td><td>gshh</td></tr><tr><td>2022数学李永乐资料合集</td><td><a href="https://pan.baidu.com/s/1HPVw62L5B2X1fZ1rEqTyTg">云盘链接</a></td><td>u985</td></tr></tbody></table><hr><table><thead><tr><th>2021资料</th><th>百度云盘链接</th><th>提取码</th></tr></thead><tbody><tr><td>2021数学汤家凤资料合集</td><td><a href="https://pan.baidu.com/s/1Vcv3UWsxbBNopIqeyXQcwg">云盘链接</a></td><td>kxvq</td></tr></tbody></table><h3 id="计算机408资料"><a class="header-anchor" href="#计算机408资料"></a>计算机408资料</h3><table><thead><tr><th>2022资料</th><th>百度云盘链接</th><th>提取码</th></tr></thead><tbody><tr><td>2022年计算机资料合集</td><td><a href="https://pan.baidu.com/s/1ADIdKQ_xHOnhgetC1ZiRqA">云盘链接</a></td><td>gihh</td></tr></tbody></table><hr><table><thead><tr><th>2021资料</th><th>百度云盘链接</th><th>提取码</th></tr></thead><tbody><tr><td>2021年计算机资料合集</td><td><a href="https://pan.baidu.com/s/1PKi1g5N03f3nt40TUIX7uA">云盘链接</a></td><td>q5xg</td></tr><tr><td>2021年计算机资料合集</td><td><a href="https://pan.baidu.com/s/1Rcwo6MYwEJZQOvq7KzkXFA">云盘链接</a></td><td>3333</td></tr></tbody></table><br/><blockquote><p>资料来源：<a href="https://mp.weixin.qq.com/s/Knp9-UbYStQXAS3vjuDZrA">研料库公众号</a>、好好考研</p></blockquote><h3 id="其他资料"><a class="header-anchor" href="#其他资料"></a>其他资料</h3><p>微信公众号：</p><ul><li>给力考研资料</li><li>好好考研</li><li>槟果考研</li><li>小白考研</li><li>灰灰考研(计算机)</li></ul><p>官方<a href="https://yz.chsi.com.cn/">中国研究生招生信息网(研招网)</a></p><h2 id="🧭知乎有关问题及回答"><a class="header-anchor" href="#🧭知乎有关问题及回答"></a>🧭知乎有关问题及回答</h2><p><a href="https://zhuanlan.zhihu.com/p/352816017">2022考研全程复习规划</a><br><a href="https://www.zhihu.com/question/20462634/answer/728661676">考研规划，看这一篇就够了！</a><br><a href="https://zhuanlan.zhihu.com/p/72965483">考研资料书推荐大全+考研经验分享</a></p><h3 id="各大院校官网"><a class="header-anchor" href="#各大院校官网"></a>各大院校官网</h3><h2 id="📆考研公共课规划"><a class="header-anchor" href="#📆考研公共课规划"></a>📆考研公共课规划</h2>]]></content>
    
    
    <summary type="html">资料来源于公众号</summary>
    
    
    
    <category term="考研" scheme="http://halo123.top/categories/%E8%80%83%E7%A0%94/"/>
    
    
    <category term="考研" scheme="http://halo123.top/tags/%E8%80%83%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>Web前端入门之CSS</title>
    <link href="http://halo123.top/2021/04/19/Web%E5%89%8D%E7%AB%AF/Web%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E4%B9%8BCSS/"/>
    <id>http://halo123.top/2021/04/19/Web%E5%89%8D%E7%AB%AF/Web%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E4%B9%8BCSS/</id>
    <published>2021-04-19T15:51:35.000Z</published>
    <updated>2021-04-24T12:30:17.642Z</updated>
    
    <content type="html"><![CDATA[<p>参考资料：</p><ul><li><a href="http://css.doyoe.com/">CSS参考手册</a></li></ul><h2 id="CSS-简介"><a class="header-anchor" href="#CSS-简介"></a>CSS 简介</h2><ol><li>CSS 是层叠样式表 ( Cascading Style Sheets ) 的简称。有时我们也会称之为 CSS 样式表或级联样式表。</li><li>CSS 是也是一种标记语言。</li><li>CSS 主要用于设置 HTML 页面中的文本内容（字体、大小、对齐方式等）、图片的外形（宽高、边框样式、边距等）以及版面的布局和外观显示样式。</li><li>CSS 让我们的网页更加丰富多彩，布局更加灵活自如。简单理解：CSS 可以美化 HTML , 让 HTML 更漂亮， 让页面布局更简单。</li><li>CSS 最大价值: 由 HTML 专注去做结构呈现，样式交给 CSS，即 结构 ( HTML ) 与样式( CSS ) 相分离。</li></ol><h3 id="CSS-语法规范"><a class="header-anchor" href="#CSS-语法规范"></a>CSS 语法规范</h3><ol><li>使用 HTML 时，需要遵从一定的规范，CSS 也是如此。要想熟练地使用 CSS 对网页进行修饰，首先需要了解CSS 样式规</li><li>CSS 规则由两个主要的部分构成：选择器以及一条或多条声明。</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span>&#123;</span><br><span class="line"><span class="attribute">color</span>:red;</span><br><span class="line"><span class="attribute">font-size</span>:<span class="number">25px</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>选择器是用于指定 CSS 样式的 HTML 标签，花括号内是对该对象设置的具体样式</li><li>属性和属性值以“键值对”的形式出现</li><li>属性是对指定的对象设置的样式属性，例如字体大小、文本颜色等</li><li>属性和属性值之间用英文<code>:</code>分开</li><li>多个“键值对”之间用英文<code>;</code>进行区分</li></ol><p>所有的样式，都包含在 <code>&lt;style&gt;</code> 标签内，表示是样式表。<code>&lt;style&gt;</code> 一般写到 <code>&lt;/head&gt;</code> 上方，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">h4</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">color</span>: blue;</span></span><br><span class="line"><span class="css">      <span class="attribute">font-size</span>: <span class="number">100px</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="CSS代码风格"><a class="header-anchor" href="#CSS代码风格"></a>CSS代码风格</h3><p>样式空格风格</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*选择器（标签）和大括号中间保留空格*/</span></span><br><span class="line"><span class="selector-tag">h3</span> &#123;</span><br><span class="line">  <span class="comment">/*属性值前面，冒号后面，保留一个空格*/</span></span><br><span class="line">  <span class="attribute">color</span>: pink;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>样式格式书写</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*紧凑格式*/</span></span><br><span class="line"><span class="selector-tag">h3</span> &#123; <span class="attribute">color</span>: deeppink;<span class="attribute">font-size</span>: <span class="number">20px</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*展开格式(推荐,更直观)*/</span></span><br><span class="line"><span class="selector-tag">h3</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: pink;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">20px</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>样式大小写风格</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*小写格式(推荐)*/</span></span><br><span class="line"><span class="selector-tag">h3</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*大写格式*/</span></span><br><span class="line"><span class="selector-tag">H3</span> &#123;</span><br><span class="line">  <span class="attribute">COLOR</span>: PINK;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CSS选择器"><a class="header-anchor" href="#CSS选择器"></a>CSS选择器</h2><h3 id="选择器的作用"><a class="header-anchor" href="#选择器的作用"></a>选择器的作用</h3><p>选择器(选择符)就是根据不同需求把不同的标签选出来这就是选择器的作用。简单来说，就是选择标签用的。</p><p>选择器分为基础选择器和复合选择器两个大类。</p><h3 id="CSS-基础选择器"><a class="header-anchor" href="#CSS-基础选择器"></a>CSS 基础选择器</h3><p>基础选择器又包括：标签选择器、类选择器、id 选择器和通配符选择器</p><h4 id="标签选择器"><a class="header-anchor" href="#标签选择器"></a>标签选择器</h4><p>标签选择器（元素选择器）是指用 HTML 标签名称作为选择器，按标签名称分类，为页面中某一类标签指定统一的 CSS 样式。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">标签选择器&#123;</span><br><span class="line">  属性：属性值</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：能快速为页面中同类型的标签统一设置样式。<br>缺点：不能设计差异化样式,只能选择全部的当前标签。</p><h4 id="类选择器"><a class="header-anchor" href="#类选择器"></a>类选择器</h4><p>如果想要差异化选择不同的标签，单独选一个或者某几个标签，可以使用类选择器。</p><p>结构需要用class属性来调用class类的意思，<code>&lt;div class=&quot;类名&quot;&gt; 变红色 &lt;/div&gt;</code></p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.类名&#123;</span><br><span class="line">  属性：属性值</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果想要差异化选择不同的标签，单独选一个或者某几个标签，可以使用类选择器。</li><li>类选择器在 HTML 中以 class 属性表示，在 CSS 中，类选择器以一个点“.”号显示。</li><li>类选择器使用“.”（英文点号）进行标识，后面紧跟类名（自定义，我们自己命名的）。</li><li>可以理解为给这个标签起了一个名字，来表示。</li><li>长名称或词组可以使用中横线来为选择器命名。</li><li>不要使用纯数字、中文等命名，尽量使用英文字母来表示。</li><li>命名要有意义，尽量使别人一眼就知道这个类名的目的。</li><li>命名规范：见资料（<a href="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%B5%84%E6%96%99/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%E6%89%8B%E5%86%8C.doc">Web 前端开发规范手册.doc</a>）</li></ol><h4 id="多类名选择器"><a class="header-anchor" href="#多类名选择器"></a>多类名选择器</h4><p>我们可以给一个标签指定多个类名，从而达到更多的选择目的。 这些类名都可以选出这个标签。简单理解就是一个标签有多个名字。</p><p>多类名的具体使用，类名之间用空格隔开：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;red font20&quot;&gt;嘤嘤嘤&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>在标签class 属性中写多个类名</li><li>多个类名中间必须用空格分开</li><li>这个标签就可以分别具有这些类名的样式</li></ol><p>多类名开发中使用场景：</p><ol><li>可以把一些标签元素相同的样式(共同的部分)放到一个类里面。</li><li>这些标签都可以调用这个公共的类然后再调用自己独有的类。</li><li>从而节省CSS代码，统一修改也非常方便。</li></ol><h4 id="ID-选择器"><a class="header-anchor" href="#ID-选择器"></a>ID 选择器</h4><p>id 选择器可以为标有特定 id 的 HTML 元素指定特定的样式。</p><p>HTML 元素以 id 属性来设置 id 选择器，CSS 中 id 选择器以 “#” 来定义。语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#id名 &#123;</span><br><span class="line">  属性1: 属性值1;  </span><br><span class="line">  ...</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>注意：id 属性只能在每个 HTML 文档中出现一次</p><p>id 选择器和类选择器的区别：</p><ol><li>类选择器（class）好比人的名字，一个人可以有多个名字，同时一个名字也可以被多个人使用。</li><li>id 选择器好比人的身份证号码，全中国是唯一的，不得重复。</li><li>id 选择器和类选择器最大的不同在于使用次数上。</li><li>类选择器在修改样式中用的最多，id 选择器一般用于页面唯一性的元素上，经常和 JavaScript 搭配使用。</li></ol><h4 id="通配符选择器"><a class="header-anchor" href="#通配符选择器"></a>通配符选择器</h4><p>在 CSS 中，通配符选择器使用 “*” 定义，它表示选取页面中所有元素（标签）。语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  属性<span class="number">1</span>: 属性值<span class="number">1</span>;  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通配符选择器不需要调用，自动就给所有的元素使用样式，特殊情况才使用(如清除所有的元素标签的内外边距)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="基础选择器总结"><a class="header-anchor" href="#基础选择器总结"></a>基础选择器总结</h4><table><thead><tr><th>基础选择器</th><th>作用</th><th>特点</th><th>使用情况</th><th>用法</th></tr></thead><tbody><tr><td>标签选择器</td><td>可以选出所有相同的标签</td><td>不能差异化选择</td><td>较多</td><td><code>p &#123;color: red;&#125;</code></td></tr><tr><td>类选择器</td><td>可以选出1个或者多个标签</td><td>可以根据需求选择</td><td>非常多</td><td><code>.nav &#123;color: red;&#125;</code></td></tr><tr><td>id选择器</td><td>一次只能选择1个标签</td><td>相同id属性只能在每一个HTML文档中出现一次</td><td>一般和JavaScript搭配</td><td><code>#nav &#123;color: red;&#125;</code></td></tr><tr><td>通配符选择器</td><td>选择所有的标签</td><td>选择所有</td><td>特殊情况下使用</td><td><code>* &#123;color: red;&#125;</code></td></tr></tbody></table><h2 id="关系选择器"><a class="header-anchor" href="#关系选择器"></a>关系选择器</h2><p>简单的选择器包括标签选择器、类选择器、ID 选择器和通配符选择器。如果把两个选择器组合在一起，就形成了一个复杂关系的选择器。在 HTML5 文档结构中，通过关系选择器可以精确匹配结构中特定关系元素。</p><h3 id="包含选择器"><a class="header-anchor" href="#包含选择器"></a>包含选择器</h3><p>包含选择器通过空格连接两个选择器，前面选择器表示包含的祖先元素，后面选择器表示被包含的后代元素。</p><ul><li>优点：可以匹配特定的结构内指定对象，用于缩小匹配范围。</li><li>缺点： 匹配范围较大，影响的层级不受限制。</li></ul><p>案例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 网页模板 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span> 网页标题 <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span> 页脚标题 <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure><p>实现以下目标：</p><ul><li>定义网页标题的字体大小为 18px</li><li>定义页脚标题的字体大小为 12px</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">header</span> <span class="selector-tag">h1</span>&#123;<span class="attribute">font-size</span>:<span class="number">18px</span>;&#125;</span><br><span class="line"><span class="selector-tag">footer</span> <span class="selector-tag">h1</span>&#123;<span class="attribute">font-size</span>:<span class="number">12px</span>;&#125;</span><br></pre></td></tr></table></figure><h3 id="子选择器"><a class="header-anchor" href="#子选择器"></a>子选择器</h3><p>子选择器使用尖括号（<code>&gt;</code>）连接两个选择器，前面选择器表示要匹配的父元素，后面选择器表示被包含的匹配子对象。</p><ul><li>优点：比包含选择器匹配的范围更小，从层级结构上来看匹配目标更明确。</li><li></li></ul><h2 id="CSS字体属性"><a class="header-anchor" href="#CSS字体属性"></a>CSS字体属性</h2><p>CSS Fonts (字体)属性用于定义字体系列、大小、粗细、和文字样式(如斜体)。</p><h3 id="字体系列"><a class="header-anchor" href="#字体系列"></a>字体系列</h3><p>CSS使用<code>font-family</code>属性定义文本的字体系列。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123; </span><br><span class="line">  <span class="attribute">font</span>- family: Arial, <span class="string">&quot;Microsoft Yahei&quot;</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>各种字体之间必须使用英文状态下的逗号隔开</li><li>般情况下，如果有空格隔开的多个单词组成的字体加引号。</li><li>尽量使用系统默认自带字体，保证在任何用户的浏览器中都能正确显示</li></ul><h3 id="字体大小"><a class="header-anchor" href="#字体大小"></a>字体大小</h3><p>CSS 使用 <code>font-size</code> 属性定义字体大小。 语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;  </span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">20px</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>px（像素）大小是我们网页的最常用的单位</li><li>谷歌浏览器默认的文字大小为16px</li><li>不同浏览器可能默认显示的字号大小不一致，我们尽量给一个明确值大小，不要默认大小</li><li>可以给 body 指定整个页面文字的大小</li></ol><h3 id="字体粗细"><a class="header-anchor" href="#字体粗细"></a>字体粗细</h3><p>CSS 使用 <code>font-weight</code> 属性设置文本字体的粗细。语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;  </span><br><span class="line">  <span class="attribute">font-weight</span>: bold; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>normal</td><td>默认值（不加粗）</td></tr><tr><td>bold</td><td>定义加粗</td></tr><tr><td>100-900</td><td>400等同于normal，700等同于bold，注意这个数字后面不加单位</td></tr></tbody></table><h3 id="字体样式"><a class="header-anchor" href="#字体样式"></a>字体样式</h3><p>CSS 使用 <code>font-style</code> 属性设置文本的风格。语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;  </span><br><span class="line">  <span class="attribute">font-style</span>: normal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性值</th><th>作用</th></tr></thead><tbody><tr><td>normal</td><td>默认值，浏览器会显示标准的字体样式<code>font- style: normal;</code></td></tr><tr><td>italic</td><td>浏览器会显示斜体的字体样式。</td></tr></tbody></table><h3 id="字体的综合写法"><a class="header-anchor" href="#字体的综合写法"></a>字体的综合写法</h3><p>字体属性可以把以上文字样式综合来写, 这样可以更节约代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123; </span><br><span class="line">  <span class="attribute">font</span>: font-style  font-weight  font-size/line-height  font-family;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 font 属性时，必须按上面语法格式中的顺序书写，<font color="#FF666">不能更换顺序</font>，并且各个属性间以空格隔开 不需要设置的属性可以省略（取默认值），但必须保留 <code>font-size</code> 和 <code>font-family</code> 属性，否则 font 属性将不起作用。</p><h3 id="字体总结"><a class="header-anchor" href="#字体总结"></a>字体总结</h3><table><thead><tr><th>属性</th><th>表示</th><th>注意点</th></tr></thead><tbody><tr><td><code>font-size</code></td><td>字号</td><td>通常用的单位是 px 像素，一定要跟上单位</td></tr><tr><td><code>font-family</code></td><td>字体</td><td>实际工作中按照团队约定来写字体</td></tr><tr><td><code>font-weight</code></td><td>字体粗细</td><td>记住加粗是700或者bold，不加粗是normal或者400记住数字不要跟单位</td></tr><tr><td><code>font-style</code></td><td>字体样式</td><td>记住倾斜是italic，不倾斜是normal。工作中我们最常用normal</td></tr><tr><td><code>font</code></td><td>字体连写</td><td>字体连写是有顺序的不能随意换位置；其中字号和字体必须同时出现</td></tr></tbody></table><h2 id="CSS文本属性"><a class="header-anchor" href="#CSS文本属性"></a>CSS文本属性</h2><p>CSS Text (文本)属性可定义文本的外观，比如文本的颜色、对齐文本、装饰文本、文本缩进、行间距等。</p><h3 id="文本颜色"><a class="header-anchor" href="#文本颜色"></a>文本颜色</h3><p>color 属性用于定义文本的颜色。语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123; </span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>表示</th><th>属性值</th></tr></thead><tbody><tr><td>预定义的颜色</td><td>red、green、blue等</td></tr><tr><td>十六进制(常用)</td><td>#FF0000、#FF6600等</td></tr><tr><td>RGB代码</td><td>rgb(255,0,0)、rgb(100%,0%,0%)</td></tr></tbody></table><h3 id="文本对齐"><a class="header-anchor" href="#文本对齐"></a>文本对齐</h3><p><code>text-align</code> 属性用于设置元素内文本内容的<font color="#FF666">水平</font>对齐方式。语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123; </span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性值</th><th>解释</th></tr></thead><tbody><tr><td>left</td><td>左对齐（默认值）</td></tr><tr><td>right</td><td>右对齐</td></tr><tr><td>center</td><td>居中对齐</td></tr></tbody></table><h3 id="修饰文本"><a class="header-anchor" href="#修饰文本"></a>修饰文本</h3><p><code>text-decoration</code>属性规定添加到文本的修饰。可以给文本添加下划线、删除线、上划线等。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123; </span><br><span class="line">  <span class="attribute">text-decoration</span>：underline；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>none</td><td>默认，没有装饰线</td></tr><tr><td>underline</td><td>下划线</td></tr><tr><td>overline</td><td>上划线</td></tr><tr><td>line-through</td><td>删除线</td></tr></tbody></table><h3 id="文本缩进"><a class="header-anchor" href="#文本缩进"></a>文本缩进</h3><p><code>text-indent</code>属性用来指定文本的第一行的缩进，通常是将段落的首行缩进。语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123; </span><br><span class="line">  <span class="attribute">text-indent</span>：<span class="number">20px</span>；</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span> &#123; </span><br><span class="line">  <span class="attribute">text-indent</span>：<span class="number">2em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>em</code> 是一个相对单位，就是当前元素（font-size) 1 个文字的大小，如果当前元素没有设置大小，则会按照父元素的 1 个文字大小。</p></blockquote><h3 id="行间距"><a class="header-anchor" href="#行间距"></a>行间距</h3><p><code>line-height</code> 属性用于设置行间的距离（行高）。可以控制文字行与行之间的距离。语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123; </span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">26px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>行高的文本分为：上间距、文本高度和下间距，这三者大小之和 = 行间距</p><h3 id="文本属性总结"><a class="header-anchor" href="#文本属性总结"></a>文本属性总结</h3><table><thead><tr><th>属性</th><th>表示</th><th>注意点</th></tr></thead><tbody><tr><td>color</td><td>文本颜色</td><td>常用十六进制表示颜色</td></tr><tr><td>text-align</td><td>文本对齐</td><td>设定文字水平对齐方式</td></tr><tr><td>text-indent</td><td>文本缩进</td><td>可以设置首行缩进</td></tr><tr><td>text-decoration</td><td>文本修饰</td><td>添加或去除下划线</td></tr><tr><td>line-height</td><td>行高</td><td>控制行间距</td></tr></tbody></table><h2 id="CSS样式表"><a class="header-anchor" href="#CSS样式表"></a>CSS样式表</h2><p>按照 CSS 样式书写的位置（或者引入的方式），CSS 样式表可以分为三大类：行内样式表（行内式）、内部样式表（嵌入式）、外部样式表（链接式）。</p><h3 id="行内样式表（行内式）"><a class="header-anchor" href="#行内样式表（行内式）"></a>行内样式表（行内式）</h3><p>行内样式表（内联样式表）是在元素标签内部的 <code>style</code> 属性中设定 CSS 样式。适合于修改简单样式。语法：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;color: red; font-size: 12px;&quot;&gt;一拳一个嘤嘤怪&lt;/div&gt;</span><br></pre></td></tr></table></figure><ol><li>style 其实就是标签的属性，在双引号中间，写法要符合 CSS 规范</li><li>可以控制当前的标签设置样式</li><li>由于书写繁琐，并且没有体现出结构与样式相分离的思想，所以不推荐大量使用，只有对当前元素添加简单样式的时候，可以考虑使用</li><li>使用行内样式表设定 CSS，通常也被称为行内式引入</li></ol><h3 id="内部样式表（嵌入式）"><a class="header-anchor" href="#内部样式表（嵌入式）"></a>内部样式表（嵌入式）</h3><p>内部样式表（内嵌样式表）是写到html页面内部. 是将所有的 CSS 代码抽取出来，单独放到一个 <code>&lt;style&gt;</code> 标签中，语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  <span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><ol><li><code>&lt;style&gt;</code> 标签理论上可以放在 HTML 文档的任何地方，但一般会放在文档的<code>&lt;head&gt;</code>标签中</li><li>通过此种方式，可以方便控制当前整个页面中的元素样式设置</li><li>代码结构清晰，但是并没有实现结构与样式完全分离</li><li>使用内部样式表设定 CSS，通常也被称为嵌入式引入，这种方式是我们练习时常用的方式</li></ol><h3 id="外部样式表（链接式）"><a class="header-anchor" href="#外部样式表（链接式）"></a>外部样式表（链接式）</h3><p>实际开发都是外部样式表. 适合于样式比较多的情况. 核心是:样式单独写到CSS 文件中，之后把CSS文件引入到 HTML 页面中使用.<br>引入外部样式表分为两步：</p><ol><li>新建一个后缀名为 .css 的样式文件，把所有 CSS 代码都放入此文件中。</li><li>在 HTML 页面中，使用<code>&lt;link&gt;</code> 标签引入这个文件。<br>语法：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel&#x3D;&quot;stylesheet&quot;  href&#x3D;&quot;css文件路径&quot;&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://css.doyoe.com/&quot;&gt;CSS参考手册&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;CSS-简介&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#CSS-简介&quot;&gt;&lt;/a&gt;CSS</summary>
      
    
    
    
    <category term="Web前端" scheme="http://halo123.top/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="CSS" scheme="http://halo123.top/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Web前端入门之HTML</title>
    <link href="http://halo123.top/2021/04/18/Web%E5%89%8D%E7%AB%AF/Web%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E4%B9%8BHTML/"/>
    <id>http://halo123.top/2021/04/18/Web%E5%89%8D%E7%AB%AF/Web%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E4%B9%8BHTML/</id>
    <published>2021-04-18T14:11:16.000Z</published>
    <updated>2021-04-19T15:50:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考资料：</p><ul><li><a href="https://www.bilibili.com/video/BV1pE411q7FU">Web前端入门教程</a></li><li><a href="http://www.w3school.com.cn/">W3CSchool</a></li><li><a href="https://developer.mozilla.org">MDN</a></li></ul><h2 id="概念"><a class="header-anchor" href="#概念"></a>概念</h2><h3 id="什么是网页"><a class="header-anchor" href="#什么是网页"></a>什么是网页?</h3><ol><li>网站是指在因特网上根据一定的规则，使用 HTML 等制作的用于展示特定内容相关的网页集合。</li><li>网页是网站中的一“页”，通常是 HTML 格式的文件，它要通过浏览器来阅读。</li><li>网页是构成网站的基本元素，它通常由图片、链接、文字、声音、视频等元素组成。通常我们看到的网页，常见以 .htm 或 .html 后缀结尾的文件，因此将其俗称为 HTML 文件。</li></ol><h3 id="什么是HTML？"><a class="header-anchor" href="#什么是HTML？"></a>什么是HTML？</h3><ol><li>HTML 指的是超文本标记语言 (Hyper Text Markup Language) ，它是用来描述网页的一种语言。</li><li>HTML 不是一种编程语言，而是一种标记语言 (markup language)。 标记语言是一套标记标签 (markup tag)。</li></ol><h3 id="浏览器"><a class="header-anchor" href="#浏览器"></a>浏览器</h3><p>浏览器是网页显示、运行的平台。常用的浏览器：Google Chrome、Microsoft Edge、IE、Apple Safari、FireFox、Opera</p><p>负责读取网页内容，整理讯息，计算网页的显示方式并显示页面</p><table><thead><tr><th>浏览器</th><th>内核</th><th>备注</th></tr></thead><tbody><tr><td>IE</td><td>Trident</td><td>IE及一些具有双核的浏览器如360极速浏览器等</td></tr><tr><td>FireFox</td><td>Gecko</td><td>火狐浏览器内核</td></tr><tr><td>Safari</td><td>Webkit</td><td>苹果浏览器内核</td></tr><tr><td>Chromium</td><td>Blink</td><td>Chrome、Opera、新版Edge浏览器内核。Blink是WebKit的分支</td></tr></tbody></table><p>目前国内一般浏览器都会采用 Webkit/Blink 内核，如 360、UC、QQ、搜狗等。</p><h3 id="Web标准"><a class="header-anchor" href="#Web标准"></a>Web标准</h3><p>Web 标准是由 <a href="https://www.w3.org/">W3C 组织</a>和其他标准化组织制定的一系列标准的集合。W3C（万维网联盟）是国际最著名的标准化组织。</p><p>遵循 Web 标准除了可以让不同的开发人员写出的页面更标准、更统一外，还有以下优点：</p><ol><li>让 Web 的发展前景更广阔。</li><li>内容能被更广泛的设备访问。</li><li>更容易被搜寻引擎搜索。</li><li>降低网站流量费用。</li><li>使网站更易于维护。</li><li>提高页面浏览速度。</li></ol><p>Web标准的构成：主要包括结构(Structure)、表现(Presentation)和行为(Behavior)三个方面。</p><table><thead><tr><th>标准</th><th>说明</th></tr></thead><tbody><tr><td>结构</td><td>结构用于对网页元素进行整理和分类。如HTML</td></tr><tr><td>表现</td><td>表现用于设置网页元素的版式、颜色、大小等外观样式。主要指的是CSS</td></tr><tr><td>行为</td><td>行为是指网页模型的定义及交互的编写。如Javascript</td></tr></tbody></table><p><strong>结构写到 HTML 文件中， 表现写到 CSS 文件中， 行为写到 JavaScript 文件中</strong></p><h2 id="HTML-标签的导读"><a class="header-anchor" href="#HTML-标签的导读"></a>HTML 标签的导读</h2><h3 id="HTML语法规则"><a class="header-anchor" href="#HTML语法规则"></a>HTML语法规则</h3><ol><li>HTML 标签是由尖括号包围的关键词，例如 <code>&lt;html&gt;</code>。</li><li>HTML 标签通常是成对出现的，例如 <code>&lt;html&gt;</code> 和 <code>&lt;/html&gt;</code> ，我们称为<strong>双标签</strong>。标签对中的第一个标签是开始标签，第二个标签是结束标签。</li><li>有些特殊的标签必须是单个标签（极少情况），例如 <code>&lt;br /&gt;</code>，我们称为<strong>单标签</strong>。</li></ol><h3 id="标签的关系"><a class="header-anchor" href="#标签的关系"></a>标签的关系</h3><p>双标签关系可以分为两类：包含关系和并列关系</p><p>包含关系：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span> <span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p>并列关系：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="基本结构标签"><a class="header-anchor" href="#基本结构标签"></a>基本结构标签</h3><p>每个网页都会有一个基本的结构标签（也称为骨架标签），页面内容也是在这些基本标签上书写</p><table><thead><tr><th>标签名</th><th>定义</th><th>说明</th></tr></thead><tbody><tr><td><code>&lt;html&gt;&lt;/html&gt;</code></td><td>HTML标签</td><td>页面中最大的标签，我们称之为根标签</td></tr><tr><td><code>&lt;head&gt;&lt;/head&gt;</code></td><td>文档的头部</td><td>注意在head标签中我们必须要设置的标签是title</td></tr><tr><td><code>&lt;title&gt;&lt;/title&gt;</code></td><td>文档的标题</td><td>让页面拥有一个属于自己的网页标题</td></tr><tr><td><code>&lt;body&gt;&lt;/body&gt;</code></td><td>文档的主体</td><td>元素包含文档的所有内容，页面内容基本都是放到body里面的</td></tr></tbody></table><h3 id="HTML基本骨架"><a class="header-anchor" href="#HTML基本骨架"></a>HTML基本骨架</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;!DOCTYPE html&gt;</code>：文档类型声明标签，告诉浏览器这个页面采取 HTML 5 版本来显示页面。</li><li><code>&lt;html lang=&quot;en&quot;&gt;</code>：<code>lang</code> 语言种类，用来定义当前文档显示的语言。en定义语言为英语，zh-CN定义语言为中文。简单来说,定义为 en 就是英文网页，定义为 zh-CN 就是中文网页。其实对于文档显示来说，定义成 en 的文档也可以显示中文，定义成 zh-CN 的文档也可以显示英文，这个属性对浏览器和搜索引擎(百度.谷歌等)还是有作用的。</li><li><code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code>：设置字符集，charset 常用的值有：GB2312 、BIG5 、GBK 和 UTF-8，其中 UTF-8 也被称为万国码，基本包含了全世界所有国家需要用到的字符。尽量统一写成标准的 “UTF-8”，不要写成  “utf8” 或 “UTF8”。</li></ul><h2 id="HTML常用的标签"><a class="header-anchor" href="#HTML常用的标签"></a>HTML常用的标签</h2><h3 id="标题标签"><a class="header-anchor" href="#标题标签"></a>标题标签</h3><p>为了使网页更具有语义化，我们经常会在页面中用到标题标签。HTML 提供了 6 个等级的网页标题，即<code>&lt;h1&gt;</code> - <code>&lt;h6&gt;</code> 。具体实现：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>标题一共六级选,<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>文字加粗一行显。<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>由大到小依次减，<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>从重到轻随之变。<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span>语法规范书写后，<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h6</span>&gt;</span>具体效果刷新见。<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br></pre></td></tr></table></figure><p>特点：</p><ol><li>加了标题的文字会变的加粗，字号也会依次变大。</li><li>一个标题独占一行。</li></ol><h3 id="段落标签"><a class="header-anchor" href="#段落标签"></a>段落标签</h3><p>在网页中，要把文字有条理地显示出来，就需要将这些文字分段显示。在 HTML 标签中，<code>&lt;p&gt;</code> (paragraph)标签用于定义段落，它可以将整个网页分为若干个段落。具体实现：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span> 我是一个段落标签 <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>特点：</p><ol><li>文本在一个段落中会根据浏览器窗口的大小自动换行。</li><li>段落和段落之间保有空隙。</li></ol><h3 id="换行标签"><a class="header-anchor" href="#换行标签"></a>换行标签</h3><p>在 HTML 中，一个段落中的文字会从左到右依次排列，直到浏览器窗口的右端，然后才自动换行。如果希望某段文本强制换行显示，就需要使用换行标签 <code>&lt;br /&gt;</code>(break)。具体实现：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>特点：</p><ol><li><code>&lt;br /&gt;</code> 是个单标签。</li><li><code>&lt;br /&gt;</code> 标签只是简单地开始新的一行，跟段落不一样，段落之间会插入一些垂直的间距。</li></ol><h3 id="文本格式化标签"><a class="header-anchor" href="#文本格式化标签"></a>文本格式化标签</h3><p>在网页中，有时需要为文字设置粗体、斜体 或下划线等效果，这时就需要用到 HTML 中的文本格式化标签，使文字以特殊的方式显示。</p><table><thead><tr><th>语义</th><th>标签</th></tr></thead><tbody><tr><td>加粗</td><td><code>&lt;strong&gt;&lt;/strong&gt;</code>或者<code>&lt;b&gt;&lt;/b&gt;</code></td></tr><tr><td>倾斜</td><td><code>&lt;em&gt;&lt;/em&gt;</code>或者<code>&lt;i&gt;&lt;/i&gt;</code></td></tr><tr><td>删除线</td><td><code>&lt;del&gt;&lt;/del&gt;</code>或者<code>&lt;s&gt;&lt;/s&gt;</code></td></tr><tr><td>下划线</td><td><code>&lt;ins&gt;&lt;/ins&gt;</code>或者<code>&lt;u&gt;&lt;/u&gt;</code></td></tr></tbody></table><h3 id="div和span标签"><a class="header-anchor" href="#div和span标签"></a><code>div</code>和<code>span</code>标签</h3><p><code>&lt;div&gt;</code> (division)和 <code>&lt;span&gt;</code>是没有语义的，它们就是一个盒子，用来装内容的。</p><p>特点：</p><ol><li><code>&lt;div&gt;</code> 标签用来布局，但是现在<font color="#FF666">一行只能放一个</font><code>&lt;div&gt;</code>。 大盒子</li><li><code>&lt;span&gt;</code> 标签用来布局，<font color="#FF666">一行上可以多个</font> <code>&lt;span&gt;</code>。小盒子</li></ol><h3 id="图片标签"><a class="header-anchor" href="#图片标签"></a>图片标签</h3><p>在 HTML 标签中，<code>&lt;img&gt;</code>(image)标签用于定义 HTML 页面中的图像。具体实现：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;图像URL&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><code>src</code> 是<code>&lt;img&gt;</code>标签的必须属性，它用于指定图像文件的路径和文件名。</p><p>图像标签的其他属性：</p><table><thead><tr><th>属性</th><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>src</td><td>图片路径</td><td>规定显示图像的 URL</td></tr><tr><td>alt</td><td>文本</td><td>替换文本。图像不能显示的文字</td></tr><tr><td>title</td><td>文本</td><td>提示文本。鼠标放到图像上，显示的文字</td></tr><tr><td>width</td><td>像素</td><td>设置图像的宽度</td></tr><tr><td>height</td><td>像素</td><td>设置图像的高度</td></tr><tr><td>border</td><td>像素</td><td>设置图像的边框粗细</td></tr></tbody></table><p>图像标签注意点：</p><ol><li>图像标签可以拥有多个属性，必须写在标签名的后面。</li><li>属性之间不分先后顺序，标签名与属性、属性与属性之间均以空格分开。</li><li>属性采取键值对的格式，即 key=“value&quot; 的格式，属性 =“属性值”。</li></ol><h3 id="路径"><a class="header-anchor" href="#路径"></a>路径</h3><p>分为相对路径和绝对路径：</p><p>相对路径：以引用文件所在位置为参考基础，而建立出的目录路径。简单来说，图片相对于 HTML 页面的位置。</p><table><thead><tr><th>相对路径分类</th><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>同一级目录</td><td></td><td>图像文件位于HTML文件同-级如<code>&lt;img src=&quot;baidu.gif&quot; /&gt;</code></td></tr><tr><td>下一级目录</td><td><code>/</code></td><td>图像文件位于HTML文件下一级如<code>&lt;img src=&quot;images/baidu.gif&quot; /&gt;</code></td></tr><tr><td>上一级目录</td><td><code>../</code></td><td>图像文件位于HTML文件上一级如<code>&lt;img src=&quot;../baidu.gif&quot; /&gt;</code></td></tr></tbody></table><p>特点：相对路径是从代码所在的这个文件出发，去寻找目标文件的，而我们这里所说的上一级 、下一级和同一级就是 图片相对于 HTML 页面的位置。</p><p>绝对路径：是指目录下的绝对位置，直接到达目标位置，通常是从盘符开始的路径。</p><p>例如，<code>&quot;D:\web\img\logo.gif&quot;</code>或完整的网络地址<code>&quot;http://www.xxx.cn/images/logo.gif&quot;</code></p><h3 id="链接标签"><a class="header-anchor" href="#链接标签"></a>链接标签</h3><p>ahchor 链接的语法格式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;跳转目标&quot;</span> <span class="attr">target</span>=<span class="string">&quot;目标窗口的弹出方式&quot;</span>&gt;</span> 文本或图像 <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>属性：</p><ol><li><code>href</code>：用于指定链接目标的url地址，必须属性</li><li>target:用于指定链接页面的打开方式<code>_self</code>默认值，<code>_blank</code>新窗口打开</li><li><code>#</code>：空链接</li></ol><p>链接分类：</p><ol><li>外部链接: 例如 <code>&lt;a href=&quot;http://www.baidu.com&quot;&gt; 百度&lt;/a&gt;</code></li><li>内部链接:网站内部页面之间的相互链接. 直接链接内部页面名称即可，例如 <code>&lt;a href=&quot;index.html&quot;&gt; 首页 &lt;/a&gt;</code></li><li>空链接: 如果当时没有确定链接目标时，<code>&lt;a href=&quot;#&quot;&gt; 首页 &lt;/a&gt;</code></li><li>下载链接: 如果 href 里面地址是一个文件或者压缩包，会下载这个文件。</li><li>网页元素链接: 在网页中的各种网页元素，如文本、图像、表格、音频、视频等都可以添加超链接.</li><li>锚点链接:  点我们点击链接,可以快速定位到页面中的某个位置.<ul><li>在链接文本的 href 属性中，设置属性值为 #名字 的形式，如<code>&lt;a href=&quot;#two&quot;&gt; 第2集 &lt;/a&gt;</code></li><li>找到目标位置标签，里面添加一个 id 属性 = 刚才的名字 ，如：<code>&lt;h3 id=&quot;two&quot;&gt;第2集介绍&lt;/h3&gt;</code></li></ul></li></ol><h3 id="注释"><a class="header-anchor" href="#注释"></a>注释</h3><p>如果需要在 HTML 文档中添加一些便于阅读和理解但又不需要显示在页面中的注释文字，就需要使用注释标签。<br>HTML中的注释以<code>&lt;!--</code>开头，以<code>--&gt;</code>结束。</p><p>具体实现：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注释语句 快捷键: ctrl +  /  --&gt;</span>      </span><br></pre></td></tr></table></figure><p>添加注释是为了更好地解释代码的功能，便于相关开发人员理解和阅读代码，程序是不会执行注释内容的。</p><h3 id="特殊字符"><a class="header-anchor" href="#特殊字符"></a>特殊字符</h3><p>在 HTML 页面中，一些特殊的符号很难或者不方便直接使用，此时我们就可以使用下面的字符来替代。</p><table><thead><tr><th>特殊字符</th><th>描述</th><th>字符的代码</th></tr></thead><tbody><tr><td> </td><td>空格符</td><td><code>&amp;nbsp;</code></td></tr><tr><td>&lt;</td><td>小于号</td><td><code>&amp;lt;</code></td></tr><tr><td>&gt;</td><td>大于号</td><td><code>&amp;gt;</code></td></tr><tr><td>&amp;</td><td>and</td><td><code>&amp;amp;</code></td></tr><tr><td>¥</td><td>人民币</td><td><code>&amp;yen;</code></td></tr><tr><td>©</td><td>版权</td><td><code>&amp;copy;</code></td></tr><tr><td>®</td><td>注册商标</td><td><code>&amp;reg;</code></td></tr><tr><td>°</td><td>摄氏度</td><td><code>&amp;deg;</code></td></tr><tr><td>±</td><td>正负号</td><td><code>&amp;plusmn;</code></td></tr><tr><td>×</td><td>乘号</td><td><code>&amp;times;</code></td></tr><tr><td>÷</td><td>除号</td><td><code>&amp;divide;</code></td></tr><tr><td>²</td><td>平方</td><td><code>&amp;sup2;</code></td></tr><tr><td>³</td><td>立方</td><td><code>&amp;sup3;</code></td></tr></tbody></table><p>重点记住：空格 、大于号、 小于号 这三个， 其余的使用很少，如果需要回头查阅即可。</p><h2 id="表格"><a class="header-anchor" href="#表格"></a>表格</h2><ol><li>表格主要用于显示、展示数据，因为它可以让数据显示的非常的规整，可读性非常好。特别是后台展示数据的时候，能够熟练运用表格就显得很重要。一个清爽简约的表格能够把繁杂的数据表现得很有条理。</li><li>表格不是用来布局页面的,而是用来展示数据的。</li></ol><h3 id="表格的具体用法"><a class="header-anchor" href="#表格的具体用法"></a>表格的具体用法</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>单元格内的文字<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><code>&lt;table&gt; &lt;/table&gt;</code> 是用于定义表格的标签。</li><li><code>&lt;tr&gt; &lt;/tr&gt;</code> 标签用于定义表格中的行，必须嵌套在 <code>&lt;table&gt; &lt;/table&gt;</code>标签中。</li><li><code>&lt;td&gt; &lt;/td&gt; 用于定义表格中的单元格，必须嵌套在</code><tr></tr>`标签中。</li><li>字母 <code>td</code> 指表格数据（table data），即数据单元格的内容。</li></ol><h3 id="表头单元格标签"><a class="header-anchor" href="#表头单元格标签"></a>表头单元格标签</h3><p>表头标签的具体实现：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>一般表头单元格位于表格的第一行或第一列，表头单元格里面的文本内容加粗居中显示。<code>&lt;th&gt;</code> 标签表示 HTML 表格的表头部分（table head 的缩写）</li><li>表头单元格也是单元格，常用于表格第一行突出重要性，表头单元格里面的文字会加粗居中</li></ol><h3 id="表格属性"><a class="header-anchor" href="#表格属性"></a>表格属性</h3><p>表格标签<code>&lt;table&gt;</code>这部分属性我们实际开发我们不常用，后面通过 CSS 来设置</p><table><thead><tr><th>属性名</th><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>align</td><td>left、center、right</td><td>规定表格相对周围元素的对齐方式</td></tr><tr><td>border</td><td>1或&quot;&quot;</td><td>规定表格单元是否拥有边框，默认为&quot;&quot;，表示没有边框</td></tr><tr><td>cellpadding</td><td>像素值</td><td>规定单元边沿与其内容之间的空白，默认1像素</td></tr><tr><td>cellspacing</td><td>像素值</td><td>规定单元格之间的空白，默认2像素</td></tr><tr><td>width</td><td>像素值或百分比</td><td>规定表格的宽度</td></tr></tbody></table><h3 id="表格结构标签"><a class="header-anchor" href="#表格结构标签"></a>表格结构标签</h3><p>使用场景:因为表格可能很长,为了更好的表示表格的语义，可以将表格分割成 表格头部和表格主体两大部分。在表格标签中，分别用：<code>&lt;thead&gt;</code>标签 表格的头部区域、<code>&lt;tbody&gt;</code>标签 表格的主体区域. 这样可以更好的分清表格结构。</p><p>总结:</p><ol><li><code>&lt;thead&gt;&lt;/thead&gt;</code>：用于定义表格的头部。<code>&lt;thead&gt;</code> 内部必须拥有 <code>&lt;tr&gt;</code> 标签。 一般是位于第一行。</li><li><code>&lt;tbody&gt;&lt;/tbody&gt;</code>：用于定义表格的主体，主要用于放数据本体 。</li><li>以上标签都是放在 <code>&lt;table&gt;&lt;/table&gt;</code> 标签中。</li></ol><h3 id="合并单元格"><a class="header-anchor" href="#合并单元格"></a>合并单元格</h3><p>合并单元格方式：</p><ol><li>跨行合并：<code>rowspan=&quot;合并单元格的个数&quot;</code>，最上侧单元格为目标单元格, 写合并代码</li><li>跨列合并：<code>colspan=&quot;合并单元格的个数&quot;</code>，最左侧单元格为目标单元格, 写合并代码</li></ol><p>合并单元格三步曲：</p><ol><li>先确定是跨行还是跨列合并。</li><li>找到目标单元格。写上合并方式 = 合并的单元格数量。比如：<code>&lt;td colspan=&quot;2&quot;&gt;&lt;/td&gt;</code>。</li><li>删除多余的单元格。</li></ol><h2 id="列表"><a class="header-anchor" href="#列表"></a>列表</h2><p>表格是用来显示数据的，那么列表就是用来布局的。 列表最大的特点就是整齐、整洁、有序，它作为布局会更加自由和方便。</p><p>根据使用情景不同，列表可以分为三大类：无序列表、有序列表和自定义列表。</p><h3 id="无序列表"><a class="header-anchor" href="#无序列表"></a>无序列表</h3><p><code>&lt;ul&gt;</code> 标签表示 HTML 页面中项目的无序列表，一般会以项目符号呈现列表项，而列表项使用 <code>&lt;li&gt;</code> 标签定义。无序列表的基本语法格式如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  ... </span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>无序列表的各个列表项之间没有顺序级别之分，是并列的。</li><li><code>&lt;ul&gt;&lt;/ul&gt;</code> 中只能嵌套 <code>&lt;li&gt;&lt;/li&gt;</code>，直接在 <code>&lt;ul&gt;&lt;/ul&gt;</code> 标签中输入其他标签或者文字的做法是不被允许的。</li><li><code>&lt;li&gt;</code> 与 <code>&lt;/li&gt;</code> 之间相当于一个容器，可以容纳所有元素。</li><li>无序列表会带有自己的样式属性，但在实际使用时，我们会使用 CSS 来设置。</li></ol><h3 id="有序列表"><a class="header-anchor" href="#有序列表"></a>有序列表</h3><p>有序列表即为有排列顺序的列表，其各个列表项会按照一定的顺序排列定义。在 HTML 标签中，<code>&lt;ol&gt;</code> 标签用于定义有序列表，列表排序以数字来显示，并且使用 <code>&lt;li&gt;</code> 标签来定义列表项。有序列表的基本语法格式如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  ... </span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><code>&lt;ol&gt;&lt;/ol&gt;</code>中只能嵌套<code>&lt;li&gt;&lt;/li&gt;</code>，直接在<code>&lt;ol&gt;&lt;/ol&gt;</code>标签中输入其他标签或者文字的做法是不被允许的。</li><li><code>&lt;li&gt;</code> 与 <code>&lt;/li&gt;</code>之间相当于一个容器，可以容纳所有元素。</li><li>有序列表会带有自己样式属性，但在实际使用时，我们会使用 CSS 来设置。</li></ol><h3 id="自定义列表"><a class="header-anchor" href="#自定义列表"></a>自定义列表</h3><p>自定义列表的使用场景:自定义列表常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号。在 HTML 标签中，<code>&lt;dl&gt;</code> 标签用于定义描述列表（或定义列表），该标签会与 <code>&lt;dt&gt;</code>（定义项目/名字）和 <code>&lt;dd&gt;</code>（描述每一个项目/名字）一起使用。语法如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span>名词1<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>名词1解释1<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>名词1解释2<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用规则同上</p><h2 id="表单"><a class="header-anchor" href="#表单"></a>表单</h2><p>使用表单目的是为了收集用户信息。在我们网页中， 我们也需要跟用户进行交互，收集用户资料，此时就需要表单。</p><p>在 HTML 中，一个完整的表单通常由<font color="#FF666">表单域</font>、<font color="#FF666">表单控件</font>（也称为表单元素）和 提示信息3个部分构成。</p><h3 id="表单域"><a class="header-anchor" href="#表单域"></a>表单域</h3><p>表单域是一个包含表单元素的区域。</p><p>在 HTML 标签中， <code>&lt;form&gt;</code> 标签用于定义表单域，以实现用户信息的收集和传递。</p><p><code>&lt;form&gt;</code> 会把它范围内的表单元素信息提交给服务器。实现代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">“url地址”</span> <span class="attr">method</span>=<span class="string">“提交方式”</span> <span class="attr">name</span>=<span class="string">“表单域名称</span>&quot;&gt;</span></span><br><span class="line">  各种表单元素控件</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>表单域的常用属性：</p><table><thead><tr><th>属性名</th><th>属性值</th><th>作用</th></tr></thead><tbody><tr><td>action</td><td>URL地址</td><td>用于指定接收并处理表单数据的服务器程序的url地址</td></tr><tr><td>method</td><td>get/p</td><td>用于设置表单数据的提交方式，其取值为get或post</td></tr><tr><td>name</td><td>名称</td><td>用于指定表单的名称，以区分同一个页面中的多个表单域</td></tr></tbody></table><h3 id="表单控件-表单元素"><a class="header-anchor" href="#表单控件-表单元素"></a>表单控件(表单元素)</h3><p><code>&lt;input&gt;</code> 表单元素</p><p>在英文单词中，input 是输入的意思，而在表单元素中 <code>&lt;input&gt;</code> 标签用于收集用户信息。在 <code>&lt;input&gt;</code> 标签中，包含一个 type 属性，根据不同的 type 属性值，输入字段拥有很多种形式（可以是文本字段、复选框、掩码后的文本控件、单选按钮、按钮等）。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;属性值&quot;</span>  /&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;input /&gt;</code> 标签为单标签 type 属性设置不同的属性值用来指定不同的控件类型，type 属性的属性值及其描述如下：</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>button</td><td>定义可点击按钮（多数情况下，用于通过 JavaScript 启动脚本）。</td></tr><tr><td>checkbox</td><td>定义复选框。</td></tr><tr><td>file</td><td>定义输入字段和 &quot;浏览&quot;按钮，供文件上传。</td></tr><tr><td>hidden</td><td>定义隐藏的输入字段。</td></tr><tr><td>image</td><td>定义图像形式的提交按钮。</td></tr><tr><td>password</td><td>定义密码字段。该字段中的字符被掩码。</td></tr><tr><td>radio</td><td>定义单选按钮。</td></tr><tr><td>reset</td><td>定义重置按钮。重置按钮会清除表单中的所有数据。</td></tr><tr><td>submit</td><td>定义提交按钮。提交按钮会把表单数据发送到服务器。</td></tr><tr><td>text</td><td>定义单行的输入字段，用户可在其中输入文本。默认宽度为 20 个字符。</td></tr></tbody></table><p>除 type 属性外，<code>&lt;input/&gt;</code>标签还有其他很多属性，其常用属性如下：</p><table><thead><tr><th>属性</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://www.w3school.com.cn/tags/att_input_name.asp">name</a></td><td>field_name</td><td>定义 input 元素的名称</td></tr><tr><td><a href="https://www.w3school.com.cn/tags/att_input_value.asp">value</a></td><td>value</td><td>规定 input 元素的值</td></tr><tr><td><a href="https://www.w3school.com.cn/tags/att_input_checked.asp">checked</a></td><td>checked</td><td>规定此 input 元素首次加载时应当被选中</td></tr><tr><td><a href="https://www.w3school.com.cn/tags/att_input_maxlength.asp">maxlength</a></td><td>number</td><td>规定输入字段中的字符的最大长度</td></tr></tbody></table><ol><li>name 和 value 是每个表单元素都有的属性值，主要给后台人员使用。</li><li>name 表单元素的名字，要求单选按钮和复选框要有相同的name值。</li><li>checked属性主要针对于单选按钮和复选框主要作用一打开页面，就要可以默认选中某个表单元素。</li></ol><h3 id="标签"><a class="header-anchor" href="#标签"></a>标签</h3><p><code>&lt;label&gt;</code> 标签为 input 元素定义标注（标签）。</p><p><code>&lt;label&gt;</code> 标签用于绑定一个表单元素, 当点击<code>&lt;label&gt;</code> 标签内的文本时，浏览器就会自动将焦点(光标)转到或者选择对应的表单元素上，用来增加用户体验。语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;sex&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span>  <span class="attr">id</span>=<span class="string">&quot;sex&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>核心：<code>&lt;label&gt;</code> 标签的 for 属性应当与相关元素的 id 属性相同。</p><h3 id="下拉框"><a class="header-anchor" href="#下拉框"></a>下拉框</h3><p><code>&lt;select&gt;</code> 下拉框，使用场景: 在页面中，如果有多个选项让用户选择，并且想要节约页面空间时，我们可以使用<code>&lt;select&gt;</code>标签控件定义下拉列表。</p><p>语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">option</span>&gt;</span>选项1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">option</span>&gt;</span>选项2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">option</span>&gt;</span>选项3<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">   ...</span><br><span class="line"> <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><code>&lt;select&gt;</code> 中至少包含一对<code>&lt;option&gt;</code></li><li>在<code>&lt;optioq&gt;</code>中定义<code>selected =&quot;selected&quot;</code>时，当前项即为默认选中项</li></ol><h3 id="文本域"><a class="header-anchor" href="#文本域"></a>文本域</h3><p><code>&lt;textarea&gt;</code> 文本域</p><ol><li>使用场景: 当用户输入内容较多的情况下，我们就不能使用文本框表单了，此时我们可以使用 <code>&lt;textarea&gt;</code> 标签。</li><li>在表单元素中，<code>&lt;textarea&gt;</code> 标签是用于定义多行文本输入的控件。</li><li>使用多行文本输入控件，可以输入更多的文字，该控件常见于留言板，评论。</li></ol><p>语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">rows</span>=<span class="string">&quot;3&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;20&quot;</span>&gt;</span> 文本内容 <span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过 <code>&lt;textarea&gt;</code> 标签可以轻松地创建多行文本输入框。<code>cols=&quot;每行中的字符数&quot;</code> ，<code>rows=&quot;显示的行数&quot;</code>。我们在实际开发中不会使用，都是用 CSS 来改变大小。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1pE411q7FU&quot;&gt;Web前端入门教程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.w3school.com.cn/&quot;&gt;W3C</summary>
      
    
    
    
    <category term="Web前端" scheme="http://halo123.top/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="HTML" scheme="http://halo123.top/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>计划与记录</title>
    <link href="http://halo123.top/2021/04/18/%E8%A7%84%E5%88%92/%E8%AE%A1%E5%88%92%E4%B8%8E%E8%AE%B0%E5%BD%95/"/>
    <id>http://halo123.top/2021/04/18/%E8%A7%84%E5%88%92/%E8%AE%A1%E5%88%92%E4%B8%8E%E8%AE%B0%E5%BD%95/</id>
    <published>2021-04-18T12:09:48.846Z</published>
    <updated>2021-04-22T16:15:37.838Z</updated>
    
    <content type="html"><![CDATA[<h2 id="⏳自律的人有多可怕"><a class="header-anchor" href="#⏳自律的人有多可怕"></a>⏳自律的人有多可怕</h2><ul><li>我的梦想到底是什么，我有为此付出过什么吗</li><li>无特殊情况，一天至少8小时考研学习时间</li><li>其中每天原神时间不超过40分钟</li><li>不许带手机到床上</li><li>1点前要睡觉</li><li>锻炼？</li></ul><h2 id="📝每日计划及记录"><a class="header-anchor" href="#📝每日计划及记录"></a>📝每日计划及记录</h2><h3 id="2021年4月25日"><a class="header-anchor" href="#2021年4月25日"></a>2021年4月25日</h3><details ><summary> 2021年4月25日小结 </summary>              <div class='content'>              <p>今天主要处理了博客的移动端的适配</p>              </div>            </details><h3 id="2021年4月24日"><a class="header-anchor" href="#2021年4月24日"></a>2021年4月24日</h3><div class='checkbox checked'><input type="checkbox" checked="checked"/>            <p>17:30，一号楼二阶二，党日活动</p>            </div><details ><summary> 4月24日小结 </summary>              <div class='content'>              <p>今天从8点又开始弄样式，看到了这位博主的<a href="https://blog.zhheo.com/">主页</a>，看来还有好多要学的</p>              </div>            </details><h3 id="2021年4月23日"><a class="header-anchor" href="#2021年4月23日"></a>2021年4月23日</h3><table><thead><tr><th>内容</th><th>备注</th><th>用时</th><th>完成情况</th></tr></thead><tbody><tr><td>数据结构完成前两章整理学习内容</td><td></td><td></td><td></td></tr><tr><td>线性代数矩阵整理学习</td><td></td><td></td><td></td></tr><tr><td>高等数学复习函数</td><td></td><td></td><td></td></tr><tr><td>学习英语7000词1P</td><td></td><td></td><td></td></tr></tbody></table><details ><summary> 4月23日小结 </summary>              <div class='content'>              <p>昨天弄博客主题结果上头了，弄到了3点</p>              </div>            </details><h3 id="2021年4月22日"><a class="header-anchor" href="#2021年4月22日"></a>2021年4月22日</h3><p><strong>待办事项</strong></p><div class='checkbox checked'><input type="checkbox" checked="checked"/>            <p>17:30-18:55，一号楼204，形势与政策</p>            </div><div class='checkbox checked'><input type="checkbox" checked="checked"/>            <p>进化生物学作业</p>            </div><p><strong>考研规划表</strong></p><table><thead><tr><th>内容</th><th>备注</th><th>用时</th><th>完成情况</th></tr></thead><tbody><tr><td>学完操作系统第2章</td><td>学到<a href="https://www.bilibili.com/video/BV1YE411D7nH?t=4&amp;p=33">P33</a></td><td>5h</td><td>✔</td></tr><tr><td>学1P题源7000词</td><td>学完<a href="https://www.bilibili.com/video/BV12E411B7A5?p=3&amp;spm_id_from=pageDriver">P2</a></td><td>2.5h</td><td>✔</td></tr><tr><td>对计算机网络前两章进行复习整理</td><td></td><td>20min</td><td>✔</td></tr><tr><td>对数据结构前两章进行复习整理</td><td></td><td></td><td>❌</td></tr><tr><td>对计算机组成原理前两章进行复习整理</td><td></td><td></td><td>❌</td></tr><tr><td>可以的话对线性代数第一章进行复习整理</td><td></td><td></td><td>❌</td></tr></tbody></table><p><strong>时间统计</strong></p><table><thead><tr><th>项目</th><th>时间</th><th>备注</th></tr></thead><tbody><tr><td>Typora</td><td>5:59:20</td><td>写文档</td></tr><tr><td>浏览器</td><td>4:34:39</td><td>学习课程</td></tr><tr><td>原神</td><td>0:46:09</td><td>日常任务，9次火本</td></tr><tr><td>进化生物学作业</td><td>40min左右</td><td></td></tr></tbody></table><details ><summary> 2021年4月22日小结 </summary>              <div class='content'>              <p>今天学了不少内容，但是通过做题发现学的不够深，还需要及时复习。</p><p>至于下一阶段，我觉得先开始复习数据结构，数学，以及英语，这些数据结构和数学对计组、网络和操作系统记忆内容相对较少，可以先复习，英语要坚持下去。政治等这些课程一轮复习完成后在开始背吧。</p>              </div>            </details><h3 id="2021年4月21日"><a class="header-anchor" href="#2021年4月21日"></a>2021年4月21日</h3><table><thead><tr><th>内容</th><th>备注</th><th>用时</th><th>完成情况</th></tr></thead><tbody><tr><td>学习操作系统并进行相关资料整理</td><td>从<a href="https://www.bilibili.com/video/BV1YE411D7nH?p=22&amp;spm_id_from=pageDriver">P16-P22</a></td><td>4h</td><td>✔</td></tr><tr><td>学习数据结构</td><td></td><td></td><td>❌</td></tr><tr><td>学单词</td><td><a href="https://www.bilibili.com/video/BV12E411B7A5?t=2948">P1 50:00</a></td><td></td><td>✔</td></tr></tbody></table><p><strong>时间统计</strong></p><table><thead><tr><th>项目</th><th>时间</th><th>备注</th></tr></thead><tbody><tr><td>浏览器</td><td>8:05:25</td><td>整理资料，学习课程</td></tr><tr><td>Typora</td><td>4:15:40</td><td>写文档</td></tr><tr><td>原神</td><td>0:15:09</td><td>日常任务</td></tr></tbody></table><details ><summary> 2021年4月21日小结 </summary>              <div class='content'>              <p>今天整理了有关<a href="http://blog.halo123.top:8090/archives/%E8%80%83%E7%A0%94%E8%B5%84%E6%96%99%E6%94%B6%E9%9B%86">考研资料</a>，也对考研计划进行了细化，还有有好多任务需要完成</p><blockquote><p>Doctor，您还有许多事要处理，现在还不能休息（阿米娅_严肃）</p></blockquote><p>时间主要花在了收集和整理资料中，也是通过对资料的整理才更清楚自己要学些什么，对于基础相对薄弱的科目(说的就是你英语)，还是要老老实实看视频跟着老师去学，一些规律还是要有一定经验的人教授才更方便理解。</p><p>而学不在于学多少，在于有多少被吸收成为自己的知识。之前没注意考研时间，现在发现只剩下246天，对我来说时间是有些紧张了。</p><p>最近有关的一些社会新闻，就如特斯拉维权频频出现在消息中。<a href="https://t.bilibili.com/516161348504803949?tab=2">中消协对此事回应</a></p><p>顺便一提，今天发布的 M1 芯片的 Ipad Pro 确实有些在我的意料之外，但也是情理之中，打通各平台的生态圈，这是其他品牌难以做到的一件事，这也会成为苹果公司一张大牌，只能说技术是产品竞争的关键。</p>              </div>            </details><h3 id="2021年4月20日"><a class="header-anchor" href="#2021年4月20日"></a>2021年4月20日</h3><p><strong>每日计划</strong></p><div class='checkbox checked'><input type="checkbox" checked="checked"/>            <p>学习前端，<a href="https://www.bilibili.com/video/BV1pE411q7FU?p=84&amp;spm_id_from=pageDriver">Web前端入门教程 P61-P84</a></p>            </div><div class='checkbox'><input type="checkbox" />            <p>学习操作系统并整理资料</p>            </div><div class='checkbox'><input type="checkbox" />            <p>学习数据结构</p>            </div><div class='checkbox'><input type="checkbox" />            <p>背单词</p>            </div><div class='checkbox checked'><input type="checkbox" checked="checked"/>            <p>15:00至16:00，红船边的思政课主题直播活动。今晚10点前上交一份观后感（字数不得少于400字）</p>            </div><p><strong>时间统计</strong></p><table><thead><tr><th>项目</th><th>时间</th><th>备注</th></tr></thead><tbody><tr><td>浏览器</td><td>6:07:42</td><td>看视频，学前端课程，写博客，看B站动态，看知乎</td></tr><tr><td>Typora</td><td>1:03:26</td><td>写观后感，写博客</td></tr><tr><td>原神</td><td>0:48:09</td><td>日常任务，龙，4浓缩树脂，9层深渊</td></tr><tr><td>Word</td><td>0:12:20</td><td>写观后感</td></tr></tbody></table><details ><summary> 2021年4月20日小结 </summary>              <div class='content'>              <p>几天晚上上完课回来，写了观后感后，在b站看到央视新闻的<a href="https://t.bilibili.com/515733926241528411">动态</a>，被评论区@到一个<a href="https://space.bilibili.com/23947287">UP</a>，为了吃瓜看了些视频，结果越看越深，看的视频如下：</p><ul><li><a href="https://www.bilibili.com/video/BV11i4y1L7QQ">苏联为何而强大？【小约翰】</a></li><li><a href="https://www.bilibili.com/video/BV1zZ4y1H7h2">你真的了解切格瓦拉吗？带你走进精神领袖伟大的一生【历史故事会】</a></li><li><a href="https://www.bilibili.com/video/BV1Z54y1m7FB">美国是如何走向世界舞台的【财经故事会】</a></li><li><a href="https://www.bilibili.com/video/BV1fk4y1B7tv">兔子的大布局：人民币国际化</a></li><li><a href="https://www.bilibili.com/video/BV1NT4y1j7J8">何以成为苏联争议最大的领导人？带你走进斯大林波澜壮阔的一生【有机社会Vol.16】</a></li><li><a href="https://www.bilibili.com/video/BV1m54y1Y7r3">我们到底在走一条什么路？共同富裕最终能实现吗？【有机社会32】</a></li></ul><p>对于视频中的一些观点需要辩证的看待，从侧面也反映出我的历史知识的匮乏，在感想中我写到</p><blockquote><p>学党史，学的不仅是历史，更是精神，而很多精神难以从黑白纸张中感受到，当与物与人与环境，多方面多角度的“对话”，一件历史中发生的某些事的细节可能会忘记，但是历史带给我们的激励作用将会一直伴随。</p></blockquote><p>历史的重要性不言而喻，而我想要了解真实的历史是一件非常难的事，仅从现在来看，我们正处于未来的历史当中，疫情、日本核排放这些事终将会写入历史书中，但身处历史中也难以了解全貌，更何况用十多分钟的视频来概括一个世纪的故事。我们站在制高点俯瞰和中山底仰视看到的风景是截然不同的。</p><p>突然想到，我之前也这样写过总结，打开看竟是去年9月开始的时候，emm只坚持了两天，话说也过去了怎么久了，当再次看到当时的总结，感觉回忆突然涌了上来，这是真的。相比较不知不觉中过日子，不如让每天都有纪念意义，我曾经以为仪式是虚的，但现在就当做开始记录的小仪式吧。感觉有点自言自语有些奇怪。</p><p>正经人谁写日记啊，我又不是什么正经人，ko no ya rou ！</p>              </div>            </details><h3 id="2021年4月19日"><a class="header-anchor" href="#2021年4月19日"></a>2021年4月19日</h3><ul><li>[X] 学习前端，<a href="https://www.bilibili.com/video/BV1pE411q7FU?p=61&amp;spm_id_from=pageDriver">Web前端入门教程 P42-P61</a></li><li>[ ] 学习操作系统并整理资料</li><li>[ ] 学习数据结构</li><li>[ ] 背单词</li></ul><details ><summary> 2021年4月19日小结 </summary>              <div class='content'>              <ul><li>打疫苗</li><li>看《哥斯拉大战金刚》体验不是很好，声音太大了，3D还是带夹片吧，对近视很不友好</li></ul>              </div>            </details><h3 id="2021年4月18日"><a class="header-anchor" href="#2021年4月18日"></a>2021年4月18日</h3><ul><li>[X] 学习前端，<a href="https://www.bilibili.com/video/BV1pE411q7FU?p=42&amp;spm_id_from=pageDriver">Web前端入门教程 P1-P41 </a></li></ul><details ><summary> 2021年4月18日小结 </summary>              <div class='content'>              <p>知乎上看到的中科院自动化所的博士论文致谢的消息。<a href="https://www.zhihu.com/question/454961393">网站链接</a></p><p>看完后也是十分触动，我也是农村出来的，不富裕，而生活在现在的环境中让我产生了逃避的想法，一箪食一瓢饮的生活对我来说并没有什么不好，但对于社会环境来说，只是要活的体面，照成贫穷原因有很多，与环境与自身，当上一辈人确实因为环境等因素制约了发展，但对于我来说，有着足够的条件来过上好生活，但如果还不向上努力，便是自身的因素。我可以选择过平淡的人生，但是我也从来不是没有独立思想，随波逐流的人。</p><p>屈原与渔夫的故事我印象非常深，选择“宁赴湘流，葬于江鱼之腹中。安能以皓皓之白，而蒙世俗之尘埃乎”与“沧浪之水清兮，可以濯吾缨；沧浪之水浊兮，可以濯吾足。”那时候我的答案是屈原，当别人多数人选择了渔夫时，我是有些不解，但这快4年下来，我也渐渐被“磨平棱角”，这件事没有谁对谁错，如果以马原来选择那就是”因地制宜“，总之有些晚了我要碎觉了。</p>              </div>            </details><h2 id="每周任务"><a class="header-anchor" href="#每周任务"></a>每周任务</h2><h3 id="2021年第15周"><a class="header-anchor" href="#2021年第15周"></a>2021年第15周</h3><ul><li>[X] 青年大学习</li><li>[ ] 看一篇英文文献并记录</li></ul><h2 id="每月计划"><a class="header-anchor" href="#每月计划"></a>每月计划</h2><h3 id="2021年4月"><a class="header-anchor" href="#2021年4月"></a>2021年4月</h3><table><thead><tr><th>计划内容</th><th>创建</th><th>开始时间</th><th>计划结束时间</th><th>结果</th></tr></thead><tbody><tr><td>学完《操作系统》</td><td>2021年4月21日00点22分</td><td></td><td></td><td></td></tr></tbody></table><h2 id="考研各项目规划"><a class="header-anchor" href="#考研各项目规划"></a>考研各项目规划</h2><h3 id="操作系统"><a class="header-anchor" href="#操作系统"></a>操作系统</h3><table><thead><tr><th>学习内容</th><th>开始时间</th><th>结束时间</th><th>学习结果</th></tr></thead><tbody><tr><td>计算机系统概述</td><td>2021年3月29日</td><td>2021年3月31日</td><td><a href="http://blog.halo123.top:8090/archives/overviewofcomputersystems">文章链接</a></td></tr><tr><td>进程管理</td><td>2021年4月1日</td><td>2021年4月22日</td><td><a href="http://blog.halo123.top:8090/archives/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86">文章链接</a></td></tr><tr><td>内存管理</td><td></td><td></td><td></td></tr><tr><td>文件管理</td><td></td><td></td><td></td></tr><tr><td>I/O管理</td><td></td><td></td><td></td></tr></tbody></table><h3 id="数据结构"><a class="header-anchor" href="#数据结构"></a>数据结构</h3><table><thead><tr><th>学习内容</th><th>开始时间</th><th>结束时间</th><th>学习结果</th></tr></thead><tbody><tr><td>绪论</td><td>3月</td><td>3月</td><td></td></tr><tr><td>线性表</td><td>3月</td><td>3月</td><td></td></tr><tr><td>栈和队列</td><td>3月</td><td></td><td></td></tr><tr><td>串</td><td></td><td></td><td></td></tr><tr><td>树和二叉树</td><td></td><td></td><td></td></tr><tr><td>图</td><td></td><td></td><td></td></tr><tr><td>查找</td><td></td><td></td><td></td></tr><tr><td>排序</td><td></td><td></td><td></td></tr></tbody></table><h3 id="计算机组成原理"><a class="header-anchor" href="#计算机组成原理"></a>计算机组成原理</h3><table><thead><tr><th>学习内容</th><th>开始时间</th><th>结束时间</th><th>学习结果</th></tr></thead><tbody><tr><td>计算机系统概述</td><td>3月</td><td>3月</td><td></td></tr><tr><td>数据的表示和运算</td><td>3月</td><td></td><td></td></tr><tr><td>储存系统</td><td></td><td></td><td></td></tr><tr><td>指令系统</td><td></td><td></td><td></td></tr><tr><td>中央处理器</td><td></td><td></td><td></td></tr><tr><td>总线</td><td></td><td></td><td></td></tr><tr><td>输入/输出系统</td><td></td><td></td><td></td></tr></tbody></table><h3 id="计算机网络"><a class="header-anchor" href="#计算机网络"></a>计算机网络</h3><table><thead><tr><th>学习内容</th><th>开始时间</th><th>结束时间</th><th>学习结果</th></tr></thead><tbody><tr><td>计算机网络体系结构</td><td>3月</td><td>3月</td><td></td></tr><tr><td>物理层</td><td>3月</td><td>3月</td><td></td></tr><tr><td>数据链路层</td><td></td><td></td><td></td></tr><tr><td>网络层</td><td></td><td></td><td></td></tr><tr><td>传输层</td><td></td><td></td><td></td></tr><tr><td>应用层</td><td></td><td></td><td></td></tr></tbody></table><h3 id="线性代数"><a class="header-anchor" href="#线性代数"></a>线性代数</h3><table><thead><tr><th>学习内容</th><th>开始时间</th><th>结束时间</th><th>学习结果</th></tr></thead><tbody><tr><td>行列式</td><td>3月</td><td>3月</td><td></td></tr><tr><td>矩阵</td><td>3月</td><td></td><td></td></tr><tr><td>向量</td><td></td><td></td><td></td></tr><tr><td>线性方程组</td><td></td><td></td><td></td></tr><tr><td>特征值和特征向量</td><td></td><td></td><td></td></tr><tr><td>二次型</td><td></td><td></td><td></td></tr></tbody></table><h3 id="概率论与梳理统计"><a class="header-anchor" href="#概率论与梳理统计"></a>概率论与梳理统计</h3><table><thead><tr><th>学习内容</th><th>开始时间</th><th>结束时间</th><th>学习结果</th></tr></thead><tbody><tr><td>随机时间和概率</td><td></td><td></td><td></td></tr><tr><td>随机变量及其概论分布</td><td></td><td></td><td></td></tr><tr><td>多维随机变量及其分布</td><td></td><td></td><td></td></tr><tr><td>随机变量的数字特征</td><td></td><td></td><td></td></tr><tr><td>大数定理和中心极限定理</td><td></td><td></td><td></td></tr><tr><td>数理统计的基本概念</td><td></td><td></td><td></td></tr><tr><td>参数估计</td><td></td><td></td><td></td></tr><tr><td>假设检验</td><td></td><td></td><td></td></tr></tbody></table><h3 id="高等数学"><a class="header-anchor" href="#高等数学"></a>高等数学</h3><table><thead><tr><th>学习内容</th><th>开始时间</th><th>结束时间</th><th>学习结果</th></tr></thead><tbody><tr><td>函数、极限、连续</td><td></td><td></td><td></td></tr><tr><td>导数与微分</td><td></td><td></td><td></td></tr><tr><td>微分中值定理及导数应用</td><td></td><td></td><td></td></tr><tr><td>不定积分</td><td></td><td></td><td></td></tr><tr><td>定积分与反常积分</td><td></td><td></td><td></td></tr><tr><td>定积分的应用</td><td></td><td></td><td></td></tr><tr><td>微分方程</td><td></td><td></td><td></td></tr><tr><td>多元函数微分学</td><td></td><td></td><td></td></tr><tr><td>二重积分</td><td></td><td></td><td></td></tr><tr><td>无穷级数</td><td></td><td></td><td></td></tr><tr><td>向量代数与空间解析几何及多元微分学在几何上的应用</td><td></td><td></td><td></td></tr><tr><td>多元积分学及其应用</td><td></td><td></td><td></td></tr></tbody></table><h3 id="思想道德修养与法律基础"><a class="header-anchor" href="#思想道德修养与法律基础"></a>思想道德修养与法律基础</h3><h3 id="毛泽东思想和中国特色社会主义理论体系概论"><a class="header-anchor" href="#毛泽东思想和中国特色社会主义理论体系概论"></a>毛泽东思想和中国特色社会主义理论体系概论</h3><h3 id="马克思主义基本原理概论"><a class="header-anchor" href="#马克思主义基本原理概论"></a>马克思主义基本原理概论</h3><h3 id="中国近代史纲要"><a class="header-anchor" href="#中国近代史纲要"></a>中国近代史纲要</h3><h3 id="英语词汇"><a class="header-anchor" href="#英语词汇"></a>英语词汇</h3><table><thead><tr><th>学习内容</th><th>开始时间</th><th>结束时间</th><th>学习结果</th></tr></thead><tbody><tr><td>题源报刊7000词Unit 1</td><td>2021年4月21日</td><td></td><td></td></tr></tbody></table><h3 id="英语语法"><a class="header-anchor" href="#英语语法"></a>英语语法</h3><h3 id="英语核心长难句"><a class="header-anchor" href="#英语核心长难句"></a>英语核心长难句</h3><h3 id="英语强化练习"><a class="header-anchor" href="#英语强化练习"></a>英语强化练习</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;⏳自律的人有多可怕&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#⏳自律的人有多可怕&quot;&gt;&lt;/a&gt;⏳自律的人有多可怕&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;我的梦想到底是什么，我有为此付出过什么吗&lt;/li&gt;
&lt;li&gt;无特殊情况，一天至少8小时考研学习时间&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>创建型模式之简单工厂模式</title>
    <link href="http://halo123.top/2021/04/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://halo123.top/2021/04/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-04-18T10:04:00.612Z</published>
    <updated>2021-04-18T10:10:47.571Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单工厂模式概述"><a class="header-anchor" href="#简单工厂模式概述"></a>简单工厂模式概述</h2><p>简单工厂模式并不属于GoF 23个经典设计模式，但通常将它作为学习其他工厂模式的基础，它的设计思想很简单，其基本流程如下：</p><ol><li>首先将需要创建的各种不同对象（例如各种不同的Chart对象）的相关代码封装到不同的类中，这些类称为具体产品类，而将它们公共的代码进行抽象和提取后封装在一个抽象产品类中，每一个具体产品类都是抽象产品类的子类；</li><li>然后提供一个工厂类用于创建各种产品，在工厂类中提供一个创建产品的工厂方法，该方法可以根据所传入的参数不同创建不同的具体产品对象；</li><li>客户端只需调用工厂类的工厂方法并传入相应的参数即可得到一个产品对象。</li></ol><p>简单工厂模式定义如下：</p><p>简单工厂模式(Simple Factory Pattern)：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。</p><p>因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。</p><p>简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。</p><h2 id="简单工厂模式结构"><a class="header-anchor" href="#简单工厂模式结构"></a>简单工厂模式结构</h2><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84.png" alt="简单工厂模式结构" style="object-fit: cover; border-radius: 10px; width: 100%;" /><p>在简单工厂模式结构中包含如下几个角色：</p><ul><li>Factory（工厂角色）：工厂角色即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂方法<code>factoryMethod()</code>，它的返回类型为抽象产品类型Product。</li><li>Product（抽象产品角色）：它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法，它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。</li><li>ConcreteProduct（具体产品角色）：它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法。</li></ul><h2 id="简单工厂模式实现"><a class="header-anchor" href="#简单工厂模式实现"></a>简单工厂模式实现</h2><p>在简单工厂模式中，客户端通过工厂类来创建一个产品类的实例，而无须直接使用<code>new</code>关键字来创建对象，它是工厂模式家族中最简单的一员。</p><p>在使用简单工厂模式时，首先需要对产品类进行重构，不能设计一个包罗万象的产品类，而需根据实际情况设计一个产品层次结构，将所有产品类公共的代码移至抽象产品类，并在抽象产品类中声明一些抽象方法，以供不同的具体产品类来实现，典型的抽象产品类代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="comment">//所有产品类的公共业务方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodSame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//公共方法的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//声明抽象业务方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">methodDiff</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在具体产品类中实现了抽象产品类中声明的抽象业务方法，不同的具体产品类可以提供不同的实现，典型的具体产品类代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实现业务方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodDiff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//业务方法的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单工厂模式的核心是工厂类，在没有工厂类之前，客户端一般会使用<code>new</code>关键字来直接创建产品对象，而在引入工厂类之后，客户端可以通过工厂类来创建产品，在简单工厂模式中，工厂类提供了一个静态工厂方法供客户端使用，根据所传入的参数不同可以创建不同的产品对象，典型的工厂类代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//静态工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title">getProduct</span><span class="params">(String arg)</span> </span>&#123;</span><br><span class="line">        Product product = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (arg.equalsIgnoreCase(<span class="string">&quot;A&quot;</span>)) &#123;</span><br><span class="line">            product = <span class="keyword">new</span> ConcreteProductA();</span><br><span class="line">            <span class="comment">//初始化设置product</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arg.equalsIgnoreCase(<span class="string">&quot;B&quot;</span>)) &#123;</span><br><span class="line">            product = <span class="keyword">new</span> ConcreteProductB();</span><br><span class="line">            <span class="comment">//初始化设置product</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在客户端代码中，我们通过调用工厂类的工厂方法即可得到产品对象，典型代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Product product;</span><br><span class="line">        product = Factory.getProduct(<span class="string">&quot;A&quot;</span>); <span class="comment">//通过工厂类创建产品对象</span></span><br><span class="line">        product.methodSame();</span><br><span class="line">        product.methodDiff();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单工厂模式应用实例"><a class="header-anchor" href="#简单工厂模式应用实例"></a>简单工厂模式应用实例</h2><p>通过设置不同参数即可得到不同类型的图表，且能易扩展。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B%E7%BB%93%E6%9E%84.png" alt="简单工厂模式应用实例结构" style="object-fit: cover; border-radius: 20px; width: 100%;" /><p><code>Chart</code>接口充当抽象产品类，其子类<code>HistogramChart</code>、<code>PieChart</code>和<code>LineChart</code>充当具体产品类，<code>ChartFactory</code>充当工厂类。完整代码如下所示：</p><ol><li><p><code>Chart</code>：抽象图表接口，充当抽象产品类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Chart</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>HistogramChart</code>：柱状图类，充当具体产品类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HistogramChart</span> <span class="keyword">implements</span> <span class="title">Chart</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HistogramChart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;创建柱状图！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;显示柱状图！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>PieChart</code>：饼状图类，充当具体产品类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PieChart</span> <span class="keyword">implements</span> <span class="title">Chart</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PieChart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;创建饼状图！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;显示饼状图！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>LineChart</code>：折线图类，充当具体产品类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineChart</span> <span class="keyword">implements</span> <span class="title">Chart</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LineChart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;创建折线图！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;显示折线图！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>ChartFactory</code>：图表工厂类，充当工厂类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChartFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//静态工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Chart <span class="title">getChart</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        Chart chart = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">&quot;histogram&quot;</span>)) &#123;</span><br><span class="line">            chart = <span class="keyword">new</span> HistogramChart();</span><br><span class="line">            System.out.println(<span class="string">&quot;初始化设置柱状图！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">&quot;pie&quot;</span>)) &#123;</span><br><span class="line">            chart = <span class="keyword">new</span> PieChart();</span><br><span class="line">            System.out.println(<span class="string">&quot;初始化设置饼状图！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">&quot;line&quot;</span>)) &#123;</span><br><span class="line">            chart = <span class="keyword">new</span> LineChart();</span><br><span class="line">            System.out.println(<span class="string">&quot;初始化设置折线图！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chart;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>Client</code>：客户端测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Chart chart;</span><br><span class="line">        chart = ChartFactory.getChart(<span class="string">&quot;histogram&quot;</span>); <span class="comment">//通过静态工厂方法创建产品</span></span><br><span class="line">        chart.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>编译并运行程序，输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">创建柱状图！</span><br><span class="line">初始化设置柱状图！</span><br><span class="line">显示柱状图！</span><br></pre></td></tr></table></figure><p>在客户端测试类中，我们使用工厂类的静态工厂方法创建产品对象，如果需要更换产品，只 需修改静态工厂方法中的参数即可，例如将柱状图改为饼状图，只需将代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chart = ChartFactory.getChart(<span class="string">&quot;histogram&quot;</span>);</span><br></pre></td></tr></table></figure><p>改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chart = ChartFactory.getChart(<span class="string">&quot;pie&quot;</span>);</span><br></pre></td></tr></table></figure><p>编译并运行程序，输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">创建饼状图！</span><br><span class="line">初始化设置饼状图！</span><br><span class="line">显示饼状图！</span><br></pre></td></tr></table></figure><p>不难发现在创建具体<code>Chart</code>对象时，每更换一个<code>Chart</code>对象都需要修改客户端代码中静态工厂方法的参数，客户端代码将要重新编译，这对于客户端而言，违反了“开闭原则”，有没有一种方法能够在不修改客户端代码的前提下更换具体产品对象呢？答案是肯定的，下面将介绍一种常用的实现方式。</p><p>我们可以将静态工厂方法的参数存储在XML或properties格式的配置文件中，如下config.xml所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">chartType</span>&gt;</span>histogram<span class="tag">&lt;/<span class="name">chartType</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>再通过一个工具类XMLUtil来读取配置文件中的字符串参数，XMLUtil类的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.xml.parsers.*;</span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.*;</span><br><span class="line"><span class="keyword">import</span> org.xml.sax.SAXException;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XMLUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">//该方法用于从XML配置文件中提取图表类型，并返回类型名</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getChartType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建文档对象</span></span><br><span class="line">            DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance();</span><br><span class="line">            DocumentBuilder builder = dFactory.newDocumentBuilder();</span><br><span class="line">            Document doc;</span><br><span class="line">            doc = builder.parse(<span class="keyword">new</span> File(<span class="string">&quot;config.xml&quot;</span>));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//获取包含图表类型的文本节点</span></span><br><span class="line">            NodeList nl = doc.getElementsByTagName(<span class="string">&quot;chartType&quot;</span>);</span><br><span class="line">            Node classNode = nl.item(<span class="number">0</span>).getFirstChild();</span><br><span class="line">            String chartType = classNode.getNodeValue().trim();</span><br><span class="line">            <span class="keyword">return</span> chartType;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在引入了配置文件和工具类<code>XMLUtil</code>之后，客户端代码修改如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Chart chart;</span><br><span class="line">        String type = XMLUtil.getChartType(); <span class="comment">//读取配置文件中的参数</span></span><br><span class="line">        chart = ChartFactory.getChart(type); <span class="comment">//创建产品对象</span></span><br><span class="line">        chart.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难发现，在上述客户端代码中不包含任何与具体图表对象相关的信息，如果需要更换具体图表对象，只需修改配置文件config.xml，无须修改任何源代码，符合“开闭原则”。</p><h2 id="简单工厂模式的简化"><a class="header-anchor" href="#简单工厂模式的简化"></a>简单工厂模式的简化</h2><p>有时候，为了简化简单工厂模式，我们可以将抽象产品类和工厂类合并，将静态工厂方法移至抽象产品类中，如图所示：</p><p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%AE%80%E5%8C%96%E7%BB%93%E6%9E%84.png" alt="简单工厂模式的简化结构"></p><p>客户端可以通过产品父类的静态工厂方法，根据参数的不同创建不同类型的产品子 类对象，这种做法在JDK等类库和框架中也广泛存在。</p><h2 id="简单工厂模式总结"><a class="header-anchor" href="#简单工厂模式总结"></a>简单工厂模式总结</h2><h3 id="简单工厂模式优点"><a class="header-anchor" href="#简单工厂模式优点"></a>简单工厂模式优点</h3><ol><li>工厂类包含必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的职责，而仅仅“消费”产品，简单工厂模式<font color="#faa755">实现了对象创建和使用的分离</font>。</li><li>客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以在一定程度减少使用者的记忆量。</li><li>通过引入配置文件，可以在<font color="#faa755">不修改任何客户端代码的情况下更换和增加新的具体产品类</font>，在一定程度上提高了系统的灵活性。</li></ol><h3 id="简单工厂模式缺点"><a class="header-anchor" href="#简单工厂模式缺点"></a>简单工厂模式缺点</h3><ol><li>由于工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响。</li><li>使用简单工厂模式势必会增加系统中类的个数（引入了新的工厂类），增加了系统的复杂度和理解难度。</li><li>系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。</li><li>简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。</li></ol><h3 id="模式适用环境"><a class="header-anchor" href="#模式适用环境"></a>模式适用环境</h3><ol><li>工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。</li><li>客户端只知道传入工厂类的参数，对于如何创建对象并不关心。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简单工厂模式概述&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#简单工厂模式概述&quot;&gt;&lt;/a&gt;简单工厂模式概述&lt;/h2&gt;
&lt;p&gt;简单工厂模式并不属于GoF 23个经典设计模式，但通常将它作为学习其他工厂模式的基础，它的设计思想很简单，其基本流程如</summary>
      
    
    
    
    <category term="设计模式" scheme="http://halo123.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://halo123.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式概述及面向对象设计原则</title>
    <link href="http://halo123.top/2021/04/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0%E5%8F%8A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <id>http://halo123.top/2021/04/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0%E5%8F%8A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</id>
    <published>2021-04-18T10:01:08.455Z</published>
    <updated>2021-04-18T10:11:29.770Z</updated>
    
    <content type="html"><![CDATA[<h1>设计模式概述</h1><h2 id="掌握设计模式的层次"><a class="header-anchor" href="#掌握设计模式的层次"></a>掌握设计模式的层次</h2><ol><li>第 1 层：刚开始学编程不久，听说过什么是设计模式</li><li>第 2 层：有很长时间的编程经验，自己写了很多代码，其中用到了设计模式，但是自己却不知道</li><li>第 3 层：学习过了设计模式，发现自己已经在使用了，并且发现了一些新的模式挺好用的</li><li>第 4 层：阅读了很多别人写的源码和框架，在其中看到别人设计模式，并且能够领会设计模式的精妙和带来的好处。</li><li>第 5 层：代码写着写着，自己都没有意识到使用了设计模式，并且熟练的写了出来</li></ol><h2 id="设计模式介绍"><a class="header-anchor" href="#设计模式介绍"></a>设计模式介绍</h2><ol><li>设计模式是程序员在面对同类软件工程设计问题所总结出来的有用的经验，模式不是代码，而是某类问题的通用解决方案，设计模式（Design pattern）代表了最佳的实践。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</li><li>设计模式的本质提高 软件的维护性，通用性和扩展性，并降低软件的复杂度。</li></ol><h2 id="设计模式类型"><a class="header-anchor" href="#设计模式类型"></a>设计模式类型</h2><p>设计模式分为三种类型，共 <strong>23</strong> 种</p><ol><li>创建型模式：<font color="#faa755">单例模式</font>、抽象工厂模式、原型模式、建造者模式、<font color="#faa755">工厂模式</font>。</li><li>结构型模式：适配器模式、桥接模式、<font color="#faa755">装饰模式</font>、组合模式、外观模式、享元模式、<font color="#faa755">代理模式</font>。</li><li>行为型模式：模版方法模式、命令模式、访问者模式、迭代器模式、<font color="#faa755">观察者模式</font>、中介者模式、备忘录模式、解释器模式（Interpreter 模式）、状态模式、策略模式、职责链模式(责任链模式)。</li></ol><table><thead><tr><th>模式名称</th><th>定义</th><th>学习难度</th><th>使用频率</th></tr></thead><tbody><tr><td>简单工厂模式 (Simple Factory Pattern)</td><td>定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。</td><td>★★☆☆☆</td><td>★★★☆☆</td></tr><tr><td>工厂方法模式 (Factory Method Pattern)</td><td>定义一个用于创建对象的接口，但是让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。</td><td>★★☆☆☆</td><td>★★★★★</td></tr><tr><td>抽象工厂模式 (Abstract Factory Pattern)</td><td>提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。</td><td>★★★★☆</td><td>★★★★★</td></tr><tr><td>建造者模式 (Builder Pattern)</td><td>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</td><td>★★★★☆</td><td>★★☆☆☆</td></tr><tr><td>原型模式 (Prototype Pattern)</td><td>使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象。</td><td>★★★☆☆</td><td>★★★☆☆</td></tr><tr><td>单例模式 (Singleton Pattern)</td><td>确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一实例。</td><td>★☆☆☆☆</td><td>★★★★☆</td></tr></tbody></table><h1>面向对象设计原则</h1><p>编写软件过程中，程序员面临着来自耦合性，内聚性以及可维护性，可扩展性，重用性，灵活性等多方面的挑战，设计模式是为了让程序(软件)，具有更好的：</p><ol><li>代码重用性 (即：相同功能的代码，不用多次编写)</li><li>可读性 (即：编程规范性, 便于其他程序员的阅读和理解)</li><li>可扩展性 (即：当需要增加新的功能时，非常的方便，称为可维护)</li><li>可靠性 (即：当我们增加新的功能后，对原来的功能没有影响）</li><li>使程序呈现高内聚，低耦合的特性</li></ol><h2 id="设计模式七大原则介绍"><a class="header-anchor" href="#设计模式七大原则介绍"></a>设计模式七大原则介绍</h2><p>设计模式原则，其实就是程序员在编程时，应当遵守的原则，也是各种设计模式的基础(即：设计模式为什么这样设计的依据)</p><p>设计模式常用的七大原则有:</p><ol><li>单一职责原则</li><li>接口隔离原则</li><li>依赖倒转(倒置)原则</li><li>里氏替换原则</li><li>开闭原则</li><li>迪米特法则</li><li>合成复用原则</li></ol><h2 id="单一职责原则"><a class="header-anchor" href="#单一职责原则"></a>单一职责原则</h2><h3 id="基本介绍"><a class="header-anchor" href="#基本介绍"></a>基本介绍</h3><p>单一职责原则是最简单的面向对象设计原则，它用于控制类的粒度大小。</p><p>单一职责原则(Single Responsibility Principle, SRP)：一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中。就一个类而言，应该仅有一个引起它变化的原因。</p><p>在软件系统中，一个类（大到模块，小到方法） 承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将它们封装在同一类中。</p><p>如类 A 负责两个不同职责：职责 1，职责 2。当职责 1 需求变更而改变 A 时，可能造成职责 2 执行错误，所以需要将类 A 的粒度分解为 A1，A2。</p><p>单一职责原则是实现高内聚、低耦合的指导方针，它是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关实践经验。</p><h3 id="应用实例"><a class="header-anchor" href="#应用实例"></a>应用实例</h3><h4 id="方案1"><a class="header-anchor" href="#方案1"></a>方案1</h4><ol><li>在方案1的<code>run</code>方法中，违反了单一职责原则</li><li>解决的方案非常的简单，根据交通工具运行方法不同，分解成不同类即可</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleResponsibility1</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Vehicle vehicle = <span class="keyword">new</span> Vehicle();</span><br><span class="line">vehicle.run(<span class="string">&quot;摩托车&quot;</span>);</span><br><span class="line">vehicle.run(<span class="string">&quot;汽车&quot;</span>);</span><br><span class="line">vehicle.run(<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交通工具类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123;</span><br><span class="line">System.out.println(vehicle + <span class="string">&quot; 在公路上运行....&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方案2"><a class="header-anchor" href="#方案2"></a>方案2</h4><ol><li>遵守单一职责原则</li><li>但是这样做的改动很大，即将类分解，同时修改客户端</li><li>改进：直接修改<code>Vehicle</code> 类，改动的代码会比较少=&gt;方案3</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleResponsibility2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">RoadVehicle roadVehicle = <span class="keyword">new</span> RoadVehicle();</span><br><span class="line">roadVehicle.run(<span class="string">&quot;摩托车&quot;</span>);</span><br><span class="line">roadVehicle.run(<span class="string">&quot;汽车&quot;</span>);</span><br><span class="line"></span><br><span class="line">AirVehicle airVehicle = <span class="keyword">new</span> AirVehicle();</span><br><span class="line">airVehicle.run(<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoadVehicle</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123;</span><br><span class="line">System.out.println(vehicle + <span class="string">&quot;公路运行&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AirVehicle</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123;</span><br><span class="line">System.out.println(vehicle + <span class="string">&quot;天空运行&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaterVehicle</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123;</span><br><span class="line">System.out.println(vehicle + <span class="string">&quot;水中运行&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方案3"><a class="header-anchor" href="#方案3"></a>方案3</h4><ol><li>这种修改方法没有对原来的类做大的修改，只是增加方法</li><li>这里虽然没有在类这个级别上遵守单一职责原则，但是在方法级别上，仍然是遵守单一职责</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleResponsibility3</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Vehicle vehicle  = <span class="keyword">new</span> Vehicle();</span><br><span class="line">vehicle.run(<span class="string">&quot;汽车&quot;</span>);</span><br><span class="line">vehicle.runWater(<span class="string">&quot;轮船&quot;</span>);</span><br><span class="line">vehicle.runAir(<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123;</span><br><span class="line">System.out.println(vehicle + <span class="string">&quot; 在公路上运行....&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runAir</span><span class="params">(String vehicle)</span> </span>&#123;</span><br><span class="line">System.out.println(vehicle + <span class="string">&quot; 在天空上运行....&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runWater</span><span class="params">(String vehicle)</span> </span>&#123;</span><br><span class="line">System.out.println(vehicle + <span class="string">&quot; 在水中行....&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单一职责原则注意事项和细节"><a class="header-anchor" href="#单一职责原则注意事项和细节"></a>单一职责原则注意事项和细节</h3><ol><li>降低类的复杂度，一个类只负责一项职责。</li><li>提高类的可读性，可维护性</li><li>降低变更引起的风险</li><li>通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则</li></ol><h2 id="接口隔离原则"><a class="header-anchor" href="#接口隔离原则"></a>接口隔离原则</h2><h3 id="基本介绍-v2"><a class="header-anchor" href="#基本介绍-v2"></a>基本介绍</h3><p>接口隔离原则(Interface Segregation Principle)：客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上</p><h3 id="应用实例-v2"><a class="header-anchor" href="#应用实例-v2"></a>应用实例</h3><p>类 A 通过接口 Interface1 依赖类 B，类 C 通过接口 Interface1 依赖类 D，如果接口 Interface1 对于类 A 和类 C 来说不是最小接口，那么类 B 和类 D 必须去实现他们不需要的方法。</p><p><img src="../../../../Image/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%991.svg" alt="接口隔离原则1"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Segregation1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation4</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation5</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">Interface1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B 实现了 operation1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B 实现了 operation2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B 实现了 operation3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B 实现了 operation4&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B 实现了 operation5&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">Interface1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;D 实现了 operation1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;D 实现了 operation2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;D 实现了 operation3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;D 实现了 operation4&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;D 实现了 operation5&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; <span class="comment">//A 类通过接口Interface1 依赖(使用) B类，但是只会用到1,2,3方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(Interface1 i)</span> </span>&#123;</span><br><span class="line">        i.operation1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(Interface1 i)</span> </span>&#123;</span><br><span class="line">        i.operation2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(Interface1 i)</span> </span>&#123;</span><br><span class="line">        i.operation3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123; <span class="comment">//C 类通过接口Interface1 依赖(使用) D类，但是只会用到1,4,5方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(Interface1 i)</span> </span>&#123;</span><br><span class="line">        i.operation1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend4</span><span class="params">(Interface1 i)</span> </span>&#123;</span><br><span class="line">        i.operation4();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend5</span><span class="params">(Interface1 i)</span> </span>&#123;</span><br><span class="line">        i.operation5();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>按隔离原则应当这样处理：将接口 <strong>Interface1</strong> 拆分为独立的几个接口**(<strong>这里我们拆分成 <strong>3</strong> 个接口</strong>)**，类 A 和类 C 分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则</p><p><img src="../../../../Image/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99.svg" alt="接口隔离原则"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Segregation1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">A a = <span class="keyword">new</span> A();</span><br><span class="line">a.depend1(<span class="keyword">new</span> B()); <span class="comment">// A类通过接口去依赖B类</span></span><br><span class="line">a.depend2(<span class="keyword">new</span> B());</span><br><span class="line">a.depend3(<span class="keyword">new</span> B());</span><br><span class="line"></span><br><span class="line">C c = <span class="keyword">new</span> C();</span><br><span class="line"></span><br><span class="line">c.depend1(<span class="keyword">new</span> D()); <span class="comment">// C类通过接口去依赖(使用)D类</span></span><br><span class="line">c.depend4(<span class="keyword">new</span> D());</span><br><span class="line">c.depend5(<span class="keyword">new</span> D());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口1</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface1</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口2</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口3</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface3</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operation4</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operation5</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">Interface1</span>, <span class="title">Interface2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;B 实现了 operation1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;B 实现了 operation2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;B 实现了 operation3&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">Interface1</span>, <span class="title">Interface3</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;D 实现了 operation1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;D 实现了 operation4&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;D 实现了 operation5&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; <span class="comment">// A 类通过接口Interface1,Interface2 依赖(使用) B类，但是只会用到1,2,3方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(Interface1 i)</span> </span>&#123;</span><br><span class="line">i.operation1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(Interface2 i)</span> </span>&#123;</span><br><span class="line">i.operation2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(Interface2 i)</span> </span>&#123;</span><br><span class="line">i.operation3();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123; <span class="comment">// C 类通过接口Interface1,Interface3 依赖(使用) D类，但是只会用到1,4,5方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(Interface1 i)</span> </span>&#123;</span><br><span class="line">i.operation1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend4</span><span class="params">(Interface3 i)</span> </span>&#123;</span><br><span class="line">i.operation4();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend5</span><span class="params">(Interface3 i)</span> </span>&#123;</span><br><span class="line">i.operation5();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="依赖倒转原则"><a class="header-anchor" href="#依赖倒转原则"></a>依赖倒转原则</h2><h3 id="基本原则"><a class="header-anchor" href="#基本原则"></a>基本原则</h3><p>依赖倒转原则(Dependence Inversion Principle)是指：</p><ol><li>高层模块不应该依赖低层模块，二者都应该依赖其抽象</li><li>抽象不应该依赖细节，细节应该依赖抽象</li><li>依赖倒转(倒置)的中心思想是<font color="#faa755">面向接口编程</font></li><li>依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在 java 中，抽象指的是接口或抽象类，细节就是具体的实现类</li><li>使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成</li></ol><h3 id="应用实例-v3"><a class="header-anchor" href="#应用实例-v3"></a>应用实例</h3><h4 id="方式1"><a class="header-anchor" href="#方式1"></a>方式1</h4><ol><li>简单，比较容易想到</li><li>如果我们获取的对象是 微信，短信等等，则新增类，同时<code>Perons</code>也要增加相应的接收方法</li><li>解决思路：引入一个抽象的接口<code>IReceiver</code>, 表示接收者, 这样<code>Person</code>类与接口<code>IReceiver</code>发生依赖。因为<code>Email</code>, <code>WeiXin</code> 等等属于接收的范围，他们各自实现<code>IReceiver</code> 接口就ok, 这样我们就符号依赖倒转原则</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyInversion</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.receive(<span class="keyword">new</span> Email());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Email</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;电子邮件信息: hello,world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Email email)</span> </span>&#123;</span><br><span class="line">        System.out.println(email.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方式2"><a class="header-anchor" href="#方式2"></a>方式2</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyInversion</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//客户端无需改变</span></span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.receive(<span class="keyword">new</span> Email());</span><br><span class="line"></span><br><span class="line">        person.receive(<span class="keyword">new</span> WeiXin());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IReceiver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Email</span> <span class="keyword">implements</span> <span class="title">IReceiver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;电子邮件信息: hello,world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加微信</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeiXin</span> <span class="keyword">implements</span> <span class="title">IReceiver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;微信信息: hello,ok&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里我们是对接口的依赖</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(IReceiver receiver)</span> </span>&#123;</span><br><span class="line">        System.out.println(receiver.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="依赖关系传递的三种方式和应用案例"><a class="header-anchor" href="#依赖关系传递的三种方式和应用案例"></a>依赖关系传递的三种方式和应用案例</h3><p>方式1：通过接口传递实现依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开关的接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(ITV tv)</span></span>; <span class="comment">//抽象方法,接收接口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ITV</span> </span>&#123; <span class="comment">//ITV接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenAndClose</span> <span class="keyword">implements</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(ITV tv)</span> </span>&#123;</span><br><span class="line">        tv.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//============使用============</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChangHong</span> <span class="keyword">implements</span> <span class="title">ITV</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;长虹电视机，打开&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyPass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ChangHong changHong = <span class="keyword">new</span> ChangHong();</span><br><span class="line">        OpenAndClose openAndClose = <span class="keyword">new</span> OpenAndClose();</span><br><span class="line">openAndClose.open(changHong);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>方式2：通过构造方法依赖传递</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>; <span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ITV</span> </span>&#123; <span class="comment">//ITV接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenAndClose</span> <span class="keyword">implements</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ITV tv; <span class="comment">//成员</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OpenAndClose</span><span class="params">(ITV tv)</span> </span>&#123; <span class="comment">//构造器</span></span><br><span class="line">        <span class="keyword">this</span>.tv = tv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tv.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//============使用============</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChangHong</span> <span class="keyword">implements</span> <span class="title">ITV</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;长虹电视机，打开&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyPass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ChangHong changHong = <span class="keyword">new</span> ChangHong();</span><br><span class="line">OpenAndClose openAndClose = <span class="keyword">new</span> OpenAndClose(changHong);</span><br><span class="line">openAndClose.open();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>方式3：通过setter方法传递</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>; <span class="comment">// 抽象方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTv</span><span class="params">(ITV tv)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ITV</span> </span>&#123; <span class="comment">// ITV接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenAndClose</span> <span class="keyword">implements</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ITV tv;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTv</span><span class="params">(ITV tv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tv = tv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tv.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//============使用============</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChangHong</span> <span class="keyword">implements</span> <span class="title">ITV</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;长虹电视机，打开&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyPass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ChangHong changHong = <span class="keyword">new</span> ChangHong();</span><br><span class="line">        OpenAndClose openAndClose = <span class="keyword">new</span> OpenAndClose();</span><br><span class="line">        openAndClose.setTv(changHong);</span><br><span class="line">        openAndClose.open();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="依赖倒转原则的注意事项和细节"><a class="header-anchor" href="#依赖倒转原则的注意事项和细节"></a>依赖倒转原则的注意事项和细节</h3><ol><li>低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好.</li><li>变量的声明类型尽量是抽象类或接口, 这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化</li><li>继承时遵循里氏替换原则</li></ol><h2 id="里氏替换原则"><a class="header-anchor" href="#里氏替换原则"></a>里氏替换原则</h2><h3 id="面向对象中的继承性的思考和说明"><a class="header-anchor" href="#面向对象中的继承性的思考和说明"></a>面向对象中的继承性的思考和说明</h3><ol><li>继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。</li><li>继承在给程序设计带来便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低， 增加对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障</li><li>问题提出：在编程中，如何正确的使用继承? =&gt; 里氏替换原则</li></ol><h3 id="基本原理"><a class="header-anchor" href="#基本原理"></a>基本原理</h3><ol><li>如果对每个类型为 T1 的对象 o1，都有类型为 T2 的对象 o2，使得以 T1 定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。换句话说，所有引用基类的地方必须能透明地使用其子类的对象。</li><li>在使用继承时，遵循里氏替换原则，在<font color="#faa755">子类中尽量不要重写父类的方法</font></li><li>里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过<font color="#faa755">聚合，组合，依赖</font>来解决问题。</li></ol><h3 id="应用案例"><a class="header-anchor" href="#应用案例"></a>应用案例</h3><p>错误示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Liskov</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        System.out.println(<span class="string">&quot;11-3=&quot;</span> + a.func1(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;1-8=&quot;</span> + a.func1(<span class="number">1</span>, <span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        System.out.println(<span class="string">&quot;11-3=&quot;</span> + b.func1(<span class="number">11</span>, <span class="number">3</span>));<span class="comment">//这里本意是求出11-3</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1-8=&quot;</span> + b.func1(<span class="number">1</span>, <span class="number">8</span>));<span class="comment">// 1-8</span></span><br><span class="line">        System.out.println(<span class="string">&quot;11+3+9=&quot;</span> + b.func2(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回两个数的差</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 - num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B类继承了A</span></span><br><span class="line"><span class="comment">// 增加了一个新功能：完成两个数相加,然后和9求和</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里，重写了A类的方法, 可能是无意识</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> func1(a, b) + <span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Liskov</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        System.out.println(<span class="string">&quot;11-3=&quot;</span> + a.func1(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;1-8=&quot;</span> + a.func1(<span class="number">1</span>, <span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        <span class="comment">//因为B类不再继承A类，因此调用者，不会再func1是求减法</span></span><br><span class="line">        <span class="comment">//调用完成的功能就会很明确</span></span><br><span class="line">        System.out.println(<span class="string">&quot;11+3=&quot;</span> + b.func1(<span class="number">11</span>, <span class="number">3</span>));<span class="comment">//这里本意是求出11+3</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1+8=&quot;</span> + b.func1(<span class="number">1</span>, <span class="number">8</span>));<span class="comment">// 1+8</span></span><br><span class="line">        System.out.println(<span class="string">&quot;11+3+9=&quot;</span> + b.func2(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用组合仍然可以使用到A类相关方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;11-3=&quot;</span> + b.func3(<span class="number">11</span>, <span class="number">3</span>));<span class="comment">// 这里本意是求出11-3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个更加基础的基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="comment">//把更加基础的方法和成员写到Base类</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回两个数的差</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 - num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B类继承了A</span></span><br><span class="line"><span class="comment">// 增加了一个新功能：完成两个数相加,然后和9求和</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果B需要使用A类的方法,使用组合关系</span></span><br><span class="line">    <span class="keyword">private</span> A a = <span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里，重写了A类的方法, 可能是无意识</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> func1(a, b) + <span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//我们仍然想使用A的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func3</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.a.func1(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="开闭原则"><a class="header-anchor" href="#开闭原则"></a>开闭原则</h2><h3 id="基本介绍-v3"><a class="header-anchor" href="#基本介绍-v3"></a>基本介绍</h3><p>开闭原则是面向对象的可复用设计的第一块基石，它是最重要的面向对象设计原则。</p><p>开闭原则(Open-Closed Principle, OCP)：一个软件实体应当对扩展开放(对提供方)，对修改关闭(对使用方)。即软件实体应尽量在不修改原有代码的情况下进行扩展。</p><p>用抽象构建框架，用实现扩展细节。</p><ol start="3"><li>当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。</li><li>编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。</li></ol><h3 id="应用案例-v2"><a class="header-anchor" href="#应用案例-v2"></a>应用案例</h3><h4 id="方式一"><a class="header-anchor" href="#方式一"></a>方式一</h4><ol><li>优点是比较好理解，简单易操作。</li><li>缺点是违反了设计模式的开闭原则，即对扩展开放(提供方)，对修改关闭(使用方)。即当我们给类增加新功能的时候，尽量不修改代码，或者尽可能少修改代码.</li><li>比如我们这时要新增加一个图形种类 三角形，我们需要做如下修改，修改的地方较多</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ocp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用看看存在的问题</span></span><br><span class="line">        GraphicEditor graphicEditor = <span class="keyword">new</span> GraphicEditor();</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> Rectangle());</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> Circle());</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> Triangle());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是一个用于绘图的类 [使用方]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphicEditor</span> </span>&#123;</span><br><span class="line">    <span class="comment">//接收Shape对象，然后根据type，来绘制不同的图形</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawShape</span><span class="params">(Shape s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s.m_type == <span class="number">1</span>) &#123;</span><br><span class="line">drawRectangle(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s.m_type == <span class="number">2</span>) &#123;</span><br><span class="line">drawCircle(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s.m_type == <span class="number">3</span>) &#123;</span><br><span class="line">drawTriangle(s);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绘制矩形</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawRectangle</span><span class="params">(Shape r)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 绘制矩形 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绘制圆形</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawCircle</span><span class="params">(Shape r)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 绘制圆形 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绘制三角形</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawTriangle</span><span class="params">(Shape r)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 绘制三角形 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Shape类，基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    Rectangle() &#123;</span><br><span class="line">        <span class="keyword">super</span>.m_type = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    Circle() &#123;</span><br><span class="line">        <span class="keyword">super</span>.m_type = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增画三角形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    Triangle() &#123;</span><br><span class="line">        <span class="keyword">super</span>.m_type = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>改进的思路分析：把创建 <strong>Shape</strong> 类做成抽象类，并提供一个抽象的 <strong>draw</strong> 方法，让子类去实现即可，这样我们有新的图形种类时，只需要让新的图形类继承 Shape，并实现 draw 方法即可，使用方的代码就不需要修  -&gt;  满足了开闭原则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.principle.ocp.improve;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ocp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用看看存在的问题</span></span><br><span class="line">        GraphicEditor graphicEditor = <span class="keyword">new</span> GraphicEditor();</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> Rectangle());</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> Circle());</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> Triangle());</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> OtherGraphic());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是一个用于绘图的类 [使用方]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphicEditor</span> </span>&#123;</span><br><span class="line">    <span class="comment">//接收Shape对象，调用draw方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawShape</span><span class="params">(Shape s)</span> </span>&#123;</span><br><span class="line">        s.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Shape类，基类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m_type;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;<span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    Rectangle() &#123;</span><br><span class="line">        <span class="keyword">super</span>.m_type = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">&quot; 绘制矩形 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    Circle() &#123;</span><br><span class="line">        <span class="keyword">super</span>.m_type = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 绘制圆形 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增画三角形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    Triangle() &#123;</span><br><span class="line">        <span class="keyword">super</span>.m_type = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 绘制三角形 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增一个图形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OtherGraphic</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    OtherGraphic() &#123;</span><br><span class="line">        <span class="keyword">super</span>.m_type = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 绘制其它图形 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迪米特法则"><a class="header-anchor" href="#迪米特法则"></a>迪米特法则</h2><h3 id="基本介绍-v4"><a class="header-anchor" href="#基本介绍-v4"></a>基本介绍</h3><ol><li><p>一个对象应该对其他对象保持最少的了解</p></li><li><p>类与类关系越密切，耦合度越大</p></li><li><p>迪米特法则(Demeter Principle)又叫最少知道原则，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的 public 方法，不对外泄露任何信息</p></li><li><p>迪米特法则还有个更简单的定义：只与直接的朋友通信</p><blockquote><p>直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。</p></blockquote></li></ol><h3 id="应用示例"><a class="header-anchor" href="#应用示例"></a>应用示例</h3><p>有一个学校，下属有各个学院和总部，现要求打印出学校总部员工 ID 和学院员工的 id</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demeter1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建了一个 SchoolManager 对象</span></span><br><span class="line">        SchoolManager schoolManager = <span class="keyword">new</span> SchoolManager();</span><br><span class="line">        <span class="comment">//输出学院的员工id 和 学校总部的员工信息</span></span><br><span class="line">        schoolManager.printAllEmployee(<span class="keyword">new</span> CollegeManager());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学校总部员工类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//学院的员工类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeEmployee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//管理学院员工的管理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回学院的所有员工</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;CollegeEmployee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;CollegeEmployee&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; <span class="comment">//这里我们增加了10个员工到 list</span></span><br><span class="line">            CollegeEmployee emp = <span class="keyword">new</span> CollegeEmployee();</span><br><span class="line">            emp.setId(<span class="string">&quot;学院员工id= &quot;</span> + i);</span><br><span class="line">            list.add(emp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学校管理类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//分析 SchoolManager 类的直接朋友类有哪些 Employee、CollegeManager</span></span><br><span class="line"><span class="comment">//CollegeEmployee 不是 直接朋友 而是一个陌生类，这样违背了 迪米特法则</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SchoolManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回学校总部的员工</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Employee&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; <span class="comment">//这里我们增加了5个员工到 list</span></span><br><span class="line">            Employee emp = <span class="keyword">new</span> Employee();</span><br><span class="line">            emp.setId(<span class="string">&quot;学校总部员工id= &quot;</span> + i);</span><br><span class="line">            list.add(emp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该方法完成输出学校总部和学院员工信息(id)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printAllEmployee</span><span class="params">(CollegeManager sub)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分析问题</span></span><br><span class="line">        <span class="comment">//1. 这里的 CollegeEmployee 不是  SchoolManager的直接朋友</span></span><br><span class="line">        <span class="comment">//2. CollegeEmployee 是以局部变量方式出现在 SchoolManager</span></span><br><span class="line">        <span class="comment">//3. 违反了 迪米特法则</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取到学院员工</span></span><br><span class="line">        List&lt;CollegeEmployee&gt; list1 = sub.getAllEmployee();</span><br><span class="line">        System.out.println(<span class="string">&quot;------------学院员工------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (CollegeEmployee e : list1) &#123;</span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取到学校总部员工</span></span><br><span class="line">        List&lt;Employee&gt; list2 = <span class="keyword">this</span>.getAllEmployee();</span><br><span class="line">        System.out.println(<span class="string">&quot;------------学校总部员工------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Employee e : list2) &#123;</span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用实例改进分析：前面设计的问题在于 <code>SchoolManager</code> 中，<code>CollegeEmployee</code> 类并不是 <code>SchoolManager</code> 类的直接朋友 (分析)，按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demeter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;~~~使用迪米特法则的改进~~~&quot;</span>);</span><br><span class="line">        <span class="comment">//创建了一个 SchoolManager 对象</span></span><br><span class="line">        SchoolManager schoolManager = <span class="keyword">new</span> SchoolManager();</span><br><span class="line">        <span class="comment">//输出学院的员工id 和  学校总部的员工信息</span></span><br><span class="line">        schoolManager.printAllEmployee(<span class="keyword">new</span> CollegeManager());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//学校总部员工类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//学院的员工类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeEmployee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//管理学院员工的管理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回学院的所有员工</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;CollegeEmployee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;CollegeEmployee&gt; list = <span class="keyword">new</span> ArrayList&lt;CollegeEmployee&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; <span class="comment">//这里我们增加了10个员工到 list</span></span><br><span class="line">            CollegeEmployee emp = <span class="keyword">new</span> CollegeEmployee();</span><br><span class="line">            emp.setId(<span class="string">&quot;学院员工id= &quot;</span> + i);</span><br><span class="line">            list.add(emp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出学院员工的信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取到学院员工</span></span><br><span class="line">        List&lt;CollegeEmployee&gt; list1 = getAllEmployee();</span><br><span class="line">        System.out.println(<span class="string">&quot;------------学院员工------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (CollegeEmployee e : list1) &#123;</span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学校管理类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//分析 SchoolManager 类的直接朋友类有哪些 Employee、CollegeManager</span></span><br><span class="line"><span class="comment">//CollegeEmployee 不是 直接朋友 而是一个陌生类，这样违背了 迪米特法则 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SchoolManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回学校总部的员工</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Employee&gt; list = <span class="keyword">new</span> ArrayList&lt;Employee&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; <span class="comment">//这里我们增加了5个员工到 list</span></span><br><span class="line">            Employee emp = <span class="keyword">new</span> Employee();</span><br><span class="line">            emp.setId(<span class="string">&quot;学校总部员工id= &quot;</span> + i);</span><br><span class="line">            list.add(emp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该方法完成输出学校总部和学院员工信息(id)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printAllEmployee</span><span class="params">(CollegeManager sub)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分析问题</span></span><br><span class="line">        <span class="comment">//1. 将输出学院的员工方法，封装到CollegeManager</span></span><br><span class="line">        sub.printEmployee();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取到学校总部员工</span></span><br><span class="line">        List&lt;Employee&gt; list2 = <span class="keyword">this</span>.getAllEmployee();</span><br><span class="line">        System.out.println(<span class="string">&quot;------------学校总部员工------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Employee e : list2) &#123;</span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="迪米特法则注意事项和细节"><a class="header-anchor" href="#迪米特法则注意事项和细节"></a>迪米特法则注意事项和细节</h3><ol><li>迪米特法则的核心是降低类之间的耦合</li><li>但是注意：由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间(对象间)耦合关系， 并不是要求完全没有依赖关系</li></ol><h2 id="合成复用原则"><a class="header-anchor" href="#合成复用原则"></a>合成复用原则</h2><h3 id="基本介绍-v5"><a class="header-anchor" href="#基本介绍-v5"></a>基本介绍</h3><p>原则是尽量使用合成/聚合的方式，而不是使用继承</p><h2 id="设计原则核心思想"><a class="header-anchor" href="#设计原则核心思想"></a>设计原则核心思想</h2><ol><li>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。</li><li>针对接口编程，而不是针对实现编程。</li><li>为了交互对象之间的松耦合设计而努力</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;设计模式概述&lt;/h1&gt;
&lt;h2 id=&quot;掌握设计模式的层次&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#掌握设计模式的层次&quot;&gt;&lt;/a&gt;掌握设计模式的层次&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;第 1 层：刚开始学编程不久，听说过什么是设计模式&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    <category term="设计模式" scheme="http://halo123.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式 | 面向对象编程" scheme="http://halo123.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>STL常用算法</title>
    <link href="http://halo123.top/2021/04/18/C++/STL%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95-stl%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    <id>http://halo123.top/2021/04/18/C++/STL%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95-stl%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/</id>
    <published>2021-04-18T09:11:12.634Z</published>
    <updated>2021-04-18T09:13:38.267Z</updated>
    
    <content type="html"><![CDATA[<p><strong>概述</strong>:</p><ul><li>算法主要是由头文件<code>&lt;algorithm&gt;</code> <code>&lt;functional&gt;</code> <code>&lt;numeric&gt;</code>组成。</li><li><code>&lt;algorithm&gt;</code>是所有STL头文件中最大的一个，范围涉及到比较、 交换、查找、遍历操作、复制、修改等等</li><li><code>&lt;numeric&gt;</code>体积很小，只包括几个在序列上面进行简单数学运算的模板函数</li><li><code>&lt;functional&gt;</code>定义了一些模板类,用以声明函数对象。</li></ul><h2 id="常用遍历算法"><a class="header-anchor" href="#常用遍历算法"></a>常用遍历算法</h2><p><strong>学习目标</strong>：掌握常用的遍历算法</p><p><strong>算法简介</strong>：</p><ul><li><code>for_each</code> //遍历容器</li><li><code>transform</code> //搬运容器到另一个容器中</li></ul><h3 id="for-each"><a class="header-anchor" href="#for-each"></a>for_each</h3><p><strong>功能描述</strong>：实现遍历容器</p><p><strong>函数原型</strong>：</p><ul><li><code>for_each(iterator beg, iterator end, _func);</code> // 遍历算法 遍历容器元素<ul><li><code>beg</code> 开始迭代器</li><li><code>end</code> 结束迭代器</li><li><code>_func</code> 函数或者函数对象</li></ul></li></ul><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print01</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">print02</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//for_each算法基本用法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历算法</span></span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), print01);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">print02</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="transform"><a class="header-anchor" href="#transform"></a>transform</h3><p><strong>功能描述</strong>：搬运容器到另一个容器中</p><p><strong>函数原型</strong>：</p><ul><li><code>transform(iterator beg1, iterator end1, iterator beg2, _func);</code><ul><li><code>beg1</code> 源容器开始迭代器</li><li><code>end1</code> 源容器结束迭代器</li><li><code>beg2</code> 目标容器开始迭代器</li><li><code>_func</code> 函数或者函数对象</li></ul></li></ul><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//常用遍历算法  搬运 transform</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TransForm</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vTarget; <span class="comment">//目标容器</span></span><br><span class="line"></span><br><span class="line">    vTarget.<span class="built_in">resize</span>(v.<span class="built_in">size</span>()); <span class="comment">// 目标容器需要提前开辟空间</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">transform</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>(), <span class="built_in">TransForm</span>());</span><br><span class="line"></span><br><span class="line">    for_each(vTarget.<span class="built_in">begin</span>(), vTarget.<span class="built_in">end</span>(), <span class="built_in">MyPrint</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong>： 搬运的目标容器必须要提前开辟空间，否则无法正常搬运</p><h2 id="常用查找算法"><a class="header-anchor" href="#常用查找算法"></a>常用查找算法</h2><p><strong>算法简介</strong>：</p><ul><li><code>find</code> //查找元素</li><li><code>find_if</code> //按条件查找元素</li><li><code>adjacent_find</code> //查找相邻重复元素</li><li><code>binary_search</code> //二分查找法</li><li><code>count</code> //统计元素个数</li><li><code>count_if</code> //按条件统计元素个数</li></ul><h3 id="find"><a class="header-anchor" href="#find"></a>find</h3><p><strong>功能描述</strong>：</p><ul><li>查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end()</li></ul><p><strong>函数原型</strong>：</p><ul><li><code>find(iterator beg, iterator end, value);</code> // 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置<ul><li><code>beg</code> 开始迭代器</li><li><code>end</code> 结束迭代器</li><li><code>value</code> 查找的元素</li></ul></li></ul><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查找容器中是否有 5 这个元素</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;找到:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载 ==</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Person &amp;p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_Name;</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建数据</span></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p4);</span><br><span class="line"></span><br><span class="line">    vector&lt;Person&gt;::iterator it = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), p2);</span><br><span class="line">    <span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;找到姓名:&quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄: &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结： 利用find可以在容器中找指定的元素，返回值是<strong>迭代器</strong></p><h3 id="find-if"><a class="header-anchor" href="#find-if"></a>find_if</h3><p><strong>功能描述</strong>：按条件查找元素</p><p><strong>函数原型</strong>：</p><ul><li><code>find_if(iterator beg, iterator end, _Pred);</code> // 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置<ul><li><code>beg</code> 开始迭代器</li><li><code>end</code> 结束迭代器</li><li><code>_Pred</code> 函数或者谓词（返回bool类型的仿函数）</li></ul></li></ul><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreaterFive</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val &gt; <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">GreaterFive</span>());</span><br><span class="line">    <span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;找到大于5的数字:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_Name;</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greater20</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Person &amp;p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p.m_Age &gt; <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建数据</span></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p4);</span><br><span class="line"></span><br><span class="line">    vector&lt;Person&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">Greater20</span>());</span><br><span class="line">    <span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;找到姓名:&quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄: &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：find_if按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略</p><h3 id="adjacent-find"><a class="header-anchor" href="#adjacent-find"></a>adjacent_find</h3><p><strong>功能描述</strong>：查找相邻重复元素</p><p><strong>函数原型</strong>：</p><ul><li><code>adjacent_find(iterator beg, iterator end);</code>  // 查找相邻重复元素,返回相邻元素的第一个位置的迭代器<ul><li><code>beg</code> 开始迭代器</li><li><code>end</code> 结束迭代器</li></ul></li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找相邻重复元素</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">adjacent_find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;找不到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;找到相邻重复元素为:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="binary-search"><a class="header-anchor" href="#binary-search"></a>binary_search</h3><p><strong>功能描述</strong>：查找指定元素是否存在</p><p>注意: 在<strong>无序序列中不可用</strong></p><p><strong>函数原型</strong>：</p><ul><li><code>bool binary_search(iterator beg, iterator end, value);</code>  // 查找指定的元素，查到 返回true 否则false<ul><li><code>beg</code> 开始迭代器</li><li><code>end</code> 结束迭代器</li><li><code>value</code> 查找的元素</li></ul></li></ul><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//二分查找</span></span><br><span class="line">    <span class="keyword">bool</span> ret = <span class="built_in">binary_search</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;找到了&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;未找到&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong>：二分查找法查找效率很高，值得注意的是查找的容器中元素必须的有序序列</p><h3 id="count"><a class="header-anchor" href="#count"></a>count</h3><p><strong>功能描述</strong>：</p><ul><li>统计元素个数</li></ul><p><strong>函数原型</strong>：</p><ul><li><code>count(iterator beg, iterator end, value);</code> // 统计元素出现次数<ul><li><code>beg</code> 开始迭代器</li><li><code>end</code> 结束迭代器</li><li><code>value</code> 统计的元素</li></ul></li></ul><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="built_in">count</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;4的个数为： &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Person &amp;p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Age == p.m_Age) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    string m_Name;</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p5);</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;诸葛亮&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="built_in">count</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), p);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong>： 统计自定义数据类型时候，需要配合重载 <code>operator==</code></p><h3 id="count-if"><a class="header-anchor" href="#count-if"></a>count_if</h3><p><strong>功能描述</strong>：</p><ul><li>按条件统计元素个数</li></ul><p><strong>函数原型</strong>：</p><ul><li><code>count_if(iterator beg, iterator end, _Pred);</code> // 按条件统计元素出现次数<ul><li><code>beg</code> 开始迭代器</li><li><code>end</code> 结束迭代器</li><li><code>_Pred</code> 谓词</li></ul></li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greater4</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val &gt;= <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="built_in">count_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">Greater4</span>());</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;大于4的个数为： &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string m_Name;</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AgeLess35</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Person &amp;p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p.m_Age &lt; <span class="number">35</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p5);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="built_in">count_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">AgeLess35</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;小于35岁的个数：&quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常见的排序算法"><a class="header-anchor" href="#常见的排序算法"></a>常见的排序算法</h2><p><strong>学习目标</strong>：掌握常用的排序算法</p><p><strong>算法简介</strong>：</p><ul><li><code>sort</code> //对容器内元素进行排序</li><li><code>random_shuffle</code> //洗牌 指定范围内的元素随机调整次序</li><li><code>merge</code> // 容器元素合并，并存储到另一容器中</li><li><code>reverse</code> // 反转指定范围的元素</li></ul><h3 id="sort"><a class="header-anchor" href="#sort"></a>sort</h3><p><strong>功能描述</strong>：对容器内元素进行排序</p><p><strong>函数原型</strong>：</p><ul><li><code>sort(iterator beg, iterator end, _Pred);</code> // 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置<ul><li><code>beg</code> 开始迭代器</li><li><code>end</code> 结束迭代器</li><li><code>_Pred</code> 谓词</li></ul></li></ul><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sort默认从小到大排序</span></span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), myPrint);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从大到小排序</span></span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), myPrint);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="random-shuffle"><a class="header-anchor" href="#random-shuffle"></a>random_shuffle</h3><p><strong>功能描述</strong>：洗牌 指定范围内的元素随机调整次序</p><p><strong>函数原型</strong>：</p><ul><li><code>random_shuffle(iterator beg, iterator end);</code> // 指定范围内的元素随机调整次序<ul><li>beg 开始迭代器</li><li>end 结束迭代器</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>((<span class="keyword">unsigned</span> <span class="keyword">int</span>) <span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打乱顺序</span></span><br><span class="line">    <span class="built_in">random_shuffle</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong>：random_shuffle洗牌算法比较实用，使用时记得加随机数种子</p><h3 id="merge"><a class="header-anchor" href="#merge"></a>merge</h3><p><strong>功能描述</strong>：两个容器元素合并，并存储到另一容器中</p><p>注意: 两个容器必须是<font color="#faa755">有序的</font></p><p><strong>函数原型</strong>：</p><ul><li><code>merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code> // 容器元素合并，并存储到另一容器中<ul><li><code>beg1</code> 容器1开始迭代器</li><li><code>end1</code> 容器1结束迭代器</li><li><code>beg2</code> 容器2开始迭代器</li><li><code>end2</code> 容器2结束迭代器</li><li><code>dest</code> 目标容器开始迭代器</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">        v2.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vtarget;</span><br><span class="line">    <span class="comment">//目标容器需要提前开辟空间</span></span><br><span class="line">    vtarget.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>() + v2.<span class="built_in">size</span>());</span><br><span class="line">    <span class="comment">//合并  需要两个有序序列</span></span><br><span class="line">    <span class="built_in">merge</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vtarget.<span class="built_in">begin</span>());</span><br><span class="line">    for_each(vtarget.<span class="built_in">begin</span>(), vtarget.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="reverse"><a class="header-anchor" href="#reverse"></a>reverse</h3><p><strong>功能描述</strong>：将容器内元素进行反转</p><p><strong>函数原型</strong>：</p><ul><li><code>reverse(iterator beg, iterator end);</code> // 反转指定范围的元素<ul><li><code>beg</code> 开始迭代器</li><li><code>end</code> 结束迭代器</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;反转前： &quot;</span> &lt;&lt; endl;</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;反转后： &quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">reverse</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常用拷贝和替换算法"><a class="header-anchor" href="#常用拷贝和替换算法"></a>常用拷贝和替换算法</h2><p><strong>算法简介</strong>：</p><ul><li><code>copy</code> // 容器内指定范围的元素拷贝到另一容器中</li><li><code>replace</code> // 将容器内指定范围的旧元素修改为新元素</li><li><code>replace_if</code> // 容器内指定范围满足条件的元素替换为新元素</li><li><code>swap</code> // 互换两个容器的元素</li></ul><h3 id="copy"><a class="header-anchor" href="#copy"></a>copy</h3><p><strong>功能描述</strong>：容器内指定范围的元素拷贝到另一容器中</p><p><strong>函数原型</strong>：</p><ul><li><code>copy(iterator beg, iterator end, iterator dest);</code> // 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置<ul><li><code>beg</code> 开始迭代器</li><li><code>end</code> 结束迭代器</li><li><code>dest</code> 目标起始迭代器</li></ul></li></ul><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">    v2.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>());</span><br><span class="line">    <span class="built_in">copy</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">    for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong>：利用copy算法在拷贝时，目标容器记得提前开辟空间</p><h3 id="replace-if"><a class="header-anchor" href="#replace-if"></a>replace_if</h3><p><strong>功能描述</strong>：将区间内满足条件的元素，替换成指定元素</p><p><strong>函数原型</strong>：</p><ul><li><code>replace_if(iterator beg, iterator end, _pred, newvalue);</code> // 按条件替换元素，满足条件的替换成指定元素<ul><li><code>beg</code> 开始迭代器</li><li><code>end</code> 结束迭代器</li><li><code>_pred</code> 谓词</li><li><code>newvalue</code> 替换的新元素</li></ul></li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReplaceGreater30</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val &gt;= <span class="number">30</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;替换前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将容器中大于等于的30 替换成 3000</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;替换后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">replace_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">ReplaceGreater30</span>(), <span class="number">3000</span>);</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong>：replace_if按条件查找，可以利用仿函数灵活筛选满足的条件</p><h3 id="swap"><a class="header-anchor" href="#swap"></a>swap</h3><p><strong>功能描述</strong>：互换两个容器的元素</p><p><strong>函数原型</strong>：</p><ul><li><code>swap(container c1, container c2);</code> // 互换两个容器的元素<ul><li><code>c1</code>容器1</li><li><code>c2</code>容器2</li></ul></li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">        v2.<span class="built_in">push_back</span>(i + <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;交换前： &quot;</span> &lt;&lt; endl;</span><br><span class="line">    for_each(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;交换后： &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">swap</span>(v1, v2);</span><br><span class="line">    for_each(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong>：swap交换容器时，注意交换的容器要同种类型</p><h2 id="常用算术生成算法"><a class="header-anchor" href="#常用算术生成算法"></a>常用算术生成算法</h2><p><strong>注意</strong>：算术生成算法属于小型算法，使用时包含的头文件为 <code>#include &lt;numeric&gt;</code></p><p><strong>算法简介</strong>：</p><ul><li><code>accumulate</code> // 计算容器元素累计总和</li><li><code>fill</code> // 向容器中添加元素</li></ul><h3 id="accumulate"><a class="header-anchor" href="#accumulate"></a>accumulate</h3><p><strong>功能描述</strong>：计算区间内 容器元素累计总和</p><p><strong>函数原型</strong>：</p><ul><li><code>accumulate(iterator beg, iterator end, value); </code>// 计算容器元素累计总和<ul><li><code>beg</code> 开始迭代器</li><li><code>end</code> 结束迭代器</li><li><code>value</code> 起始值</li></ul></li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> total = <span class="built_in">accumulate</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;total = &quot;</span> &lt;&lt; total &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong>：accumulate使用时头文件注意是 numeric，这个算法很实用</p><h3 id="fill"><a class="header-anchor" href="#fill"></a>fill</h3><p><strong>功能描述</strong>：向容器中填充指定的元素</p><p><strong>函数原型</strong>：</p><ul><li><code>fill(iterator beg, iterator end, value);</code> // 向容器中填充元素<ul><li><code>beg</code> 开始迭代器</li><li><code>end</code> 结束迭代器</li><li><code>value</code> 填充的值</li></ul></li></ul><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//填充</span></span><br><span class="line">    <span class="built_in">fill</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong>：利用fill可以将容器区间内元素填充为指定的值</p><h2 id="常用集合算法"><a class="header-anchor" href="#常用集合算法"></a>常用集合算法</h2><p><strong>算法简介</strong>：</p><ul><li><code>set_intersection</code> // 求两个容器的交集</li><li><code>set_union</code> // 求两个容器的并集</li><li><code>set_difference</code> // 求两个容器的差集</li></ul><h3 id="set-intersection"><a class="header-anchor" href="#set-intersection"></a>set_intersection</h3><p><strong>功能描述</strong>：求两个容器的交集</p><p><strong>注意：两个集合必须是有序序列</strong></p><p><strong>函数原型</strong>：</p><ul><li><code>set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code> // 求两个集合的交集<ul><li><code>beg1</code> 容器1开始迭代器</li><li><code>end1</code> 容器1结束迭代器</li><li><code>beg2</code> 容器2开始迭代器</li><li><code>end2</code> 容器2结束迭代器</li><li><code>dest</code> 目标容器开始迭代器</li></ul></li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">        v2.<span class="built_in">push_back</span>(i + <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vTarget;</span><br><span class="line">    <span class="comment">//取两个里面较小的值给目标容器开辟空间</span></span><br><span class="line">    vTarget.<span class="built_in">resize</span>(<span class="built_in">min</span>(v1.<span class="built_in">size</span>(), v2.<span class="built_in">size</span>()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator itEnd =</span><br><span class="line">            <span class="built_in">set_intersection</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">    for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong>：</p><ul><li>求交集的两个集合必须的有序序列</li><li>目标容器开辟空间需要从<strong>两个容器中取小值</strong></li><li>set_intersection返回值是交集中最后一个元素的位置</li></ul><h3 id="set-union"><a class="header-anchor" href="#set-union"></a>set_union</h3><p><strong>功能描述</strong>：求两个集合的并集</p><p><strong>注意：两个集合必须是有序序列</strong></p><p><strong>函数原型</strong>：</p><ul><li><code>set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code> // 求两个集合的并集<ul><li><code>beg1</code> 容器1开始迭代器</li><li><code>end1</code> 容器1结束迭代器</li><li><code>beg2</code> 容器2开始迭代器</li><li><code>end2</code> 容器2结束迭代器</li><li><code>dest</code> 目标容器开始迭代器</li></ul></li></ul><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">        v2.<span class="built_in">push_back</span>(i + <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vTarget;</span><br><span class="line">    <span class="comment">//取两个容器的和给目标容器开辟空间</span></span><br><span class="line">    vTarget.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>() + v2.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator itEnd =</span><br><span class="line">            <span class="built_in">set_union</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">    for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong>：</p><ul><li>求并集的两个集合必须的有序序列</li><li>目标容器开辟空间需要<strong>两个容器相加</strong></li><li>set_union返回值是并集中最后一个元素的位置</li></ul><h3 id="set-difference"><a class="header-anchor" href="#set-difference"></a>set_difference</h3><p><strong>功能描述</strong>：求两个集合的差集</p><p><strong>注意：两个集合必须是有序序列</strong></p><p><strong>函数原型</strong>：</p><ul><li><code>set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code> // 求两个集合的差集<ul><li><code>beg1</code> 容器1开始迭代器</li><li><code>end1</code> 容器1结束迭代器</li><li><code>beg2</code> 容器2开始迭代器</li><li><code>end2</code> 容器2结束迭代器</li><li><code>dest</code> 目标容器开始迭代器</li></ul></li></ul><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">        v2.<span class="built_in">push_back</span>(i + <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vTarget;</span><br><span class="line">    <span class="comment">//取两个里面较大的值给目标容器开辟空间</span></span><br><span class="line">    vTarget.<span class="built_in">resize</span>(<span class="built_in">max</span>(v1.<span class="built_in">size</span>(), v2.<span class="built_in">size</span>()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v1与v2的差集为： &quot;</span> &lt;&lt; endl;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator itEnd =</span><br><span class="line">            <span class="built_in">set_difference</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line">    for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v2与v1的差集为： &quot;</span> &lt;&lt; endl;</span><br><span class="line">    itEnd = <span class="built_in">set_difference</span>(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line">    for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong>：</p><ul><li>求差集的两个集合必须的有序序列</li><li>目标容器开辟空间需要从<strong>两个容器取较大值</strong></li><li>set_difference返回值是差集中最后一个元素的位置</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;概述&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;算法主要是由头文件&lt;code&gt;&amp;lt;algorithm&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;functional&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;numeric&amp;gt;&lt;/code&gt;组成。</summary>
      
    
    
    
    <category term="STL" scheme="http://halo123.top/categories/STL/"/>
    
    
    <category term="STL" scheme="http://halo123.top/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>STL函数对象</title>
    <link href="http://halo123.top/2021/04/18/C++/STL%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1-stl-han-shu-dui-xiang/"/>
    <id>http://halo123.top/2021/04/18/C++/STL%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1-stl-han-shu-dui-xiang/</id>
    <published>2021-04-18T09:10:42.906Z</published>
    <updated>2021-04-18T09:10:42.906Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数对象"><a class="header-anchor" href="#函数对象"></a>函数对象</h2><h3 id="函数对象概念"><a class="header-anchor" href="#函数对象概念"></a>函数对象概念</h3><p><strong>概念：</strong></p><ul><li>重载<strong>函数调用操作符</strong>的类，其对象常称为<strong>函数对象</strong></li><li><strong>函数对象</strong>使用重载的()时，行为类似函数调用，也叫<strong>仿函数</strong></li></ul><p><strong>本质：<strong>函数对象(仿函数)是一个</strong>类</strong>，不是一个函数</p><h3 id="函数对象使用"><a class="header-anchor" href="#函数对象使用"></a>函数对象使用</h3><p><strong>特点：</strong></p><ul><li>函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</li><li>函数对象超出普通函数的概念，函数对象可以有自己的状态</li><li>函数对象可以作为参数传递</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAdd</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v1 + v2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyAdd myAdd;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">myAdd</span>(<span class="number">10</span>, <span class="number">10</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、函数对象可以有自己的状态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyPrint</span>() &#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string test)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; test &lt;&lt; endl;</span><br><span class="line">        count++; <span class="comment">//统计使用次数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count; <span class="comment">//内部自己的状态</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyPrint myPrint;</span><br><span class="line">    <span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;myPrint调用次数为： &quot;</span> &lt;&lt; myPrint.count &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、函数对象可以作为参数传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doPrint</span><span class="params">(MyPrint &amp;mp, string test)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">mp</span>(test);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyPrint myPrint;</span><br><span class="line">    <span class="built_in">doPrint</span>(myPrint, <span class="string">&quot;Hello C++&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：仿函数写法非常灵活，可以作为参数进行传递。</p><h2 id="谓词"><a class="header-anchor" href="#谓词"></a>谓词</h2><h3 id="谓词概念"><a class="header-anchor" href="#谓词概念"></a>谓词概念</h3><p><strong>概念：</strong></p><ul><li>返回bool类型的仿函数称为<strong>谓词</strong></li><li>如果operator()接受一个参数，那么叫做一元谓词</li><li>如果operator()接受两个参数，那么叫做二元谓词</li></ul><h3 id="一元谓词"><a class="header-anchor" href="#一元谓词"></a>一元谓词</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.一元谓词</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GreaterFive</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val &gt; <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">GreaterFive</span>());</span><br><span class="line">    <span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;没找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;找到:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：参数只有一个的谓词，称为一元谓词</p><h3 id="二元谓词"><a class="header-anchor" href="#二元谓词"></a>二元谓词</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二元谓词</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCompare</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 &gt; num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认从小到大</span></span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;----------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用函数对象改变算法策略，排序从大到小</span></span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">MyCompare</span>());</span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：参数只有两个的谓词，称为二元谓词</p><h2 id="内建函数对象"><a class="header-anchor" href="#内建函数对象"></a>内建函数对象</h2><h3 id="内建函数对象意义"><a class="header-anchor" href="#内建函数对象意义"></a>内建函数对象意义</h3><p><strong>概念：</strong></p><ul><li>STL内建了一些函数对象</li></ul><p><strong>分类:</strong></p><ul><li>算术仿函数</li><li>关系仿函数</li><li>逻辑仿函数</li></ul><p><strong>用法：</strong></p><ul><li>这些仿函数所产生的对象，用法和一般函数完全相同</li><li>使用内建函数对象，需要引入头文件 <code>#include&lt;functional&gt;</code></li></ul><h3 id="算术仿函数"><a class="header-anchor" href="#算术仿函数"></a>算术仿函数</h3><p><strong>功能描述：</strong></p><ul><li>实现四则运算</li><li>其中negate是一元运算，其他都是二元运算</li></ul><p><strong>仿函数原型：</strong></p><ul><li><code>template&lt;class T&gt; T plus&lt;T&gt;</code> //加法仿函数</li><li><code>template&lt;class T&gt; T minus&lt;T&gt;</code> //减法仿函数</li><li><code>template&lt;class T&gt; T multiplies&lt;T&gt;</code> //乘法仿函数</li><li><code>template&lt;class T&gt; T divides&lt;T&gt;</code> //除法仿函数</li><li><code>template&lt;class T&gt; T modulus&lt;T&gt;</code> //取模仿函数</li><li><code>template&lt;class T&gt; T negate&lt;T&gt;</code> //取反仿函数</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//negate</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    negate&lt;<span class="keyword">int</span>&gt; n;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">n</span>(<span class="number">50</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//plus</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    plus&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">p</span>(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：使用内建函数对象时，需要引入头文件 <code>#include &lt;functional&gt;</code></p><h3 id="关系仿函数"><a class="header-anchor" href="#关系仿函数"></a>关系仿函数</h3><p><strong>功能描述：</strong></p><ul><li>实现关系对比</li></ul><p><strong>仿函数原型：</strong></p><ul><li><code>template&lt;class T&gt; bool equal_to&lt;T&gt;</code> //等于</li><li><code>template&lt;class T&gt; bool not_equal_to&lt;T&gt;</code> //不等于</li><li><code>template&lt;class T&gt; bool greater&lt;T&gt;</code> //大于</li><li><code>template&lt;class T&gt; bool greater_equal&lt;T&gt;</code> //大于等于</li><li><code>template&lt;class T&gt; bool less&lt;T&gt;</code> //小于</li><li><code>template&lt;class T&gt; bool less_equal&lt;T&gt;</code> //小于等于</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCompare</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自己实现仿函数</span></span><br><span class="line">    <span class="comment">//sort(v.begin(), v.end(), MyCompare());</span></span><br><span class="line">    <span class="comment">//STL内建仿函数  大于仿函数</span></span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="逻辑仿函数"><a class="header-anchor" href="#逻辑仿函数"></a>逻辑仿函数</h3><p><strong>功能描述：</strong></p><ul><li>实现逻辑运算</li></ul><p><strong>函数原型：</strong></p><ul><li><code>template&lt;class T&gt; bool logical_and&lt;T&gt;</code> //逻辑与</li><li><code>template&lt;class T&gt; bool logical_or&lt;T&gt;</code> //逻辑或</li><li><code>template&lt;class T&gt; bool logical_not&lt;T&gt;</code> //逻辑非</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">bool</span>&gt; v;</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="literal">true</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="literal">true</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="keyword">bool</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//逻辑非  将v容器搬运到v2中，并执行逻辑非运算</span></span><br><span class="line">    vector&lt;<span class="keyword">bool</span>&gt; v2;</span><br><span class="line">    v2.<span class="built_in">resize</span>(v.<span class="built_in">size</span>());</span><br><span class="line">    <span class="built_in">transform</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), logical_not&lt;<span class="keyword">bool</span>&gt;());</span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="keyword">bool</span>&gt;::iterator it = v2.<span class="built_in">begin</span>(); it != v2.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;函数对象&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#函数对象&quot;&gt;&lt;/a&gt;函数对象&lt;/h2&gt;
&lt;h3 id=&quot;函数对象概念&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#函数对象概念&quot;&gt;&lt;/a&gt;函数对象概念&lt;/h3&gt;
&lt;p</summary>
      
    
    
    
    <category term="STL" scheme="http://halo123.top/categories/STL/"/>
    
    
    <category term="STL" scheme="http://halo123.top/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>STL常用容器</title>
    <link href="http://halo123.top/2021/04/18/C++/STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8-stl-container/"/>
    <id>http://halo123.top/2021/04/18/C++/STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8-stl-container/</id>
    <published>2021-04-18T07:08:52.298Z</published>
    <updated>2021-04-18T07:08:52.298Z</updated>
    
    <content type="html"><![CDATA[<h2 id="string容器"><a class="header-anchor" href="#string容器"></a>string容器</h2><h3 id="string基本概念"><a class="header-anchor" href="#string基本概念"></a>string基本概念</h3><p><strong>本质</strong>：<code>string</code>是C++风格的字符串，而<code>string</code>本质上是一个类。</p><p><strong><code>string</code>和<code>char*</code> 区别</strong>：</p><ul><li><code>char*</code> 是一个指针</li><li><code>string</code>是一个类，类内部封装了<code>char*</code>，管理这个字符串，是一个<code>char*</code>型的容器。</li></ul><p><strong>特点</strong>：</p><ol><li><code>string</code> 类内部封装了很多成员方法，例如：查找find，拷贝copy，删除delete 替换replace，插入insert</li><li>string管理<code>char*</code>所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责。</li></ol><h3 id="string构造函数"><a class="header-anchor" href="#string构造函数"></a>string构造函数</h3><p>构造函数原型：</p><ul><li><code>string();</code>  //创建一个空的字符串 例如: string str;</li><li><code>string(const char* s);</code> //使用字符串s初始化</li><li><code>string(const string&amp; str);</code> //使用一个string对象初始化另一个string对象</li><li><code>string(int n, char c);</code> //使用n个字符c初始化</li></ul><p>使用不同构造函数创建string对象，<strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//string构造</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s1; <span class="comment">//创建空字符串，调用无参构造函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; s1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="function">string <span class="title">s2</span><span class="params">(str)</span></span>; <span class="comment">//把c_string转换成了string</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str2 = &quot;</span> &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">s3</span><span class="params">(s2)</span></span>; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">s4</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：string的多种构造方式没有可比性，灵活使用即可</p><h3 id="string赋值操作"><a class="header-anchor" href="#string赋值操作"></a>string赋值操作</h3><p>功能描述：给string字符串进行赋值</p><p>函数原型：</p><ul><li><code>string&amp; operator=(const char* s);</code> //char*类型字符串 赋值给当前的字符串</li><li><code>string&amp; operator=(const string &amp;s);</code> //把字符串s赋给当前的字符串</li><li><code>string&amp; operator=(char c);</code> //字符赋值给当前的字符串</li><li><code>string&amp; assign(const char *s);</code> //把字符串s赋给当前的字符串</li><li><code>string&amp; assign(const char *s, int n);</code> //把字符串s的前n个字符赋给当前的字符串</li><li><code>string&amp; assign(const string &amp;s);</code> //把字符串对象s的值赋给当前字符串</li><li><code>string&amp; assign(int n, char c);</code> //用n个字符c赋给当前字符串</li></ul><p>不同赋值函数的使用，示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str1;</span><br><span class="line">    str1 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    string str2;</span><br><span class="line">    str2 = str1;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str2 = &quot;</span> &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    string str3;</span><br><span class="line">    str3 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把字符串s赋给当前的字符串</span></span><br><span class="line">    string str4;</span><br><span class="line">    str4.<span class="built_in">assign</span>(<span class="string">&quot;hello c++&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str4 = &quot;</span> &lt;&lt; str4 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把字符串s的前n个字符赋给当前的字符串</span></span><br><span class="line">    string str5;</span><br><span class="line">    str5.<span class="built_in">assign</span>(<span class="string">&quot;hello c++&quot;</span>,<span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str5 = &quot;</span> &lt;&lt; str5 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把字符串对象s的值赋给当前字符串</span></span><br><span class="line">    string str6;</span><br><span class="line">    str6.<span class="built_in">assign</span>(str5);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str6 = &quot;</span> &lt;&lt; str6 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用n个字符c赋给当前字符串</span></span><br><span class="line">    string str7;</span><br><span class="line">    str7.<span class="built_in">assign</span>(<span class="number">5</span>, <span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str7 = &quot;</span> &lt;&lt; str7 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结： string的赋值方式很多，<code>operator=</code> 这种方式是比较实用的</p><h3 id="string字符串拼接"><a class="header-anchor" href="#string字符串拼接"></a>string字符串拼接</h3><p><strong>功能描述</strong>：实现在字符串末尾拼接字符串</p><p><strong>函数原型</strong>：</p><ul><li><code>string&amp; operator+=(const char* str);</code> //重载+=操作符</li><li><code>string&amp; operator+=(const char c);</code> //重载+=操作符</li><li><code>string&amp; operator+=(const string&amp; str);</code> //重载+=操作符</li><li><code>string&amp; append(const char *s);</code> //把字符串s连接到当前字符串结尾</li><li><code>string&amp; append(const char *s, int n);</code> //把字符串s的前n个字符连接到当前字符串结尾</li><li><code>string&amp; append(const string &amp;s);</code> //同operator+=(const string&amp; str)</li><li><code>string&amp; append(const string &amp;s, int pos, int n);</code>//字符串s中从pos开始的n个字符连接到字符串结尾</li></ul><p>拼接示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串拼接</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string str1 = <span class="string">&quot;你好&quot;</span>;</span><br><span class="line">    str1 += <span class="string">&quot;世界 &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    str1 += <span class="string">&#x27;:&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    string str2 = <span class="string">&quot; Hello,World&quot;</span>;</span><br><span class="line">    str1 += str2;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    string str3 = <span class="string">&quot;I&quot;</span>;</span><br><span class="line">    str3.<span class="built_in">append</span>(<span class="string">&quot; am &quot;</span>);</span><br><span class="line">    str3.<span class="built_in">append</span>(<span class="string">&quot;Halo Hola&quot;</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="comment">//str3.append(str2);</span></span><br><span class="line">    str3.<span class="built_in">append</span>(str2, <span class="number">4</span>, <span class="number">2</span>); <span class="comment">// 从下标4位置开始 ，截取3个字符，拼接到字符串末尾</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="string查找和替换"><a class="header-anchor" href="#string查找和替换"></a>string查找和替换</h3><p><strong>功能描述</strong>：</p><ul><li>查找：查找指定字符串是否存在</li><li>替换：在指定的位置替换字符串</li></ul><p><strong>函数原型</strong>：</p><ul><li><code>int find(const string&amp; str, int pos = 0) const;</code> //查找str第一次出现位置,从pos开始查找</li><li><code>int find(const char* s, int pos = 0) const;</code> //查找s第一次出现位置,从pos开始查找</li><li><code>int find(const char* s, int pos, int n) const;</code> //从pos位置查找s的前n个字符第一次位置</li><li><code>int find(const char c, int pos = 0) const;</code> //查找字符c第一次出现位置</li><li><code>int rfind(const string&amp; str, int pos = npos) const;</code> //查找str最后一次位置,从pos开始查找</li><li><code>int rfind(const char* s, int pos = npos) const;</code> //查找s最后一次出现位置,从pos开始查找</li><li><code>int rfind(const char* s, int pos, int n) const;</code> //从pos查找s的前n个字符最后一次位置</li><li><code>int rfind(const char c, int pos = 0) const;</code> //查找字符c最后一次出现位置</li><li><code>string&amp; replace(int pos, int n, const string&amp; str);</code> //替换从pos开始n个字符为字符串str</li><li><code>string&amp; replace(int pos, int n,const char* s);</code> //替换从pos开始的n个字符为字符串s</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找和替换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//查找</span></span><br><span class="line">    string str1 = <span class="string">&quot;abcdefgde&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> pos = str1.<span class="built_in">find</span>(<span class="string">&quot;de&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pos == <span class="number">-1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;未找到&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;pos = &quot;</span> &lt;&lt; pos &lt;&lt; endl; <span class="comment">// pos = 3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pos = str1.<span class="built_in">rfind</span>(<span class="string">&quot;de&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pos = &quot;</span> &lt;&lt; pos &lt;&lt; endl; <span class="comment">// pos = 7</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//替换</span></span><br><span class="line">    string str1 = <span class="string">&quot;abcdefgde&quot;</span>;</span><br><span class="line">    str1.<span class="built_in">replace</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="string">&quot;1111&quot;</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl; <span class="comment">// str1 = a1111efgde</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>find查找是从左往后，rfind从右往左</li><li>find找到字符串后返回查找的第一个字符位置，找不到返回-1</li><li>replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串</li></ul><h3 id="string字符串比较"><a class="header-anchor" href="#string字符串比较"></a>string字符串比较</h3><p><strong>功能描述</strong>：字符串之间的比较</p><p><strong>比较方式</strong>：字符串比较是按字符的ASCII码进行对比。等于返回 0；大于返回 1；小于返回 -1。</p><p><strong>函数原型</strong>：</p><ul><li><code>int compare(const string &amp;s) const;</code> //与字符串s比较</li><li><code>int compare(const char *s) const;</code> //与字符串s比较</li></ul><p>比较，示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串比较</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    string s2 = <span class="string">&quot;aello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = s1.<span class="built_in">compare</span>(s2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;s1 等于 s2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;s1 大于 s2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;s1 小于 s2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：字符串对比主要是用于比较两个字符串是否相等，判断谁大谁小的意义并不是很大</p><h3 id="string字符存取"><a class="header-anchor" href="#string字符存取"></a>string字符存取</h3><p>string中单个字符存取方式有两种</p><ul><li><code>char&amp; operator[](int n);</code> //通过[]方式取字符</li><li><code>char&amp; at(int n);</code> //通过at方法获取字符</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; str[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; str.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//字符修改</span></span><br><span class="line">    str[<span class="number">0</span>] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">    str.<span class="built_in">at</span>(<span class="number">1</span>) = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="string插入和删除"><a class="header-anchor" href="#string插入和删除"></a>string插入和删除</h3><p><strong>功能描述</strong>：对string字符串进行插入和删除字符操作</p><p><strong>函数原型</strong>：</p><ul><li><code>string&amp; insert(int pos, const char* s);</code> //插入字符串</li><li><code>string&amp; insert(int pos, const string&amp; str);</code> //插入字符串</li><li><code>string&amp; insert(int pos, int n, char c);</code> //在指定位置插入n个字符c</li><li><code>string&amp; erase(int pos, int n = npos);</code> //删除从pos开始的n个字符</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    str.<span class="built_in">insert</span>(<span class="number">1</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    str.<span class="built_in">erase</span>(<span class="number">1</span>, <span class="number">3</span>);  <span class="comment">//从1号位置开始3个字符</span></span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong>：插入和删除的起始下标都是从0开始</p><h3 id="string子串"><a class="header-anchor" href="#string子串"></a>string子串</h3><p><strong>功能描述</strong>：从字符串中获取想要的子串</p><p><strong>函数原型</strong>：<code>string substr(int pos = 0, int n = npos) const;</code> //返回由pos开始的n个字符组成的字符串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    string str = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">    string subStr = str.<span class="built_in">substr</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;subStr = &quot;</span> &lt;&lt; subStr &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    string email = <span class="string">&quot;hello@sina.com&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> pos = email.<span class="built_in">find</span>(<span class="string">&quot;@&quot;</span>);</span><br><span class="line">    string username = email.<span class="built_in">substr</span>(<span class="number">0</span>, pos);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;username: &quot;</span> &lt;&lt; username &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong>：灵活的运用求子串功能，可以在实际开发中获取有效的信息</p><h2 id="vector容器"><a class="header-anchor" href="#vector容器"></a>vector容器</h2><h3 id="vector基本概念"><a class="header-anchor" href="#vector基本概念"></a>vector基本概念</h3><p><strong>功能</strong>：vector数据结构和<strong>数组非常相似</strong>，也称为<strong>单端数组</strong>。vector容器的迭代器是支持随机访问的迭代器</p><p><strong>vector与普通数组区别</strong>：不同之处在于数组是静态空间，而vector可以<font color="#faa755">动态扩展</font></p><p><strong>动态扩展</strong>：并不是在原空间之后接新空间，而是找更大的内存空间，然后将原数据拷贝到新空间，释放原空间</p><h3 id="vector构造函数"><a class="header-anchor" href="#vector构造函数"></a>vector构造函数</h3><p><strong>功能描述</strong>：创建vector容器</p><p><strong>函数原型</strong>：</p><ul><li><code>vector&lt;T&gt; v;</code> //采用模板实现类实现，默认构造函数</li><li><code>vector(v.begin(), v.end());</code> //将<code>v[begin(), end())</code>区间中的元素拷贝给本身。</li><li><code>vector(n, elem);</code> //构造函数将n个elem拷贝给本身。</li><li><code>vector(const vector &amp;vec);</code> //拷贝构造函数。</li></ul><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v1; <span class="comment">//无参构造</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v2</span><span class="params">(v1.begin(), v1.end())</span></span>;</span><br><span class="line">    <span class="built_in">printVector</span>(v2);</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">10</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="built_in">printVector</span>(v3);</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v4</span><span class="params">(v3)</span></span>;</span><br><span class="line">    <span class="built_in">printVector</span>(v4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="vector赋值操作"><a class="header-anchor" href="#vector赋值操作"></a>vector赋值操作</h3><p><strong>功能描述</strong>：给vector容器进行赋值</p><p><strong>函数原型</strong>：</p><ul><li><code>vector&amp; operator=(const vector &amp;vec);</code>//重载等号操作符</li><li><code>assign(beg, end);</code> //将[beg, end)区间中的数据拷贝赋值给本身。</li><li><code>assign(n, elem);</code> //将n个elem拷贝赋值给本身。</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v1; <span class="comment">//无参构造</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">    v2 = v1;</span><br><span class="line">    <span class="built_in">printVector</span>(v2);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v3;</span><br><span class="line">    v3.<span class="built_in">assign</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">printVector</span>(v3);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v4;</span><br><span class="line">    v4.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">printVector</span>(v4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="vector容量和大小"><a class="header-anchor" href="#vector容量和大小"></a>vector容量和大小</h3><p><strong>功能描述</strong>：对vector容器的容量和大小操作</p><p><strong>函数原型</strong>：</p><ul><li><code>empty();</code> //判断容器是否为空</li><li><code>capacity();</code> //容器的容量</li><li><code>size();</code> //返回容器中元素的个数</li><li><code>resize(int num);</code> //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</li><li><code>resize(int num, elem);</code> //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printVector</span>(v1);</span><br><span class="line">    <span class="keyword">if</span> (v1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;v1为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;v1不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;v1的容量 = &quot;</span> &lt;&lt; v1.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;v1的大小 = &quot;</span> &lt;&lt; v1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//resize 重新指定大小 ，若指定的更大，默认用0填充新位置，可以利用重载版本替换默认填充</span></span><br><span class="line">    v1.<span class="built_in">resize</span>(<span class="number">15</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//resize 重新指定大小 ，若指定的更小，超出部分元素被删除</span></span><br><span class="line">    v1.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printVector</span>(v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>判断是否为空 — empty</li><li>返回元素个数 — size</li><li>返回容器容量 — capacity</li><li>重新指定大小 — resize</li></ul><h3 id="vector插入和删除"><a class="header-anchor" href="#vector插入和删除"></a>vector插入和删除</h3><p><strong>功能描述</strong>：对vector容器进行插入、删除操作</p><p><strong>函数原型</strong>：</p><ul><li><code>push_back(ele);</code> //尾部插入元素ele</li><li><code>pop_back();</code> //删除最后一个元素</li><li><code>insert(const_iterator pos, ele);</code> //迭代器指向位置pos插入元素ele</li><li><code>insert(const_iterator pos, int count,ele);</code>//迭代器指向位置pos插入count个元素ele</li><li><code>erase(const_iterator pos);</code> //删除迭代器指向的元素</li><li><code>erase(const_iterator start, const_iterator end);</code>//删除迭代器从start到end之间的元素</li><li><code>clear();</code> //删除容器中所有元素</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    <span class="comment">//尾插</span></span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">    <span class="built_in">printVector</span>(v1);</span><br><span class="line">    <span class="comment">//尾删</span></span><br><span class="line">    v1.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="built_in">printVector</span>(v1);</span><br><span class="line">    <span class="comment">//插入</span></span><br><span class="line">    v1.<span class="built_in">insert</span>(v1.<span class="built_in">begin</span>(), <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">    v1.<span class="built_in">insert</span>(v1.<span class="built_in">begin</span>(), <span class="number">2</span>, <span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除</span></span><br><span class="line">    v1.<span class="built_in">erase</span>(v1.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清空</span></span><br><span class="line">    v1.<span class="built_in">erase</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line">    v1.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">printVector</span>(v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>尾插 — push_back</li><li>尾删 — pop_back</li><li>插入 — insert (位置迭代器)</li><li>删除 — erase （位置迭代器）</li><li>清空 — clear</li></ul><h3 id="vector数据存取"><a class="header-anchor" href="#vector数据存取"></a>vector数据存取</h3><p><strong>功能描述</strong>：对vector中的数据的存取操作</p><p><strong>函数原型</strong>：</p><ul><li><code>at(int idx);</code> //返回索引idx所指的数据</li><li><code>operator[];</code> //返回索引idx所指的数据</li><li><code>front();</code> //返回容器中第一个数据元素</li><li><code>back();</code> //返回容器中最后一个数据元素</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; v1.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v1的第一个元素为： &quot;</span> &lt;&lt; v1.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v1的最后一个元素为： &quot;</span> &lt;&lt; v1.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>除了用迭代器获取vector容器中元素，[ ]和at也可以</li><li>front返回容器第一个元素</li><li>back返回容器最后一个元素</li></ul><h3 id="vector互换容器"><a class="header-anchor" href="#vector互换容器"></a>vector互换容器</h3><p><strong>功能描述</strong>：实现两个容器内元素进行互换</p><p><strong>函数原型</strong>：<code>swap(vec);</code> // 将vec与本身的元素互换</p><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        v2.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printVector</span>(v2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//互换容器</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;互换后&quot;</span> &lt;&lt; endl;</span><br><span class="line">    v1.<span class="built_in">swap</span>(v2);</span><br><span class="line">    <span class="built_in">printVector</span>(v1);</span><br><span class="line">    <span class="built_in">printVector</span>(v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    v.<span class="built_in">resize</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//收缩内存</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;(v).<span class="built_in">swap</span>(v); <span class="comment">//匿名对象</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：swap可以使两个容器互换，可以达到实用的收缩内存效果</p><h3 id="vector预留空间"><a class="header-anchor" href="#vector预留空间"></a>vector预留空间</h3><p><strong>功能描述</strong>：减少vector在动态扩展容量时的扩展次数</p><p><strong>函数原型</strong>：<code>reserve(int len);</code>//容器预留len个元素长度，预留位置不初始化，元素不可访问。</p><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//预留空间</span></span><br><span class="line">    v.<span class="built_in">reserve</span>(<span class="number">100000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="comment">// 统计扩容次数</span></span><br><span class="line">        <span class="keyword">if</span> (p != &amp;v[<span class="number">0</span>]) &#123;</span><br><span class="line">            p = &amp;v[<span class="number">0</span>];</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;扩容了 &quot;</span> &lt;&lt; num - <span class="number">1</span> &lt;&lt; <span class="string">&quot; 次&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：如果数据量较大，可以一开始利用reserve预留空间</p><h2 id="deque容器"><a class="header-anchor" href="#deque容器"></a>deque容器</h2><h3 id="deque容器基本概念"><a class="header-anchor" href="#deque容器基本概念"></a>deque容器基本概念</h3><p><strong>功能</strong>：双端数组，可以对头端进行插入删除操作</p><p><strong>deque与vector区别</strong>：</p><ul><li>vector对于头部的插入删除效率低，数据量越大，效率越低</li><li>deque相对而言，对头部的插入删除速度回比vector快</li><li>vector访问元素时的速度会比deque快，这和两者内部实现有关</li></ul><p>deque内部工作原理：deque内部有个<strong>中控器</strong>，维护每段缓冲区中的内容，缓冲区中存放真实数据，中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间。</p><p>deque容器的迭代器也是支持随机访问的</p><h3 id="deque构造函数"><a class="header-anchor" href="#deque构造函数"></a>deque构造函数</h3><p><strong>功能描述</strong>：deque容器构造</p><p><strong>函数原型</strong>：</p><ul><li><code>deque&lt;T&gt; deqT;</code> //默认构造形式</li><li><code>deque(beg, end);</code> //构造函数将[beg, end)区间中的元素拷贝给本身。</li><li><code>deque(n, elem);</code> //构造函数将n个elem拷贝给本身。</li><li><code>deque(const deque &amp;deq);</code> //拷贝构造函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> deque&lt;<span class="keyword">int</span>&gt; &amp;d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (deque&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//deque构造</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; d1; <span class="comment">//无参构造函数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        d1.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printDeque</span>(d1);</span><br><span class="line">    <span class="function">deque&lt;<span class="keyword">int</span>&gt; <span class="title">d2</span><span class="params">(d1.begin(), d1.end())</span></span>;</span><br><span class="line">    <span class="built_in">printDeque</span>(d2);</span><br><span class="line"></span><br><span class="line">    <span class="function">deque&lt;<span class="keyword">int</span>&gt; <span class="title">d3</span><span class="params">(<span class="number">10</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="built_in">printDeque</span>(d3);</span><br><span class="line"></span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; d4 = d3;</span><br><span class="line">    <span class="built_in">printDeque</span>(d4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong>：deque容器和vector容器的构造方式几乎一致，灵活使用即可</p><h3 id="deque赋值操作"><a class="header-anchor" href="#deque赋值操作"></a>deque赋值操作</h3><p><strong>功能描述</strong>：给deque容器进行赋值</p><p><strong>函数原型</strong>：</p><ul><li><code>deque&amp; operator=(const deque &amp;deq);</code> //重载等号操作符</li><li><code>assign(beg, end);</code> //将[beg, end)区间中的数据拷贝赋值给本身。</li><li><code>assign(n, elem);</code> //将n个elem拷贝赋值给本身。</li></ul><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> deque&lt;<span class="keyword">int</span>&gt; &amp;d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (deque&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; d1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        d1.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; d2;</span><br><span class="line">    d2 = d1;</span><br><span class="line">    <span class="built_in">printDeque</span>(d2);</span><br><span class="line"></span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; d3;</span><br><span class="line">    d3.<span class="built_in">assign</span>(d1.<span class="built_in">begin</span>(), d1.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">printDeque</span>(d3);</span><br><span class="line"></span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; d4;</span><br><span class="line">    d4.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">printDeque</span>(d4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：deque赋值操作也与vector相同，需熟练掌握</p><h3 id="deque大小操作"><a class="header-anchor" href="#deque大小操作"></a>deque大小操作</h3><p><strong>功能描述</strong>：对deque容器的大小进行操作</p><p><strong>函数原型</strong>：</p><ul><li><code>deque.empty();</code> //判断容器是否为空</li><li><code>deque.size();</code> //返回容器中元素的个数</li><li><code>deque.resize(num);</code> //重新指定容器的长度为num,若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</li><li><code>deque.resize(num, elem);</code> //重新指定容器的长度为num,若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</li></ul><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> deque&lt;<span class="keyword">int</span>&gt; &amp;d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (deque&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; d1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        d1.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断容器是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (d1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;d1为空!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;d1不为空!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">//统计大小</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;d1的大小为：&quot;</span> &lt;&lt; d1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重新指定大小</span></span><br><span class="line">    d1.<span class="built_in">resize</span>(<span class="number">15</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">    d1.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printDeque</span>(d1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>deque没有容量的概念</li><li>判断是否为空 — empty</li><li>返回元素个数 — size</li><li>重新指定个数 — resize</li></ul><h3 id="deque-插入和删除"><a class="header-anchor" href="#deque-插入和删除"></a>deque 插入和删除</h3><p><strong>功能描述</strong>：向deque容器中插入和删除数据</p><p><strong>函数原型</strong>：</p><p>两端插入操作：</p><ul><li><code>push_back(elem);</code> //在容器尾部添加一个数据</li><li><code>push_front(elem);</code> //在容器头部插入一个数据</li><li><code>pop_back();</code> //删除容器最后一个数据</li><li><code>pop_front();</code> //删除容器第一个数据</li></ul><p>指定位置操作：</p><ul><li><code>insert(pos,elem);</code> //在pos位置插入一个elem元素的拷贝，返回新数据的位置。</li><li><code>insert(pos,n,elem);</code> //在pos位置插入n个elem数据，无返回值。</li><li><code>insert(pos,beg,end);</code> //在pos位置插入[beg,end)区间的数据，无返回值。</li><li><code>clear();</code> //清空容器的所有数据</li><li><code>erase(beg,end);</code> //删除[beg,end)区间的数据，返回下一个数据的位置。</li><li><code>erase(pos);</code> //删除pos位置的数据，返回下一个数据的位置。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> deque&lt;<span class="keyword">int</span>&gt; &amp;d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (deque&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两端操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;=======两端操作=======&quot;</span> &lt;&lt; endl;</span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">    <span class="comment">//尾插</span></span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="comment">//头插</span></span><br><span class="line">    d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">    d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尾删</span></span><br><span class="line">    d.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="comment">//头删</span></span><br><span class="line">    d.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="built_in">printDeque</span>(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;=========插入=========&quot;</span> &lt;&lt; endl;</span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">    d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line">    <span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">    d.<span class="built_in">insert</span>(d.<span class="built_in">begin</span>(), <span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">    d.<span class="built_in">insert</span>(d.<span class="built_in">begin</span>(), <span class="number">2</span>, <span class="number">10000</span>);</span><br><span class="line">    <span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; d2;</span><br><span class="line">    d2.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    d2.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    d2.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    d.<span class="built_in">insert</span>(d.<span class="built_in">begin</span>(), d2.<span class="built_in">begin</span>(), d2.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">printDeque</span>(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;=========删除=========&quot;</span> &lt;&lt; endl;</span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">    d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line">    <span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">    d.<span class="built_in">erase</span>(d.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">    d.<span class="built_in">erase</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line">    d.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">printDeque</span>(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>插入和删除提供的位置是迭代器！</li><li>尾插 — push_back</li><li>尾删 — pop_back</li><li>头插 — push_front</li><li>头删 — pop_front</li></ul><h3 id="deque-数据存取"><a class="header-anchor" href="#deque-数据存取"></a>deque 数据存取</h3><p><strong>功能描述</strong>：对deque 中的数据的存取操作</p><p><strong>函数原型</strong>：</p><ul><li><code>at(int idx);</code> //返回索引idx所指的数据</li><li><code>operator[];</code> //返回索引idx所指的数据</li><li><code>front();</code> //返回容器中第一个数据元素</li><li><code>back();</code> //返回容器中最后一个数据元素</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据存取</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">    d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; d[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; d.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;front:&quot;</span> &lt;&lt; d.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;back:&quot;</span> &lt;&lt; d.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>除了用迭代器获取deque容器中元素，[ ]和at也可以</li><li>front返回容器第一个元素</li><li>back返回容器最后一个元素</li></ul><h3 id="deque-排序"><a class="header-anchor" href="#deque-排序"></a>deque 排序</h3><p><strong>功能描述</strong>：利用算法实现对deque容器进行排序</p><p><strong>算法</strong>：</p><ul><li><code>sort(iterator beg, iterator end)</code> //对beg和end区间内元素进行排序</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> deque&lt;<span class="keyword">int</span>&gt; &amp;d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (deque&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">    d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printDeque</span>(d);</span><br><span class="line">    <span class="built_in">sort</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：sort算法非常实用，使用时包含头文件 algorithm即可</p><h2 id="stack容器"><a class="header-anchor" href="#stack容器"></a>stack容器</h2><h3 id="stack-基本概念"><a class="header-anchor" href="#stack-基本概念"></a>stack 基本概念</h3><p>概念：stack是一种<strong>先进后出</strong>(First In Last Out,FILO)的数据结构，它只有一个出口</p><p>栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为</p><p>栈中进入数据称为 — <strong>入栈</strong> <code>push</code></p><p>栈中弹出数据称为 — <strong>出栈</strong> <code>pop</code></p><h3 id="stack-常用接口"><a class="header-anchor" href="#stack-常用接口"></a>stack 常用接口</h3><p>功能描述：栈容器常用的对外接口</p><p>构造函数：</p><ul><li><code>stack&lt;T&gt; stk;</code> //stack采用模板类实现， stack对象的默认构造形式</li><li><code>stack(const stack &amp;stk);</code> //拷贝构造函数</li></ul><p>赋值操作：</p><ul><li><code>stack&amp; operator=(const stack &amp;stk);</code> //重载等号操作符</li></ul><p>数据存取：</p><ul><li><code>push(elem);</code> //向栈顶添加元素</li><li><code>pop();</code> //从栈顶移除第一个元素</li><li><code>top();</code> //返回栈顶元素</li></ul><p>大小操作：</p><ul><li><code>empty();</code> //判断堆栈是否为空</li><li><code>size();</code> //返回栈的大小</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈容器常用接口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建栈容器 栈容器必须符合先进后出</span></span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向栈中添加元素，叫做 压栈 入栈</span></span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">//输出栈顶元素</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;栈顶元素为： &quot;</span> &lt;&lt; s.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="comment">//弹出栈顶元素</span></span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;栈的大小为：&quot;</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>入栈 — push</li><li>出栈 — pop</li><li>返回栈顶 — top</li><li>判断栈是否为空 — empty</li><li>返回栈大小 — size</li></ul><h2 id="queue-容器"><a class="header-anchor" href="#queue-容器"></a>queue 容器</h2><h3 id="queue-基本概念"><a class="header-anchor" href="#queue-基本概念"></a>queue 基本概念</h3><p>概念：Queue是一种<strong>先进先出</strong>(First In First Out,FIFO)的数据结构，它有两个出口</p><p>队列容器允许从一端新增元素，从另一端移除元素</p><p>队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为</p><p>队列中进数据称为 — <strong>入队</strong> <code>push</code></p><p>队列中出数据称为 — <strong>出队</strong> <code>pop</code></p><h3 id="queue-常用接口"><a class="header-anchor" href="#queue-常用接口"></a>queue 常用接口</h3><p>功能描述：栈容器常用的对外接口</p><p>构造函数：</p><ul><li><code>queue&lt;T&gt; que;</code> //queue采用模板类实现，queue对象的默认构造形式</li><li><code>queue(const queue &amp;que);</code> //拷贝构造函数</li></ul><p>赋值操作：</p><ul><li><code>queue&amp; operator=(const queue &amp;que);</code> //重载等号操作符</li></ul><p>数据存取：</p><ul><li><code>push(elem);</code> //往队尾添加元素</li><li><code>pop();</code> //从队头移除第一个元素</li><li><code>back();</code> //返回最后一个元素</li><li><code>front();</code> //返回第一个元素</li></ul><p>大小操作：</p><ul><li><code>empty();</code> //判断堆栈是否为空</li><li><code>size();</code> //返回栈的大小</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string m_Name;</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建队列</span></span><br><span class="line">    queue&lt;Person&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//准备数据</span></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;唐僧&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">1000</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">900</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;沙僧&quot;</span>, <span class="number">800</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向队列中添加元素  入队操作</span></span><br><span class="line">    q.<span class="built_in">push</span>(p1);</span><br><span class="line">    q.<span class="built_in">push</span>(p2);</span><br><span class="line">    q.<span class="built_in">push</span>(p3);</span><br><span class="line">    q.<span class="built_in">push</span>(p4);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列不提供迭代器，更不支持随机访问</span></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">//输出队头元素</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;队头元素-- 姓名： &quot;</span> &lt;&lt; q.<span class="built_in">front</span>().m_Name</span><br><span class="line">             &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; q.<span class="built_in">front</span>().m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;队尾元素-- 姓名： &quot;</span> &lt;&lt; q.<span class="built_in">back</span>().m_Name</span><br><span class="line">             &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; q.<span class="built_in">back</span>().m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="comment">//弹出队头元素</span></span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;队列大小为：&quot;</span> &lt;&lt; q.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>入队 — push</li><li>出队 — pop</li><li>返回队头元素 — front</li><li>返回队尾元素 — back</li><li>判断队是否为空 — empty</li><li>返回队列大小 — size</li></ul><h2 id="list容器"><a class="header-anchor" href="#list容器"></a>list容器</h2><h3 id="list基本概念"><a class="header-anchor" href="#list基本概念"></a>list基本概念</h3><p><strong>功能</strong>：将数据进行链式存储</p><p><strong>链表</strong>（list）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的</p><p>链表的组成：链表由一系列<strong>结点</strong>组成</p><p>结点的组成：一个是存储数据元素的<strong>数据域</strong>，另一个是存储下一个结点地址的<strong>指针域</strong></p><p>STL中的链表是一个双向循环链表</p><p>由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于<strong>双向迭代器</strong></p><p>list的优点：</p><ul><li>采用动态存储分配，不会造成内存浪费和溢出</li><li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li></ul><p>list的缺点：</p><ul><li>链表灵活，但是空间(指针域) 和 时间（遍历）额外耗费较大</li></ul><p>List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。</p><p>总结：STL中<strong>List和vector是两个最常被使用的容器</strong>，各有优缺点</p><h3 id="list构造函数"><a class="header-anchor" href="#list构造函数"></a>list构造函数</h3><p><strong>功能描述</strong>：创建list容器</p><p><strong>函数原型</strong>：</p><ul><li><code>list&lt;T&gt; lst;</code> //list采用采用模板类实现,对象的默认构造形式：</li><li><code>list(beg,end);</code> //构造函数将[beg, end)区间中的元素拷贝给本身。</li><li><code>list(n,elem);</code> //构造函数将n个elem拷贝给本身。</li><li><code>list(const list &amp;lst);</code> //拷贝构造函数。</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> list&lt;<span class="keyword">int</span>&gt; &amp;L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (list&lt;<span class="keyword">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    list&lt;<span class="keyword">int</span>&gt; L1;</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printList</span>(L1);</span><br><span class="line"></span><br><span class="line">    <span class="function">list&lt;<span class="keyword">int</span>&gt; <span class="title">L2</span><span class="params">(L1.begin(), L1.end())</span></span>;</span><br><span class="line">    <span class="built_in">printList</span>(L2);</span><br><span class="line"></span><br><span class="line">    <span class="function">list&lt;<span class="keyword">int</span>&gt; <span class="title">L3</span><span class="params">(L2)</span></span>;</span><br><span class="line">    <span class="built_in">printList</span>(L3);</span><br><span class="line"></span><br><span class="line">    <span class="function">list&lt;<span class="keyword">int</span>&gt; <span class="title">L4</span><span class="params">(<span class="number">10</span>, <span class="number">1000</span>)</span></span>;</span><br><span class="line">    <span class="built_in">printList</span>(L4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：list构造方式同其他几个STL常用容器，熟练掌握即可</p><h3 id="list-赋值和交换"><a class="header-anchor" href="#list-赋值和交换"></a>list 赋值和交换</h3><p><strong>功能描述</strong>：</p><ul><li>给list容器进行赋值，以及交换list容器</li></ul><p><strong>函数原型</strong>：</p><ul><li><code>assign(beg, end);</code> //将[beg, end)区间中的数据拷贝赋值给本身。</li><li><code>assign(n, elem);</code> //将n个elem拷贝赋值给本身。</li><li><code>list&amp; operator=(const list &amp;lst);</code> //重载等号操作符</li><li><code>swap(lst);</code> //将lst与本身的元素互换。</li></ul><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> list&lt;<span class="keyword">int</span>&gt; &amp;L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (list&lt;<span class="keyword">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值和交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;=========赋值=========&quot;</span> &lt;&lt; endl;</span><br><span class="line">    list&lt;<span class="keyword">int</span>&gt; L1;</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">    <span class="built_in">printList</span>(L1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//赋值</span></span><br><span class="line">    list&lt;<span class="keyword">int</span>&gt; L2;</span><br><span class="line">    L2 = L1;</span><br><span class="line">    <span class="built_in">printList</span>(L2);</span><br><span class="line"></span><br><span class="line">    list&lt;<span class="keyword">int</span>&gt; L3;</span><br><span class="line">    L3.<span class="built_in">assign</span>(L2.<span class="built_in">begin</span>(), L2.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">printList</span>(L3);</span><br><span class="line"></span><br><span class="line">    list&lt;<span class="keyword">int</span>&gt; L4;</span><br><span class="line">    L4.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">printList</span>(L4);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;=========交换=========&quot;</span> &lt;&lt; endl;</span><br><span class="line">    list&lt;<span class="keyword">int</span>&gt; L1;</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    list&lt;<span class="keyword">int</span>&gt; L2;</span><br><span class="line">    L2.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;交换前： &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">printList</span>(L1);</span><br><span class="line">    <span class="built_in">printList</span>(L2);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    L1.<span class="built_in">swap</span>(L2);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;交换后： &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">printList</span>(L1);</span><br><span class="line">    <span class="built_in">printList</span>(L2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="list-大小操作"><a class="header-anchor" href="#list-大小操作"></a>list 大小操作</h3><p><strong>功能描述</strong>：对list容器的大小进行操作</p><p><strong>函数原型</strong>：</p><ul><li><code>size();</code> //返回容器中元素的个数</li><li><code>empty();</code> //判断容器是否为空</li><li><code>resize(num);</code> //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。 如果容器变短，则末尾超出容器长度的元素被删除。</li><li><code>resize(num, elem);</code> //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。 如果容器变短，则末尾超出容器长度的元素被删除。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> list&lt;<span class="keyword">int</span>&gt; &amp;L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (list&lt;<span class="keyword">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    list&lt;<span class="keyword">int</span>&gt; L1;</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (L1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;L1为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;L1不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;L1的大小为： &quot;</span> &lt;&lt; L1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重新指定大小</span></span><br><span class="line">    L1.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printList</span>(L1);</span><br><span class="line"></span><br><span class="line">    L1.<span class="built_in">resize</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printList</span>(L1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>判断是否为空 — empty</li><li>返回元素个数 — size</li><li>重新指定个数 — resize</li></ul><h3 id="list-插入和删除"><a class="header-anchor" href="#list-插入和删除"></a>list 插入和删除</h3><p><strong>功能描述</strong>：</p><ul><li>对list容器进行数据的插入和删除</li></ul><p><strong>函数原型</strong>：</p><ul><li><code>push_back(elem);</code>//在容器尾部加入一个元素</li><li><code>pop_back();</code>//删除容器中最后一个元素</li><li><code>push_front(elem);</code>//在容器开头插入一个元素</li><li><code>pop_front();</code>//从容器开头移除第一个元素</li><li><code>insert(pos,elem);</code>//在pos位置插elem元素的拷贝，返回新数据的位置。</li><li><code>insert(pos,n,elem);</code>//在pos位置插入n个elem数据，无返回值。</li><li><code>insert(pos,beg,end);</code>//在pos位置插入[beg,end)区间的数据，无返回值。</li><li><code>clear();</code>//移除容器的所有数据</li><li><code>erase(beg,end);</code>//删除[beg,end)区间的数据，返回下一个数据的位置。</li><li><code>erase(pos);</code>//删除pos位置的数据，返回下一个数据的位置。</li><li><code>remove(elem);</code>//删除容器中所有与elem值匹配的元素。</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> list&lt;<span class="keyword">int</span>&gt; &amp;L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (list&lt;<span class="keyword">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    list&lt;<span class="keyword">int</span>&gt; L;</span><br><span class="line">    <span class="comment">//尾插</span></span><br><span class="line">    L.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    L.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    L.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    <span class="comment">//头插</span></span><br><span class="line">    L.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">    L.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line">    L.<span class="built_in">push_front</span>(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尾删</span></span><br><span class="line">    L.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//头删</span></span><br><span class="line">    L.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入</span></span><br><span class="line">    list&lt;<span class="keyword">int</span>&gt;::iterator it = L.<span class="built_in">begin</span>();</span><br><span class="line">    L.<span class="built_in">insert</span>(++it, <span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除</span></span><br><span class="line">    it = L.<span class="built_in">begin</span>();</span><br><span class="line">    L.<span class="built_in">erase</span>(++it);</span><br><span class="line">    <span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除</span></span><br><span class="line">    L.<span class="built_in">push_back</span>(<span class="number">10000</span>);</span><br><span class="line">    L.<span class="built_in">push_back</span>(<span class="number">10000</span>);</span><br><span class="line">    L.<span class="built_in">push_back</span>(<span class="number">10000</span>);</span><br><span class="line">    <span class="built_in">printList</span>(L);</span><br><span class="line">    L.<span class="built_in">remove</span>(<span class="number">10000</span>);</span><br><span class="line">    <span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清空</span></span><br><span class="line">    L.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">printList</span>(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>尾插 — push_back</li><li>尾删 — pop_back</li><li>头插 — push_front</li><li>头删 — pop_front</li><li>插入 — insert</li><li>删除 — erase</li><li>移除 — remove</li><li>清空 — clear</li></ul><h3 id="list-数据存取"><a class="header-anchor" href="#list-数据存取"></a>list 数据存取</h3><p><strong>功能描述</strong>：对list容器中数据进行存取</p><p><strong>函数原型</strong>：</p><ul><li><code>front();</code> //返回第一个元素。</li><li><code>back();</code> //返回最后一个元素。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据存取</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    list&lt;<span class="keyword">int</span>&gt; L1;</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//cout &lt;&lt; L1.at(0) &lt;&lt; endl;//错误 不支持at访问数据</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; L1[0] &lt;&lt; endl; //错误  不支持[]方式访问数据</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一个元素为： &quot;</span> &lt;&lt; L1.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;最后一个元素为： &quot;</span> &lt;&lt; L1.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//list容器的迭代器是双向迭代器，不支持随机访问</span></span><br><span class="line">    list&lt;<span class="keyword">int</span>&gt;::iterator it = L1.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">//it = it + 1;//错误，不可以跳跃访问，即使是+1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>list容器中不可以通过[]或者at方式访问数据</li><li>返回第一个元素 — front</li><li>返回最后一个元素 — back</li></ul><h3 id="list-反转和排序"><a class="header-anchor" href="#list-反转和排序"></a>list 反转和排序</h3><p><strong>功能描述</strong>：将容器中的元素反转，以及将容器中的数据进行排序</p><p><strong>函数原型</strong>：</p><ul><li><code>reverse();</code> //反转链表</li><li><code>sort();</code> //链表排序</li></ul><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> list&lt;<span class="keyword">int</span>&gt; &amp;L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (list&lt;<span class="keyword">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCompare</span><span class="params">(<span class="keyword">int</span> val1, <span class="keyword">int</span> val2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val1 &gt; val2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反转和排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    list&lt;<span class="keyword">int</span>&gt; L;</span><br><span class="line">    L.<span class="built_in">push_back</span>(<span class="number">90</span>);</span><br><span class="line">    L.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    L.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    L.<span class="built_in">push_back</span>(<span class="number">70</span>);</span><br><span class="line">    <span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反转容器的元素</span></span><br><span class="line">    L.<span class="built_in">reverse</span>();</span><br><span class="line">    <span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//排序</span></span><br><span class="line">    L.<span class="built_in">sort</span>(); <span class="comment">//默认的排序规则 从小到大</span></span><br><span class="line">    <span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">    L.<span class="built_in">sort</span>(myCompare); <span class="comment">//指定规则，从大到小</span></span><br><span class="line">    <span class="built_in">printList</span>(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>反转 — reverse</li><li>排序 — sort （成员函数）</li></ul><h2 id="set-multiset-容器"><a class="header-anchor" href="#set-multiset-容器"></a>set/multiset 容器</h2><h3 id="set基本概念"><a class="header-anchor" href="#set基本概念"></a>set基本概念</h3><p><strong>简介</strong>：所有元素都会在插入时自动被排序</p><p><strong>本质</strong>：set/multiset属于<strong>关联式容器</strong>，底层结构是用<strong>二叉树</strong>实现。</p><p><strong>set和multiset区别</strong>：</p><ul><li>set不允许容器中有重复的元素</li><li>multiset允许容器中有重复的元素</li></ul><h3 id="set构造和赋值"><a class="header-anchor" href="#set构造和赋值"></a>set构造和赋值</h3><p>功能描述：创建set容器以及赋值</p><p>构造：</p><ul><li><code>set&lt;T&gt; st;</code> //默认构造函数：</li><li><code>set(const set &amp;st);</code> //拷贝构造函数</li></ul><p>赋值：</p><ul><li><code>set&amp; operator=(const set &amp;st);</code> //重载等号操作符</li></ul><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSet</span><span class="params">(set&lt;<span class="keyword">int</span>&gt; &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (set&lt;<span class="keyword">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造和赋值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line"></span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">    <span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拷贝构造</span></span><br><span class="line">    <span class="function">set&lt;<span class="keyword">int</span>&gt; <span class="title">s2</span><span class="params">(s1)</span></span>;</span><br><span class="line">    <span class="built_in">printSet</span>(s2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//赋值</span></span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt; s3;</span><br><span class="line">    s3 = s2;</span><br><span class="line">    <span class="built_in">printSet</span>(s3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>set容器插入数据时用insert</li><li>set容器插入数据的数据会自动排序</li></ul><h3 id="set大小和交换"><a class="header-anchor" href="#set大小和交换"></a>set大小和交换</h3><p><strong>功能描述</strong>：</p><ul><li>统计set容器大小以及交换set容器</li></ul><p><strong>函数原型</strong>：</p><ul><li><code>size();</code> //返回容器中元素的数目</li><li><code>empty();</code> //判断容器是否为空</li><li><code>swap(st);</code> //交换两个集合容器</li></ul><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSet</span><span class="params">(set&lt;<span class="keyword">int</span>&gt; &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (set&lt;<span class="keyword">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line"></span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;s1为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;s1不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;s1的大小为： &quot;</span> &lt;&lt; s1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line"></span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt; s2;</span><br><span class="line"></span><br><span class="line">    s2.<span class="built_in">insert</span>(<span class="number">100</span>);</span><br><span class="line">    s2.<span class="built_in">insert</span>(<span class="number">300</span>);</span><br><span class="line">    s2.<span class="built_in">insert</span>(<span class="number">200</span>);</span><br><span class="line">    s2.<span class="built_in">insert</span>(<span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;交换前&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">printSet</span>(s1);</span><br><span class="line">    <span class="built_in">printSet</span>(s2);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;交换后&quot;</span> &lt;&lt; endl;</span><br><span class="line">    s1.<span class="built_in">swap</span>(s2);</span><br><span class="line">    <span class="built_in">printSet</span>(s1);</span><br><span class="line">    <span class="built_in">printSet</span>(s2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>统计大小 — size</li><li>判断是否为空 — empty</li><li>交换容器 — swap</li></ul><h3 id="set插入和删除"><a class="header-anchor" href="#set插入和删除"></a>set插入和删除</h3><p><strong>功能描述</strong>：</p><ul><li>set容器进行插入数据和删除数据</li></ul><p><strong>函数原型</strong>：</p><ul><li><code>insert(elem);</code> //在容器中插入元素。</li><li><code>clear();</code> //清除所有元素</li><li><code>erase(pos);</code> //删除pos迭代器所指的元素，返回下一个元素的迭代器。</li><li><code>erase(beg, end);</code> //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li><li><code>erase(elem);</code> //删除容器中值为elem的元素。</li></ul><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSet</span><span class="params">(set&lt;<span class="keyword">int</span>&gt; &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (set&lt;<span class="keyword">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">    <span class="comment">//插入</span></span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">    <span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除</span></span><br><span class="line">    s1.<span class="built_in">erase</span>(s1.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line">    s1.<span class="built_in">erase</span>(<span class="number">30</span>);</span><br><span class="line">    <span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清空</span></span><br><span class="line">    <span class="comment">//s1.erase(s1.begin(), s1.end());</span></span><br><span class="line">    s1.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">printSet</span>(s1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>插入 — insert</li><li>删除 — erase</li><li>清空 — clear</li></ul><h3 id="set查找和统计"><a class="header-anchor" href="#set查找和统计"></a>set查找和统计</h3><p><strong>功能描述</strong>：</p><ul><li>对set容器进行查找数据以及统计数据</li></ul><p><strong>函数原型</strong>：</p><ul><li><code>find(key);</code> //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li><li><code>count(key);</code> //统计key的元素个数</li></ul><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找和统计</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">    <span class="comment">//插入</span></span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找</span></span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt;::iterator pos = s1.<span class="built_in">find</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pos != s1.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;找到了元素 ： &quot;</span> &lt;&lt; *pos &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;未找到元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//统计</span></span><br><span class="line">    <span class="keyword">int</span> num = s1.<span class="built_in">count</span>(<span class="number">30</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>查找 — find （返回的是迭代器）</li><li>统计 — count （对于set，结果为0或者1）</li></ul><h3 id="set和multiset区别"><a class="header-anchor" href="#set和multiset区别"></a>set和multiset区别</h3><p>掌握set和multiset的区别</p><p><strong>区别</strong>：</p><ul><li>set不可以插入重复数据，而multiset可以</li><li>set插入数据的同时会返回插入结果，表示插入是否成功</li><li>multiset不会检测数据，因此可以插入重复数据</li></ul><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//set和multiset区别</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    pair&lt;set&lt;<span class="keyword">int</span>&gt;::iterator, <span class="keyword">bool</span>&gt; ret = s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret.second) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;第一次插入成功!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;第一次插入失败!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret.second) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;第二次插入成功!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;第二次插入失败!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//multiset</span></span><br><span class="line">    multiset&lt;<span class="keyword">int</span>&gt; ms;</span><br><span class="line">    ms.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    ms.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (multiset&lt;<span class="keyword">int</span>&gt;::iterator it = ms.<span class="built_in">begin</span>(); it != ms.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>如果不允许插入重复数据可以利用set</li><li>如果需要插入重复数据利用multiset</li></ul><h3 id="pair对组创建"><a class="header-anchor" href="#pair对组创建"></a>pair对组创建</h3><p><strong>功能描述</strong>：成对出现的数据，利用对组可以返回两个数据</p><p><strong>两种创建方式</strong>：</p><ul><li><code>pair&lt;type, type&gt; p ( value1, value2 );</code></li><li><code>pair&lt;type, type&gt; p = make_pair( value1, value2 );</code></li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对组创建</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pair&lt;string, int&gt; p(string(&quot;Tom&quot;), 20);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.first &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p.second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    pair&lt;string, <span class="keyword">int</span>&gt; p2 = <span class="built_in">make_pair</span>(<span class="string">&quot;Jerry&quot;</span>, <span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p2.first &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p2.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="set容器排序"><a class="header-anchor" href="#set容器排序"></a>set容器排序</h3><p>学习目标：set容器默认排序规则为从小到大，掌握如何改变排序规则</p><p>主要技术点：利用仿函数，可以改变排序规则</p><p><strong>示例一</strong> set存放内置数据类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCompare</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认从小到大</span></span><br><span class="line">    <span class="keyword">for</span> (set&lt;<span class="keyword">int</span>&gt;::iterator it = s1.<span class="built_in">begin</span>(); it != s1.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定排序规则</span></span><br><span class="line">    set&lt;<span class="keyword">int</span>, MyCompare&gt; s2;</span><br><span class="line">    s2.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    s2.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">    s2.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">    s2.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">    s2.<span class="built_in">insert</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (set&lt;<span class="keyword">int</span>, MyCompare&gt;::iterator it = s2.<span class="built_in">begin</span>(); it != s2.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例二</strong> set存放自定义数据类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string m_Name;</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">comparePerson</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Person &amp;p1, <span class="keyword">const</span> Person &amp;p2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//按照年龄进行排序  降序</span></span><br><span class="line">        <span class="keyword">return</span> p1.m_Age &gt; p2.m_Age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    set&lt;Person, comparePerson&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">23</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">27</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">21</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    s.<span class="built_in">insert</span>(p1);</span><br><span class="line">    s.<span class="built_in">insert</span>(p2);</span><br><span class="line">    s.<span class="built_in">insert</span>(p3);</span><br><span class="line">    s.<span class="built_in">insert</span>(p4);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (set&lt;Person, comparePerson&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于自定义数据类型，set必须指定排序规则才可以插入数据</p><h3 id="map-multimap容器"><a class="header-anchor" href="#map-multimap容器"></a>map/multimap容器</h3><h3 id="map基本概念"><a class="header-anchor" href="#map基本概念"></a>map基本概念</h3><p><strong>简介</strong>：</p><ul><li>map中所有元素都是pair</li><li>pair中第一个元素为key（键值），起到索引作用，第二个元素为value（实值）</li><li>所有元素都会根据元素的键值自动排序</li></ul><p><strong>本质</strong>：</p><ul><li>map/multimap属于<strong>关联式容器</strong>，底层结构是用二叉树实现。</li></ul><p><strong>优点</strong>：</p><ul><li>可以根据key值快速找到value值</li></ul><p>map和multimap<strong>区别</strong>：</p><ul><li>map不允许容器中有重复key值元素</li><li>multimap允许容器中有重复key值元素</li></ul><h3 id="map构造和赋值"><a class="header-anchor" href="#map构造和赋值"></a>map构造和赋值</h3><p><strong>功能描述</strong>：对map容器进行构造和赋值操作</p><p><strong>函数原型</strong>：</p><p><strong>构造</strong>：</p><ul><li><code>map&lt;T1, T2&gt; mp;</code> //map默认构造函数:</li><li><code>map(const map &amp;mp);</code> //拷贝构造函数</li></ul><p><strong>赋值</strong>：</p><ul><li><code>map&amp; operator=(const map &amp;mp);</code> //重载等号操作符</li></ul><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMap</span><span class="params">(map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m; <span class="comment">//默认构造</span></span><br><span class="line">    m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">    <span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line">    map&lt;int, int&gt; m2(m); //拷贝构造</span><br><span class="line">    <span class="built_in">printMap</span>(m2);</span><br><span class="line"></span><br><span class="line">    map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m3;</span><br><span class="line">    m3 = m2; <span class="comment">//赋值</span></span><br><span class="line">    <span class="built_in">printMap</span>(m3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：map中所有元素都是成对出现，插入数据时候要使用对组</p><h3 id="map大小和交换"><a class="header-anchor" href="#map大小和交换"></a>map大小和交换</h3><p><strong>功能描述</strong>：</p><ul><li>统计map容器大小以及交换map容器</li></ul><p>函数原型：</p><ul><li><code>size();</code> //返回容器中元素的数目</li><li><code>empty();</code> //判断容器是否为空</li><li><code>swap(st);</code> //交换两个集合容器</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMap</span><span class="params">(map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;m为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;m不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;m的大小为： &quot;</span> &lt;&lt; m.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">    map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m2;</span><br><span class="line">    m2.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">4</span>, <span class="number">100</span>));</span><br><span class="line">    m2.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">5</span>, <span class="number">200</span>));</span><br><span class="line">    m2.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">6</span>, <span class="number">300</span>));</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;交换前&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">printMap</span>(m);</span><br><span class="line">    <span class="built_in">printMap</span>(m2);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;交换后&quot;</span> &lt;&lt; endl;</span><br><span class="line">    m.<span class="built_in">swap</span>(m2);</span><br><span class="line">    <span class="built_in">printMap</span>(m);</span><br><span class="line">    <span class="built_in">printMap</span>(m2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>统计大小 — size</li><li>判断是否为空 — empty</li><li>交换容器 — swap</li></ul><h3 id="map插入和删除"><a class="header-anchor" href="#map插入和删除"></a>map插入和删除</h3><p><strong>功能描述</strong>：</p><ul><li>map容器进行插入数据和删除数据</li></ul><p><strong>函数原型</strong>：</p><ul><li><code>insert(elem);</code> //在容器中插入元素。</li><li><code>clear();</code> //清除所有元素</li><li><code>erase(pos);</code> //删除pos迭代器所指的元素，返回下一个元素的迭代器。</li><li><code>erase(beg, end);</code> //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li><li><code>erase(key);</code> //删除容器中值为key的元素。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMap</span><span class="params">(map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//插入</span></span><br><span class="line">    map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="comment">//第一种插入方式</span></span><br><span class="line">    m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">    <span class="comment">//第二种插入方式</span></span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">    <span class="comment">//第三种插入方式</span></span><br><span class="line">    m.<span class="built_in">insert</span>(map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::<span class="built_in">value_type</span>(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">    <span class="comment">//第四种插入方式</span></span><br><span class="line">    m[<span class="number">4</span>] = <span class="number">40</span>;</span><br><span class="line">    <span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除</span></span><br><span class="line">    m.<span class="built_in">erase</span>(m.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line">    m.<span class="built_in">erase</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清空</span></span><br><span class="line">    m.<span class="built_in">erase</span>(m.<span class="built_in">begin</span>(), m.<span class="built_in">end</span>());</span><br><span class="line">    m.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">printMap</span>(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>map插入方式很多，记住其一即可</li><li>插入 — insert</li><li>删除 — erase</li><li>清空 — clear</li></ul><h3 id="map查找和统计"><a class="header-anchor" href="#map查找和统计"></a>map查找和统计</h3><p><strong>功能描述</strong>：</p><ul><li>对map容器进行查找数据以及统计数据</li></ul><p><strong>函数原型</strong>：</p><ul><li><code>find(key);</code> //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li><li><code>count(key);</code> //统计key的元素个数</li></ul><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找和统计</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找</span></span><br><span class="line">    map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator pos = m.<span class="built_in">find</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pos != m.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;找到了元素 key = &quot;</span> &lt;&lt; (*pos).first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; (*pos).second &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;未找到元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//统计</span></span><br><span class="line">    <span class="keyword">int</span> num = m.<span class="built_in">count</span>(<span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>查找 — find （返回的是迭代器）</li><li>统计 — count （对于map，结果为0或者1）</li></ul><h3 id="map容器排序"><a class="header-anchor" href="#map容器排序"></a>map容器排序</h3><p><strong>学习目标</strong>：map容器默认排序规则为 按照key值进行 从小到大排序，掌握如何改变排序规则</p><p><strong>主要技术点</strong>：利用仿函数，可以改变排序规则</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCompare</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//默认从小到大排序</span></span><br><span class="line">    <span class="comment">//利用仿函数实现从大到小排序</span></span><br><span class="line">    map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, MyCompare&gt; m;</span><br><span class="line"></span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">4</span>, <span class="number">40</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">5</span>, <span class="number">50</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, MyCompare&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;key:&quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value:&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>利用仿函数可以指定map容器的排序规则</li><li>对于自定义数据类型，map必须要指定排序规则，同set容器</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;string容器&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#string容器&quot;&gt;&lt;/a&gt;string容器&lt;/h2&gt;
&lt;h3 id=&quot;string基本概念&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#string基本概念</summary>
      
    
    
    
    <category term="STL" scheme="http://halo123.top/categories/STL/"/>
    
    
    <category term="STL" scheme="http://halo123.top/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>STL介绍</title>
    <link href="http://halo123.top/2021/04/18/C++/STL%E4%BB%8B%E7%BB%8D-stl-introduce/"/>
    <id>http://halo123.top/2021/04/18/C++/STL%E4%BB%8B%E7%BB%8D-stl-introduce/</id>
    <published>2021-04-18T07:05:03.323Z</published>
    <updated>2021-04-18T07:06:50.665Z</updated>
    
    <content type="html"><![CDATA[<h2 id="STL的诞生"><a class="header-anchor" href="#STL的诞生"></a>STL的诞生</h2><ul><li>长久以来，软件界一直希望建立一种可重复利用的东西</li><li>C++的<strong>面向对象</strong>和<strong>泛型编程</strong>思想，目的就是<strong>复用性的提升</strong></li><li>大多情况下，数据结构和算法都未能有一套标准,导致被迫从事大量重复工作</li><li>为了建立数据结构和算法的一套标准,诞生了<strong>STL</strong></li></ul><h2 id="STL基本概念"><a class="header-anchor" href="#STL基本概念"></a>STL基本概念</h2><ul><li>STL(Standard Template Library，<strong>标准模板库</strong>)</li><li>STL 从广义上分为: <strong>容器(container)、 算法(algorithm)、 迭代器(iterator)</strong></li><li><strong>容器</strong>和<strong>算法</strong>之间通过<strong>迭代器</strong>进行无缝连接。</li><li>STL 几乎所有的代码都采用了模板类或者模板函数</li></ul><h2 id="STL六大组件"><a class="header-anchor" href="#STL六大组件"></a>STL六大组件</h2><p>STL大体分为六大组件，分别是：<strong>容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器</strong></p><ol><li>容器：各种数据结构，如<code>vector</code>、<code>list</code>、<code>deque</code>、<code>set</code>、<code>map</code>等,用来存放数据。</li><li>算法：各种常用的算法，如<code>sort</code>、<code>find</code>、<code>copy</code>、<code>for_each</code>等</li><li>迭代器：扮演了容器与算法之间的胶合剂。</li><li>仿函数：行为类似函数，可作为算法的某种策略。</li><li>适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。</li><li>空间配置器：负责空间的配置与管理。</li></ol><h2 id="STL中容器、算法、迭代器"><a class="header-anchor" href="#STL中容器、算法、迭代器"></a>STL中容器、算法、迭代器</h2><h3 id="容器"><a class="header-anchor" href="#容器"></a>容器</h3><p><strong>容器</strong>：置物之所也</p><p>STL<strong>容器</strong>就是将运用<strong>最广泛的一些数据结构</strong>实现出来，常用的数据结构：数组, 链表,树, 栈, 队列, 集合, 映射表 等</p><p>这些容器分为<strong>序列式容器</strong>和<strong>关联式容器</strong>两种：</p><ul><li><strong>序列式容器</strong>：强调值的排序，序列式容器中的每个元素均有固定的位置。</li><li><strong>关联式容器</strong>：二叉树结构，各元素之间没有严格的物理上的顺序关系</li></ul><h3 id="算法"><a class="header-anchor" href="#算法"></a>算法</h3><p><strong>算法</strong>：问题之解法也</p><p>有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms)</p><p>算法分为：<strong>质变算法</strong>和<strong>非质变算法</strong>。</p><ul><li><p>质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等</p></li><li><p>非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等</p></li></ul><h3 id="迭代器"><a class="header-anchor" href="#迭代器"></a>迭代器</h3><p><strong>迭代器</strong>：容器和算法之间粘合剂</p><p>提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。</p><p>每个容器都有自己专属的迭代器</p><p>迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针</p><p>迭代器种类：</p><table><thead><tr><th>种类</th><th>功能</th><th>支持运算</th></tr></thead><tbody><tr><td>输入迭代器</td><td>对数据的只读访问</td><td>只读，支持++、==、！=</td></tr><tr><td>输出迭代器</td><td>对数据的只写访问</td><td>只写，支持++</td></tr><tr><td>前向迭代器</td><td>读写操作，并能向前推进迭代器</td><td>读写，支持++、==、！=</td></tr><tr><td>双向迭代器</td><td>读写操作，并能向前和向后操作</td><td>读写，支持++、–，</td></tr><tr><td>随机访问迭代器</td><td>读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器</td><td>读写，支持++、–、[n]、-n、&lt;、&lt;=、&gt;、&gt;=</td></tr></tbody></table><p>常用的容器中迭代器种类为双向迭代器，和随机访问迭代器</p><h2 id="容器、算法、迭代器初识"><a class="header-anchor" href="#容器、算法、迭代器初识"></a>容器、算法、迭代器初识</h2><p>STL中最常用的容器为Vector，可以理解为数组，下面我们将学习如何向这个容器中插入数据、并遍历这个容器</p><h3 id="Vector存放内置数据类型"><a class="header-anchor" href="#Vector存放内置数据类型"></a>Vector存放内置数据类型</h3><p>容器： <code>vector</code></p><p>算法： <code>for_each</code></p><p>迭代器： <code>vector&lt;int&gt;::iterator</code></p><p>创建<code>vector</code>容器并遍历输出，<strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyPrint</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建vector容器对象，并且通过模板参数指定容器中存放的数据的类型</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="comment">//向容器中放数据</span></span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//每一个容器都有自己的迭代器，迭代器是用来遍历容器中的元素</span></span><br><span class="line"><span class="comment">//v.begin()返回迭代器，这个迭代器指向容器中第一个数据</span></span><br><span class="line"><span class="comment">//v.end()返回迭代器，这个迭代器指向容器元素的最后一个元素的下一个位置</span></span><br><span class="line"><span class="comment">//vector&lt;int&gt;::iterator 拿到vector&lt;int&gt;这种容器的迭代器类型</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;::iterator pBegin = v.<span class="built_in">begin</span>();</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;::iterator pEnd = v.<span class="built_in">end</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种遍历方式：</span></span><br><span class="line"><span class="keyword">while</span> (pBegin != pEnd) &#123;</span><br><span class="line">cout &lt;&lt; *pBegin &lt;&lt; endl;</span><br><span class="line">pBegin++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种遍历方式：</span></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种遍历方式：</span></span><br><span class="line"><span class="comment">//使用STL提供标准遍历算法  头文件 algorithm</span></span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), MyPrint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">test</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Vector存放自定义数据类型"><a class="header-anchor" href="#Vector存放自定义数据类型"></a>Vector存放自定义数据类型</h3><p><code>vector</code>中存放自定义数据类型，并打印输出，示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">        mName = name;</span><br><span class="line">        mAge = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string mName;</span><br><span class="line">    <span class="keyword">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存放对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建数据</span></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;eee&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p5);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;Person&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; (*it).mName &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; (*it).mAge &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//放对象指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;Person *&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建数据</span></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;eee&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    v.<span class="built_in">push_back</span>(&amp;p1);</span><br><span class="line">    v.<span class="built_in">push_back</span>(&amp;p2);</span><br><span class="line">    v.<span class="built_in">push_back</span>(&amp;p3);</span><br><span class="line">    v.<span class="built_in">push_back</span>(&amp;p4);</span><br><span class="line">    v.<span class="built_in">push_back</span>(&amp;p5);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;Person *&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        Person *p = (*it);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; p-&gt;mName &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; (*it)-&gt;mAge &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Vector容器嵌套容器"><a class="header-anchor" href="#Vector容器嵌套容器"></a>Vector容器嵌套容器</h3><p>容器中嵌套容器，并将所有数据进行遍历输出，示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//容器嵌套容器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; v;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v3;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v4;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">        v2.<span class="built_in">push_back</span>(i + <span class="number">2</span>);</span><br><span class="line">        v3.<span class="built_in">push_back</span>(i + <span class="number">3</span>);</span><br><span class="line">        v4.<span class="built_in">push_back</span>(i + <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将容器元素插入到vector v中</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(v1);</span><br><span class="line">    v.<span class="built_in">push_back</span>(v2);</span><br><span class="line">    v.<span class="built_in">push_back</span>(v3);</span><br><span class="line">    v.<span class="built_in">push_back</span>(v4);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;vector&lt;<span class="keyword">int</span> &gt;&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator vit = (*it).<span class="built_in">begin</span>(); vit != (*it).<span class="built_in">end</span>(); vit++) &#123;</span><br><span class="line">            cout &lt;&lt; *vit &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;STL的诞生&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#STL的诞生&quot;&gt;&lt;/a&gt;STL的诞生&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;长久以来，软件界一直希望建立一种可重复利用的东西&lt;/li&gt;
&lt;li&gt;C++的&lt;strong&gt;面向对象&lt;/strong&gt;</summary>
      
    
    
    
    <category term="STL" scheme="http://halo123.top/categories/STL/"/>
    
    
    <category term="STL" scheme="http://halo123.top/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>计算机系统概述</title>
    <link href="http://halo123.top/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
    <id>http://halo123.top/2021/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</id>
    <published>2021-04-18T03:59:48.870Z</published>
    <updated>2021-04-22T11:27:50.226Z</updated>
    
    <content type="html"><![CDATA[<h1>1 操作系统的概念</h1><p>操作系统（Operating System, OS）是指控制和管理整个计算机系统的硬件与软件资源，合理地组织、调度计算机的工作与资源的分配，进而为用户和其他软件提供方便接口与环境的程序集合。操作系统是计算机系统中最基本的<font color="#faa755">系统软件</font>。</p><h2 id="1-1-操作系统的目标和功能"><a class="header-anchor" href="#1-1-操作系统的目标和功能"></a>1.1 操作系统的目标和功能</h2><p>为了给多道程序提供良好的运行环境，操作系统应具有以下几方面的功能：<font color="#faa755">处理机管理</font>、<font color="#faa755">存储器管理</font>、<font color="#faa755">设备管理</font>和<font color="#faa755">文件管理</font>。为了方便用户使用操作系统，还必须向用户提供接口。同时，操作系统可用来扩充机器，以提供更方便的服务、更高的资源利用率。</p><h3 id="1-1-1-操作系统作为计算机系统资源的管理者"><a class="header-anchor" href="#1-1-1-操作系统作为计算机系统资源的管理者"></a>1.1.1 操作系统作为计算机系统资源的管理者</h3><ol><li><p>处理机管理</p><p>在多道程序环境下，处理机的分配和运行都以进程(或线程)为基本单位，因而对处理机的管理可归结为对进程的管理。并发是指在计算机内同时运行多个进程，因此进程何时创建、何时撤销、如何管理、如何避免冲突、合理共享就是进程管理的最主要的任务。进程管理的主要功能包括进程控制、进程同步、进程通信、死锁处理、处理机调度等。</p></li><li><p>存储器管理</p><p>存储器管理是为了给多道程序的运行提供良好的环境，方便用户使用及提高内存的利用率，主要包括内存分配与回收、地址映射、内存保护与共享和内存扩充等功能。</p></li><li><p>文件管理</p><p>计算机中的信息都是以文件的形式存在的，操作系统中负责文件管理的部分称为文件系统。文件管理包括文件存储空间的管理、目录管理及文件读写管理和保护等。</p></li><li><p>设备管理</p><p>设备管理的主要任务是完成用户的I/O请求，方便用户使用各种设备,并提高设备的利用率，主要包括缓冲管理、设备分配、设备处理和虚拟设备等功能。</p></li></ol><h3 id="1-1-2-操作系统作为用户与计算机硬件系统之间的接口"><a class="header-anchor" href="#1-1-2-操作系统作为用户与计算机硬件系统之间的接口"></a>1.1.2 操作系统作为用户与计算机硬件系统之间的接口</h3><p>为了让用户方便、快捷、可靠地操纵计算机硬件并运行自己的程序，操作系统还提供了用户接口。操作系统提供的接口主要分为两类:</p><ul><li>一类是命令接口，用户利用这些操作命令来组织和控制作业的执行;</li><li>另一类是程序接口，编程人员可以使用它们来请求操作系统服务。</li></ul><ol><li><p>命令接口</p><p>使用命令接口进行作业控制的主要方式有两种，即联机控制方式和脱机控制方式。按作业控制方式的不同，可将命令接口分为<font color="#ea66a6">联机命令接口</font>和<font color="#ea66a6">脱机命令接口</font>。</p><ul><li><p>联机命令接口又称交互式命令接口，适用于分时或实时系统的接口。它由一组键盘操作命令组成。用户通过控制台或终端输入操作命令，向系统提出各种服务要求。用户每输入一条命令，控制权就转给操作系统的命令解释程序，然后由命令解释程序解释并执行输入的命令，完成指定的功能。之后，控制权转回控制台或终端，此时用户又可输入下一条命令。联机命令接口可以这样理解:“雇主”说一句话,“工人”做一件事，并做出反馈，这就强调了<font color="#faa755">交互性</font>。</p></li><li><p>脱机命令接口又称批处理命令接口，适用于批处理系统，它由一组作业控制命令组成。脱机用户不能直接干预作业的运行，而应事先用相应的作业控制命令写成一份作业操作说明书，连同!作业一起提交给系统。系统调度到该作业时，由系统中的命令解释程序逐条解释执行作业说明书上的命令，从而间接地控制作业的运行。脱机命令接口可以这样理解:“雇主”把要“工人”做的事写在清单上,“工人”按照清单命令逐条完成这些事，这就是<font color="#faa755">批处理</font>。</p></li></ul></li><li><p>程序接口</p><p>程序接口由一组<font color="#ea66a6">系统调用</font>（也称<font color="#ea66a6">广义指令</font>）组成。用户通过在程序中使用这些系统调用来请求操作系统为其提供服务，如使用各种外部设备、申请分配和回收内存及其他各种要求。</p></li></ol><p>当前最为流行的是图形用户界面（GUI），即<font color="#ea66a6">图形接口</font>。GUI最终是通过调用程序接口实现的，用户通过鼠标和键盘在图形界面上单击或使用快捷键，就能很方便地使用操作系统。严格来说，图形接口不是操作系统的一部分，但图形接口所调用的系统调用命令是操作系统的一部分。</p><h3 id="1-1-3-操作系统用作扩充机器"><a class="header-anchor" href="#1-1-3-操作系统用作扩充机器"></a>1.1.3 操作系统用作扩充机器</h3><p>没有任何软件支持的计算机称为裸机，它仅构成计算机系统的物质基础，而实际呈现在用户面前的计算机系统是经过若干层软件改造的计算机。裸机在最里层，其外面是操作系统。操作系统所提供的资源管理功能和方便用户的各种服务功能，将裸机改造成功能更强、使用更方便的机器;因此，我们通常把覆盖了软件的机器称为扩充机器或虚拟机。</p><h2 id="1-2-操作系统的特征"><a class="header-anchor" href="#1-2-操作系统的特征"></a>1.2 操作系统的特征</h2><p>操作系统是一种系统软件，但与其他系统软件和应用软件有很大的不同，它有自己的特殊性即基本特征。操作系统的基本特征包括并发、共享、虚拟和异步。这些概念对理解和掌握操作系统的核心至关重要，将一直贯穿于各个章节中。</p><h3 id="1-2-1-并发-Concurrence"><a class="header-anchor" href="#1-2-1-并发-Concurrence"></a>1.2.1 并发(Concurrence)</h3><p><font color="#ad1a72">并发</font>是指两个或多个事件在同一时间间隔内发生。操作系统的并发性是指计算机系统中同时存在多个运行的程序，因此它具有处理和调度多个程序同时执行的能力。在操作系统中，引入进程的目的是使程序能并发执行。</p><p>注意同一时间间隔(并发)和同一时刻(并行)的区别。在多道程序环境下，一段时间内，<font color="#faa755">宏观</font>上有多道程序在同时执行，而在每个时刻，单处理机环境下实际仅能有一道程序执行，因此<font color="#faa755">微观</font>上这些程序仍是分时交替执行的。操作系统的并发性是<font color="#faa755">通过分时得以实现的</font>。</p><p>注意，<font color="#ad1a72">并行性</font>是指系统具有同时进行运算或操作的特性，在同一时刻能完成两种或两种以上的工作。并行性需要有相关硬件的支持，如多流水线或多处理机硬件环境。</p><p>我们以现实生活中的直观例子来认识并发和并行的区别。例如，如果你在9:00-9:10 仅吃面包，在9:10-9:20 仅写字，在9:20-9:30 仅吃面包，在9:30-10:00仅写字，那么在9:00-10:00吃面包和写字这两种行为就是并发执行的;再如，如果你在9:00-10:00 右手写字，左手同时拿着面包吃，那么这两个动作就是并行执行的。</p><h3 id="1-2-2-共享-Sharing"><a class="header-anchor" href="#1-2-2-共享-Sharing"></a>1.2.2 共享(Sharing)</h3><p>资源共享即共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。</p><p>共享可分为以下两种资源共享方式:</p><ol><li><p>互斥共享方式</p><p>系统中的某些资源，如打印机、磁带机，虽然可供多个进程使用，但为使得所打印或记录的结果不致造成混淆，应规定<font color="#faa755">在一段时间内只允许一个进程访问该资源</font>。为此，当进程A访问某个资源时，必须先提出请求，若此时该资源空闲，则系统便将之分配给进程A使用，此后有其他进程也要访问该资源时(只要A未用完)就必须等待。仅当进程A访问完并释放该资源后，才允许另一个进程对该资源进行访问。我们把这种资源共享方式称为互斥式共享，而把在一段时间内只允许一个进程访问的资源称为临界资源或独占资源。计算机系统中的大多数物理设备及某些软件中所用的栈、变量和表格，都属于临界资源，它们都要求被互斥地共享。</p></li><li><p>同时访问方式</p><p>系统中还有另一类资源，这类资源<font color="#faa755">允许在一段时间内由多个进程“同时”访问</font>。这里所说的“同时”通常是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问即“分时共享”的。可供多个进程“同时”访问的典型资源是磁盘设备，一些用重入码编写的文件也可被“同时”共享，即允许若干个用户同时访问该文件。</p></li></ol><p>注意，互斥共享要求一种资源在一段时间内(哪怕是一段很小的时间)只能满足一个请求，否则就会出现严重的问题，(你能想象打印机第一行打印A文档的内容、第二行打印B文档的内容的效果吗?)而同时访问共享通常要求一个请求分几个时间片段间隔地完成，其效果与连续完成的效果相同。</p><p><font color="#FF666">并发和共享是操作系统两个最基本的特征，两者之间互为存在的条件</font>:</p><ol><li>资源共享是以程序的并发为条件的，若系统不允许程序并发执行，则自然不存在资源共享问题;</li><li>若系统不能对资源共享实施有效的管理，则必将影响到程序的并发执行，甚至根本无法并发执行。</li></ol><h3 id="1-2-3-虚拟（Virtual）"><a class="header-anchor" href="#1-2-3-虚拟（Virtual）"></a>1.2.3 虚拟（Virtual）</h3><p>虚拟是指把一个物理上的实体变为若干逻辑上的对应物。物理实体(前者)是实的，即实际存在的;而后者是虚的，是用户感觉上的事物。用于实现虚拟的技术，称为虚拟技术。操作系统中利用了多种虚拟技术来实现虚拟处理器、虚拟内存和虚拟外部设备等。</p><p><font color="#FF666">时分复用技术</font>:虚拟处理器技术是通过多道程序设计技术，采用让多道程序并发执行的方法，来分时使用一个处理器的。此时，虽然只有一个处理器，但它能同时为多个用户服务，使每个终端用户都感觉有一个中央处理器(CPU) 在专门为它服务。利用多道程序设计技术把一个物理 上的CPU虚拟为多个逻辑上的CPU，称为虚拟处理器。</p><p><font color="#FF666">空分复用技术</font>:类似地，可以采用虚拟存储器技术将一台机器的物理存储器变为虚拟存储器，以便从逻辑上扩充存储器的容量。当然，这时用户所感觉到的内存容量是虚的。我们把用户感觉到(但实际不存在)的存储器称为虚拟存储器。</p><p>还可采用虚拟设备技术将一台物理I/O设备虚拟为多台逻辑上的I/O设备，并允许每个用户占用一台逻辑上的I/O设备，使原来仅允许在一段时间内由一个用户访问的设备(即临界资源)变为在一段时间内允许多个用户同时访问的共享设备。</p><p>因此，操作系统的虚拟技术可归纳为:时分复用技术，如处理器的分时共享;空分复用技术，如虚拟存储器。</p><h3 id="1-2-4-异步（Asynchronism）"><a class="header-anchor" href="#1-2-4-异步（Asynchronism）"></a>1.2.4 异步（Asynchronism）</h3><p>多道程序环境允许多个程序并发执行，但由于资源有限，进程的执行并不是一贯到底的，而是走走停停的，它以不可预知的速度向前推进，这就是进程的异步性。</p><p>异步性使得操作系统运行在一种随机的环境下，可能导致进程产生与时间有关的错误(就像对全局变量的访问顺序不当会导致程序出错一样)。然而，只要运行环境相同，操作系统就须保证多次运行进程后都能获得相同的结果。</p><h1>2 操作系统的发展与分类</h1><h2 id="2-1-手工操作系统阶段-此阶段无操作系统"><a class="header-anchor" href="#2-1-手工操作系统阶段-此阶段无操作系统"></a>2.1 手工操作系统阶段(此阶段无操作系统)</h2><p>用户在计算机上算题的所有工作都要人工干预，如程序的装入、运行、结果的输出等。随着计算机硬件的发展，人机矛盾(速度和资源利用)越来越大，必须寻求新的解决办法。</p><p>手工操作阶段有两个突出的缺点:</p><ol><li>用户独占全机，不会出现因资源已被其他用户占用而等待的现象，但资源利用率低。</li><li>CPU等待手工操作，CPU的利用不充分。</li></ol><p>唯一的解决办法就是用高速的机器代替相对较慢的手工操作来对作业进行控制。</p><h2 id="2-2-批处理阶段-操作系统开始出现"><a class="header-anchor" href="#2-2-批处理阶段-操作系统开始出现"></a>2.2 批处理阶段(操作系统开始出现)</h2><p>为了解决人机矛盾及CPU和I/O设备之间速度不匹配的矛盾，出现了批处理系统。它按发展历程又分为单道批处理系统、多道批处理系统(多道程序设计技术出现以后)。</p><h3 id="2-2-1-单道批处理系统"><a class="header-anchor" href="#2-2-1-单道批处理系统"></a>2.2.1 单道批处理系统</h3><p>系统对作业的处理是成批进行的，但内存中始终保持一道作业。 单道批处理系统是在解决人机矛盾及CPU和I/O设备速率不匹配的矛盾中形成的。单道批处理系统的主要特征如下:</p><ol><li><font color="#faa755">自动性</font>。在顺利的情况下，磁带上的一批作业能自动地逐个运行，而无须人工干预。</li><li><font color="#faa755">顺序性</font>。磁带上的各道作业顺序地进入内存，各道作业的完成顺序与它们进入内存的顺序在正常情况下应完全相同，亦即先调入内存的作业先完成。</li><li><font color="#faa755">单道性</font>。内存中仅有一道程序运行，即监督程序每次从磁带上只调入一道程序进入内存运行，当该程序完成或发生异常情况时，才换入其后继程序进入内存运行。</li></ol><p>此时面临的问题是:每次主机内存中仅存放一道作业， 每当它在运行期间(注意这里是“运行时”而不是“完成后”)发出输入/输出请求后，高速的CPU便处于等待低速的I/O完成状态。为了进一步提高资源的利用率和系统的吞吐量，引入了多道程序技术。</p><h3 id="2-2-2-多道批处理系统"><a class="header-anchor" href="#2-2-2-多道批处理系统"></a>2.2.2 多道批处理系统</h3><p>多道程序设计技术允许多个程序同时进入内存并允许它们在CPU中交替地运行，这些程序共享系统中的各种硬/软件资源。当一道程序因I/O请求而暂停运行时，CPU便立即转去运行另一道程序。它不采用某些机制来提高某一技术方面的瓶颈问题，而让系统的各个组成部分都尽量去“忙”，因此切换任务所花费的时间很少，可实现系统各部件之间的并行工作，使其整体在单位时间内的效率翻倍。</p><p>当然，多道批处理系统的设计和实现要比单道系统复杂很多，因为要充分利用各种资源，就要涉及各种资源的调度问题。</p><p>多道程序设计的特点是多道、宏观上并行、微观上串行。</p><ol><li><font color="#faa755">多道</font>。计算机内存中同时存放多道相互独立的程序。</li><li><font color="#faa755">宏观上并行</font>。同时进入系统的多道程序都处于运行过程中，即它们先后开始各自的运行，但都未运行完毕。</li><li><font color="#faa755">微观上串行</font>。内存中的多道程序轮流占有CPU，交替执行。</li></ol><p>多道程序设计技术的实现需要解决下列问题:</p><ol><li>如何分配处理器。</li><li>多道程序的内存分配问题。</li><li>I/O设备如何分配。</li><li>如何组织和存放大量的程序和数据，以方便用户使用并保证其安全性与一致性。</li></ol><p>在批处理系统中采用多道程序设计技术就形成了多道批处理操作系统。该系统把用户提交的作业成批地送入计算机内存，然后由作业调度程序自动地选择作业运行.</p><p>优点:</p><ul><li>资源利用率高，多道程序共享计算机资源，从而使各种资源得到充分利用;</li><li>系统吞吐量大，CPU和其他资源保持“忙碌”状态。</li></ul><p>缺点:</p><ul><li>用户响应的时间较长;</li><li>不提供人机交互能力，用户既不能了解自己的程序的运行情况，又不能控制计算机。</li></ul><h3 id="2-2-3-分时操作系统"><a class="header-anchor" href="#2-2-3-分时操作系统"></a>2.2.3 分时操作系统</h3><p>所谓<font color="#ea66a6">分时技术</font>，是指把处理器的运行时间分成很短的时间片，按时间片轮流把处理器分配给各联机作业使用。若某个作业在分配给它的时间片内不能完成其计算，则该作业暂时停止运行，把处理器让给其他作业使用，等待下一轮再继续运行。由于计算机速度很快，作业运行轮转得也很快，因此给每个用户的感觉就像是自己独占一台计算机。</p><p>分时操作系统是指多个用户通过终端同时共享一台主机，这些终端连接在主机上，用户可以同时与主机进行交互操作而互不干扰。因此，实现分时系统最关键的问题是如何使用户能与自己的作业进行交互，即当用户在自己的终端上键入命令时，系统应能及时接收并及时处理该命令，再将结果返回用户。分时系统也是支持多道程序设计的系统，但它不同于多道批处理系统。多道批处理是实现作业自动控制而无须人工干预的系统，而分时系统是实现人机交互的系统，这使得分时系统具有与批处理系统不同的特征。分时系统的主要特征如下:</p><ol><li><font color="#faa755">同时性</font>。同时性也称多路性，指允许多个终端用户同时使用一台计算机，即一台计算机与若干台终端相连接，终端上的这些用户可以同时或基本同时使用计算机。</li><li><font color="#faa755">交互性</font>。用户能够方便地与系统进行人机对话，即用户通过终端采用人机对话的方式直接控制程序运行，与同程序进行交互。</li><li><font color="#faa755">独立性</font>。系统中多个用户可以彼此独立地进行操作，互不干扰，单个用户感觉不到别人也在使用这台计算机，好像只有自己单独使用这台计算机一样。</li><li><font color="#faa755">及时性</font>。用户请求能在很短时间内获得响应。分时系统采用时间片轮转方式使一台计算机同时为多个终端服务，使用户能够对系统的及时响应感到满意。</li></ol><p>虽然分时操作系统较好地解决了人机交互问题，但在一些应用场合，需要系统能对外部的信息在规定的时间(比时间片的时间还短)内做出处理(比如飞机订票系统或导弹制导系统)。因此，实时系统应运而生。</p><h3 id="2-2-4-实时操作系统"><a class="header-anchor" href="#2-2-4-实时操作系统"></a>2.2.4 实时操作系统</h3><p>为了能在某个时间限制内完成某些紧急任务而不需要时间片排队，诞生了实时操作系统。这里的时间限制可以分为两种情况:</p><ol><li>若某个动作必须绝对地在规定的时刻(或规定的时间范围)发生，则称为<font color="#ea66a6">硬实时系统</font>，如飞行器的飞行自动控制系统，这类系统必须提供绝对保证，让某个特定的动作在规定的时间内完成。</li><li>若能够接受偶尔违反时间规定且不会引起任何永久性的损害，则称为<font color="#ea66a6">软实时系统</font>，如飞机订票系统、银行管理系统。</li></ol><p>在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并在严格的时限内处理完接收的事件。实时操作系统的主要特点是及时性和可靠性。</p><h3 id="2-2-5-网络操作系统和分布式计算机系统"><a class="header-anchor" href="#2-2-5-网络操作系统和分布式计算机系统"></a>2.2.5 网络操作系统和分布式计算机系统</h3><p>网络操作系统把计算机网络中的各台计算机有机地结合起来，提供一种统一、 经济而有效的使用各台计算机的方法，实现各台计算机之间数据的互相传送。网络操作系统最主要的特点是网络中各种资源的共享及各台计算机之间的通信。</p><p>分布式计算机系统是由多台计算机组成并满足下列条件的系统:</p><ul><li>系统中任意两台计算机通过通信方式交换信息;</li><li>系统中的每台计算机都具有同等的地位，即没有主机也没有从机;</li><li>每台计算机上的资源为所有用户共享;</li><li>系统中的任意台计算机都可以构成一个子系统，并且还能重构;</li><li>任何工作都可以分布在几台计算机上，由它们并行工作、协同完成。</li></ul><p>用于管理分布式计算机系统的操作系统称为分布式计算机系统。该系统的主要特点是:<font color="#faa755">分布性和并行性</font>。分布式操作系统与网络操作系统的本质不同是,分布式操作系统中的若干计算机相互协同完成同一任务。</p><h3 id="2-2-6-个人计算机操作系统"><a class="header-anchor" href="#2-2-6-个人计算机操作系统"></a>2.2.6 个人计算机操作系统</h3><p>个人计算机操作系统是目前使用最广泛的操作系统，它广泛应用于文字处理、电子表格、游戏中，常见的有Windows、Linux和Macintosh等。</p><hr><p>此外,还有嵌入式操作系统、服务器操作系统、智能手机操作系统等。</p><h1>3 操作系统的运行环境</h1><h2 id="3-1-操作系统的运行机制"><a class="header-anchor" href="#3-1-操作系统的运行机制"></a>3.1 操作系统的运行机制</h2><p>两种指令:特权指令和非特权指令;</p><p>两种处理器状态:用户态(目态)和核心态(管态);</p><p>两种程序:内核程序和应用程序.</p><hr><p>计算机系统中，通常CPU执行两种不同性质的程序:</p><ol><li>一种是操作系统内核程序;</li><li>另一种是用户自编程序(即系统外层的应用程序，或简称“应用程序”)。</li></ol><p>对操作系统而言，这两种程序的作用不同，前者是后者的管理者，因此“管理程序”(即内核程序)要执行一些特权指令，而“被<br>管理程序”(即用户自编程序)出于安全考虑不能执行这些指令。</p><p>所谓<font color="#ea66a6">特权指令</font>，是指计算机中<font color="#faa755">不允许用户直接使用的指令</font>，如I/O指令、置中断指令，存取用于内存保护的寄存器、送程序状态字到程序状态字寄存器等的指令。</p><p>在具体实现上，将CPU的状态划分为<font color="#ea66a6">用户态(目态)</font>和<font color="#ea66a6">核心态(又称管态、内核态)</font>。可以理解为CPU内部有一个小开关，</p><ul><li>当小开关为1时，CPU处于核心态，此时CPU可以执行特权指令；</li><li>当小开关为0时，CPU处于用户态，此时CPU只能执行非特权指令。</li></ul><p><font color="#ea66a6">用户自编程序</font>运行在用户态，<font color="#ea66a6">操作系统内核程序</font>运行在核心态。</p><p>在软件工程思想和结构程序设计方法影响下诞生的现代操作系统,几乎都是层次式的结构。操作系统的各项功能分别被设置在不同的层次上。</p><p>一些与硬件关联较紧密的模块，如时钟管理、中断处理、设备驱动等处于最低层。其次是运行频率较高的程序，如进程管理、存储器管理和设备管理等。这两部分内容构成了<font color="#ea66a6">操作系统的内核</font>。这部分内容的指令操作工作在核心态。</p><p>内核是计算机上配置的底层<font color="#faa755">软件</font>，是计算机功能的延伸,是操作系统最基本、最核心的部分。不同系统对内核的定义稍有区别，大多数操作系统内核包括4方面的内容。</p><ol><li><p>时钟管理</p><p>在计算机的各种部件中，时钟是最关键的设备。时钟的第一功能是<font color="#faa755">计时</font>，操作系统需要通过时钟管理，向用户提供标准的系统时间。另外，通过<font color="#faa755">时钟中断的管理</font>，可以实现进程的切换。例如，在分时操作系统中采用时间片轮转调度，在实时系统中按截止时间控制运行，在批处理系统中通过时钟管理来衡量一个作业的运行程度等。因此，系统管理的方方面面无不依赖于时钟。</p></li><li><p>中断机制</p><p>引入中断技术的初衷是提高多道程序运行环境中CPU的利用率，而且主要是针对外部设备的。后来逐步得到发展，形成了多种类型，成为操作系统各项操作的基础。例如，键盘或鼠标信息的输入、进程的管理和调度、系统功能的调用、设备驱动、文件访问等，无不依赖于中断机制。可以说，现代操作系统是靠中断驱动的软件。</p><p>中断机制中，只有一小部分功能属于内核，它们负责保护和恢复中断现场的信息，转移控制权到相关的处理程序。这样可以减少中断的处理时间，提高系统的并行处理能力。</p></li><li><p>原语</p></li></ol><p>按层次结构设计的操作系统，底层必然是一些可被调用的公用小程序，它们各自完成一个规定的操作。它们的特点如下:</p><ul><li><p>处于操作系统的最低层，是最接近硬件的部分。</p></li><li><p>这些程序的运行具有<font color="#faa755">原子性</font>，其操作只能一气呵成(主要从系统安全性和便于管理考虑)。</p></li><li><p>这些程序的运行时间都较短，而且调用频繁。</p><p>通常把具有这些特点的程序称为原语(Atomic Operation)。定义原语的直接方法是关闭中断，让其所有动作不可分割地完成后再打开中断。<br>系统中的设备驱动、CPU切换、进程通信等功能中的部分操作都可定义为原语，使它们成为内核的组成部分。</p></li></ul><ol start="4"><li><p>系统控制的数据结构及处理.</p><p>系统中用来登记状态信息的数据结构很多，如作业控制块、进程控制块(PCB)、设备控制块、各类链表、消息队列、缓冲区、空闲区登记表、内存分配表等。为了实现有效的管理，系统需要一些基本的操作，常见的操作有以下3种:</p><ul><li>进程管理。进程状态管理、进程调度和分派、创建与撤销进程控制块等。</li><li>存储器管理。存储器的空间分配和回收、内存信息保护程序、代码对换程序等。</li><li>设备管理。缓冲区管理、设备分配和回收等。</li></ul></li></ol><p>从上述内容可以了解，核心态指令实际上包括系统调用类指令和一些针对时钟、中断和原语的操作指令。</p><h2 id="3-2-大内核和微内核"><a class="header-anchor" href="#3-2-大内核和微内核"></a>3.2 大内核和微内核</h2><p>操作系统的体系结构是一个开放的问题 。 如上文所述，操作系统在核心态为应用程序提供公共的服务，那么操作系统在核心态应该提供什么服务、怎样提供服务？有关这一 问题的回答形成了两种主要的体系结构：大内核和微内核 。</p><p>大内核系统将操作系统的主要功能模块都作为一个紧密联系的整体运行在核心态，从而为应用提供高性能的系统服务 。 因为各管理模块之间共享信息，能有效利用相互之间的有效特性，所以具有无可比拟的性能优势 。</p><p>但随着体系结构和应用 需求的不断发展，需要操作系统提供的服务越来越多，而且接口形式越来越复杂，操作系统的设计规模急剧增长，操作系统也面临着 “软件危机”困境 。 为此，操作系统设计人员试图按照复杂性、时间常数、抽象级别等因素，将操作系统内核分成基本进程管理 、虚存、I/O 与设备管理、IPC 、文件系统等几个层次，继而定义层次之间的服务结构，提高操作系统内核设计上的模块化。 但是，由于层次之间的交互关系错综复杂 ，定义清晰的层次间接口非常困难，复杂的交互关系也使得层次之间的界限极其模糊。</p><p>为解决操作系统的内核代码难以维护的问题，提出了微内核的体系结构 。 它将内核中最基本的功能（如进程管理等 ）保留在内核，而将那些不需要在核心态执行的功能移到用户态执行，从而降低了内核的设计复杂性 。 那些移出内核的操作系统代码根据分层的原则被划分成若干服务程序，它们的执行相互独立，交互则都借助于微内核进行通信。</p><p>微内核结构有效地分离了内核与服务、服务与服务，使得它们之间的接口更加清晰，维护的代价大大降低，各部分可以独立地优化和演进 ，从而保证了操作系统的可靠性。</p><p>微内核结构的最大问题是性能问题，因为需要频繁地在核心态和用户态之间进行切换，操作系统的执行开销偏大 。 因此有的操作系统将那些频繁使用的系统服务又移回内核，从而保证系统性能。但相当多的实验数据表明，体系结构不是引起性能下降的主要因素，体系结构带来的性能提升足以弥补切换开销带来的缺陷 。 为减少切换开销，也有人提出将系统服务作为运行库链接到用户程序的一种解决方案，这样的体系结构称为库操作系统。</p><h2 id="3-3-font-color-33a3dc-中断和异常的概念-font"><a class="header-anchor" href="#3-3-font-color-33a3dc-中断和异常的概念-font"></a>3.3 <font color="#33a3dc">中断和异常的概念</font></h2><ol><li>当中断发生时，CPU立即进入核心态（并且是进入核心态的<font color="#FF666">唯一方式</font>）</li><li>当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理</li><li>对于不同的中断信号，会进行不同的处理</li></ol><p>在操作系统中引入核心态和用户态这两种工作状态后，就需要考虑这两种状态之间如何切换 。操作系统内核工作在核心态，而用户程序工作在用户态 。系统不允许用户程序实现核心态的功能，而它们又必须使用这些功能 。因此，需要在核心态建立一些“门”以便实现从用户态进入核心态 。</p><p>在实际操作系统中，CPU 运行上层程序时唯一能进入这些“门”的途径就是通过中断或异常。发生中断或异常时，运行用户态的 CPU 会主即进入核心态，这是通过硬件实现的（例如，用一个特殊寄存器的一位来表示CPU所处的工作状态，0表示核心态，1表示用户态。若要进入核心态，则只需将该位置0即可)。</p><p>中断是操作系统中非常重要的一个概念，对一个运行在计算机上的实用操作系统而言，缺少了中断机制，将是不可想象的。原因是，操作系统的发展过程大体上就是一个想方设法不断提高资源利用率的过程，而提高资源利用率就需要在程序并未使用某种资源时，把它对那种资源的占有权释放，而这一行为就需要通过中断实现。</p><h3 id="3-3-1-font-color-33a3dc-中断和异常的定义-font"><a class="header-anchor" href="#3-3-1-font-color-33a3dc-中断和异常的定义-font"></a>3.3.1 <font color="#33a3dc">中断和异常的定义</font></h3><p>中断(Interruption)也称<font color="#faa755">外中断</font>，指来自CPU执行<font color="#faa755">指令以外</font>的事件的发生，如设备发出的I/O结束中断，表示设备输入/输出处理已经完成，希望处理机能够向设备发下一个输入/输出请求,同时让完成输入/输出后的程序继续运行。时钟中断，表示一个固定的时间片已到，让处理机处理计时、启动定时运行的任务等。这一类中断通常是与当前指令执行无关的事件，即它们与当前处理机运行的程序无关。</p><p>异常(Exception)也称<font color="#faa755">内中断</font>、例外或陷入(trap),指源自CPU执行<font color="#faa755">指令内部</font>的事件，如程序的非法操作码、地址越界、算术溢出、虚存系统的缺页及专门的陷入指令等引起的事件。对异常的处理一般要依赖于当前程序的运行现场，而且异常不能被屏蔽，一旦出现应立即处理。关于内中断和外中断的联系与区别如图1.2 所示。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E4%B8%AD%E6%96%AD%E5%92%8C%E5%A4%96%E4%B8%AD%E6%96%AD%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB.png" alt="内中断和外中断的联系与区别" style="object-fit: cover; border-radius: 10px; width: 80%;" /><h3 id="3-3-2-中断处理的过程"><a class="header-anchor" href="#3-3-2-中断处理的过程"></a>3.3.2 中断处理的过程</h3><p>不同计算机的中断（指外中断〉处理过程各具特色，所示。各阶段处理流程的描述如下：</p><ol><li>关中断 。CPU 响应中断后，首先要保护程序的现场状态，在保护现场的过程中，CPU 不应响应更高级中断源的中断请求。否则，若现场保存不完整，在中断服务程序结束后，也就不能正确地恢复并继续执行现行程序 。</li><li>保存断点。为保证中断服务程序执行完毕后能正确地运回到原来的程序，必须将原来的程序的断点（即程序计数器 PC）保存起来。</li><li>引出中断服务程序 。其实质是取出中断服务程序的入口地址送入程序计数器 PC 。</li><li>存现场和屏蔽字。 进入中断服务程序后 ，首先要保存现场，现场信息一般是指程序状态字寄存器 PSWR 和某些通用寄存器的内容。</li><li>开中断。 允许更高级中断请求得到响应。</li><li>执行中断服务程序。这是中断请求的目的。</li><li>关中断。保证在恢复现场和屏蔽字时不被中断。</li><li>恢复现场和屏蔽字。将现场和屏蔽字恢复到原来的状态。</li><li>开中断、中断返回。中断服务程序的最后一条指令通常是一条中断返回指令，使其返回到原程序的断点处，以便继续执行原程序 。</li></ol><p>其中，1~3步是在 CPU 进入中断周期后，由硬件自动（中断隐指令）完成的；4~9 步由中断服务程序完成。恢复现场是指在中断返回前，必须将寄存器的内容恢复到中断处理前的状态，这部分工作由中断服务程序完成 。中断返回由中断服务程序的最后一条中断返回指令完成。</p><h2 id="4-系统调用"><a class="header-anchor" href="#4-系统调用"></a>4 系统调用</h2><p>所谓<font color="#ea66a6">系统调用</font>， 是指用户在程序中调用操作系统所提供的一些子功能，系统调用可视为特殊的公共子程序。系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作（如存储分配、进行 I/0 传输及管理文件等），都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成 。 通常，一个操作系统提供的系统调用命令有几十条乃至上百条之多。这些系统调用按功能大致可分为如下几类。</p><ul><li>设备管理。完成设备的请求或释放，以及设备启动等功能。</li><li>文件管理。完成文件的读、写、创建及删除等功能。</li><li>进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。</li><li>进程通信。完成进程之间的消息传递或信号传递等功能。</li><li>内存管理。完成内存的分配、回收以及获取作业占用内存区大小及始址等功能。</li></ul><p>显然，系统调用相关功能涉及系统资源管理、进程管理之类的操作，对整个系统的影响非常大，因此必定需要使用某些特权指令才能完成，所以系统调用的处理需要由操作系统内核程序负责完成，要运行在核心态。</p><p>用户程序可以执行陷入指令(又称访管指令或trap指令)来发起系统调用，请求操作系统提供服务。可以这么理解，用户程序执行“陷入指令”，相当于把CPU的使用权主动交给操作系统内核程序(CPU状态会从用户态进入核心态)，之后操作系统内核程序再对系统调用请求做出相应处理。处理完成后，操作系统内核程序又会把CPU的使用权还给用户程序(即CPU状态会从核心态回到用户态)。这么设计的目的是:用户程序不能直接执行对系统影响非常大的操作，必须通过系统调用的方式请求操作系统代为执行，以便保证系统的稳定性和安全性，防止用户程序随意更改或访问重要的系统资源，影响其他进程的运行。</p><p>这样，操作系统的运行环境就可以理解为:用户通过操作系统运行上层程序(如系统提供的命令解释程序或用户自编程序)，而这个上层程序的运行依赖于操作系统的底层管理程序提供服务支持，当需要管理程序服务时，系统则通过硬件中断机制进入核心态，运行管理程序;也可能是程序运行出现异常情况，被动地需要管理程序的服务，这时就通过异常处理来进入核心态。管理程序运行结束时，用户程序需要继续运行，此时通过相应的保存的程序现场退出中断处理程序或异常处理程序，返回断点处继续执行，如图1.4 所示。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.png" alt="系统调用执行过程" style="object-fit: cover; border-radius: 10px; width: 100%;;" /><p>在操作系统这一层面上，我们关心的是系统核心态和用户态的软件实现与切换，对于硬件层面的具体理解，可以结合 “计算机组成原理”课程中有关中断的内容进行学习 。</p><p>下面列举一些由用户态转向核心态的例子：</p><ol><li>用户程序要求操作系统的服务，即系统调用。</li><li>发生一次中断。</li><li>用户程序中产生了一个错误状态。</li><li>用户程序中企图执行一条特权指令。</li><li>从核心态转向用户态由一条指令实现， 这条指令也是特权命令，一般是中断返回指令。</li></ol><p>注意：由用户态进入核心态，不仅状态需要切换，而且所用的堆栈也可能需要由用户堆栈切换为系统堆栈，但这个系统堆栈也是属于该进程的。</p><p>若程序的运行由用户态转到核心态，则会用到<font color="#faa755">访管指令(陷入指令)</font>，访管指令是在用户态使用的，发出系统调用请求，所以它不可能是特权指令。</p><p>陷入指令是唯一一个只能在用户态执行，而不可在核心态执行的指令。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;1 操作系统的概念&lt;/h1&gt;
&lt;p&gt;操作系统（Operating System, OS）是指控制和管理整个计算机系统的硬件与软件资源，合理地组织、调度计算机的工作与资源的分配，进而为用户和其他软件提供方便接口与环境的程序集合。操作系统是计算机系统中最基本的&lt;font co</summary>
      
    
    
    
    <category term="操作系统" scheme="http://halo123.top/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://halo123.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>博客增加锚点功能</title>
    <link href="http://halo123.top/2020/12/28/Hexo%E5%8D%9A%E5%AE%A2%E5%A2%9E%E5%8A%A0%E9%94%9A%E7%82%B9%E5%8A%9F%E8%83%BD/"/>
    <id>http://halo123.top/2020/12/28/Hexo%E5%8D%9A%E5%AE%A2%E5%A2%9E%E5%8A%A0%E9%94%9A%E7%82%B9%E5%8A%9F%E8%83%BD/</id>
    <published>2020-12-28T05:51:58.000Z</published>
    <updated>2021-04-23T18:20:33.289Z</updated>
    
    <content type="html"><![CDATA[<p>Here is a footnote reference,<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> and another.<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p><p>Hexo自带的Markdown渲染器没有脚注等语法的支持，提供以下方法增加该功能的支持<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup></p><h2 id="锚点功能的解决途径"><a class="header-anchor" href="#锚点功能的解决途径"></a>锚点功能的解决途径</h2><p>一种是手动添加<code>a</code>标签，但这种方法比较麻烦。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#bib1&quot;</span> <span class="attr">id</span>=<span class="string">&quot;bib1ref&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">sup</span>&gt;</span>[1]<span class="tag">&lt;/<span class="name">sup</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">&quot;bib1&quot;</span> <span class="attr">href</span>=<span class="string">&quot;#bib1ref&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">sup</span>&gt;</span>[1]<span class="tag">&lt;/<span class="name">sup</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>还有一种是采用插件，这里选择了<a href="https://github.com/hexojs/hexo-renderer-markdown-it">hexo-renderer-markdown-it</a>插件</p><p>插件的安装</p><p>首先在Hexo博客目录下，选择删除原来的渲染器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm un hexo-renderer-marked --save</span><br></pre></td></tr></table></figure><p>在安装该插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-renderer-markdown-it --save</span><br></pre></td></tr></table></figure><p>之后在 Hexo 的 _config.yml 文件中进行相关的配置。</p><p>2021年4月24日更换了博客主题对配置进行了修改（来源：<a href="https://zhanghuimeng.github.io/post/add-footnote-plugin-for-hexo-blog/#fnref3">链接</a>）</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Markdown-it config</span></span><br><span class="line"><span class="comment">## Docs: https://github.com/celsomiranda/hexo-renderer-markdown-it/wiki</span></span><br><span class="line"><span class="attr">markdown:</span></span><br><span class="line">  <span class="comment"># 渲染设置</span></span><br><span class="line">  <span class="attr">render:</span></span><br><span class="line">    <span class="comment"># 置为true时，html内容保持不变；置为false时，html内容将被转义成普通字符串</span></span><br><span class="line">    <span class="attr">html:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 是否生成与XHTML完全兼容的标签（虽然我不懂是什么意思）</span></span><br><span class="line">    <span class="attr">xhtmlOut:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 置为true时，每个换行符都被渲染成一个&lt;br&gt;（即Hexo的默认表现）；置为false时，只有空行才会被渲染为&lt;br&gt;（GFM的默认表现）</span></span><br><span class="line">    <span class="attr">breaks:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 是否自动识别链接并把它渲染成链接</span></span><br><span class="line">    <span class="attr">linkify:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 是否自动识别印刷格式（意思是把(c)渲染为©这样的）</span></span><br><span class="line">    <span class="attr">typographer:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 如果typographer被设置为true，则该选项用于设置将dumb quotes（&quot;&quot;）自动替换为smart quotes</span></span><br><span class="line">    <span class="attr">quotes:</span> <span class="string">&#x27;“”‘’&#x27;</span></span><br><span class="line">  <span class="comment"># 设置所需插件</span></span><br><span class="line">  <span class="attr">plugins:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-abbr</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-footnote</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-ins</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-sub</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-sup</span></span><br><span class="line">  <span class="comment"># 锚点设置（因为我没有尝试相关内容，所以就不翻译相关说明了）</span></span><br><span class="line">  <span class="attr">anchors:</span></span><br><span class="line">    <span class="attr">level:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">collisionSuffix:</span> <span class="string">&#x27;v&#x27;</span></span><br><span class="line">    <span class="attr">permalink:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">permalinkClass:</span> <span class="string">header-anchor</span></span><br><span class="line">    <span class="attr">permalinkSymbol:</span> <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">markdown:</span></span><br><span class="line">  <span class="attr">preset:</span> <span class="string">&#x27;default&#x27;</span></span><br><span class="line">  <span class="attr">render:</span></span><br><span class="line">    <span class="attr">html:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">xhtmlOut:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">langPrefix:</span> <span class="string">&#x27;language-&#x27;</span></span><br><span class="line">    <span class="attr">breaks:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">linkify:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">typographer:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">quotes:</span> <span class="string">&#x27;“”‘’&#x27;</span></span><br><span class="line">  <span class="attr">enable_rules:</span></span><br><span class="line">  <span class="attr">disable_rules:</span></span><br><span class="line">  <span class="attr">plugins:</span></span><br><span class="line">  <span class="attr">anchors:</span></span><br><span class="line">    <span class="attr">level:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">collisionSuffix:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="attr">permalink:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">permalinkClass:</span> <span class="string">&#x27;header-anchor&#x27;</span></span><br><span class="line">    <span class="attr">permalinkSide:</span> <span class="string">&#x27;left&#x27;</span></span><br><span class="line">    <span class="attr">permalinkSymbol:</span> <span class="string">&#x27;¶&#x27;</span></span><br><span class="line">    <span class="attr">case:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">separator:</span> <span class="string">&#x27;-&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p>在安装插件的过程中遇到没有生效的问题，首先使用<code>hexo clean</code>命令清理，在重新尝试<br>如果仍不生效可以查看 packge.json 和 node_modules 有没有导入包，Markdown脚注的格式是否正确，</p></blockquote><h2 id="对于锚点的适配问题"><a class="header-anchor" href="#对于锚点的适配问题"></a>对于锚点的适配问题</h2><p>在我使用的<a href="https://github.com/blinkfox/hexo-theme-matery/">matery</a>主题中，文章内<code>a</code>标签中默认加入了<code>target:_brank</code>属性，这使得点击链接会跳转到新的窗口中现实，不符合锚点需要的页面内的跳转功能</p><p>解决办法，在主题的 source\js\matery.js 文件中找到如下代码，并注释<code>$('#articleContent a').attr('target', '_blank');</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*文章内容详情的一些初始化特性*/</span></span><br><span class="line"><span class="keyword">let</span> articleInit = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//$(&#x27;#articleContent a&#x27;).attr(&#x27;target&#x27;, &#x27;_blank&#x27;);</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>完成以上内容，即可使用锚点，但锚点总会跳转到页面最顶端，由于主题banner是浮动效果，会导致遮住跳转的链接。</p><p>下面提供一种Js代码的解决方式，<a href="https://www.cnblogs.com/attlia/p/7488271.html">参考文章</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*文章内容详情的一些初始化特性*/</span></span><br><span class="line"><span class="keyword">let</span> articleInit = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// $(&#x27;#articleContent a&#x27;).attr(&#x27;target&#x27;, &#x27;_blank&#x27;);</span></span><br><span class="line">    $(<span class="string">&#x27;#articleContent a&#x27;</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> target = $(<span class="built_in">this</span>).attr(<span class="string">&#x27;href&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(target);</span><br><span class="line">        $(<span class="string">&#x27;html, body&#x27;</span>).animate(&#123;</span><br><span class="line">           scrollTop: $(target).offset().top - <span class="number">65</span> <span class="comment">//65位设置的偏移值</span></span><br><span class="line">         &#125;, <span class="number">500</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自此完成了对脚注的支持，但因为这个renderer-markdown-it渲染器的原因，可以会存在一些问题，之后遇到了在说。</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>Here is the footnote. <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>Here’s one with multiple blocks. <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p>这是脚注内容 <a href="#fnref3" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Here is a footnote reference,&lt;sup class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;#fn1&quot; id=&quot;fnref1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; and another.&lt;sup class=&quot;footnote-ref&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="Hexo" scheme="http://halo123.top/categories/Hexo/"/>
    
    
    <category term="Hexo" scheme="http://halo123.top/tags/Hexo/"/>
    
    <category term="Html" scheme="http://halo123.top/tags/Html/"/>
    
  </entry>
  
  <entry>
    <title>植物组织培养复习整理</title>
    <link href="http://halo123.top/2020/12/25/%E7%94%9F%E7%89%A9%E5%AD%A6/%E6%A4%8D%E7%89%A9%E7%BB%84%E7%BB%87%E5%9F%B9%E5%85%BB%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86_v202101062123/"/>
    <id>http://halo123.top/2020/12/25/%E7%94%9F%E7%89%A9%E5%AD%A6/%E6%A4%8D%E7%89%A9%E7%BB%84%E7%BB%87%E5%9F%B9%E5%85%BB%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86_v202101062123/</id>
    <published>2020-12-25T08:41:51.000Z</published>
    <updated>2021-04-24T14:29:38.945Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>如文档内容有误，点击<a href="http://doc.halo123.top:3000/ygHmkfBjRZq1ZoAtW8Wk5g?both">该链接</a>对文档进行修改，定时会同步到网站上，感谢参与整理的同学们</p></blockquote><h2 id="第1章-组培绪论思考题（无）"><a class="header-anchor" href="#第1章-组培绪论思考题（无）"></a>第1章 组培绪论思考题（无）</h2><h2 id="第2章-组培基本技术思考题"><a class="header-anchor" href="#第2章-组培基本技术思考题"></a>第2章 组培基本技术思考题</h2><h3 id="培养基中的主要成分有哪几类？（PPT23）"><a class="header-anchor" href="#培养基中的主要成分有哪几类？（PPT23）"></a>培养基中的主要成分有哪几类？（PPT23）</h3><p>培养基的成分：水、无机成分、有机成分、天然有机添加物质、植物生长调节物质、培养基的pH值、凝固剂（琼脂）、活性炭、抗生素。</p><h3 id="培养基中常添加的植物生长调节物质有哪两大类？各包括哪些常用种类？培养基中使用浓度范围？-PPT28、29"><a class="header-anchor" href="#培养基中常添加的植物生长调节物质有哪两大类？各包括哪些常用种类？培养基中使用浓度范围？-PPT28、29"></a>培养基中常添加的植物生长调节物质有哪两大类？各包括哪些常用种类？培养基中使用浓度范围？(PPT28、29)</h3><p>培养基中常添加的植物生长调节物质有生长素类和细胞分裂素类这两大类</p><ul><li>生长素类常用种类有吲哆乙酸（IAA），2,4-二氯苯氧乙酸（2,4-D），吲哆丁酸（IBA），萘乙酸（NAA）。培养基中常用浓度：0.1~10mg/L</li><li>细胞分裂素类常用种类有6-BA，激动素（KT），异戊烯基腺嘌呤（2-ip） ，噻重氮苯基脲（TDZ），玉米素（Zt）， 6-苄基腺嘌呤（BAP）。培养基中常用浓度： 0.1~10mg/L</li></ul><h3 id="培养基中经常加入的生长素类和细胞分裂素类物质各有何作用？这两类激素的使用规律如何？"><a class="header-anchor" href="#培养基中经常加入的生长素类和细胞分裂素类物质各有何作用？这两类激素的使用规律如何？"></a>培养基中经常加入的生长素类和细胞分裂素类物质各有何作用？这两类激素的使用规律如何？</h3><ul><li>生长素类主要被用于诱导愈伤组织形成；诱导根的分化和促进细胞分裂，伸长生长。</li><li>细胞分裂素类促进细胞分裂和分化，诱导胚状体和不定芽的形成，延缓组织的衰老和蛋白质的合成</li></ul><p>根和芽的分化由细胞分裂素和生长素的比值所决定：二者比值低时促进生根；比值高时促进茎芽的分化；比值适中则组织倾向于以一种无结构的方式生长。</p><h3 id="母液配制流程？（PPT40）"><a class="header-anchor" href="#母液配制流程？（PPT40）"></a>母液配制流程？（PPT40）</h3><p>计算 → 称量 → 加成分溶解 → 混合定容 → 测pH → 贴标签 → 冰箱贮存</p><h3 id="选择外植体需要注意哪些方面（PPT50）"><a class="header-anchor" href="#选择外植体需要注意哪些方面（PPT50）"></a>选择外植体需要注意哪些方面（PPT50）</h3><ol><li><strong>选择优良的基因型</strong>。基因型是控制愈伤组织形态建成的关键。不同物种的外植体诱导的愈伤组织器官分化明显不同，如烟草、胡萝卜、苜蓿等较易发生器官分化，而禾本科（禾谷类）、豆类、棉花等的愈伤组织形态建成相对较难。 同属不同种，甚至同一物种不同品种的愈伤组织器官分化的能力也不同。根据目的，选择优良的基因型，提高成功率。</li><li><strong>外植体的增殖能力</strong>。不同组织细胞的脱分化能力不同。</li><li><strong>外植体大小</strong>。胚胎培养或脱毒，外植体宜小； 若快速繁殖，外植体宜大；但过大杀菌不彻底，过小难以长活。一般在5~10mm为宜。</li><li><strong>选择外植体的季节和时间</strong>。在生长季节取材，较幼嫩的外植体培养容易；秋冬季取材需要处理，夏季，雨季取材不容易灭菌成功。</li><li><strong>外植体的生理状态和发育年龄</strong>。越幼嫩，年限越短的组织具有较高的形态发生能力；同株植物，较低部位外植体比上部的外植体容易启动，培养成功可能性大。</li></ol><h3 id="外植体污染原因？（PPT68）"><a class="header-anchor" href="#外植体污染原因？（PPT68）"></a>外植体污染原因？（PPT68）</h3><ol><li>外植体材料消毒不彻底</li><li>培养基灭菌不彻底</li><li>操作环境不洁净</li><li>操作人员操作不规范、不熟练。</li></ol><h3 id="污染的病原类型？（PPT68）"><a class="header-anchor" href="#污染的病原类型？（PPT68）"></a>污染的病原类型？（PPT68）</h3><p>污染原因从病源方面主要有细菌和真菌两大类。造成污染的病原菌主要包括外部污染菌和内源菌。</p><ul><li>外部污染菌：主要由外植体带菌或培养基灭菌不彻底以及操作人员操作不慎造成。</li><li>内源菌：外植体带菌引起的污染与外植体的种类、取材季节、部位、预处理及消毒方法等密切相关。</li></ul><h3 id="防污染对策？（PPT69）"><a class="header-anchor" href="#防污染对策？（PPT69）"></a>防污染对策？（PPT69）</h3><ol><li>减少或防止材料带菌，取材时应选择嫩梢，新芽或胚作为外植体材料</li><li>外植体灭菌要彻底</li><li>培养基灭菌要彻底</li><li>玻璃器皿和金属器皿的灭菌要彻底</li><li>无菌室的消毒</li><li>操作人员一定要严格按照无菌操作的程序进行接种。</li></ol><h3 id="常用消毒剂及外植体的消毒步骤？（PPT60、62）"><a class="header-anchor" href="#常用消毒剂及外植体的消毒步骤？（PPT60、62）"></a>常用消毒剂及外植体的消毒步骤？（PPT60、62）</h3><table><thead><tr><th>常用消毒剂</th><th>使用浓度(%)</th><th>消毒时间(min)</th><th>效 果</th><th>残液去除难易</th></tr></thead><tbody><tr><td><strong>乙醇</strong></td><td>70~75</td><td>0.1~3</td><td>好</td><td>易</td></tr><tr><td><strong>氯化汞</strong></td><td>0.1~1</td><td>2~15</td><td>最好</td><td>最难</td></tr><tr><td><strong>次氯酸钙</strong></td><td>10~20</td><td>5~30</td><td>好</td><td>易</td></tr><tr><td><strong>次氯酸钠</strong></td><td>2</td><td>5~30</td><td>好</td><td>易</td></tr></tbody></table><p>外植体表面消毒的一般过程：</p><p>外植体取材 → 预处理 → 无菌条件下，70%~75%酒精表面消毒30s~60s → 无菌条件下，消毒剂处理 → 无菌水充分漂洗3~5次 → 备用</p><h3 id="继代培养定义？（PPT84）"><a class="header-anchor" href="#继代培养定义？（PPT84）"></a>继代培养定义？（PPT84）</h3><p>培养物在培养基上生长一段时间以后，由于营养物质枯竭，水分散失，以及代谢产物的积累，必须转移到新鲜培养基上培养,这个过程叫做继代培养。</p><h3 id="何为外植体的褐变，减轻外植体褐变的方法？（PPT87、90）"><a class="header-anchor" href="#何为外植体的褐变，减轻外植体褐变的方法？（PPT87、90）"></a>何为外植体的褐变，减轻外植体褐变的方法？（PPT87、90）</h3><p>外植体褐变是指在接种后，其表面开始褐变，有时甚至会使整个培养基褐变的现象。</p><ul><li>它的出现是由于植物组织中的多酚氧化酶（PPO）被激活，而使细胞的代谢发生变化所致。</li><li>在褐变过程中，会产生醌类物质，它们多呈棕褐色，当扩散到培养基后，就会抑制其他酶的活性，从而影响所接种外植体的培养。</li></ul><p>减轻褐变现象发生的方法：</p><ol><li><strong>选择合适的外植体</strong>。一般来说，最好选择生长处于旺盛的外植体，这样可以使褐变现象明显减轻。</li><li><strong>合适的培养条件</strong>。无机盐成分、植物生长物质水平、适宜温度、及时继代培养均可以减轻材料的褐变现象。</li><li><strong>使用抗氧化剂</strong>。在培养基中，使用半胱氨酸、抗坏血酸、PVP等抗氧化剂能够较为有效地避免或减轻很多外植体的褐变现象。另外，使用0.1%~0.5%的活性炭对防止褐变也有较为明显的效果。</li><li><strong>连续转移</strong>。对容易褐变的材料可间隔12~24h的培养后，再转移到新的培养基上，这样经过连续处理7~10d后，褐变现象便会得到控制或大为减轻。</li></ol><hr><ol><li><p>在培养室和操作室中，一年中要定期进行一两次熏蒸，使用的药品是：<br>A、甲醛和高锰酸钾✔<br>B、酒精和次氯酸钠<br>C、紫外灯和酒精<br>D、升汞和酒精</p></li><li><p>组织培养中常用的生长素：吲哆乙酸（IAA），2,4-二氯苯氧乙酸（2,4-D），吲哆丁酸（IBA），萘乙酸（NAA），它们的作用强弱顺序为 <psw>2,4-D</psw> &gt; <psw>NAA</psw> &gt; <psw>IBA</psw> &gt; <psw>IAA</psw> 。</p></li><li><p>细胞分裂素中作用最强的是 <psw>TDZ</psw> 。</p></li></ol><h2 id="第3章-组培基本理论思考题"><a class="header-anchor" href="#第3章-组培基本理论思考题"></a>第3章 组培基本理论思考题</h2><h3 id="为什么利用植物的一个花瓣就可以培育出完整的植株？"><a class="header-anchor" href="#为什么利用植物的一个花瓣就可以培育出完整的植株？"></a>为什么利用植物的一个花瓣就可以培育出完整的植株？</h3><p>细胞全能性</p><h3 id="细胞为什么具有全能性？"><a class="header-anchor" href="#细胞为什么具有全能性？"></a>细胞为什么具有全能性？</h3><p>生物的每一个细胞都包含有该物种所特有的全套遗传物质，都有发育成完整个体所必需的全部基因。</p><h3 id="细胞表现出全能性的条件"><a class="header-anchor" href="#细胞表现出全能性的条件"></a>细胞表现出全能性的条件</h3><ul><li>离体状态</li><li>有一定营养物质、激素和其他外界条件（如无菌、温度、pH）</li></ul><h3 id="植物组织培养一般要经过哪两个的基本过程？"><a class="header-anchor" href="#植物组织培养一般要经过哪两个的基本过程？"></a>植物组织培养一般要经过哪两个的基本过程？</h3><p>脱分化和再分化</p><h3 id="决定细胞脱分化、再分化的关键因素是什么？"><a class="header-anchor" href="#决定细胞脱分化、再分化的关键因素是什么？"></a>决定细胞脱分化、再分化的关键因素是什么？</h3><p>植物激素的种类和比例浓度。</p><h3 id="愈伤组织的细胞有何特点？"><a class="header-anchor" href="#愈伤组织的细胞有何特点？"></a>愈伤组织的细胞有何特点？</h3><p>排列疏松、高度液泡化的薄壁细胞</p><h3 id="胚状体有何特点？"><a class="header-anchor" href="#胚状体有何特点？"></a>胚状体有何特点？</h3><p>胚状体是由体细胞诱导分化出具有胚芽、胚根、胚轴的胚状结构，进而长成完整植株。</p><hr><ol><li>当细胞分裂素与生长素共同使用时，能强烈促进愈伤组织的形成。当细胞分裂素与生长素<strong>浓度比高</strong>时，<strong>有利于</strong>芽的发生；<strong>浓度比低</strong>时，<strong>有利于</strong>根的发生。</li><li>一般情况下外植体越幼小，分化的程度就越低，组织培养的成功率就越高。</li><li>在一个生物体内，细胞没有表现出全能性，原因是:<br>A、细胞失去了全能性<br>B、细胞中的基因部分丢失<br>C、细胞中的基因选择性表达✔<br>D、细胞中的基因变异不同</li><li>关于愈伤组织形成过程的正确叙述是:<br>A、愈伤组织的形成是离体植物细胞分化的结果<br>B、愈伤组织的形成是离体植物细胞分裂的结果<br>C、愈伤组织的形成是离体动物细胞分化的结果<br>D、愈伤组织的形成是离体植物细胞脱分化的结果✔</li><li>当植物细胞脱离了原来所在植物体的器官或组织而处于离体状态时，下列有可能使其表现出全能性，发育成完整的植株的是:<br>A、细胞分裂素<br>B、生长素<br>C、一定的营养物质<br>D、以上三者均是✔</li><li>要将胡萝卜韧皮部细胞培养成完整植株，不需要:<br>A、具有完整细胞核的细胞<br>B、离体状态<br>C、导入外源基因✔<br>D、一定的营养物质和激素</li><li>下列植物细胞全能性最高的是:<br>A、形成层细胞✔<br>B、韧皮部细胞<br>C、木质部细胞<br>D、叶肉细胞</li><li>下列细胞全能性最高的是:<br>A、植物的卵细胞<br>B、植物的精子细胞<br>C、被子植物的受精卵✔<br>D、被子植物的的叶肉细胞</li><li>绝大多数培养植物再生植株时都先经过 <psw>愈伤组织</psw> 阶段。</li><li>愈伤组织形成大致经历 <psw>诱导期</psw> 、<psw>分裂期</psw> 和 <psw>分化期</psw> 三个时期。</li><li>愈伤组织的形态发生方式主要有 <psw>不定芽和不定根</psw> 方式和 <psw>胚状体</psw> 方式。</li></ol><hr><p>某二倍体植物是杂合子,下图为其花药中未成熟花粉在适宜的培养基上培养产生完整植株的过程。据图回答：<br><img src="https://pic.downk.cc/item/5ff5b86e3ffa7d37b3fa31a5.png" style="zoom:67%;" /></p><ol><li>①表示的是该花粉培养过程中的 <psw>脱分化</psw> 过程</li><li>②表示的是 <psw>再分化</psw> 过程,X代表的是 <psw>胚状体</psw></li><li>③表示的是 <psw>分化（或发育）</psw> 过程</li><li>④表示的是诱导 <psw>生根</psw> 过程。</li></ol><hr><p>下图是植物组织培养的简略表示。据此回答：<br><img src="https://pic.downk.cc/item/5ff5b9083ffa7d37b3fb27b9.jpg" style="zoom:80%;" /></p><ol><li>①表示 <psw>离体的器官、组织或细胞</psw> 它能被培养成为④的根本原因是 <psw>植物细胞的全能性</psw></li><li>②表示 <psw>愈伤组织</psw> ，它与①相比分化程度 <psw>低</psw> 全能性 <psw>高</psw> 。</li><li>若想制作人工种子，应该选用（填编号） <psw>③</psw> 。</li><li>若①是胡萝卜根尖细胞，则培养成的④的叶片的颜色是 <psw>绿色</psw> ，这说明根尖细胞 <psw>含有叶绿体形成相关的基因</psw> 。</li></ol><h2 id="第4章-植物组织器官形成思考题"><a class="header-anchor" href="#第4章-植物组织器官形成思考题"></a>第4章 植物组织器官形成思考题</h2><h3 id="愈伤组织形态发生（再分化过程）的两种方式（PPT4）"><a class="header-anchor" href="#愈伤组织形态发生（再分化过程）的两种方式（PPT4）"></a>愈伤组织形态发生（再分化过程）的两种方式（PPT4）</h3><ul><li>体细胞发生途径（胚状体）</li><li>器官发生途径（不定芽不定根）</li></ul><h3 id="器官发生再生植株的四种基本方式（PPT8）"><a class="header-anchor" href="#器官发生再生植株的四种基本方式（PPT8）"></a>器官发生再生植株的四种基本方式（PPT8）</h3><ol><li>愈伤组织仅有根或芽器官的分别形成，即无根的芽或无芽的根</li><li>先长芽，后长根，多数情况；</li><li>先长根，再从根的基部长芽。这种情况较难诱导芽的形成，尤其对于单子叶植物；</li><li>先在愈伤组织的邻近不同部位分别形成芽和根，然后两者结合起来形成一株植株。</li></ol><h3 id="胚状体定义（PPT26）"><a class="header-anchor" href="#胚状体定义（PPT26）"></a>胚状体定义（PPT26）</h3><p>体细胞胚又叫胚状体：指在组织培养中，由一个非合子细胞（体细胞），经胚胎发生和胚胎发育过程（经过原胚、球形胚、心形胚、鱼雷胚和子叶胚5个时期），形成具有双极性的胚状结构。</p><h3 id="体细胞胚发生途径的特点（PPT33）"><a class="header-anchor" href="#体细胞胚发生途径的特点（PPT33）"></a>体细胞胚发生途径的特点（PPT33）</h3><ol><li>胚状体具有明显的两极性，即有茎端和根端；</li><li>存在生理隔离，即体细胞胚和外植体的维管束系统无直接联系，胚状体与周围组织间形成缝隙，处于较独立的状态。</li><li>遗传的稳定性。</li><li>发生数量大，增殖率高。</li></ol><h3 id="影响体细胞胚胎发生的因素（PPT37-54、课本P53-55）"><a class="header-anchor" href="#影响体细胞胚胎发生的因素（PPT37-54、课本P53-55）"></a>影响体细胞胚胎发生的因素（PPT37~54、课本P53~55）</h3><p>植物材料的内在因素</p><ol><li>供体植物的基因型<ul><li>不同物种产生胚状体的能力不同</li><li>同一物种的不同品种之间产生胚状体的能力也不同</li></ul></li><li>外植体的来源<ul><li>大多数植物只有处于一定发育阶段的某一种器官的外植体能产生胚状体；</li><li>芹菜、人参、葡萄、甘蔗的组织培养</li><li>离体产生的胚状体可以再次作为外植体，经继代培养能够产生大量的次级和三级胚状体</li><li>利用胚状体进行连续培养快速繁殖种苗</li><li>在继代培养过程中，胚状体的发生能力会逐渐降低</li><li>不同植物callus分化胚状体的速度不同</li></ul></li><li>培养物的生理状况<ul><li>培养细胞的内源激素水平</li><li>不同采样时期的外植体</li><li>采用增殖能力较强的外植体</li><li>获得较多的体细胞胚</li></ul></li><li>培养物的倍性<ul><li>体细胞胚可以从不同倍性的组织中获得，单倍性的小孢子（花粉）；二倍体、三倍体、多倍体体细胞</li><li>倍性水平不影响体细胞胚的发生但体细胞胚的发育和转换过程会有差异</li></ul></li></ol><p>组织培养的外部因素</p><ol><li><p>培养基中的外源激素</p><ul><li>根据不同植物对外源激素的需求分3种情况：①全过程不需要外源激素。添加少量会提高诱导频率；②诱导胚状体的全过程需要外源激素。较高的激动素和生长素的配比才有较高的频率(咖啡)；③前期需要激素，后期不需要或极低浓度即可。常见，激素诱导出后callus，诱导胚状体无需激素（或很低）</li><li>不同植物的体胚发生，要求不同的激素种类（颠茄: NAA和激动素，南瓜：NAA和IBA）</li><li>玉米素，一种天然的细胞分裂素，促进胡萝卜体胚的发生，猕猴桃的胚乳callus只有在培养基中添加玉米素才能分化出体胚</li></ul></li><li><p>培养基成分对体胚形成的影响</p><ul><li>氮源：还原态的氮（铵盐）的浓度直接影响胚状体的诱导效果，培养基中添加有机氮源（水解酪蛋白、氨基酸）有利于胚状体的发生</li><li>碳源：碳水化合物能维持组织培养中外植体的渗透压，同时又作为体胚发育的能源。其种类和浓度可以影响体胚的生长发育</li><li>天然提取物：椰子乳被认为是对体胚发生最有效的物质；其它未成熟的胚乳，如玉米胚乳、水稻胚乳、小麦胚乳对胚的生长也有一定作用；酵母、麦芽、酪蛋白等提取物对促进体胚的产生和发育，都是较为有效的天然物质。</li><li>活性炭：吸附一些外植体分泌出的有毒物质；提高体胚的诱导频率和生长发育</li></ul></li><li><p>另外，一些其他因素如培养过程中的环境条件如光照、温度，对外植体的预处理如辐射、低温及离心等都会影响胚状体发发生。</p></li></ol><h2 id="第5章-胚胎培养思考题"><a class="header-anchor" href="#第5章-胚胎培养思考题"></a>第5章 胚胎培养思考题</h2><h3 id="为什么幼胚培养比成熟胚培养要求的培养基和培养条件更为严格？"><a class="header-anchor" href="#为什么幼胚培养比成熟胚培养要求的培养基和培养条件更为严格？"></a>为什么幼胚培养比成熟胚培养要求的培养基和培养条件更为严格？</h3><p>成熟胚培养：指子叶期至发育成熟的胚培养。成熟胚是自养的，培养基需要简单。仅提供一定的温度、湿度就可以发芽生成植物体。如种子的发育。</p><p>幼胚培养：是指处于原胚期、球形期、心形期、鱼雷期的胚培养；幼胚基本是<strong>异养</strong>的，离体条件下培养要求培养基成分复杂，培养不易成功。</p><h3 id="离体培养时胚的发育方式有哪几种？（PPT11）"><a class="header-anchor" href="#离体培养时胚的发育方式有哪几种？（PPT11）"></a>离体培养时胚的发育方式有哪几种？（PPT11）</h3><p>离体胚培养：是指从植物种子中分离出胚组织进行离体培养的技术</p><ol><li>合子胚发育途径：由合子形成球形胚，心形胚，鱼雷形胚，子叶形胚，形成完整的种子，合适条件下即可萌发成苗。</li><li>早熟萌发：幼胚离体培养不经历休眠过程，不经历胚胎发育迅速萌发成幼苗。多数情况一个幼胚萌发成一个植株，有时因细胞分裂形成许多胚状体，进而形成许多植株，即丛生胚现象。<strong>苗弱小，不易成活</strong>。</li><li>脱分化形成愈伤组织：多数植物幼胚形成愈伤组织。再分化成胚状体或形成芽苗，主要原因是培养基成分不适宜。</li></ol><h3 id="胚胎培养在育种工作中有哪些应用（意义）？（PPT12）"><a class="header-anchor" href="#胚胎培养在育种工作中有哪些应用（意义）？（PPT12）"></a>胚胎培养在育种工作中有哪些应用（意义）？（PPT12）</h3><ol><li>用于的胚挽救，克服远缘杂种的不育性</li><li>使无生活力的种子获得后代</li><li>使发育不完全的植物获得后代</li><li>克服种子休眠、缩短育种年限</li><li>克服珠心胚的干扰</li><li>诱导胚状体及胚性愈伤组织</li><li>稀有植物的繁殖</li></ol><h3 id="离体授粉的类型和意义有哪些方面？（PPT55）"><a class="header-anchor" href="#离体授粉的类型和意义有哪些方面？（PPT55）"></a>离体授粉的类型和意义有哪些方面？（PPT55）</h3><p>离体授粉的类型：</p><ul><li>离体胎座（胚珠）授粉：把花粉授于连在胎座的胚珠上，进而实现受精作用的方法</li><li>离体子房授粉：将花粉粒直接送入子房以实现受精作用的方法。</li><li>离体柱头（雌蕊）授粉：把花粉授于离体子房的柱头上，进而实现受精作用的方法</li></ul><p>意义：</p><ol><li>可以克服植物受精不育障碍，特别是离体子房授粉和离体胚珠授粉，能消除柱头和花柱所造成的受精前障碍。</li><li>克服自我不亲和性</li><li>诱导孤雌生殖</li><li>双受精及胚台早期发育的机理研究</li></ol><h2 id="第6章-人工种子思考题（无）"><a class="header-anchor" href="#第6章-人工种子思考题（无）"></a>第6章 人工种子思考题（无）</h2><h2 id="第7章-单倍体细胞培养思考题"><a class="header-anchor" href="#第7章-单倍体细胞培养思考题"></a>第7章 单倍体细胞培养思考题</h2><h3 id="说明植物花药培养和花粉培养概念（PPT21、32）"><a class="header-anchor" href="#说明植物花药培养和花粉培养概念（PPT21、32）"></a>说明植物花药培养和花粉培养概念（PPT21、32）</h3><p>花药培养：将发育到一定阶段的花药剥离下来（切去花丝部分）接种到培养基上进行培养，最终形成完整植株的过程。</p><p>花粉培养：是从花药中分离出来的花粉粒，使之成为分散的或游离的状态，通过培养使花粉粒脱分化，进而再分化并发育成完整植株的过程。</p><h3 id="通过离体培养获得单倍体的途径有哪些？（课本P97）"><a class="header-anchor" href="#通过离体培养获得单倍体的途径有哪些？（课本P97）"></a>通过离体培养获得单倍体的途径有哪些？（课本P97）</h3><p>花药培养、花粉（小孢子）培养和未受精子房及卵细胞培养，其中花药和小孢子培养是体外诱导单倍体的主要途径</p><h3 id="花药培养中如何选择外植体？"><a class="header-anchor" href="#花药培养中如何选择外植体？"></a>花药培养中如何选择外植体？</h3><p>选择花粉发育时期：单核早期到双核早期</p><h3 id="花药培养与花粉培养有什么不同（或异同）？（PPT33）"><a class="header-anchor" href="#花药培养与花粉培养有什么不同（或异同）？（PPT33）"></a>花药培养与花粉培养有什么不同（或异同）？（PPT33）</h3><p>相同点：培养目的相同，均获得单倍体植株。胚状体成苗途径、愈伤组织再分化成苗途径。</p><p>不同点：</p><ol><li>花药培养其外植体是植物雄性生殖器官的一部分，就培养方法和技术来讲，属于器官培养；而花粉培养属于细胞培养。</li><li>花粉培养没有药壁组织干扰；可计数小孢子产胚率；可观察雄核发育的全过程；单倍体产量高。但技术更复杂</li></ol><h3 id="花药培养过程中花药为什么要经过低温处理？（课本P108）"><a class="header-anchor" href="#花药培养过程中花药为什么要经过低温处理？（课本P108）"></a>花药培养过程中花药为什么要经过低温处理？（课本P108）</h3><p>对于有些物种，培养前对花药进行低温预处理，能显著提高培养效果。是成功的前提条件。</p><h2 id="第8章-植物细胞培养及应用思考题（无）"><a class="header-anchor" href="#第8章-植物细胞培养及应用思考题（无）"></a>第8章 植物细胞培养及应用思考题（无）</h2><h2 id="第9章-植物体细胞杂交思考题（无）"><a class="header-anchor" href="#第9章-植物体细胞杂交思考题（无）"></a>第9章 植物体细胞杂交思考题（无）</h2><h2 id="第10章-植物脱毒技术思考题"><a class="header-anchor" href="#第10章-植物脱毒技术思考题"></a>第10章 植物脱毒技术思考题</h2><h3 id="某地区的一种马铃薯经多年的种植后，植株变的矮小，产量和品质都下降，怀疑是由病毒所至。请你设计一个病毒的鉴定和脱毒的技术方案"><a class="header-anchor" href="#某地区的一种马铃薯经多年的种植后，植株变的矮小，产量和品质都下降，怀疑是由病毒所至。请你设计一个病毒的鉴定和脱毒的技术方案"></a>某地区的一种马铃薯经多年的种植后，植株变的矮小，产量和品质都下降，怀疑是由病毒所至。请你设计一个病毒的鉴定和脱毒的技术方案</h3><p>脱毒植物的鉴定方法：</p><ol><li>直接鉴定法：观察脱毒后植株茎、叶等器官生长情况，有无病毒引起的症状。</li><li>指示植物鉴定：对病毒反应敏感、症状明显的植物。如烟草、马铃薯、葡萄、柑桔等。方法①摩擦接种法：用脱毒植物叶片中汁液与金刚砂或石英沙摩擦指示植物叶片，冲冼培养数天，观察有无出现病毒感染症状。方法②嫁接法：木本植物病毒不通过汁液传播。将脱毒植物茎尖微嫁接在指示植物砧木上，观察有无出现病毒感染症状。</li><li>电镜检测：电镜下检测病毒形态、大小及结构。</li><li>抗血清检测法：病毒蛋白抗原免疫动物，获得含特异结合抗体的血清，再与脱毒植物是否发生血清反应检测。酶联免疫吸附测定</li><li>分子检测技术：利用已知病毒DNA序列设计引物或探针，检测脱毒植物</li></ol><p>脱毒的技术方案：</p><ol><li>茎尖培养脱毒</li><li>热处理脱毒</li><li>茎尖与热处理相结合方法</li><li>其它途径脱毒：愈伤组织培养脱毒、茎尖微体嫁接、化学疗法脱毒（病毒抑制剂）</li></ol><h2 id="第11章-无性系变异及种质离体保存思考题"><a class="header-anchor" href="#第11章-无性系变异及种质离体保存思考题"></a>第11章 无性系变异及种质离体保存思考题</h2><h3 id="超低温保存离体种质资源的原理和一般程序是什么？（PPT34-35、38）"><a class="header-anchor" href="#超低温保存离体种质资源的原理和一般程序是什么？（PPT34-35、38）"></a>超低温保存离体种质资源的原理和一般程序是什么？（PPT34~35、38）</h3><p>超低温保存：也叫冷冻保存，指在<b>-196℃</b>的液氮超低温下使细胞代谢和生长处于基本停止的状态，在适宜条件下可繁殖，再生出新的植株，并保持原来的遗传特性。</p><p>保存原理：低温冰冻过程中，如果生物细胞内水分结冰，细胞结构就遭到不可逆的破坏，导致细胞和组织死亡。<strong>植物材料在超低温条件下，冰冻过程中避免了细胞内水分结冰</strong>，并且在解冻过程中防止细胞内水分次生结冰而达到植物材料保存目的。</p><p>基本程序：超低温保存的基本程序包括预处理、冷冻处理、冷冻贮存、解冻和再培养。</p><h3 id="限制生长保存离体种质资源有哪些方式？"><a class="header-anchor" href="#限制生长保存离体种质资源有哪些方式？"></a>限制生长保存离体种质资源有哪些方式？</h3><ul><li>常温限制生长保存</li><li>低温保存</li><li>超低温保存</li></ul><h3 id="细胞活力检测有哪些方法？（课本P258）"><a class="header-anchor" href="#细胞活力检测有哪些方法？（课本P258）"></a>细胞活力检测有哪些方法？（课本P258）</h3><ul><li>TTC法（氯化三苯基四氮唑还原法）</li><li>FDA染色法（二醋酸酯荧光素染色法）</li><li>色谱分析法</li><li>再培养</li><li>细胞学变化</li><li>生化稳定性</li><li>遗传性分析</li></ul><h3 id="有哪些冷冻保护剂？（课本P249）"><a class="header-anchor" href="#有哪些冷冻保护剂？（课本P249）"></a>有哪些冷冻保护剂？（课本P249）</h3><p>常见的防冻剂有二甲基亚砜（DMSO）、聚乙二醇（PEG）、甘油及多种糖类等</p><h3 id="利用马铃薯无毒苗学习实践植物种质资源的限制生长保存技术"><a class="header-anchor" href="#利用马铃薯无毒苗学习实践植物种质资源的限制生长保存技术"></a>利用马铃薯无毒苗学习实践植物种质资源的限制生长保存技术</h3><h2 id="影响因素整理"><a class="header-anchor" href="#影响因素整理"></a>影响因素整理</h2><h3 id="影响器官分化的因素（课本P46、第4章PPT12）"><a class="header-anchor" href="#影响器官分化的因素（课本P46、第4章PPT12）"></a>影响器官分化的因素（课本P46、第4章PPT12）</h3><ol><li><p>培养基成分</p><ul><li><strong>无机营养</strong>：培养基中的N，大多数都用硝态氮，对细胞分化起重要作用。</li><li><strong>植物生长调节物质</strong>：培养基中生长调节物质对愈伤组织的诱导及增殖起着重要的调节作用。使用植物生长调节剂时，要注意种类和浓度，特别是生长素和细胞分裂素的比值。</li><li><strong>有机成分</strong>：培养基中加入糖、维生素类、肌醇和甘氨酸等，可满足愈伤组织生长和分化的要求。各种氨基酸和嘌呤、嘧啶类物质，可促进器官分化。水解酪蛋白中含有多种氨基酸，助于器官分化。糖的种类和浓度对组织培养物的增殖和器官分化均有明显的影响。</li><li><strong>培养基pH值</strong>：培养基pH值影响愈伤组织对营养元素的吸收、呼吸代谢、多胺代谢、DNA合成以及植物激素对细胞的影响，从而影响愈伤组织的形成及形态建成。</li><li><strong>活性炭等一些惰性物质</strong>：活性炭有时会对愈伤组织的分化起到很好的作用，活性炭可促进愈伤组织的器官发生（根、芽）和体细胞胚胎发生。</li><li><strong>培养方式</strong>：有固体培养、液体培养等</li></ul></li><li><p>环境条件</p><ul><li><strong>光照</strong>：光照包括光强、光质和光周期，对器官分化有重要影响。光照对器官发生的调节可能与调节培养物的内源激素平衡有关，光照还可能影响生长素的信号转导系统，调整生长素的极性运输，从而引起器官分化。光质对器官分化的影响可能与光受体精确调节系统有关。</li><li><strong>温度</strong>：昼夜温差处理，低温处理</li><li><strong>湿度</strong>：培养室适宜的湿度为70%~80%</li></ul></li><li><p>植株材料</p><ul><li>不同品种基因型的差异</li><li>外植体的生理状况和外植体的类型：生长活跃的，幼嫩，自然繁殖的外植体利于培养</li></ul></li></ol><h3 id="影响体细胞胚胎发生的因素（第4章PPT37-54）"><a class="header-anchor" href="#影响体细胞胚胎发生的因素（第4章PPT37-54）"></a>影响体细胞胚胎发生的因素（第4章PPT37~54）</h3><p>植物材料的内在因素</p><ol><li>供体植物的基因型<ul><li>不同物种产生胚状体的能力不同</li><li>同一物种的不同品种之间产生胚状体的能力也不同</li></ul></li><li>外植体的来源<ul><li>大多数植物只有处于一定发育阶段的某一种器官的外植体能产生胚状体；</li><li>芹菜、人参、葡萄、甘蔗的组织培养</li><li>离体产生的胚状体可以再次作为外植体，经继代培养能够产生大量的次级和三级胚状体</li><li>利用胚状体进行连续培养快速繁殖种苗</li><li>在继代培养过程中，胚状体的发生能力会逐渐降低</li><li>不同植物callus分化胚状体的速度不同</li></ul></li><li>培养物的生理状况<ul><li>培养细胞的内源激素水平</li><li>不同采样时期的外植体</li><li>采用增殖能力较强的外植体</li><li>获得较多的体细胞胚</li></ul></li><li>培养物的倍性<ul><li>体细胞胚可以从不同倍性的组织中获得，单倍性的小孢子（花粉）；二倍体、三倍体、多倍体体细胞</li><li>倍性水平不影响体细胞胚的发生但体细胞胚的发育和转换过程会有差异</li></ul></li></ol><p>组织培养的外部因素</p><ol><li><p>培养基中的外源激素</p><ul><li>根据不同植物对外源激素的需求分3种情况：①全过程不需要外源激素。添加少量会提高诱导频率；②诱导胚状体的全过程需要外源激素。较高的激动素和生长素的配比才有较高的频率(咖啡)；③前期需要激素，后期不需要或极低浓度即可。常见，激素诱导出后callus，诱导胚状体无需激素（或很低）</li><li>不同植物的体胚发生，要求不同的激素种类（颠茄: NAA和激动素，南瓜：NAA和IBA）</li><li>玉米素，一种天然的细胞分裂素，促进胡萝卜体胚的发生，猕猴桃的胚乳callus只有在培养基中添加玉米素才能分化出体胚</li></ul></li><li><p>培养基成分对体胚形成的影响</p><ul><li>氮源：还原态的氮（铵盐）的浓度直接影响胚状体的诱导效果，培养基中添加有机氮源（水解酪蛋白、氨基酸）有利于胚状体的发生</li><li>碳源：碳水化合物能维持组织培养中外植体的渗透压，同时又作为体胚发育的能源。其种类和浓度可以影响体胚的生长发育</li><li>天然提取物：椰子乳被认为是对体胚发生最有效的物质；其它未成熟的胚乳，如玉米胚乳、水稻胚乳、小麦胚乳对胚的生长也有一定作用；酵母、麦芽、酪蛋白等提取物对促进体胚的产生和发育，都是较为有效的天然物质。</li><li>活性炭：吸附一些外植体分泌出的有毒物质；提高体胚的诱导频率和生长发育</li></ul></li><li><p>另外，一些其他因素如培养过程中的环境条件如光照、温度，对外植体的预处理如辐射、低温及离心等都会影响胚状体发发生。</p></li></ol><h3 id="影响离体授粉的因素（课本P63）"><a class="header-anchor" href="#影响离体授粉的因素（课本P63）"></a>影响离体授粉的因素（课本P63）</h3><ol><li>外植体的发育阶段</li><li>花粉粒数量及萌发力</li><li>营养及环境条件</li><li>授粉方式</li><li>保留母体组织的影响</li><li>基因型的影响</li><li>培养前的预处理</li></ol><h3 id="影响花药培养的因素"><a class="header-anchor" href="#影响花药培养的因素"></a>影响花药培养的因素</h3><p>课本P105</p><ol><li><p>植株的生长条件</p></li><li><p>供体植株的年龄</p></li><li><p>花粉发育时期</p></li><li><p>花蕾和花药的预处理</p></li><li><p>供体植株的基因型</p></li><li><p>培养基</p><ul><li>基本培养基</li><li>碳源</li><li>激素成分</li><li>氮源</li><li>硝酸银</li><li>其他成分</li><li>pH值</li></ul></li><li><p>培养条件</p></li><li><p>活性炭的作用</p></li></ol><hr><p>第7章PPT30</p><ol><li>供体植株的基因型：不同种和品种的花药，在离体培养条件下的反应能力有明显差异。</li><li>花粉发育时期：花粉的发育时期使诱导小孢子分裂的关键，多数植物在单核中期至单核晚期（单核靠边期）的花粉都易形成花粉愈伤组织或花粉胚。</li><li>花药的生理状态：适宜条件下的健康植株，花药培养的胚诱导率，再生率高，冬春季较夏秋季适合花药培养；多数情况下，幼年植株优于老年植株。</li><li>花蕾和花药的预处理：预处理是小孢子培养成功的前提条件。有低温，高温及甘露醇等预处理，其中以低温预处理应用最广。</li><li>培养基的影响：基本培养基是花药培养中影响花粉启动和再分化的重要条件，不仅决定花药培养的成功，还决定着雄核发育的方式。培养基因植物种类的不同而异。<ul><li>多采用MS培养基</li><li>对氨态氮和硝态氮比例加以调整</li><li>植物生长调节剂为大多数的雄核发育所必需，常诱发细胞的分裂，生长和分化。</li><li>所需蔗糖的浓度在3%-10%</li><li>pH值有一定的要求</li></ul></li></ol><h3 id="影响花药培养和花粉培养的因素（第7章PPT42）"><a class="header-anchor" href="#影响花药培养和花粉培养的因素（第7章PPT42）"></a>影响花药培养和花粉培养的因素（第7章PPT42）</h3><ol><li>基因型：不同基因型的培养难易及植株再生有很大差别。</li><li>植株的生理状态和环境条件：母体植株的年龄和所经历的环境条件如：光周期、光照强度、温度等对以后的花粉离体培养有很大影响。一般田间比温室，幼龄比老龄植株易于培养。</li><li>花粉的发育时期：多数植物<strong>单核期</strong>的花粉培养容易成功。</li><li>培养基：基因型不同，所需培养基种类，蔗糖浓度以及添加激素种类和浓度不同</li></ol><h3 id="影响花粉-小孢子-培养的因素（课本P118）"><a class="header-anchor" href="#影响花粉-小孢子-培养的因素（课本P118）"></a>影响花粉(小孢子)培养的因素（课本P118）</h3><p>很大程度上与影响花药培养效果的因素相类似</p><ol><li>合适的基因型分离小孢子是培养成功的关键因素</li><li>外植体的生理状态对游离花粉的分裂能力有重要影响</li><li>一定条件下预培养后的花药分离出的花粉在进行培养容易收到良好的效果</li><li>培养基的成分当然影响花粉的培养效果</li><li>培养基的物理状态与培养效果有关</li><li>良好的培养与再生效果需要多种因素综合改进使用</li></ol><h3 id="影响单细胞培养的因素（课本P128）"><a class="header-anchor" href="#影响单细胞培养的因素（课本P128）"></a>影响单细胞培养的因素（课本P128）</h3><p>培养基的成分和细胞植板密度是单细胞培养成败的关键，这两个因子是相互依赖的。</p><h3 id="影响细胞悬浮培养的因素（课本P136）"><a class="header-anchor" href="#影响细胞悬浮培养的因素（课本P136）"></a>影响细胞悬浮培养的因素（课本P136）</h3><ol><li>基本培养基的组成</li><li>有机成分</li><li>碳源</li><li>植物激素</li><li>培养基的pH值及渗透压</li><li>振荡频率</li><li>培养条件</li></ol><h3 id="影响幼胚培养成功的因素（第5章PPT25）"><a class="header-anchor" href="#影响幼胚培养成功的因素（第5章PPT25）"></a>影响幼胚培养成功的因素（第5章PPT25）</h3><ol><li><p>基本培养基+附加物</p><ul><li>无机盐，成熟胚培养基简单，如White.幼胚培养有MS，B5等，可使K<sup>+</sup>,Ca<sup>2+</sup>水平稍高。</li><li>碳水化合物，糖的作用：调节渗透压；碳源；防止幼胚早萌。渗透压：提高培养基渗透压是防止早熟萌发的有效方法。最适蔗糖浓度随着胚的发育时期二降低。提高渗透压的方法：提高糖浓度，提高无机盐浓度，加入甘露醇。</li></ul></li><li><p>激素的作用</p><ul><li>成熟胚一般不需要外源激素即可萌发。单激素能促进休眠胚的 萌发。</li><li>幼胚需要外源激素，应保持外源激素与内源激素的平衡。过低不能促进生长，过高易导致幼胚脱分化形成愈伤。</li></ul></li><li><p>天然提取物及某些蛋白制品：促进幼胚的发育</p></li><li><p>环境条件</p><ul><li>温度：多数为25~30℃；</li><li>光照：一般认为黑暗或弱光条件较为合适。</li></ul></li><li><p>提高幼胚的成活萌发的有效率，可采用胚乳看护培养</p></li></ol><h2 id="有关流程整理"><a class="header-anchor" href="#有关流程整理"></a>有关流程整理</h2><h3 id="外植体表面消毒的一般过程（第2章PPT62、课本P34）"><a class="header-anchor" href="#外植体表面消毒的一般过程（第2章PPT62、课本P34）"></a>外植体表面消毒的一般过程（第2章PPT62、课本P34）</h3><p>外植体表面消毒的一般过程：</p><p>外植体取材 → 预处理 → 无菌条件下，70%~75%酒精表面消毒30s~60s → 无菌条件下，消毒剂处理 → 无菌水充分漂洗3~5次 → 备用</p><h3 id="配置母液流程（第2章PPT40）"><a class="header-anchor" href="#配置母液流程（第2章PPT40）"></a>配置母液流程（第2章PPT40）</h3><p>计算 → 称量 → 加成分溶解 → 混合定容 → 测pH → 贴标签 → 冰箱贮存</p><h3 id="培养基的配制流程（第2章PPT43）"><a class="header-anchor" href="#培养基的配制流程（第2章PPT43）"></a>培养基的配制流程（第2章PPT43）</h3><p>准备 → 将水、母液和糖混合定容 → 调pH → 加入琼脂 → 加热溶解 → 分装到已经清洗干燥的培养器皿中 → 封口 → 标记 → 高压蒸汽灭菌 → 冷却 → 凝固 → 接种</p><h3 id="外植体接种步骤（第2章PPT74）"><a class="header-anchor" href="#外植体接种步骤（第2章PPT74）"></a>外植体接种步骤（第2章PPT74）</h3><p>切割外植体 → 培养瓶倾斜靠近酒精灯火焰 → 瓶盖外部在火焰上旋转灼烧数秒钟 → 旋开瓶盖，放在酒精灯旁边 → 瓶口在火焰上旋转灼烧数秒钟 → 用无菌镊子将外植体均匀放置在培养基上 → 瓶盖在火焰上灼烧两圈 → 盖紧瓶盖</p><h3 id="茎尖脱毒培育程序（课本P76）"><a class="header-anchor" href="#茎尖脱毒培育程序（课本P76）"></a>茎尖脱毒培育程序（课本P76）</h3><p>采样 → 取外叶 → 剥离茎尖 → 切取分生组织 → 茎尖培养 → 茎尖再生植株 → 病毒鉴定 → 防虫网内繁殖脱毒苗</p><h3 id="花药培养的基本程序（第7章PPT23）"><a class="header-anchor" href="#花药培养的基本程序（第7章PPT23）"></a>花药培养的基本程序（第7章PPT23）</h3><p>培养材料的选择 → 材料（花蕾）预处理 → 外植体消毒灭菌 → 接种培养 → 植株再生 → 诱导生根 → 单倍体植株的染色体加倍及驯化移栽。</p><h3 id="花粉培养的基本程序（第7章PPT35）"><a class="header-anchor" href="#花粉培养的基本程序（第7章PPT35）"></a>花粉培养的基本程序（第7章PPT35）</h3><p>取花蕾（镜检） → 消毒 → 取花药 → 预培养数天 → 分离花粉 → 接种 → 培养 → 胚状体或愈伤组织发生</p><h3 id="成熟胚培养过程（第5章PPT21）"><a class="header-anchor" href="#成熟胚培养过程（第5章PPT21）"></a>成熟胚培养过程（第5章PPT21）</h3><p>选取完好种子 → 70%酒精浸数秒 → 0.1%升汞或2%次氯酸钠浸泡 → 无菌水冲洗 → 种子培养几天 → 剥离种胚 → 接种在培养基上。</p><h3 id="幼胚培养的基本程序（第5章PPT22）"><a class="header-anchor" href="#幼胚培养的基本程序（第5章PPT22）"></a>幼胚培养的基本程序（第5章PPT22）</h3><p>取子房 → 常规表面消毒 → 解剖镜下，取胚珠、去珠被、取出完整幼胚 → 固体培养</p><h3 id="超低温保存的基本程序（第11章PPT38）"><a class="header-anchor" href="#超低温保存的基本程序（第11章PPT38）"></a>超低温保存的基本程序（第11章PPT38）</h3><p>超低温保存的基本程序包括预处理、冷冻处理、冷冻贮存、解冻和再培养。</p><p>预处理：为保证茎尖在液N<sub>2</sub>处理后具有稳定且高的存活率，需进行一定的预处理，或在冷冻防护剂存在下进行预培养，或直接进行低温（-3~10℃）预处理。</p><h3 id="植物组织培养一般过程（第3章PPT64）"><a class="header-anchor" href="#植物组织培养一般过程（第3章PPT64）"></a>植物组织培养一般过程（第3章PPT64）</h3><p>初代培养 → 继代培养 → 丛芽培养 → 生根培养 → 驯化培养</p><h2 id="计算题培养基的配置"><a class="header-anchor" href="#计算题培养基的配置"></a>计算题培养基的配置</h2><p>母液配制注意的问题：</p><ol><li>几种试剂混合配制时要按一定顺序将各种溶液混合。</li><li>在配制母液时应注意防止产生沉淀,如Ca<sup>2+</sup>和SO<sub>4</sub><sup>2+</sup> , Ca<sup>2+</sup>、Mg<sup>2+</sup>和PO<sub>4</sub><sup>2+</sup> 一起溶解后,会产生沉淀。</li><li>应采用纯度等级较高的分析纯或化学纯。</li><li>要用纯度较高的蒸馏水或去离子水。</li><li>母液一旦出现沉淀或有可见微生物的污染，应立即停止使用，重新配制。</li></ol><p>母液吸取体积计算公式：</p><p>所需母液的体积=所需要培养基的体积/母液的浓缩倍数</p><h2 id="重点知识点整理"><a class="header-anchor" href="#重点知识点整理"></a>重点知识点整理</h2><ol><li>培养基的成分：水、无机成分、有机成分、天然有机添加物质、植物生长调节物质、培养基的pH值、凝固剂–琼脂、活性炭、抗生素。</li><li>无机成分中大量元素化合物指浓度&gt;0.5mmol/L，有N、P、K、Ca、Mg、S。</li><li>无机成分中微量元素化合物指浓度&lt;0.5mmol/L，有B、Mn、Zn、Cu、Mo、Co、Cl、Fe</li><li>铁盐容易发生沉淀，需要<strong>单独配制</strong>，一般与Na<sub>2</sub>EDTA相互配</li><li>培养基中糖类的功能：碳源及维持培养基一定的渗透压，蔗糖是最好的碳源，葡萄糖和果糖次之。</li><li>培养基中氨基酸类的功能：蛋白质组成，优质有机氮源，促进细胞生长分化</li><li>生长素类、细胞分裂素类的作用、常用种类、强弱顺序</li><li>培养基的pH值：灭菌前pH值<strong>调控范围</strong>：pH=5.0~6.0。pH对培养基凝固的影响：<strong>高6.0会变硬，低于5.0凝固效果不好</strong>。pH调节剂：HCl、NaOH</li><li>凝固剂–琼脂,用量范围：0.4%~1.0%，影响琼脂凝固的因素：厂家的加工方式；灭菌的时间，温度，pH值；存放的时间</li><li>抗生素<strong>不耐高温，需单独过滤灭菌</strong>。作用：防止外植体内生菌造成的污染。</li><li>基本培养基较于完全培养基<strong>不包括激素和天然有机附加物</strong>。</li><li><strong>高无机盐含量</strong>的培养基代表类型：MS培养基、ER培养基</li><li>硝酸钾含量较高的培养基代表类型：B5、N6</li><li>干热灭菌（如烘烤和灼烧）；湿热灭菌（如常压或高压蒸煮）；过滤灭菌（如空气过滤和液体过滤）</li><li>高温高压蒸气灭菌温度：<strong>121°C</strong>；<strong>1.1~1.2kg/cm<sup>2</sup></strong>，压力不要超过<strong>0.15MP</strong>，维持<strong>15~20</strong>分钟即可关闭电源。</li><li>过滤灭菌：用于高温高压下易分解的培养基和激素类</li><li>细胞全能性理论：植物每一个具有完整细胞核的体细胞，都含有植物体的全部遗传信息，在适当条件下，具有发育成完整植株的潜在能力。</li><li>植物细胞全能性表现根据细胞类型不同从强到弱:<strong>营养生长中心</strong> &gt; <strong>形成层</strong> &gt; 薄壁细胞 &gt; 厚壁细胞(木质化细胞) &gt; 特化细胞(筛管、导管细胞)</li><li>植物细胞全能性表达的条件：①体细胞与完整植株分离，脱离完整植株的控制；②创造理想的适于细胞生长和分化的环境（主要是激素的作用）</li><li>细胞实现全能性的过程：通过<strong>脱分化</strong>和<strong>再分化</strong>两个阶段。</li><li><strong>液泡消失</strong>和<strong>叶绿体的转变</strong>是脱分化的重要特征。</li><li>根据脱分化细胞过程中细胞结构发生变化的时空顺序，细胞的脱分化过程可分为3个阶段：<strong>启动阶段</strong>、<strong>演变阶段</strong>和<strong>脱分化终结期</strong></li><li>脱分化的关键<strong>植物激素</strong></li><li>脱分化细胞特点：细胞质显著变浓，大液泡消失，核体积增加并逐渐移位至细胞中央，细胞器增加。</li><li>愈伤组织的定义：在组织培养过程中，沿用了这一名称，实际上是指外植体在离体培养条件下，形成的一团没有分化、又能旺盛分裂的薄壁细胞团，是组织培养过程中经常出现的一种组织状态。</li><li>愈伤组织的产生原因：内因：内源激素，材料被切伤后分泌的伤源激素；外因：外源生长调节剂，人为在培养基内加入激素。</li><li>从外植体脱分化形成典型的愈伤组织大致可分为三个时期：<strong>诱导期</strong>、<strong>分裂期</strong>和<strong>分化期</strong></li><li>两种愈伤组织间的转化关系：坚实型升高生长素浓度转化成松脆型，松脆型降低或去除生长素转化成松脆型</li><li>优良的愈伤组织通常具备以下4个特性：①高度的胚性或再分化能力。②容易散碎，建立优良的悬浮系，并能分离出全能性原生质体。③旺盛的自我增殖能力。④经过长期继代保存而不丧失胚性，以便有可能对它们进行各种遗传操作。</li><li>愈伤组织的形态发生：愈伤组织在适宜的培养条件下发生再分化，产生芽和根，或者形成胚状体，发育成苗或完整植株。</li><li>愈伤组织形态发生形成完整植株的途径：<strong>体细胞发生途径（胚状体）</strong>、<strong>器官发生途径（不定芽不定根）</strong></li><li>器官发生的途径有两种：直接途径：不经愈伤组织阶段直接分化器官；间接途径：经过愈伤组织阶段</li><li>愈伤组织通过不定芽方式再分化成完整植株的的方式主要有四种(器官发生再生植株的基本方式)：①<strong>愈伤组织仅有根或芽器官的分别形成，即无根的芽或无芽的根；<strong>②</strong>先长芽，后长根，多数情况；<strong>③</strong>先长根，再从根的基部长芽。这种情况较难诱导芽的形成，尤其对于单子叶植物；<strong>④</strong>先在愈伤组织的邻近不同部位分别形成芽和根，然后两者结合起来形成一株植株。</strong></li><li>影响器官分化的因素（要点，详见影响因素）</li><li>体细胞胚又叫胚状体：指在组织培养中，由一个非合子细胞(体细胞)，经胚胎发生和胚胎发育过程（经过<strong>原胚</strong>、<strong>球形胚</strong>、<strong>心形胚</strong>、<strong>鱼雷胚</strong>和<strong>子叶</strong>胚5个时期），形成具有<strong>双极性</strong>的胚状结构。</li><li>体细胞胚发生的途径：直接形成胚胎指在外植体上直接分化出胚状体，大多数外植体为子叶和下轴胚最易诱导体细胞胚发生。间接形成胚胎是指在外植体上先分化出胚性愈伤组织，然后由胚性愈伤组织再分化形成胚状体</li><li>体细胞胚发生途径的特点:①胚状体具有明显的两极性，即有茎端和根端；存在生理隔离，即体细胞胚和外植体的维管束系统无直接联系，胚状体与周围组织间形成缝隙，处于较独立的状态。②遗传的稳定性。③发生数量大，增殖率高。</li><li>影响体细胞胚胎发生的因素（重点，详见影响因素）</li><li>胚培养：是将胚从胚珠或种子中取出，置于适宜的培养基生长；包括<strong>未成熟胚(原胚)<strong>和</strong>成熟胚</strong>两种类型的离体培养。</li><li>胚发育可分为<strong>异养</strong>和<strong>自养</strong>两个阶段。</li><li>胚培养的意义</li><li>依据所剥离胚的发育时期不同：分为两种培养类型<strong>幼胚培养</strong>（子叶形成前）和<strong>成熟胚培养</strong>（子叶形成后）</li><li>幼胚培养：是指处于原胚期、球形期、心形期、鱼雷期的胚培养；<strong>幼胚基本是异养的</strong>，离体条件下培养要求培养基成分复杂，培养不易成功。</li><li>幼胚的分离及培养：<strong>幼胚剥离</strong>是关键。</li><li>影响幼胚培养成功的因素（要点，详见影响因素）</li><li>胚乳培养（Endosperm culture）：是指将胚乳组织从母体上分离出来，通过离体培养，使其发育成完整植株的技术。</li><li>胚乳离体培养的意义</li><li>带胚培养胚乳组织容易成功，不带胚培养胚乳组织成功率低</li><li>根据细胞分化特点，胚乳发育可分为以下3类：<strong>核型胚乳</strong>、<strong>细胞型胚乳</strong>、<strong>沼生目型胚乳</strong></li><li>胚乳培养的关键技术，胚乳发育时期中<strong>游离核型期</strong>难以培养，<strong>细胞型期</strong>易培养成功</li><li>离体授粉：指将未授粉的胚珠或子房从母体上分离下来，进行无菌培养，并以一定的方式授以无菌花粉，使之在试管内实现受精的技术。</li><li>离体授粉的类型：<strong>离体胎座（胚珠）授粉</strong>、<strong>离体子房授粉</strong>、<strong>离体柱头（雌蕊）授粉</strong></li><li>离体子房授粉的方法：<strong>直接引入法</strong>、<strong>注射法</strong></li><li>离体授粉的目的：<strong>克服受精前障碍</strong></li><li>人工种子：将植物离体培养中产生的胚状体(体胚)或者能发育成完整植株的分生组织(不定芽、小鳞茎、短枝、毛状根、愈伤组织等)包裹在有养分和具有保护功能的物质中形成的类似于天然植物种子的结构，并在适宜条件下发芽出苗的颗粒体。</li><li>人工种子的结构：最外面一层是<strong>人工种皮</strong>，中间是<strong>人工胚乳</strong>，种子内面则是被包埋的<strong>胚状体</strong>或类似物</li><li>人工种子的包埋技术最佳的凝胶包埋材料是<strong>藻酸盐</strong>，包埋方法有滴注法和装模法。（课本P67）</li><li>单倍体（Haploid）：指具有配子体（gametophyte）染色体数的个体或组织，即体细胞染色体数为n。 <strong>单倍体不等于一倍体</strong>。把只有一个染色体组的细胞或体细胞中只含有单个染色体组的个体称为一倍体。由合子发育来的个体，细胞中含有几个染色体组，就叫几倍体;而由配子直接发育来的,不管含有几个染色组，都只能叫单倍体，</li><li>单倍体植物与二倍体相比较，有三个明显的特点：体细胞染色体数<strong>减半</strong>；生长发育<strong>弱</strong>，体形<strong>小</strong>、各器官明显<strong>减小</strong>； 雌雄配子严重<strong>败育</strong>，有的甚至不能进入有性世代。</li><li>植物单倍体细胞培养方法：<strong>胚珠或子房培养（未受精）</strong>、<strong>花药培养</strong>、<strong>花粉培养</strong></li><li>花药培养：将发育到一定阶段的花药剥离下来(切去花丝部分)接种到培养基上进行培养，最终形成完整植株的过程。</li><li>花药培养的基本程序（详见有关程序）</li><li>花药培养材料的选择：花粉发育时期为<strong>单核早期到双核早期</strong></li><li>压片染色法：花药在接种以前，一般需先用<strong>醋酸洋红</strong>压片法进行镜检，以确定花粉的发育时期，并找出花粉发育与花蕾或幼穗大小、颜色等特征之间的相应关系。（第7章PPT25、课本P107）</li><li>花药培养材料的<strong>预处理</strong>是小孢子培养成功的前提条件。</li><li>影响花药培养效率的因素：<strong>供体植株的基因型</strong>；<strong>花粉发育时期</strong>；<strong>花药的生理状态</strong>；<strong>花蕾和花药的预处理</strong>；<strong>培养基的影响</strong></li><li>花粉培养的概念：是从花药中分离出来的花粉粒，使之成为分散的或游离的状态，通过培养使花粉粒脱分化，进而再分化并发育成完整植株的过程。</li><li>花药培养与花粉培养的异同</li><li>花粉的分离的3个方法：<strong>自然散落法</strong>、<strong>挤压法</strong>、<strong>机械游离</strong></li><li>单倍体育种：指将具有单套染色体的单倍体植物，经人工染色体加倍，使其成为纯合二倍体。从中选出具有优良性状的个体，直接繁育成新品种；或选出具有单一优良性状的个体，作为杂交育种的原理材料。</li><li>由完整的植物器官分离单细胞：<strong>叶片</strong>是分离单细胞的最好材料</li><li>植物单细胞的分离的方法：<strong>机械法</strong>、<strong>酶解法</strong></li><li>酶解法：指用专一的水解酶（<strong>纤维素酶</strong>、<strong>果胶酶</strong>、<strong>琼脂酶</strong>等）在温和条件下分解胞间层，分离细胞。</li><li>植物单细胞培养的方法：<strong>平板培养</strong>、<strong>看护培养</strong>、<strong>微室培养</strong>、<strong>纸桥培养</strong>、<strong>饲养层培养法</strong></li><li>悬浮细胞培养的同步化：①<strong>物理方法</strong>：体积选择法、低温休克法；②<strong>化学法</strong>：饥饿法；抑制法；不连续密度梯度离心法</li><li>生物反应器的类型：<strong>搅拌式反应器</strong>、<strong>气动式反应器</strong>、<strong>固定化反应器</strong></li><li>固定化细胞活力测定：①荧光染色观察法：根据<strong>活细胞</strong>对FDA（二乙酸荧光素）黄绿色荧光染料<strong>能被吸收</strong>，而<strong>死细胞无法吸收原理鉴定</strong>。②呼吸强度测定：用氧电极法测定固定化细胞的呼吸强度判断存活率。③细胞分解和生长速率的测定：通过测定细胞的湿重或干重增加率反映细胞活性大小。</li><li>在幼胚培养中，蔗糖是效果最好的碳源之一，同时又起<strong>调节渗透压</strong>的主要作用，这一点对幼胚尤其重要。（课本P58）</li><li>对于体细胞发生的同步化控制和纯化筛选的方法有化学抑制法、低温抑制法、渗透压选择法、机械过筛选择法、应用植物胚性细胞分级仪。（课本P67）</li><li>原生质体：除去植物细胞壁的裸露细胞，称为原生质体</li><li>原生质体的分离方法：机械分离法、酶解分离法（<strong>纤维素酶</strong>、<strong>半纤维素酶</strong>、<strong>果胶酶</strong>、<strong>果酸酶等</strong>）</li><li>原生质体的纯化方法：<strong>沉降法</strong>、<strong>漂浮法</strong>、<strong>界面法</strong></li><li>原生质体活力的测定：目测法：形态识别；<strong>荧光素双醋酸酯(FDA)染色法</strong>（FDA本身不发荧光，也不具有极性，能自由穿过细胞质膜。活细胞内FDA可以被酯酶分解，形成有荧光的极性物质（荧光素）。荧光素则不能自由穿越质膜，在完整的活细胞内积累。<strong>活细胞被染色</strong>）；染色法，酚藏花红染色法（0.01%）（无活力的原生质体染成红色，有活力的原生质体不着色。）、伊凡蓝(Evan’s blue)染色法（0.025%）（有活力但受损伤的细胞和死细胞能够摄取这种染料，活细胞不摄取，无色；无活力的细胞吸收染料为蓝色。）</li><li>细胞杂种的鉴定：①<strong>杂种植物形态特征、特性鉴定</strong>；②<strong>杂种植物的核型分析</strong>；③<strong>同工酶分析</strong>；④<strong>分子标记鉴定</strong>：RFLP、RAPD、SSR标记鉴定</li><li>无病毒苗：指不含该种植物的主要危害病毒，即经检测主要病毒在植物体内的存在表现阴性反应的苗木。</li><li>茎尖脱毒一般切取<strong>0.2~0.3mm</strong>，带1~2个叶原基的茎尖作为培养材料较好。</li><li>热处理去除病毒的原因：利用某些病毒受<strong>热以后的不稳定性</strong>，而使病毒钝化，失去活性。（课本P75）</li><li>去除植物病毒的方法有<strong>热处理法</strong>、<strong>微茎尖培养法</strong>、<strong>愈伤组织培养法</strong>和<strong>茎尖微体嫁接法</strong>等。</li><li>茎尖微体嫁接：木本植物茎尖培养难以生根成植株，将实生苗砧木在人工培养基上种植培育，再从成年无病树枝上切取0.4~1mm茎尖，在砧木上进行试管微体嫁接，以获得无病毒幼苗。</li><li>脱毒植物的鉴定方法：<strong>直接鉴定法</strong>、<strong>指示植物鉴定</strong>、<strong>抗血清反应鉴定</strong>、<strong>分子检测</strong>、<strong>电镜检测</strong></li><li>无病毒苗的保存繁殖：<strong>隔离保存</strong>、<strong>长期保存</strong></li><li>无毒苗的鉴定方法主要有：①<strong>指示植物鉴定法</strong>；②<strong>抗血清鉴定法</strong>；③<strong>电子显微镜检查法</strong>；④<strong>酶联免疫鉴定法</strong>。其中，最后一种是目前比较精确和常用的鉴定方法。多次监测，有延时性</li><li>体细胞无性系：由任何形式的细胞培养所产生的植株统称为<strong>体细胞无性系</strong>（somaclones）。</li><li>在培养阶段发生变异，进而导致再生植株亦发生遗传改变的现象，称为<strong>体细胞无性系变异</strong>（somaclonal variation）。</li><li><strong>嵌合性</strong>是指同一有机体中同时存在有遗传组成不同的细胞，它是组织培养中常见的现象。</li><li>影响体细胞遗传与变异的因素：<strong>培养基和培养方式</strong>、<strong>继代培养的次数</strong></li><li>体细胞变异的细胞遗传学基础：<strong>染色体数量和结构的改变</strong></li><li>染色体结构变异是体细胞变异的另一重要类型。染色体断裂与重组是离体培养中染色体结构变异的主要原因之一，也是体细胞变异中经常发生的现象，其细胞学特征是<strong>分裂中期出现断裂的染色体片段、落后染色体以及染色体桥</strong>，其结果是在体细胞中出现染色体易位、缺失、倒位等多种类型的结构变异。</li><li>种质：是亲代通过生殖细胞或体细胞传递给子代的遗传物质。</li><li>植物种质资源：即为携带各种不同遗传物质的植物总称，又称遗传资源或品种资源，包括栽培，野生及人工创造的各种植物的品种或品系。</li><li>种质资源保存：是指在天然或人工创造的适宜环境条件下，贮存植物种质，使其保持生命力与遗传性的技术。</li><li>植物种质离体保存的方法：<strong>常温限制生长</strong>、<strong>低温保存</strong>、<strong>超低温保存</strong></li><li>低温保存：温度（非冰冻低温，一般为<strong>1~9℃</strong>）；超低温保存：<strong>-196℃</strong>的<strong>液氮</strong></li><li>超低温保存的原理：植物材料在超低温条件下，冰冻过程中避免了细胞内水分结冰，并且在解冻过程中防止细胞内水分次生结冰而达到植物材料保存目的。</li><li>冷冻防护剂：常见的防冻剂有二甲基亚砜（<strong>DMSO</strong>）、聚乙二醇（PEG）、甘油及多种糖类等，防止细胞冰冻或解冻时引起过度脱水而遭到破坏，保护细胞。</li><li>冷冻保护剂应具有以下特性：<strong>分子质量较小</strong>、<strong>易于与溶剂混合</strong>、<strong>快速渗入细胞</strong>；<strong>无毒或毒性小</strong>、<strong>易洗脱</strong>。常用的是DMSO。</li></ol><h2 id="重点知识点自测"><a class="header-anchor" href="#重点知识点自测"></a>重点知识点自测</h2><ol><li>培养基的成分： <psw>水</psw> 、 <psw>无机成分</psw> 、 <psw>有机成分</psw> 、 <psw>天然有机添加物质</psw> 、 <psw>植物生长调节物质</psw> 、 <psw>培养基的pH值</psw> 、 <psw>凝固剂--琼脂</psw> 、 <psw>活性炭</psw> 、 <psw>抗生素</psw> 。</li><li>无机成分中大量元素化合物指浓度 <psw>大于0.5mmol/L</psw> ，有 <psw>N、P、K、Ca、Mg、S</psw> 。</li><li>无机成分中微量元素化合物指浓度 <psw>小于0.5mmol/L</psw> ，有 <psw>B、Mn、Zn、Cu、Mo、Co、Cl、Fe</psw> 。</li><li>铁盐容易发生沉淀，需要 <psw>单独配制</psw> ，一般与 <psw>Na<sub>2</sub>EDTA</psw> 相互配</li><li>培养基中糖类的功能：碳源及维持培养基一定的 <psw>渗透压</psw> ，蔗糖是最好的碳源，葡萄糖和果糖次之。</li><li>培养基中氨基酸类的功能：蛋白质组成，优质有机 <psw>氮源</psw> ，促进细胞生长分化</li><li>生长素类、细胞分裂素类的作用、常用种类、强弱顺序</li><li>培养基的pH值：灭菌前pH值调控范围：pH= <psw>5.0\~6.0</psw> 。pH对培养基凝固的影响：高6.0会变 <psw>硬</psw> ，低于5.0凝固 <psw>效果不好</psw> 。pH调节剂：HCl、NaOH</li><li>凝固剂–琼脂,用量范围： <psw>0.4%\~1.0%</psw> ，影响琼脂凝固的因素：厂家的加工方式；灭菌的时间，温度，pH值；存放的时间</li><li>抗生素不耐高温，需单独 <psw>过滤</psw> 灭菌。作用：防止外植体内生菌造成的污染。</li><li>基本培养基较于完全培养基 <psw>不包括激素和天然有机附加物</psw> 。</li><li>高无机盐含量的培养基代表类型： <psw>MS培养基</psw> 、 <psw>ER培养基</psw> 。</li><li>硝酸钾含量较高的培养基代表类型： <psw>B5</psw> 、 <psw>N6</psw> 。</li><li>干热灭菌（如烘烤和灼烧）；湿热灭菌（如常压或高压蒸煮）；过滤灭菌（如空气过滤和液体过滤）</li><li>高温高压蒸气灭菌温度： <psw>121</psw> °C； <psw>1.1\~1.2</psw> kg/cm<sup>2</sup>，压力不要超过 <psw>0.15</psw> MP，维持 <psw>15-20</psw> 分钟即可关闭电源。</li><li>过滤灭菌：在高温高压下易分解的培养基和激素类</li><li>细胞全能性理论： <psw>植物每一个具有完整细胞核的体细胞，都含有植物体的全部遗传信息，在适当条件下，具有发育成完整植株的潜在能力</psw> 。</li><li>植物细胞全能性表现根据细胞类型不同从强到弱: <psw>营养生长中心</psw>  &gt;  <psw>形成层</psw>  &gt;  <psw>薄壁细胞</psw>  &gt;  <psw>厚壁细胞(木质化细胞)</psw>  &gt;  <psw>特化细胞(筛管、导管细胞)</psw> 。</li><li>植物细胞全能性表达的条件：① <psw>体细胞与完整植株分离，脱离完整植株的控制</psw> ；② <psw>创造理想的适于细胞生长和分化的环境（主要是激素的作用）</psw></li><li>细胞实现全能性的过程：通过 <psw>脱分化</psw> 和 <psw>再分化</psw> 两个阶段。</li><li><psw>液泡消失</psw> 和 <psw>叶绿体的转变</psw> 是脱分化的重要特征。</li><li>根据脱分化细胞过程中细胞结构发生变化的时空顺序，细胞的脱分化过程可分为3个阶段： <psw>启动阶段</psw> 、 <psw>演变阶段</psw> 和 <psw>脱分化终结期</psw> 。</li><li>脱分化的关键 <psw>植物激素</psw> 。</li><li>脱分化细胞特点： <psw>细胞质显著变浓，大液泡消失，核体积增加并逐渐移位至细胞中央，细胞器增加。</psw></li><li>愈伤组织的定义： <psw>在组织培养过程中，沿用了这一名称，实际上是指外植体在离体培养条件下，形成的一团没有分化、又能旺盛分裂的薄壁细胞团，是组织培养过程中经常出现的一种组织状态。</psw> 。</li><li>愈伤组织的产生原因：内因： <psw>内源激素，材料被切伤后分泌的伤源激素</psw> ；外因： <psw>外源生长调节剂，人为在培养基内加入激素。</psw> 。</li><li>从外植体脱分化形成典型的愈伤组织大致可分为三个时期： <psw>诱导期</psw> 、 <psw>分裂期</psw> 和 <psw>分化期</psw></li><li>两种愈伤组织间的转化关系：坚实型 <psw>升高生长素浓度</psw> 转化成松脆型，松脆型 <psw>降低或去除生长素</psw> 转化成松脆型</li><li>优良的愈伤组织通常具备以下4个特性：① <psw>高度的胚性或再分化能力</psw> 。② <psw>容易散碎，建立优良的悬浮系，并能分离出全能性原生质体</psw> 。③ <psw>旺盛的自我增殖能力</psw> 。④ <psw>经过长期继代保存而不丧失胚性，以便有可能对它们进行各种遗传操作</psw> 。</li><li>愈伤组织的形态发生：愈伤组织在适宜的培养条件下发生再分化，产生芽和根，或者形成胚状体，发育成苗或完整植株。</li><li>愈伤组织形态发生形成完整植株的途径： <psw>体细胞发生途径（胚状体）</psw> 、 <psw>器官发生途径（不定芽不定根）</psw> 。</li><li>器官发生的途径有两种： <psw>直接途径：不经愈伤组织阶段直接分化器官</psw> ； <psw>间接途径：经过愈伤组织阶段</psw> 。</li><li>愈伤组织通过不定芽方式再分化成完整植株的的方式主要有四种(器官发生再生植株的基本方式)：① <psw>愈伤组织仅有根或芽器官的分别形成，即无根的芽或无芽的根</psw> ；② <psw>先长芽，后长根，多数情况</psw> ；③ <psw>先长根，再从根的基部长芽。这种情况较难诱导芽的形成，尤其对于单子叶植物</psw> ；④ <psw>先在愈伤组织的邻近不同部位分别形成芽和根，然后两者结合起来形成一株植株</psw> 。</li><li>影响器官分化的因素（要点，详见影响因素）</li><li>体细胞胚又叫胚状体（embryoid）：指在组织培养中，由一个非合子细胞(体细胞)，经胚胎发生和胚胎发育过程（经过 <psw>原胚</psw> 、 <psw>球形胚</psw> 、 <psw>心形胚</psw> 、 <psw>鱼雷胚</psw> 和 <psw>子叶</psw> 胚5个时期），形成具有双极性的胚状结构。</li><li>体细胞胚发生的途径： <psw>直接形成胚胎指在外植体上直接分化出胚状体，大多数外植体为子叶和下轴胚最易诱导体细胞胚发生</psw> 。 <psw>间接形成胚胎是指在外植体上先分化出胚性愈伤组织，然后由胚性愈伤组织再分化形成胚状体</psw> 。</li><li>体细胞胚发生途径的特点:① <psw>胚状体具有明显的两极性，即有茎端和根端；存在生理隔离，即体细胞胚和外植体的维管束系统无直接联系，胚状体与周围组织间形成缝隙，处于较独立的状态</psw> 。② <psw>遗传的稳定性</psw> 。③ <psw>发生数量大，增殖率高</psw> 。</li><li>影响体细胞胚胎发生的因素（重点，详见影响因素）</li><li>胚培养： <psw>是将胚从胚珠或种子中取出，置于适宜的培养基生长；包括未成熟胚(原胚)和成熟胚两种类型的离体培养。</psw></li><li>胚发育可分为 <psw>异养</psw> 和 <psw>自养</psw> 两个阶段。</li><li>胚培养的意义</li><li>依据所剥离胚的发育时期不同：分为两种培养类型 <psw>幼胚培养</psw> （子叶形成前）和 <psw>成熟胚培养</psw> （子叶形成后）</li><li>幼胚培养： <psw>是指处于原胚期、球形期、心形期、鱼雷期的胚培养</psw> ；幼胚基本是 <psw>异养的</psw> ，离体条件下培养要求培养基成分复杂，培养不易成功。</li><li>幼胚的分离及培养： <psw>幼胚剥离</psw> 是关键。</li><li>影响幼胚培养成功的因素（要点，详见影响因素）</li><li>胚乳培养（Endosperm culture）： <psw>是指将胚乳组织从母体上分离出来，通过离体培养，使其发育成完整植株的技术。</psw></li><li>胚乳离体培养的意义</li><li><psw>带胚</psw> 培养胚乳组织容易成功， <psw>不带胚</psw> 培养胚乳组织成功率低</li><li>根据细胞分化特点，胚乳发育可分为以下3类： <psw>核型胚乳</psw> 、 <psw>细胞型胚乳</psw> 、 <psw>沼生目型胚乳</psw></li><li>胚乳培养的关键技术，胚乳发育时期中 <psw>游离核型期</psw> 难以培养， <psw>细胞型期</psw> 易培养成功</li><li>离体授粉： <psw>指将未授粉的胚珠或子房从母体上分离下来，进行无菌培养，并以一定的方式授以无菌花粉，使之在试管内实现受精的技术。</psw></li><li>离体授粉的类型： <psw>离体胎座（胚珠）授粉</psw> 、 <psw>离体子房授粉</psw> 、 <psw>离体柱头（雌蕊）授粉</psw></li><li>离体子房授粉的方法： <psw>直接引入法</psw> 、 <psw>注射法</psw></li><li>离体授粉的目的： <psw>克服受精前障碍</psw></li><li>人工种子： <psw>将植物离体培养中产生的胚状体(体胚)或者能发育成完整植株的分生组织(不定芽、小鳞茎、短枝、毛状根、愈伤组织等)包裹在有养分和具有保护功能的物质中形成的类似于天然植物种子的结构，并在适宜条件下发芽出苗的颗粒体。</psw></li><li>人工种子的结构：最外面一层是 <psw>人工种皮</psw> ，中间是 <psw>人工胚乳</psw> ，种子内面则是被包埋的 <psw>胚状体</psw> 或类似物</li><li>人工种子的包埋技术最佳的凝胶包埋材料是 <psw>藻酸盐</psw> ，包埋方法有 <psw>滴注法</psw> 和 <psw>装模法</psw> 。（课本P67）</li><li>单倍体（Haploid）： <psw>指具有配子体（gametophyte）染色体数的个体或组织，即体细胞染色体数为n。 单倍体不等于一倍体</psw> 。把只有一个染色体组的细胞或体细胞中只含有单个染色体组的个体称为一倍体。由合子发育来的个体，细胞中含有几个染色体组，就叫几倍体;而由配子直接发育来的,不管含有几个染色组，都只能叫单倍体，</li><li>单倍体植物与二倍体相比较，有三个明显的特点：体细胞染色体数 <psw>减半</psw> ；生长发育 <psw>弱</psw> ，体形 <psw>小</psw> 、各器官明显 <psw>减小</psw> ； 雌雄配子严重 <psw>败育</psw> ，有的甚至不能进入有性世代。</li><li>植物单倍体细胞培养方法: <psw>胚珠或子房培养（未受精）</psw> 、 <psw>花药培养</psw> 、 <psw>花粉培养</psw></li><li>花药培养： <psw>将发育到一定阶段的花药剥离下来(切去花丝部分)接种到培养基上进行培养，最终形成完整植株的过程。</psw></li><li>花药培养的基本程序（详见有关程序）</li><li>花药培养材料的选择：花粉发育时期为 <psw>单核早期到双核早期</psw></li><li>压片染色法：花药在接种以前，一般需先用 <psw>醋酸洋红</psw> 压片法进行镜检，以确定花粉的发育时期，并找出花粉发育与花蕾或幼穗大小、颜色等特征之间的相应关系。（第7章PPT25、课本P107）</li><li>花药培养材料的 <psw>预处理</psw> 是小孢子培养成功的前提条件。</li><li>影响花药培养效率的因素： <psw>供体植株的基因型</psw> ； <psw>花粉发育时期</psw> ； <psw>花药的生理状态</psw> ； <psw>花蕾和花药的预处理</psw> ； <psw>培养基的影响</psw></li><li>花粉培养的概念： <psw>是从花药中分离出来的花粉粒，使之成为分散的或游离的状态，通过培养使花粉粒脱分化，进而再分化并发育成完整植株的过程。</psw></li><li>花药培养与花粉培养的异同</li><li>花粉的分离的3个方法： <psw>自然散落法</psw> 、 <psw>挤压法</psw> 、 <psw>机械游离</psw></li><li>单倍体育种： <psw>指将具有单套染色体的单倍体植物，经人工染色体加倍，使其成为纯合二倍体。从中选出具有优良性状的个体，直接繁育成新品种；或选出具有单一优良性状的个体，作为杂交育种的原理材料。</psw></li><li>由完整的植物器官分离单细胞： <psw>叶片</psw> 是分离单细胞的最好材料</li><li>植物单细胞的分离的方法： <psw>机械法</psw> 、 <psw>酶解法</psw></li><li>酶解法：指用专一的水解酶（<psw>纤维素酶</psw> 、 <psw>果胶酶</psw> 、 <psw>琼脂酶</psw> 等）在温和条件下分解胞间层，分离细胞。</li><li>植物单细胞培养的方法： <psw>平板培养</psw> 、 <psw>看护培养</psw> 、 <psw>微室培养</psw> 、 <psw>纸桥培养</psw> 、 <psw>饲养层培养法</psw></li><li>悬浮细胞培养的同步化：① <psw>物理方法：体积选择法、低温休克法</psw> ；② <psw>化学法：饥饿法；抑制法；不连续密度梯度离心法</psw></li><li>生物反应器的类型： <psw>搅拌式反应器</psw> 、 <psw>气动式反应器</psw> 、 <psw>固定化反应器</psw></li><li>固定化细胞活力测定：① <psw>荧光染色观察法：根据活细胞对FDA（二乙酸荧光素）黄绿色荧光染料能被吸收，而死细胞无法吸收原理鉴定。</psw> ② <psw>呼吸强度测定：用氧电极法测定固定化细胞的呼吸强度判断存活率。③细胞分解和生长速率的测定：通过测定细胞的湿重或干重增加率反映细胞活性大小。</psw></li><li>在幼胚培养中，蔗糖是效果最好的碳源之一，同时又起 <psw>调节渗透压</psw> 的主要作用，这一点对幼胚尤其重要。（课本P58）</li><li>对于体细胞发生的同步化控制和纯化筛选的方法有 <psw>化学抑制法</psw> 、 <psw>低温抑制法</psw> 、 <psw>渗透压选择法</psw> 、 <psw>机械过筛选择法</psw> 、 <psw>应用植物胚性细胞分级仪</psw> 。（课本P67）</li><li>原生质体： <psw>除去植物细胞壁的裸露细胞，称为原生质体</psw></li><li>原生质体的分离方法： <psw>机械分离法</psw> 、 <psw>酶解分离法</psw> （ <psw>纤维素</psw> 酶、 <psw>半纤维素</psw> 酶、 <psw>果胶</psw> 酶、 <psw>果酸</psw> 酶等）</li><li>原生质体的纯化方法： <psw>沉降法</psw> 、 <psw>漂浮法</psw> 、 <psw>界面法</psw></li><li>原生质体活力的测定： <psw>目测</psw> 法：形态识别； <psw>荧光素双醋酸酯(FDA)染色</psw> 法（FDA本身不发荧光，也不具有极性，能自由穿过细胞质膜。活细胞内FDA可以被酯酶分解，形成有荧光的极性物质（荧光素）。荧光素则不能自由穿越质膜，在完整的活细胞内积累。活细胞被染色）； <psw>染色</psw> 法，酚藏花红染色法（0.01%)、伊凡蓝(Evan’s blue)染色法(0.025%)</li><li>细胞杂种的鉴定：① <psw>杂种植物形态特征、特性鉴定</psw> ；② <psw>杂种植物的核型分析</psw> ；③ <psw>同工酶分析</psw> ；④ <psw>分子标记鉴定：RFLP、RAPD、SSR标记鉴定</psw></li><li>无病毒苗： <psw>指不含该种植物的主要危害病毒，即经检测主要病毒在植物体内的存在表现阴性反应的苗木。</psw></li><li>茎尖脱毒一般切取 <psw>0.2\~0.3mm</psw> ，带1~2个叶原基的茎尖作为培养材料较好。</li><li>热处理去除病毒的原因：利用某些病毒受 <psw>热以后的不稳定性</psw> ，而使病毒钝化，失去活性。（课本P75）</li><li>去除植物病毒的方法有 <psw>热处理法</psw> 、 <psw>微茎尖培养法</psw> 、 <psw>愈伤组织培养法</psw> 和 <psw>茎尖微体嫁接法</psw> 等。</li><li>茎尖微体嫁接： <psw>木本植物茎尖培养难以生根成植株，将实生苗砧木在人工培养基上种植培育，再从成年无病树枝上切取0.4\~1mm茎尖，在砧木上进行试管微体嫁接，以获得无病毒幼苗。</psw></li><li>脱毒植物的鉴定方法： <psw>直接鉴定法</psw> 、 <psw>指示植物鉴定</psw> 、 <psw>抗血清反应鉴定</psw> 、 <psw>分子检测</psw> 、 <psw>电镜检测</psw></li><li>无病毒苗的保存繁殖： <psw>隔离保存</psw> 、 <psw>长期保存</psw></li><li>无毒苗的鉴定方法主要有：① <psw>指示植物鉴定法</psw> ；② <psw>抗血清鉴定法</psw> ；③ <psw>电子显微镜检查法</psw> ；④ <psw>酶联免疫鉴定法</psw> 。其中，最后一种是目前比较精确和常用的鉴定方法。</li><li>体细胞无性系： <psw>由任何形式的细胞培养所产生的植株统称为体细胞无性系（somaclones）。</psw></li><li><psw>在培养阶段发生变异，进而导致再生植株亦发生遗传改变的现象</psw> ，称为体细胞无性系变异（somaclonal variation）。</li><li>嵌合性是指 <psw>同一有机体中同时存在有遗传组成不同的细胞，它是组织培养中常见的现象。</psw></li><li>影响体细胞遗传与变异的因素： <psw>培养基和培养方式</psw> 、 <psw>继代培养的次数</psw></li><li>体细胞变异的细胞遗传学基础： <psw>染色体数量和结构的改变</psw></li><li>染色体结构变异是体细胞变异的另一重要类型。染色体断裂与重组是离体培养中染色体结构变异的主要原因之一，也是体细胞变异中经常发生的现象，其细胞学特征是 <psw>分裂中期出现断裂的染色体片段</psw> 、落后染色体以及染色体桥，其结果是在体细胞中出现染色体易位、缺失、倒位等多种类型的结构变异。</li><li>种质：是 <psw>亲代通过生殖细胞或体细胞传递给子代的遗传物质。</psw> 。</li><li>植物种质资源：即为 <psw>携带各种不同遗传物质的植物总称，又称遗传资源或品种资源，包括栽培，野生及人工创造的各种植物的品种或品系。</psw></li><li>种质资源保存：是指 <psw>在天然或人工创造的适宜环境条件下，贮存植物种质，使其保持生命力与遗传性的技术。</psw></li><li>植物种质离体保存的方法： <psw>常温限制生长</psw> 、 <psw>低温保存</psw> 、 <psw>超低温保存</psw></li><li>低温保存：温度（ <psw>非冰冻低温，一般为1-9℃</psw> ）；超低温保存： <psw>-196℃的液氮</psw></li><li>超低温保存的原理： <psw>植物材料在超低温条件下，冰冻过程中避免了细胞内水分结冰，并且在解冻过程中防止细胞内水分次生结冰而达到植物材料保存目的。</psw></li><li>冷冻防护剂：常见的防冻剂有 <psw>二甲基亚砜（DMSO）</psw> 、 <psw>聚乙二醇（PEG）</psw> 、 <psw>甘油及多种糖类</psw> 等，防止细胞冰冻或解冻时引起过度脱水而遭到破坏，保护细胞。</li><li>冷冻保护剂应具有以下特性： <psw>分子质量较小</psw> 、 <psw>易于与溶剂混合</psw> 、 <psw>快速渗入细胞</psw> ； <psw>无毒或毒性小</psw> 、 <psw>易洗脱</psw> 。常用的是 <psw>DMSO</psw> 。</li></ol><h2 id="有关名词整理"><a class="header-anchor" href="#有关名词整理"></a>有关名词整理</h2><h3 id="第1章-组培绪论"><a class="header-anchor" href="#第1章-组培绪论"></a>第1章 组培绪论</h3><ol><li><strong>植物组织培养</strong>：指在无菌条件下，将离体的植物器官、组织、细胞或原生质体，培养在人工配制的培养基上，人为控制培养条件，使其生长、分化、增殖，发育成完整植株或生产次生代谢物质的过程和技术。狭义指由植物组织或器官培养产生愈伤组织，经过再分化进而培养成完整植株。广义指人工培养植物体一部分(即外植体) 生成完整植株。⭐</li><li><strong>愈伤组织</strong>：原本是指植物在受伤后与其伤口表面形成的一团薄壁细胞。在植物细胞组织培养中，愈伤组织则指在人工培养基上由外植体长出来的一团无序生长的薄壁细胞。特征：细胞排列疏松而无规则，是一种高度液泡化的呈无定形状态的薄壁细胞。 ⭐</li><li><strong>外植体</strong>：从植物体分离并用于离体培养的材料。⭐</li><li><strong>植株培养</strong>：对具有完整植株形态的幼苗或较大植株进行离体培养的方法</li><li><strong>器官培养</strong>：即离体器官的培养。根据作物和需要的不同，可以包括分离的茎尖﹑茎段﹑根尖﹑叶片﹑叶原基﹑子叶﹑花瓣﹑雄蕊﹑雌蕊﹑胚珠﹑胚﹑子房﹑果实等外植体的培养。</li><li><strong>组织培养</strong>：是对植物体的各部分组织进行培养，如茎尖分生组织﹑形成层﹑木质部﹑韧皮部﹑表皮组织﹑胚乳组织和薄壁组织等等；或对由植物器官培养产生的愈伤组织进行培养，二者均通过在分化诱导形成植株。</li><li><strong>胚胎培养</strong>：对植物的胚及胚器官进行人工离体的无菌培养，使其发育成幼苗的技术</li><li><strong>细胞培养</strong>：对植物的单个细胞或较小的细胞团进行离体培养的方法。常用的细胞培养材料有性细胞，叶肉细胞，根尖细胞等。</li><li><strong>细胞看护培养</strong>：用一块活跃生长的愈伤组织块来看护单个细胞，并使其生长和增殖的方法。</li><li><strong>细胞平板培养</strong>：把单个细胞与融化的琼脂培养基均匀混合，并平铺一薄层在培养皿底上的培养方法。</li><li><strong>原生质体培养</strong>：是用酶及物理方法除去细胞壁的原生质体的培养</li><li><strong>初代/诱导培养</strong>：芽、茎段、叶片、花器等外植体在离体培养条件下诱导愈伤组织、侧芽或不定芽、胚状体过程。</li><li><strong>继代培养/增殖培养</strong>：更换新鲜培养基来繁殖同种类型的材料（愈伤组织、芽）。</li><li><strong>生根培养</strong>：将芽苗转接到生根培养基上培养成为完整植株的过程。</li><li><strong>驯化移栽</strong>： 组培苗经人工炼苗后移栽到驯化苗床上使之适应露地或保护地条件的过程。</li><li><strong>人工种子</strong>：指植物离体培养中产生的胚状体或不定芽，被包裹在含有养分和保护功能的人工胚乳和种皮中，从而形成能发芽出苗颗粒体。</li><li><strong>工厂化育苗</strong>：指以植物培养基为基础，将外植体接种在人工配制的培养基上，通过控制环境条件，使细胞脱分化﹑再分化成新的组织﹑器官，进而培育出与母株一样的批量幼苗的方法。</li><li><strong>植物激素</strong>：是指植物体内合成的，对生长发育有显著调节作用的微量小分子有机物，它们在某些组织中产生，既可以在产生它的组织中，也可运输到其它组织中发挥作用</li><li><strong>植物生长调节剂</strong>：人工合成的具有植物激素活性的物质称为植物生长调节剂</li></ol><h3 id="第2章-组培基本技术"><a class="header-anchor" href="#第2章-组培基本技术"></a>第2章 组培基本技术</h3><ol><li><strong>基本培养基</strong>：指只含有维持离体植物细胞基本生命活动所需的营养成分的培养基。通常包括水分、无机营养成分和有机营养成分，<strong>不包括激素和天然有机附加物</strong>。</li><li><strong>完全培养基</strong>：指在基本培养基的基础上另外附加激素或天然有机附加物所组成的培养基。</li><li><strong>继代培养</strong>：培养物在培养基上生长一段时间以后，由于营养物质枯竭，水分散失，以及代谢产物的积累，必须转移到新鲜培养基上培养。⭐</li><li><strong>外植体</strong>：从植物体分离并用于离体培养的材料。⭐</li><li><strong>愈伤组织培养</strong>：外植体接种到人工培养基上，在激素作用下，进行愈伤组织诱导、生长和分化的培养过程。</li><li><strong>外植体褐变</strong>：是指在接种后，其表面开始褐变，有时甚至会使整个培养基褐变的现象。</li><li><strong>玻璃化现象</strong>：植物组织培养中，常会出现一些半透明状的畸形试管植物，培养物的嫩茎、叶片往往会呈半透明水渍状, 这类植物体被称为“玻璃苗”，这种现象称为玻璃化现象，又称过度水化现象。</li></ol><h3 id="第3章-组培基本理论"><a class="header-anchor" href="#第3章-组培基本理论"></a>第3章 组培基本理论</h3><ol><li><strong>细胞全能性理论</strong>：植物每一个具有完整细胞核的体细胞，都含有植物体的全部遗传信息，在适当条件下，具有发育成完整植株的潜在能力。⭐</li><li><strong>分化</strong>：分化是指个体发育过程中，不同部位的细胞形态结构和生理功能发生改变，形成不同组织或器官。</li><li><strong>脱分化</strong>：已分化好的细胞在人工诱导条件下，恢复分生能力，回复到分生组织状态的过程。</li><li><strong>再分化</strong>：脱分化后具有分生能力的细胞再经过与原来相同的分化过程，重新形成各类组织和器官的过程。</li></ol><h3 id="第4章-植物组织器官形成"><a class="header-anchor" href="#第4章-植物组织器官形成"></a>第4章 植物组织器官形成</h3><ol><li><strong>体细胞胚(胚状体)</strong>：指在组织培养中，由一个非合子细胞(体细胞)，经胚胎发生和胚胎发育过程（经过原胚、球形胚、心形胚、鱼雷胚和子叶胚5个时期），形成具有双极性的胚状结构。⭐</li></ol><h3 id="第5章-植物胚胎培养"><a class="header-anchor" href="#第5章-植物胚胎培养"></a>第5章 植物胚胎培养</h3><ol><li><strong>植物胚胎培养</strong>：指对植物的胚、子房、胚珠和胚乳进行离体培养，使其发育成完整植物的技术。包括：胚培养、胚乳培养、胚珠培养、子房培养、离体受精。</li><li><strong>胚培养</strong>：是将胚从胚珠或种子中取出，置于适宜的培养基生长；包括未成熟胚(原胚)和成熟胚两种类型的离体培养。⭐</li><li><strong>成熟胚培养</strong>：指子叶期至发育成熟的胚培养。成熟胚是自养的，培养基需要简单。仅提供一定的温度、湿度就可以发芽生成植物体。如种子的发育。</li><li><strong>幼胚培养</strong>：是指处于原胚期、球形期、心形期、鱼雷期的胚培养；幼胚基本是异养的，离体条件下培养要求培养基成分复杂，培养不易成功。</li><li><strong>胚乳培养</strong> ：指处于细胞期胚乳的离体培养，获得三倍体⭐</li><li><strong>胚珠培养</strong> ：未受精，为试管受精提供雌配子体，受精后，从两个细胞的原胚开始至球形胚阶段。⭐</li><li><strong>子房培养</strong> ：亲缘关系较远的物种杂交可获得杂种。</li><li><strong>离体受精</strong> ：培养未受精胚珠并在试管内撒播花粉，使其受精形成具有生活力的种子。</li><li><strong>离体胚培养</strong>：是指从植物种子中分离出胚组织进行离体培养的技术</li></ol><h3 id="第7章-单倍体细胞培养"><a class="header-anchor" href="#第7章-单倍体细胞培养"></a>第7章 单倍体细胞培养</h3><ol><li><strong>花粉培养</strong>：是从花药中分离出来的花粉粒，使之成为分散的或游离的状态，通过培养使花粉粒脱分化，进而再分化并发育成完整植株的过程。⭐</li><li><strong>花药培养</strong>：将发育到一定阶段的花药剥离下来(切去花丝部分)接种到培养基上进行培养，最终形成完整植株的过程。⭐</li><li><strong>嵌合性</strong>：指的是遗传组成不同的细胞在个体中同时存在的现象。（课本P203）⭐</li><li><strong>单倍体</strong>：指具有配子体（gametophyte）染色体数的个体或组织，即体细胞染色体数为n。</li><li><strong>单倍体育种</strong>：指将具有单套染色体的单倍体植物，经人工染色体加倍，使其成为纯合二倍体。从中选出具有优良性状的个体，直接繁育成新品种；或选出具有单一优良性状的个体，作为杂交育种的原理材料。</li></ol><h3 id="第10章-植物脱毒技术"><a class="header-anchor" href="#第10章-植物脱毒技术"></a>第10章 植物脱毒技术</h3><ol><li><strong>无病毒苗</strong>：指<strong>不含</strong>该种植物的<strong>主要危害病毒</strong>，即经检测主要病毒在植物体内的存在表现阴性反应的苗木）。<strong>能相对保持物种遗传稳定性</strong>。⭐（PPT10）</li></ol><h3 id="第11章-植物体细胞无性系变异及种质离体保存"><a class="header-anchor" href="#第11章-植物体细胞无性系变异及种质离体保存"></a>第11章 植物体细胞无性系变异及种质离体保存</h3><ol><li><strong>体细胞无性系</strong>：由任何形式的细胞培养所产生的植株统称为体细胞无性系。⭐</li><li><strong>体细胞无性系变异</strong>：在培养阶段发生变异，进而导致再生植株亦发生遗传改变的现象。⭐</li><li><strong>种质</strong>：是亲代通过生殖细胞或体细胞传递给子代的遗传物质。</li><li><strong>植物种质资源</strong>：即为携带各种不同遗传物质的植物总称，又称遗传资源或品种资源，包括栽培，野生及人工创造的各种植物的品种或品系。</li><li><strong>种质资源保存</strong>：是指在天然或人工创造的适宜环境条件下，贮存植物种质，使其保持生命力与遗传性的技术。</li><li><strong>超低温保存</strong>：也叫冷冻保存，指在-196℃的液氮超低温下使细胞代谢和生长处于基本停止的状态，在适宜条件下可繁殖，再生出新的植株，并保持原来的遗传特性。</li></ol><hr><p><a href="https://halo123.top/2020/12/25/%E7%94%9F%E7%89%A9%E5%AD%A6/%E7%BB%84%E5%9F%B9%E8%B5%84%E6%96%99/">其他组培资料</a><br><a href="https://halo123.top/2020/12/25/%E7%94%9F%E7%89%A9%E5%AD%A6/%E7%BB%84%E5%9F%B9PPT/">组培PPT资料整理（未完成）</a></p>]]></content>
    
    
    <summary type="html">仅供参考</summary>
    
    
    
    <category term="生物学" scheme="http://halo123.top/categories/%E7%94%9F%E7%89%A9%E5%AD%A6/"/>
    
    
    <category term="植物组织培养" scheme="http://halo123.top/tags/%E6%A4%8D%E7%89%A9%E7%BB%84%E7%BB%87%E5%9F%B9%E5%85%BB/"/>
    
  </entry>
  
  <entry>
    <title>专业英语复习整理</title>
    <link href="http://halo123.top/2020/12/25/%E7%94%9F%E7%89%A9%E5%AD%A6/%E4%B8%93%E4%B8%9A%E8%8B%B1%E8%AF%AD%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86_v202101040129/"/>
    <id>http://halo123.top/2020/12/25/%E7%94%9F%E7%89%A9%E5%AD%A6/%E4%B8%93%E4%B8%9A%E8%8B%B1%E8%AF%AD%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86_v202101040129/</id>
    <published>2020-12-25T08:41:51.000Z</published>
    <updated>2021-04-24T11:38:33.224Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近一次同步时间:2021年1月4日01点30分<br>如文档内容有误，点击<a href="http://doc.halo123.top:3000/m06H0jw0QDC0327_Bn1xEw?both">该链接</a>对文档进行修改，定时会同步到网站上<br>文档采用Markdown格式排版，可以参考<a href="https://halo123.top/2019/05/08/Markdown%E8%AF%AD%E6%B3%95/">该网站</a>进行简单学习，感谢参与整理的同学们</p></blockquote><h2 id="第1章-Inside-the-Living-Cell-Structure-and-Function-of-Internal-Cell-Parts"><a class="header-anchor" href="#第1章-Inside-the-Living-Cell-Structure-and-Function-of-Internal-Cell-Parts"></a>第1章 Inside the Living Cell: Structure and Function of Internal Cell Parts</h2><ol><li><p>Cytoplasm: The Dynamic, Mobile Factory (细胞质：动力工厂)</p><p>Most of the properties we associate with life are properties of the cytoplasm.  Much of the mass of a cell consists of this semifluid substance, which is bounded on the outside by the plasma membrane.  Organelles are suspended within it, supported by the filamentous network of the cytoskeleton.  Dissolved in the cytoplasmic fluid are nutrients, ions, soluble proteins, and other materials needed for cell functioning.</p><blockquote><p>生命的大部分特征表现在细胞质的特征上。细胞质大部分由半流体物质组成，并由细胞膜（原生质膜）包被。细胞器悬浮在其中，并由丝状的细胞骨架支撑。细胞质中溶解了大量的营养物质，离子，可溶蛋白以及维持细胞生理需求的其它物质。</p></blockquote></li><li><p>The Nucleus: Information Central（细胞核：信息中心）</p><p>The eukaryotic cell nucleus is the largest organelle and houses the genetic material (DNA) on chromosomes. (In prokaryotes the hereditary material is found in the nucleoid.) The nucleus also contains one or two organelles-the nucleoli-that play a role in cell division.  A pore-perforated sac called the nuclear envelope separates the nucleus and its contents from the cytoplasm.  Small molecules can pass through the nuclear envelope, but larger molecules such as mRNA and ribosomes must enter and exit via the pores.</p><blockquote><p>真核细胞的细胞核是最大的细胞器，细胞核对染色体组有保护作用（原核细胞的遗传物质存在于拟核中）。细胞核含有一或二个核仁，核仁促进细胞分裂。核膜贯穿许多小孔，小分子可以自由通过核膜，而象mRNA和核糖体等大分子必须通过核孔运输。</p></blockquote></li><li><p>Organelles: Specialized Work Units（细胞器：特殊的功能单位）</p><p>All eukaryotic cells contain most of the various kinds of organelles, and each organelle performs a specialized function in the cell.  Organelles described in this section include ribosomes, the endoplasmic reticulum, the Golgi complex, vacuoles, lysosomes, mitochondria, and the plastids of plant cells.</p><blockquote><p>所有的真核细胞都含有多种细胞器，每个细胞器都有其特定功能。本节主要介绍核糖体，内质网，高尔基体系，液泡，溶酶体，线粒体和植物细胞中的质体。</p></blockquote><p>The number of ribosomes within a cell may range from a few hundred to many thousands.  This quantity reflects the fact that, ribosomes are the sites at which amino acids are assembled into proteins for export or for use in cell processes.  A complete ribosome is composed of one larger and one smaller subunit.  During protein synthesis the two subunits move along a strand of mRNA, “reading” the genetic sequence coded in it and translating that sequence into protein.  Several ribosomes may become attached to a single mRNA strand; such a combination is called a polysome.  Most cellular proteins are manufactured on ribosomes in the cytoplasm.  Exportable proteins and membrane proteins are usually made in association with the endoplasmic reticulum.</p><blockquote><p>核糖体的数量变化从几百到几千，核糖体是氨基酸组装成蛋白质的重要场所。完整的核糖体由大亚基和小亚基组成。核糖体沿着mRNA移动并阅读遗传密码，翻译成蛋白质。一条mRNA上可能有多个核糖体，称多聚核糖体。大多数细胞蛋白是由细胞质中核糖体生产。输出蛋白和膜蛋白通常与内质网有关。</p></blockquote><p>The endoplasmic reticulum, a lacy array of membranous sacs, tubules, and vesicles, may be either rough (RER) or smooth (SER).  Both types play roles in the synthesis and transport of proteins. The RER, which is studded with polysomes, also seems to be the source of the nuclear envelope after a cell divides. SER lacks polysomes; it is active in the synthesis of fats and steroids and in the oxidation of toxic substances in the cell.  Both types of endoplasmic reticulum serve as compartments within the cell where specific products can be isolated and subsequently shunted to particular areas in or outside the cell.</p><blockquote><p>内质网，带有花边的生物囊，有管状，泡状之分，以及光滑和粗糙面区别。两种都与蛋白质的合成和运输有关。粗糙内质网上分布许多核糖体，也可能提供细胞分裂后所需的细胞膜。光滑内质网上无核糖体，主要作用是脂肪和类固醇的合成以及细胞内有毒物质的氧化。两种内质网合成的产物在其中进行分流或运输到细胞外。</p></blockquote><p>Transport vesicles may carry exportable molecules from the endoplasmic reticulum to another membranous organelle, the Golgi complex.  Within the Golgi complex molecules are modified and packaged for export out of the cell or for delivery else where in the cytoplasm.</p><blockquote><p>运输小泡能够将可运输分子从内质网运输到高尔基复合体上。在高尔基复合体中修饰，包装后输出细胞或传递到细胞质中的其他场所。</p></blockquote><p>Vacuoles in cells appear to be hollow sacs but are actually filled with fluid and soluble molecules.  The most prominent vacuoles appear in plant cells and serve as water reservoirs and storage sites for sugars and other molecules.  Vacuoles in animal cells carry out phagocytosis (the intake of particulate matter) and pinocytosis (vacuolar drinking).</p><blockquote><p>细胞中的液泡好象是中空的，但实际上充满了液体和可溶分子。最典型的液泡存在于植物细胞中，储备水，糖以及其它分子。动物中的液泡起吞噬和胞饮作用。</p></blockquote><p>A subset of vacuoles are the organelles known as lysosomes, which contain digestive enzymes (packaged in lysosomes in the Golgi complex) that can break down most biological macromolecules.  They act to digest food particles and to degrade damaged cell parts.</p><blockquote><p>溶酶体是液泡亚单位，含有消化酶，降解大部分生物大分子。消化食物微粒和降解损伤的细胞残片。</p></blockquote><p>Mitochondria are the sites of energy-yielding chemical reactions in all cells.  In addition, plant cells contain plastids that utilize light energy to manufacture carbohydrates in the process of photosynthesis.  It is on the large surface area provided by the inner cristae of mitochondria that ATP-generating enzymes are located.  Mitochondria are self-replicating, and probably they are the evolutionary descendants of what were once free-living prokaryotes.</p><blockquote><p>线粒体是细胞中化学产能的场所。另外，植物细胞中的质体在光合作用中利用光能产生碳水化合物，线粒体内嵴上提供了很大的表面积并分布着产ATP酶。线粒体自我复制，并且可能是自由生活的原核生物在进化中形成的后代。</p></blockquote><p>There are two types of plastids: leucoplasts, which lack pigments and serve as storage sites for starch, proteins, and oils; and chromoplasts, which contain pigments.  The most important chromoplasts are chloroplasts-organelles that contain the chlorophyll used in photosynthesis.  The internal structure of chloroplasts includes stacks of membranes called grana, which are embedded in a matrix called the stroma.</p><blockquote><p>质体有两种类型：白色体，缺乏色素，是淀粉，蛋白质和油的储备场所；色质体，含有色素。叶绿体是最重要的色质体，含有与光合作用有关的叶绿素。叶绿体的内部结构是由多层膜形成的叶绿体基粒，其中包埋在基质中的基粒称子座。</p></blockquote></li><li><p>The Cytoskeleton（细胞骨架）</p><p>All eukaryotic cells have a cytoskeleton, which is a convoluted latticework of filaments and tubules that appears to fill all available space in the cell and provides support for various other organelles.  A large portion of the cytoskeleton consists of threadlike microfilaments composed mainly of the contractile protein actin.  They are involved in many types of intracellular movements in plant and animal cells.  A second protein, myosin, is involve in the contraction of muscle cells.  Another main structural component of the cytoskeleton consists of microtubules, which are composed of the globular protein tubulin and together act as scaffolding that provides a stable cell shape.  Cytoskeletal intermediate filaments appear to impart tensile strength to the cell cytoplasm.  Mechanoenzymes such as myosin, dynein, and kinesin interact with the cytoskeletal filaments and tubules to generate forces that cause movements.</p><blockquote><p>所有的细胞都有细胞骨架，网络结构的纤丝充满了它所能触及的全部空间并且对细胞器提供支持作用。细胞骨架大部分由微丝组成，微丝主要由可收缩的肌动蛋白组成。动植物细胞的许多种类型细胞内运动与肌动蛋白有关。第二类蛋白是肌球蛋白，它与肌肉细胞的收缩有关。细胞骨架的另一个主要结构成分是微管，由球状的微管蛋白组成，象脚手架一般维持细胞的稳定形态。细胞骨架的中间丝提供了细胞质伸缩动力。机械酶，例如，肌球蛋白，动力蛋白，驱动蛋白与微丝，微管相互作用产生动力而引起细胞运动。</p></blockquote></li><li><p>Cellular Movements（细胞运动）</p><p>Although the cytoskeleton provides some stability to cells, its microtubules and filaments and their associated proteins enable cells to move by creeping or gliding .  Such movements require a solid substrate to which the cell can adhere and can be guided by the geometry of the surface.  Some cells also exhibit chemotaxis, the ability to move toward or away from the source of a diffusing chemical.</p><blockquote><p>尽管细胞骨架提供了细胞的某些稳定性，微丝，微管及相关蛋白能使细胞爬行或滑动。这种运动需要固体基质依托并通过表面几何形状的改变而运动。某些细胞具备趋药性，即趋向或逃离扩散开的化学源。</p></blockquote><p>Certain eukaryotic cells can swim freely in liquid environments, propelled by whiplike cilia or flagella. Both cilia and flagella have the same internal structure: nine doublets (pairs of microtubules) are arranged in a ring and extend the length of the cilium or flagellum, and two more microtubules run down the center of the ring. Every cilium or flagellum grows only from the cell surface where a basal body is located. Movement is based on the activities of tiny dynein side arms that extend from one of the microtubules of each doublet.</p><blockquote><p>某些真核细胞能在液体液体中自由运动，由纤毛或鞭毛推动。纤毛和鞭毛具有同样的内部结构：九个双微管环形排列，纵向延伸，环中心是两个或以上微管组成。纤毛或鞭毛从细胞表面的基体出生长，双微管的动力蛋白臂从一侧延伸到另一侧而引起运动。</p></blockquote><p>Nutrients, proteins, and other materials within most plant cells are moved about via cytoplasmic streaming. The process occurs as myosin ˈmaiəusin肌凝蛋白 proteins attached to organelles 细胞器,小器官 push against microfilaments arrayed [əˈrei] 展示throughout the cell. Microfilaments and microtubules are responsible for almost all major cytoplasmic movements. During cell division, microtubules of the spindle assembled 集合, 收集 from tubutin subunits near organelles called centrioles move the chromosomes.</p><blockquote><p>大部分植物细胞的营养，蛋白质和其它物质由细胞质流运输。这个过程是由于依附在细胞器上的肌球蛋白反推排列在细胞周围的微丝形成的。绝大部分细胞质运动由微丝和微管完成。在细胞分裂期间，中心粒周围的由微管蛋白亚基装配形成的纺锤体微管移向染色体。</p></blockquote></li></ol><h2 id="第二章-Photosynthesis"><a class="header-anchor" href="#第二章-Photosynthesis"></a>第二章 Photosynthesis</h2><p>Photosynthesis occurs only in the chlorophyllchlorophyll叶绿素-containing cells of green plants, algae藻, and certain protists原生生物and bacteria.  Overall, it is a process that converts light energy into chemical energy that is stored in the molecular bonds.  From the point of view of chemistry and energetics, it is the opposite of cellular respiration.  Whereas 然而 cellular细胞的 respiration 呼吸is highly exergonic吸收能量的 and releases energy, photosynthesis光合作用 requires energy and is highly endergonic.</p><blockquote><p>光合作用只发生在含有叶绿素的绿色植物细胞，海藻，某些原生动物和细菌之中。总体来说，这是一个将光能转化成化学能，并将能量贮存在分子键中，从化学和动能学角度来看，它是细胞呼吸作用的对立面。细胞呼吸作用是高度放能的，光合作用是需要能量并高吸能的过程。</p></blockquote><p>Photosynthesis starts with CO2 and H2O as raw materials and proceeds through two sets of partial reactions.  In the first set, called the light-dependent reactions, water molecules are split裂开 (oxidized), 02 is released, and ATP and NADPH are formed.  These reactions must take place in the presence of 在面前 light energy.  In the second set, called light-independent reactions, CO2 is reduced (via the addition of H atoms) to carbohydrate.  These chemical events rely on the electron carrier NADPH and ATP generated by the first set of reactions.</p><blockquote><p>光合作用以二氧化碳和水为原材料并经历两步化学反应。第一步，称光反应，水分子分解，氧分子释放，ATP和NADPH形成。此反应需要光能的存在。第二步，称暗反应，二氧化碳被还原成碳水化合物，这步反应依赖电子载体NADPH以及第一步反应产生的ATP。</p></blockquote><p>Both sets of reactions take place in chloroplasts.  Most of the enzymes and pigments 色素for the lightdependent reactions are embedded 深入的内含的in the thylakoid类囊体 membrane膜隔膜 of chloroplasts 叶绿体.  The dark reactions take place in the stroma.基质</p><blockquote><p>两步反应都发生在叶绿体中。光反应需要的大部分酶和色素包埋在叶绿体的类囊体膜上。暗反应发生在基质中。</p></blockquote><ol><li><p>How Light Energy Reaches Photosynthetic Cells（光合细胞如何吸收光能的）</p><p>The energy in light photons in the visible part of the spectrum can be captured by biological molecules to do constructive work.  The pigment chlorophyll in plant cells absorbs photons within a particular absorption spectrums statement of the amount of light absorbed by chlorophyll at different wavelengths.  When light is absorbed it alters the arrangement of electrons in the absorbing molecule.  The added energy of the photon boosts the energy condition of the molecule from a stable state to a less-stable excited state.  During the light-dependent reactions of photosynthesis, as the absorbing molecule returns to the ground state, the “excess” excitation energy is transmitted to other molecules and stored as chemical energy.</p><blockquote><p>生物分子能捕获可见光谱中的光能。植物细胞中叶绿素在不同光波下吸收部分吸收光谱。在吸收分子中，光的作用使分子中的电子发生重排。光子的能量激活了分子的能量状态，使其从稳定态进入不稳定的激活态。</p></blockquote><p>All photosynthetic organisms contain various classes of chlorophylls and one or more carotenoid (accessory) pigments that also contribute to photosynthesis.  Groups of pigment molecules called antenna complexes are present on thylakoids.  Light striking any one of the pigment molecules is funneled to a special chlorophyll a molecule, termed a reaction-center chlorophyll, which directly participates in photosynthesis.  Most photosynthetic organisms possess two types of reaction-center chlorophylls, P680 and P700, each associated with an electron acceptor molecule and an electron donor.  These aggregations are known respectively as photosystem Ⅰ (P700) and photosystem Ⅱ (P680).</p><blockquote><p>所有的光合作用生物含有不同等级的叶绿素和一个或多个类胡萝卜素（光合作用的辅助色素）。称作天线复合体的色素分子群存在于类囊体中。激活色素分子的光能进入叶绿素反应中心，其直接参与光合作用。大部分光反应细胞器拥有两套反应中心，P680和P700，每个光系统都含有一个电子受体和电子供体。这些集合体就是大家熟识的光合系统Ⅰ和光合系统Ⅱ。</p></blockquote></li><li><p>The Light-Dependent Reaction: Converting Solar Energy into Chemical-Bond Energy（光反应：光能转化成化学键能）</p><p>The photosystems of the light-dependent reactions are responsible for the packaging of light energy in the chemical compounds ATP and NADPH.  This packaging takes place through a series of oxidation reduction reactions set in motion when light strikes the P680 reaction center in photosystem Ⅱ.  In this initial event water molecules are cleaved, oxygen is released, and electrons are donated.  These electrons are accepted first by plastoquinone and then by a series of carriers as they descend an electron transport chain.  For each four electrons that pass down the chain, two ATPs are formed. The last acceptor in the chain is the P700 reaction center of photosystem Ⅰ. At this point incoming photons boost the energy of the electrons, and they are accepted by ferredoxin.  Ferredoxin is then reoxidized, and the coenzyme NADP+ is reduced to the NADPH.  The ATP generated previously and the NADPH then take part in the light independent reactions.</p><blockquote><p>光反应的光系统将光能转化成化学复合物ATP和NADPH。当光激活光系统Ⅱ的光反应中心时，通过一系列的氧化还原反应实现能量的传递。反应开始时，水被分解，氧被释放并提供电子。电子首先传递给质体醌，然后通过一系列载体形成的电子传递链。每传递4个电子，形成2个ATP。最后一个受体存在于光反应系统Ⅰ的反应中心里。此处光子激活电子，电子传递给铁氧还蛋白。铁氧还蛋白再氧化，并且辅酶NADP+还原成NADPH。早期产生的ATP和NADPH进入暗反应。</p></blockquote><p>The production of ATP from the transport of electrons excited by light energy down an electron transport chain is termed photophosphorylation.  The one-way flow of electrons through photosystems II and I is called noncyclic photophosphorylation; plants also derive additional ATP through cyclic photophosphorylation, in which some electrons are shunted back through the electron transport chain between photosystems Ⅱ and Ⅰ.</p><blockquote><p>由电子传递链偶连产生ATP的过程称为光合磷酸化。通过光合系统Ⅱ流经光合系统Ⅰ的电子路径称非循环式光合磷酸化；植物通过循环式光合磷酸化获得额外的ATP，一些电子在光合系统Ⅰ和Ⅱ之间的电子传递链中回流。</p></blockquote></li><li><p>The Light-Independent Reactions: Building Carbohydrates（暗反应：碳水化合物的形成）</p><p>In the light-independent reactions of photosynthesis, which are driven by ATP and NADPH, C02 is converted to carbohydrate.  The reactions are also known as the Calvin-Benson cycle.  Atmospheric CO2, is fixed as it reacts with ribulosebiphosphate (RuBP), a reaction that is catalyzed by the enzyme ribulosebiphosphate carboxylase. The reduction Of C02 to carbohydrate (fructose diphosphate) is completed via several more steps of the cycle.  Finally, RUBP is regenerated so that the cycle may continue.</p><blockquote><p>由ATP和NADPH驱动的暗反应中，二氧化碳转化成碳水化合物。即卡尔文循环。二磷酸核酮糖固定二氧化碳，由二磷酸核酮糖羧化酶催化。</p></blockquote></li><li><p>Oxygen: An Inhibitor of photosynthesis（氧：光合作用的抑制因子）</p><p>High levels of oxygen in plant cells can disrupt photosynthesis and can also cause photorespiration-an inefficient fun of the dark reactions in which O<sub>2</sub> is fixed rather than CO<sub>2</sub> and no carbohydrate is produced.</p><blockquote><p>植物细胞中高浓度的氧会扰乱光合作用，并导致光呼吸——暗反应的无效形式，在反应中消耗的是O<sub>2</sub>，而不是CO<sub>2</sub>，且没有有机物产生。</p></blockquote></li><li><p>Reprieve from Photorespiration: The C4 Pathway（避开光呼吸：C4循环途径）<br>Most plants are C3 plants; they experience decreased carbohydrate production under hot, dry conditions as a result of the effects of photorespiration.  Among C4 plants, however, special leaf anatomy and a unique biochemical pathway enable the plant to thrive in and conditions.  Thus C4 plants lessen photorespiration by carrying out photosynthesis only in cells that are insulated from high levels of CO2.  They also possess a novel mechanism for carbon fixation.</p><blockquote><p>大部分植物是碳3植物，在高温干旱条件下，由于光呼吸作用而使碳水化合物的合成降低。而在大多数的碳4植物中，由于叶脉的特殊构造和独特的化学路径使植物依然很茂盛。这是碳固定的一个新机制。</p></blockquote></li></ol><h2 id="第三章-Cellular-Reproduction-Mitosis-and-Meiosis"><a class="header-anchor" href="#第三章-Cellular-Reproduction-Mitosis-and-Meiosis"></a>第三章 Cellular Reproduction:  Mitosis and Meiosis</h2><ol><li><p>The Nucleus and Chromosomes（细胞核和染色体）<br>The cell nucleus is the main repository of genetic information.  Within the nucleus are the chromosomes tightly coiled strands of DNA and clusters of associated proteins.  Long stretches of the continuous DNA molecule wind around these clusters of proteins, or histones, forming beadlike complexes known as nucleosomes. More coiling and supercoiling produces a dense chromosome structure. Each long strand of DNA combines with histones and nonhistone proteins to make up the substance chromatin.</p><blockquote><p>细胞核是贮藏遗传信息的主要场所。DNA盘绕成螺旋线以及相关的成簇蛋白质。DNA螺旋线缠绕成簇的组蛋白形成珠链状的核小体。这些螺旋和超螺旋形成致密的染色体组结构。每个长链DNA与组蛋白和非组蛋白一起构成染色质物质。</p></blockquote><p>A pictorial display of an organism’s chromosomes in the coiled, condensed state is known as a karyotype.  Karyotype reveal that in most cells all but sex chromosomes are present as two copies, referred to as homologous pairs.  Non-sex chromosomes are called autosomes.  Organisms whose cells contain two sets of parental chromosomes are called diploid; those with cells containing a single set of parental chromosomes are called haploid.</p><blockquote><p>染色体致密的超螺旋状态我们称染色体组。除了性染色体外，大多数细胞的染色体组成对出现，称同源染色体对。非性染色体称常染色体。生物细胞含有两套父母本染色体的称二倍体；含有单套染色体的称单倍体。</p></blockquote></li><li><p>The Cell Cycle（细胞循环）<br>The cell cycle is a regular sequence in which the cell grows, prepares for division, and divides to form two daughter cells, each of which then repeats the cycle.  Such cycling in effect makes single-celled organisms immortal.  Many cells in multicellular organisms, including animal muscle and nerve cells, either slow the cycle or break out of it altogether.</p><blockquote><p>在细胞生长过程中，细胞循环遵循特定程序，分裂准备，分裂成2个子细胞，子细胞再循环。此循环使得单细胞永生。多细胞生物中的许多细胞，包括动物肌肉和神经细胞，要么降低循环速度，要么同时分裂。</p></blockquote><p>The normal cell cycle consists of four phases.  The first three include G1, the period of normal metabolism; S phase, during which normal synthesis of biological molecules continues, DNA is replicated, and histones are synthesized; and G2, a brief period of metabolism and additional growth.  Together the G1, S, and G2 phases are called interphase.  The fourth phase of the cell cycle is M phase, the period of mitosis, during which the replicated chromosomes condense and move and the cell divides.  It is believed that properties of the cell cytoplasm control the cell cycle, along with external stimulators and inhibitors such as chalones.</p><blockquote><p>正常细胞循环由4个时期组成。头三期包括G1,正常新陈代谢；S期,正常新陈代谢同时，DNA复制，组蛋白合成； G2 期，短期的新陈代谢和少许生长。G1, S, 和G2称分裂间期。最后是M期，有丝分裂期，复制的染色体组浓缩，移动并细胞分裂。据称是染色质控制了细胞循环，伴随外部激活因子和抑制因子如抑素。</p></blockquote></li><li><p>Mitosis: Partitioning the Hereditary Material（有丝分裂：遗传物质的分割）</p><p>Biologists divide the mitotic cycle into four phases.  At the beginning of prophase 前期 the chromosomes each consist of two highly condensed chromatids attached to each other at a centromere.  As prophase ends and metaphase 中期 begins, the condensed 浓缩的 chromosomes become associated with the spindle 纺锤体.  Eventually the chromosomes become arranged in a plane (called the metaphase plate) at a right angle to the spindle fibers.  Next, during anaphase 后期, the two  sister chromatids of each chromosome split, and one from each pair is drawn toward each pole of the cell.  During telophase末期 nuclear envelopes 包膜 begin to form around each set of chromosomes, and division of the cytoplasm takes place.</p><blockquote><p>生物学家将有丝分裂划分为4个阶段。分裂前期，高度浓缩的两个染色单体通过着丝粒连接在一起。在分裂前期后期和分裂中期前期，浓缩的染色体与纺锤体相连，最后以正确的角度排列在赤道板上。在分裂后期，两个姊妹单体分离，分别拽向细胞两极。在分裂末期，在每套染色体周围形成核膜，细胞质发生分裂。</p></blockquote><p>As mitosis proceeds, the spindle microtubules play a crucial role in ensuring that both paired and separated chromatids  染色单体 move in the right directions at the proper times.  Each half of the spindle forms as microtubules extend from each pole of a dividing cell to the region of the metaphase plate.  During prophase, other microtubules, the centromeric着丝粒fibers, extend outward from the spindle poles to structures on the chromosomes called kinetochores着丝粒.  During anaphase the fibers begin to shorten, and the chromatids begin to move apart.</p><blockquote><p>在有丝分裂过程中，是纺锤体微管确保了染色单体在适当时间以正确方向进行分离。纺锤体微管由两极向赤道板延伸。在分裂前期，其它微管，着丝粒纤维延伸到染色体的动粒。在分裂后期，纤维开始变短，染色单体分离。</p></blockquote><p>The spindle forms differently in plant and animal cells.  In animals it is associated with centriole 中心粒, while in plant and fungal 真菌 cells spindle formation is associated with reions called microtubule organizing centers.</p><blockquote><p>植物和动物细胞形成的纺锤体不同。动物细胞与中心粒相连，而在植物和真菌细胞中，纺锤体与微管组织中心的离子相连。</p></blockquote></li><li><p>Cytokinesis: Partitioning the Cytoplasm（胞质分裂：细胞质分离）</p><p>The division of the cell cytoplasm at the end of mitosis is called cytokinesis 细胞浆移动.  In animal cells it takes place as a ring of actin filaments contracts使缩短合同契约 around the cell equator赤道, pinching收聚 the cell in two.  In plant cells, which are bounded 有限制的 by a cell wall, cytokinesis involves the building of a new cell plate across the dividing cell at its equator.  Cell wall material is then deposited 存放堆积 in the region of the cell plate.</p><blockquote><p>在动物细胞中，环形肌动蛋白丝延赤道板收缩而使细胞一分为二。在植物细胞中，在赤道板形成新的细胞板。</p></blockquote></li><li><p>Meiosis: The Basis of Sexual Reproduction（减数分裂：有性生殖的基础）<br>Meiosis 减数 is a special form of cell division that takes place in the reproductive 生殖 organs that produce sex cells.  Like mitosis, it takes place after DNA replication has occurred and involves two sequential 连续的 nuclear divisions (meiosis I and meiosis Ⅱ).  These divisions result in four daughter cells, each with half the number of chromosomes of the parent cell.  The phenomenon of crossing over during meiosis results in exchanges of genetic information between chromosomes.  Hence因此, the homologous 同源的 chromosomes distributed 分布 to different progeny 后裔 cells are not identical同样的.</p><blockquote><p>减数分裂是性细胞分裂的特殊形式。如有丝分裂，它也是发生在DNA复制后并有连续的两个核分裂。产生4个子细胞，分别含有亲本一半的染色体数。</p></blockquote><p>As in mitosis two chromatids exist for each chromosome at the beginning of prophase 1. During this phase the homologous 同源 chromosomes undergo 经历sy-napsis联会 , or pairing, which is brought about by a bridging structure of proteins and RNA called the synaptonemal联会丝的 complex.  The homologous pairs stay together when they align 排列 on the metaphase 中 plate.  Unlike the anaphase of mitosis, however, during anaphase I the two chromatids of each chromosome stay joined at the centromere着丝点 and move together to one of the two poles of the cell.  It is this event that results in the halving 减半的 of the chromosome number in the four daughter cells that result from meiosis.</p><blockquote><p>正如在有丝分裂中一样，两个同源染色单体通过蛋白质和RNA桥配对形成联会复合体。与有丝分裂不同的是，每组染色体的两个染色单体连接在着丝点上并一起移向细胞两极的一级。由此而导致4个子细胞染色体数减半。</p></blockquote><p>During telophase末期 I nuclear envelopes enclose the chromosomes in nuclei, and in most species cytokinesis 细胞浆流动 (the first nuclear division) follows.  The second nuclear division begins with metaphase Ⅱ, in which the chromosomes in each daughter cell again align 排列on a metaphase plate.  The centromeres着丝粒 finally divide, and each sister chromatid moves to one of the poles of the spindle.  The next phase is telophase , followed again by cytokinesis.  The result of the entire process is four haploid cells in which parental chromosomes are randomly distributed.</p><blockquote><p>第二次核分裂开始于分裂中期，子细胞中染色体重新排列在赤道板上。着丝粒最终分离，每个姊妹染色单体分向两极。接着胞质分裂。产生4个单倍体，父母染色体随机分配。</p></blockquote></li><li><p>Asexual Versus Sexual Reproduction（无性生殖与有性生殖）</p><p>Mitosis and meiosis, respectively分别, make simple cell division and sexual reproduction possible.  Each means of passing on hereditary 遗传 information has advantages.  In asexual  无性的 reproduction the parent organism生物体 gives rise to offspring 后代that are genetic clones of the parent.  The advantages of this type of reproduction are that it preserves the parent’s successful genetic complement 遗传互补, requires little or no specialization of reproductive organs, and is more rapid than sexual reproduction.  A major disadvantage of the asexual mode is that a single catastrophic灾难的 event or disease may destroy an entire population of genetically identical organisms.  A prime benefit of sexual reproduction is that it provides genetic variability and a ready mechanism机制 for the elimination of deleterious mutations.  It also allows “new” gene forms to arise and spread through populations.</p><blockquote><p>有丝分裂和减数分裂在传递遗传信息过程中各有优势。体细胞的繁殖就是父母本的克隆，其优势是保留了父母本的成功遗传信息，不需要特殊器官，比性复制快的多。但一个简单灾难性事件或疾病都可能摧毁一个细胞群体。性复制的优势是它提供了遗传可变性和现存排除有害突变的机制。也可以产生新的基因并在种群中蔓延。</p></blockquote></li></ol><h2 id="第四章-Foundations-of-Genetics"><a class="header-anchor" href="#第四章-Foundations-of-Genetics"></a>第四章 Foundations of Genetics</h2><ol><li><p>Early Theories of inheritanee（早期遗传理论）</p><p>Early ideas of inheritance included Hippocrates’ theory of pangenesis and August Weismands germ plasm theory.  Based on experiments with mice, Weismann proposed that hereditary information in gametes transmitted traits to progeny.  Both of these early views incorporated the blending theory: they held that heritable traits of the two parents blend, so that the distinct characteristics of each are lost in offspring.</p><blockquote><p>遗传学的早期理论包括泛生说和种质理论。基于小鼠实验，维丝曼提出遗传信息储存在配子中并将遗传信息传递给后代。这两个早期观点合起来形成融合理论：子代拥有父母本混合的遗传特征，而不完全象亲代。</p></blockquote></li><li><p>Gregor Mendel and the Birth of Genetics  Gregor Mendel（和遗传学的诞生）</p><p>Gregor Mendel, an Augustinian monk in the monastery at Brunn, Austria, is known as the “father of genetics.” Having been exposed to theories of the particulate nature of matter while a university student and having a background in mathematics, Mendel carried out a series of carefully planned experiments that demonstrated the particulate nature of heredity.  His revolutionary ideas were neither understood nor accepted until many years after Mendel died.</p><blockquote><p>孟德尔，众所周知的遗传学之父，是一名修道士。当他还是大学生时就提出了物质的粒子属性。孟德尔进行了一系列周密安排的实验来证实遗传的颗粒性。直到他去世后，他的理论才被理解和接受。</p></blockquote></li><li><p>Mendel’s Classic Experiments   （Mendel的经典实验）</p><p>Mendel studied genetics through plant-breeding experiments with the garden pea, a plant species that is self-fertilizing and breeds true (each offspring is identical to the parent in the trait of interest).  To test the blending theory, he focused his research on seven distinct characters.  Each of these characters, such as seed color and plant height, present only two, clear-cut possibilities.  He also recorded the type and number of all progeny produced from each pair of parent pea plants, and followed the results of each cross for two generations.</p><blockquote><p>孟德尔通过豌豆实验研究遗传学，豌豆是自花授粉植物和纯品系。为验证融合理论，他的研究主要集中在7个特征上。例如，种子颜色，植株高度，这些特征只有两个明确的可能性。他记录了产生的每一个子代类型和数量，在杂交产生子2代。</p></blockquote><p>For each of the characters he studied, Mendel found that one trait was dominant while the other was recessive. In the second filial (F2) generation, the ratio of dominant to recessive was 3:1. Mendel deduced that this result was possible only if each individual possesses only two hereditary units, one from each parent. The units Mendel hypothesized are today known as alleles, alternative forms of genes. Genes are the basic units of heredity. An organism that inherits identical alleles for a trait from each parent is said to be homozygous for that trait; if different alleles for a trait are inherited, the organism is heterozygous for that trait.</p><blockquote><p>对于每个特征而言，要么显形，要么隐性。在子2代中显形与隐性比为3∶1。只有在每个个体仅拥有两个研究遗传单元，并每个单元来自一个亲代时，实验结果才成立。此遗传单元就是今天共识的等位基因。两个一样的等位基因决定一个特征，称纯合。相反，称杂合。</p></blockquote><p>When an organism is heterozygous for a trait, the resulting phenotype for that trait expresses only the dominant allele.Thus, the organism’s phenotype—its physical appearance and properties-differs from its genotype, which may include both a dominant and a recessive allele.  A pictorial representation of all possible combinations of a genetic cross is known as a Punnett square.</p><blockquote><p>当生物是杂合时，它的表型由显性基因决定。因此，生物的表型与基因型是不同的。旁纳特方格可以陈列所有可能的遗传组合。</p></blockquote><p>The results of Mendel’s experiments on dominant and recessive inheritance let to Mendel’s first law: the law of segregation.This law states that for a given trait an organism inherits one allele from each parent.  Together these alleles form the allele pair. When gametes are formed during meiosis, the two alleles become separated (halving of chromosome number).To gain evidence for his theory Mendel performed test crosses, mating plants of unknown genotype to plants that were homozygous recessive for the trait of interest.  The ratio of dominant phenotypes (if any) in the progeny makes clear whether the unknown genotype is heterozygous, homozygous dominant, or homozygous recessive.</p><blockquote><p>分离定律，生物只遗传父母本等位基因对的一个等位基因。减数分裂期形成配子时两个等位基因分离。为验证此理论，他做了测交实验，即基因型未知的植物与纯合的隐性基因植物杂交。子代显性表型可以明确测得杂合基因或纯合基因的基因型。</p></blockquote></li><li><p>Mendel’s Ideas and the Law of independent Assortment  （Mendel的想法和独立分配定律）</p><p>Mendel also performed dihybrid crosses, which enabled him to consider how two traits are inherited relative to one another.  This work let to the law of independent assortment, which states that the alleles of genes governing different characters are inherited independently.  An apparent exception to Mendel’s laws is incomplete dominance, a phenomenon in which offspring of a cross exhibit a phenotype that is intermediate between those of the parents.  However, incomplete dominance reflects the fact that both alleles for the trait in question exert an effect on the phenotype.  The alleles themselves remain separate.</p><blockquote><p>双因子杂合试验，两个特征是如何相互影响遗传的。试验结果产生独自分配定律，即等位基因独立遗传。特例是，不完全显性。子代的表型是父母本的中间类型。不完全显性说明了两个等位基因对表型都有影响。，等位基因会继续分离。</p></blockquote><p>Mendel presented his ideas in 1866 in a scientific paper published by the Brunn Society for Natural History.  Unfortunately, the meaning of his research was not understood by other scientists of the day.  His work was rediscovered in 1900 by Carl Correns and Hugo de Vries.</p><blockquote><p>1866年，孟德尔在自然史上发表了他的科学论文，陈诉了他的观点。不幸的是，他的研究不被当时科学家接受。在1900年，他的著作再被发现利用。</p></blockquote></li><li><p>Chromosomes and Mendelian Genetics（染色体和孟德尔遗传定律）</p><p>Soon after Mendel’s work was rediscovered, Walter Sutton and Theodor Boveri independently proposed that the hereditary units might be located on chromosomes.  Experiments to prove this hypothesis were carried out by Thomas Hunt Morgan and his students at Columbia University, in research on the sex chromosomes of fruit flies.  Morgan’s studies were also the first exploration of sex-linked traits.  It also led to the discovery in 1916 by Calvin Bridges of the phenomenon of nondisjunction, in which a chromosome pair fails to segregate during meiosis.</p><blockquote><p>孟德尔著作被再发现不久，Walter Sutton 和Theodor Boveri提出，遗传单位可能定位在染色体组上。伴性遗传又导致了不分离现象的发现，即在减数分裂中，染色体对不分离。</p></blockquote></li></ol><h2 id="第五章-Discovering-the-Chemical-Nature-of-the-Gene"><a class="header-anchor" href="#第五章-Discovering-the-Chemical-Nature-of-the-Gene"></a>第五章 Discovering the Chemical Nature of the Gene</h2><ol><li><p>Genes Code for Particular Proteins（特定蛋白质的基因编码）</p><p>The first scientist to investigate the question of how genes affect phenotype was Sir Archibald Garrod, whose studies of alkaptonuria implied a relationship between genes and enzymes.  Thirty years later Beadle and Ephrussi showed a relationship between particular genes and biosynthetic reactions responsible for eye color in fruit flies. Next, in a series of classic experiments on the effects of mutations in the bread mold Neurosporacrassa, Beadle and Tatum explored the one-gene-one-enzyme hypothesis-the idea that each gene codes for a particular enzyme.  Their work paved the way for other researchers to elucidate the precise ways in which enzymes affect complex metabolic <a href="http://pathways.In">pathways.In</a> 1949, in research on the role of hemoglobin in sickle cell anemia, Linus Pauling helped refine the one-gene-one-enzyme hypothesis into the one-gene-one-polypeptide hypothesis.</p><blockquote><p>Archibald Garrod是第一个研究基因是如何影响表型的科学家，他对尿黑酸症的研究揭示了基因与酶之间的关系。Beadle 和Ephrussi在三十年后对果蝇眼睛颜色的研究发现特殊基因与相关反应的生物合成有关。接着对面包发霉粗糙脉孢菌的突变试验得出一个基因一个酶的假说。他们的工作为其他工作者铺平了道路，即精确地阐明了酶影响了复杂的新陈代谢途径。在1949年，对镰刀状细胞贫血症的研究对一个基因一个酶的假说进一步上升为一个基因一个多肽。</p></blockquote></li><li><p>The Search for the Chemistry and Molecular Structure of nucleic Acids（核酸的化学和分子结构的研究）</p><p>Nuclei acid, originally isolated by Johann Miescher in 1871, was identified as a prime constituent of chromosomes through the use of the red-staining method developed by Feulgen in the early 1900s.  Frederick Griffith’s experiments with the R and S stains of pneumococci showed that an as yet unknown material from one set of bacterial could alter the physical traits of a second set.  In the 1940s the team of Avery, MacLeod, and McCarty showed that this unknown material was DNA.  At about the same time P.A. Levene discovered that DNA contained four nitrogenous bases, each of which was attached to a sugar molecule and a phosphate group-a combination Levene termed a nucleotide.</p><blockquote><p>在1871年，核酸最初是由Johann Miescher分离成功，并由Feulgen在1900年证实核酸是染色体组最基本的组成。Frederick Griffith对粗糙和光滑的肺炎球菌实验表明，不确定的某种物质可以从一组细菌转移到另一种细菌中。在1940年，确认该物质为DNA。四个碱基和磷酸分子分别连接在糖分子上，称核苷酸。</p></blockquote><p>Disagreement over whether DNA could carry complex genetic information was ended in the early 1950s by Martha Chase and Alfred Hershey, whose work with E. coli showed clearly that DNA, and not protein, is the bearer of genetic information.</p><blockquote><p>直到1950年，通过对大肠杆菌实验发现，遗传物质是DNA，而不是蛋白质。</p></blockquote><p>Each DNA nucleotide contains a five-carbon sugar, deoxyribose, attached to one of four bases: adenine, guanine, cytosine, or thymine.  Adenine and guanine molecules are double-ring structures called purines, while cytosine and thymine are single-ring structures called pyrimidines.  The molecule made up of a base plus a sugar is termed a nucleoside.  In each molecule of DNA a phosphate group links the five-carbon sugar of one nucleoside to the five-carbon sugar of the next nucleoside in the chain.  This phosphate bonding creates a sugar-phosphate backbone.</p><blockquote><p>每个核苷酸都含有一个五碳脱氧核糖，分别连接4个碱基，即：腺嘌呤，鸟嘌呤，胞嘧啶，胸腺嘧啶。碱基连接糖称核苷。磷酸键形成磷酸骨架。</p></blockquote><p>Chargaff’s rules describe the fact that (1) the amount of adenine is equal to the amount of thymine in DNA, with amount of cytosine equal to that of guanine, and (2) the ratios of A to T and of C to G vary with different species.</p><blockquote><p>（1）腺嘌呤与胸腺嘧啶，胞嘧啶与鸟嘌呤相等；（2）腺嘌呤与胸腺嘧啶，胞嘧啶与鸟嘌呤的比例随物种不同而不同。</p></blockquote></li><li><p>The Research Race for the Molecular Structure of  DNA  (DNA分子结构的研究实验 )</p><p>In the late 1940s and early 1950s, researchers looking for the structure of DNA drew upon Chargaff s insight, Levene’s ideas on DNA components, and two other lines of evidence.  One was the suggestion of Linus Pauling that DNA might have a helical structure held in place by hydrogen bonds, and the other was X-ray diffraction photos of DNA, showing a helical structure with distance between the coils, taken by Franklin and Wilkins.</p><blockquote><p>直到40年代末50年代初，研究者在寻求DNA结构过程中，确立了Chargaff 的观点和, Levene的组成理论以及其他两个线索。一个是Linus Pauling的假设，DNA可能具有螺旋结构，通过氢键连接。另一个是X-衍射图片，Franklin and Wilkins提供。</p></blockquote><p>Based on this information Watson and Crick proposed the double helix model of DNA-A twisted ladder-like molecule with two outer sugar phosphate chains and rungs formed by nucleotide pairs.  Paired nucleotides, which always occur as A-T or G-C, are linked by hydrogen bonds.  Watson and Crick also proposed that genetic information is encoded by the sequence of base pairs along the DNA molecule.</p><blockquote><p>基于这些信息，Watson 和 Crick提出了双螺旋结构模型，成对的核苷酸通过氢键相连，遗传信息就贮藏在碱基对中。</p></blockquote></li><li><p>How DNA Replicates  (DNA如何复制)</p><p>In their model of DNA structure and function, Watson and Crick hypothesized that DNA replicates itself by “unzipping” along the hydrogen bonds joining A to T and C to G. This process would produce two opposite halves that could then serve as templates for the construction of new, complementary strands.  This model of semiconservative replication conservative because each new molecule has one half of the former parent molecule-was later confirmed by the work of</p><blockquote><p>DNA进行复制是以拉链方式自我复制，产生的两个二分体分别为模板生成互补链，即半保留复制。并由Meselson和 Stahl验证。</p></blockquote><p>In E. coli DNA replication begins with the formation of a bubblelike structure on the circular chromosome that is produced by replication forks.  Studies of bacterial DNA replication have shown that a growing DNA chain lengthens only in the 5’ to 3’ direction (from the 5’ carbon of one sugar to the 3’ carbon of the next).  The leading strand is synthesized continuously, while the lagging strand is synthesized in short stretches known as Okazaki fragments.  The enzyme DNA polymerase links free nucleotides as they line up on the template formed by the original strand of the parent molecule.<br>In eukaryotes DNA replication follows the same general principles as in prokarotes. On the long DNA molecules replication proceeds (in two directions at once) from hundreds or thousands of points of origin.</p><blockquote><p>大肠杆菌复制开始时形成泡样复制叉，链生长方向由5′向3′端，前导链连续生成，后随链由冈崎片段组成，由DNA聚合酶催化。真核生物复制与原核生物复制相似，但有几百到几千个复制原点（原核一般只有一个复制原点）。</p></blockquote></li></ol><h2 id="第八章-Animal-Development"><a class="header-anchor" href="#第八章-Animal-Development"></a>第八章 Animal Development</h2><ol><li><p>Production of Sperm and Eggs（精子和卵子的产生）</p><p>In sexually reproducing organisms males and females produce sex cells, known as gametes.  These are swimming sperm in males and ova (eggs) in females.</p><blockquote><p>在性繁殖过程中，生物的雄性和雌性产生性细胞，称配子。雄性是能够游动的精子，雌性是卵子。</p></blockquote><p>The process of sperm production, spermatogenesis, takes place in testes.  The sperm originate in gonial cells (spermatogonia) in the walls of seminiferous tubules.  Spermatocytes produced by mitosis in spermatogonia divide meiotically to generate haploid spermatids.  The mature sperm has a tail, a nucleus containing haploid chromosomes, and a front end with an acrosome, the storage site for enzymes that will aid fertilization.</p><blockquote><p>精子产生过程，即精子发生在睾丸中。精子产生于输精管壁的性母细胞（精原细胞）。精原细胞经有丝分裂再减数分裂产生单倍体精子细胞，即精母细胞。成熟精子有尾部，单倍体染色体组，头部有顶体，内部储存酶类，有助于受精。</p></blockquote><p>Ova, which are produced during oogenesis, are generated in gonial cells (oogonia) of the female’s ovaries.  Oocytes then enter a stage of arrest in early meiosis.  At a species-specific later point, a final ripening (ovulation) and the first meiotic division occur.  A second meiotic division, followed by development of the embryo, takes place if the egg is fertilized.</p><blockquote><p>在卵子发生过程中，由卵巢中的性母细胞产生。卵母细胞进入减数分裂的抑制阶段。第一次减数分裂产生一个成熟卵。如果卵受精，那么第二次减数分裂伴随胚胎的发育。</p></blockquote><p>Eggs vary greatly in size from species to species and have complex structures.  Virtually all developing animal ova are surrounded by helper cells, either follicle cells or nurse cells.  Depending on the species, eggs also store varying amounts of yolk, a reservoir of nutrients produced by digestive-gland cells in the mother’s body.  Finally, follicle cells or cells of the maternal oviduct provide protective coatings for the egg, including albumen (egg white) and various types of outer membranes and shells.</p><blockquote><p>品种间卵的大小变化很大，并且有复杂的结构。实际上，所有发育过程中的卵都辅助细胞环绕，要么是滤泡细胞，要么是抚育细胞。依赖物种的不同而不同，卵黄贮备也不同，即由母体消化腺细胞产生的营养储备。最后，滤泡或母体输卵管细胞产生保护性的卵膜，包括清蛋白和各种外部膜及壳。</p></blockquote><p>Frog oocytes have served as model systems for studies of oocyte development.  During maturation they produce huge numbers of ribosomes through gene amplification.  Large quantities of mRNA may also be made and stored.</p><blockquote><p>蛙卵母细胞作为卵母细胞发育的研究系统模型。在成熟过程中，通过基因扩增产生大量的核糖体。同时也产生和储备了大量的mRNA。</p></blockquote></li><li><p>Fertilization: Initiating Development（受精：启动发育）</p><p>Fertilization unites male and female gametes and initiates development.  In some species fertilization is external; in others (including most terrestrial animals) it takes place internally.  The first contact of the sperm head with the egg’s jelly coat triggers the acrosome reaction, in which enzymes are released to digest a hole through the egg’s protective layers, and the plasma membrane of the sperm is brought into position to bind to the ovum’s surface.  After fusion of the egg and sperm plasma membranes, the haploid male nucleus with its chromosomes moves into the egg cytoplasm.  Fusion also triggers the egg’s final meiotic reduction divisions.  When sperm and egg nuclei unite, the two sets of chromosomes mingle to create a diploid set.  The fertilized egg is now a zygote.</p><blockquote><p>雌雄配子结合作用称受精作用，发育开始。某些物种中，是外部受孕；另一些物种，包括大部分陆生动物，是内部受孕。当精子和卵子的胶状膜发生接触时，触发了顶体反应。释放多种酶而将卵保护膜消化出一个洞。精子的原生质膜与卵子的表面连接起来。精卵原生质膜融合后，单倍体雄性核进入卵细胞质。融合也触发了最后的减数分裂。当精卵核结合时，两套染色体混合产生一二倍体，即受精卵。</p></blockquote><p>The egg’s cortical reaction serves as a barrier to the entry of more than one sperm.  Initially, there is a temporary change in the egg’s electrical state, and the egg cell is activated.  The final stage of the reaction, the rapid elevation of the fertilization membrane, prevents further sperm penetration.</p><blockquote><p>卵皮层阻止其他的精子进入，充当壁垒作用。开始时，卵电位发生暂时变化，卵细胞被激活。反应最后阶段，受精卵的膜快速隆起，阻止更多精子进入。</p></blockquote><p>In some species fertilization is not necessary.  Instead, parthenogenesis takes place: the egg is spontaneously activated and proceeds to normal embryonic development.</p><blockquote><p>对某些物种而言，受精不是必须的。孤雌生殖，即卵自发地被激活并进入正常的胚胎发育过程中。</p></blockquote></li><li><p>Cleavage: An Increase in Cell Number（分裂：细胞数量的增加）</p><p>Cleavage, the major developmental event immediately following fertilization, is a special form of cell division (mitosis).  Cleavage produces a blastula, a sheet of cells rounded into a sphere that in most species surrounds a cavity.  In the process, the single-celled zygote is divided into many small cells, and yolk, mRNA, ribosomes, and other materials arc distributed to each cell in precise ways.  The cells of the blastula, called blastomeres, also each receive a full diploid set of chromosomes.</p><blockquote><p>受精后，立即发生卵裂，细胞有丝分裂的特殊过程。卵裂产生一个囊胚，形成的细胞壁球形排列形成一个空腔。在这个过程中，单细胞的受精卵分裂成许多小细胞，卵黄，mRNA，核糖体和其他物质被精确分配到每个细胞中。这些囊胚细胞，称卵裂球，每个细胞都有一套二倍体染色体组。</p></blockquote><p>There are different patterns of cleavage in different species.  The amount of yolk present in the egg is a major factor in determining the pattern: in species having little yolk (such as mammals) the zygote cleaves completely through, forming cells that are roughly equivalent in size.  In frogs, in which the egg has somewhat more yolk, cleavage proceeds more rapidly in regions of the embryo having less yolk.  In bird eggs the yolk is so massive that cleavage divisions are restricted to a tiny area of cytoplasm.</p><blockquote><p>不同物种，卵裂方式不同。决定因素主要取决于卵黄的含量。含有少量卵黄的物种（例如哺乳动物），合子分裂得很彻底，子细胞大致平均分裂。蛙卵，卵黄稍微多点，在胚胎的卵黄较少区域发育更快些。鸟卵卵黄很大，卵裂被限制在细胞质很小区域内。</p></blockquote><p>In many species the precise distribution to blastomeres of molecular determinants in the cytoplasm is crucial to proper development of different cell types in the embryo.  In mammal and bird species the fate of cells is determined by the position of a cell late in cleavage.</p><blockquote><p>细胞质中分子遗传因素精确分配到卵裂球中，对许多物种而言，是发育成胚中不同类型细胞关键所在。对哺乳动物和鸟类而言，细胞的命运最终由细胞分裂后所处的位置决定的。</p></blockquote></li><li><p>Gastrulation: Rearrangement of Cells（原肠胚：细胞重排列）</p><p>The rearrangement of the blastula into a three-dimensional organism with inner, middle, and outer layers occurs during gastrulation.  The resulting gastrula consists of an outer ectoderm, an inner endoderm, and a mesoderm layer positioned between them.</p><blockquote><p>在原肠胚形成过程中，囊胚重新排列，形成包括内层，中层，外层的三围组织。最终原肠胚由一个外肠胚，内肠胚，和一个中肠胚构成。</p></blockquote><p>Each layer gives rise to specific tissues during embryonic development.  A variation in gastrulation, involving the movement of cells into endodermal and mesodermal positions through the thickened primitive streak, arose in reptiles and can still be seen in bird and mammalian embryos, lending support to the theory that birds and mammals evolved from reptiles.</p><blockquote><p>每个胚层产生特殊的胚胎组织。密实的原肠胚通过细胞运动进入内胚层和中胚层，爬虫，鸟，哺乳动物的胚胎都如此。因此提出这样的理论，鸟类和哺乳动物是由爬虫进化而来的。</p></blockquote></li><li><p>Organogenesis: Formation of Functional Tissues and Organs（器官发生：功能组织和器官的形成）</p><p>The organs and tissues of the embryo arise during organogenesis as cells inside the embryo and on its surface become specialized.  Organogenesis actually includes two closely linked processes, morphogenesis and differentiation.  During morphogenesis cells and cell populations change shape: an example is neurulation in vertebrate embryos, in which the edges of the flat neural plate fold upward and fuse, forming the beginnings of the hollow brain and spinal cord.  During differentiation cells mature so that they may perform separate functions.  This maturation may include taking on a function-related shape, such as the long, spindly shape of skeletal-muscle cells.  Cell differentiation also results in responsiveness-the ability of a cell to be regulated within the organism through the action of hormones, neurons, and other signals.</p><blockquote><p>胚经过内部细胞和表面细胞特化后，器官形成，发育成器官和组织。器官形成实质上包括两个联系紧密的过程，即形态发生和分化。在形态发生期间，细胞和细胞群体形状发生改变：例如，脊椎动物的神经胚，扁平神经板的边缘向上折叠并融合，是中空大脑和脊髓神经形成的开端。在分化期间，细胞成熟，执行各自功能。成熟包括功能相关的成型过程。例如，细长的骨骼肌肉细胞。细胞分化也产生应答能力，即细胞受生物体内激素，神经和其他信号的调控过程。</p></blockquote></li><li><p>Embryonic Coverings and Membranes（胚胎覆盖物和胎膜）</p><p>The embryos of land vertebrates are enclosed within four extraembryonic membranes that afford protection while still permitting the exchange of gases, nutrients, and other materials.</p><blockquote><p>脊椎动物的胚胎被4层膜包被，起保护作用，但仍能交换气体，营养和其他物质。</p></blockquote></li><li><p>Growth: Increase in Size（增长：规模增加）</p><p>Growth in embryos is largely due to an increase in the number of cells rather than to an increase in the size of individual cells.  In many species the extent of embryonic growth is limited by the availability of food (yolk).  In animals that develop entirely free of the maternal body, such as frogs and insects, the embryo give rise to a larval stage that can feed itself and later undergo metamorphosis to attain the adult stage.  In many species the most spectacular growth phase takes place during the juvenile and adolescent phases of the life cycle.  Actual growth generally stops once the organism reaches its typical adolescent phases of the life cycle.  Actual growth generally stops once the organism reaches its typical adult size, although replacement of dead cells may continue.</p><blockquote><p>胚的生长很大程度取决于细胞数量的增加而不是单个细胞大小的改变。在大多数物种中，胚的生长是受卵黄的量限制的。在动物细胞中，完全依赖于母体，例如蛙和昆虫，胚产生幼虫状态，后来经历变态而进入成年状态。在许多物种中，在少年和青春期，发生特别显著的生长。一旦细胞进入成年状态和成年大小，生长就停止了，尽管死细胞的替代不断发生。</p></blockquote><p>A special type of growth, regeneration of lost body parts, can take place in adults of some species.  Prior to such regeneration cells in stump tissue undergo dedifferentiation.  They lose their functional phenotype, divide rapidly, and generate a population of cells that will regenerate the lost part. Compensatory hypertrophy is a different, temporary growth response in which residual tissue increases in mass and cell number: cells undergo mitosis but do not dedifferentiate.</p><blockquote><p>一个特殊类型的生长，再生失去的部分躯体，发生在某些物种的成体中。在再生之前，残肢组织细胞经历了去分化过程。他们失去功能表型，快速分裂，产生细胞群来再生失去的部分。代偿式肥大是一个不同的，暂时的生长应答过程，残余组织在体积和细胞数量上增加：细胞经历了减数分裂，但没有去分化过程。</p></blockquote></li><li><p>Aging and Death: Final Developmental Processes（衰老与死亡：最后的发展过程）</p><p>Aging is an ongoing, time-dependent developmental process in which body parts deteriorate.  Proposed causes include the degeneration of collagen (the fibrous proteins of the connective tissues) and limits on the number of times cells can divide.  Other theories focus on a decline of the immune system or on the accumulation of lipofuscins (aging pigments).</p><blockquote><p>老化是一个持续过程，随时间发育，身体部分恶化。可能原因包括胶质的退化（纤维蛋白）和能分裂活细胞的限制。另外理论认为，免疫系统的免疫下降或脂褐素的堆积造成的。</p></blockquote></li></ol><h2 id="第一章"><a class="header-anchor" href="#第一章"></a>第一章</h2><ol><li>Polysome：多聚核糖体 → RNA and ribosomes：RNA和核糖体</li><li>Pinocytosis：胞饮 → cell drinking</li><li>Exocytosis：胞吐 → expel：排出</li><li>Plastid：质体 → in plants only：仅在植物体中</li><li>Golgi complex：高尔基体 → packaging：包装，打包</li><li>Flagella：鞭毛 → whiplike：鞭子似的，像鞭子的</li><li>Phagocytosis：吞噬 → engulfment：吞食</li><li>Lysosome：溶酶体 → baglike structure：像袋子一样的结构</li><li>Basal body：基体 → where flagella grow：鞭毛生长的地方</li><li>Chemotactic：趋化 → toward or away from a chemical stimulus：朝向或远离化学刺激</li><li>Nucleus：核 → control room：控制中心</li><li>Vacuole：液泡 → vacant：空着的</li><li>Ribosome：核糖体 → protein synthesis：蛋白质合成</li><li>Cytoskeleton：细胞骨架 → weblike：像网的</li><li>Mitochondrion：线粒体 → power generator：发电机</li></ol><hr><ol><li>❌The DNA of prokaryotic cells is concentrated in the nucleus. 原核细胞的DNA集中在细胞核内。</li><li>✔Ribosomes are derived from the nucleoli.核糖体来源于核仁。</li><li>❌Unlike other cell membranes, the nuclear envelope has no pores.与其他细胞膜不同，核膜没有孔。</li><li>✔The smooth endoplasmic reticulum is held in place by the cytoskeleton.光滑的内质网由细胞骨架固定。</li><li>✔Structural proteins are exportable.</li><li>✔The nuclear envelope is produced by the rough endoplasmic reticulum.核膜由粗面内质网产生。</li><li>✔Most cellular proteins are manufactured on ribosomes.大多数细胞蛋白质是由核糖体制造的。</li><li>✔White blood cells work by phagocytosis.白细胞通过吞噬作用起作用。</li><li>❌Prokaryotic cells have microbodies.原核细胞有微体。</li><li>✔Mitochondria are self-replicating.</li><li>✔Pinocytosis describes the intake of fluid into a cell by a vacuole.</li><li>❌Both prokaryotic and eukaryotic cells have a supporting cytoskeleton.</li><li>❌Carotenoids are colorless molecules.</li><li>❌Grana are surrounded by stoma.</li></ol><hr><ol><li><p>Most of the properties associated with processes of life are properties of __</p><p>a. the nucleus<br>b. DNA<br>c. the cytoplasm<br>d. endosymbionts 内共生体 ✔<br>e. none of the above</p></li><li><p>Ribosomes</p><p>a. are organelles involved in protein synthesis 参与蛋白质合成的细胞器 ✔<br>b. are the cell’s main energy source<br>c. are storage sites for starch<br>d. are involved in the breakdown of proteins<br>e. store genetic information in the form of DNA</p></li><li><p>Smooth endoplasmic reticulum (SER) __</p><p>a. lacks ribosomes<br>b. is active in fat and steroid synthesis<br>c. is involved in the oxidation of toxins<br>d. all of the above ✔<br>e. none of the above</p></li><li><p>Ribosomes are manufactured in __核糖体制造是在</p><p>a. cytoplasm<br>b. nucleoli 核仁 ✔<br>c. mitochondria<br>d. smooth endoplasmic reticulum<br>e. rough endoplasmic reticulum</p></li><li><p>Lysosomes contain __ 溶酶体包含</p><p>a. hydrolytic enzymes ✔<br>b. genetic material<br>c. stored fats<br>d. proteins<br>e. carbohydrates</p></li><li><p>The process of phagocytosis involves __吞噬的过程包括</p><p>a. vacuolar engulfing of particulate matter 颗粒物质的液泡吞噬 ✔<br>b. exocytosis<br>c. intake of water by a cell’s vacuole<br>d. expulsion of particulate matter from a cell<br>e. expulsion of water from a cell</p></li><li><p>Transformation of energy and storage of energy in the cell are the main function of __ 能量的转换和储存是主要功能对于</p><p>a. ribosomes<br>b. microbodies<br>c. contractile vacuoles<br>d. mitochondria 线粒体 ✔<br>e. smooth endoplasmic reticulum</p></li><li><p>In the mitochondria, enzymes involved in ATP generation are  __在线粒体中，参与ATP产生的酶是</p><p>a. located within the matrix<br>b. located on the cristae 位于嵴上 ✔<br>c. located on ribosomes in the matrix<br>d. dispersed throughout the cristae and matrix<br>e. associated with polysomes</p></li><li><p>Chromoplasts are a type of   __ 有色体是一种</p><p>a. pigment<br>b. storage bin<br>c. nutrient tank<br>d. plastid 质体 ✔<br>e. none of the above</p></li><li><p>An mRNA molecule and its associated ribosomes make up __ 一个信使rna分子及其相关的核糖体组成</p><p>a. a multisome<br>b. a polysome ✔<br>c. a lysosome<br>d. a monosome<br>e. none of the above</p></li><li><p>Leucoplasts are plastids that __ 白色体是一种质体</p><p>a. contain carotenoid<br>b. are involved in photosynthesis<br>c. serve as a storage site for starch, proteins, and oils  作为淀粉、蛋白质和油脂的储存场所 ✔<br>d. are responsible for plant pigmentation<br>e. are none of the above</p></li><li><p>Each individual cell is supported by a network of filaments and tubules known as __ 每个细胞都由一个由丝和小管组成的网络支撑</p><p>a. cytoplasm<br>b. a vacuole<br>c. an endoplasmic reticulum<br>d. a cytoskeleton 细胞骨架 ✔<br>e. a plasma membrane</p></li><li><p>In prokaryotic cells the DNA is __ 在原核细胞中DNA是</p><p>a. found in the nucleus<br>b. organized into a number of discrete chromosomes<br>c. condensed into an unbounded area called the nucleoid 凝聚成一个无界区域，称为类核 ✔<br>d. condensed into nucleoli<br>e. enclosed in a nuclear envelope</p></li><li><p>Amino acids are assembled into proteins in the cells __ 氨基酸在细胞中组装成蛋白质</p><p>a. in the nucleus<br>b. on ribosomes 在核糖体 ✔<br>c. in mitochondria<br>d. in lysosomes<br>e. in the Golgi complex</p></li><li><p>During protein synthesis a single mRNA molecule may be associated with several ribosomes to form __在蛋白质合成过程中，单个mRNA分子可能与几个核糖体结合形成</p><p>a. a gene<br>b. a lysosome<br>c. a polysome 多聚核糖体 ✔<br>d. smooth endoplasmic reticulum<br>e. rough endoplasmic reticulum</p></li><li><p>Export proteins are proteins destined for export from the cell or for inclusion in cell membranes. The can be identified by __</p><p>a. their secondary structure<br>b. a sequence of amino acids known as signal peptide 被称为信号肽的氨基酸序列 ✔<br>c. their association with a polysome<br>d. all of the above<br>e. none of the above</p></li><li><p>Proteins synthesized on endoplasmic reticulum are modified __ 内质网合成的蛋白质经过修饰</p><p>a. in vacuoles<br>b. in the cell membrane<br>c. in the Golgi complex ✔<br>d. in lysosomes<br>e. not at all after synthesis</p></li><li><p>An amoeba living in water whose tonicity is lower than that of its internal cytoplasm must deal with a constant infux of water into the cell. It expels this excess water by __ 生活在水中的变形虫的张力低于其内部细胞质的张力，因此必须不断地向细胞内注入水。它把多余的水排出</p><p>a. using excretory proteins<br>b. waterproofing its cell membrane with lipids<br>c. using a contractile vacuole 用一个可收缩的液泡 ✔<br>d. using phagocytosis<br>e. moving to an environment with lower tonicity</p></li><li><p>Hydrolytic enzymes in the cell digest food in the __ 细胞里的水解酶消化食物在</p><p>a. lysosome 溶酶体 ✔<br>b. Golgi complex<br>c. mitochondria<br>d. chloroplast<br>e. endoplasmic reticulum</p></li><li><p>An organelle isolated from an animal cell is found to contain large numbers of enzymes involved in energy transformation. This organelle is most likely to be __人们发现从动物细胞中分离出来的细胞器含有大量参与能量转换的酶。这个细胞器很可能是</p><p>a. a lysosome<br>b. a Golgi complex<br>c. a mitochondrion  线粒体 ✔<br>d. a chloroplast<br>e. a leucoplast</p></li></ol><hr><h2 id="第二章"><a class="header-anchor" href="#第二章"></a>第二章</h2><ol><li>C<sub>3</sub> plant→moist climates</li><li>pigment→absorbs</li><li>light reactions→water oxidized</li><li>thylakoid→surrounds a lumen</li><li>ground state→most stable</li><li>reaction center→a specific site</li><li>photorespiration→greenhouse effect</li><li>RuBP→electron acceptor for CO<sub>2</sub></li><li>Calvin Benson cycle→light-independent reactions</li><li>C<sub>4</sub> plant→dry climates</li><li>photon→wave and particle</li><li>chlorophyll→principal pigment</li><li>chloroplast→banana shape</li><li>carbon cycle→inefficient dark reaction</li><li>light- independent reactions→light optional</li></ol><hr><ol><li>❌Photosynthesis occurs in all living things.</li><li>✔Photon energy is inversely proportional to wavelength.</li><li>❌Chlorophyll b is not found in any prokaryote.</li><li>❌The reaction center in photosystem Ⅱ is P700.</li><li>✔Cyclic photophosphorylation produces additional ATP in plants.</li><li>❌The chemiosmotic theory applies to mitochondria but not to chloroplasts.</li><li>❌Light-dependent reactions take place in the chloroplast stroma.</li><li>✔The Calvin-Benson cycle may take place either in light or in the dark.</li><li>❌Light-independent reactions take place in thylakoid membrane.</li><li>✔C<sub>3</sub> plant grow slowly in hot, dry weather.</li><li>✔Chlorophyll a is the primary photosynthetic pigment in green plants.</li></ol><hr><ol><li><p>The process of photosynthesis can be considered as a series of reactions in which light energy from the sun is __ 光合作用的过程可以看作是来自太阳的光能的一系列反应</p><p>a. transformed into chemical energy 转化成化学能 ✔<br>b. not transformed in the plant<br>c. transformed into kinetic energy<br>d. transformed into potential energy<br>e. transformed by electrons into electric energy</p></li><li><p>In the first stage of photosynthesis water is __ 在光合作用的第一阶段，水是</p><p>a. oxidized 被氧化 ✔<br>b. phosphorylated<br>c. reduced<br>d. heated<br>e. none of the above</p></li><li><p>In the course of photosynthesis glucose molecules are formed from CO<sub>2</sub>  and H<sub>2</sub>O. This process __在光合作用过程中，CO2和H2O形成葡萄糖分子。这个过程</p><p>a. is exergonic<br>b. is endergonic 是吸能 ✔<br>c. requires no energy<br>d. liberates energy to the atmosphere<br>e. is none of the above</p></li><li><p>The splitting of water molecules during photosynthesis __光合作用水分子在光合作用中分解</p><p>a. occurs independently of light<br>b. is known as the Calvin-Benson cycle<br>c. takes place in the mitochondria<br>d. is light-dependent 是依赖光 ✔<br>e. only occurs in C<sub>4</sub> plant</p></li><li><p>The end products of the first stage of photosynthesis that drive the second stage are __ 驱动光合作用第一个阶段的最终产物是</p><p>a. ADP and NAD<br>b. ATP and NADPH ✔<br>c. H<sub>2</sub>O and ADP<br>d. CO<sub>2</sub><br>e. low-energy compounds</p></li><li><p>During the second stage of photosynthesis, __</p><p>a. CO<sub>2</sub> is oxidized to carbohydrate<br>b. O<sub>2</sub> is reduced<br>c. CO<sub>2</sub> is reduced✔<br>d. CO<sub>2</sub> is liberated into the atmosphere<br>e. carbohydrates are oxidized to release energy</p></li><li><p>The fattened stacks of saclike structures in the chloroplast are called grana. Each sac is known as __叶绿体中肥厚的囊状结构称为基粒。每个囊被称为</p><p>a. a lumen<br>b. a granum<br>c. a membrane<br>d. a thylakoid✔<br>e. a photoreactive center</p></li><li><p>The enzymes and cofactors that facilitate the light-dependent reactions of photosynthesis are embedded in the __酶和辅助因子促进光合作用依赖光的反应是嵌入在</p><p>a. stroma<br>b. lumen of the cytoplasm<br>c. thylakoid membrane 类囊体膜 ✔<br>d. cell wall<br>e. nuclear membrane</p></li><li><p>The distance a photon travels during a complete vibration is __</p><p>a. its particle property<br>b. its radiation<br>✔c. its wavelength<br>d. its strength<br>e. none of the above</p></li><li><p>Biological molecules can only capture light whose wavelength lies in __.</p><p>a. the high-energy part of the spectrum<br>b. the low-energy part of the spectrum<br>c. any part of the spectrum<br>✔d. the visible part of the spectrum<br>e. the gamma-ray spectrum</p></li><li><p>When a chlorophyll molecule absorbs light,  __.</p><p>a. all wavelengths are equally absorbed<br>b. green light is maximally absorbed<br>✔c. green light is not absorbed<br>d. red light is reflected<br>e. blue light is reflected</p></li><li><p>The last electron acceptor in electron transport is __.</p><p>a. O<sub>2</sub><br>✔b. P700<br>c. photosystem I<br>d. water<br>e. none of the above</p></li><li><p>The precise range of wavelengths active duling photosynthesis is known as __.</p><p>a. the electromagnetic spectrum<br>b. the absorption spectrum<br>c. the high-energy spectrum<br>d. the low-energy spectrum<br>✔e. the action spectrum</p></li><li><p>Pigment molecules aggregated together into an antenna complex __.</p><p>a. act together to gather light energy<br>b. transfer light energy down an electron transport system<br>c. are closely associated with reaction-center chlorophyll molecules<br>✔d. all of the above<br>e. none of the above</p></li><li><p>When a chlorophyll molecule absorbs a photon of light, __.</p><p>✔a. the outermost electron becomes excited and moves to a higher- energy orbital<br>b. it immediately donates an electron<br>c. all its electrons remain in the ground state<br>d. fuorescence is the first event to occur<br>e. the molecule donates all its electrons</p></li><li><p>Cyclic phosphorylation differs from noncyclic phosphorylation in that __.</p><p>a. only cyclic phosphorylation yields NADP<br>✔b. cyclic phosphorylation yields ATP while non-cyclic phosphorylation yields ATP and NADPH<br>c. cyclic phosphorylation yields ATP and non-cyclic phosphorylation yields only NADPH<br>d. only noncyclic phosphorylationyields ATP<br>e. none of the above; there is no difference in end product or in the processes</p></li><li><p>The Calvin-Benson cycle takes place in __.</p><p>a. the ribosomes<br>✔b. the inner plasma membrane<br>c. the cytoplasm<br>d. the stroma<br>e. none of the above</p></li><li><p>In the light-independent reactions of photosynthesis, the first electron acceptor for atmospheric CO<sub>2</sub> is __.</p><p>a. PGA<br>b. ATP<br>✔c. ribulose biphosphate<br>d. a carbohydrate subunit<br>e. a carboxylase</p></li><li><p>The process of photorespiration __.</p><p>a. occurs when oxygen levels are high<br>b. is an inefficient form of light-independent reactions of photosynthesis<br>C. results in the fixation of oxygen<br>d. is due in part to stomata closure on hot, dry, sunny days<br>✔e. is all of the above</p></li></ol><hr><h2 id="第三章"><a class="header-anchor" href="#第三章"></a>第三章</h2><ol><li>cytokinesis → division of cytoplasm</li><li>synapsis → crossing over</li><li>histone → positively charged protein</li><li>mitosis → cell division</li><li>cell cycle → sequence of cell growth and division</li><li>chalone → inhibit cell division</li><li>spindle → set of microtubules</li><li>chromatid → single chromosome copy</li><li>nucleosome → DNA + histones</li><li>diploid → two sets</li><li>meiosis → gamete production</li><li>cell plate → plant division</li><li>sex chromosome → X and Y</li><li>karyotype → chromosome display</li><li>haploid → one set</li></ol><hr><ol><li>❌Autosomes include X and Y chromosomes.常染色体包括X染色体和Y染色体</li><li>✔Cells enter G<sub>2</sub> at the end of the S phase. S期结束时，细胞进入G2。</li><li>❌Chalones promote cell division.抑素促进细胞分裂。</li><li>✔The nuclear envelope forms in telophase.核膜在末期形成。</li><li>❌Plant cells have the most prominent centrioles.植物细胞有最显著的中心粒。</li><li>✔Nuclear division may occur without cytokinesis.核分裂在没有胞质分裂的情况下也可以发生。</li><li>✔Homologous chromosome pair in synapsis.同源染色体在联会时组成一对</li><li>✔Chromosomes break at chiasmata.染色体在交叉处断裂。</li><li>❌Sexual organisms cannot be cloned.有性生物不能被克隆。</li><li>❌All daughter cells are haploid.所有子细胞都是单倍体。</li></ol><hr><ol><li><p>DNA is replicate during the __.DNA复制在</p><p>✔a. S phase<br>b. M phase<br>c. G<sub>2</sub> phase<br>d. G<sub>1</sub> phase<br>e. G<sub>0</sub> phase</p></li><li><p>Members of a chromosome pair collectively make up __.一对染色体共同组成的成员</p><p>a. a tetrad<br>b. chromatin<br>c. a homologous pair<br>✔d. a chromatid 一个染色单体<br>e. a nucleosome</p></li><li><p>Autosomes represent __.常染色体表示</p><p>a. all chromosomes found in a normal human cell<br>b. those chromosomes found in egg or sperm cells<br>✔c. all chromosomes other than the sex chromosomes 除性染色体外的所有染色体<br>d. chromosome pairs with unlike members<br>e. all homologous chromosomes</p></li><li><p>In a typical vertebrate the longest phase is __.在典型的脊椎动物中，最长的阶段是</p><p>a. S<br>b. M<br>C. G<sub>2</sub><br>✔d. G<sub>1</sub><br>e. none of the above</p></li><li><p>A normal diploid human cell contains __.一个正常的二倍体人类细胞包含</p><p>✔a.46 chromosomes<br>b.23 chromosomes<br>c.46 homologous pairs of chromosomes<br>d.20 chromosomes<br>e.20 pairs of chromosomes and 2 sex chromosomes</p></li><li><p>Male sex chromosomes can never be __.男性的性染色体永远不会</p><p>a. haploid<br>✔b. homologous 同源<br>c. diploid<br>d. analogous<br>e. duplicated</p></li><li><p>During G<sub>1</sub>, S, and G<sub>2</sub> phases, a cell is said to be in __.在G<sub>1</sub>、S和G<sub>2</sub>阶段，细胞被称为处于</p><p>a. the process of mitosis<br>b. the process of meiosis<br>c. metaphase<br>d. cytokinesis<br>✔e. interphase 分裂间期</p></li><li><p>It is possible for 2 meters of DNA to fit into a human cell 5 micrometers in diameter because __.2米长的DNA可以植入直径5微米的人体细胞，因为</p><p>a. DNA is broken into small fragments<br>✔b. DNA is wound around histones DNA缠绕在组蛋白周围<br>c. DNA is wound around nonhistone proteins<br>d. Chromosomes are composed of chromatids<br>e. Chromosomes are joined at the centromere</p></li><li><p>The association of a DNA molecule, histones, and nonhistone proteins is known as a __.DNA分子、组蛋白和非组蛋白的结合称为</p><p>a. nucleosome<br>b. chromosome<br>✔c. chromatin 染色质<br>d. chromatid<br>e. karyotype</p></li><li><p>The two daughter strands of a duplicated chromosome are each known as (a) __.复制染色体的两条子链分别称为</p><p>a. synapse pair<br>b. centromere<br>✔c. chromatid 染色单体<br>d. homologous chromosome<br>e. chiasmata</p></li><li><p>Chromosomes become visible during mitotic phase of __.染色体在有丝分裂期间可见</p><p>a. metaphase<br>b. anaphase<br>✔c. prophase 前期<br>d. synapsis<br>e. none of the above</p></li><li><p>Anaphase begins during mitosis when  后期开始于有丝分裂期间</p><p>a. chromosomes line up in the nuclear region of the cell<br>✔b. centromeres split and chromatids start to move apart 着丝点分裂，染色单体开始分离<br>c. synapsis occurs<br>d. crossing over occurs<br>e. prophase has been completed</p></li><li><p>A new nuclear envelope begins to form around each chromosome set during __.一个新的核膜开始在每条染色体周围形成</p><p>a. anaphase I<br>b. metaphase<br>c. prophase Ⅱ<br>d. cytokinesis<br>✔e. telophase 末期</p></li><li><p>In animal cells spindle formation is assoclated with __. 在动物细胞中纺锤形形成与</p><p>a. the nuclear membrane<br>b. nucleosomes<br>c. histone proteins<br>✔d. the centriole 中心粒<br>e. chromosomes</p></li><li><p>Haploid cells contain __.  单倍体细胞包含</p><p>a. the diploid chromosome number<br>✔b. one copy of each chromosome 每个染色体的一个拷贝<br>c. two copies of the sex chromosomes<br>d. twice the diploid chromosome number<br>e. pairs of homologous chromosomes</p></li><li><p>Meiosis results in__. 减数分裂的结果</p><p>a. no change in the chromosome number<br>b. a doubling of the chromosome number<br>✔c. a reduction in the chromosome number 染色体数目的减少<br>d. two interphase cells<br>e. four diploid cells</p></li><li><p>Crossing over occurs during __. 交叉发生在</p><p>a. G<sub>0</sub> phase<br>b. G<sub>1</sub> phase<br>✔c. synapsis 染色体联会<br>d. cytokinesis<br>e.Mphase</p></li><li><p>Cytokinesis is accomplished in animal cells by __. 动物细胞的胞质分裂是通过</p><p>✔a. a ring of actin filaments pinching the cell in two 将细胞夹成两半的肌动蛋白丝环<br>b. the formation of a cell plate<br>c. the formation of a new cell wall<br>d. the action of centrioles<br>e. the re formation of the nuclear membrane</p></li><li><p>During crossing over __. 在交叉时</p><p>a. chromosomes line up along the metaphase plate .<br>✔b. homologous chromosomes exchange corresponding pieces of genetic information 同源染色体交换相应的遗传信息片段<br>c. chromosomes move to opposite ends of the cell<br>d. the cell is in S phase<br>e. the cell is undergoing mitosis</p></li><li><p>The advantages of asexual reproduction include__.无性繁殖的优点包括</p><p>a. it is more rapid than sexual reproduction<br>b. it requires few specialized reproductive structures<br>c. it preserves the individual’s winning genetic make up<br>✔d. all of the above 上述全部<br>e. a and c</p></li></ol><h2 id="第四章"><a class="header-anchor" href="#第四章"></a>第四章</h2><ol><li><p>dominant 显性 → always expressed 总是表达</p></li><li><p>phenotype 表型 → appearance 外观</p></li><li><p>allele 等位基因 → alternative forms 替代形式</p></li><li><p>homozygous  纯合子 → similar 相似</p></li><li><p>recessive 隐性性状 → nondominant 非显性的</p></li><li><p>P1 → parental 亲本</p></li><li><p>dihybrid cross 双因子杂种杂交 → two characters</p></li><li><p>law of segregation 分离定律 → separate 分离</p></li><li><p>gene 基因 → basic units of heredity 遗传的基本单位</p></li><li><p>pangenesis 泛生论 → Hippocrates 希波克拉底</p></li><li><p>F2 → grandchildren</p></li><li><p>sex-linked 伴性的 → X or Y chromosome</p></li><li><p>heterozygote 杂合子 → different</p></li><li><p>genotype 基因型 → total alleles 总等位基因</p></li><li><p>germ plasm theory → Weismann 魏斯曼</p></li></ol><hr><ol><li>❌Germ plasm theory is the notion that each body part produces a“seed&quot; .种质理论的概念是，身体的每个部分产生一个“种子”。</li><li>✔Breeding true means offspring are identical with parents in certain traits.真正的繁殖是指后代在某些特性上与父母相同。</li><li>✔Alleles are simply alternate forms of genes.等位基因只是基因的另一种形式。</li><li>❌Snapdragon color is an example of blending inheritance.金鱼草颜色是混合继承的一个例子</li><li>✔An XO male may result from nondisjunction. XO雄性可能是不分离的结果。</li><li>❌Hippocrates fully rejected the idea of pangenesis.希波克拉底完全拒绝泛生学说。</li><li>✔Homozygous organisms produce only one type of gamete for a gene.纯合子的生物体一个基因只产生一种配子。</li><li>✔Test crosses helped establish the law of segregation.杂交试验有助于建立分离定律。</li><li>✔Sutton and Boveri developed the chromosome theory of heredity.萨顿和博韦里发展了遗传的染色体理论。</li><li>❌Mendel’s second law states that characters are inherited dependently.孟德尔第二定律指出，特性是独立继承的</li></ol><hr><ol><li><p>The notion that each part of the body of an organism produces a“seed”that then travels to the reproductive organs is called __.生物体身体的每个部分都产生一种“种子”，然后传播到生殖器官的概念被称为。</p><p>a. germ plasm theory<br>✔b. pangenesis 泛生论<br>c. law of independent assortment<br>d. law of segregation<br>e. heterozygosity</p></li><li><p>The germ plasm theory of heredity, which emphasized the role of parental germ cells in determining traits in offspring, was linked to a widespread belief in__.遗传的种质理论强调亲代生殖细胞在决定后代性状方面的作用，这与一种普遍的观念</p><p>✔a. blending 混合<br>b. vitalism<br>c. pangenesis<br>d. Mendelism<br>e. Herodotus</p></li><li><p>When true breeding plants are self-fertilized, they__.当真正的育种植物自我受精时，它们</p><p>a. produce heterozygous offspring<br>b. produce offspring that show a range ofphenotypes<br>✔c. produce offspring that are identical to the parent 产生与亲本完全相同的后代<br>d. produce offspring with dominant genotypes<br>e. produce offspring with recessive genotypes</p></li><li><p>Mendel’s experiments with peas had unique and important features, including the fact that __.孟德尔的豌豆实验具有独特而重要的特点，其中包括</p><p>a. he studied traits that offered only two alternative outcomes<br>b. he followed and recorded the type and number of all offspring<br>c. he followed the results of each cross for two generations<br>✔d. all of the above<br>e. he used the test cross procedure for two generations</p></li><li><p>A plant that is heterozygous for a particular trait __. 杂合子一种特殊性状的杂合子植物</p><p>a. carries identical alleles for that trait<br>✔b. carries different alleles for that trait 携带不同的等位基因<br>c. can be distinguished from a homozygous plant by its phenotype<br>d. shows incomplete dominance<br>e. is none of the above</p></li><li><p>In modern terms Mendel’s first law states that __.用现代术语来说，孟德尔第一定律表明</p><p>✔a. during meiosis alleles of a gene segregate out at random在减数分裂期间，一个基因的等位基因会随机分离出来<br>b. homologous chromosomes pair during meiosis<br>c. chromosomes move in a predetermined manner<br>d. recessive genes are only evident in the homozygous phenotype<br>e. dominant genes are only evident in the homozygous phenotype</p></li><li><p>Hereditary factors determining green seedcolor and yellow seed color are examples of __. 决定绿色种子颜色和黄色种子颜色的遗传因素，例如</p><p>a. incomplete dominance<br>✔b. different alleles of the same gene 同一基因的不同等位基因<br>c. sex linkage .<br>d. two genes<br>e. sex chromosomes</p></li><li><p>If P represents a dominant allele and p a recessive allele for the same trait, a homozygous recessive individual will have the following genotype:__.如果P为显性等位基因，p为隐性等位基因，则纯合隐性个体具有以下基因型</p><p>a. PP<br>b. Pp<br>c. pP<br>✔d. pp<br>e. none of the above</p></li><li><p>According to Mendel’s laws, in a cross involving an individual that is homozygous dominant for a trait and an individual that is homozygous recessive for the same trait, __.根据孟德尔定律，一个个体在某一性状上是纯合显性的，另一个个体在同一性状上是纯合隐性的</p><p>a. the recessive trait will be present in a 1:3 ratio in the F1 phenotypes<br>✔b. the recessive trait will not be present in the F1 phenotypes 隐性性状在F1表现型中不存在<br>c. the recessive trait will be present in the F1 phenotypes more often than the dominant trait<br>d. the recessive trait will be present three times more often than the dominant trait in the F1 phenotypes</p></li><li><p>Mendel’s law of independent assortment states that__.孟德尔自由组合定律说</p><p>a. monohybrid crosses will show segregation and independent assortment<br>b. the segregation of alleles of one gene depends on the segregation of all other alleles<br>c. test crosses always produce heterozygous offspring<br>✔d. alleles of different genes segregate at random and fertilization is random 不同基因的等位基因随机分离，受精是随机的<br>e. alleles segregate at meiosis</p></li><li><p>In a cross between a homozygous plant bearing round yellow seeds and a homozygous plant bearing wrinkled green seeds, all the offspring had round yellow seeds. If R represents the round allele and Y the yellow allele, the F1 genotype was__.在一株结黄色圆形种子的纯合子植株和一株结皱绿色种子的纯合子植株的杂交中，所有的后代都结黄色圆形种子。若R代表圆形等位基因，Y代表黄色等位基因，则F1基因型为</p><p>a. RRYY<br>b. RRyy<br>c. RRyY<br>✔d. RrYy<br>e. Rryy</p></li><li><p>The punnett square was used by Mendel to 庞尼特形被孟德尔用来</p><p>✔a. predict the probabilities of different allele combinations 预测不同等位基因组合的概率<br>b. record the results of his test crosses<br>c. develop the idea of the dihybrid cross<br>d. disprove pangenesis<br>e. none of the above</p></li><li><p>A dihybrid cross is a mating between two organisms 杂交是指两种生物交配</p><p>a. when at least one is heterozygous for two traits<br>✔b. when both are heterozygous for two traits 当两种性状都是杂合子时<br>c. when one is homozygous and one is heterozygous for a trait<br>d. when both are homozygous for a single trait</p></li><li><p>For some specific traits the phenotypes of offspring are intermediate between those of the parents’ traits. This is a case of 对于某些特定性状，后代的表现型介于父母的表现型之间。这是一个例子</p><p>a. blending<br>b. linkage<br>✔c. incomplete dominance 不完全显性<br>d. intermediate inheritance<br>e. none of the above</p></li><li><p>Sutton and Boveri proposed that Mendel’s hereditary factors were located on chromosome,in a theory known as Sutton和Boveri提出孟德尔的遗传因子位于染色体上，在一个被称为</p><p>a. pangenesis<br>b. germ plasm theory<br>✔c. chromosomal theory of inheritance 染色体遗传理论<br>d. independent assortment<br>e. blending theory of inheritance</p></li><li><p>Sex chromosomes were first discovered in 性染色体最早发现于</p><p>a. peas<br>b. Manx cats<br>c. frizzle chickens<br>✔d. fruit flies 果蝇<br>e. humans</p></li><li><p>Sex-linked traits are 位于性染色体的特征是</p><p>✔a. traits carried on sex chromosomes 性状由性染色体携带<br>b. traits only found in one sex<br>c. traits found in female fruit flies<br>d. traits carried only on the Y chromosome<br>e. none of the above</p></li><li><p>Nondisjunction describes. 不分离描述</p><p>a. the movement of chromosomes to opposite poles of the cell during anaphase<br>✔b. the failure of homologous chromosomes to segregate during mitosis or meiosis 在有丝分裂或减数分裂过程中同源染色体分离失败<br>c. the failure of two new daughter cells to separate after mitosis<br>d. the process of crossing over during meiosis<br>e. none of the above</p></li><li><p>In fruit fies the following genotypes will produce a female 在果蝇中，下列基因型将产生雌性</p><p>a. YY<br>b. YO<br>c.XY.<br>d. XO<br>✔e. XX</p></li><li><p>A gamete showing a new association of alleles that differs from the parental associations is known as 一个配子显示出不同于亲本配子的新的等位基因组合称为配子</p><p>✔a. a recombinant type 一种重组<br>b. a crossing-over type<br>c. an incomplete dominant<br>d. a heterozygote<br>e. a homozygote</p></li></ol><h2 id="第五章"><a class="header-anchor" href="#第五章"></a>第五章</h2><ol><li>Replication fork 复制叉 → start of DNA replication DNA复制的开始</li><li>cytosine  胞嘧啶 → a DNA base</li><li>Okazaki fragment 冈崎片段 → small piece of DNA</li><li>X-ray diffraction  X射线衍射 → photographic process</li><li>nucleoside 核苷 → a base plus a sugar 碱基加糖</li><li>semiconservative replication 半保留复制 → unwinding must occur 解旋必须发生</li><li>5’ to 3’ direction → DNA chain lengthens</li><li>Chargaf’s rules → A=T</li><li>base → ring structure composed of carbon and nitrogen 由碳和氮组成的环状结构</li><li>double helix 双螺旋 →  shape proposed by Watson and Crick</li></ol><hr><ol><li>✔Hershey and Chase showed that genes are composed of DNA.研究表明，基因是由DNA组成的。</li><li>✔Complementation test can be used to study metabolic pathways.互补试验可用于研究代谢途径</li><li>❌Feulgen staining works on cell walls.富尔根染色作用于细胞壁。</li><li>❌Robert Feulgen discovered nucleic acid.罗伯特·福尔根发现了核酸。</li><li>✔Phages are made only of DNA and a protein coat.噬菌体仅由DNA和蛋白质外壳组成。</li><li>✔Dispersive replication requires breakage.分散复制需要破坏。</li><li>❌Not all organisms exhibit semiconservative replication.不是所有的生物都表现出半保留复制。</li><li>❌Auxotrophs are mutant Neurospora.营养缺陷体是变异脉孢菌。</li><li>✔Virulent pneumonia bacteria secrete a capsule.强毒性肺炎细菌分泌一种胶囊。</li><li>❌Watson and Crick did not make use of X-ray diffraction data.沃森和克里克没有利用x射线衍射数据。</li><li>✔The sequence of bases on the DNA molecule carries the genetic information.DNA分子上的碱基序列携带着遗传信息。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IV. Multiple Choice</span><br><span class="line">1. a 2. c 3. b 4. a 5. b 6. d 7. c</span><br><span class="line">8. c 9. b 10. c 11. d 12. e 13. e 14. b</span><br><span class="line">15. e 16. b 17. d 18. d 19. e 20. b</span><br></pre></td></tr></table></figure><h2 id="第八章"><a class="header-anchor" href="#第八章"></a>第八章</h2><ol><li>yolk 卵黄  → food</li><li>amnion 羊膜  → cushions embryo 缓冲胚胎</li><li>regeneration 重生  → replacement of lost parts</li><li>parthenogenesis 单性生殖 → “virgin”birth</li><li>cleavage 卵裂 → divides a single-celled zygote into many small cells 将单细胞合子分成许多小细胞</li><li>zygote 受精卵 → fertilized egg</li><li>chorion 绒毛膜 → fuses with allantois</li><li>testis → homologous with ovaries</li><li>cortical reaction 皮质反应 →  prevents multiple fertilizations</li><li>ovum 卵 → gamete or egg</li><li>primitive streak 原条 → 与蛋黄有关</li><li>blastomere 分裂球 → individual blastula cells</li><li>allantois → trash dump</li><li>oviduct 输卵管 → egg tube</li><li>gonial cell → spermatogonia 精原细胞</li></ol><hr><ol><li>✔Sertoli cells are helper cells in sperm production.支持细胞是精子生产中的辅助细胞。</li><li>❌The sperm head contains a small number of mitochondria. 精子头部含有少量的线粒体。</li><li>✔Oogenesis may be arrested for years in some species.在某些物种中卵子发生可能被抑制数年</li><li>✔An ostrich egg can be considered a single cell.鸵鸟蛋可以被认为是一个单细胞。</li><li>❌Chromosomes in the “lamp brush” phase produce little mRNA.</li><li>✔The acrosome reaction is triggered by the egg’s jelly coat.顶体反应是由卵的胶膜触发的。</li><li>❌Prior to fertilization, the egg’s electrical charge is positive.在受精之前，卵子的电荷是正电荷。</li><li>✔Parthenogenesis produces only females.孤雌生殖只产生雌性。</li><li>✔The so-called “vegetable pole” contains the most yolk.所谓的“植物极”含有最多的蛋黄。</li><li>✔The gut cavity is derived from an archenteron.肠道由原肠演变而来。</li><li>❌A mphioxus eggs show a prominent primitive streak.斑马鱼的卵显示出明显的原始条纹。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IV. Multiple Choice</span><br><span class="line">1. c 2. a 3. e 4. c 5. d 6. b 7. d</span><br><span class="line">8. b 9. c 10. b 11. b 12. c 13. b 14. b</span><br><span class="line">15. c 16. d 17. d 18. e 19. c 20. d</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">仅供参考</summary>
    
    
    
    <category term="生物学" scheme="http://halo123.top/categories/%E7%94%9F%E7%89%A9%E5%AD%A6/"/>
    
    
    <category term="专业英语" scheme="http://halo123.top/tags/%E4%B8%93%E4%B8%9A%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>组培资料</title>
    <link href="http://halo123.top/2020/12/25/%E7%94%9F%E7%89%A9%E5%AD%A6/%E7%BB%84%E5%9F%B9%E8%B5%84%E6%96%99/"/>
    <id>http://halo123.top/2020/12/25/%E7%94%9F%E7%89%A9%E5%AD%A6/%E7%BB%84%E5%9F%B9%E8%B5%84%E6%96%99/</id>
    <published>2020-12-25T08:41:50.000Z</published>
    <updated>2021-04-24T11:42:34.584Z</updated>
    
    <content type="html"><![CDATA[<h2 id="绪论"><a class="header-anchor" href="#绪论"></a>绪论</h2><h3 id="简述植物组织培养的理论依据？"><a class="header-anchor" href="#简述植物组织培养的理论依据？"></a>简述植物组织培养的理论依据？</h3><p>植物组织培养的理论依据是植物细胞的全能性。即植物每个细胞都携带有完整的全套遗传基因，并具有发育成完整植株的潜在能力。</p><h3 id="植物组织培养有哪些特点？"><a class="header-anchor" href="#植物组织培养有哪些特点？"></a>植物组织培养有哪些特点？</h3><ol><li>培养条件可以人为控制。组织培养采用的植物材料完全是在人为提供的培养基和小气候环境条件下进行生长，摆脱了大自然中四季、昼夜的变化以及灾害性气候的不利影响，且条件均一，对植物生长极为有利，便于稳定地进行周年培养生产。</li><li>生长周期短，繁殖率高。植物组织培养是由于人为控制培养条件，根据不同植物不同部位的不同要求而提供不同的培养条件，因此生长较快。另外，植株也比较小，往往20-30天为一个周期。</li><li>管理方便，利于工厂化生产和自动化控制。植物组织培养是在一定的场所和环境下，人为提供一定的温度、光照、湿度、营养、激素等条件，极利于高度集约化和高密度工厂化生产，也利于自动化控制生产。它是未来农业工厂化育苗的发展方向。它可以大大节省人力、物力及田间种植所需要的土地。</li></ol><h3 id="植物组织培养的分类？"><a class="header-anchor" href="#植物组织培养的分类？"></a>植物组织培养的分类？</h3><ol><li>按培养对象分为：植株培养；胚胎培养；器官培养；组织培养；细胞培养；原生质体培养；</li><li>按培养过程分：初代培养；继代培养；</li><li>根据再生途径分为：愈伤组织途径；芽增殖途径；原球茎途径；体胚发生途径；</li><li>根据培养基的物理状态：固体培养；液体培养。</li></ol><h3 id="植物组织培养主要应用于哪些方面？"><a class="header-anchor" href="#植物组织培养主要应用于哪些方面？"></a>植物组织培养主要应用于哪些方面？</h3><ol><li>快速繁殖  运用组织培养的途径，一个单株一年可以繁殖几万到几百万个植株；</li><li>种苗脱毒  针对病毒对农作物造成的严重危害，通过组织培养可以有效地培育出大量的无病毒种苗；</li><li>培育和创制新品种  利用组织培养可以使难度很大的远缘杂交取得成功，从而育成一些罕见的新物种；</li><li>大量生产次生代谢物质  通过植物细胞培养获得的生物碱、维生素、色素、抗生素以及抗肿瘤药物不下50多个大类，其中已有30多种次生物质的含量在人工培养时已达到或超过亲本植物的水平。植物细胞次生物质的研制与生产硕果累累，后来居上。</li><li>植物种质资源的离体保存  植物组织培养结合超低温保存技术，可以给植物种质保存带来一次大的飞跃。因为保存一个细胞就相当于保存一粒种子，但所占的空间仅为原来的几万分之一，而且在-193度的液氮中可以长时间保存，不像种子那样需要年年更新或经常更新。</li><li>人工种子  人工种子便于贮藏和运输，适合机械化播种；繁殖速度快，不受季节和环境限制，利于工厂化生产； 体细胞胚由无性繁殖体系产生，可以固定杂种优势。</li></ol><h2 id="组培的基本技术"><a class="header-anchor" href="#组培的基本技术"></a>组培的基本技术</h2><h3 id="论述植物生长调节物质在组织培养中的作用？-并列举常见的种类"><a class="header-anchor" href="#论述植物生长调节物质在组织培养中的作用？-并列举常见的种类"></a>论述植物生长调节物质在组织培养中的作用？ 并列举常见的种类</h3><p>植物生长物质是培养基中不可缺少的关键物质，用量虽少，但它们对外植体愈伤组织的诱导和根、芽等器官分化，起着重要和关键的调节作用。<br>常见的种类有：</p><ol><li>生长素类：主要被用于诱导愈伤组织形成，促进细胞脱分化；促进细胞伸长；诱导根的分化，促进生根。吲哚乙酸（IAA）、吲哚丁酸（IBA）、萘乙酸（NAA）、2,4-二氯苯氧乙酸（2,4-D）</li><li>细胞分裂素类：诱导芽的分化促进侧芽萌发生长；促进细胞分裂与扩大；抑制根的分化；抑制衰老，减少叶绿素分解，有保鲜效果。激动素（KT）、异戊烯基腺嘌呤（z-iP）、6-苄基腺嘌呤（BAP、6-BA）、玉米素（Zt）、TDZ</li><li>赤霉素（GA3）</li><li>脱落酸（ABA）</li></ol><h3 id="常用的培养基有哪些？说明其特点"><a class="header-anchor" href="#常用的培养基有哪些？说明其特点"></a>常用的培养基有哪些？说明其特点</h3><ol><li>MS培养基:1962年由 Murashige 和Skoog为培养烟草细胞而设计的。是目前应用最广泛的培养基。特点是无机盐离子浓度较高；</li><li>white 培养基:无机机盐浓度较低，适于生根培养；</li><li>N6培养基: KNO3 和(NH4) 2S04含量高，不含钼。广泛应用于禾谷类植物的花粉和花药培养；</li><li>B5培养基:主要特点是含有较低的铵盐，较高的硝酸盐和盐酸硫胺素。适宜双子叶植物特别是木本植物的培养；</li><li>M- -8P培养基:为原生质体培养而设计的。其特点是有机成分较复杂，它包括了所有的单糖和维生素。</li></ol><h3 id="接种后离体培养物对光、温、湿等环境条件的要求？"><a class="header-anchor" href="#接种后离体培养物对光、温、湿等环境条件的要求？"></a>接种后离体培养物对光、温、湿等环境条件的要求？</h3><ol><li>光照:愈伤组织的诱导不需光照或弱光，器官分化需要光照，一般12- 16h/d，光照度1000 - 50001x;</li><li>温度：一般25士2℃</li><li>湿度:培养室内的湿度要求保持70%一80%的相对湿度。</li></ol><h3 id="论述离体培养污染产生的原因及防治措施。"><a class="header-anchor" href="#论述离体培养污染产生的原因及防治措施。"></a>论述离体培养污染产生的原因及防治措施。</h3><p>污染：污染原因从病源分面主要有细菌和真菌和两大类。<br>产生原因：</p><ol><li>外植体材料消毒不彻底</li><li>培养基灭菌不彻底</li><li>操作环境不洁净</li><li>操作人员操作不规范、不熟练。</li></ol><p>防止措施：</p><ol><li>减少或防止材料带菌</li><li>外植体灭菌要彻底</li><li>培养基灭菌要彻底</li><li>玻璃器皿和金属器皿的灭菌要彻底</li><li>无菌室的消毒</li><li>操作人员一定要严格按照无菌操作的程序进行接种</li></ol><h3 id="植物组织培养技术主要包括哪些环节？"><a class="header-anchor" href="#植物组织培养技术主要包括哪些环节？"></a>植物组织培养技术主要包括哪些环节？</h3><ol><li>培养基的配制及灭菌</li><li>外植体的选择及灭菌</li><li>外植体的接种及培养</li><li>试管苗的驯化与移栽</li></ol><h3 id="无菌操作时应注意哪些事项？"><a class="header-anchor" href="#无菌操作时应注意哪些事项？"></a>无菌操作时应注意哪些事项？</h3><ol><li>在接种4h前用甲醛熏蒸接种室;</li><li>在接种前15-20min,打开超净工作台的风机以及台上的紫外灯;</li><li>接种员先洗净双手，在实验前换好专用实验服;</li><li>到超净台后，用酒精棉球擦拭双手，特别是指甲处。然后用70%酒精擦拭工作台面:</li><li>接种工具蘸95%酒精，灼烧;</li><li>接种时将试管斜着，使试管口在酒精灯火焰上转动，灼烧数秒钟。接完种后，将管口在火焰上再灼烧数秒钟。</li><li>接种时，接种员双手不能离开工作台，不能说话、走动和咳嗽等;</li><li>接种完毕后要清理干净并用酒精擦工作台。</li></ol><h3 id="在植物组织培养中，通过哪些途径可以得到完整的植株？"><a class="header-anchor" href="#在植物组织培养中，通过哪些途径可以得到完整的植株？"></a>在植物组织培养中，通过哪些途径可以得到完整的植株？</h3><ol><li><p>外植体→愈伤组织一根、芽→试管苗</p><p>①同时长芽和根    ②先长芽，再长根    ③先长根，再长芽</p></li><li><p>外植体→胚状体→试管苗</p></li><li><p>外植体→根、芽→试管苗。</p></li></ol><h2 id="基本原理"><a class="header-anchor" href="#基本原理"></a>基本原理</h2><h3 id="愈伤组织细胞的分化一般分几个时期？各有何特点？"><a class="header-anchor" href="#愈伤组织细胞的分化一般分几个时期？各有何特点？"></a>愈伤组织细胞的分化一般分几个时期？各有何特点？</h3><ol><li>诱导期：是细胞准备分裂的时期。细胞大小几不变，内部发生生理生化变化，迅速合成蛋白质和核酸。</li><li>分裂期：外层细胞分裂，中间细胞常不分裂，形成小芯。细胞分裂快，结构疏松，缺少结构，浅而透明。在原培养基上，细胞必分化，及时转移，其可无限制地进行细胞分裂，维持不分化状态。</li><li>分化期：细胞在形态和生理功能上的分化，出现形态和功能各异的细胞。</li></ol><h3 id="优良的愈伤组织必须具备哪4个特性？"><a class="header-anchor" href="#优良的愈伤组织必须具备哪4个特性？"></a>优良的愈伤组织必须具备哪4个特性？</h3><ol><li>高度的胚性或再分化能力，以便从这些愈伤组织得到再生植物。</li><li>容易散碎，以便用这些愈伤组织建立优良的悬浮系，并且在需要时能从中分离出全能性的原生质体</li><li>旺盛的自我增殖能力，以便用这些愈伤组织建立大规模的愈伤组织无性系</li><li>经过长期继代保存而不丧失胚性，便有可能对它们进行各种遗传操作。</li></ol><h3 id="愈伤组织的形态发生有哪些情况？"><a class="header-anchor" href="#愈伤组织的形态发生有哪些情况？"></a>愈伤组织的形态发生有哪些情况？</h3><ol><li><p>愈伤组织仅有根或芽器官的分别形成，即无根的芽或无芽的根；</p></li><li><p>先形成芽，再在芽伸长后，在其茎的基部长出根而形成小植株，多数植物属这种情况；</p></li><li><p>先产生根，再从根基部分化出芽而形成小植株。这种情况较难诱导芽的形成，尤其对于单子叶植物少见；</p></li><li><p>先在愈伤组织的邻近不同部位分别形成芽和根，然后两者结合起来形成一株小植株。</p><p>单子叶植物：与双子叶植物诱导发生过程类似，只是在形态上无鱼雷形胚等阶段，成熟体胚上有盾片、胚芽鞘和胚根等结构。</p></li></ol><h3 id="简述细胞脱分化过程。"><a class="header-anchor" href="#简述细胞脱分化过程。"></a>简述细胞脱分化过程。</h3><p>细胞的脱分化过程可分为3个阶段：</p><ol><li>第一阶段为启动阶段，表现为细胞质增生，并开始向细胞中央伸出细胞质丝，液泡蛋白体出现；</li><li>第二阶段为演变阶段，此时细胞核开始向中央移动，质体演变成原质体；</li><li>第三阶段是脱分化终结阶段，此时细胞回复到分生细胞状态，细胞分裂即将开始</li></ol><h3 id="胚状体发生途径与器官发生途径形成植株的区别"><a class="header-anchor" href="#胚状体发生途径与器官发生途径形成植株的区别"></a>胚状体发生途径与器官发生途径形成植株的区别:</h3><ol><li>胚状体具有两极性， 即在发育的早期阶段， 从其方向相反的两端 分化出茎端和根端;而不定芽和不定根<br>都为单向极性。</li><li>胚状体的维管组织与外植体的维管组织无解剖结构上的联系。而不定芽或不定根往往总是与愈伤组织的<br>维管组织相联系。</li><li>胚状体维管组织的分布是独立的“Y”字形。而不定芽的维管组织无此现象。</li></ol><h2 id="胚胎培养及离体授粉"><a class="header-anchor" href="#胚胎培养及离体授粉"></a>胚胎培养及离体授粉</h2><h3 id="胚培养的作用有哪些？"><a class="header-anchor" href="#胚培养的作用有哪些？"></a>胚培养的作用有哪些？</h3><ol><li>在远缘杂交育种中的应用，克服杂种胚不能正常发育</li><li>克服珠心胚的干扰，提高育种效率</li><li>缩短育种周期</li><li>测定休眠种子的萌发率</li><li>理论研究中的应用</li></ol><h3 id="简述离体授粉的程序"><a class="header-anchor" href="#简述离体授粉的程序"></a>简述离体授粉的程序</h3><ol><li>确定开花、花药开裂及授粉时间</li><li>去雄后将花蕾套袋隔离</li><li>制备无菌子房或胚珠</li><li>制备无菌花粉</li><li>胚珠或子房的试管内授粉</li></ol><h3 id="胚胎培养的操作步骤"><a class="header-anchor" href="#胚胎培养的操作步骤"></a>胚胎培养的操作步骤</h3><ol><li>取子房</li><li>常规表面消毒</li><li>解剖镜下，取胚珠、去珠被、取出完整幼胚</li><li>固体培养</li></ol><h3 id="幼胚的发育方式"><a class="header-anchor" href="#幼胚的发育方式"></a>幼胚的发育方式</h3><ol><li>胚性发育:继续进行正常的胚胎发育</li><li>早熟发育:迅速萌发成幼苗</li><li>产生愈伤组织:再分化形成多个胚状体或芽原基。</li></ol><h3 id="胚胎培养的意义"><a class="header-anchor" href="#胚胎培养的意义"></a>胚胎培养的意义</h3><ol><li>克服远缘杂种的不育性</li><li>使胚胎发育不完全的植株获得后代</li><li>缩短育种年限，提高育种效率</li></ol><h2 id="花药和花粉培养"><a class="header-anchor" href="#花药和花粉培养"></a>花药和花粉培养</h2><h3 id="如何确定水稻单核靠边期的花粉？"><a class="header-anchor" href="#如何确定水稻单核靠边期的花粉？"></a>如何确定水稻单核靠边期的花粉？</h3><ol><li>在水稻中，在外部形态上可根据叶枕距为5-15cm，颖片淡黄绿色、雄蕊长度接近颖片长度的1/2这些条件鉴定。</li><li>利用这些外部标志，选择符合条件的花蕾，经镜检确定花粉发育的准确时期。</li><li>压片染色法是检测划分发育时期的简便有效方法，常用染色剂为醋酸洋红。</li></ol><h3 id="比较花粉培养与花药培养"><a class="header-anchor" href="#比较花粉培养与花药培养"></a>比较花粉培养与花药培养</h3><p>相同点：</p><ol><li>利用小孢子染色体数目的单倍性，培育出单倍体植株。</li><li>成苗途径相同，即有 胚状体成苗 和 愈伤组织再分化成苗两条途径。</li></ol><p>不同点：</p><ol><li>花药培养属于器官培养；而花粉培养属于细胞培养。</li><li>花粉培养可避免花药壁，花丝和药隔的等体细胞组织的干扰；可计数小孢子产胚率；可观察和更好调节控制雄核发育的全过程；花粉量大，具有单细胞，单倍性和较高的同步性。但技术更复杂。</li></ol><h3 id="简述花粉分离方法"><a class="header-anchor" href="#简述花粉分离方法"></a>简述花粉分离方法</h3><ol><li>自然散落法(漂浮培养散落小孢子收集法)将 花药接种在预处理液或液体培养基上，待花粉自动散落后，收集培养。</li><li>挤压法在烧杯或研钵中挤压花药，将花粉挤出后收集培养。</li><li>机械游离<ul><li>磁搅拌法  用磁力搅拌器搅拌培养液中的花药，使花粉游离出来;</li><li>超速旋切法通过搅拌器 中的高速旋转刀具破碎花蕾、穗子、花药，使小孢子游离出来</li></ul></li></ol><h2 id="细胞培养"><a class="header-anchor" href="#细胞培养"></a>细胞培养</h2><h3 id="如何得到单细胞无性系？"><a class="header-anchor" href="#如何得到单细胞无性系？"></a>如何得到单细胞无性系？</h3><p>在细胞培养中，常由分散性较好的愈伤组织或悬浮培养物来制备单细胞，也可以用机械法和酶解法从植物器官直接制备单细胞。<br>由分离的单细胞经看护培养法、微室培养法或平板培养法，即可得到单细胞无性系。</p><h3 id="单细胞培养有哪些方法？各有何含义及特点"><a class="header-anchor" href="#单细胞培养有哪些方法？各有何含义及特点"></a>单细胞培养有哪些方法？各有何含义及特点</h3><p>单细胞培养：看护培养；微室培养；平板培养</p><ol><li>看护培养法：指用一块活跃生长的愈伤组织块来看护单个细胞，并使其生长和增殖的方法。<br>特点：优点：①简便易行 ②效果好，易于成功。<br>缺点：不能在显微镜下直接观察细胞的生长过程。<br>用途：诱导形成单细胞系。</li><li>微室培养法：即将细胞培养在很少量的培养基中。<br>特点：优点：在培养过程中，可以连续进行显微观察一个细胞的生长、分裂和形成细胞团的全部过程<br>缺点：培养时间较短<br>用途：主要用来观察细胞生长、分裂、形成细胞团的过程。</li><li>平板培养法：把单细胞悬浮液与融化的琼脂培养基均匀混合，平铺一薄层在培养基底上的培养方法。<br>特点：优点：①可以定点观察;②分离单细胞系容易;<br>缺点：培养细胞气体交换不畅。<br>用途：分离单细胞无性系，研究其生理、生化、遗传上的差异而设计的一种单细胞培养技术。广泛应用于细胞、原生质体及融合产物的培养。</li></ol><h3 id="什么是植板率？小细胞团的计数方法有哪几种？"><a class="header-anchor" href="#什么是植板率？小细胞团的计数方法有哪几种？"></a>什么是植板率？小细胞团的计数方法有哪几种？</h3><p>植板率是指已形成细胞团的单细胞与接种总细胞数的百分数。<br>小细胞团计数方法:</p><ol><li>低倍显微镜直接计算;</li><li>细胞团显影法</li></ol><h3 id="什么是细胞悬浮培养？简述成批培养和连续培养的的特点？"><a class="header-anchor" href="#什么是细胞悬浮培养？简述成批培养和连续培养的的特点？"></a>什么是细胞悬浮培养？简述成批培养和连续培养的的特点？</h3><p>细胞悬浮培养:是使离体的植物细胞悬浮在液体培养基中进行的无菌培养。</p><ol><li>成批培养的特点:<ul><li>细胞生长在固定体积的培养基上，直至养分耗尽；</li><li>用搅拌的方法使细胞团和细胞均匀分布；</li><li>细胞数目呈现慢-快一慢一停止生长的变化，但必须更换新鲜培养基才能进行下一批培养。</li></ul></li><li>连续培养的特点:<ul><li>由于不断加入新鲜培养基，保证了养分的充分供应，不会出现悬浮培养物发生营养不足的现象；</li><li>可在培养期间使细胞保持在对数生长期中。细胞增殖速度快；</li><li>适于大规模工业化生产。</li></ul></li></ol><h3 id="细胞悬浮培养主要应用"><a class="header-anchor" href="#细胞悬浮培养主要应用"></a>细胞悬浮培养主要应用</h3><ol><li>植物有用物质的生产：在植物组织培养研究中，发现培养细胞中含有各种特殊的代谢产物。</li><li>诱发和筛选突变体：在细胞培养过程中会产生一些突变体，常采用不同培养基来进行选择，也就是把悬浮细胞培养于缺少某种营养物质或生长因子，或是添加某种抑制剂的培养基里，使突变细胞和正常细胞区别开来</li><li>原生质体培养和细胞分离：利用细胞悬浮培养方法，对细胞原生质进行分离，在适宜的培养基上进行培养，使之生成完整植株，或对原生体的生理特性进行观察研究。</li><li>食品生产：通过对许多食用植物培养组织的细胞团生产的研究。</li></ol><h2 id="原生质体培养和细胞融合"><a class="header-anchor" href="#原生质体培养和细胞融合"></a>原生质体培养和细胞融合</h2><h3 id="简述原生质体作为遗传操作和生理生化研究的材料有何特点？"><a class="header-anchor" href="#简述原生质体作为遗传操作和生理生化研究的材料有何特点？"></a>简述原生质体作为遗传操作和生理生化研究的材料有何特点？</h3><ol><li>没有细胞壁，有利于体细胞融合、体细胞杂交、基因转移和单细胞培养。</li><li>原生质体能比较容易摄取外来的遗传物质。</li></ol><h3 id="酶法分离原生质体时使用的酶的种类有哪些？"><a class="header-anchor" href="#酶法分离原生质体时使用的酶的种类有哪些？"></a>酶法分离原生质体时使用的酶的种类有哪些？</h3><p>常用的细胞壁降解酶种类：纤维素酶、半纤维素酶、果胶酶、果酸酶等。</p><h3 id="简述一步酶法分离原生质体的方法"><a class="header-anchor" href="#简述一步酶法分离原生质体的方法"></a>简述一步酶法分离原生质体的方法</h3><p>一步分离法:把一定量纤维素酶和果胶酶组成混合酶液，对材料进行一次性处理而分离出原生质体。处理温度25-30℃，处理的时间根据材料及酶浓度的不同而不同，可为2-24h。</p><h3 id="如何纯化分离的植物原生质体并鉴定其活力？"><a class="header-anchor" href="#如何纯化分离的植物原生质体并鉴定其活力？"></a>如何纯化分离的植物原生质体并鉴定其活力？</h3><ol><li>原生质体的纯化<ul><li>沉降法：应用原生质体的比重大于溶液的性质而使原生质体沉于底部。</li><li>漂浮法：应用渗透剂含量较高的洗涤液使原生质体漂浮于液体表面。</li><li>梯度离心法：选两种不同渗透浓度的溶液，其中一种溶液密度大于原生质体的密度，另一种溶液小于原生质体的密度。</li></ul></li><li>原生质体活力的测定<ul><li>形态识别:形态上完整，呈圆形，含有饱满的细胞质，颜色鲜艳的即为存活的原生质体。</li><li>染色识别<ol><li>0.1%酚番红或Evans蓝染色：有活力的不被染色，死亡的被染上色。</li><li>双醋酸盐荧光素(FDA)染色法：在荧光显微镜下有荧光的即为有活性的原生质体。</li></ol></li></ul></li></ol><h3 id="原生质体培养的方法有哪些？"><a class="header-anchor" href="#原生质体培养的方法有哪些？"></a>原生质体培养的方法有哪些？</h3><ol><li>液体浅层培养</li><li>平板法培养</li><li>微悬滴法培养</li><li>双层培养法</li><li>饲养层培养</li></ol><h3 id="原生质体融合有哪几种主要方法？"><a class="header-anchor" href="#原生质体融合有哪几种主要方法？"></a>原生质体融合有哪几种主要方法？</h3><ol><li>化学法诱导融合:硝酸盐溶液</li><li>PEG结合高钙-高pH诱导法:在无菌条件下混合双亲原生质体——滴加PEG溶液，摇匀，静置一—滴加高钙高pH溶液，摇匀，静置——滴加原生质体培养液洗涤数次——离心获得原生质体细胞团——筛选——再生杂合细胞。</li><li>电融合技术:将双亲原生质体悬浮溶液混合后插入微电极，接通一定的交变电场，原生质体极化后顺着电场排列成珠状，此时施与适当强度的电脉冲，使原生质体膜被击穿而发生融合。</li></ol><h2 id="植物离体快繁和人工种子"><a class="header-anchor" href="#植物离体快繁和人工种子"></a>植物离体快繁和人工种子</h2><h3 id="人工种子的优点。"><a class="header-anchor" href="#人工种子的优点。"></a>人工种子的优点。</h3><ol><li>使自然条件下不易结实或种子昂贵的材料能快速繁殖和保存；</li><li>繁殖速度快；</li><li>为基因工程技术应用于生产提供桥梁；</li><li>固定杂种优势；</li><li>提高植物抗逆性；</li><li>取代天然种子，节约粮食。</li></ol><ul><li>人工种子与试管苗相比，具有所用培养基量少、体积小、繁殖快、发芽成苗快、运输及保存方便的特点;</li><li>人工种子技术适用于难以保存的种质资源、遗传性状不稳定或育性不佳的珍稀林木繁殖;</li><li>人工种子可以克服营养繁殖造成的病毒积累，可以快速繁殖脱毒苗。</li></ul><h2 id="植物无病毒苗木培育"><a class="header-anchor" href="#植物无病毒苗木培育"></a>植物无病毒苗木培育</h2><h3 id="植物脱毒的主要方法有哪些？其主要原理是什么？"><a class="header-anchor" href="#植物脱毒的主要方法有哪些？其主要原理是什么？"></a>植物脱毒的主要方法有哪些？其主要原理是什么？</h3><ol><li>茎尖培养脱毒:病毒在植物体内的分布并不均匀，越靠近茎端的病毒的感染深度越低，生长点则几乎不含或含病毒很少</li><li>愈伤组织培养脱毒法:通过植物的器官和组织的培养，脱分化诱导产生愈伤组织，然后从愈伤组织再分化产生芽，长成小植株，可以得到无病毒苗</li><li>珠心胚培养脱毒:病毒一般不通过种子传播，由珠心细胞发育成的胚再生的植株是无毒的，并具有与母本相:同的遗传特性。</li><li>茎尖微体嫁接:将实生苗砧木在人工培养基上种植培育，再从成年无病树枝上切取0.4- -1.0mm茎尖，在砧木上进行试管 微体嫁接，以获得无病毒幼苗。</li><li>热处理脱毒:一些病毒对热不稳定，在高于常温的温度下(35-40C)，即钝化失活(6)化学处理脱毒:抑制或杀死病毒</li><li>化学处理脱毒：抑制或杀死病毒</li></ol><h3 id="说明微尖嫁接技术脱毒的程序"><a class="header-anchor" href="#说明微尖嫁接技术脱毒的程序"></a>说明微尖嫁接技术脱毒的程序</h3><p>微尖嫁接技术指在人工培养基上培养实生砧木，嫁接无病毒茎尖以培养脱毒苗的技术。<br>主要程序:无菌砧木培养——茎尖准备——嫁接——嫁接苗培养——移栽。</p><h3 id="目前鉴定脱毒苗的方法有哪些？各有何特点？"><a class="header-anchor" href="#目前鉴定脱毒苗的方法有哪些？各有何特点？"></a>目前鉴定脱毒苗的方法有哪些？各有何特点？</h3><ol><li>指示植物法:将一些对病毒反应敏感、症状特征显著的植物作为指示植物(又称鉴别寄主)，利用病毒在其他植物上产生的枯斑作为鉴别病毒种类的方法。这种方法条件简单，操作方便，为一种经济而有效的鉴定方法</li><li>抗血清鉴定法:用已知抗血清鉴定未知病毒的种类。这种方法特异性高，测定速度快。所以抗血清法成为植物病毒鉴定中最有用的方法之一。</li><li>电镜检查法:可以直接观察病毒，检查出有无病毒存在，了解病毒颗粒的大小、形状和结构，又可以鉴定病毒的种类。优点是方法先进、灵敏度高、能在植物粗提取液中定量测定病毒。但需一定的设备和技术。</li></ol><h3 id="简述植物无病毒原种长期保存的方法。"><a class="header-anchor" href="#简述植物无病毒原种长期保存的方法。"></a>简述植物无病毒原种长期保存的方法。</h3><ol><li>低温保存:将茎尖或小植株接种到培养基上，置低温(1-9℃)、低光照下保存。材料生长极缓慢，只需半年或一年更换一次培养基，又叫最小生长法。</li><li>冷冻保存(又叫超低温保存)，一般用液氮保存植物材料。在—169℃的低温下，植物材料新陈代谢活动基本停止，处于“生机停顿”状态。</li></ol><h3 id="植物脱毒的意义"><a class="header-anchor" href="#植物脱毒的意义"></a>植物脱毒的意义</h3><ol><li>能够有效地保持优良品种的特性</li><li>快速繁殖品种，使优良品种迅速应用</li><li>生产无病毒种苗，防止品种退化</li><li>节约耕地，提高农产品的商品率</li><li>便于运输</li></ol><h3 id="种质保存"><a class="header-anchor" href="#种质保存"></a>种质保存</h3><h3 id="低温保存和超低温保存技术冷冻的方法"><a class="header-anchor" href="#低温保存和超低温保存技术冷冻的方法"></a>低温保存和超低温保存技术冷冻的方法</h3><ul><li>快速冷冻法</li><li>冷冻前的预处理</li><li>解冻方法</li><li>重新培养</li></ul><h3 id="冷冻保存的应用前景"><a class="header-anchor" href="#冷冻保存的应用前景"></a>冷冻保存的应用前景</h3><ol><li>长期保存种质的遗传稳定性。</li><li>长期保存去病毒的种质。</li><li>保持稀有珍贵及濒危植物的种质资源。</li><li>保持不稳定性的培养物，如单倍体。</li><li>保持培养细胞形态发生的能力。</li><li>防止种质衰老。</li><li>延长花粉寿命，解决不同开花期和异地植物杂交上的困难。</li><li>冷冻解冻过程可筛选抗逆新品种。</li><li>便于国际间的种质交换。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;绪论&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#绪论&quot;&gt;&lt;/a&gt;绪论&lt;/h2&gt;
&lt;h3 id=&quot;简述植物组织培养的理论依据？&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#简述植物组织培养的理论依据？&quot;&gt;&lt;/a&gt;简述植物</summary>
      
    
    
    
    <category term="生物学" scheme="http://halo123.top/categories/%E7%94%9F%E7%89%A9%E5%AD%A6/"/>
    
    
    <category term="植物组织培养" scheme="http://halo123.top/tags/%E6%A4%8D%E7%89%A9%E7%BB%84%E7%BB%87%E5%9F%B9%E5%85%BB/"/>
    
  </entry>
  
</feed>
