<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HALO</title>
  
  <subtitle>HALO</subtitle>
  <link href="http://halo123.top/atom.xml" rel="self"/>
  
  <link href="http://halo123.top/"/>
  <updated>2021-05-26T15:12:28.132Z</updated>
  <id>http://halo123.top/</id>
  
  <author>
    <name>HALO</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据的表示和运算</title>
    <link href="http://halo123.top/2021/05/26/ComputerComposition/B-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/"/>
    <id>http://halo123.top/2021/05/26/ComputerComposition/B-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/</id>
    <published>2021-05-26T11:56:05.000Z</published>
    <updated>2021-05-26T15:12:28.132Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数制与编码"><a class="header-anchor" href="#数制与编码"></a>数制与编码</h2><p>在计算机系统内部，所有的信息都是用二进制进行编码的，这样做的原因有以下几点。</p><ol><li>二进制只有两种状态，使用有两个稳定状态的物理器件就可以表示二进制数的每一位，制造成本比较低，例如用高低电平或电荷的正负极性都可以很方便地表示 0 和 1。</li><li>二进制位 1 和 0 正好与逻辑值“真”和“假”对应，为计算机实现逻辑运算和程序中的逻辑判断提供了便利条件。</li><li>二进制的编码和运算规则都很简单，通过逻辑门电路能方便地实现算术运算。</li></ol><h3 id="进位计数法"><a class="header-anchor" href="#进位计数法"></a>进位计数法</h3><p>进位计数法是一种计数的方法。常用的进位计数法有十进制、二进制、八进制、十六进制等。十进制数是日常生活中最常使用的，而计算机中通常使用二进制数、八进制数和十六进制数。</p><p>在进位计数法中，每个数位所用到的不同数码的个数称为基数。十进制的基数为 10（0 ~ 9），每个数位计满 10 就向高位进位，即“逢十进一”。十进制数 101，其个位的 1 显然与百位的 1 所表示的数值是不同的。每个数码所表示的数值等于该数码本身乘以一个与它所在数位有关的常数，这个常数称为位权。一个进位数的数值大小就是它的各位数码按权相加。</p><p>一个 $r$ 进制数（$K_{n} K_{n-1} \cdots K_{0} K_{-1} \cdots K_{-m}$）的数值可表示为：$$K_{n} r^{n}+ K_{n-1} r^{n-1} + \cdots + K_{0} r^{0} + K_{-1} r^{-1} + \cdots + K_{-m} r^{-m} = \sum_{i=n}^{-m} K_{i} r^{i}$$式中，$r$ 是基数；$r^{i}$ 是第 $i$ 位的位权（整数位最低规定为第 0 位）；$K_{i}$ 的取值可以是 $0,1,\cdots,r-1$ 共 $r$ 个数码中的任意一个。</p><ul><li>二进制。计算机中用得最多的是基数为 2 的计数制，即二进制。二进制只有 0 和 1 两种数字符号，计数“逢二进一”。它的任意数位的权为 $2^{i}$, $i$ 为所在位数。</li><li>八进制。八进制作为二进制的一种书写形式，其基数为 8，有 0 ~ 7 共 8 个不同的数字符号，计数“逢八进一”。因为 $r=8=2^{3}$,所以只要把二进制中的 3 位数码编为一组就是一位八进制数码，两者之间的转换极为方便。</li><li>十六进制。十六进制也是二进制的一种常用书写形式，其基数为 16,“逢十六进一”。 每个数位可取 0 ~ 9、A、B、C、D、E、F 中的任意一个，其中 A、B、C、D、E、F 分别表示 10 ~ 15。因为 $r=16=2^{4}$，因此 4 位二进制数码与 1 位十六进制数码相对应。</li></ul><h3 id="不同进制数之间的相互转换"><a class="header-anchor" href="#不同进制数之间的相互转换"></a>不同进制数之间的相互转换</h3><p>1、<strong>二进制数转为八进制数和十六进制数</strong></p><p>对于一个二进制混合数（既包含整数部分，又包含小数部分），在转换时应以小数点为界。</p><ul><li>其整数部分，从小数点开始往左数，将一串二进制数分为 3 位（八进制）一组或 4 位（十六进制）一组，在数的最左边可根据需要加“0”补齐；</li><li>对于小数部分，从小数点开始往右数，也将一串二进制数分为 3 位一组或 4 位一组，在数的最右边也可根据需要加“0”补齐。最终使总的位数为 3 或 4 的整数倍，然后分别用对应的八进制数或十六进制数取代。</li></ul><p>同样，由八进制数或十六进制数转换成二进制数， 只需将每位改为 3 位或 4 位二进制数即可（必要时去掉整数最高位或小数最低位的 0）。</p><p>八进制数和十六进制数之间的转换也能方便地实现，十六进数制转换为八进制数（或八进制数转换为十六进制数）时，先将十六进制（八进制）数转换为二进制数，然后由二进制数转换为八进制（十六进制）数较为方便。</p><p>2、<strong>任意进制数转换为十进制数</strong></p><p>将任意进制数的各位数码与它们的权值相乘，再把乘积相加，就得到了一个十进制数。这种方法称为按权展开相加法。</p><p>3、<strong>十进制数转换为任意进制数</strong></p><p>一个十进制数转换为任意进制数，常采用基数乘除法。这种转换方法对十进制数的整数部分和小数部分将分别进行处理，对整数部分用除基取余法，对小数部分用乘基取整法，最后将整数部分与小数部分的转换结果拼接起来。</p><ul><li>除基取余法（整数部分的转换）：整数部分除基取余，最先取得的余数为数的最低位，最后取得的余数为数的最高位（即除基取余，先余为低，后余为高），商为 0 时结束。</li><li>乘基取整法（小数部分的转换）：小数部分乘基取整，最先取得的整数为数的最高位，最后取得的整数为数的最低位（即乘基取整，先整为高，后整为低），乘积为 1.0 （或满足精度要求）时结束。</li></ul><p>例如将十进制数 123.6875 转换成二进制数：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BB%BB%E6%84%8F%E8%BF%9B%E5%88%B6%E6%95%B0.png" alt="十进制数转换为任意进制数"></p><p>因此整数部分 123 = (1111011)<sub>2</sub> ，小数部分 0.6885 = (0.1011)<sub>2</sub> ，所以 123.6875 = (1111011.1011)<sub>2</sub></p><blockquote><p>注意：在计算机中，小数和整数不一样，整数可以连续表示，但小数是离散的，所以并不是每个十进制小数都可以准确地用二进制表示。例如 0.3，无论经过多少次乘二取整转换都无法得到精确的结果。但任意一个二进制小数都可以用十进制小数表示。</p></blockquote><h3 id="真值和机器数"><a class="header-anchor" href="#真值和机器数"></a>真值和机器数</h3><p>在日常生活中，通常用正号、负号来分别表示正数（正号可省略）和负数，如 +15、-8 等。这种带“+”或“-”符号的数称为真值。真值是机器数所代表的实际值。</p><p>在计算机中，通常采用数的符号和数值一起编码的方法来表示数据。常用的有原码、补码和反码表示法。这几种表示法都将数据的符号数字化，通常用“0”表示“正”，用“1”表示“负”。如 0,101 （这里的逗号“,”实际上并不存在，仅为区分符号位与数值位）表示 +5。这种把符号“数字化”的数称为机器数。</p><h3 id="BCD-码"><a class="header-anchor" href="#BCD-码"></a>BCD 码</h3><p>二进制编码的十进制数（Binary-Coded Decimal, BCD）通常采用 4 位二进制数来表示一位十进制数中的 0 ~ 9 这 10 个数码。这种编码方法使二进制数和十进制数之间的转换得以快速进行。但 4 位二进制数可以组合出 16 种代码，因此必有 6 种状态为冗余状态。</p><p>下面列举几种常用的 BCD 码：</p><ol><li>8421 码（最常用）。它是一种有权码，设其各位的数值为 $b_{3}$，$b_{2}$，$b_{2}$，$b_{0}$，则权值从高到低依次为 8，4，2，1，它表示的十进制数为 $D= 8b_{3} +4b_{2} + 2b_{1}+ 1b_{0}$。如 8 → 1000；9 → 1001。若两个 8421 码相加之和小于等于 (1001)<sub>2</sub> 即 (9)<sub>10</sub>，则不需要修正；若相加之和大于等于 (1010)<sub>2</sub> 即 (10)<sub>10</sub>，则要加 6 修正（从 1010 到 1111 这 6 个为无效码，当运算结果落于这个区间时，需要将运算结果加上 6），并向高位进位，进位可以在首次相加或修正时产生。<br><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/8421%E7%A0%81%E4%BF%AE%E6%AD%A3.png" alt="8421码修正"></li><li>余 3 码。这是一种无权码，是在 8421 码的基础上加 (0011)<sub>2</sub> 形成的，因每个数都多余“3”，因此称为余 3 码。如 8 → 1011；9 → 1100。</li><li>2421 码。这也是一种有权码，权值由高到低分别为 2，4，2，1，特点是大于等于 5 的 4 位二进制数中最高位为 1，小于 5 的最高位为 0。如 5 → 1011 而非 0101。</li></ol><h3 id="字符与字符串"><a class="header-anchor" href="#字符与字符串"></a>字符与字符串</h3><p>由于计算机内部只能识别和处理二进制代码，所以字符都必须按照一定的规则用一组二进制编码来表示。</p><p>1、<strong>字符编码 ASCII 码</strong></p><p>目前，国际上普遍采用的一种字符系统是 7 位二进制编码的 ASCII 码，它可表示 10 个十进制数码、52 个英文大写字母和小写字母（A ~ Z, a ~ z）及一定数量的专用符号（如 $、%、+、= 等），共 128 个字符。</p><p>在 ASCII 码中，编码值 0 ~ 31 为控制字符，用于通信控制或设备的功能控制；编码值 127 是 DEL 码；编码值 32 是空格 SP；编码值 32 ~ 126 共 95 个字符称为可印刷字符。</p><blockquote><p>提示: 0 ~ 9 的 ASCII 码值为 48 (011 0000) ~ 57 (011 1001)，即去掉高 3 位，只保留低 4 位，正好是二进制形式的 0 ~ 9。</p></blockquote><p>2、<strong>汉字的表示和编码</strong></p><p>在 1981 年的国家标准 GB 2312——1980 中，每个编码用两字节表示，收录了一级汉字 3755 个、二级汉字 3008 个、各种符号 682 个，共计 7445 个。</p><p>目前最新的汉字编码是 2000 年公布的国家标准 GB 18030，它收录了 27484 个汉字。编码标准采用 1 B、2 B 和 4 B。</p><p>汉字的编码包括汉字的输入编码、汉字内码、汉字字形码三种，它们是计算机中用于输入、内部处理和输出三种用途的编码。区位码是国家标准局于 1981 年颁布的标准，它用两字节表示一个汉字，每字节用七位码，并将汉字和图形符号排列在一个 94 行 94 列的二维代码表中。区位码是 4 位十进制数，前 2 位是区码，后 2 位是位码，所以称为区位码。</p><p>国标码将十进制的区位码转换为十六进制数后，再在每字节上加上 20 H。国标码两字节的最高位都是 0，ASCII 码的最高位也是 0。为了方便计算机区分中文字符和英文字符，将国标码两字节的最高位都改为“ 1 ”， 这就是汉字内码。</p><p>区位码和国标码都是输入码，它们和汉字内码的关系（十六进制）如下:</p><ul><li>国标码 = (区位码)<sub>16</sub> + 2020H</li><li>汉字内码 = (国标码)<sub>16</sub> + 8080H</li></ul><h3 id="校验码"><a class="header-anchor" href="#校验码"></a>校验码</h3><p>校验码是指能够发现或能够自动纠正错误的数据编码，也称检错纠错编码。校验码的原理是通过增加一些冗余码，来检验或纠错编码。</p><p>通常某种编码都由许多码字构成，任意两个合法码字之间最少变化的二进制位数，称为数据校验码的码距。对于码距不小于 2 的数据校验码，开始具有检错的能力。码距越大，检错、纠错的能力就越强，而且检错能力总是大于等于纠错能力。</p><h4 id="奇偶校验码"><a class="header-anchor" href="#奇偶校验码"></a>奇偶校验码</h4><p>在原编码上加一个校验位，它的码距等于 2，可以检测出一位错误（或奇数位错误），但不能确定出错的位置，也不能够检测出偶数位错误，增加的冗余位称为奇偶校验位。</p><p>奇偶校验实现的方法：由若干位有效信息（如 1 B）再加上一个二进制位（校验位）组成校验码。校验位的取值（0 或 1）将使整个校验码中“ 1 ”的个数为奇数或偶数，所以有两种可供选择的校验规律。</p><ul><li>奇校验码：整个校验码（有效信息位和校验位）中“ 1 ”的个数为奇数。</li><li>偶校验码：整个校验码（有效信息位和校验位）中“ 1 ”的个数为偶数。</li></ul><p>缺点：具有局限性，奇偶校验只能发现数据代码中奇数位的出错情况，但不能纠正错误，常用于对存储器数据的检查或传输数据的检查。</p><h4 id="海明校验码"><a class="header-anchor" href="#海明校验码"></a>海明校验码</h4><p>海明码是广泛采用的一种有效的校验码，它实际上是一种多重奇偶校验码。其实现原理是在有效信息位中加入几个校验位形成海明码，并把海明码的每个二进制位分配到几个奇偶校验组中。当某一位出错后，就会引起有关的几个校验位的值发生变化，这不但可以发现错位，还能指出错位的位置，为自动纠错提供依据。根据纠错理论得：$$L- 1=D+C \ (D \ge C)$$即编码最小码距 $L$ 越大，其检测错误的位数 $D$ 越大，纠正错误的位数 $C$ 也越大，且纠错能力恒小于等于检错能力。海明码就是根据这一理论提出的具有纠错能力的一种编码。</p><p>下面用一个例子来介绍求海明码的步骤。在 $n=4$、$k=3$ 时，求 1010 的海明码。</p><p>1、<strong>确定海明码的位数</strong></p><p>设 $n$ 为有效信息的位数，$k$ 为校验位的位数，则信息位 $n$ 和校验位 $k$ 应满足 $$n+k \le 2^{k}-1$$ 若要检测两位错，则需再增加 1 位校验位，即 $k+1$ 位。海明码位数为 $n+k=7 \le 2^{3}-1$ 成立，则 $n$、$k$ 有效。</p><p>设信息位为 $D_{4} D_{3} D_{2} D_{1}$（1010），共 4 位，校验位为 $P_{3} P_{2} P_{1}$，共 3 位，对应的海明码为 $H_{7} H_{6} H_{5} H_{4} H_{3} H_{2} H_{1}$。</p><p>2、<strong>确定校验位的分布</strong></p><p>规定校验位 $P_i$ 在海明位号为 $2^{i-1}$ 的位置上，其余各位为信息位，因此有：</p><ul><li>$P_1$ 的海明位号为 $2^{i-1} = 2^{0} = 1$，即 $H_1$ 为 $P_1$。</li><li>$P_2$ 的海明位号为 $2^{i-1} = 2^{1} = 2$，即 $H_2$ 为 $P_2$。</li><li>$P_3$ 的海明位号为 $2^{i-1} = 2^{2} = 4$，即 $H_4$ 为 $P_3$。</li></ul><p>将信息位按原来的顺序插入，则海明码各位的分布如下:<br>$$<br>\begin{matrix}<br>H_{7}  &amp; H_{6}  &amp; H_{5}  &amp; H_{4}  &amp; H_{3}  &amp; H_{2}  &amp; H_{1} \\<br>D_{4}  &amp; D_{3}  &amp; D_{2}  &amp; P_{3}  &amp; D_{1}  &amp; P_{2}  &amp; P_{1}<br>\end{matrix}<br>$$</p><p>3、<strong>分组以形成校验关系</strong></p><p>每个数据位用多个校验位进行校验，但要满足条件：被校验数据位的海明位号等于校验该数据位的各校验位海明位号之和。另外，校验位不需要再被校验。分组形成的校验关系如下。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/%E6%B5%B7%E6%98%8E%E7%A0%81%E6%A0%A1%E9%AA%8C%E4%BD%8D.png" alt="海明码校验位"></p><p>4、<strong>校验位取值</strong></p><p>校验位 $P_i$ 的值为第 $i$ 组（由该校验位校验的数据位）所有位求异或（如果两个值不相同，则异或结果为 1。如果两个值相同，异或结果为 0。）。由上分组有：</p><p>$$<br>\begin{align*}<br>P_{1}=D_{1} \oplus D_{2} \oplus D_{4} = 0 \oplus 1 \oplus 1 = 0 \\<br>P_{2}=D_{1} \oplus D_{3} \oplus D_{4} = 0 \oplus 0 \oplus 1 = 1 \\<br>P_{3}=D_{2} \oplus D_{3} \oplus D_{4} = 1 \oplus 0 \oplus 1 = 0<br>\end{align*}<br>$$</p><p>所以，1010 对应的海明码为 1010010</p><p>5、<strong>海明码的校验原理</strong></p><p>每个校验组分别利用校验位和参与形成该校验位的信息位进行奇偶校验检查，构成 $k$ 个校验方程：</p><p>$$<br>\begin{align*}<br>S_{1}=P_{1} \oplus D_{1} \oplus D_{2} \oplus D_{4} \\<br>S_{2}=P_{2} \oplus D_{1} \oplus D_{3} \oplus D_{4} \\<br>S_{3}=P_{3} \oplus D_{2} \oplus D_{3} \oplus D_{4}<br>\end{align*}<br>$$</p><p>若 $S_{3}S_{2}S_{1} =000$，则说明无错；否则说明出错，且这个数就是错误的位号，如 $S_{3}S_{2}S_{1} = 001$，说明第 1 位出错，即 $H_{1}$ 出错，直接将该位取反就达到纠错的目的。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/%E6%B5%B7%E6%98%8E%E7%A0%81%E6%A0%A1%E9%AA%8C%E5%85%83%E7%B4%A0%E5%85%B3%E7%B3%BB.png" alt="海明码校验元素关系"></p><p>海明码的检错能力为 1 位，纠错能力为 2 位。通常使用时会在最头部加上“全校验位”，对整体进行偶校验：</p><ul><li>$S_{3}S_{2}S_{1} =000$ 且全体偶校验成功，无错误</li><li>$S_{3}S_{2}S_{1} \ne 000$ 且全体偶校验失败，有 1 位错误，纠正即可</li><li>$S_{3}S_{2}S_{1} \ne 000$ 且全体偶校验成功，有 2 位称为，需重传</li></ul><p>3、<strong>循环冗余校验码</strong></p><ul><li>CRC 码的基本思想</li><li>如何构造</li><li>如何检错纠错</li></ul><p>循环冗余校验（Cyclic Redundancy Check，CRC）码的基本思想是：在 $K$ 位信息码后再拼接 $R$ 位的校验码，整个编码的长度为 $N$ 位，因此，这种编码又称 $(N,K)$ 码。</p><ul><li>数据发送、接收方约定一个“除数”</li><li>$K$ 个信息位 + $R$ 个校验位作为“被除数”，添加校验位后需保证除法的余数为 0</li><li>收到数据后，进行除法检查余数是否为 0，若余数非 0 说明出错，则进行重传或纠错</li></ul><p>CRC 码基于线性编码理论，在发送端，将要传送的 $K$ 位二进制信息码左移 $R$ 位，将它与生成多项式 $G(x)$ 做模 2 除法，生成一个 $R$ 位校验码，并附在信息码后，构成一个新的二进制码（CRC 码），共 $K+R$ 位。在接收端，利用生成多项式对接收到的编码做模 2 除法，以检测和确定出错的位置，如无错则整除，其中生成多项式是接收端和发送端的一个约定。</p><p>任意一个二进制数码都可用一个系数仅为“ 0 ”或“ 1 ”的多项式与其对应。生成多项式 $G(x)$ 的最高幂次为 $R$，转换成对应的二进制数有 $R+1$ 位。例如，生成多项式 $x^{3} + x^{2} + 1$ 对应的二进制数为 1101，而二进制数 1011 对应的多项式为 $x^{3} + x^{2} + 1$ 。下面用一个例子来介绍 CRC 的编码和检测过程。</p><p>设生成多项式 $G(x) = x^{3} + x^{2} + 1$，信息码为 101001，求对应的 CRC 码</p><ul><li>生成多项式 $G(x) = 1x^{3} + 1x^{2} + 0x^{1} + 1x^{0}$，故对应的二进制码为 1101。</li><li>$R$ 等于生成多项式最高次幂，即为 3</li><li>$K$ 等于信息码长度，即为 6</li><li>校验码位数 $N = K+R=9$</li></ul><p><strong>位移</strong></p><p>将原信息码左移 $R$ 位，低位补 0，得到 101001000</p><p><strong>相除</strong></p><p>对位移后的信息码，用生成多项式进行模 2 除法，产生余数。</p><blockquote><p>模 2 减法：和模 2 加法的结果相同，都是做异或运算<br>模 2 除法：模 2 除法和算术除法类似，但每位除（减）的结果不影响其他位，即不借位。</p></blockquote><p>① 用除数对被除数最高几位做模 2 减（异或），不借位。<br>② 除数右移一位，若余数最高位为 1，商为 1，并对余数做模 2 减。若余数最高位为 0，商为 0，除数继续右移一位。<br>③ 循环直到余数位数小于除数时，该余数为最终余数。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/CRC%E7%A0%81%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B.png" alt="CRC码生成过程"></p><p>模 2 除法过程如图上所示，得到余数为 001，则报文 101001 编码后的报文（即CRC码）为 101001001</p><p><strong>检错和纠错</strong></p><p>接收端收到的 CRC 码，用生成多项式 $G(x)$ 做模 2 除法，若余数为 0，则码字无错。</p><p>若接收端收的 CRC 码为 $C_{9} C_{8} C_{7} C_{6} C_{5} C_{4} C_{3} C_{2} C_{1} = 101001011$，将这个数据与 1101 进行模 2 除法，得到的余数为 010，则说明 $C_{2}$ 出错（不一定正确），将 $C_{2}$ 取反即可。</p><blockquote><p>注意：余数值与出错位置并不是二进制与十进制转换的关系。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/CRC%E7%A0%81%E4%BD%99%E6%95%B0%E4%B8%8E%E5%87%BA%E9%94%99%E4%BD%8D%E5%85%B3%E7%B3%BB.png" alt="CRC码余数与出错位关系"></p><p>$K$ 个信息位，$R$ 个校验位，若生成多项式选择得当，且 $2^{R} \ge K + R + 1$ ，则 CRC 码可纠正 1 位错。实际应用中一般只用来“检错”。</p><p>理论上可以证明循环冗余校验码的检错能力有以下特点：</p><ol><li>可检测出所有奇数个错误;</li><li>可检测出所有双比特的错误;</li><li>可检测出所有小于等于校验位长度的连续错误;</li></ol><h2 id="定点数的表示与运算"><a class="header-anchor" href="#定点数的表示与运算"></a>定点数的表示与运算</h2><p><a href="https://www.bilibili.com/video/BV1BE411D7ii?p=14">https://www.bilibili.com/video/BV1BE411D7ii?p=14</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数制与编码&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#数制与编码&quot;&gt;&lt;/a&gt;数制与编码&lt;/h2&gt;
&lt;p&gt;在计算机系统内部，所有的信息都是用二进制进行编码的，这样做的原因有以下几点。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;二进制只有两种状态，使用有两个稳</summary>
      
    
    
    
    <category term="计算机组成原理" scheme="http://halo123.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="计算机组成原理" scheme="http://halo123.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>中文文案排版</title>
    <link href="http://halo123.top/2021/05/26/BasicKnowledge/%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%88%E6%8E%92%E7%89%88/"/>
    <id>http://halo123.top/2021/05/26/BasicKnowledge/%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%88%E6%8E%92%E7%89%88/</id>
    <published>2021-05-26T08:30:50.000Z</published>
    <updated>2021-05-26T08:34:29.754Z</updated>
    
    <content type="html"><![CDATA[<div class="tag link"><a class="link-card" title="转自 《中文文案排版指北》" href="https://github.com/sparanoid/chinese-copywriting-guidelines/blob/master/README.zh-CN.md"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/GithubIcon.jpg"/></div><div class="right"><p class="text">转自 《中文文案排版指北》</p><p class="url">https://github.com/sparanoid/chinese-copywriting-guidelines/blob/master/README.zh-CN.md</p></div></a></div><h2 id="空格"><a class="header-anchor" href="#空格"></a>空格</h2><h3 id="中英文之间需要增加空格"><a class="header-anchor" href="#中英文之间需要增加空格"></a>中英文之间需要增加空格</h3><p>正确：</p><blockquote><p>在 LeanCloud 上，数据存储是围绕 <code>AVObject</code> 进行的。</p></blockquote><p>错误：</p><blockquote><p>在LeanCloud上，数据存储是围绕<code>AVObject</code>进行的。</p><p>在 LeanCloud上，数据存储是围绕<code>AVObject</code> 进行的。</p></blockquote><p>完整的正确用法：</p><blockquote><p>在 LeanCloud 上，数据存储是围绕 <code>AVObject</code> 进行的。每个 <code>AVObject</code> 都包含了与 JSON 兼容的 key-value 对应的数据。数据是 schema-free 的，你不需要在每个 <code>AVObject</code> 上提前指定存在哪些键，只要直接设定对应的 key-value 即可。</p></blockquote><p>例外：「豆瓣FM」等产品名词，按照官方所定义的格式书写。</p><h3 id="中文与数字之间需要增加空格"><a class="header-anchor" href="#中文与数字之间需要增加空格"></a>中文与数字之间需要增加空格</h3><p>正确：</p><blockquote><p>今天出去买菜花了 5000 元。</p></blockquote><p>错误：</p><blockquote><p>今天出去买菜花了 5000元。</p><p>今天出去买菜花了5000元。</p></blockquote><h3 id="数字与单位之间需要增加空格"><a class="header-anchor" href="#数字与单位之间需要增加空格"></a>数字与单位之间需要增加空格</h3><p>正确：</p><blockquote><p>我家的光纤入屋宽带有 10 Gbps，SSD 一共有 20 TB</p></blockquote><p>错误：</p><blockquote><p>我家的光纤入屋宽带有 10Gbps，SSD 一共有 20TB</p></blockquote><p>例外：度 / 百分比与数字之间不需要增加空格：</p><p>正确：</p><blockquote><p>今天是 233° 的高温。</p><p>新 MacBook Pro 有 15% 的 CPU 性能提升。</p></blockquote><p>错误：</p><blockquote><p>今天是 233 ° 的高温。</p><p>新 MacBook Pro 有 15 % 的 CPU 性能提升。</p></blockquote><h3 id="全角标点与其他字符之间不加空格"><a class="header-anchor" href="#全角标点与其他字符之间不加空格"></a>全角标点与其他字符之间不加空格</h3><p>正确：</p><blockquote><p>刚刚买了一部 iPhone，好开心！</p></blockquote><p>错误：</p><blockquote><p>刚刚买了一部 iPhone ，好开心！</p><p>刚刚买了一部 iPhone， 好开心！</p></blockquote><h3 id="用-text-spacing-来挽救？"><a class="header-anchor" href="#用-text-spacing-来挽救？"></a>用 <code>text-spacing</code> 来挽救？</h3><p>CSS Text Module Level 4 的 <a href="https://www.w3.org/TR/css-text-4/#text-spacing-property"><code>text-spacing</code></a> 和 Microsoft 的 <a href="https://msdn.microsoft.com/library/ms531164(v=vs.85).aspx"><code>-ms-text-autospace</code></a> 可以实现自动为中英文之间增加空白。不过目前并未普及，另外在其他应用场景，例如 macOS、iOS、Windows 等用户介面目前并不存在这个特性，所以请继续保持随手加空格的习惯。</p><h2 id="标点符号"><a class="header-anchor" href="#标点符号"></a>标点符号</h2><h3 id="不重复使用标点符号"><a class="header-anchor" href="#不重复使用标点符号"></a>不重复使用标点符号</h3><p>正确：</p><blockquote><p>德国队竟然战胜了巴西队！</p><p>她竟然对你说「喵」？！</p></blockquote><p>错误：</p><blockquote><p>德国队竟然战胜了巴西队！！</p><p>德国队竟然战胜了巴西队！！！！！！！！</p><p>她竟然对你说「喵」？？！！</p><p>她竟然对你说「喵」？！？！？？！！</p></blockquote><h2 id="全角和半角"><a class="header-anchor" href="#全角和半角"></a>全角和半角</h2><p>不明白什么是全角（全形）与半角（半形）符号？请查看维基百科词条『<a href="https://zh.wikipedia.org/wiki/%E5%85%A8%E5%BD%A2%E5%92%8C%E5%8D%8A%E5%BD%A2">全形和半形</a>』。</p><h3 id="使用全角中文标点"><a class="header-anchor" href="#使用全角中文标点"></a>使用全角中文标点</h3><p>正确：</p><blockquote><p>嗨！你知道嘛？今天前台的小妹跟我说「喵」了哎！</p><p>核磁共振成像（NMRI）是什么原理都不知道？JFGI！</p></blockquote><p>错误：</p><blockquote><p>嗨! 你知道嘛? 今天前台的小妹跟我说 “喵” 了哎！</p><p>嗨!你知道嘛?今天前台的小妹跟我说&quot;喵&quot;了哎！</p><p>核磁共振成像 (NMRI) 是什么原理都不知道? JFGI!</p><p>核磁共振成像(NMRI)是什么原理都不知道?JFGI!</p></blockquote><h3 id="数字使用半角字符"><a class="header-anchor" href="#数字使用半角字符"></a>数字使用半角字符</h3><p>正确：</p><blockquote><p>这个蛋糕只卖 1000 元。</p></blockquote><p>错误：</p><blockquote><p>这个蛋糕只卖 １０００ 元。</p></blockquote><p>例外：在设计稿、宣传海报中如出现极少量数字的情形时，为方便文字对齐，是可以使用全形数字的。</p><h3 id="遇到完整的英文整句、特殊名词，其内容使用半角标点"><a class="header-anchor" href="#遇到完整的英文整句、特殊名词，其内容使用半角标点"></a>遇到完整的英文整句、特殊名词，其内容使用半角标点</h3><p>正确：</p><blockquote><p>贾伯斯那句话是怎么说的？「Stay hungry, stay foolish.」</p><p>推荐你阅读《Hackers &amp; Painters: Big Ideas from the Computer Age》，非常的有趣。</p></blockquote><p>错误：</p><blockquote><p>贾伯斯那句话是怎么说的？「Stay hungry，stay foolish。」</p><p>推荐你阅读《Hackers＆Painters：Big Ideas from the Computer Age》，非常的有趣。</p></blockquote><h2 id="名词"><a class="header-anchor" href="#名词"></a>名词</h2><h3 id="专有名词使用正确的大小写"><a class="header-anchor" href="#专有名词使用正确的大小写"></a>专有名词使用正确的大小写</h3><p>大小写相关用法原属于英文书写范畴，不属于本 wiki 讨论内容，在这里只对部分易错用法进行简述。</p><p>正确：</p><blockquote><p>使用 GitHub 登录</p><p>我们的客户有 GitHub、Foursquare、Microsoft Corporation、Google、Facebook, Inc.。</p></blockquote><p>错误：</p><blockquote><p>使用 github 登录</p><p>使用 GITHUB 登录</p><p>使用 Github 登录</p><p>使用 gitHub 登录</p><p>使用 gｲんĤЦ8 登录</p><p>我们的客户有 github、foursquare、microsoft corporation、google、facebook, inc.。</p><p>我们的客户有 GITHUB、FOURSQUARE、MICROSOFT CORPORATION、GOOGLE、FACEBOOK, INC.。</p><p>我们的客户有 Github、FourSquare、MicroSoft Corporation、Google、FaceBook, Inc.。</p><p>我们的客户有 gitHub、fourSquare、microSoft Corporation、google、faceBook, Inc.。</p><p>我们的客户有 gｲんĤЦ8、ｷouЯƧquﾑгє、๓เςг๏ร๏Ŧt ς๏гק๏гคtเ๏ภn、900913、ƒ4ᄃëв๏๏к, IПᄃ.。</p></blockquote><p>注意：当网页中需要配合整体视觉风格而出现全部大写／小写的情形，HTML 中请使用标淮的大小写规范进行书写；并通过 <code>text-transform: uppercase;</code>／<code>text-transform: lowercase;</code> 对表现形式进行定义。</p><h3 id="不要使用不地道的缩写"><a class="header-anchor" href="#不要使用不地道的缩写"></a>不要使用不地道的缩写</h3><p>正确：</p><blockquote><p>我们需要一位熟悉 JavaScript、HTML5，至少理解一种框架（如 Backbone.js、AngularJS、React 等）的前端开发者。</p></blockquote><p>错误：</p><blockquote><p>我们需要一位熟悉 Js、h5，至少理解一种框架（如 backbone、angular、RJS 等）的 FED。</p></blockquote><h2 id="争议"><a class="header-anchor" href="#争议"></a>争议</h2><p>以下用法略带有个人色彩，即：无论是否遵循下述规则，从语法的角度来讲都是<strong>正确</strong>的。</p><h3 id="链接之间增加空格"><a class="header-anchor" href="#链接之间增加空格"></a>链接之间增加空格</h3><p>用法：</p><blockquote><p>请 <a href="#">提交一个 issue</a> 并分配给相关同事。</p><p>访问我们网站的最新动态，请 <a href="#">点击这里</a> 进行订阅！</p></blockquote><p>对比用法：</p><blockquote><p>请<a href="#">提交一个 issue</a>并分配给相关同事。</p><p>访问我们网站的最新动态，请<a href="#">点击这里</a>进行订阅！</p></blockquote><h3 id="简体中文使用直角引号"><a class="header-anchor" href="#简体中文使用直角引号"></a>简体中文使用直角引号</h3><p>用法：</p><blockquote><p>「老师，『有条不紊』的『紊』是什么意思？」</p></blockquote><p>对比用法：</p><blockquote><p>“老师，‘有条不紊’的‘紊’是什么意思？”</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;tag link&quot;&gt;&lt;a class=&quot;link-card&quot; title=&quot;转自 《中文文案排版指北》&quot; href=&quot;https://github.com/sparanoid/chinese-copywriting-guidelines/blob/mast</summary>
      
    
    
    
    <category term="Tips" scheme="http://halo123.top/categories/Tips/"/>
    
    
    <category term="Tips" scheme="http://halo123.top/tags/Tips/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理概述</title>
    <link href="http://halo123.top/2021/05/26/ComputerComposition/A-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/"/>
    <id>http://halo123.top/2021/05/26/ComputerComposition/A-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/</id>
    <published>2021-05-26T04:55:05.000Z</published>
    <updated>2021-05-26T11:56:51.070Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机系统的组成"><a class="header-anchor" href="#计算机系统的组成"></a>计算机系统的组成</h2><p>硬件系统和软件系统共同构成了一个完整的计算机系统。</p><ul><li>硬件是指有形的物理设备，是计算机系统中实际物理装置的总称。</li><li>软件是指在硬件上运行的程序和相关的数据及文档。</li></ul><p>计算机系统性能的好坏，很大程度上是由软件的效率和作用来表征的，而软件性能的发挥又离不开硬件的支持。对某一功能来说，其既可以用软件实现，又可以用硬件实现，则称为软硬件在逻辑上是等效的。在设计计算机系统时，要进行软/硬件的功能分配。通常来说，一个功能若使用较为频繁且用硬件实现的成本较为理想，则使用硬件解决可以提高效率。而用软件实现可以提<br>高灵活性，但效率往往不如硬件实现高。</p><h2 id="计算机硬件的基本组成"><a class="header-anchor" href="#计算机硬件的基本组成"></a>计算机硬件的基本组成</h2><h3 id="早期的冯·诺依曼机"><a class="header-anchor" href="#早期的冯·诺依曼机"></a>早期的冯·诺依曼机</h3><p>冯·诺依曼在研究 EDVAC 机时提出了“存储程序”的概念，“存储程序”的思想奠定了现代计算机的基本结构，以此概念为基础的各类计算机通称为冯·诺依曼机，其特点如下：</p><ol><li>计算机硬件系统由运算器、存储器、控制器、输入设备和输出设备 5 大部件组成。</li><li>指令和数据以同等地位存储在存储器中，并可按地址寻访。</li><li>指令和数据均用二进制代码表示。</li><li>指令由操作码和地址码组成，操作码用来表示操作的性质，地址码用来表示操作数在存储器中的位置。</li><li>指令在存储器内按顺序存放。通常，指令是顺序执行的，在特定条件下可根据运算结果或根据设定的条件改变执行顺序。</li><li>早期的冯·诺依曼机以运算器为中心，输入/输出设备通过运算器与存储器传送数据。</li></ol><blockquote><p>注意：“存储程序”的概念是指将指令以代码的形式事先输入计算机的主存储器，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束。</p></blockquote><p>典型的冯·诺依曼机计算机结构如图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/%E5%85%B8%E5%9E%8B%E7%9A%84%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%93%E6%9E%84.png" alt="典型的冯诺依曼计算机结构"></p><h3 id="现代计算机的组织结构"><a class="header-anchor" href="#现代计算机的组织结构"></a>现代计算机的组织结构</h3><p>在微处理器问世之前，运算器和控制器分离，而且存储器的容量很小，因此设计成以运算器为中心的结构，其他部件都通过运算器完成信息的传递。</p><p>而随着微电子技术的进步，同时计算机需要处理、加工的信息量也与日俱增，大量 I/O 设备的速度和 CPU 的速度差距悬殊，因此以运算器为中心的结构不能够满足计算机发展的要求。现代计算机已发展为以存储器为中心，使 I/O 操作尽可能地绕过 CPU ，直接在 I/O 设备和存储器之间完成，以提高系统的整体运行效率，其结构如图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/%E4%BB%A5%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%BA%E4%B8%AD%E5%BF%83%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%93%E6%9E%84.png" alt="以存储器为中心的计算机结构"></p><p>目前绝大多数现代计算机仍遵循冯·诺依曼的存储程序的设计思想。</p><h3 id="计算机的功能部件"><a class="header-anchor" href="#计算机的功能部件"></a>计算机的功能部件</h3><p>传统冯·诺依曼计算机和现代计算机的结构虽然有所不同，但功能部件是一致的，它们的功能部件包括如下几种：</p><p>1、<strong>输入设备</strong></p><p>输入设备的主要功能是将程序和数据以机器所能识别和接受的信息形式输入计算机。最常用也最基本的输入设备是键盘，此外还有鼠标、扫描仪、摄像机等。</p><p>2、<strong>输出设备</strong></p><p>输出设备的任务是将计算机处理的结果以人们所能接受的形式或其他系统所要求的信息形式输出。最常用、最基本的输出设备是显示器、打印机。计算机的输入/输出设备（简称 I/O 设备）是计算机与外界联系的桥梁，是计算机中不可缺少的重要组成部分。</p><p>3、<strong>存储器</strong></p><p>存储器是计算机的存储部件，用来存放程序和数据。存储器分为主存储器（简称主存，也称内存储器）和辅助存储器（简称辅存，也称外存储器）。</p><ul><li>CPU 能够直接访问的存储器是主存储器。</li><li>辅助存储器用于帮助主存储器记忆更多的信息，辅助存储器中的信息必须调入主存后，才能为 CPU 所访问。</li></ul><p>主存储器由许多存储单元组成，每个存储单元包含若干存储元件，每个存储元件存储一位二进制代码“0”或“1”。因此存储单元可存储一串二进制代码，称这串代码为存储字，称这串代码的位数为存储字长，存储字长可以是 1 B（8 bit）或是字节的偶数倍。</p><p>主存储器的工作方式是按存储单元的地址进行存取，这种存取方式称为按地址存取方式（相联存储器是按内容访问的）。</p><p>主存储器的最基本组成如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E9%80%BB%E8%BE%91%E5%9B%BE.png" alt="主存储器逻辑图"></p><ul><li>存储体存放二进制信息；</li><li>地址寄存器（Memory Address Register，MAR）存放访存地址，经过地址译码后找到所选的存储单元；</li><li>数据寄存器（Memory Data Register，MDR）用于暂存要从存储器中读或写的信息；</li><li>时序控制逻辑用于产生存储器操作所需的各种时序信号。</li></ul><p>MAR 用于寻址，其位数对应着存储单元的个数，如 MAR 为 10 位，则有 2<sup>10</sup> = 1024 个存储单元，记为 1 K。MAR 的长度与 程序计数器（Program Counter，PC） 的长度相等。</p><p>MDR 的位数和存储字长相等，一般为字节的二次幂的整数倍。</p><blockquote><p>注意：MAR 与 MDR 虽然是存储器的一部分，但在现代 CPU 中却是存在于 CPU 中的。另外，高速缓存（Cache）也存在于 CPU 中。</p></blockquote><p>4、<strong>运算器</strong></p><p>运算器是计算机的执行部件，用于进行算术运算和逻辑运算。</p><ul><li>算术运算是按算术运算规则进行的运算，如加、减、乘、除；</li><li>逻辑运算包括与、或、非、异或、比较、移位等运算。</li></ul><p>运算器的核心是算术逻辑单元（Arithmetic and Logical Unit，ALU）。</p><p>运算器包含若干通用寄存器，用于暂存操作数和中间结果，如累加器（Accumulator，ACC）、乘商寄存器（Multiple—Quotient Register，MQ）、操作数寄存器（X）、变址寄存器（IX）、基址寄存器（BR）等，其中前3个寄存器是必须有的。</p><p>运算器内还有程序状态寄存器（Program Status Word，PSW），也称标志寄存器，用于存放 ALU 运算得到的一些标志信息或处理机的状态信息，如结果是否溢出、有无产生进位或借位、结果是否为负等。</p><p>5、<strong>控制器</strong></p><p>控制器是计算机的指挥中心，由其“指挥”各部件自动协调地进行工作。控制器由程序计数器（Program Counter，PC）、指令寄存器（Instruction Register，IR）和控制单元（CU）组成。</p><p>PC 用来存放当前欲执行指令的地址，可以自动加 1 以形成下一条指令的地址，它与主存的 MAR 之间有一条直接通路。</p><p>IR 用来存放当前的指令，其内容来自主存的 MDR。</p><ul><li>指令中的操作码 OP(IR) 送至 CU，用以分析指令并发出各种微操作命令序列</li><li>指令中的地址码 Ad(IR) 送往 MAR，用以取操作数。</li></ul><p>一般将运算器和控制器集成到同一个芯片上，称为中央处理器（Central Processing Unit，CPU）。CPU 和主存储器共同构成主机，而除主机外的其他硬件装置（外存、I/O 设备等）统称为外部设备，简称外设。</p><p>下图所示为冯·诺依曼结构的模型机。CPU 包含 ALU、通用寄存器组 GPRs、标志寄存器、控制器、指令寄存器 IR、程序计数器 PC、存储器地址寄存器 MAR 和存储器数据寄存器 MDR。图中从控制器送出的虚线就是控制信号，可以控制如何修改 PC 以得到下一条指令的地址，可以控制 ALU 执行什么运算，可以控制主存是进行读操作还是写操作（读/写控制信号）。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%BB%93%E6%9E%84%E7%9A%84%E6%A8%A1%E5%9E%8B%E6%9C%BA.png" alt="冯诺依曼结构的模型机"></p><p>CPU 和主存之间通过一组总线相连，总线中有地址、控制和数据 3 组信号线。</p><ul><li>MAR 中的地址信息会直接送到地址线上，用于指向读/写操作的主存存储单元;</li><li>控制线中有读/写信号线，指出数据是从 CPU 写入主存还是从主存读出到 CPU，根据是读操作还是写操作来控制将 MDR 中的数据是直接送到数据线上还是将数据线上的数据接收到 MDR 中。</li></ul><h2 id="计算机软件的分类"><a class="header-anchor" href="#计算机软件的分类"></a>计算机软件的分类</h2><h3 id="系统软件和应用软件"><a class="header-anchor" href="#系统软件和应用软件"></a>系统软件和应用软件</h3><p>软件按其功能分类，可分为系统软件和应用软件。</p><ul><li>系统软件是一组保证计算机系统高效、正确运行的基础软件，通常作为系统资源提供给用户使用。系统软件主要有操作系统（OS）、数据库管理系统（DBMS）、语言处理程序、分布式软件系统、网络软件系统、标准库程序、服务性程序等。</li><li>应用软件是指用户为解决某个应用领域中的各类问题而编制的程序，如各种科学计算类程序、工程设计类程序、数据统计与处理程序等。</li></ul><blockquote><p>注意：数据库管理系统（DBMS）和数据库系统（DBS）是有区别的。DBMS 是位于用户和操作系统之间的一层数据管理软件，是系统软件；而 DBS 是指计算机系统中引入数据库后的系统，一般由数据库、数据库管理系统、数据库管理员（DBA）和应用系统构成。</p></blockquote><h3 id="三个级别的语言"><a class="header-anchor" href="#三个级别的语言"></a>三个级别的语言</h3><ol><li>机器语言。又称二进制代码语言，需要编程人员记忆每条指令的二进制编码。机器语言是计算机唯一可以直接识别和执行的语言。</li><li>汇编语言。汇编语言用英文单词或其缩写代替二进制的指令代码，更容易为人们记忆和理解。使用汇编语言编辑的程序，必须经过一个称为汇编程序的系统软件的翻译，将其转换为计算机的机器语言后，才能在计算机的硬件系统上执行。</li><li>高级语言。高级语言（如C、C++、Java等）是为方便程序设计人员写出解决问题的处理方案和解题过程的程序。通常高级语言需要经过编译程序编译成汇编语言程序，然后经过汇编操作得到机器语言程序，或直接由高级语言程序翻译成机器语言程序。</li></ol><h2 id="计算机的工作过程"><a class="header-anchor" href="#计算机的工作过程"></a>计算机的工作过程</h2><p>计算机的工作过程分为以下三个步骤：</p><ol><li>把程序和数据装入主存储器。</li><li>将源程序转换成可执行文件。</li><li>从可执行文件的首地址开始逐条执行指令。</li></ol><h3 id="从源程序到可执行文件"><a class="header-anchor" href="#从源程序到可执行文件"></a>从源程序到可执行文件</h3><p>在计算机中编写的 C 语言程序，都必须被转换为一系列的低级机器指令，这些指令按照一种称为可执行目标文件的格式打好包，并以二进制磁盘文件的形式存放起来。</p><p>以 UNIX 系统中的 GCC 编译器程序为例，读取源程序文件 hello.c，并把它翻译成一个可执行目标文件 hello，整个翻译过程可分为 4 个阶段完成，如图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/%E6%BA%90%E7%A8%8B%E5%BA%8F%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="源程序转换为可执行文件的过程"></p><ol><li>预处理阶段：预处理器（cpp）对源程序中以字符 <code>#</code> 开头的命令进行处理，例如将 <code>#include</code> 命令后面的 .h 文件内容插入程序文件。输出结果是一个以 i 为扩展名的源文件 hello.i</li><li>编译阶段：编译器（ccl）对预处理后的源程序进行编译，生成一个汇编语言源程序 hello.s 汇编语言源程序中的每条语句都以一种文本格式描述了一条低级机器语言指令。</li><li>汇编阶段：汇编器（as）将 hello.s 翻译成机器语言指令，把这些指令打包成一个称为可重定位目标文件的 hello.o，它是一种二进制文件，因此在文本编辑器中打开它时会显示乱码。</li><li>链接阶段：链接器（ld）将多个可重定位目标文件和标准库函数合并为一个可执行目标文件，或简称可执行文件。本例中，链接器将 hello.o 和标准库函数 <code>prinft</code> 所在的可重定位目标模块 prinft.o 合并，生成可执行文件 hello。最终生成的可执行文件被保存在磁盘上。</li></ol><h3 id="指令执行过程的描述"><a class="header-anchor" href="#指令执行过程的描述"></a>指令执行过程的描述</h3><p>程序中第一条指令的地址置于 PC 中，根据 PC 取出第一条指令，经过译码、执行步骤等，控制计算机各功能部件协同运行，完成这条指令的功能，并计算下一条指令的地址。用新得到的指令地址继续读出第二条指令并执行，直到程序结束为止。</p><p>下面以取数指令（即将指令地址码指示的存储单元中的操作数取出后送至运算器的 ACC 中）为例进行说明，其信息流程如下：</p><p>1、取指令: PC → MAR → M → MDR → IR</p><p>根据 PC 取指令到 IR（指令寄存器）。将 PC 的内容送 MAR（地址寄存器），MAR 中的内容直接送地址线，同时控制器将读信号送读/写信号线，主存根据地址线上的地址和读信号，从指定存储单元读出指令，送到数据线上，MDR（数据寄存器） 从数据线接收指令信息，并传送到 IR 中。</p><p>2、分析指令: OP(IR) → CU</p><p>指令译码并送出控制信号。控制器根据IR中指令的操作码，生成相应的控制信号，送到不同的执行部件。在本例中，IR 中是取数指令，因此读控制信号被送到总线的控制线上。</p><p>3、执行指令：Ad(IR) → MAR → M → MDR → ACC</p><p>取数操作。将 IR 中指令的地址码送 MAR，MAR 中的内容送地址线，同时控制器将读信号送读/写信号线，从主存指定存储单元读出操作数，并通过数据线送至 MDR，再传送到 ACC 中。</p><p>此外，每取完一条指令，还须为取下一条指令做准备，形成下一条指令的地址，即 (PC)+1 → PC。</p><blockquote><p>注意: (PC) 指程序计数器 PC 中存放的内容。PC → MAR 应理解为 (PC) → MAR，即程序计数器中的值经过数据通路送到 MAR，也即表示数据通路时括号可省略（因为只是表示数据流经的途径，而不强调数据本身的流动）。但运算时括号不能省略，即 (PC)+1 → PC 不能写为 PC+1 → PC。</p></blockquote><h2 id="计算机系统的多级层次结构"><a class="header-anchor" href="#计算机系统的多级层次结构"></a>计算机系统的多级层次结构</h2><p>现代计算机是一个硬件与软件组成的综合体。由于面对的应用范围越来越广，因此必须有复杂的系统软件和硬件的支持。由于软/硬件的设计者和使用者都从不同的角度并用不同的语言来对待同一个计算机系统，因此他们各自看到的计算机系统的属性及对计算机系统提出的要求也就不同。</p><p>计算机系统的多级层次结构的作用，就是针对上述情况，根据从各种角度所看到的机器之间的有机联系，来分清彼此之间的界面，明确各自的功能，以便构成合理、高效的计算机系统。</p><p>关于计算机系统层次结构的分层方式，目前尚无统一的标准，这里采用如下图所示的层次结构。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%9A%E7%BA%A7%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" alt="计算机系统的多级层次结构"></p><p>第 1 级是微程序机器层，这是一个实在的硬件层，它由机器硬件直接执行微指令。</p><p>第 2 级是传统机器语言层，它也是一个实际的机器层，由微程序解释机器指令系统。</p><p>第 3 级是操作系统层，它由操作系统程序实现。操作系统程序是由机器指令和广义指令组成的，这些广义指令是为了扩展机器功能而设置的，是由操作系统定义和解释的软件指令，所以这一层也称混合层。</p><p>第 4 级是汇编语言层，它为用户提供一种符号化的语言，借此可编写汇编语言源程序。这一层由汇编程序支持和执行。</p><p>第 5 级是高级语言层，它是面向用户的，是为方便用户编写应用程序而设置的。该层由各种高级语言编译程序支持和执行。</p><p>在高级语言层之上，还可以有应用层，它由解决实际问题和应用问题的处理程序组成，如文字处理软件、数据库软件、多媒体处理软件和办公自动化软件等。</p><p>通常把没有配备软件的纯硬件系统称为“裸机”。第 3 层至第 5 层称为虚拟机，简单来说就是软件实现的机器。虚拟机只对该层的观察者存在，这里的分层和计算机网络的分层类似，对于某层的观察者来说，只能通过该层次的语言来了解和使用计算机，而不必关心下层是如何工作的。</p><p>层次之间的关系紧密，下层是上层的基础，上层是下层的扩展。随着超大规模集成电路技术的不断发展，部分软件功能将由硬件来实现，因而软/硬件交界面的划分也不是绝对的。</p><p>这里主要讨论传统机器 M1 和微程序机器 M0 的组成原理及设计思想。</p><h2 id="计算机的性能指标"><a class="header-anchor" href="#计算机的性能指标"></a>计算机的性能指标</h2><h3 id="计算机的主要性能指标"><a class="header-anchor" href="#计算机的主要性能指标"></a>计算机的主要性能指标</h3><p>1、<strong>机器字长</strong></p><p>机器字长是指计算机进行一次整 数运算（即定点整数运算）所能处理的二进制数据的位数，通常与 CPU 的寄存器位数、加法器有关。因此，机器字长一般等于内部寄存器的大小，字长越长，数的表示范围越大，计算精度越高。计算机字长通常选定为字节（8 位）的整数倍。</p><blockquote><p>注意：<a href="#%E6%9C%BA%E5%99%A8%E5%AD%97%E9%95%BF%E3%80%81%E6%8C%87%E4%BB%A4%E5%AD%97%E9%95%BF%E5%92%8C%E5%AD%98%E5%82%A8%E5%AD%97%E9%95%BF%E7%9A%84%E5%85%B3%E7%B3%BB">机器字长、指令字长和存储字长的关系</a></p></blockquote><p>2、<strong>数据通路带宽</strong></p><p>数据通路带宽是指数据总线一次所能并行传送信息的位数。这里所说的数据通路宽度是指外部数据总线的宽度，它与 CPU 内部的数据总线宽度（内部寄存器的大小）有可能不同。</p><blockquote><p>注意：各个子系统通过数据总线连接形成的数据传送路径称为数据通路。</p></blockquote><p>3、<strong>主存容量</strong></p><p>主存容量是指主存储器所能存储信息的最大容量，通常以字节来衡量，也可用字数 × 字长（如 512 K × 16位）来表示存储容量。其中，MAR 的位数反映存储单元的个数，MAR 的位数反映可寻址范围的最大值（而不一定是实际存储器的存储容量）。</p><p>例如，MAR 为 16 位，表示 2<sup>16</sup> = 65536，即此存储体内有 65536 个存储单元（可称为 64 K 内存，1 K = 1024），若 MDR 为 32 位，表示存储容量为 64 K × 32 位。</p><p>4、<strong>运算速度</strong></p><ul><li><p>吞吐量。指系统在单位时间内处理请求的数量。它取决于信息能多快地输入内存，CPU 能多快地取指令，数据能多快地从内存取出或存入，以及所得结果能多快地从内存送给一台外部设备。几乎每步都关系到主存，因此系统吞吐量主要取决于主存的存取周期。</p></li><li><p>响应时间。指从用户向计算机发送一个请求，到系统对该请求做出响应并获得所需结果的等待时间。通常包括 CPU 时间（运行一个程序所花费的时间）与等待时间（用于磁盘访问、存储器访问、I/O 操作、操作系统开销等的时间）。</p></li><li><p>CPU 时钟周期。通常为节拍脉冲或 T 周期，即主频的倒数，它是 CPU 中最小的时间单位，每个动作至少需要 1 个时钟周期。CPU时钟周期 = 1/主频，主频通常以 Hz（赫兹）为单位，1 Hz 表示每秒 1 次。</p></li><li><p>主频（CPU 时钟频率）。机器内部主时钟的频率，是衡量机器速度的重要参数。对于同一个型号的计算机，其主频越高，完成指令的一个执行步骤所用的时间越短，执行指令的速度越快。例如，常用 CPU 的主频有 1.8 GHz、2.4 GHz、 2.8 GHz 等。</p></li><li><p>CPI（Clock cycle Per Instruction），即执行一条 指令所需的时钟周期数。</p></li><li><p>CPU 执行时间，指运行一个程序所花费的时间。</p><p>CPU 执行时间 = CPU 时钟周期数 / 主频 = (指令条数 × CPI) / 主频。</p><p>上式表明，CPU 的性能（CPU执行时间）取决于三个要素：① 主频（时钟频率）；② 每条指令执行所用的时钟周期数（CPI）； ③ 指令条数。</p><p>主频、CPI 和指令条数是相互制约的。例如，更改指令集可以减少程序所含指令的条数，但同时可能引起 CPU 结构的调整，从而可能会增加时钟周期的宽度（降低主频）。</p></li><li><p>MIPS（Million Instructions Per Second），即每秒执行多少百万条指令。</p><p>MIPS = 指令条数 / (执行时间 × 10<sup>6</sup>) = 主频 / CPI</p></li><li><p>MFLOPS（Mega Floating point Operations Per Second），即每秒执行多少百万次浮点运算。</p><p>MFLOPS = 浮点操作次数 / (执行时间 × 10<sup>6</sup>)</p></li><li><p>GFLOPS（Giga Floating point Operations Per Second），即每秒执行多少十亿次浮点运算。</p><p>GFLOPS = 浮点操作次数 / (执行时间 × 10<sup>9</sup>)</p></li><li><p>TFLOPS（Tera Floating point Operations Per Second），即每秒执行多少万亿次浮点运算。</p><p>TFLOPS = 浮点操作次数 / (执行时间 × 10<sup>12</sup>)</p></li></ul><blockquote><p>注意：在描述存储容量、文件大小等时，K、M、G、T 通常用 2 的幂次表示，如 1 Kb = 2<sup>10</sup> b；在描述速率、频率等时，k、M、G、T 通常用 10 的幂次表示，如 1 kb/s = 10 b/s。通常前者用大写的 K，后者用小写的 k，但其他前缀均为大写，表示的含义取决于所用的场景。</p></blockquote><h3 id="几个专业术语"><a class="header-anchor" href="#几个专业术语"></a>几个专业术语</h3><ul><li>系列机。具有基本相同的体系结构，使用相同基本指令系统的多个不同型号的计算机组成的一个产品系列。</li><li>兼容。指计算机软件或硬件的通用性，即使用或运行在某个型号的计算机系统中的硬件/软件也能应用于另一个型号的计算机系统时，称这两台计算机在硬件或软件上存在兼容性。</li><li>软件可移植性。指把使用在某个系列计算机中的软件直接或进行很少的修改就能运行在另一个系列计算机中的可能性。</li><li>固件。将程序固定在 ROM 中组成的部件称为固件。固件是一种具有软件特性的硬件，固件的性能指标介于硬件与软件之间，吸收了软/硬件各自的优点，其执行速度快于软件，灵活性优于硬件，是软/硬件结合的产物。例如，目前操作系统已实现了部分固化（把软件永恒地存储于只读存储器中）。</li></ul><h2 id="常见问题和易混淆知识点"><a class="header-anchor" href="#常见问题和易混淆知识点"></a>常见问题和易混淆知识点</h2><h3 id="计算机由哪几部分组成？以哪部分为中心？"><a class="header-anchor" href="#计算机由哪几部分组成？以哪部分为中心？"></a>计算机由哪几部分组成？以哪部分为中心？</h3><p>计算机由运算器、控制器、存储器、输入设备及输出设备五大部分构成，现代计算机通常把运算器和控制器集成在一个芯片上，合称为中央处理器。</p><p>而在微处理器面世之前，运算器和控制器分离，而且存储器的容量很小，因此设计成以运算器为中心的结构，其他部件都通过运算器完成信息的传递。</p><p>随着微电子技术的进步，同时计算机需要处理、加工的信息量也与日俱增，大量 I/O 设备的速度和 CPU 的速度差距悬殊，因此以运算器为中心的结构不能满足计算机发展的要求。现代计算机已经发展为以存储器为中心，使 I/O 操作尽可能地绕过 CPU，直接在 I/O 设备和存储器之间完成，以提高系统的整体运行效率。</p><h3 id="主频高的-CPU-一定比主频低的-CPU-快吗？为什么？"><a class="header-anchor" href="#主频高的-CPU-一定比主频低的-CPU-快吗？为什么？"></a>主频高的 CPU 一定比主频低的 CPU 快吗？为什么？</h3><p>衡量 CPU 运算速度的指标有很多，不能以单独的某个指标来判断 CPU 的好坏。CPU 的主频，即 CPU 内核工作的时钟频率。CPU 的主频表示 CPU 内数字脉冲信号振荡的速度，主频和实际的运算速度存在一定的关系，但目前还没有一个确定的公式能够定量两者的数值关系，因为 CPU 的运算速度还要看 CPU 的流水线的各方面的性能指标（架构、缓存、指令集、CPU 的位数、Cache 大小等）。由于主频并不直接代表运算速度，因此在一定情况下很可能会出现主频较高的 CPU 实际运算速度较低的现象。</p><h3 id="不同级别的语言编写的程序有什么区别？哪种语言编写的程序能被硬件直接执行？"><a class="header-anchor" href="#不同级别的语言编写的程序有什么区别？哪种语言编写的程序能被硬件直接执行？"></a>不同级别的语言编写的程序有什么区别？哪种语言编写的程序能被硬件直接执行？</h3><p>机器语言和汇编语言与机器指令对应，而高级语言不与指令直接对应，具有较好的可移植性。其中机器语言可以被硬件直按执行。</p><h3 id="什么是透明性？透明是指什么都能看见吗？"><a class="header-anchor" href="#什么是透明性？透明是指什么都能看见吗？"></a>什么是透明性？透明是指什么都能看见吗？</h3><p>在计算机领域中，站在某类用户的角度，若感觉不到某个事物或属性的存在，即“看”不到某个事物或属性，则称为“对该用户而言，某个事物或属性是透明的”。这与日常生活中的“透明”概念（公开、看得见）正好相反。</p><p>例如，对于高级语言程序员来说，浮点数格式、乘法指令等这些指令的格式、数据如何在运算器中运算等都是透明的；而对于机器语言或汇编语言程序员来说，指令的格式、机器结构、数据格式等则不是透明的。</p><p>在 CPU 中，IR、MAR 和 MDR 对各类程序员都是透明的。</p><h3 id="计算机体系结构和计算机组成的区别和联系是什么？"><a class="header-anchor" href="#计算机体系结构和计算机组成的区别和联系是什么？"></a>计算机体系结构和计算机组成的区别和联系是什么？</h3><p>计算机体系结构是指机器语言或汇编语言程序员所看得到的传统机器的属性，包括指令集、数据类型、存储器寻址技术等，大都属于抽象的属性。</p><p>计算机组成是指如何实现计算机体系结构所体现的属性，它包含对许多对程序员来说透明的硬件细节。例如，指令系统属于结构的问题，但指令的实现即如何取指令、分析指令、取操作数、如何运算等都属于组成的问题。因此，当两台机器指令系统相同时，只能认为它们具有相同的结构，至于这两台机器如何实现其指令，完全可以不同，即可以认为它们的组成方式是不同的。例<br>如，一台机器是否具备乘法指令是一个结构的问题，但实现乘法指令采用什么方式则是一个组成的问题。</p><p>许多计算机厂商提供一系列体系结构相同的计算机，而它们的组成却有相当大的差别，即使是同一系列的不同型号机器，其性能和价格差异也很大。例如，IBM System/370 结构就包含了多种价位和性能的机型。</p><h3 id="基准程序执行得越快说明机器的性能越好吗"><a class="header-anchor" href="#基准程序执行得越快说明机器的性能越好吗"></a>基准程序执行得越快说明机器的性能越好吗?</h3><p>一般情况下， 基准测试程序能够反映机器性能的好坏。但是，由于基准程序中的语句存在频度的差异，因此运行结果并不能完全说明问题。</p><h3 id="机器字长、指令字长和存储字长的关系"><a class="header-anchor" href="#机器字长、指令字长和存储字长的关系"></a>机器字长、指令字长和存储字长的关系</h3><ul><li>机器字长：计算机能直接处理的二进制数据的位数，机器字长一般等于内部寄存器的大小，它决定了计算机的运算精度。</li><li>指令字长：一个指令字中包含的二进制代码的位数。</li><li>存储字长：一个存储单元存储的二进制代码的长度。</li></ul><p>它们都必须是字节的整数倍。</p><p>指令字长一般取存储字长的整数倍，若指令字长等于存储字长的 2 倍，则需要 2 次访存来取出一条指令，因此取指周期为机器周期的 2 倍；若指令字长等于存储字长，则取指周期等于机器周期。</p><p>早期的计算机存储字长一般和机器的指令字长与数据字长相等，因此访问一次主存便可取出一条指令或一个数据。随着计算机的发展，指令字长可变，数据字长也可变，但它们必须都是字节的整数倍。</p><p>请注意 64 位操作系统是指特别为 64 位架构的计算机而设计的操作系统，它能够利用 64 位处理器的优势。但 64 位机器既可以使用 64 位操作系统，又可以使用 32 位操作系统。而 32 位处理器是无法使用 64 位操作系统的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;计算机系统的组成&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#计算机系统的组成&quot;&gt;&lt;/a&gt;计算机系统的组成&lt;/h2&gt;
&lt;p&gt;硬件系统和软件系统共同构成了一个完整的计算机系统。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;硬件是指有形的物理设备，是计算机系统中实</summary>
      
    
    
    
    <category term="计算机组成原理" scheme="http://halo123.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="计算机组成原理" scheme="http://halo123.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>内存管理</title>
    <link href="http://halo123.top/2021/05/25/ComputerOperatingSystem/D_%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://halo123.top/2021/05/25/ComputerOperatingSystem/D_%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2021-05-25T15:33:05.000Z</published>
    <updated>2021-05-26T04:52:10.894Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存管理概念"><a class="header-anchor" href="#内存管理概念"></a>内存管理概念</h2><h3 id="内存管理的基本原理和要求"><a class="header-anchor" href="#内存管理的基本原理和要求"></a>内存管理的基本原理和要求</h3><h2 id="虚拟内存管理"><a class="header-anchor" href="#虚拟内存管理"></a>虚拟内存管理</h2>]]></content>
    
    
    <summary type="html">内存管理</summary>
    
    
    
    <category term="操作系统" scheme="http://halo123.top/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://halo123.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>VSCode下C\C++开发环境配置</title>
    <link href="http://halo123.top/2021/05/24/C/VSCode%E4%B8%8BC%E5%BC%80%E5%8F%91/"/>
    <id>http://halo123.top/2021/05/24/C/VSCode%E4%B8%8BC%E5%BC%80%E5%8F%91/</id>
    <published>2021-05-24T13:15:36.000Z</published>
    <updated>2021-05-24T16:21:04.541Z</updated>
    
    <content type="html"><![CDATA[<p>参考视频：<a href="https://www.bilibili.com/video/BV13K411M78v">https://www.bilibili.com/video/BV13K411M78v</a></p><h2 id="开发环境搭建"><a class="header-anchor" href="#开发环境搭建"></a>开发环境搭建</h2><p>mingw-w64 编译器 <a href="http://www.mingw-w64.org/doku.php/download">官网下载链接</a></p><p>Cmake工具 <a href="https://cmake.org/download/">官网下载链接</a></p><p>将下载的压缩包解压，并将 解压后的文件夹的 bin 文件夹目录放到环境变量中。</p><p>VSCode插件，在插件中搜索下载</p><ul><li>C\C++：智能提示、debug和代码浏览</li><li>Cmake：Cmake 的语法支持</li><li>Cmake Tools：Cmake 的扩展支持</li></ul><p>Cmake Tools 安装的坑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bad CMake executable . Is it installed or settings contain the correct path (cmake.cmakePath)? </span><br></pre></td></tr></table></figure><p>Cmake Tools版本为1.7.3。解决方法是在设置中（[Settings]-&gt;[Extensions]-&gt;[CMake Tools Configuration]-&gt;[CMake:Cmake Path]）指定 cmake.exe 的文件地址。具体方法是打开设置（快捷键 Ctrl+逗号）搜索 cmake.cmakePath 可以看到 Name/path of the CMake executable to use. 默认为 cmake 将其设置自己安装 cmake.exe 文件地址，例如我的设置是 E:\Program\Develop\Cmake\bin\cmake.exe。</p><p>参考解决地址：<a href="https://github.com/microsoft/vscode-cmake-tools/issues/685">https://github.com/microsoft/vscode-cmake-tools/issues/685</a></p><h2 id="基于-g-命令"><a class="header-anchor" href="#基于-g-命令"></a>基于 g++ 命令</h2><h3 id="编译单文件"><a class="header-anchor" href="#编译单文件"></a>编译单文件</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val1 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> val2 = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Before swap:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;val1 = &quot;</span> &lt;&lt; val1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;val2 = &quot;</span> &lt;&lt; val2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap</span>(val1, val2);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After swap:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;val1 = &quot;</span> &lt;&lt; val1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;val2 = &quot;</span> &lt;&lt; val2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里顺便写段实例代码，打开命令行 VSCode 默认快捷键为 Ctrl 加 反引号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">E:\Project\CodeBase\C\VSCode&gt;g++ .\main.cpp</span><br><span class="line"></span><br><span class="line">E:\Project\CodeBase\C\VSCode&gt;.\a.exe</span><br><span class="line">Before swap:</span><br><span class="line">val1 &#x3D; 10   </span><br><span class="line">val2 &#x3D; 20   </span><br><span class="line">After swap: </span><br><span class="line">val1 &#x3D; 20   </span><br><span class="line">val2 &#x3D; 10  </span><br></pre></td></tr></table></figure><p>这里会默认生成 a.exe 可执行文件，通过命令行可以运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E:\Project\CodeBase\C\VSCode&gt; g++ -g .\main.cpp -o swap</span><br></pre></td></tr></table></figure><p>通过上一段命令可以生成名为 swap 的可调试的可执行文件</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/VSCode%E9%85%8D%E7%BD%AElaunch.json.png" alt="VSCode配置launch"></p><p>选择 g++.exe - Build and debug active file ，会在目录 .vscode 下自动生成 launch.json 文件夹，同时产生了与 cpp 同名的 .exe 文件用于断点调试</p><h3 id="编译多文件"><a class="header-anchor" href="#编译多文件"></a>编译多文件</h3><p>将上述代码拆分成多个文件如下：</p><p>many_main.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;many.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val1 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> val2 = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Before swap:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;val1 = &quot;</span> &lt;&lt; val1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;val2 = &quot;</span> &lt;&lt; val2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap</span>(val1, val2);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After swap:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;val1 = &quot;</span> &lt;&lt; val1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;val2 = &quot;</span> &lt;&lt; val2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>many_swap.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;many.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>many.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span>;</span><br></pre></td></tr></table></figure><p>通过 g++ 编译多文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -g .\many_main.cpp .\many_swap.cpp -o many_swap </span><br></pre></td></tr></table></figure><p>如果使用 VSCode 默认生成的 launch.json 进行调试会出错，这里需要进行配置，修改<code>program</code> 属性为 g++ 生成的可调式的可执行文件名，并注释 <code>preLaunchTask</code>，这里因为自己使用 g++ 命令编程完成，不在需要 VSCode 进行编译</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;g++.exe - Build and debug active file&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;cppdbg&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;program&quot;</span>: <span class="string">&quot;$&#123;fileDirname&#125;\\many_swap.exe&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;environment&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span>: <span class="string">&quot;gdb&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;miDebuggerPath&quot;</span>: <span class="string">&quot;E:\\Program\\Develop\\MinGW\\mingw64\\bin\\gdb.exe&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;Enable pretty-printing for gdb&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;-enable-pretty-printing&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span>: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="comment">// &quot;preLaunchTask&quot;: &quot;C/C++: g++.exe build active file&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基于-Cmake"><a class="header-anchor" href="#基于-Cmake"></a>基于 Cmake</h2><p>在主目录中新建 CMakeLists.txt</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">project(SWAP)</span><br><span class="line"></span><br><span class="line">add_executable(cmake_swap many_main.cpp many_swap.cpp)</span><br></pre></td></tr></table></figure><p>使用 Shift + Ctrl + P 调出配置搜索，搜索 CMake:Configure 选择 mingw</p><p>之后会自动生成 build 文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">E:\Project\CodeBase\C\VSCode&gt;cd build</span><br><span class="line"></span><br><span class="line">E:\Project\CodeBase\C\VSCode\build&gt;cmake ..</span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: E:&#x2F;Project&#x2F;CodeBase&#x2F;C&#x2F;VSCode&#x2F;build</span><br><span class="line"></span><br><span class="line">E:\Project\CodeBase\C\VSCode\build&gt;mingw32-make.exe</span><br></pre></td></tr></table></figure><p>就会在 build 文件夹中生成 cmake_swap.exe （根据 CMakeLists.txt 配置生成）</p><p>如果电脑中安装了 VS 可以会调用微软的 MSVC 编译器，第一次使用时用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -G &quot;MinGW Makefiles&quot; ..</span><br></pre></td></tr></table></figure><p>来代替</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake ..</span><br></pre></td></tr></table></figure><h2 id="修改-launch-json-和-tasks-json"><a class="header-anchor" href="#修改-launch-json-和-tasks-json"></a>修改 launch.json 和 tasks.json</h2><p>launch.json 需要关注的点为：</p><ul><li><code>program</code>：可执行文件的路径</li><li><code>preLaunchTask</code>：对应 tasks.json 的 <code>label</code> 属性的值</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;g++.exe - Build and debug active file&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;cppdbg&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;program&quot;</span>: <span class="string">&quot;$&#123;fileDirname&#125;\\build\\cmake_swap.exe&quot;</span>,</span><br><span class="line">            <span class="comment">// 调试时需要添加的参数</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;environment&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span>: <span class="string">&quot;gdb&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;miDebuggerPath&quot;</span>: <span class="string">&quot;E:\\Program\\Develop\\MinGW\\mingw64\\bin\\gdb.exe&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;Enable pretty-printing for gdb&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;-enable-pretty-printing&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span>: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;preLaunchTask&quot;</span>: <span class="string">&quot;C/C++: g++.exe build active file&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tasks.json 用于调试之前的编译工作指令，需要关注的点为：</p><ul><li><code>args</code>：多文件需要指定文件名</li><li><code>label</code>：与 launch.json 的 <code>preLaunchTask</code> 对应</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;cppbuild&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;label&quot;</span>: <span class="string">&quot;C/C++: g++.exe build active file&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;E:\\Program\\Develop\\MinGW\\mingw64\\bin\\g++.exe&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;-g&quot;</span>,</span><br><span class="line">                <span class="string">&quot;$&#123;file&#125;&quot;</span>,</span><br><span class="line">                <span class="string">&quot;-o&quot;</span>,</span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;options&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;problemMatcher&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;$gcc&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;group&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;kind&quot;</span>: <span class="string">&quot;build&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;isDefault&quot;</span>: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;detail&quot;</span>: <span class="string">&quot;Task generated by Debugger.&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;2.0.0&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 CMake 文件的自动配置 tasks.json 如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;2.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;options&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;fileDirname&#125;/build&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;shell&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;label&quot;</span>: <span class="string">&quot;cmake&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;cmake&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;..&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;label&quot;</span>: <span class="string">&quot;make&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;group&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;kind&quot;</span>: <span class="string">&quot;build&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;isDefault&quot;</span>: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;mingw32-make.exe&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: []</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;label&quot;</span>: <span class="string">&quot;Build&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;dependsOn&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;cmake&quot;</span>,</span><br><span class="line">                <span class="string">&quot;make&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考视频：&lt;a href=&quot;https://www.bilibili.com/video/BV13K411M78v&quot;&gt;https://www.bilibili.com/video/BV13K411M78v&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;开发环境搭建&quot;&gt;&lt;a class=&quot;</summary>
      
    
    
    
    <category term="C\C++" scheme="http://halo123.top/categories/C-C/"/>
    
    
    <category term="C" scheme="http://halo123.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Java IO</title>
    <link href="http://halo123.top/2021/05/23/Java/Java-I-IO/"/>
    <id>http://halo123.top/2021/05/23/Java/Java-I-IO/</id>
    <published>2021-05-23T08:31:54.000Z</published>
    <updated>2021-05-23T08:57:49.506Z</updated>
    
    <content type="html"><![CDATA[<p>参考资料：《Java 技术手册》</p><h2 id="File-类"><a class="header-anchor" href="#File-类"></a>File 类</h2><p>File 类是对文件系统中文件以及文件夹进行操作的类，可以通过面向对象的思想操作文件和文件夹。是以前 Java 处理文件 I/O 的基础。这个抽象既能表示文件，也能表示目录，不过有时使用起来有些麻烦，写出的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个文件对象，表示用户的家目录</span></span><br><span class="line">File homedir = <span class="keyword">new</span> File(System.getProperty(<span class="string">&quot;user.home&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个对象，表示配置文件</span></span><br><span class="line"><span class="comment">// （家目录中应该存在这个文件）</span></span><br><span class="line">File f = <span class="keyword">new</span> File(homedir, <span class="string">&quot;app.conf&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查文件是否存在，是否真是文件，以及是否可读</span></span><br><span class="line"><span class="keyword">if</span> (f.exists() &amp;&amp; f.isFile() &amp;&amp; f.canRead()) &#123;</span><br><span class="line">    <span class="comment">// 创建一个文件对象，表示新配置目录</span></span><br><span class="line">    File configdir = <span class="keyword">new</span> File(f, <span class="string">&quot;.configdir&quot;</span>);</span><br><span class="line">    <span class="comment">// 然后创建这个目录</span></span><br><span class="line">    configdir.mkdir();</span><br><span class="line">    <span class="comment">// 最后，把配置文件移到新位置</span></span><br><span class="line">    f.renameTo(<span class="keyword">new</span> File(configdir, <span class="string">&quot;.config&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码展现了 File 类使用灵活的一面，但也演示了这种抽象带来的一些问题。一般情况下，需要调用很多方法查询 File 对象才能判断这个对象到底表示的是什么，以及具有什么能力。</p><p>File 类中有相当多的方法，但根本没有直接提供一些基本功能（尤其是无法读取文件的内容），下述代码简要总结了 File 类中的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 权限管理</span></span><br><span class="line"><span class="keyword">boolean</span> canX = f.canExecute();</span><br><span class="line"><span class="keyword">boolean</span> canR = f.canRead();</span><br><span class="line"><span class="keyword">boolean</span> canW = f.canWrite();</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> ok;</span><br><span class="line">ok = f.setReadOnly();</span><br><span class="line">ok = f.setExecutable(<span class="keyword">true</span>);</span><br><span class="line">ok = f.setReadable(<span class="keyword">true</span>);</span><br><span class="line">ok = f.setWritable(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用不同的方式表示文件名</span></span><br><span class="line">File absF = f.getAbsoluteFile();</span><br><span class="line">File canF = f.getCanonicalFile();</span><br><span class="line">String absName = f.getAbsolutePath();</span><br><span class="line">String canName = f.getCanonicalPath();</span><br><span class="line">String name = f.getName();</span><br><span class="line">String pName = getParent();</span><br><span class="line">URI fileURI = f.toURI(); <span class="comment">// 创建文件路径的URI形式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件的元数据</span></span><br><span class="line"><span class="keyword">boolean</span> exists = f.exists();</span><br><span class="line"><span class="keyword">boolean</span> isAbs = f.isAbsolute();</span><br><span class="line"><span class="keyword">boolean</span> isDir = f.isDirectory();</span><br><span class="line"><span class="keyword">boolean</span> isFile = f.isFile();</span><br><span class="line"><span class="keyword">boolean</span> isHidden = f.isHidden();</span><br><span class="line"><span class="keyword">long</span> modTime = f.lastModified(); <span class="comment">// 距Epoch时间的毫秒数</span></span><br><span class="line"><span class="keyword">boolean</span> updateOK = f.setLastModified(updateTime); <span class="comment">// 毫秒</span></span><br><span class="line"><span class="keyword">long</span> fileLen = f.length();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件管理操作</span></span><br><span class="line"><span class="keyword">boolean</span> renamed = f.renameTo(destFile);</span><br><span class="line"><span class="keyword">boolean</span> deleted = f.delete();</span><br><span class="line"><span class="comment">// 创建文件不会覆盖现有文件</span></span><br><span class="line"><span class="keyword">boolean</span> createdOK = f.createNewFile();</span><br><span class="line"><span class="comment">// 处理临时文件</span></span><br><span class="line">File tmp = File.createTempFile(<span class="string">&quot;my-tmp&quot;</span>, <span class="string">&quot;.tmp&quot;</span>);</span><br><span class="line">tmp.deleteOnExit();</span><br><span class="line"><span class="comment">// 处理目录</span></span><br><span class="line"><span class="keyword">boolean</span> createdDir = dir.mkdir();</span><br><span class="line">String[] fileNames = dir.list();</span><br><span class="line">File[] files = dir.listFiles();</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考资料：《Java 技术手册》&lt;/p&gt;
&lt;h2 id=&quot;File-类&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#File-类&quot;&gt;&lt;/a&gt;File 类&lt;/h2&gt;
&lt;p&gt;File 类是对文件系统中文件以及文件夹进行操作的类，可以通过面向对象的思想操作文</summary>
      
    
    
    
    <category term="Java" scheme="http://halo123.top/categories/Java/"/>
    
    
    <category term="Java" scheme="http://halo123.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 泛型</title>
    <link href="http://halo123.top/2021/05/20/Java/Java-G-%E6%B3%9B%E5%9E%8B/"/>
    <id>http://halo123.top/2021/05/20/Java/Java-G-%E6%B3%9B%E5%9E%8B/</id>
    <published>2021-05-20T13:47:40.000Z</published>
    <updated>2021-05-23T08:37:21.121Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是泛型"><a class="header-anchor" href="#什么是泛型"></a>什么是泛型</h2><p>在讲解什么是泛型之前，我们先观察 Java 标准库提供的 <code>ArrayList</code>，它可以看作“可变长度”的数组，因为用起来比数组更方便。</p><p>实际上 <code>ArrayList</code> 内部就是一个 <code>Object[]</code> 数组，配合存储一个当前分配的长度，就可以充当“可变数组”：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object e)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用上述 <code>ArrayList</code> 存储 String 类型，会有这么几个缺点：</p><ul><li>需要强制转型；</li><li>不方便，易出错。</li></ul><p>例如，代码必须这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="comment">// 获取到Object，必须强制转型为String:</span></span><br><span class="line">String first = (String) list.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>很容易出现 <code>ClassCastException</code>，因为容易“误转型”：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list.add(<span class="keyword">new</span> Integer(<span class="number">123</span>));</span><br><span class="line"><span class="comment">// ERROR: ClassCastException:</span></span><br><span class="line">String second = (String) list.get(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>要解决上述问题，我们可以为 String 单独编写一种 ArrayList：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringArrayList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String e)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，存入的必须是 String，取出的也一定是 String，不需要强制转型，因为编译器会强制检查放入的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StringArrayList list = <span class="keyword">new</span> StringArrayList();</span><br><span class="line">list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">String first = list.get(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 编译错误: 不允许放入非String类型:</span></span><br><span class="line">list.add(<span class="keyword">new</span> Integer(<span class="number">123</span>));</span><br></pre></td></tr></table></figure><p>问题暂时解决。然而，新的问题是，如果要存储 Integer，还需要为 Integer 单独编写一种 ArrayList，实际上，还需要为其他所有 class 单独编写一种 ArrayList。这是不可能的，JDK 的 class 就有上千个，而且它还不知道其他人编写的 class。</p><p>为了解决新的问题，我们必须把 <code>ArrayList</code> 变成一种模板：<code>ArrayList&lt;T&gt;</code>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T e)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>T</code> 可以是任何 class。这样一来，我们就实现了，编写一次模版，可以创建任意类型的 <code>ArrayList</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建可以存储String的ArrayList:</span></span><br><span class="line">ArrayList&lt;String&gt; strList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="comment">// 创建可以存储Float的ArrayList:</span></span><br><span class="line">ArrayList&lt;Float&gt; floatList = <span class="keyword">new</span> ArrayList&lt;Float&gt;();</span><br><span class="line"><span class="comment">// 创建可以存储Person的ArrayList:</span></span><br><span class="line">ArrayList&lt;Person&gt; personList = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br></pre></td></tr></table></figure><p>因此，泛型就是定义一种模板，例如 <code>ArrayList&lt;T&gt;</code>，然后在代码中为用到的类创建对应的 <code>ArrayList&lt;类型&gt;</code>。由编译器针对类型作检查：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">strList.add(<span class="string">&quot;hello&quot;</span>); <span class="comment">// OK</span></span><br><span class="line">String s = strList.get(<span class="number">0</span>); <span class="comment">// OK</span></span><br><span class="line">strList.add(<span class="keyword">new</span> Integer(<span class="number">123</span>)); <span class="comment">// compile error!</span></span><br><span class="line">Integer n = strList.get(<span class="number">0</span>); <span class="comment">// compile error!</span></span><br></pre></td></tr></table></figure><p>这样一来，既实现了编写一次，万能匹配，又通过编译器保证了类型安全：这就是泛型。</p><h3 id="向上转型"><a class="header-anchor" href="#向上转型"></a>向上转型</h3><p>在 Java 标准库中的 <code>ArrayList&lt;T&gt;</code> 实现了 <code>List&lt;T&gt;</code> 接口，它可以向上转型为 <code>List&lt;T&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即类型 <code>ArrayList&lt;T&gt;</code> 可以向上转型为 <code>List&lt;T&gt;</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure><p>要特别注意：不能把 <code>ArrayList&lt;Integer&gt;</code> 向上转型为 <code>ArrayList&lt;Number&gt;</code> 或 <code>List&lt;Number&gt;</code> 。</p><p>假设 <code>ArrayList&lt;Integer&gt;</code> 可以向上转型为 <code>ArrayList&lt;Number&gt;</code>，观察一下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建ArrayList&lt;Integer&gt;类型：</span></span><br><span class="line">ArrayList&lt;Integer&gt; integerList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"><span class="comment">// 添加一个Integer：</span></span><br><span class="line">integerList.add(<span class="keyword">new</span> Integer(<span class="number">123</span>));</span><br><span class="line"><span class="comment">// “向上转型”为ArrayList&lt;Number&gt;：</span></span><br><span class="line">ArrayList&lt;Number&gt; numberList = integerList;</span><br><span class="line"><span class="comment">// 添加一个Float，因为Float也是Number：</span></span><br><span class="line">numberList.add(<span class="keyword">new</span> Float(<span class="number">12.34</span>));</span><br><span class="line"><span class="comment">// 从ArrayList&lt;Integer&gt;获取索引为1的元素（即添加的Float）：</span></span><br><span class="line">Integer n = integerList.get(<span class="number">1</span>); <span class="comment">// ClassCastException!</span></span><br></pre></td></tr></table></figure><p>我们把一个 <code>ArrayList&lt;Integer&gt;</code> 转型为 <code>ArrayList&lt;Number&gt;</code> 类型后，这个 <code>ArrayList&lt;Number&gt;</code> 就可以接受 Float 类型，因为 Float 是 Number 的子类。但是，<code>ArrayList&lt;Number&gt;</code> 实际上和 <code>ArrayList&lt;Integer&gt;</code> 是同一个对象，也就是 <code>ArrayList&lt;Integer&gt;</code> 类型，它不可能接受 Float 类型， 所以在获取 Integer 的时候将产生  <code>ClassCastException</code>。</p><p>实际上，编译器为了避免这种错误，根本就不允许把 <code>ArrayList&lt;Integer&gt;</code> 转型为 <code>ArrayList&lt;Number&gt;</code>。</p><p><code>ArrayList&lt;Integer&gt;</code> 和 <code>ArrayList&lt;Number&gt;</code> 两者完全没有继承关系。</p><h2 id="使用泛型"><a class="header-anchor" href="#使用泛型"></a>使用泛型</h2><p>使用 ArrayList 时，如果不定义泛型类型时，泛型类型实际上就是 Object：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译器警告</span></span><br><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">String first = (String) list.get(<span class="number">0</span>);</span><br><span class="line">String second = (String) list.get(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>此时，只能把 <code>&lt;T&gt;</code> 当作 Object 使用，没有发挥泛型的优势。</p><p>当我们定义泛型类型 <code>&lt;String&gt;</code> 后，<code>List&lt;T&gt;</code> 的泛型接口变为强类型 <code>List&lt;String&gt;</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无编译器警告</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;World&quot;</span>);</span><br><span class="line"><span class="comment">// 无强制转型:</span></span><br><span class="line">String first = list.get(<span class="number">0</span>);</span><br><span class="line">String second = list.get(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>当我们定义泛型类型 <code>&lt;Number&gt;</code> 后，<code>List&lt;T&gt;</code> 的泛型接口变为强类型 <code>List&lt;Number&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Number&gt; list = <span class="keyword">new</span> ArrayList&lt;Number&gt;();</span><br><span class="line">list.add(<span class="keyword">new</span> Integer(<span class="number">123</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> Double(<span class="number">12.34</span>));</span><br><span class="line">Number first = list.get(<span class="number">0</span>);</span><br><span class="line">Number second = list.get(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>编译器如果能自动推断出泛型类型，就可以省略后面的泛型类型。例如，对于下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Number&gt; list = <span class="keyword">new</span> ArrayList&lt;Number&gt;();</span><br></pre></td></tr></table></figure><p>编译器看到泛型类型 <code>List&lt;Number&gt;</code> 就可以自动推断出后面的 <code>ArrayList&lt;T&gt;</code> 的泛型类型必须是 <code>ArrayList&lt;Number&gt;</code>，因此，可以把代码简写为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以省略后面的Number，编译器可以自动推断泛型类型</span></span><br><span class="line">List&lt;Number&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>除了 <code>ArrayList&lt;T&gt;</code> 使用了泛型，还可以在接口中使用泛型。例如，<code>Arrays.sort(Object[])</code> 可以对任意数组进行排序，但待排序的元素必须实现 <code>Comparable&lt;T&gt;</code> 这个泛型接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回负数: 当前实例比参数o小</span></span><br><span class="line"><span class="comment">     * 返回0: 当前实例与参数o相等</span></span><br><span class="line"><span class="comment">     * 返回正数: 当前实例比参数o大</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以直接对 String 数组进行排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] ss = <span class="keyword">new</span> String[] &#123; <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Pear&quot;</span> &#125;;</span><br><span class="line">Arrays.sort(ss);</span><br><span class="line">System.out.println(Arrays.toString(ss));</span><br></pre></td></tr></table></figure><p>这是因为 String 本身已经实现了 <code>Comparable&lt;String&gt;</code> 接口。如果换成我们自定义的 Person 类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sort</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person[] ps = <span class="keyword">new</span> Person[]&#123;</span><br><span class="line">                <span class="keyword">new</span> Person(<span class="string">&quot;Bob&quot;</span>, <span class="number">61</span>),</span><br><span class="line">                <span class="keyword">new</span> Person(<span class="string">&quot;Alice&quot;</span>, <span class="number">88</span>),</span><br><span class="line">                <span class="keyword">new</span> Person(<span class="string">&quot;Lily&quot;</span>, <span class="number">75</span>),</span><br><span class="line">        &#125;;</span><br><span class="line">        Arrays.sort(ps);</span><br><span class="line">        System.out.println(Arrays.toString(ps));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    Person(String name, <span class="keyword">int</span> score) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">&quot;,&quot;</span> + <span class="keyword">this</span>.score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，我们会得到 <code>ClassCastException</code>，即无法将 Person 转型为 Comparable。我们修改代码，让 Person 实现 <code>Comparable&lt;T&gt;</code> 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    Person(String name, <span class="keyword">int</span> score) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name.compareTo(other.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">&quot;,&quot;</span> + <span class="keyword">this</span>.score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码，可以正确实现按 <code>name</code> 进行排序。也可以修改比较逻辑，例如，按 <code>score</code> 从高到低排序。</p><h2 id="编写泛型"><a class="header-anchor" href="#编写泛型"></a>编写泛型</h2><p>编写泛型类比普通类要复杂。通常来说，泛型类一般用在集合类中，例如 <code>ArrayList&lt;T&gt;</code>，我们很少需要编写泛型类。</p><p>如果我们确实需要编写一个泛型类，那么，应该如何编写它？</p><p>可以按照以下步骤来编写一个泛型类。</p><p>首先，按照某种类型，例如 <code>String</code>，来编写类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String first;</span><br><span class="line">    <span class="keyword">private</span> String last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(String first, String last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，标记所有的特定类型，这里是 <code>String</code>，最后，把特定类型 <code>String</code> 替换为 <code>T</code>，并申明 <code>&lt;T&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>熟练后即可直接从 <code>T</code> 开始编写。</p><h3 id="静态方法"><a class="header-anchor" href="#静态方法"></a>静态方法</h3><p>编写泛型类时，要特别注意，泛型类型 <code>&lt;T&gt;</code> 不能用于静态方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对静态方法使用&lt;T&gt;:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Pair&lt;T&gt; <span class="title">create</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(first, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码会导致编译错误，我们无法在静态方法 <code>create()</code> 的方法参数和返回类型上使用泛型类型 <code>T</code>。</p><p>可以在 <code>static</code> 修饰符后面加一个 <code>&lt;T&gt;</code>，编译就能通过：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以编译通过</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">create</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(first, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但实际上，这个 <code>&lt;T&gt;</code> 和 <code>Pair&lt;T&gt;</code> 类型的 <code>&lt;T&gt;</code> 已经没有任何关系了。</p><p>对于静态方法，我们可以单独改写为“泛型”方法，只需要使用另一个类型即可。对于上面的 <code>create()</code> 静态方法，我们应该把它改为另一种泛型类型，例如，<code>&lt;K&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态泛型方法应该使用其他类型区分</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K&gt; <span class="function">Pair&lt;K&gt; <span class="title">create</span><span class="params">(K first, K last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;K&gt;(first, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样才能清楚地将静态方法的泛型类型和实例类型的泛型类型区分开。</p><h3 id="多个泛型类型"><a class="header-anchor" href="#多个泛型类型"></a>多个泛型类型</h3><p>泛型还可以定义多种类型。例如，我们希望 <code>Pair</code> 不总是存储两个类型一样的对象，就可以使用类型 <code>&lt;T, K&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>, <span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> K last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, K last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getLast</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的时候，需要指出两种类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String, Integer&gt; p = <span class="keyword">new</span> Pair&lt;&gt;(<span class="string">&quot;test&quot;</span>, <span class="number">123</span>);</span><br></pre></td></tr></table></figure><p>Java 标准库的 <code>Map&lt;K, V&gt;</code> 就是使用两种泛型类型的例子。它对 Key 使用一种类型，对 Value 使用另一种类型。</p><h3 id="擦拭法"><a class="header-anchor" href="#擦拭法"></a>擦拭法</h3><p>泛型是一种类似“模板代码”的技术，不同语言的泛型实现方式不一定相同。Java 语言的泛型实现方式是擦拭法（Type Erasure）。</p><p>所谓擦拭法是指，虚拟机对泛型其实一无所知，所有的工作都是编译器做的。例如，我们编写了一个泛型类 <code>Pair&lt;T&gt;</code>，这是编译器看到的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而虚拟机根本不知道泛型。这是虚拟机执行的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object first;</span><br><span class="line">    <span class="keyword">private</span> Object last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(Object first, Object last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，Java 使用擦拭法实现泛型，导致了：</p><ul><li>编译器把类型 <code>&lt;T&gt;</code> 视为 Object；</li><li>编译器根据 <code>&lt;T&gt;</code> 实现安全的强制转型。</li></ul><p>使用泛型的时候，我们编写的代码也是编译器看到的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt; p = <span class="keyword">new</span> Pair&lt;&gt;(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">String first = p.getFirst();</span><br><span class="line">String last = p.getLast();</span><br></pre></td></tr></table></figure><p>而虚拟机执行的代码并没有泛型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pair p = <span class="keyword">new</span> Pair(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">String first = (String) p.getFirst();</span><br><span class="line">String last = (String) p.getLast();</span><br></pre></td></tr></table></figure><p>所以，Java 的泛型是由编译器在编译时实行的，编译器内部永远把所有类型 <code>T</code> 视为 Object 处理，但是，在需要转型的时候，编译器会根据 <code>T</code> 的类型自动为我们实行安全地强制转型。</p><p>了解了 Java 泛型的实现方式——擦拭法，我们就知道了 Java 泛型的局限：</p><p>局限一：<code>&lt;T&gt;</code> 不能是基本类型，例如 int，因为实际类型是 Object，Object 类型无法持有基本类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;<span class="keyword">int</span>&gt; p = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// compile error!</span></span><br></pre></td></tr></table></figure><p>局限二：无法取得带泛型的 Class。观察以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pair&lt;String&gt; p1 = <span class="keyword">new</span> Pair&lt;&gt;(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">        Pair&lt;Integer&gt; p2 = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">        Class c1 = p1.getClass();</span><br><span class="line">        Class c2 = p2.getClass();</span><br><span class="line">        System.out.println(c1==c2); <span class="comment">// true</span></span><br><span class="line">        System.out.println(c1==Pair.class); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>T</code> 是 Object，我们对 <code>Pair&lt;String&gt;</code> 和 <code>Pair&lt;Integer&gt;</code> 类型获取 Class 时，获取到的是同一个 Class，也就是 Pair 类的 Class。</p><p>换句话说，所有泛型实例，无论 <code>T</code> 的类型是什么，<code>getClass()</code> 返回同一个 <code>Class</code> 实例，因为编译后它们全部都是 <code>Pair&lt;Object&gt;</code>。</p><p>局限三：无法判断带泛型的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Integer&gt; p = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line"><span class="comment">// Compile error:</span></span><br><span class="line"><span class="keyword">if</span> (p <span class="keyword">instanceof</span> Pair&lt;String&gt;) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因和前面一样，并不存在 <code>Pair&lt;String&gt;.class</code>，而是只有唯一的 <code>Pair.class</code>。</p><p>局限四：不能实例化 <code>T</code> 类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Compile error:</span></span><br><span class="line">        first = <span class="keyword">new</span> T();</span><br><span class="line">        last = <span class="keyword">new</span> T();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码无法通过编译，因为构造方法的两行语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">first = <span class="keyword">new</span> T();</span><br><span class="line">last = <span class="keyword">new</span> T();</span><br></pre></td></tr></table></figure><p>擦拭后实际上变成了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">first = <span class="keyword">new</span> Object();</span><br><span class="line">last = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><p>这样一来，创建 <code>new Pair&lt;String&gt;()</code> 和创建 <code>new Pair&lt;Integer&gt;()</code> 就全部成了 Object，显然编译器要阻止这种类型不对的代码。</p><p>要实例化 <code>T</code> 类型，我们必须借助额外的 <code>Class&lt;T&gt;</code> 参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        first = clazz.newInstance();</span><br><span class="line">        last = clazz.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码借助 <code>Class&lt;T&gt;</code> 参数并通过反射来实例化T类型，使用的时候，也必须传入 <code>Class&lt;T&gt;</code> 。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt; pair = <span class="keyword">new</span> Pair&lt;&gt;(String.class);</span><br></pre></td></tr></table></figure><p>因为传入了 <code>Class&lt;String&gt;</code> 的实例，所以我们借助 <code>String.class</code> 就可以实例化 String 类型。</p><h3 id="不恰当的覆写方法"><a class="header-anchor" href="#不恰当的覆写方法"></a>不恰当的覆写方法</h3><p>有些时候，一个看似正确定义的方法会无法通过编译。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span> == t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为，定义的 <code>equals(T t)</code> 方法实际上会被擦拭成 <code>equals(Object t)</code>，而这个方法是继承自 Object 的，编译器会阻止一个实际上会变成覆写的泛型方法定义。</p><p>换个方法名，避开与 <code>Object.equals(Object)</code> 的冲突就可以成功编译：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">same</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span> == t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型继承"><a class="header-anchor" href="#泛型继承"></a>泛型继承</h3><p>一个类可以继承自一个泛型类。例如：父类的类型是 <code>Pair&lt;Integer&gt;</code>，子类的类型是 <code>IntPair</code>，可以这么继承：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntPair</span> <span class="keyword">extends</span> <span class="title">Pair</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的时候，因为子类 <code>IntPair</code> 并没有泛型类型，所以，正常使用即可。</p><p>前面讲了，我们无法获取 <code>Pair&lt;T&gt;</code> 的 <code>T</code> 类型，即给定一个变量 <code>Pair&lt;Integer&gt; p</code>，无法从 <code>p</code> 中获取到 <code>Integer</code> 类型。</p><p>但是，在父类是泛型类型的情况下，编译器就必须把类型 <code>T</code>（对 <code>IntPair</code> 来说，也就是 <code>Integer</code> 类型）保存到子类的 class 文件中，不然编译器就不知道 <code>IntPair</code> 只能存取 Integer 这种类型。</p><p>在继承了泛型类型的情况下，子类可以获取父类的泛型类型。例如：<code>IntPair</code> 可以获取到父类的泛型类型 Integer。获取父类的泛型类型代码比较复杂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.ParameterizedType;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class&lt;IntPair&gt; clazz = IntPair.class;</span><br><span class="line">        Type t = clazz.getGenericSuperclass();</span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">            ParameterizedType pt = (ParameterizedType) t;</span><br><span class="line">            Type[] types = pt.getActualTypeArguments(); <span class="comment">// 可能有多个泛型类型</span></span><br><span class="line">            Type firstType = types[<span class="number">0</span>]; <span class="comment">// 取第一个泛型类型</span></span><br><span class="line">            Class&lt;?&gt; typeClass = (Class&lt;?&gt;) firstType;</span><br><span class="line">            System.out.println(typeClass); <span class="comment">// Integer</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntPair</span> <span class="keyword">extends</span> <span class="title">Pair</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IntPair</span><span class="params">(Integer first, Integer last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(first, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 Java 引入了泛型，所以，只用 Class 来标识类型已经不够了。实际上，Java 的类型系统结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">                      ┌────┐</span><br><span class="line">                      │Type│</span><br><span class="line">                      └────┘</span><br><span class="line">                         ▲</span><br><span class="line">                         │</span><br><span class="line">   ┌────────────┬────────┴─────────┬───────────────┐</span><br><span class="line">   │            │                  │               │</span><br><span class="line">┌─────┐┌─────────────────┐┌────────────────┐┌────────────┐</span><br><span class="line">│Class││ParameterizedType││GenericArrayType││WildcardType│</span><br><span class="line">└─────┘└─────────────────┘└────────────────┘└────────────┘</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="extends-通配符"><a class="header-anchor" href="#extends-通配符"></a>extends 通配符</h2><p>我们前面已经讲到了泛型的继承关系：<code>Pair&lt;Integer&gt;</code> 不是 <code>Pair&lt;Number&gt;</code> 的子类。</p><p>假设我们定义了 <code>Pair&lt;T&gt;</code>，然后，我们又针对 <code>Pair&lt;Number&gt;</code> 类型写了一个静态方法，它接收的参数类型是 <code>Pair&lt;Number&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PairHelper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(Pair&lt;Number&gt; p)</span> </span>&#123;</span><br><span class="line">        Number first = p.getFirst();</span><br><span class="line">        Number last = p.getLast();</span><br><span class="line">        <span class="keyword">return</span> first.intValue() + last.intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码是可以正常编译的。使用的时候，我们传入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = PairHelper.add(<span class="keyword">new</span> Pair&lt;Number&gt;(<span class="number">1</span>, <span class="number">2</span>));</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">泛型是一种“代码模板”，可以用一套代码套用各种类型。</summary>
    
    
    
    <category term="Java" scheme="http://halo123.top/categories/Java/"/>
    
    
    <category term="Java" scheme="http://halo123.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 反射</title>
    <link href="http://halo123.top/2021/05/20/Java/Java-E-%E5%8F%8D%E5%B0%84/"/>
    <id>http://halo123.top/2021/05/20/Java/Java-E-%E5%8F%8D%E5%B0%84/</id>
    <published>2021-05-20T09:42:40.000Z</published>
    <updated>2021-05-20T12:55:43.553Z</updated>
    
    <content type="html"><![CDATA[<p>反射（Reflection），Java 的反射是指程序在运行期可以拿到一个对象的所有信息。</p><p>正常情况下，如果我们要调用一个对象的方法，或者访问一个对象的字段，通常会传入对象实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">import</span> com.halo.test.Person;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getFullName</span><span class="params">(Person p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p.getFirstName() + <span class="string">&quot; &quot;</span> + p.getLastName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，如果不能获得 <code>Person</code> 类，只有一个 <code>Object</code> 实例，比如这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getFullName</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="comment">// ???</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>怎么办？强制转型？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getFullName</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    Person p = (Person) obj;</span><br><span class="line">    <span class="keyword">return</span> p.getFirstName() + <span class="string">&quot; &quot;</span> + p.getLastName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>强制转型的时候，你会发现一个问题：编译上面的代码，仍然需要引用 <code>Person</code> 类。不然，去掉import语句，不能编译通过</p><p>而反射是为了解决在运行期，对某个实例一无所知的情况下，如何调用其方法。</p><h2 id="Class-类"><a class="header-anchor" href="#Class-类"></a>Class 类</h2><p>除了 int 等基本类型外，Java 的其他类型全部都是 class（包括 interface ）。</p><p>仔细思考，我们可以得出结论：class（包括 interface ）的本质是数据类型（Type）。无继承关系的数据类型无法赋值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Number n = <span class="keyword">new</span> Double(<span class="number">123.456</span>); <span class="comment">// OK</span></span><br><span class="line">String s = <span class="keyword">new</span> Double(<span class="number">123.456</span>); <span class="comment">// compile error!</span></span><br></pre></td></tr></table></figure><p>而 class 是由 JVM 在执行过程中动态加载的。JVM 在第一次读取到一种 class 类型时，将其加载进内存。</p><p>每加载一种 class，JVM 就为其创建一个 <code>Class</code> 类型的实例，并关联起来。注意：这里的 <code>Class</code> 类型是一个名叫 Class 的 class。它长这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Class</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以 String 类为例，当 JVM 加载 String 类时，它首先读取 <code>String.class</code> 文件到内存，然后，为 String 类创建一个 <code>Class</code> 实例并关联起来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class cls = <span class="keyword">new</span> Class(String);</span><br></pre></td></tr></table></figure><p>这个 <code>Class</code> 实例是 JVM 内部创建的，如果我们查看 JDK 源码，可以发现 <code>Class</code> 类的构造方法是 private，只有 JVM 能创建 <code>Class</code> 实例，我们自己的 Java 程序是无法创建 Class 实例的。</p><p>所以， JVM 持有的每个 <code>Class</code> 实例都指向一个数据类型（class或interface）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">┌───────────────────────────┐</span><br><span class="line">│      Class Instance       │──────&gt; String</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│name &#x3D; &quot;java.lang.String&quot;  │</span><br><span class="line">└───────────────────────────┘</span><br><span class="line">┌───────────────────────────┐</span><br><span class="line">│      Class Instance       │──────&gt; Random</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│name &#x3D; &quot;java.util.Random&quot;  │</span><br><span class="line">└───────────────────────────┘</span><br><span class="line">┌───────────────────────────┐</span><br><span class="line">│      Class Instance       │──────&gt; Runnable</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│name &#x3D; &quot;java.lang.Runnable&quot;│</span><br><span class="line">└───────────────────────────┘</span><br></pre></td></tr></table></figure><p>一个 <code>Class</code> 实例包含了该 class 的所有完整信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">┌───────────────────────────┐</span><br><span class="line">│      Class Instance       │──────&gt; String</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│name &#x3D; &quot;java.lang.String&quot;  │</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│package &#x3D; &quot;java.lang&quot;      │</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│super &#x3D; &quot;java.lang.Object&quot; │</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│interface &#x3D; CharSequence...│</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│field &#x3D; value[],hash,...   │</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│method &#x3D; indexOf()...      │</span><br><span class="line">└───────────────────────────┘</span><br></pre></td></tr></table></figure><p>由于 JVM 为每个加载的 class 创建了对应的 <code>Class</code> 实例，并在实例中保存了该 class 的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个 <code>Class</code> 实例，我们就可以通过这个 <code>Class</code> 实例获取到该实例对应的 class 的所有信息。</p><p>这种通过 <code>Class</code> 实例获取 class 信息的方法称为反射（Reflection）。</p><p>如何获取一个 class 的 <code>Class</code> 实例？有三个方法：</p><p>方法一：直接通过一个 class 的静态变量 class 获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class cls = String.class;</span><br></pre></td></tr></table></figure><p>方法二：如果我们有一个实例变量，可以通过该实例变量提供的 <code>getClass()</code> 方法获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">Class cls = s.getClass();</span><br></pre></td></tr></table></figure><p>方法三：如果知道一个 class 的完整类名，可以通过静态方法 <code>Class.forName()</code> 获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class cls = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br></pre></td></tr></table></figure><p>因为 <code>Class</code> 实例在 JVM 中是唯一的，所以，上述方法获取的 <code>Class</code> 实例是同一个实例。可以用 <code>==</code> 比较两个 <code>Class</code> 实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class cls1 = String.class;</span><br><span class="line"></span><br><span class="line">String s = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">Class cls2 = s.getClass();</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> sameClass = cls1 == cls2; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>注意一下 <code>Class</code> 实例比较和 <code>instanceof</code> 的差别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Integer n = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b1 = n <span class="keyword">instanceof</span> Integer; <span class="comment">// true，因为n是Integer类型</span></span><br><span class="line"><span class="keyword">boolean</span> b2 = n <span class="keyword">instanceof</span> Number; <span class="comment">// true，因为n是Number类型的子类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b3 = n.getClass() == Integer.class; <span class="comment">// true，因为n.getClass()返回Integer.class</span></span><br><span class="line"><span class="keyword">boolean</span> b4 = n.getClass() == Number.class; <span class="comment">// false，因为Integer.class!=Number.class</span></span><br></pre></td></tr></table></figure><p>用 <code>instanceof</code> 不但匹配指定类型，还匹配指定类型的子类。而用 <code>==</code> 判断 class 实例可以精确地判断数据类型，但不能作子类型比较。</p><p>通常情况下，我们应该用 <code>instanceof</code> 判断数据类型，因为面向抽象编程的时候，我们不关心具体的子类型。只有在需要精确判断一个类型是不是某个 class 的时候，我们才使用 <code>==</code> 判断 class 实例。</p><p>因为反射的目的是为了获得某个实例的信息。因此，当我们拿到某个 <code>Object</code> 实例时，我们可以通过反射获取该 <code>Object</code> 的 class 信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printObjectInfo</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    Class cls = obj.getClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要从 <code>Class</code> 实例获取获取的基本信息，参考下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        printClassInfo(<span class="string">&quot;&quot;</span>.getClass());</span><br><span class="line">        printClassInfo(Runnable.class);</span><br><span class="line">        printClassInfo(java.time.Month.class);</span><br><span class="line">        printClassInfo(String[].class);</span><br><span class="line">        printClassInfo(<span class="keyword">int</span>.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printClassInfo</span><span class="params">(Class cls)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Class name: &quot;</span> + cls.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;Simple name: &quot;</span> + cls.getSimpleName());</span><br><span class="line">        <span class="keyword">if</span> (cls.getPackage() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Package name: &quot;</span> + cls.getPackage().getName());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;is interface: &quot;</span> + cls.isInterface());</span><br><span class="line">        System.out.println(<span class="string">&quot;is enum: &quot;</span> + cls.isEnum());</span><br><span class="line">        System.out.println(<span class="string">&quot;is array: &quot;</span> + cls.isArray());</span><br><span class="line">        System.out.println(<span class="string">&quot;is primitive: &quot;</span> + cls.isPrimitive());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到数组（例如 <code>String[]</code>）也是一种 <code>Class</code>，而且不同于 <code>String.class</code>，它的类名是 <code>[Ljava.lang.String</code>。此外，JVM 为每一种基本类型如 <code>int</code> 也创建了 <code>Class</code>，通过 <code>int.class</code> 访问。</p><p>如果获取到了一个 <code>Class</code> 实例，我们就可以通过该 <code>Class</code> 实例来创建对应类型的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取String的Class实例:</span></span><br><span class="line">Class cls = String.class;</span><br><span class="line"><span class="comment">// 创建一个String实例:</span></span><br><span class="line">String s = (String) cls.newInstance();</span><br></pre></td></tr></table></figure><p>上述代码相当于 <code>new String()</code>。通过 <code>Class.newInstance()</code> 可以创建类实例，它的局限是：只能调用 public 的无参数构造方法。带参数的构造方法，或者非 public 的构造方法都无法通过 <code>Class.newInstance()</code> 被调用。</p><h2 id="动态加载"><a class="header-anchor" href="#动态加载"></a>动态加载</h2><p>JVM 在执行 Java 程序的时候，并不是一次性把所有用到的 class 全部加载到内存，而是第一次需要用到 class 时才加载。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            create(args[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行 Main.java 时，由于用到了 <code>Main</code>，因此，JVM 首先会把 Main.class 加载到内存。然而，并不会加载 Person.class，除非程序执行到 <code>create()</code> 方法，JVM 发现需要加载 <code>Person</code> 类时，才会首次加载 <code>Person.class</code>。如果没有执行 <code>create()</code> 方法，那么 Person.class根本就不会被加载。</p><p>这就是 JVM 动态加载 class 的特性。</p><p>动态加载 class 的特性对于 Java 程序非常重要。利用 JVM 动态加载 class 的特性，我们才能在运行期根据条件加载不同的实现类。例如，Commons Logging 总是优先使用 Log4j，只有当 Log4j 不存在时，才使用 JDK 的 logging。利用 JVM 动态加载特性，大致的实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Commons Logging优先使用Log4j:</span></span><br><span class="line">LogFactory factory = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (isClassPresent(<span class="string">&quot;org.apache.logging.log4j.Logger&quot;</span>)) &#123;</span><br><span class="line">    factory = createLog4j();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    factory = createJdkLog();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isClassPresent</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class.forName(name);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是为什么我们只需要把 Log4j 的 jar 包放到 classpath 中，Commons Logging 就会自动使用 Log4j 的原因。</p><h2 id="访问字段"><a class="header-anchor" href="#访问字段"></a>访问字段</h2><p>对任意的一个 Object 实例，只要我们获取了它的 <code>Class</code>，就可以获取它的一切信息。</p><p>我们先看看如何通过 <code>Class</code> 实例获取字段信息。<code>Class</code> 类提供了以下几个方法来获取字段：</p><ul><li><code>Field getField(name)</code>：根据字段名获取某个 public 的 field（包括父类）</li><li><code>Field getDeclaredField(name)</code>：根据字段名获取当前类的某个 field（不包括父类）</li><li><code>Field[] getFields()</code>：获取所有 public 的 field（包括父类）</li><li><code>Field[] getDeclaredFields()</code>：获取当前类的所有 field（不包括父类）</li></ul><p>我们来看一下示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class stdClass = Student.class;</span><br><span class="line">        <span class="comment">// 获取public字段&quot;score&quot;:</span></span><br><span class="line">        System.out.println(stdClass.getField(<span class="string">&quot;score&quot;</span>));</span><br><span class="line">        <span class="comment">// 获取继承的public字段&quot;name&quot;:</span></span><br><span class="line">        System.out.println(stdClass.getField(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        <span class="comment">// 获取private字段&quot;grade&quot;:</span></span><br><span class="line">        System.out.println(stdClass.getDeclaredField(<span class="string">&quot;grade&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> score;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码首先获取 <code>Student</code> 的 <code>Class</code> 实例，然后，分别获取 <code>public</code> 字段、继承的 <code>public</code> 字段以及 <code>private</code> 字段，打印出的 Field ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int Student.score</span><br><span class="line">public java.lang.String Person.name</span><br><span class="line">private int Student.grade</span><br></pre></td></tr></table></figure><p>一个 Field 对象包含了一个字段的所有信息：</p><ul><li><code>getName()</code>：返回字段名称，例如，<code>name</code>；</li><li><code>getType()</code>：返回字段类型，也是一个 <code>Class</code> 实例，例如，<code>String.class</code>；</li><li><code>getModifiers()</code>：返回字段的修饰符，它是一个 int，不同的 bit 表示不同的含义。</li></ul><p>以 String 类的 <code>value</code> 字段为例，它的定义是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们用反射获取该字段的信息，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Field f = String.class.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">f.getName(); <span class="comment">// &quot;value&quot;</span></span><br><span class="line">f.getType(); <span class="comment">// class [B 表示byte[]类型</span></span><br><span class="line"><span class="keyword">int</span> m = f.getModifiers();</span><br><span class="line">Modifier.isFinal(m); <span class="comment">// true</span></span><br><span class="line">Modifier.isPublic(m); <span class="comment">// false</span></span><br><span class="line">Modifier.isProtected(m); <span class="comment">// false</span></span><br><span class="line">Modifier.isPrivate(m); <span class="comment">// true</span></span><br><span class="line">Modifier.isStatic(m); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>利用反射拿到字段的一个 Field 实例只是第一步，我们还可以拿到一个实例对应的该字段的值。</p><p>例如，对于一个 <code>Person</code> 实例，我们可以先拿到 <code>name</code> 字段对应的 Field，再获取这个实例的 <code>name</code> 字段的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Object p = <span class="keyword">new</span> Person(<span class="string">&quot;Xiao Ming&quot;</span>);</span><br><span class="line">        Class c = p.getClass();</span><br><span class="line">        Field f = c.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        Object value = f.get(p);</span><br><span class="line">        System.out.println(value); <span class="comment">// &quot;Xiao Ming&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码先获取 <code>Class</code> 实例，再获取 Field 实例，然后，用 <code>Field.get(Object)</code> 获取指定实例的指定字段的值。</p><p>运行代码，如果不出意外，会得到一个 <code>IllegalAccessException</code>，这是因为 <code>name</code> 被定义为一个 private 字段，正常情况下，<code>Main</code> 类无法访问 <code>Person</code> 类的 private 字段。要修复错误，可以将 private 改为 public，或者，在调用<code>Object value = f.get(p);</code> 前，先写一句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f.setAccessible(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>调用 <code>Field.setAccessible(true)</code> 的意思是，别管这个字段是不是 public，一律允许访问。再运行代码，就可以打印出 private 字段的值。</p><p>如果使用反射可以获取 private 字段的值，那么类的封装还有什么意义？</p><p>答案是正常情况下，我们总是通过 <code>p.name</code> 来访问 Person 的 name 字段，编译器会根据 public、protected 和 private 决定是否允许访问字段，这样就达到了数据封装的目的。</p><p>而反射是一种非常规的用法，使用反射，首先代码非常繁琐，其次，它更多地是给工具或者底层框架来使用，目的是在不知道目标实例任何信息的情况下，获取特定字段的值。</p><p>此外，<code>setAccessible(true)</code> 可能会失败。如果 JVM 运行期存在 SecurityManager，那么它会根据规则进行检查，有可能阻止 <code>setAccessible(true)</code> 。例如，某个 SecurityManager 可能不允许对 java 和 javax 开头的 package 的类调用 <code>setAccessible(true)</code>，这样可以保证 JVM 核心库的安全。</p><h2 id="设置字段值"><a class="header-anchor" href="#设置字段值"></a>设置字段值</h2><p>通过 Field 实例既然可以获取到指定实例的字段值，自然也可以设置字段的值。</p><p>设置字段值是通过 <code>Field.set(Object, Object)</code> 实现的，其中第一个 <code>Object</code> 参数是指定的实例，第二个 <code>Object</code> 参数是待修改的值。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person(<span class="string">&quot;Xiao Ming&quot;</span>);</span><br><span class="line">        System.out.println(p.getName()); <span class="comment">// &quot;Xiao Ming&quot;</span></span><br><span class="line">        Class c = p.getClass();</span><br><span class="line">        Field f = c.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        f.set(p, <span class="string">&quot;Xiao Hong&quot;</span>);</span><br><span class="line">        System.out.println(p.getName()); <span class="comment">// &quot;Xiao Hong&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码，打印的 <code>name</code> 字段从 <code>Xiao Ming</code> 变成了 <code>Xiao Hong</code>，说明通过反射可以直接修改字段的值。</p><p>同样的，修改非 public 字段，需要首先调用 <code>setAccessible(true)</code>。</p><h2 id="调用方法"><a class="header-anchor" href="#调用方法"></a>调用方法</h2><p>我们已经能通过 Class 实例获取所有 Field 对象，同样的，可以通过 Class 实例获取所有 Method 信息。Class 类提供了以下几个方法来获取 Method：</p><ul><li><code>Method getMethod(name, Class...)</code>：获取某个 public 的 Method（包括父类）</li><li><code>Method getDeclaredMethod(name, Class...)</code>：获取当前类的某个 Method（不包括父类）</li><li><code>Method[] getMethods()</code>：获取所有 public 的 Method（包括父类）</li><li><code>Method[] getDeclaredMethods()</code>：获取当前类的所有 Method（不包括父类）</li></ul><p>我们来看一下示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class stdClass = Student.class;</span><br><span class="line">        <span class="comment">// 获取public方法getScore，参数为String:</span></span><br><span class="line">        System.out.println(stdClass.getMethod(<span class="string">&quot;getScore&quot;</span>, String.class));</span><br><span class="line">        <span class="comment">// 获取继承的public方法getName，无参数:</span></span><br><span class="line">        System.out.println(stdClass.getMethod(<span class="string">&quot;getName&quot;</span>));</span><br><span class="line">        <span class="comment">// 获取private方法getGrade，参数为int:</span></span><br><span class="line">        System.out.println(stdClass.getDeclaredMethod(<span class="string">&quot;getGrade&quot;</span>, <span class="keyword">int</span>.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">99</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getGrade</span><span class="params">(<span class="keyword">int</span> year)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码首先获取 Student 的 Class 实例，然后，分别获取 public 方法、继承的 public 方法以及 private 方法，打印出的 Method 类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> Student.getScore(java.lang.String)</span><br><span class="line"><span class="keyword">public</span> java.lang.String Person.getName()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> Student.getGrade(<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><p>一个 <code>Method</code> 对象包含一个方法的所有信息：</p><ul><li><code>getName()</code>：返回方法名称，例如：“getScore”；</li><li><code>getReturnType()</code>：返回方法返回值类型，也是一个 Class 实例，例如：<code>String.class</code>；</li><li><code>getParameterTypes()</code>：返回方法的参数类型，是一个 Class 数组，例如：<code>&#123;String.class, int.class&#125;</code>；</li><li><code>getModifiers()</code>：返回方法的修饰符，它是一个 int，不同的 bit 表示不同的含义。</li></ul><p>当我们获取到一个 Method 对象时，就可以对它进行调用。我们以下面的代码为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line">String r = s.substring(<span class="number">6</span>); <span class="comment">// &quot;world&quot;</span></span><br></pre></td></tr></table></figure><p>如果用反射来调用 <code>substring</code> 方法，需要以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// String对象:</span></span><br><span class="line">        String s = <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line">        <span class="comment">// 获取String substring(int)方法，参数为int:</span></span><br><span class="line">        Method m = String.class.getMethod(<span class="string">&quot;substring&quot;</span>, <span class="keyword">int</span>.class);</span><br><span class="line">        <span class="comment">// 在s对象上调用该方法并获取结果:</span></span><br><span class="line">        String r = (String) m.invoke(s, <span class="number">6</span>);</span><br><span class="line">        <span class="comment">// 打印调用结果:</span></span><br><span class="line">        System.out.println(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对 Method 实例调用 <code>invoke</code> 就相当于调用该方法，<code>invoke</code> 的第一个参数是对象实例，即在哪个实例上调用该方法，后面的可变参数要与方法参数一致，否则将报错。</p><h3 id="调用静态方法"><a class="header-anchor" href="#调用静态方法"></a>调用静态方法</h3><p>如果获取到的 Method 表示一个静态方法，调用静态方法时，由于无需指定实例对象，所以 <code>invoke</code> 方法传入的第一个参数永远为 null。我们以 <code>Integer.parseInt(String)</code> 为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取Integer.parseInt(String)方法，参数为String:</span></span><br><span class="line">        Method m = Integer.class.getMethod(<span class="string">&quot;parseInt&quot;</span>, String.class);</span><br><span class="line">        <span class="comment">// 调用该静态方法并获取结果:</span></span><br><span class="line">        Integer n = (Integer) m.invoke(<span class="keyword">null</span>, <span class="string">&quot;12345&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印调用结果:</span></span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用非-public-方法"><a class="header-anchor" href="#调用非-public-方法"></a>调用非 public 方法</h3><p>和 Field 类似，对于非 public 方法，我们虽然可以通过 <code>Class.getDeclaredMethod()</code> 获取该方法实例，但直接对其调用将得到一个 <code>IllegalAccessException</code> 。为了调用非 public 方法，我们通过 <code>Method.setAccessible(true)</code> 允许其调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        Method m = p.getClass().getDeclaredMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line">        m.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        m.invoke(p, <span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">        System.out.println(p.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多态"><a class="header-anchor" href="#多态"></a>多态</h3><p>我们来考察这样一种情况：一个 <code>Person</code> 类定义了 <code>hello()</code> 方法，并且它的子类 <code>Student</code> 也覆写了 <code>hello()</code> 方法，那么，从 <code>Person.class</code> 获取的 Method，作用于 <code>Student</code> 实例时，调用的方法到底是哪个？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取Person的hello方法:</span></span><br><span class="line">        Method h = Person.class.getMethod(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="comment">// 对Student实例调用hello方法:</span></span><br><span class="line">        h.invoke(<span class="keyword">new</span> Student());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person:hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Student:hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码，发现打印出的是 <code>Student:hello</code>，因此，使用反射调用方法时，仍然遵循多态原则：即总是调用实际类型的覆写方法（如果存在）。上述的反射代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Method m = Person.class.getMethod(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">m.invoke(<span class="keyword">new</span> Student());</span><br></pre></td></tr></table></figure><p>实际上相当于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Student();</span><br><span class="line">p.hello();</span><br></pre></td></tr></table></figure><h2 id="调用构造方法"><a class="header-anchor" href="#调用构造方法"></a>调用构造方法</h2><p>我们通常使用new操作符创建新的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure><p>如果通过反射来创建新的实例，可以调用 Class 提供的 <code>newInstance()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p = Person.class.newInstance();</span><br></pre></td></tr></table></figure><p>调用 <code>Class.newInstance()</code> 的局限是，它只能调用该类的 public 无参数构造方法。如果构造方法带有参数，或者不是 public，就无法直接通过 <code>Class.newInstance()</code> 来调用。</p><p>为了调用任意的构造方法，Java 的反射 API 提供了 <code>Constructor</code> 对象，它包含一个构造方法的所有信息，可以创建一个实例。<code>Constructor</code> 对象和 Method 非常类似，不同之处仅在于它是一个构造方法，并且，调用结果总是返回实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取构造方法Integer(int):</span></span><br><span class="line">        Constructor cons1 = Integer.class.getConstructor(<span class="keyword">int</span>.class);</span><br><span class="line">        <span class="comment">// 调用构造方法:</span></span><br><span class="line">        Integer n1 = (Integer) cons1.newInstance(<span class="number">123</span>);</span><br><span class="line">        System.out.println(n1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取构造方法Integer(String)</span></span><br><span class="line">        Constructor cons2 = Integer.class.getConstructor(String.class);</span><br><span class="line">        Integer n2 = (Integer) cons2.newInstance(<span class="string">&quot;456&quot;</span>);</span><br><span class="line">        System.out.println(n2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 Class 实例获取 Constructor 的方法如下：</p><ul><li><code>getConstructor(Class...)</code>：获取某个 public 的 <code>Constructor</code>；</li><li><code>getDeclaredConstructor(Class...)</code>：获取某个 Constructor`；</li><li><code>getConstructors()</code>：获取所有 public 的 <code>Constructor</code>；</li><li><code>getDeclaredConstructors()</code>：获取所有 <code>Constructor</code>。</li></ul><p>注意 <code>Constructor</code> 总是当前类定义的构造方法，和父类无关，因此不存在多态的问题。</p><p>调用非 public 的 <code>Constructor</code> 时，必须首先通过 <code>setAccessible(true)</code> 设置允许访问。<code>setAccessible(true)</code> 可能会失败。</p><h2 id="获取继承关系"><a class="header-anchor" href="#获取继承关系"></a>获取继承关系</h2><p>当我们获取到某个 Class 对象时，实际上就获取到了一个类的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class cls = String.class; <span class="comment">// 获取到String的Class</span></span><br></pre></td></tr></table></figure><p>还可以用实例的 <code>getClass()</code> 方法获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">Class cls = s.getClass(); <span class="comment">// s是String，因此获取到String的Class</span></span><br></pre></td></tr></table></figure><p>最后一种获取 Class 的方法是通过 <code>Class.forName(&quot;&quot;)</code>，传入 Class 的完整类名获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class s = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br></pre></td></tr></table></figure><p>这三种方式获取的 Class 实例都是同一个实例，因为 JVM 对每个加载的 Class 只创建一个 Class 实例来表示它的类型。</p><h3 id="获取父类的-Class"><a class="header-anchor" href="#获取父类的-Class"></a>获取父类的 Class</h3><p>有了 Class 实例，我们还可以获取它的父类的 Class：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class i = Integer.class;</span><br><span class="line">        Class n = i.getSuperclass();</span><br><span class="line">        System.out.println(n);</span><br><span class="line">        Class o = n.getSuperclass();</span><br><span class="line">        System.out.println(o);</span><br><span class="line">        System.out.println(o.getSuperclass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码，可以看到，Integer 的父类类型是 Number，Number 的父类是 Object，Object 的父类是 null。除 Object 外，其他任何非 interface 的 Class都必定存在一个父类类型。</p><h3 id="获取-interface"><a class="header-anchor" href="#获取-interface"></a>获取 interface</h3><p>由于一个类可能实现一个或多个接口，通过 Class 我们就可以查询到实现的接口类型。例如，查询 Integer 实现的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class s = Integer.class;</span><br><span class="line">        Class[] is = s.getInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Class i : is) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码可知，Integer 实现的接口有：</p><ul><li><code>java.lang.Comparable</code></li><li><code>java.lang.constant.Constable</code></li><li><code>java.lang.constant.ConstantDesc</code></li></ul><p>要特别注意：<code>getInterfaces()</code> 只返回当前类直接实现的接口类型，并不包括其父类实现的接口类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class s = Integer.class.getSuperclass();</span><br><span class="line">        Class[] is = s.getInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Class i : is) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Integer 的父类是 Number，Number 实现的接口是 <code>java.io.Serializable</code>。</p><p>此外，对所有 interface 的 Class 调用 <code>getSuperclass()</code> 返回的是 null，获取接口的父接口要用 <code>getInterfaces()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(java.io.DataInputStream.class.getSuperclass()); </span><br><span class="line"><span class="comment">// java.io.FilterInputStream，因为DataInputStream继承自FilterInputStream</span></span><br><span class="line">System.out.println(java.io.Closeable.class.getSuperclass()); </span><br><span class="line"><span class="comment">// null，对接口调用getSuperclass()总是返回null，获取接口的父接口要用getInterfaces()</span></span><br></pre></td></tr></table></figure><p>如果一个类没有实现任何 interface，那么 <code>getInterfaces()</code> 返回空数组。</p><h3 id="继承关系"><a class="header-anchor" href="#继承关系"></a>继承关系</h3><p>当我们判断一个实例是否是某个类型时，正常情况下，使用 <code>instanceof</code> 操作符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object n = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line"><span class="keyword">boolean</span> isDouble = n <span class="keyword">instanceof</span> Double; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">boolean</span> isInteger = n <span class="keyword">instanceof</span> Integer; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">boolean</span> isNumber = n <span class="keyword">instanceof</span> Number; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">boolean</span> isSerializable = n <span class="keyword">instanceof</span> java.io.Serializable; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果是两个 Class 实例，要判断一个向上转型是否成立，可以调用 <code>isAssignableFrom()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Integer i = ?</span></span><br><span class="line">Integer.class.isAssignableFrom(Integer.class); <span class="comment">// true，因为Integer可以赋值给Integer</span></span><br><span class="line"><span class="comment">// Number n = ?</span></span><br><span class="line">Number.class.isAssignableFrom(Integer.class); <span class="comment">// true，因为Integer可以赋值给Number</span></span><br><span class="line"><span class="comment">// Object o = ?</span></span><br><span class="line">Object.class.isAssignableFrom(Integer.class); <span class="comment">// true，因为Integer可以赋值给Object</span></span><br><span class="line"><span class="comment">// Integer i = ?</span></span><br><span class="line">Integer.class.isAssignableFrom(Number.class); <span class="comment">// false，因为Number不能赋值给Integer</span></span><br></pre></td></tr></table></figure><h3 id="动态代理"><a class="header-anchor" href="#动态代理"></a>动态代理</h3><p>我们来比较 Java 的 class 和 interface 的区别：</p><ul><li>可以实例化 class（非abstract）；</li><li>不能实例化 interface。</li></ul><p>所有 interface 类型的变量总是通过向上转型并指向某个实例的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CharSequence cs = <span class="keyword">new</span> StringBuilder();</span><br></pre></td></tr></table></figure><p>有没有可能不编写实现类，直接在运行期创建某个 interface 的实例呢？</p><p>这是可能的，因为 Java 标准库提供了一种动态代理（Dynamic Proxy）的机制：可以在运行期动态创建某个 interface 的实例。</p><p>什么叫运行期动态创建？听起来好像很复杂。所谓动态代理，是和静态相对应的。我们来看静态代码怎么写：</p><p>定义接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">morning</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> <span class="keyword">implements</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">morning</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Good morning, &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建实例，转型为接口并调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello hello = <span class="keyword">new</span> HelloWorld();</span><br><span class="line">hello.morning(<span class="string">&quot;Bob&quot;</span>);</span><br></pre></td></tr></table></figure><p>这种方式就是我们通常编写代码的方式。</p><p>还有一种方式是动态代码，我们仍然先定义了接口 <code>Hello</code>，但是我们并不去编写实现类，而是直接通过 JDK 提供的一个 <code>Proxy.newProxyInstance()</code> 创建了一个 <code>Hello</code> 接口对象。这种没有实现类但是在运行期动态创建了一个接口对象的方式，我们称为动态代码。JDK 提供的动态创建接口对象的方式，就叫动态代理。</p><p>一个最简单的动态代理实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InvocationHandler handler = <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                System.out.println(method);</span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;morning&quot;</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Good morning, &quot;</span> + args[<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Hello hello = (Hello) Proxy.newProxyInstance(</span><br><span class="line">            Hello.class.getClassLoader(), <span class="comment">// 传入ClassLoader</span></span><br><span class="line">            <span class="keyword">new</span> Class[] &#123; Hello.class &#125;, <span class="comment">// 传入要实现的接口</span></span><br><span class="line">            handler); <span class="comment">// 传入处理调用方法的InvocationHandler</span></span><br><span class="line">        hello.morning(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">morning</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在运行期动态创建一个 interface 实例的方法如下：</p><ul><li>定义一个 <code>InvocationHandler</code> 实例，它负责实现接口的方法调用；</li><li>通过 <code>Proxy.newProxyInstance()</code> 创建 interface 实例，它需要3个参数：<ol><li>使用的 <code>ClassLoader</code>，通常就是接口类的 <code>ClassLoader</code>；</li><li>需要实现的接口数组，至少需要传入一个接口进去；</li><li>用来处理接口方法调用的 <code>InvocationHandler</code> 实例。</li></ol></li><li>将返回的 Object 强制转型为接口。</li></ul><p>动态代理实际上是 JVM 在运行期动态创建 class 字节码并加载的过程，它并没有什么黑魔法，把上面的动态代理改写为静态实现类大概长这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloDynamicProxy</span> <span class="keyword">implements</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    InvocationHandler handler;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloDynamicProxy</span><span class="params">(InvocationHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">morning</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        handler.invoke(</span><br><span class="line">           <span class="keyword">this</span>,</span><br><span class="line">           Hello.class.getMethod(<span class="string">&quot;morning&quot;</span>, String.class),</span><br><span class="line">           <span class="keyword">new</span> Object[] &#123; name &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是 JVM 帮我们自动编写了一个上述类（不需要源码，可以直接生成字节码），并不存在可以直接实例化接口的黑魔法。</p>]]></content>
    
    
    <summary type="html">Java 反射</summary>
    
    
    
    <category term="Java" scheme="http://halo123.top/categories/Java/"/>
    
    
    <category term="Java" scheme="http://halo123.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java异常处理</title>
    <link href="http://halo123.top/2021/05/20/Java/Java-D-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>http://halo123.top/2021/05/20/Java/Java-D-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</id>
    <published>2021-05-20T09:33:40.000Z</published>
    <updated>2021-05-20T09:39:06.447Z</updated>
    
    <content type="html"><![CDATA[<p>参考资料：</p><div class="tag link"><a class="link-card" title="廖雪峰Java教程" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255943543190176"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@master/img/网站.svg"/></div><div class="right"><p class="text">廖雪峰Java教程</p><p class="url">https://www.liaoxuefeng.com/wiki/1252599548343744/1255943543190176</p></div></a></div><h2 id="Java-的异常"><a class="header-anchor" href="#Java-的异常"></a>Java 的异常</h2><p>在计算机程序运行的过程中，总是会出现各种各样的错误。</p><p>有一些错误是用户造成的，比如，希望用户输入一个 int 类型的年龄，但是用户的输入是 abc：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设用户输入了abc：</span></span><br><span class="line">String s = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> n = Integer.parseInt(s); <span class="comment">// NumberFormatException</span></span><br></pre></td></tr></table></figure><p>程序想要读写某个文件的内容，但是用户已经把它删除了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用户删除了该文件：</span></span><br><span class="line">String t = readFile(<span class="string">&quot;C:\\abc.txt&quot;</span>); <span class="comment">// FileNotFoundException!</span></span><br></pre></td></tr></table></figure><p>还有一些错误是随机出现，并且永远不可能避免的。比如：</p><ul><li>网络突然断了，连接不到远程服务器；</li><li>内存耗尽，程序崩溃了；</li><li>用户点“打印”，但根本没有打印机；</li><li>……</li></ul><p>所以，一个健壮的程序必须处理各种各样的错误。</p><p>所谓错误，就是程序调用某个函数的时候，如果失败了，就表示出错。</p><p>调用方如何获知调用失败的信息？有两种方法：</p><p>方法一：约定返回错误码。</p><p>例如，处理一个文件，如果返回 0，表示成功，返回其他整数，表示约定的错误码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> code = processFile(<span class="string">&quot;C:\\test.txt&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (code == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// ok:</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// error:</span></span><br><span class="line">    <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="comment">// file not found:</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="comment">// no read permission:</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// unknown error:</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为使用 int 类型的错误码，想要处理就非常麻烦。这种方式常见于底层C函数。</p><p>方法二：在语言层面上提供一个异常处理机制。</p><p>Java 内置了一套异常处理机制，总是使用异常来表示错误。</p><p>异常是一种 class，因此它本身带有类型信息。异常可以在任何地方抛出，但只需要在上层捕获，这样就和方法调用分离了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    String s = processFile(“C:\\test.txt”);</span><br><span class="line">    <span class="comment">// ok:</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    <span class="comment">// file not found:</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">    <span class="comment">// no read permission:</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">// io error:</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// other error:</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从继承关系可知：<code>Throwable</code> 是异常体系的根，它继承自 <code>Object</code>。<code>Throwable</code> 有两个体系：<code>Error</code> 和 <code>Exception</code>，<code>Error</code> 表示严重的错误，程序对此一般无能为力，例如：</p><ul><li><code>OutOfMemoryError</code>：内存耗尽</li><li><code>NoClassDefFoundError</code>：无法加载某个Class</li><li><code>StackOverflowError</code>：栈溢出</li></ul><p>而 <code>Exception</code> 则是运行时的错误，它可以被捕获并处理。</p><p>某些异常是应用程序逻辑处理的一部分，应该捕获并处理。例如：</p><ul><li><code>NumberFormatException</code>：数值类型的格式错误</li><li><code>FileNotFoundException</code>：未找到文件</li><li><code>SocketException</code>：读取网络失败</li></ul><p>还有一些异常是程序逻辑编写不对造成的，应该修复程序本身。例如：</p><ul><li><code>NullPointerException</code>：对某个 null 的对象调用方法或字段</li><li><code>IndexOutOfBoundsException</code>：数组索引越界</li></ul><p><code>Exception</code> 又分为两大类：</p><ul><li><code>RuntimeException</code> 以及它的子类；</li><li>非 <code>RuntimeException</code>（包括 <code>IOException</code>、<code>ReflectiveOperationException</code> 等等）</li></ul><p>Java规定：</p><ul><li>必须捕获的异常，包括 <code>Exception</code> 及其子类，但不包括 <code>RuntimeException</code> 及其子类，这种类型的异常称为 Checked Exception。</li><li>不需要捕获的异常，包括 <code>Error</code> 及其子类，<code>RuntimeException</code> 及其子类。</li></ul><p>注意：编译器对 <code>RuntimeException</code> 及其子类不做强制捕获要求，不是指应用程序本身不应该捕获并处理 <code>RuntimeException</code>。是否需要捕获，具体问题具体分析。</p><h2 id="捕获异常"><a class="header-anchor" href="#捕获异常"></a>捕获异常</h2><p>捕获异常使用 <code>try...catch</code> 语句，把可能发生异常的代码放到 <code>try &#123;...&#125;</code> 中，然后使用 <code>catch</code> 捕获对应的 <code>Exception</code> 及其子类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bs = toGBK(<span class="string">&quot;中文&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(bs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">byte</span>[] toGBK(String s) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 用指定编码转换String为byte[]:</span></span><br><span class="line">            <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            <span class="comment">// 如果系统不支持GBK编码，会捕获到UnsupportedEncodingException:</span></span><br><span class="line">            System.out.println(e); <span class="comment">// 打印异常信息</span></span><br><span class="line">            <span class="keyword">return</span> s.getBytes(); <span class="comment">// 尝试使用用默认编码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们不捕获 <code>UnsupportedEncodingException</code>，会出现编译失败的问题</p><p>编译器会报错，错误信息类似：<code>unreported exception UnsupportedEncodingException; must be caught or declared to be thrown</code>，并且准确地指出需要捕获的语句是 <code>return s.getBytes(&quot;GBK&quot;);</code> 。意思是说，像 <code>UnsupportedEncodingException</code> 这样的 Checked Exception，必须被捕获。</p><p>这是因为 <code>String.getBytes(String)</code> 方法定义是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] getBytes(String charsetName) <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在方法定义的时候，使用 <code>throws Xxx</code> 表示该方法可能抛出的异常类型。调用方在调用的时候，必须强制捕获这些异常，否则编译器会报错。<br><code>在</code>toGBK()<code>方法中，因为调用了</code>String.getBytes(String)<code>方法，就必须捕获</code>UnsupportedEncodingException<code>。我们也可以不捕获它，而是在方法定义处用 </code>throws<code>表示</code>toGBK()<code> 方法可能会抛出</code>UnsupportedEncodingException<code>，就可以让 </code>toGBK()` 方法通过编译器检查：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bs = toGBK(<span class="string">&quot;中文&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(bs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">byte</span>[] toGBK(String s) <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码仍然会得到编译错误，但这一次，编译器提示的不是调用 <code>return s.getBytes(&quot;GBK&quot;);</code> 的问题，而是 <code>byte[] bs = toGBK(&quot;中文&quot;);</code>。因为在 <code>main()</code> 方法中，调用 <code>toGBK()</code>，没有捕获它声明的可能抛出的 <code>UnsupportedEncodingException</code> 。修复方法是在 <code>main()</code> 方法中捕获异常并处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bs = toGBK(<span class="string">&quot;中文&quot;</span>);</span><br><span class="line">            System.out.println(Arrays.toString(bs));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">byte</span>[] toGBK(String s) <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">        <span class="comment">// 用指定编码转换String为byte[]:</span></span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，只要是方法声明的 Checked Exception，不在调用层捕获，也必须在更高的调用层捕获。所有未捕获的异常，最终也必须在 <code>main()</code> 方法中捕获，不会出现漏写 <code>try</code> 的情况。这是由编译器保证的。<code>main()</code> 方法也是最后捕获 <code>Exception</code> 的机会。</p><p>如果是测试代码，上面的写法就略显麻烦。如果不想写任何 <code>try</code> 代码，可以直接把 <code>main()</code> 方法定义为 <code>throws Exception</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bs = toGBK(<span class="string">&quot;中文&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(bs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">byte</span>[] toGBK(String s) <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">        <span class="comment">// 用指定编码转换String为byte[]:</span></span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>main()</code> 方法声明了可能抛出 <code>Exception</code>，也就声明了可能抛出所有的 <code>Exception</code>，因此在内部就无需捕获了。代价就是一旦发生异常，程序会立刻退出。</p><p>捕获后不处理的方式是非常不好的，即使真的什么也做不了，也要先把异常记录下来。所有异常都可以调用 <code>printStackTrace()</code> 方法打印异常栈，这是一个简单有用的快速打印异常的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">byte</span>[] toGBK(String s) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        <span class="comment">// 先记下来再说:</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h3 id="多-catch-语句"><a class="header-anchor" href="#多-catch-语句"></a>多 catch 语句</h3><p>可以使用多个 <code>catch</code> 语句，每个 <code>catch</code> 分别捕获对应的 <code>Exception</code> 及其子类。JVM 在捕获到异常后，会从上到下匹配 <code>catch</code> 语句，匹配到某个 <code>catch</code> 后，执行 <code>catch</code> 代码块，然后不再继续匹配。</p><p>简单地说就是：多个 <code>catch</code> 语句只有一个能被执行。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存在多个 <code>catch</code> 的时候，<code>catch</code> 的顺序非常重要，子类必须写在前面。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;IO error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123; <span class="comment">// 永远捕获不到</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Bad encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面的代码，<code>UnsupportedEncodingException</code> 异常是永远捕获不到的，因为它是 <code>IOException</code> 的子类。当抛出 <code>UnsupportedEncodingException</code> 异常时，会被 <code>catch (IOException e) &#123; ... &#125;</code> 捕获并执行。因此，正确的写法是把子类放到前面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bad encoding&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;IO error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="finally-语句"><a class="header-anchor" href="#finally-语句"></a>finally 语句</h3><p>无论是否有异常发生，如果我们都希望执行一些语句，例如清理工作，怎么写？</p><p>可以把执行语句写若干遍：正常执行的放到 try 中，每个 catch 再写一遍。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">        System.out.println(<span class="string">&quot;END&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bad encoding&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;END&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;IO error&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;END&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码无论是否发生异常，都会执行 <code>System.out.println(&quot;END&quot;);</code> 这条语句。</p><p>那么如何消除这些重复的代码？Java 的 <code>try ... catch</code> 机制还提供了 <code>finally</code> 语句，<code>finally</code> 语句块保证有无错误都会执行。上述代码可以改写如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bad encoding&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;IO error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;END&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 <code>finally</code> 有几个特点：</p><ul><li><code>finally</code> 语句不是必须的，可写可不写；</li><li><code>finally</code> 总是最后执行。</li></ul><p>如果没有发生异常，就正常执行 <code>try &#123; ... &#125;</code> 语句块，然后执行 <code>finally</code>。如果发生了异常，就中断执行 <code>try &#123; ... &#125;</code> 语句块，然后跳转执行匹配的 <code>catch</code> 语句块，最后执行 <code>finally</code>。</p><p>可见，<code>finally</code> 是用来保证一些代码必须执行的。</p><p>某些情况下，可以没有 <code>catch</code>，只使用 <code>try ... finally</code> 结构。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(String file)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;END&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为方法声明了可能抛出的异常，所以可以不写 <code>catch</code>。</p><p>TODO: IO情况下不安全问题</p><h3 id="捕获多种异常"><a class="header-anchor" href="#捕获多种异常"></a>捕获多种异常</h3><p>如果某些异常的处理逻辑相同，但是异常本身不存在继承关系，那么就得编写多条 <code>catch</code> 子句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bad input&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bad input&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Unknown error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为处理 <code>IOException</code> 和 <code>NumberFormatException</code> 的代码是相同的，所以我们可以把它两用 <code>|</code> 合并到一起：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | NumberFormatException e) &#123; <span class="comment">// IOException或NumberFormatException</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Bad input&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Unknown error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抛出异常"><a class="header-anchor" href="#抛出异常"></a>抛出异常</h2><h3 id="异常的传播"><a class="header-anchor" href="#异常的传播"></a>异常的传播</h3><p>当某个方法抛出了异常时，如果当前方法没有捕获异常，异常就会被抛到上层调用方法，直到遇到某个 <code>try ... catch</code> 被捕获为止：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            process1();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        process2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Integer.parseInt(<span class="keyword">null</span>); <span class="comment">// 会抛出NumberFormatException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>printStackTrace()</code> 可以打印出方法的调用栈，类似：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NumberFormatException: null</span><br><span class="line">    at java.base&#x2F;java.lang.Integer.parseInt(Integer.java:614)</span><br><span class="line">    at java.base&#x2F;java.lang.Integer.parseInt(Integer.java:770)</span><br><span class="line">    at Main.process2(Main.java:16)</span><br><span class="line">    at Main.process1(Main.java:12)</span><br><span class="line">    at Main.main(Main.java:5)</span><br></pre></td></tr></table></figure><p><code>printStackTrace()</code> 对于调试错误非常有用，上述信息表示：<code>NumberFormatException</code> 是在 <code>java.lang.Integer.parseInt</code> 方法中被抛出的，从下往上看，调用层次依次是：</p><ol><li><code>main()</code> 调用 <code>process1()</code></li><li><code>process1()</code> 调用 <code>process2()</code></li><li><code>process2()</code> 调用 <code>Integer.parseInt(String)</code></li><li><code>Integer.parseInt(String)</code> 调用 <code>Integer.parseInt(String, int)</code></li></ol><p>查看 <code>Integer.java</code> 源码可知，抛出异常的方法代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(String s, <span class="keyword">int</span> radix)</span> <span class="keyword">throws</span> NumberFormatException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NumberFormatException(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且，每层调用均给出了源代码的行号，可直接定位。</p><h3 id="抛出异常-v2"><a class="header-anchor" href="#抛出异常-v2"></a>抛出异常</h3><p>当发生错误时，例如，用户输入了非法的字符，我们就可以抛出异常。</p><p>如何抛出异常？参考 <code>Integer.parseInt()</code> 方法，抛出异常分两步：</p><ol><li>创建某个 <code>Exception</code> 的实例；</li><li>用 <code>throw</code> 语句抛出。</li></ol><p>下面是一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process2</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span>) &#123;</span><br><span class="line">        NullPointerException e = <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，绝大部分抛出异常的代码都会合并写成一行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process2</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个方法捕获了某个异常后，又在 <code>catch</code> 子句中抛出新的异常，就相当于把抛出的异常类型“转换”了，当 <code>process2()</code> 抛出 <code>NullPointerException</code> 后，被 <code>process1()</code> 捕获，然后抛出 <code>IllegalArgumentException()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process1</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process2();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process2</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在 <code>main()</code> 中捕获 <code>IllegalArgumentException</code>，我们看看打印的异常栈：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            process1();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            process2();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印出的异常栈类似：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalArgumentException</span><br><span class="line">    at Main.process1(Main.java:15)</span><br><span class="line">    at Main.main(Main.java:5)</span><br></pre></td></tr></table></figure><p>这说明新的异常丢失了原始异常信息，我们已经看不到原始异常 <code>NullPointerException</code> 的信息了。</p><p>为了能追踪到完整的异常栈，在构造异常的时候，把原始的 <code>Exception</code> 实例传进去，新的 <code>Exception</code> 就可以持有原始 <code>Exception</code> 信息。对上述代码改进如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            process1();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            process2();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalArgumentException: java.lang.NullPointerException</span><br><span class="line">    at Main.process1(Main.java:15)</span><br><span class="line">    at Main.main(Main.java:5)</span><br><span class="line">Caused by: java.lang.NullPointerException</span><br><span class="line">    at Main.process2(Main.java:20)</span><br><span class="line">    at Main.process1(Main.java:13)</span><br></pre></td></tr></table></figure><p>注意到 <code>Caused by: Xxx</code>，说明捕获的 <code>IllegalArgumentException</code> 并不是造成问题的根源，根源在于 <code>NullPointerException</code>，是在 <code>Main.process2()</code> 方法抛出的。</p><p>在代码中获取原始异常可以使用 <code>Throwable.getCause()</code> 方法。如果返回 <code>null</code>，说明已经是“根异常”了。</p><p>有了完整的异常栈的信息，我们才能快速定位并修复代码的问题。捕获到异常并再次抛出时，一定要留住原始异常，否则很难定位第一案发现场！</p><p>如果我们在 <code>try</code> 或者 <code>catch</code> 语句块中抛出异常，<code>finally</code> 语句是否会执行？例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Integer.parseInt(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;caught&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">caught</span><br><span class="line">finally</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.RuntimeException: java.lang.NumberFormatException: For input string: &quot;abc&quot;</span><br><span class="line">    at Main.main(Main.java:8)</span><br><span class="line">Caused by: java.lang.NumberFormatException: For input string: &quot;abc&quot;</span><br><span class="line">  at ...</span><br></pre></td></tr></table></figure><p>第一行打印了 <code>caught</code>，说明进入了 catch 语句块。第二行打印了 <code>finally</code> ，说明执行了 finally 语句块。</p><p>因此，在 catch 中抛出异常，不会影响 finally 的执行。JVM 会先执行 finally，然后抛出异常。</p><h3 id="异常屏蔽"><a class="header-anchor" href="#异常屏蔽"></a>异常屏蔽</h3><p>如果在执行 finally 语句时抛出异常，那么，catch 语句的异常还能否继续抛出？例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Integer.parseInt(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;caught&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上述代码，发现异常信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">caught</span><br><span class="line">finally</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalArgumentException</span><br><span class="line">    at Main.main(Main.java:11)</span><br></pre></td></tr></table></figure><p>这说明 finally 抛出异常后，原来在 catch 中准备抛出的异常就“消失”了，因为只能抛出一个异常。没有被抛出的异常称为“被屏蔽”的异常（Suppressed Exception）。</p><p>在极少数的情况下，我们需要获知所有的异常。如何保存所有的异常信息？方法是先用 <code>origin</code> 变量保存原始异常，然后调用 <code>Throwable.addSuppressed()</code>，把原始异常添加进来，最后在 finally 抛出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Exception origin = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Integer.parseInt(<span class="string">&quot;abc&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            origin = e;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Exception e = <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">            <span class="keyword">if</span> (origin != <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.addSuppressed(origin);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 catch 和 finally 都抛出了异常时，虽然 catch 的异常被屏蔽了，但是，finally 抛出的异常仍然包含了它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalArgumentException</span><br><span class="line">    at Main.main(Main.java:11)</span><br><span class="line">Suppressed: java.lang.NumberFormatException: For input string: &quot;abc&quot;</span><br><span class="line">    at java.base&#x2F;java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)</span><br><span class="line">    at java.base&#x2F;java.lang.Integer.parseInt(Integer.java:652)</span><br><span class="line">    at java.base&#x2F;java.lang.Integer.parseInt(Integer.java:770)</span><br><span class="line">    at Main.main(Main.java:6)</span><br></pre></td></tr></table></figure><p>通过 <code>Throwable.getSuppressed()</code> 可以获取所有的 <code>Suppressed Exception</code>。</p><p>绝大多数情况下，在 finally 中不要抛出异常。因此，我们通常不需要关心 <code>Suppressed Exception</code>。</p><h2 id="自定义异常"><a class="header-anchor" href="#自定义异常"></a>自定义异常</h2><p>Java 标准库定义的常用异常包括：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Exception</span><br><span class="line">│</span><br><span class="line">├─ RuntimeException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ NullPointerException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ IndexOutOfBoundsException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ SecurityException</span><br><span class="line">│  │</span><br><span class="line">│  └─ IllegalArgumentException</span><br><span class="line">│     │</span><br><span class="line">│     └─ NumberFormatException</span><br><span class="line">│</span><br><span class="line">├─ IOException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ UnsupportedCharsetException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ FileNotFoundException</span><br><span class="line">│  │</span><br><span class="line">│  └─ SocketException</span><br><span class="line">│</span><br><span class="line">├─ ParseException</span><br><span class="line">│</span><br><span class="line">├─ GeneralSecurityException</span><br><span class="line">│</span><br><span class="line">├─ SQLException</span><br><span class="line">│</span><br><span class="line">└─ TimeoutException</span><br></pre></td></tr></table></figure><p>当我们在代码中需要抛出异常时，尽量使用 JDK 已定义的异常类型。例如，参数检查不合法，应该抛出 <code>IllegalArgumentException</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process1</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (age &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一个大型项目中，可以自定义新的异常类型，但是，保持一个合理的异常继承体系是非常重要的。</p><p>一个常见的做法是自定义一个 <code>BaseException</code> 作为“根异常”，然后，派生出各种业务类型的异常。</p><p><code>BaseException</code> 需要从一个适合的 <code>Exception</code> 派生，通常建议从 <code>RuntimeException</code> 派生：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他业务类型的异常就可以从 <code>BaseException</code> 派生：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserNotFoundException</span> <span class="keyword">extends</span> <span class="title">BaseException</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginFailedException</span> <span class="keyword">extends</span> <span class="title">BaseException</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>自定义的 <code>BaseException</code> 应该提供多个构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseException</span><span class="params">(String message, Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseException</span><span class="params">(Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述构造方法实际上都是原样照抄 <code>RuntimeException</code>。这样，抛出异常的时候，就可以选择合适的构造方法。通过IDE可以根据父类快速生成子类的构造方法。</p><h2 id="NullPointerException"><a class="header-anchor" href="#NullPointerException"></a>NullPointerException</h2><p>在所有的 <code>RuntimeException</code> 异常中，Java 程序员最熟悉的恐怕就是 <code>NullPointerException</code> 了。</p><p><code>NullPointerException</code> 即空指针异常，俗称 NPE。如果一个对象为 <code>null</code>，调用其方法或访问其字段就会产生 <code>NullPointerException</code>，这个异常通常是由 JVM 抛出的，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(s.toLowerCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指针这个概念实际上源自 C 语言，Java 语言中并无指针。我们定义的变量实际上是引用，Null Pointer 更确切地说是 Null Reference，不过两者区别不大。</p><h3 id="处理NullPointerException"><a class="header-anchor" href="#处理NullPointerException"></a>处理NullPointerException</h3><p>如果遇到 <code>NullPointerException</code>，我们应该如何处理？首先，必须明确，<code>NullPointerException</code> 是一种代码逻辑错误，遇到 <code>NullPointerException</code>，遵循原则是早暴露，早修复，严禁使用 <code>catch</code> 来隐藏这种编码错误，好的编码习惯可以极大地降低 <code>NullPointerException</code> 的产生，例如成员变量在定义时初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用空字符串 <code>&quot;&quot;</code> 而不是默认的 <code>null</code> 可避免很多 <code>NullPointerException</code> ，编写业务逻辑时，用空字符串 <code>&quot;&quot;</code> 表示未填写比 <code>null</code> 安全得多。</p><p>返回空字符串 <code>&quot;&quot;</code> 、空数组而不是 <code>null</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] readLinesFromFile(String file) &#123;</span><br><span class="line">    <span class="keyword">if</span> (getFileSize(file) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 返回空数组而不是null:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样可以使得调用方无需检查结果是否为 <code>null</code>。</p><p>如果调用方一定要根据 <code>null</code> 判断，比如返回 <code>null</code> 表示文件不存在，那么考虑返回 <code>Optional&lt;T&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Optional&lt;String&gt; <span class="title">readFromFile</span><span class="params">(String file)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!fileExist(file)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样调用方必须通过 <code>Optional.isPresent()</code> 判断是否有结果。</p><h3 id="定位-NullPointerException"><a class="header-anchor" href="#定位-NullPointerException"></a>定位 NullPointerException</h3><p>如果产生了 <code>NullPointerException</code>，例如，调用 <code>a.b.c.x()</code> 时产生了 <code>NullPointerException</code>，原因可能是：</p><ul><li><code>a</code> 是 <code>null</code>；</li><li><code>a.b</code> 是 <code>null</code>；</li><li><code>a.b.c</code> 是 <code>null</code>；</li></ul><p>确定到底是哪个对象是 <code>null</code> 以前只能打印这样的日志：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(a);</span><br><span class="line">System.out.println(a.b);</span><br><span class="line">System.out.println(a.b.c);</span><br></pre></td></tr></table></figure><p>从 Java 14 开始，如果产生了 <code>NullPointerException</code>，JVM 可以给出详细的信息告诉我们 <code>null</code> 对象到底是谁。我们来看例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        System.out.println(p.address.city.toLowerCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String[] name = <span class="keyword">new</span> String[<span class="number">2</span>];</span><br><span class="line">    Address address = <span class="keyword">new</span> Address();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">    String city;</span><br><span class="line">    String street;</span><br><span class="line">    String zipcode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.NullPointerException: Cannot invoke &quot;String.toLowerCase()&quot; because &quot;p.address.city&quot; is null</span><br><span class="line">at Main.main(Main.java:4)</span><br></pre></td></tr></table></figure><p>可以在 <code>NullPointerException</code> 的详细信息中看到类似 <code>... because &quot;&lt;local1&gt;.address.city&quot; is null</code>，意思是 <code>city</code> 字段为 <code>null</code>，这样我们就能快速定位问题所在。</p><p>这种增强的 <code>NullPointerException</code> 详细信息是 Java 14 新增的功能，但默认是关闭的，我们可以给 JVM 添加一个 <code>-XX:+ShowCodeDetailsInExceptionMessages</code> 参数启用它，在 JDK 15 及以上默认是开启的。</p><h2 id="使用断言"><a class="header-anchor" href="#使用断言"></a>使用断言</h2><p>断言（Assertion）是一种调试程序的方式。在 Java 中，使用 <code>assert</code> 关键字来实现断言。我们先看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x = Math.abs(-<span class="number">123.45</span>);</span><br><span class="line">    <span class="keyword">assert</span> x &gt;= <span class="number">0</span>;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>语句 <code>assert x &gt;= 0;</code> 即为断言，断言条件 <code>x &gt;= 0</code> 预期为 <code>true</code>。如果计算结果为 <code>false</code>，则断言失败，抛出 <code>AssertionError</code>。</p><p>使用 <code>assert</code> 语句时，还可以添加一个可选的断言消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> x &gt;= <span class="number">0</span> : <span class="string">&quot;x must &gt;= 0&quot;</span>;</span><br></pre></td></tr></table></figure><p>这样，断言失败的时候，<code>AssertionError</code> 会带上消息 <code>x must &gt;= 0</code>，更加便于调试。</p><p>Java 断言的特点是：断言失败时会抛出 <code>AssertionError</code>，导致程序结束退出。因此，断言不能用于可恢复的程序错误，只应该用于开发和测试阶段。</p><p>对于可恢复的程序错误，不应该使用断言。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> arr != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应该抛出异常并在上层捕获：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;array cannot be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们在程序中使用 <code>assert</code> 时，例如，一个简单的断言：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">assert</span> x &gt; <span class="number">0</span>;</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>断言 <code>x</code> 必须大于 0，实际上 <code>x</code> 为 -1，断言肯定失败。执行上述代码，发现程序并未抛出 <code>AssertionError</code>，而是正常打印了 <code>x</code> 的值。为什么 <code>assert</code> 语句不起作用？</p><p>这是因为 JVM 默认关闭断言指令，即遇到 <code>assert</code> 语句就自动忽略了，不执行。</p><p>要执行 <code>assert</code> 语句，必须给 Java 虚拟机传递 <code>-enableassertions</code>（可简写为 <code>-ea</code> ）参数启用断言。所以，上述程序必须在命令行下运行才有效果。</p><p>还可以有选择地对特定地类启用断言，命令行参数是：<code>-ea:com.halo.test.Main</code> ，表示只对 <code>com.halo.test.Main</code> 这个类启用断言。或者对特定地包启用断言，命令行参数是：<code>-ea:com.halo.test...</code>（注意结尾有 3 个 <code>.</code> ），表示对 <code>com.halo.test</code> 这个包启动断言。</p><p>实际开发中，很少使用断言。更好的方法是编写单元测试，例如 JUnit。</p><h2 id="使用JDK-Logging"><a class="header-anchor" href="#使用JDK-Logging"></a>使用JDK Logging</h2><p>在编写程序的过程中，发现程序运行结果与预期不符，怎么办？当然是用 <code>System.out.println()</code> 打印出执行过程中的某些变量，观察每一步的结果与代码逻辑是否符合，然后有针对性地修改代码。</p><p>代码改好了怎么办？当然是删除没有用的 <code>System.out.println()</code> 语句了。</p><p>如果改代码又改出问题怎么办？再加上 <code>System.out.println()</code>。</p><p>反复这么搞几次，很快大家就发现使用 <code>System.out.println()</code> 非常麻烦。</p><p>怎么办？解决方法是使用日志（Logging）。它的目的是为了取代 <code>System.out.println()</code>。</p><p>输出日志，而不是用 <code>System.out.println()</code>，有以下几个好处：</p><ol><li>可以设置输出样式，避免自己每次都写 <code>&quot;ERROR: &quot; + var</code></li><li>可以设置输出级别，禁止某些级别输出。例如，只输出错误日志</li><li>可以被重定向到文件，这样可以在程序运行结束后查看日志</li><li>可以按包名控制日志级别，只输出某些包打的日志</li><li>……</li></ol><p>因为 Java 标准库内置了日志包 <code>java.util.logging</code>，我们可以直接用。先看一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Logger logger = Logger.getGlobal();</span><br><span class="line">        logger.info(<span class="string">&quot;start process...&quot;</span>);</span><br><span class="line">        logger.warning(<span class="string">&quot;memory is running out...&quot;</span>);</span><br><span class="line">        logger.fine(<span class="string">&quot;ignored.&quot;</span>);</span><br><span class="line">        logger.severe(<span class="string">&quot;process will be terminated...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码，得到类似如下的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">May 20, 2021 4:42:58 PM Hello main</span><br><span class="line">INFO: start process...</span><br><span class="line">May 20, 2021 4:42:58 PM Hello main</span><br><span class="line">WARNING: memory is running out...</span><br><span class="line">May 20, 2021 4:42:58 PM Hello main</span><br><span class="line">SEVERE: process will be terminated...</span><br></pre></td></tr></table></figure><p>对比可见，使用日志最大的好处是，它自动打印了时间、调用类、调用方法等很多有用的信息。再仔细观察发现，4 条日志，只打印了 3 条，<code>logger.fine()</code> 没有打印。这是因为，日志的输出可以设定级别。JDK 的 Logging 定义了 7 个日志级别，从严重到普通：SEVERE、WARNING、INFO、CONFIG、FINE、FINER、FINEST。</p><p>因为默认级别是 INFO，因此，INFO级别以下的日志，不会被打印出来。使用日志级别的好处在于，调整级别，就可以屏蔽掉很多调试相关的日志输出。</p><p>使用 Java 标准库内置的 Logging 有以下局限：</p><p>Logging 系统在 JVM 启动时读取配置文件并完成初始化，一旦开始运行 main() 方法，就无法修改配置；</p><p>配置不太方便，需要在 JVM 启动时传递参数 <code>-Djava.util.logging.config.file=&lt;config-file-name&gt;</code>。</p><p>因此，Java 标准库内置的 Logging 使用并不是非常广泛。</p><h2 id="使用-Commons-Logging"><a class="header-anchor" href="#使用-Commons-Logging"></a>使用 Commons Logging</h2><p>和 Java 标准库提供的日志不同，Commons Logging 是一个第三方日志库，它是由 Apache 创建的日志模块。</p><p>Commons Logging 的特色是，它可以挂接不同的日志系统，并通过配置文件指定挂接的日志系统。默认情况下，Commons Loggin 自动搜索并使用 Log4j（ Log4j 是另一个流行的日志系统），如果没有找到 Log4j，再使用 JDK Logging。</p><p>使用 Commons Logging 只需要和两个类打交道，并且只有两步：</p><ul><li>第一步，通过LogFactory获取Log类的实例</li><li>第二步，使用Log实例的方法打日志。</li></ul><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.logging.Log;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.LogFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Log log = LogFactory.getLog(Main.class);</span><br><span class="line">        log.info(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">        log.warn(<span class="string">&quot;end.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Maven 项目 pom.xml 中添加如下依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/commons-logging/commons-logging --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">May <span class="number">20</span>, <span class="number">2021</span> <span class="number">4</span>:<span class="number">56</span>:<span class="number">02</span> PM com.halo.logging.Main main</span><br><span class="line">INFO: start...</span><br><span class="line">May <span class="number">20</span>, <span class="number">2021</span> <span class="number">4</span>:<span class="number">56</span>:<span class="number">02</span> PM com.halo.logging.Main main</span><br><span class="line">WARNING: end.</span><br></pre></td></tr></table></figure><p>Commons Logging 定义了 6 个日志级别：FATAL、ERROR、WARNING、INFO、DEBUG、TRACE。默认级别是 INFO。</p><p>使用 Commons Logging 时，如果在静态方法中引用 Log，通常直接定义一个静态类型变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在静态方法中引用 Log:</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(Main.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实例方法中引用 <code>Log</code>，通常定义一个实例变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在实例方法中引用Log:</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Log log = LogFactory.getLog(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到实例变量 <code>log</code> 的获取方式是 <code>LogFactory.getLog(getClass())</code>，虽然也可以用 <code>LogFactory.getLog(Person.class)</code>，但是前一种方式有个非常大的好处，就是子类可以直接使用该 <code>log</code> 实例。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在子类中使用父类实例化的log:</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 Java 类的动态特性，子类获取的 <code>log</code> 字段实际上相当于 <code>LogFactory.getLog(Student.class)</code>，但却是从父类继承而来，并且无需改动代码。</p><p>此外，Commons Logging 的日志方法，例如 <code>info()</code>，除了标准的 <code>info(String)</code> 外，还提供了一个非常有用的重载方法：<code>info(String, Throwable)</code>，这使得记录异常更加简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;got exception!&quot;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-Log4j"><a class="header-anchor" href="#使用-Log4j"></a>使用 Log4j</h2><p>前面介绍了 Commons Logging ，可以作为“日志接口”来使用。而真正的“日志实现”可以使用 Log4j。</p><p>Log4j 是一种非常流行的日志框架。是一个组件化设计的日志系统，它的架构大致如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">log.info(&quot;User signed in.&quot;);</span><br><span class="line"> │</span><br><span class="line"> │   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐</span><br><span class="line"> ├──&gt;│ Appender │───&gt;│  Filter  │───&gt;│  Layout  │───&gt;│ Console  │</span><br><span class="line"> │   └──────────┘    └──────────┘    └──────────┘    └──────────┘</span><br><span class="line"> │</span><br><span class="line"> │   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐</span><br><span class="line"> ├──&gt;│ Appender │───&gt;│  Filter  │───&gt;│  Layout  │───&gt;│   File   │</span><br><span class="line"> │   └──────────┘    └──────────┘    └──────────┘    └──────────┘</span><br><span class="line"> │</span><br><span class="line"> │   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐</span><br><span class="line"> └──&gt;│ Appender │───&gt;│  Filter  │───&gt;│  Layout  │───&gt;│  Socket  │</span><br><span class="line">     └──────────┘    └──────────┘    └──────────┘    └──────────┘</span><br></pre></td></tr></table></figure><p>当我们使用 Log4j 输出一条日志时，Log4j 自动通过不同的 Appender 把同一条日志输出到不同的目的地。例如：</p><ul><li>console：输出到屏幕；</li><li>file：输出到文件；</li><li>socket：通过网络输出到远程计算机；</li><li>jdbc：输出到数据库。</li></ul><p>在输出日志的过程中，通过 <code>Filter</code> 来过滤哪些 log 需要被输出，哪些 log 不需要被输出。例如，仅输出 ERROR 级别的日志。</p><p>最后，通过 Layout 来格式化日志信息，例如，自动添加日期、时间、方法名称等信息。</p><p>上述结构虽然复杂，但我们在实际使用的时候，并不需要关心 Log4j 的 API，而是通过配置文件来配置它。</p><p>以 Maven项目 的 XML 配置为例，使用 Log4j 的时候，我们把一个 log4j2.xml 的文件放到 main/resourse 下就可以让 Log4j 读取配置文件并按照我们的配置来输出日志。下面是一个配置文件的例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Properties</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义日志格式 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">&quot;log.pattern&quot;</span>&gt;</span>%d&#123;MM-dd HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125;%n%msg%n%n<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义文件名变量 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">&quot;file.err.filename&quot;</span>&gt;</span>log/err.log<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">&quot;file.err.pattern&quot;</span>&gt;</span>log/err.%i.log.gz<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Properties</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义Appender，即目的地 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义输出到屏幕 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">&quot;console&quot;</span> <span class="attr">target</span>=<span class="string">&quot;SYSTEM_OUT&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 日志格式引用上面定义的log.pattern --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;$&#123;log.pattern&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义输出到文件,文件名引用上面定义的file.err.filename --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">&quot;err&quot;</span> <span class="attr">bufferedIO</span>=<span class="string">&quot;true&quot;</span> <span class="attr">fileName</span>=<span class="string">&quot;$&#123;file.err.filename&#125;&quot;</span> <span class="attr">filePattern</span>=<span class="string">&quot;$&#123;file.err.pattern&#125;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;$&#123;log.pattern&#125;&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 根据文件大小自动切割日志 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">&quot;1 MB&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 保留最近10份 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span> <span class="attr">max</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 对info级别的日志，输出到console --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;console&quot;</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 对error级别的日志，输出到err，即上面定义的RollingFile --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;err&quot;</span> <span class="attr">level</span>=<span class="string">&quot;error&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>虽然配置 Log4j 比较繁琐，但一旦配置完成，使用起来就非常方便。对上面的配置文件，凡是 INFO 级别的日志，会自动输出到屏幕，而 ERROR 级别的日志，不但会输出到屏幕，还会同时输出到文件。并且，一旦日志文件达到指定大小（1MB），Log4j 就会自动切割新的日志文件，并最多保留 10 份。</p><p>在 Maven 项目 pom.xml 中添加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/commons-logging/commons-logging --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-core --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.14.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-jcl --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-jcl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.14.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>要打印日志，只需要按 Commons Logging 的写法写，不需要改动任何代码，就可以得到 Log4j 的日志输出，类似：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">05-20 17:13:44.186 [main] INFO  com.halo.logging.Main</span><br><span class="line">start...</span><br><span class="line"></span><br><span class="line">05-20 17:13:44.191 [main] WARN  com.halo.logging.Main</span><br><span class="line">end.</span><br></pre></td></tr></table></figure><h2 id="使用-SLF4J-和-Logback"><a class="header-anchor" href="#使用-SLF4J-和-Logback"></a>使用 SLF4J 和 Logback</h2><p>前面介绍了 Commons Logging 和 Log4j 这一对，它们一个负责充当日志 API，一个负责实现日志底层，搭配使用非常便于开发。</p><p>其实 SLF4J 类似于Commons Logging，也是一个日志接口，而 Logback 类似于 Log4j，是一个日志的实现。</p><p>为什么有了 Commons Logging 和 Log4j，又会蹦出来 SLF4J 和 Logback？这是因为 Java 有着非常悠久的开源历史，不但 OpenJDK 本身是开源的，而且我们用到的第三方库，几乎全部都是开源的。开源生态丰富的一个特定就是，同一个功能，可以找到若干种互相竞争的开源库。</p><p>因为对 Commons Logging 的接口不满意，有人就搞了 SLF4J。因为对 Log4j 的性能不满意，有人就搞了 Logback。</p><p>我们先来看看 SLF4J 对 Commons Logging 的接口有何改进。在 Commons Logging 中，我们要打印日志，有时候得这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> score = <span class="number">99</span>;</span><br><span class="line">p.setScore(score);</span><br><span class="line">log.info(<span class="string">&quot;Set score &quot;</span> + score + <span class="string">&quot; for Person &quot;</span> + p.getName() + <span class="string">&quot; ok.&quot;</span>);</span><br></pre></td></tr></table></figure><p>拼字符串是一个非常麻烦的事情，所以 SLF4J 的日志接口改进成这样了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> score = <span class="number">99</span>;</span><br><span class="line">p.setScore(score);</span><br><span class="line">logger.info(<span class="string">&quot;Set score &#123;&#125; for Person &#123;&#125; ok.&quot;</span>, score, p.getName());</span><br></pre></td></tr></table></figure><p>我们靠猜也能猜出来，SLF4J 的日志接口传入的是一个带占位符的字符串，用后面的变量自动替换占位符，所以看起来更加自然。</p><p>如何使用 SLF4J ？它的接口实际上和 Commons Logging 几乎一模一样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比一下 Commons Logging 和 SLF4J 的接口，不同之处就是 <code>Log</code> 变成了 <code>Logger</code>，<code>LogFactory</code> 变成了 <code>LoggerFactory</code>。</p><p>在 Maven 项目中添加相关依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/ch.qos.logback/logback-classic --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>logback-classic</code> 依赖包括了 <code>slf4j-api</code> 所以无需单独引用</p><p>在 Maven 项目中添加相关配置文件 logback.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;CONSOLE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>log/output.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.FixedWindowRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>log/output.log.%i<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">triggeringPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">MaxFileSize</span>&gt;</span>1MB<span class="tag">&lt;/<span class="name">MaxFileSize</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">triggeringPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILE&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行即可获得类似如下的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">17:28:08.829 [main] INFO  com.halo.slf4j.Test - start...</span><br><span class="line">17:28:08.832 [main] WARN  com.halo.slf4j.Test - end.</span><br></pre></td></tr></table></figure><p>从目前的趋势来看，越来越多的开源项目从 Commons Logging 加 Log4j 转向了 SLF4J 加 Logback。</p>]]></content>
    
    
    <summary type="html">Java异常和日志</summary>
    
    
    
    <category term="Java" scheme="http://halo123.top/categories/Java/"/>
    
    
    <category term="Java" scheme="http://halo123.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>蘑菇博客环境搭建</title>
    <link href="http://halo123.top/2021/05/15/MoGuBlog/A_%E8%98%91%E8%8F%87%E5%8D%9A%E5%AE%A2%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://halo123.top/2021/05/15/MoGuBlog/A_%E8%98%91%E8%8F%87%E5%8D%9A%E5%AE%A2%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</id>
    <published>2021-05-15T07:45:20.000Z</published>
    <updated>2021-05-15T13:34:29.956Z</updated>
    
    <content type="html"><![CDATA[<div class="tag link"><a class="link-card" title="蘑菇博客项目地址" href="https://gitee.com/moxi159753/mogu_blog_v2"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/icon/Gitee.svg"/></div><div class="right"><p class="text">蘑菇博客项目地址</p><p class="url">https://gitee.com/moxi159753/mogu_blog_v2</p></div></a></div><p>蘑菇博客（MoguBlog），一个基于微服务架构的前后端分离博客系统。Web 端使用 Vue + Element , 移动端使用 uniapp 和 ColorUI。后端使用 Spring Cloud + Spring Boot + mybatis-plus 进行开发，使用 Jwt + Spring Security 做登录验证和权限校验，使用 ElasticSearch 和 Solr 作为全文检索服务，使用 Github Actions 完成博客的持续集成，使用 ELK 收集博客日志，文件支持上传七牛云和 Minio，支持 Docker Compose 脚本一键部署。</p><p>参考资料：</p><div class="tag link"><a class="link-card" title="Windows+VMware一键搭建蘑菇博客本地开发环境" href="http://www.moguit.cn/#/info?blogOid=583"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@master/img/网站.svg"/></div><div class="right"><p class="text">Windows+VMware一键搭建蘑菇博客本地开发环境</p><p class="url">http://www.moguit.cn/#/info?blogOid=583</p></div></a></div><h2 id="Docker-环境"><a class="header-anchor" href="#Docker-环境"></a>Docker 环境</h2><p>在 VMware 或 云服务器中 配置 Docker 环境</p><h3 id="安装Docker"><a class="header-anchor" href="#安装Docker"></a>安装Docker</h3><p>因为我们需要拉取镜像，所以需要在服务器提前安装好 Docker，首先配置一下 Docker 的阿里 yum 源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cat &gt;&#x2F;etc&#x2F;yum.repos.d&#x2F;docker.repo&lt;&lt;EOF</span><br><span class="line">[docker-ce-edge]</span><br><span class="line">name&#x3D;Docker CE Edge - \$basearch</span><br><span class="line">baseurl&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;7&#x2F;\$basearch&#x2F;edge</span><br><span class="line">enabled&#x3D;1</span><br><span class="line">gpgcheck&#x3D;1</span><br><span class="line">gpgkey&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>然后 yum 方式安装 Docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># yum安装</span><br><span class="line">yum -y install docker-ce</span><br><span class="line"># 查看docker版本</span><br><span class="line">docker --version  </span><br><span class="line"># 开机自启</span><br><span class="line">systemctl enable docker</span><br><span class="line"># 启动docker</span><br><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><p>配置 Docker 的镜像源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat &gt;&gt; &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;b9pmyelo.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>然后重启 Docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><p>因为 Docker 容器之间，需要互相通信访问，所以我们需要创建我们的 Docker 网络</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create mogu</span><br></pre></td></tr></table></figure><h3 id="安装-Docker-Compose"><a class="header-anchor" href="#安装-Docker-Compose"></a>安装 Docker Compose</h3><p>Docker Compose 是用来定义和运行多个 Docker 应用程序的工具。通过 Compose，可以使用 YAML 文件来配置应用程序需要的所有服务，然后使用一个命令即可从YML文件配置中创建并启动所有服务。</p><div class="tag link"><a class="link-card" title="安装 Docker Compose 官方文档" href="https://docs.docker.com/compose/install/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/DockerIcon.svg"/></div><div class="right"><p class="text">安装 Docker Compose 官方文档</p><p class="url">https://docs.docker.com/compose/install/</p></div></a></div><div class="tag link"><a class="link-card" title="Docker Compose 下载链接" href="https://github.com/docker/compose/releases"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/GithubIcon.jpg"/></div><div class="right"><p class="text">Docker Compose 下载链接</p><p class="url">https://github.com/docker/compose/releases</p></div></a></div><p>把下载到的文件使用 ftp 工具，拷贝到 /usr/local/bin/ 目录下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 重命名</span><br><span class="line">mv docker-compose-Linux-x86_64  docker-compose</span><br><span class="line"># 加入执行权限</span><br><span class="line">sudo chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span><br><span class="line"># 查看docker-compose版本</span><br><span class="line">docker-compose -v</span><br></pre></td></tr></table></figure><h2 id="下载源码"><a class="header-anchor" href="#下载源码"></a>下载源码</h2><p>下载蘑菇博客的<a href="https://gitee.com/moxi159753/mogu_blog_v2">源码</a></p><p>找到，doc\docker-compose 目录，目录结构如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker-compose</span><br><span class="line"> ├── bin     # 相关一键启动脚本的目录</span><br><span class="line"> ├── config  # 存放配置文件</span><br><span class="line"> ├── data    # 存放数据文件</span><br><span class="line"> ├── log     # 存放日志文件</span><br><span class="line"> └── yaml    # 存放 docker compose 的 yaml 文件</span><br></pre></td></tr></table></figure><p>下面我们开始，将 docker-compose 文件夹，拷贝服务器目录位置随意，我是拷贝到 /root/docker-compose 目录，然后给命令设置执行权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 进入目录</span><br><span class="line">cd docker-compose</span><br><span class="line"># 添加执行权限</span><br><span class="line">chmod +x bin&#x2F;middleware.sh</span><br><span class="line">chmod +x bin&#x2F;kernShutdown.sh</span><br><span class="line">chmod +x bin&#x2F;wait-for-it.sh</span><br></pre></td></tr></table></figure><h2 id="部署核心组件"><a class="header-anchor" href="#部署核心组件"></a>部署核心组件</h2><p>下面我们将部署蘑菇博客所依赖的核心中间件，例如：Nacos、MySQL、Redis、RabbitMQ、Nginx 等</p><p>首先到 docker-compose/bin 目录下，执行脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 开始部署核心组件</span><br><span class="line">sh middleware.sh</span><br><span class="line"># 以后打算关闭的话，执行 .&#x2F;kernShutdown.sh</span><br></pre></td></tr></table></figure><p>在部署完中间件后，我们需要进行测试中间件安装是否成功。</p><h3 id="MySQL"><a class="header-anchor" href="#MySQL"></a>MySQL</h3><p>利用 SQLyog、IDEA等工具测试连接：</p><p>默认MySQL用户名：root<br>默认MySQL密码：mogu2018</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/Idea%E6%B5%8B%E8%AF%95mugo_mysql%E8%BF%9E%E6%8E%A5.png" alt="Idea测试mugo_mysql连接"></p><h3 id="Nacos"><a class="header-anchor" href="#Nacos"></a>Nacos</h3><p>Nacos 后台配置页面，默认账号和密码：nacos  nacos</p><p>访问下面 URL 进行测试 <a href="http://nacos:8848/nacos">http://nacos:8848/nacos</a></p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/%E6%B5%8B%E8%AF%95nacos_mugo%E8%BF%9E%E6%8E%A5.png" alt="测试nacos_mugo连接"></p><blockquote><p>设置 host 将 nacos 改为对应服务器外网 IP ，记得开放对应端口</p></blockquote><h3 id="Redis"><a class="header-anchor" href="#Redis"></a>Redis</h3><p>默认Redis密码：mogu2018</p><h3 id="RabbitMQ"><a class="header-anchor" href="#RabbitMQ"></a>RabbitMQ</h3><p>RabbitMQ是消息队列，我们可以访问其图形化界面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 图形化地址</span><br><span class="line">IP地址:15672</span><br><span class="line"># 默认账号和密码为：admin  mogu2018</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/%E6%B5%8B%E8%AF%95rabbitmq_mugo%E8%BF%9E%E6%8E%A5.png" alt="测试rabbitmq_mugo连接"></p><h2 id="部署非核心组件"><a class="header-anchor" href="#部署非核心组件"></a>部署非核心组件</h2><h3 id="Zipkin"><a class="header-anchor" href="#Zipkin"></a>Zipkin</h3><p>Zipkin是一个开源的分布式的链路追踪系统，每个微服务都会向zipkin报告计时数据，聚合各业务系统调用延迟数据，达到链路调用监控跟踪</p><h3 id="Sentinel"><a class="header-anchor" href="#Sentinel"></a>Sentinel</h3><h3 id="搜索模块"><a class="header-anchor" href="#搜索模块"></a>搜索模块</h3><h2 id="启动后端项目"><a class="header-anchor" href="#启动后端项目"></a>启动后端项目</h2><h3 id="修改项目配置"><a class="header-anchor" href="#修改项目配置"></a>修改项目配置</h3><p>修改的是 mogu_admin 项目的 application.yml，将 dev 改成 prod 然后修改 bootstrap.yaml ，将 dev 改成 prod，同时还需要修改 nacos 和 sentinel ，将 localhost改为对应的服务名称即可。</p><p>我们重复上面操作，将 mogu_web、mogu_sms、mogu_gateway、mogu_picture、mogu_montor 等项目都进行修改。</p><h3 id="启动项目"><a class="header-anchor" href="#启动项目"></a>启动项目</h3><p>修改完成后，直接启动项目即可。其中我们需要启动核心组件包含下面几个【服务启动没有先后顺序】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mogu_admin、mogu_web、mogu_sms、mogu_picture、mogu_gateway</span><br></pre></td></tr></table></figure><p>等服务器都启动完成后，下面我们验证一下后台是否正常启动，回到我们的 Nacos 管理界面,如果我们看到下面五个服务都注册到 Nacos 中，那说明启动成功</p><ul><li>mogu_picture</li><li>mogu_sms</li><li>mogu_admin</li><li>mogu_web</li><li>mogu_gateway</li></ul><p>在通过访问下列 swagger 接口，测试接口是否正常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">############ admin端swagger ##################</span><br><span class="line">http:&#x2F;&#x2F;localhost:8601&#x2F;swagger-ui&#x2F;index.html</span><br><span class="line"></span><br><span class="line">############ picture端swagger ##################</span><br><span class="line">http:&#x2F;&#x2F;localhost:8602&#x2F;swagger-ui&#x2F;index.html</span><br><span class="line"></span><br><span class="line">############ web端swagger ##################</span><br><span class="line">http:&#x2F;&#x2F;localhost:8603&#x2F;swagger-ui&#x2F;index.html</span><br></pre></td></tr></table></figure><p>如果能够进入下面页面的话，说明后台是没有问题的了，下面我们可以验证一下接口</p>]]></content>
    
    
    <summary type="html">蘑菇博客是我目前找到理想的博客系统，基于对该项目的学习，进一步掌握 Java 后端过程</summary>
    
    
    
    <category term="蘑菇博客" scheme="http://halo123.top/categories/%E8%98%91%E8%8F%87%E5%8D%9A%E5%AE%A2/"/>
    
    
  </entry>
  
  <entry>
    <title>服务器环境搭建</title>
    <link href="http://halo123.top/2021/05/15/WebAfterEnd/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://halo123.top/2021/05/15/WebAfterEnd/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</id>
    <published>2021-05-15T06:56:51.000Z</published>
    <updated>2021-05-15T06:47:29.809Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基于-Docker-的环境搭建"><a class="header-anchor" href="#基于-Docker-的环境搭建"></a>基于 Docker 的环境搭建</h2><h3 id="安装Docker"><a class="header-anchor" href="#安装Docker"></a>安装Docker</h3><div class="tag link"><a class="link-card" title="Docker文档" href="https://docs.docker.com/engine/install/centos/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/DockerIcon.svg"/></div><div class="right"><p class="text">Docker文档</p><p class="url">https://docs.docker.com/engine/install/centos/</p></div></a></div><ol><li><p>卸载系统之前的docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br><span class="line">            </span><br></pre></td></tr></table></figure></li><li><p>安装依赖的包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-utils</span><br></pre></td></tr></table></figure></li><li><p>配置镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br></pre></td></tr></table></figure></li><li><p>安装Docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure></li><li><p>启动Docker服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure></li><li><p>检测Docker是否安装成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -v</span><br></pre></td></tr></table></figure></li><li><p>查看下载镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker images</span><br></pre></td></tr></table></figure></li><li><p>设置开机自启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable docker</span><br></pre></td></tr></table></figure></li></ol><h3 id="配置-Docker-镜像加速"><a class="header-anchor" href="#配置-Docker-镜像加速"></a>配置 Docker 镜像加速</h3><div class="tag link"><a class="link-card" title="阿里云镜像加速" href="https://cr.console.aliyun.com/cn-qingdao/instances/mirrors"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/icon/阿里云.svg"/></div><div class="right"><p class="text">阿里云镜像加速</p><p class="url">https://cr.console.aliyun.com/cn-qingdao/instances/mirrors</p></div></a></div><p>针对Docker客户端版本大于 1.10.0 的用户</p><p>您可以通过修改daemon配置文件 /etc/docker/daemon.json 来使用加速器</p><ol><li><p>创建目录</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p &#x2F;etc&#x2F;docker</span><br></pre></td></tr></table></figure></li><li><p>配置镜像加速器地址</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo tee &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;-&#39;EOF&#39;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;578xeysa.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li><li><p>重启 Docker 后台线程</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br></pre></td></tr></table></figure></li><li><p>重启 Docker 服务</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure></li></ol><h3 id="安装-MySQL"><a class="header-anchor" href="#安装-MySQL"></a>安装 MySQL</h3><ol><li><p>拉取 MySQL 5.7 的镜像</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull mysql:5.7</span><br></pre></td></tr></table></figure></li><li><p>检查下载的镜像</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker images</span><br></pre></td></tr></table></figure></li><li><p>创建实例并启动</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -p 3306:3306 --name mysql \</span><br><span class="line">-v &#x2F;mydata&#x2F;mysql&#x2F;log:&#x2F;var&#x2F;log&#x2F;mysql \</span><br><span class="line">-v &#x2F;mydata&#x2F;mysql&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql \</span><br><span class="line">-v &#x2F;mydata&#x2F;mysql&#x2F;conf:&#x2F;etc&#x2F;mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD&#x3D;root \</span><br><span class="line">-d mysql:5.7</span><br></pre></td></tr></table></figure><blockquote><p>配置说明：<br><code>-p 3306:3306</code> 将容器的3306端口映射到主机的3306端口<br><code>--name</code> 指定容器名字<br><code>-v</code>目录挂载<br><code>-e</code>设置mysql参数，初始化root用户的密码<br><code>-d</code>后台运行</p></blockquote></li><li><p>查看 Docker 正在运行的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure></li><li><p>进入容器内部</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mysql bin&#x2F;bash</span><br><span class="line"># 退出命令</span><br><span class="line">exit</span><br></pre></td></tr></table></figure></li><li><p>查看 MySQL 位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis mysql</span><br></pre></td></tr></table></figure></li><li><p>修改 MySQL 配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;mydata&#x2F;mysql&#x2F;conf&#x2F;my.cnf</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">default-character-set&#x3D;utf8</span><br><span class="line">[mysql]</span><br><span class="line">default-character-set&#x3D;utf8</span><br><span class="line">[mysqld]</span><br><span class="line">init_connect&#x3D;&#39;SET collation_connection &#x3D; utf8_unicode_ci&#39;</span><br><span class="line">init_connect&#x3D;&#39;SET NAMES utf8&#39;</span><br><span class="line">character-set-server&#x3D;utf8</span><br><span class="line">collation-server&#x3D;utf8_unicode_ci</span><br><span class="line">skip-character-set-client-handshake</span><br><span class="line">skip-name-resolve</span><br></pre></td></tr></table></figure></li><li><p>重启 MySQL</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart mysql</span><br></pre></td></tr></table></figure></li></ol><h3 id="安装-Redis"><a class="header-anchor" href="#安装-Redis"></a>安装 Redis</h3><ol><li><p>拉取镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull redis</span><br></pre></td></tr></table></figure></li><li><p>先配置目录，注意 <code>redis.conf</code> 是文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p &#x2F;mydata&#x2F;redis&#x2F;conf</span><br><span class="line">touch &#x2F;mydata&#x2F;redis&#x2F;conf&#x2F;redis.conf</span><br></pre></td></tr></table></figure></li><li><p>安装，挂载目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 6379:6379 --name redis \</span><br><span class="line">-v &#x2F;mydata&#x2F;redis&#x2F;data:&#x2F;data \</span><br><span class="line">-v &#x2F;mydata&#x2F;redis&#x2F;conf&#x2F;redis.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf \</span><br><span class="line">-d redis redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf</span><br></pre></td></tr></table></figure></li><li><p>直接进去 redis 客户端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it redis redis-cli</span><br></pre></td></tr></table></figure></li><li><p>配置 redis 持久化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;mydata&#x2F;redis&#x2F;conf&#x2F;redis.conf</span><br></pre></td></tr></table></figure><p>插入以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart redis</span><br></pre></td></tr></table></figure></li><li><p>设置 redis 容器在 Docker 启动的时候启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker update redis --restart&#x3D;always</span><br></pre></td></tr></table></figure></li></ol><h3 id="安装-Nacos"><a class="header-anchor" href="#安装-Nacos"></a>安装 Nacos</h3><ol><li><p>拉取镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nacos&#x2F;nacos-server</span><br></pre></td></tr></table></figure></li><li><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8848:8848 --env MODE&#x3D;standalone --name nacos nacos&#x2F;nacos-server</span><br></pre></td></tr></table></figure></li></ol><h3 id="安装-Elasticsearch、Kibana"><a class="header-anchor" href="#安装-Elasticsearch、Kibana"></a>安装 Elasticsearch、Kibana</h3><ol><li><p>下载镜像文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 存储和检索数据</span><br><span class="line">docker pull elasticsearch:7.4.2</span><br><span class="line"></span><br><span class="line"># 可视化检索数据</span><br><span class="line">docker pull kibana:7.4.2</span><br></pre></td></tr></table></figure></li><li><p>配置挂载数据文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 创建配置文件目录</span><br><span class="line">mkdir -p &#x2F;mydata&#x2F;elasticsearch&#x2F;config</span><br><span class="line"></span><br><span class="line"># 创建数据目录</span><br><span class="line">mkdir -p &#x2F;mydata&#x2F;elasticsearch&#x2F;data</span><br><span class="line"></span><br><span class="line"># 将&#x2F;mydata&#x2F;elasticsearch&#x2F;文件夹中文件都可读可写</span><br><span class="line">chmod -R 777 &#x2F;mydata&#x2F;elasticsearch&#x2F;</span><br><span class="line"></span><br><span class="line"># 配置任意机器可以访问 elasticsearch</span><br><span class="line">echo &quot;http.host: 0.0.0.0&quot; &gt;&#x2F;mydata&#x2F;elasticsearch&#x2F;config&#x2F;elasticsearch.yml</span><br></pre></td></tr></table></figure></li><li><p>启动 Elasticsearch</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run --name elasticsearch -p 9200:9200 -p 9300:9300 \</span><br><span class="line">-e  &quot;discovery.type&#x3D;single-node&quot; \</span><br><span class="line">-e ES_JAVA_OPTS&#x3D;&quot;-Xms64m -Xmx512m&quot; \</span><br><span class="line">-v &#x2F;mydata&#x2F;elasticsearch&#x2F;config&#x2F;elasticsearch.yml:&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;config&#x2F;elasticsearch.yml \</span><br><span class="line">-v &#x2F;mydata&#x2F;elasticsearch&#x2F;data:&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;data \</span><br><span class="line">-v  &#x2F;mydata&#x2F;elasticsearch&#x2F;plugins:&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;plugins \</span><br><span class="line">-d elasticsearch:7.4.2 </span><br></pre></td></tr></table></figure><blockquote><p>配置说明：<br><code>-p 9200:9200 -p 9300:9300</code>：向外暴露两个端口，9200 用于HTTP REST API请求，9300 ES 在分布式集群状态下 ES 之间的通信端口；<br><code>-e  &quot;discovery.type=single-node&quot;</code>：es 以单节点运行<br><code>-e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot;</code>：设置启动占用内存，不设置可能会占用当前系统所有内存<br><code>-v</code>：挂载容器中的配置文件、数据文件、插件数据到本机的文件夹；<br><code>-d elasticsearch:7.6.2</code>：指定要启动的镜像</p></blockquote></li><li><p>设置 Elasticsearch 随 Docker 启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 当前 Docker 开机自启，所以 ES 现在也是开机自启</span><br><span class="line">docker update elasticsearch --restart&#x3D;always</span><br></pre></td></tr></table></figure></li><li><p>启动可视化 Kibana</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run --name kibana \</span><br><span class="line">-e ELASTICSEARCH_HOSTS&#x3D;http:&#x2F;&#x2F;&#123;IP地址&#125;:9200 \</span><br><span class="line">-p 5601:5601 \</span><br><span class="line">-d kibana:7.4.2</span><br></pre></td></tr></table></figure><blockquote><p>配置说明：<br><code>-e ELASTICSEARCH_HOSTS=http://&#123;IP地址&#125;:9200</code>: 这里要设置成自己的虚拟机IP地址</p></blockquote></li><li><p>浏览器输入 IP地址:5601 测试</p><blockquote><p>注意：将服务器对应端口的防火墙关闭</p></blockquote></li></ol>]]></content>
    
    
    <summary type="html">由于环境搭建比较繁琐，该文章用于记录平时需要配置的一些环境过程，一方面为了复现，另一方面在环境有问题时可以用做参考</summary>
    
    
    
    <category term="Linux" scheme="http://halo123.top/categories/Linux/"/>
    
    
    <category term="Docker" scheme="http://halo123.top/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>贪心算法</title>
    <link href="http://halo123.top/2021/05/14/LeetCode/GreedyAlgorithm/"/>
    <id>http://halo123.top/2021/05/14/LeetCode/GreedyAlgorithm/</id>
    <published>2021-05-14T10:56:51.000Z</published>
    <updated>2021-05-18T15:10:29.322Z</updated>
    
    <content type="html"><![CDATA[<p>参考资料：</p><div class="tag link"><a class="link-card" title="《LeetCode 101：和你一起你轻松刷题（C++）》" href="https://github.com/changgyhub/leetcode_101"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/GithubIcon.jpg"/></div><div class="right"><p class="text">《LeetCode 101：和你一起你轻松刷题（C++）》</p><p class="url">https://github.com/changgyhub/leetcode_101</p></div></a></div><h2 id="算法解释"><a class="header-anchor" href="#算法解释"></a>算法解释</h2><p>顾名思义，贪心算法或贪心思想采用贪心的策略，保证每次操作都是局部最优的，从而使最后得到的结果是全局最优的。</p><p>举一个最简单的例子：小明和小王喜欢吃苹果，小明可以吃五个，小王可以吃三个。已知苹果园里有吃不完的苹果，求小明和小王一共最多吃多少个苹果。在这个例子中，我们可以选用的贪心策略为，每个人吃自己能吃的最多数量的苹果，这在每个人身上都是局部最优的。又因为全局结果是局部结果的简单求和，且局部结果互不相干，因此局部最优的策略也同样是全局最优的策略。</p><h2 id="分配问题"><a class="header-anchor" href="#分配问题"></a>分配问题</h2><h3 id="分发饼干"><a class="header-anchor" href="#分发饼干"></a>分发饼干</h3><div class="tag link"><a class="link-card" title="455. 分发饼干" href="https://leetcode-cn.com/problems/assign-cookies/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/leetcodeicon.svg"/></div><div class="right"><p class="text">455. 分发饼干</p><p class="url">https://leetcode-cn.com/problems/assign-cookies/</p></div></a></div><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 <code>i</code> ，都有一个胃口值 <code>g[i]</code>，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 <code>j</code>，都有一个尺寸 <code>s[j]</code> 。如果 <code>s[j] &gt;= g[i]</code>，我们可以将这个饼干 <code>j</code> 分配给孩子 <code>i</code> ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><div class="tabs" id="分发饼干"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分发饼干-1">示例 1</button></li><li class="tab"><button type="button" data-href="#分发饼干-2">示例 2</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分发饼干-1"><p>输入：<code>g = [1,2,3]</code> ，<code>s = [1,1]</code></p><p>输出：<code>1</code></p><p>解释：你有三个孩子和两块小饼干，3 个孩子的胃口值分别是：1，2，3。虽然你有两块小饼干，由于他们的尺寸都是 1 ，你只能让胃口值是 1 的孩子满足。所以你应该输出 1 。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分发饼干-2"><p>输入：<code>g = [1,2]</code>，<code>s = [1,2,3]</code></p><p>输出：<code>2</code></p><p>解释：你有两个孩子和三块小饼干，2 个孩子的胃口值分别是 1，2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出2。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>因为饥饿度最小的孩子最容易吃饱，所以我们先考虑这个孩子。为了尽量使得剩下的饼干可以满足饥饿度更大的孩子，所以我们应该把大于等于这个孩子饥饿度的、且大小最小的饼干给这个孩子。满足了这个孩子之后，我们采取同样的策略，考虑剩下孩子里饥饿度最小的孩子，直到没有满足条件的饼干存在。</p><p>简而言之，这里的贪心策略是，给剩余孩子里最小饥饿度的孩子分配最小的能饱腹的饼干。</p><p>至于具体实现，因为我们需要获得大小关系，一个便捷的方法就是把孩子和饼干分别排序。这样我们就可以从饥饿度最小的孩子和大小最小的饼干出发，计算有多少个对子可以满足条件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; g, vector&lt;<span class="keyword">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对胃口值进行升序排序</span></span><br><span class="line">        <span class="built_in">sort</span>(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 对饼干进行升序排序</span></span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> child = <span class="number">0</span>, cookie = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 循环遍历，如果其中一个数组长度小于另一个则跳出循环</span></span><br><span class="line">        <span class="keyword">while</span> (child &lt; g.<span class="built_in">size</span>() &amp;&amp; cookie &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (g[child] &lt;= s[cookie]) &#123;</span><br><span class="line">                <span class="comment">// 满足一个孩子</span></span><br><span class="line">                child++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 无论是否满足都将饼干++</span></span><br><span class="line">            cookie++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回满足的孩子数</span></span><br><span class="line">        <span class="keyword">return</span> child;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; children = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; cookies = &#123;<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> result = Solution::<span class="built_in">findContentChildren</span>(children, cookies);</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; children = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; cookies = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> result = Solution::<span class="built_in">findContentChildren</span>(children, cookies);</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;example 1 &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test1</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;example 2 &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test2</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findContentChildren</span>(<span class="params">g, s</span>):</span></span><br><span class="line">    <span class="comment"># 升序排序</span></span><br><span class="line">    g.sort()</span><br><span class="line">    s.sort()</span><br><span class="line">    child = cookie = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(child &lt; <span class="built_in">len</span>(g) <span class="keyword">and</span> cookie &lt; <span class="built_in">len</span>(s)):</span><br><span class="line">        <span class="keyword">if</span> (g[child] &lt;= s[cookie]):</span><br><span class="line">            child += <span class="number">1</span></span><br><span class="line">        cookie += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> child</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test1 = findContentChildren([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(test1)</span><br><span class="line">test2 = findContentChildren([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(test2)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="keyword">int</span>[] g, <span class="keyword">int</span>[] s)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        <span class="keyword">int</span> child = <span class="number">0</span>, cookie = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (child &lt; g.length &amp;&amp; cookie &lt; s.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (g[child] &lt;= s[cookie]) &#123;</span><br><span class="line">                child++;</span><br><span class="line">            &#125;</span><br><span class="line">            cookie++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span>[] g, <span class="keyword">int</span>[] s)</span></span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="keyword">int</span> result = solution.findContentChildren(g, s);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] g1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] s1 = &#123;<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;example 1&quot;</span>);</span><br><span class="line">        test(g1,s1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] g2 = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] s2 = &#123;<span class="number">1</span>, <span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;example 2&quot;</span>);</span><br><span class="line">        test(g2,s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color="#33a3dc">复杂度分析</font></strong></p><p>时间复杂度：$O(m \log m + n \log n$)，其中 $m$ 和 $n$ 分别是数组 $g$ 和 $s$ 的长度。对两个数组排序的时间复杂度是 $O(m \log m + n \log n)$，遍历数组的时间复杂度是 $O(m+n)$，因此总时间复杂度是 $O(m \log m + n \log n)$。</p><p>空间复杂度：$O(\log m + \log n)$，其中 $m$ 和 $n$ 分别是数组 $g$ 和 $s$ 的长度。空间复杂度主要是排序的额外空间开销。</p><h3 id="分发糖果"><a class="header-anchor" href="#分发糖果"></a>分发糖果</h3><div class="tag link"><a class="link-card" title="135. 分发糖果" href="https://leetcode-cn.com/problems/candy/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/leetcodeicon.svg"/></div><div class="right"><p class="text">135. 分发糖果</p><p class="url">https://leetcode-cn.com/problems/candy/</p></div></a></div><p>老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。</p><p>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p><ul><li>每个孩子至少分配到 1 个糖果。</li><li>评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。</li></ul><p>那么这样下来，老师至少需要准备多少颗糖果呢？</p><div class="tabs" id="分发糖果"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分发糖果-1">示例 1</button></li><li class="tab"><button type="button" data-href="#分发糖果-2">示例 2</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分发糖果-1"><p>输入：<code>[1,0,2]</code></p><p>输出：<code>5</code></p><p>解释：你可以分别给这三个孩子分发 2、1、2 颗糖果。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分发糖果-2"><p>输入：<code>[1,2,2]</code></p><p>输出：<code>4</code></p><p>解释：你可以分别给这三个孩子分发 1、2、1 颗糖果。第三个孩子只得到 1 颗糖果，这已满足上述两个条件。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>虽然这一道题也是运用贪心策略，但我们只需要简单的两次遍历即可：</p><ol><li>把所有孩子的糖果数初始化为 1；</li><li>先从左往右遍历一遍，如果右边孩子的评分比左边的高，则右边孩子的糖果数更新为左边孩子的糖果数加 1；</li><li>再从右往左遍历一遍，如果左边孩子的评分比右边的高，且左边孩子当前的糖果数不大于右边孩子的糖果数，则左边孩子的糖果数更新为右边孩子的糖果数加 1。</li></ol><p>通过这两次遍历，分配的糖果就可以满足题目要求了。这里的贪心策略即为，在每次遍历中，只考虑并更新相邻一侧的大小关系。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">candy</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;ratings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nums = ratings.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (nums &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化数组</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">candies</span><span class="params">(nums, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 从左遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i + <span class="number">1</span>] &gt; ratings[i]) &#123;</span><br><span class="line">                candies[i + <span class="number">1</span>] = candies[i] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从右遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i - <span class="number">1</span>] &gt; ratings[i] &amp;&amp; candies[i - <span class="number">1</span>] &lt;= candies[i]) &#123;</span><br><span class="line">                candies[i - <span class="number">1</span>] = candies[i] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">accumulate</span>(candies.<span class="built_in">begin</span>(), candies.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; children = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> result = Solution::<span class="built_in">candy</span>(children);</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">candy</span>(<span class="params">ratings</span>):</span></span><br><span class="line">    lens = <span class="built_in">len</span>(ratings)</span><br><span class="line">    <span class="keyword">if</span>(lens &lt; <span class="number">2</span>):</span><br><span class="line">        <span class="keyword">return</span> lens</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将糖果数量列表每项值初始化为1</span></span><br><span class="line">    num_list = [<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, lens)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 先从左往右遍历一遍</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, lens-<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 如果右边孩子的评分比左边的高</span></span><br><span class="line">        <span class="keyword">if</span>(ratings[i+<span class="number">1</span>] &gt; ratings[i]):</span><br><span class="line">            <span class="comment"># 右边孩子的糖果数更新为左边孩子的糖果数加 1</span></span><br><span class="line">            num_list[i+<span class="number">1</span>] = num_list[i]+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 再从右往左遍历一遍</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(lens-<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 如果左边孩子的评分比右边的高</span></span><br><span class="line">        <span class="comment"># 且左边孩子当前的糖果数不大于右边孩子的糖果数</span></span><br><span class="line">        <span class="keyword">if</span>(ratings[j-<span class="number">1</span>] &gt; ratings[j] <span class="keyword">and</span> num_list[j-<span class="number">1</span>] &lt;= num_list[j]):</span><br><span class="line">            num_list[j-<span class="number">1</span>] = num_list[j]+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 求得总糖果数</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> num_list:</span><br><span class="line">        num += k</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(candy([<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>]))</span><br><span class="line"><span class="built_in">print</span>(candy([<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>]))</span><br><span class="line"><span class="built_in">print</span>(candy([<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>]))</span><br><span class="line"><span class="built_in">print</span>(candy([<span class="number">1</span>, <span class="number">2</span>]))</span><br><span class="line"><span class="built_in">print</span>(candy([<span class="number">1</span>]))</span><br></pre></td></tr></table></figure><p><strong><font color="#33a3dc">复杂度分析</font></strong></p><p>时间复杂度：$O(n)$，其中 $n$ 是孩子的数量。我们需要遍历两次数组以分别计算满足左规则或右规则的最少糖果数量。</p><p>空间复杂度：$O(n)$，其中 $n$ 是孩子的数量。我们需要保存所有的左规则对应的糖果数量。</p><h2 id="区间问题"><a class="header-anchor" href="#区间问题"></a>区间问题</h2><h3 id="无重叠区间"><a class="header-anchor" href="#无重叠区间"></a>无重叠区间</h3><div class="tag link"><a class="link-card" title="435. 无重叠区间" href="https://leetcode-cn.com/problems/non-overlapping-intervals/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/leetcodeicon.svg"/></div><div class="right"><p class="text">435. 无重叠区间</p><p class="url">https://leetcode-cn.com/problems/non-overlapping-intervals/</p></div></a></div><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p><p>注意:</p><ol><li>可以认为区间的终点总是大于它的起点。</li><li>区间 <code>[1,2]</code> 和 <code>[2,3]</code> 的边界相互“接触”，但没有相互重叠。</li></ol><div class="tabs" id="无重叠区间"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#无重叠区间-1">示例 1</button></li><li class="tab"><button type="button" data-href="#无重叠区间-2">示例 2</button></li><li class="tab"><button type="button" data-href="#无重叠区间-3">示例 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="无重叠区间-1"><p>输入：<code>[ [1,2], [2,3], [3,4], [1,3] ]</code></p><p>输出：<code>1</code></p><p>解释：移除 <code>[1,3]</code> 后，剩下的区间没有重叠。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="无重叠区间-2"><p>输入：<code>[ [1,2], [1,2], [1,2] ]</code></p><p>输出：<code>2</code></p><p>解释：你需要移除两个 <code>[1,2]</code> 来使剩下的区间没有重叠</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="无重叠区间-3"><p>输入：<code>[ [1,2], [2,3] ]</code></p><p>输出：<code>0</code></p><p>解释：你不需要移除任何区间，因为它们已经是无重叠的了。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>在选择要保留区间时，区间的结尾十分重要：选择的区间结尾越小，余留给其它区间的空间就越大，就越能保留更多的区间。因此，我们采取的贪心策略为，优先保留结尾小且不相交的区间。</p><p>具体实现方法为，先把区间按照结尾的大小进行增序排序，每次选择结尾最小且和前一个选择的区间不重叠的区间。我们这里使用 C++ 的 Lambda，结合 <code>std::sort()</code> 函数进行自定义排序。</p><p>在样例中，排序后的数组为 <code>[[1,2], [1,3], [2,4]]</code>。按照我们的贪心策略：</p><ol><li>首先初始化为区间<code>[1,2]</code>；</li><li>由于 <code>[1,3]</code> 与 <code>[1,2]</code> 相交，我们跳过该区间；</li><li>由于 <code>[2,4]</code> 与 <code>[1,2]</code> 不相交，我们将其保留。</li><li>因此最终保留的区间为 <code>[[1,2], [2,4]]</code>。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(vector &lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = intervals.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), [](vector&lt;<span class="keyword">int</span>&gt; a, vector&lt;<span class="keyword">int</span>&gt; b) &#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>, prev = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &lt; prev) &#123;</span><br><span class="line">                total++;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                prev = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector &lt;vector&lt;<span class="keyword">int</span>&gt;&gt; test = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">2</span>,<span class="number">4</span>&#125;,&#123;<span class="number">1</span>,<span class="number">3</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> result = Solution::<span class="built_in">eraseOverlapIntervals</span>(test);</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color="#33a3dc">复杂度分析</font></strong></p><p>时间复杂度：$O(n \log n)$，其中 $n$ 是区间的数量。我们需要 $O(n \log n)$ 的时间对所有的区间按照右端点进行升序排序，并且需要 $O(n)$ 的时间进行遍历。由于前者在渐进意义下大于后者，因此总时间复杂度为 $O(n \log n)$。</p><p>空间复杂度：$O(\log n)$，即为排序需要使用的栈空间。</p><h3 id="种花问题"><a class="header-anchor" href="#种花问题"></a>种花问题</h3><div class="tag link"><a class="link-card" title="605. 种花问题" href="https://leetcode-cn.com/problems/can-place-flowers/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/leetcodeicon.svg"/></div><div class="right"><p class="text">605. 种花问题</p><p class="url">https://leetcode-cn.com/problems/can-place-flowers/</p></div></a></div><br/><p>从一边开始遍历，当这个值为0且左右两边都为0时，将其变成1。最后将结果数组求和与原始值求和值相减即为最大满足值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">canPlaceFlowers</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;flowerbed, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当n为0时无论什么情况都为true</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> nums = flowerbed.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 在只有1个位置时，chu了n=0情况下，只有n为1且位置为空才为true</span></span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">1</span> &amp;&amp; flowerbed[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用于统计未加入花时的，花数目</span></span><br><span class="line">        <span class="keyword">int</span> before = <span class="built_in">accumulate</span>(flowerbed.<span class="built_in">begin</span>(), flowerbed.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将[0,0,...]情况下时变成[1,0,...]</span></span><br><span class="line">        <span class="keyword">if</span> (flowerbed[<span class="number">0</span>] == <span class="number">0</span> &amp;&amp; flowerbed[<span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            flowerbed[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将[...,0,0,0,...]情况变成[...,0,1,0,...]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; flowerbed.<span class="built_in">size</span>() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flowerbed[i] == <span class="number">0</span> &amp;&amp; flowerbed[i - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; flowerbed[i + <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                flowerbed[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将[...,0,0]情况变成[...,0,1]</span></span><br><span class="line">        <span class="keyword">if</span> (flowerbed[flowerbed.<span class="built_in">size</span>() - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; flowerbed[flowerbed.<span class="built_in">size</span>() - <span class="number">2</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            flowerbed[flowerbed.<span class="built_in">size</span>() - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//统计加入花后的所有花的数目</span></span><br><span class="line">        <span class="keyword">int</span> after = <span class="built_in">accumulate</span>(flowerbed.<span class="built_in">begin</span>(), flowerbed.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 当n小于,可以插入花的最大数目时返回true</span></span><br><span class="line">        <span class="keyword">if</span> ((after - before) &gt;= n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; test = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; test2 = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; test3 = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; test4 = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; test5 = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">bool</span> result = Solution::<span class="built_in">canPlaceFlowers</span>(test4, <span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color="#33a3dc">复杂度分析</font></strong></p>]]></content>
    
    
    <summary type="html">LeetCode刷题之贪心算法</summary>
    
    
    
    <category term="LeetCode" scheme="http://halo123.top/categories/LeetCode/"/>
    
    
    <category term="贪心算法" scheme="http://halo123.top/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="http://halo123.top/2021/05/13/DataStructure/H_Sort/"/>
    <id>http://halo123.top/2021/05/13/DataStructure/H_Sort/</id>
    <published>2021-05-13T00:35:51.000Z</published>
    <updated>2021-05-14T11:54:19.557Z</updated>
    
    <content type="html"><![CDATA[<h2 id="排序的基本概念"><a class="header-anchor" href="#排序的基本概念"></a>排序的基本概念</h2><h2 id="排序的定义"><a class="header-anchor" href="#排序的定义"></a>排序的定义</h2><p>排序，就是重新排列表中的元素，使表中的元素满足按关键字有序的过程。</p><p>算法的稳定性。若待排序表中有两个元素 $R_i$ 和 $R_j$ ，其对应的关键字相同即 $\mathrm{ key}_i= \mathrm{ key}_j$，且在排序前 $R_i$ 在 $R_j$ 的前面，若使用某一排序算法排序后，$R_i$ 仍然在 $R_j$ 的前面，则称这个排序算法是稳定的，否则称排序算法是不稳定的。需要注意的是，算法是否具有稳定性并不能衡量一个算法的优劣，它主要是对算法的性质进行描述。如果待排序表中的关键字不允许重复，则排序结果是唯一的，那么选择排序算法时的稳定与否就无关紧要。</p><p>注意：对于不稳定的排序算法，只需举出一组关键字的实例，说明它的不稳定性即可。</p><p>在排序过程中，根据数据元素是否完全在内存中，可将排序算法分为两类：</p><ol><li>内部排序，是指在排序期间元素全部存放在内存中的排序；</li><li>外部排序，是指在排序期间元素无法全部同时存放在内存中，必须在排序的过程中根据要求不断地在内、外存之间移动的排序。（除了关注算法时间和空间复杂度外，还要考虑如何使读写磁盘的次数更少）</li></ol><p>一般情况下，内部排序算法在执行过程中都要进行两种操作：比较和移动。通过比较两个关键字的大小，确定对应元素的前后关系，然后通过移动元素以达到有序。当然，并非所有的内部排序算法都要基于比较操作，事实上，基数排序就不基于比较。</p><p>每种排序算法都有各自的优缺点，适合在不同的环境下使用，就其全面性能而言，很难提出一种被认为是最好的算法。通常可以将排序算法分为插入排序、交换排序、选择排序、归并排序和基数排序五大类，后面几节会分别进行详细介绍。内部排序算法的性能取决于算法的时间复杂度和空间复杂度，而时间复杂度一般是由比较和移动的次数决定的。</p><h2 id="插入排序"><a class="header-anchor" href="#插入排序"></a>插入排序</h2><p>插入排序是一种简单直观的排序方法，其基本思想是每次将一个待排序的记录按其关键字大小插入到前面已排好序的子序列中，直到全部记录插入完成。由插入排序的思想可以引申出三个重要的排序算法：直接插入排序、折半插入排序和希尔排序。</p><h3 id="直接插入排序"><a class="header-anchor" href="#直接插入排序"></a>直接插入排序</h3><p>根据上面的插入排序思想，不难得出一种最简单也最直观的直接插入排序算法。假设在排序过程中，待排序表 <code>L[1...n]</code> 在某次排序过程中的某一时刻状态如下: 有序序列 <code>L[1...i-1]</code> ，<code>L(i)</code>，无序序列 <code>L[i+1...n]</code></p><p>要将元素 <code>L(i)</code> 插入到已有序的子序列 <code>L[1...i-1]</code> 中，需要执行以下操作（为避免混淆，下面用 <code>L[]</code> 表示一个表，而用<code>L()</code> 表示一个元素）：</p><ol><li>查找出 <code>L(i)</code> 在 <code>L[1...i-1]</code> 中的插入位置 <code>k</code>。</li><li>将 <code>L[k...i-1]</code> 中的所有元素依次后移一个位置。</li><li>将 <code>L(i)</code> 复制到 <code>L(k)</code>。</li></ol><p>为了实现对 <code>L[1...n]</code> 的排序，可以将 <code>L(2)</code>~<code>L (n)</code> 依次插入到前面已排好序的子序列中，初始 <code>L[1]</code> 可以视为是一个已排好序的子序列。上述操作执行 $n-1$ 次就能得到一个有序的表。插入排序在实现上通常采用就地排序（空间复杂度为 $O(n)$ ）， 因而在从后向前的比较过程中，需要反复把已排序元素逐步向后挪位，为新元素提供插入空间。</p><p>下面是直接插入排序的代码，其中再次用到了我们前面提到的“哨兵”（作用相同）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; i++) &#123;  <span class="comment">// 依次将A[2]~A[n]插入到前面已排序序列</span></span><br><span class="line">        <span class="keyword">if</span> (A[i] &lt; A[i - <span class="number">1</span>]) &#123;  <span class="comment">// 若A[i]关键码小于其前驱，将A[i]插入有序表</span></span><br><span class="line">            A[<span class="number">0</span>] = A[i];  <span class="comment">// 复制为哨兵，A[0]不存放元素</span></span><br><span class="line">            <span class="keyword">for</span> (j = i - <span class="number">1</span>; A[<span class="number">0</span>] &lt; A[j]; --j)  <span class="comment">// 从后往前查找待插入位置</span></span><br><span class="line">                A[j + <span class="number">1</span>] = A[j];               <span class="comment">// 向后挪位</span></span><br><span class="line">            A[j + <span class="number">1</span>] = A[<span class="number">0</span>];                   <span class="comment">// 复制到插入位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接插入排序算法的性能分析如下：</p><p>空间效率：仅使用了常数个辅助单元，因而空间复杂度为 $O(1)$ 。</p><p>时间效率：在排序过程中，向有序子表中逐个地插入元素的操作进行了 $n-1$ 趟，每趟操作都分为比较关键字和移动元素，而比较次数和移动次数取决于待排序表的初始状态。</p><p>在最好情况下，表中元素已经有序，此时每插入一个元素，都只需比较一次而不用移动元素，因而时间复杂度为 $O(n)$。</p><p>在最坏情况下，表中元素顺序刚好与排序结果中的元素顺序相反（逆序），总的比较次数达到最大，为 $\sum_{i=2}^{n}i$ ，总的移动次数也达到最大，为 $\sum_{i=2}^{n}(i+1)$ 。</p><p>平均情况下，考虑待排序表中元素是随机的，此时可以取上述最好与最坏情况的平均值作为平均情况下的时间复杂度，总的比较次数与总的移动次数均约为 $\frac{n^2}{4}$ 。</p><p>因此，直接插入排序算法的时间复杂度为 $O(n^2)$。</p><p>稳定性：由于每次插入元素时总是从后向前先比较再移动，所以不会出现相同元素相对位置发生变化的情况，即直接插入排序是一个稳定的排序方法。</p><p>适用性：直接插入排序算法适用于顺序存储和链式存储的线性表。为链式存储时，可以从前往后查找指定元素的位置。</p><p>注意：大部分排序算法都仅适用于顺序存储的线性表。</p><h3 id="折半插入排序"><a class="header-anchor" href="#折半插入排序"></a>折半插入排序</h3><p>从直接插入排序算法中，不难看出每趟插入的过程中都进行了两项工作：</p><ol><li>从前面的有序子表中查找出待插入元素应该被插入的位置；</li><li>给插入位置腾出空间，将待插入元素复制到表中的插入位置。</li></ol><p>注意到在该算法中，总是边比较边移动元素。下面将比较和移动操作分离，即先折半查找出元素的待插入位置，然后统一地移动待插入位置之后的所有元素。当排序表为顺序表时，可以对直接插入排序算法做如下改进：由于是顺序存储的线性表，所以查找有序子表时可以用折半查找来实现。确定待插入位置后，就可统一地向后移动元素。算法代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, low, high, mid;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; i++) &#123;  <span class="comment">// 依次将A[2]~A[n]插入前面的已排序序列</span></span><br><span class="line">        A[<span class="number">0</span>] = A[i];            <span class="comment">// 将A[i]暂存到A[0]</span></span><br><span class="line">        low = <span class="number">1</span>;                <span class="comment">// 设置折半查找的范围</span></span><br><span class="line">        high = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;        <span class="comment">// 折半查找(默认递增有序)</span></span><br><span class="line">            mid = (low + high) / <span class="number">2</span>;  <span class="comment">// 取中间点</span></span><br><span class="line">            <span class="keyword">if</span> (A[mid] &gt; A[<span class="number">0</span>]) &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;  <span class="comment">// 查找左半子表</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;  <span class="comment">// 查找右半子表，保证算法稳定性</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= high + <span class="number">1</span>; --j) &#123;</span><br><span class="line">            A[j + <span class="number">1</span>] = A[j];  <span class="comment">// 统一后移元素，空出插入位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        A[high + <span class="number">1</span>] = A[<span class="number">0</span>];  <span class="comment">// 插入操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述算法中，不难看出折半插入排序仅减少了比较元素的次数，约为 $O(n\log_{2}{n})$ ，该比较次数与待排序表的初始状态无关，仅取决于表中的元素个数 $n$ ；而元素的移动次数并未改变，它依赖于待排序表的初始状态。因此，折半插入排序的时间复杂度仍为 $O(n^2)$，但对于数据量不很大的排序表，折半插入排序往往能表现出很好的性能。折半插入排序是一种稳定的排序方法。</p><h3 id="希尔排序"><a class="header-anchor" href="#希尔排序"></a>希尔排序</h3><p>从前面的分析可知，直接插入排序算法的时间复杂度为 $O(n^2)$ ，但若待排序列为“正序”时，其时间复杂度可提高至 $O(n)$，由此可见它更适用于基本有序的排序表和数据量不大的排序表。希尔排序正是基于这两点分析对直接插入排序进行改进而得来的，又称缩小增量排序。</p><p>希尔排序的基本思想是：先将待排序表分割成若干形如 <code>L[i,i+d,i+2d,...,i+kd]</code> 的“特殊”子表，即把相隔某个“增量”的记录组成一个子表，对各个子表分别进行直接插入排序，当整个表中的元素已呈“基本有序”时，再对全体记录进行一次直接插入排序。</p><p>希尔排序的过程如下：先取一个小于 $n$ 的步长 $d_i$ ，把表中的全部记录分成 $d_1$ 组，所有距离为 $d$ 的倍数的记录放在同一组， 在各组内进行直接插入排序；然后取第二个步长 $d_2&lt;d_1$，重复上述过程，直到所取到的 $d_t = 1$，即所有记录已放在同一组中，再进行直接插入排序，由于此时已经具有较好的局部有序性，故可以很快得到最终结果。到目前为止，尚未求得一个最好的增量序列，希尔提出的方法是 $d_1=\frac{n}{2},\ d_{i+1}=\left \lfloor  \frac{d_i}{2} \right \rfloor$，并且最后一个增量等于 1。</p><p>希尔排序算法的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d, i, j;</span><br><span class="line">    <span class="comment">// A[0]只是暂存单元，不是哨兵</span></span><br><span class="line">    <span class="keyword">for</span> (d = n / <span class="number">2</span>; d &gt; <span class="number">1</span>; d = d / <span class="number">2</span>) &#123;  <span class="comment">// 步长变化</span></span><br><span class="line">        <span class="keyword">for</span> (i = d + <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] &lt; A[i - d]) &#123;  <span class="comment">// 需将A[i]插入有序增量子表</span></span><br><span class="line">                A[<span class="number">0</span>] = A[i];        <span class="comment">// 暂存在 A[0]</span></span><br><span class="line">                <span class="keyword">for</span> (j = i - d; j &gt; <span class="number">0</span> &amp;&amp; A[<span class="number">0</span>] &lt; A[j]; j -= d) &#123;</span><br><span class="line">                    A[j + d] = A[j];  <span class="comment">// 记录后移，查找插入的位置</span></span><br><span class="line">                &#125;</span><br><span class="line">                A[j + d] = A[<span class="number">0</span>];  <span class="comment">// 插入</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>希尔排序算法的性能分析如下：</p><p>空间效率：仅使用了常数个辅助单元，因而空间复杂度为 $O(1)$。</p><p>时间效率：由于希尔排序的时间复杂度依赖于增量序列的函数，这涉及数学上尚未解决的难题，所以其时间复杂度分析比较困难。当 $n$ 在某个特定范围时，希尔排序的时间复杂度约为 $O(n^{1.3})$。在最坏情况下希尔排序的时间复杂度为 $O(n^2)$。</p><p>稳定性：当相同关键字的记录被划分到不同的子表时，可能会改变它们之间的相对次序，因此希尔排序是一种不稳定的排序方法。</p><p>适用性：希尔排序算法仅适用于线性表为顺序存储的情况。</p><h2 id="交换排序"><a class="header-anchor" href="#交换排序"></a>交换排序</h2><h3 id="冒泡排序"><a class="header-anchor" href="#冒泡排序"></a>冒泡排序</h3><p>冒泡排序的基本思想是：从后往前（或从前往后）两两比较相邻元素的值，若为逆序（即 <code>A[i-1] &gt; A[i]</code>），则交换它们，直到序列比较完。我们称它为第一趟冒泡，结果是将最小的元素交换到待排序列的第一个位置（或将最大的元素交换到待排序列的最后一个位置），关键字最小的元素如气泡一般逐渐往上“漂浮”直至“水面”（或关键字最大的元素如石头一般下沉至水底）。下一趟冒泡时，前一趟确定的最小元素不再参与比较，每趟冒泡的结果是把序列中的最小元素（或最大元素）放到了序列的最终位置……这样最多做 $n-1$ 趟冒泡就能把所有元素排好序。</p><p>冒泡排序算法的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;  <span class="comment">// 表示本轮冒泡是否发生了交换的标志</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[j - <span class="number">1</span>] &gt; A[j]) &#123;</span><br><span class="line">                temp = A[j - <span class="number">1</span>];  <span class="comment">// 交换</span></span><br><span class="line">                A[j - <span class="number">1</span>] = A[j];</span><br><span class="line">                A[j] = temp;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;  <span class="comment">// 本次遍历后没有发生交换，说明表已经有序</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>冒泡排序的性能分析如下：</p><p>空间效率：仅使用了常数个辅助单元，因而空间复杂度为 $O(1)$ 。</p><p>时间效率：当初始序列有序时，显然第一趟冒泡后 <code>flag</code> 依然为 <code>false</code> （本趟冒泡没有元素交换），从而直接跳出循环，比较次数为$n- 1$ ，移动次数为 0，从而最好情况下的时间复杂度为 $O(n)$ ；当初始序列为逆序时，需要进行 $n- 1$ 趟排序，第 $i$ 趟排序要进行 $n -i$ 次关键字的比较，而且每次比较后都必须移动元素 3 次来交换元素位置。这种情况下，比较次数= $\frac{n(n-1)}{2}$ ，移动次数 = $\frac{3n(n-1)}{2}$ 从而，最坏情况下的时间复杂度为 $O(n^2)$ ，其平均时间复杂度也为 $O(n^2)$ 。</p><p>稳定性：由于 <code>i&gt;j</code> 且 <code>A[i]=A[j]</code> 时，不会发生交换，因此冒泡排序是一种 稳定的排序方法。</p><p>注意：冒泡排序中所产生的有序子序列一定是全局有序的（不同于直接插入排序），也就是说，有序子序列中的所有元素的关键字一定小于或大于无序子序列中所有元素的关键字，这样每趟排序都会将一个元素放置到其最终的位置上。</p><h3 id="快速排序"><a class="header-anchor" href="#快速排序"></a>快速排序</h3><p>快速排序的基本思想是基于分治法的：在待排序表 <code>L[1..n]</code> 中任取一个元素 <code>pivot</code> 作为枢轴（或基准，通常取首元素），通过一趟排序将待排序表划分为独立的两部分 <code>L[1...&lt;k-1]</code> 和 <code>L[k+1...n]</code>，使得 <code>L[1...k-1]</code> 中的所有元素小于 <code>pivot</code> ， <code>L[k+1...n]</code> 中的所有元素大于等于 <code>pivot</code> ，则 <code>pivot</code> 放在了其最终位置 <code>L(k)</code> 上，这个过程称为一趟快速排序（或一次划分）。然后分别递归地对两个子表重复上述过程，直至每部分内只有一个元素或空为止，即所有元素放在了其最终位置上。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;  <span class="comment">//递归跳出的条件</span></span><br><span class="line">        <span class="keyword">int</span> pivotpos = Partition(A, low, high);</span><br><span class="line">        QuickSort(A, low, pivotpos - <span class="number">1</span>);   <span class="comment">// 划分左子表</span></span><br><span class="line">        QuickSort(A, pivotpos + <span class="number">1</span>, high);  <span class="comment">// 划分右子表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用第一个元素将待排序序列划分成左右两个部分</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = A[low];  <span class="comment">// 第一个元素作为枢轴</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; A[high] &gt; pivot) &#123;</span><br><span class="line">            --high;</span><br><span class="line">        &#125;</span><br><span class="line">        A[low] = A[high];  <span class="comment">// 比枢轴小的元素移动到左端</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; A[low] &lt;= pivot) &#123;</span><br><span class="line">            ++low;</span><br><span class="line">        &#125;</span><br><span class="line">        A[high] = A[low];  <span class="comment">// 比枢轴大的元素移动到右端</span></span><br><span class="line">    &#125;</span><br><span class="line">    A[low] = pivot;  <span class="comment">// 枢轴元素存放到的最终位置</span></span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>快速排序算法的性能分析如下：</p><p>空间效率：由于快速排序是递归的，需要借助一个递归工作栈来保存每层递归调用的必要信息，其容量应与递归调用的最大深度一致。 最好情况下为 $O(\log_{2}{n})$ ；最坏情况下，因为要进行 $n-1$ 次递归调用，所以栈的深度为 $O(n)$ ；平均情况下，栈的深度为 $O(\log_{2}{n})$。</p><p>时间效率：快速排序的运行时间与划分是否对称有关，快速排序的最坏情况发生在两个区域分别包含 $n-1$ 个元素和 0 个元素时，这种最大程度的不对称性若发生在每层递归上，即对应于初始排序表基本有序或基本逆序时，就得到最坏情况下的时间复杂度为 $O(n^2)$。</p><p>有很多方法可以提高算法的效率：一种方法是尽量选取一个可以将数据中分的枢轴元素，如从序列的头尾及中间选取三个元素，再取这三个元素的中间值作为最终的枢轴元素；或者随机地从当前表中选取枢轴元素，这样做可使得最坏情况在实际排序中几乎不会发生。</p><p>在最理想的状态下，即 <code>Partition()</code> 可能做到最平衡的划分，得到的两个子问题的大小都不可能大于 $\frac{n}{2}$ ，在这种情况下，快速排序的运行速度将大大提升，此时，时间复杂度为 $O(n\log_{2}{n})$ 。 好在快速排序平均情况下的运行时间与其最佳情况下的运行时间很接近，而不是接近其最坏情况下的运行时间。快速排序是所有内部排序算法中平均性能最优的排序算法。</p><p>稳定性：在划分算法中，若右端区间有两个关键字相同，且均小于基准值的记录，则在交换到左端区间后，它们的相对位置会发生变化，即快速排序是一种不稳定的排序方法。</p><p>注意：在快速排序算法中，并不产生有序子序列，但每趟排序后会将枢轴（基准）元素放到其最终的位置上。</p><h2 id="选择排序"><a class="header-anchor" href="#选择排序"></a>选择排序</h2><p>选择排序的基本思想是：每一趟（如第 $i$ 趟）在后面 $n-i+1 \ (i=1,2,\cdots ,n-1)$ 个待排序元素中选取关键字最小的元素，作为有序子序列的第 $i$ 个元素，直到第 $n-1$ 趟做完，待排序元素只剩下 1 个，就不用再选了。</p><h3 id="简单选择排序"><a class="header-anchor" href="#简单选择排序"></a>简单选择排序</h3><p>根据上面选择排序的思想，可以很直观地得出简单选择排序算法的思想：假设排序表为 $L[1…n]$ ，第 $i$ 趟排序即从 $L[i…n]$ 中选择关键字最小的元素与 $L(i)$ 交换，每一趟排序可以确定一个元素的最终位置，这样经过 $n-1$ 趟排序就可使得整个排序表有序。简单选择排序算法的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;    <span class="comment">// 一共进行n-1趟</span></span><br><span class="line">        <span class="keyword">int</span> min = i;                     <span class="comment">// 记录最小元素位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)  <span class="comment">// 在A[i...n-1]中选择最小的元素</span></span><br><span class="line">            <span class="keyword">if</span> (A[j] &lt; A[min]) min = j;  <span class="comment">// 更新最小元素位置</span></span><br><span class="line">        <span class="keyword">if</span> (min != i) swap(A[i], A[min]);  <span class="comment">//封装的 swap() 函数共移动元素3次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单选择排序算法的性能分析如下：</p><p>空间效率：仅使用常数个辅助单元，故空间效率为 $O(1)$。</p><p>时间效率：从上述伪码中不难看出，在简单选择排序过程中，元素移动的操作次数很少，不会超过 $3(n- 1)$ 次，最好的情况是移动 0 次，此时对应的表已经有序；但元素间比较的次数与序列的初始状态无关，始终是 $\frac{n(n- 1)}{2}$ 次，因此时间复杂度始终是 $O(n^2)$ 。</p><p>稳定性：在第 $i$ 趟找到最小元素后，和第 $i$ 个元素交换，可能会导致第 $i$ 个元素与其含有相同关键字元素的相对位置发生改变。因此，简单选择排序是一种不稳定的排序方法。</p><h3 id="堆排序"><a class="header-anchor" href="#堆排序"></a>堆排序</h3><p>堆的定义如下，$n$ 个关键字序列 <code>L[1..n]</code> 称为堆，当且仅当该序列满足：</p><ol><li><code>L(i)&gt;=L(2i)</code> 且 <code>L(i)&gt;=L(2i+1)</code> 或</li><li><code>L(i)&lt;=L(2i)</code> 且 <code>L(i)&lt;=L(2i+1)</code> （$1\le i \le \left \lfloor \frac{n}{2} \right \rfloor $）</li></ol><p>可以将该一维数组视为一棵完全二叉树，</p><ul><li>满足条件 1 的堆称为大根堆（大顶堆），大根堆的<font color="#faa755">最大元素存放在根结点</font>，且其任一非根结点的值小于等于其双亲结点值。</li><li>满足条件 2 的堆称为小根堆（小顶堆），小根堆的定义刚好相反，<font color="#faa755">根结点是最小元素</font>。</li></ul><p>堆排序的思路很简单：首先将存放在 <code>L[1...n]</code> 中的 $n$ 个元素建成初始堆，由于堆本身的特点（以大顶堆为例），堆顶元素就是最大值。输出堆顶元素后，通常将堆底元素送入堆顶，此时根结点已不满足大顶堆的性质，堆被破坏，将堆顶元素向下调整使其继续保持大顶堆的性质，再输出堆顶元素。如此重复，直到堆中仅剩一个元素为止。可见堆排序需要解决两个问题：</p><ol><li>如何将无序序列构造成初始堆</li><li>输出堆顶元素后，如何将剩余元素调整成新的堆</li></ol><p>堆排序的关键是构造初始堆。$n$ 个结点的完全二叉树，最后一个结点是第 $\left \lfloor \frac{n}{2} \right \rfloor$  个结点的孩子。对第  $\left \lfloor \frac{n}{2} \right \rfloor$   个结点为根的子树筛选（对于大根堆，若根结点的关键字小于左右孩子中关键字较大者，则交换），使该子树成为堆。之后向前依次对各结点（ $\left \lfloor \frac{n}{2} \right \rfloor -1 \sim  1$） 为根的子树进行筛选，看该结点值是否大于其左右子结点的值，若不大于，则将左右子结点中的较大值与之交换，交换后可能会破坏下一级的堆，于是继续采用上述方法构造下一级的堆，直到以该结点为根的子树构成堆为止。反复利用上述调整堆的方法建堆，直到根结点。</p><p>下面是建立大根堆算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建立大根堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildMaxHeap</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len / <span class="number">2</span>; i &gt; <span class="number">0</span>; i--) &#123;  <span class="comment">// 从后往前调整所有的非终端结点</span></span><br><span class="line">        HeadAdjust(A, i, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将以 k 为根的子树调整为大根堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeadAdjust</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> k, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    A[<span class="number">0</span>] = A[k];                             <span class="comment">// A[0] 暂存子树的根节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> * k; i &lt;= len; i *= <span class="number">2</span>) &#123;  <span class="comment">// 沿 key 较大的子结点向下筛选</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; len &amp;&amp; A[i] &lt; A[i + <span class="number">1</span>]) &#123; <span class="comment">// i &lt; len 保证有右兄弟</span></span><br><span class="line">            i++;  <span class="comment">// 取 key 较大的子结点的下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (A[<span class="number">0</span>] &gt;= A[i]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// 筛选结束</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            A[k] = A[i];  <span class="comment">// 将 A[i] 调整到双亲结点上</span></span><br><span class="line">            k = i;        <span class="comment">// 修改 k 值，以便继续向下筛选</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A[k] = A[<span class="number">0</span>];  <span class="comment">// 被筛选结点的值放入最终位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是堆排序算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    BuildMaxHeap(A, len);  <span class="comment">// 初始建堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &gt; <span class="number">1</span>; i--) &#123;</span><br><span class="line">        Swap(A[i], A[<span class="number">1</span>]);  <span class="comment">// 输出堆顶元素（和堆底元素交换）</span></span><br><span class="line">        HeadAdjust(A, <span class="number">1</span>, i - <span class="number">1</span>);  <span class="comment">// 调整，把剩余的 i-1 个元素整理成堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>堆排序适合关键字较多的情况（如 $n&gt;1000$ ）。例如，在 1 亿个数中选出前 100 个最大值。首先使用一个大小为 100 的数组，读入前 100 个数，建立小顶堆，而后依次读入余下的数，若小于堆顶则舍弃，否则用该数取代堆顶并重新调整堆，待数据读取完毕，堆中 100 个数即为所求。</p><p>堆排序算法的性能分析如下：</p><p>空间效率：仅使用了常数个辅助单元，所以空间复杂度为 $O(1)$。</p><p>时间效率：建堆时间为 $O(n)$ 【<a href="https://www.bilibili.com/video/BV1b7411N798?p=83&amp;t=1290">推导过程</a>】，之后有 $n- 1$ 次向下调整操作，每次调整的时间复杂度为 $O(h)$，故在最好、最坏和平均情况下，堆排序的时间复杂度为 $O(n \log_{2}{n})$。</p><p>稳定性：进行筛选时，有可能把后面相同关键字的元素调整到前面，所以堆排序算法是一种不稳定的排序方法。</p><p>堆的插入：新元素放到表尾（堆底），根据大/小根堆的要求，新元素不断“上升”，直到无法继续上升为止。每次“上升”调整只需对比关键字 1 次。</p><p>堆的删除：被删除元素用表尾（堆底）元素代替，根据大/小根堆的要求，替代元素不断“下坠”，知道无法继续下坠为止。每次“下坠”调整可能需要对比关键字 2 次，也可能只需对比 1 次。</p><h2 id="归并排序和基数排序"><a class="header-anchor" href="#归并排序和基数排序"></a>归并排序和基数排序</h2><h3 id="归并排序"><a class="header-anchor" href="#归并排序"></a>归并排序</h3><p>归并排序与上述基于交换、选择等排序的思想不一样，“归并”的含义是将两个或两个以上的有序表组合成一个新的有序表。假定待排序表含有 $n$ 个记录，则可将其视为 $n$ 个有序的子表，每个子表的长度为 1 ，然后两两归并，得到 $\left \lceil \frac{n}{2}  \right \rceil $ 个长度为 2 或 1 的有序表；继续两两归并如此重复，直到合并成一个长度为 $n$ 的有序表为止，这种排序方法称为 2 路归并排序。</p><p>$m$ 路归并，每选出一个元素需要对比关键字 $m-1$ 次</p><p><code>Merge()</code> 的功能是将前后相邻的两个有序表归并为一个有序表。设两段有序表 <code>A[low..mid]</code>、<code>A[mid+1...high]</code> 存放在同一顺序表中的相邻位置，先将它们复制到辅助数组 <code>B</code> 中。每次从对应 <code>B</code> 中的两个段取出一个记录进行关键字的比较，将较小者放入 <code>A</code> 中，当数组 <code>B</code> 中有一段的下标超出其对应的表长（即该段的所有元素都已复制到 <code>A</code> 中）时，将另一段中的剩余部分直接复制到 <code>A</code> 中。算法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n = A.length;</span><br><span class="line"><span class="keyword">int</span> *B = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));  <span class="comment">// 辅助数组B</span></span><br><span class="line"><span class="comment">// A[low..mid]和A[mid+1...high]各自有序，将两个部分归并</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">for</span> (k = low; k &lt;= high; k++) &#123;</span><br><span class="line">        B[k] = A[k];  <span class="comment">// 将 A 中所有元素复制到 B 中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = low, j = mid + <span class="number">1</span>, k = i; i &lt; mid &amp;&amp; j &lt;= high; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (B[i] &lt;= B[j]) &#123;</span><br><span class="line">            A[k] = B[i++];  <span class="comment">// 将较小值复制到 A 中</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            A[k] = B[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123;  <span class="comment">// 处理剩余大值元素</span></span><br><span class="line">        A[k++] = B[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= high) &#123;</span><br><span class="line">        A[k++] = B[j++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：上面的代码中，最后两个 <code>while</code> 循环只有一个会执行。</p><p>一趟归并排序的操作是，调用 $\left \lceil \frac{n}{2h}  \right \rceil $ 次算法 <code>merge()</code>，将 <code>L[1...n]</code> 中前后相邻且长度为 $h$ 的有序段进行两两归并，得到前后相邻、长度为 $2h$ 的有序段，整个归并排序需要进行 $\left \lceil \log_{2}{n}  \right \rceil $ 趟。</p><p>递归形式的 2 路归并排序算法是基于分治的，其过程如下。</p><p>分解：将含有 $n$ 个元素的待排序表分成各含 $\frac{n}{2}$ 个元素的子表，采用 2 路归并排序算法对两个子表递归地进行排序。</p><p>合并：合并两个已排序的子表得到排序结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;   <span class="comment">// 从中间划分</span></span><br><span class="line">        MergeSort(A, low, mid);       <span class="comment">// 对左半部分归并排序</span></span><br><span class="line">        MergeSort(A, mid + <span class="number">1</span>, high);  <span class="comment">// 对右半部分归并排序</span></span><br><span class="line">        Merge(A, low, mid, high);     <span class="comment">// 归并</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 路归并排序算法的性能分析如下：</p><p>空间效率：<code>Merge()</code> 操作中，辅助空间刚好为 $n$ 个单元，所以算法的空间复杂度为 $O(n)$ 。</p><p>时间效率：每趟归并的时间复杂度为 $O(n)$，共需进行 $\left \lceil \log_{2}{n}  \right \rceil $ 趟归并，所以算法的时间复杂度为 $O(n \log_{2}{n})$。</p><p>稳定性：由于 <code>Merge()</code> 操作不会改变相同关键字记录的相对次序，所以 2 路归并排序算法是一种稳定的排序方法。</p><p>注意：一般而言，对于 $N$ 个元素进行 $k$ 路归并排序时，排序的趟数 $m$ 满足 $K^m=N$，从而 $m=\log_{k}{N}$，又考虑到 $m$ 为整数，所以 $m=\left \lceil \log_{k}{N}  \right \rceil$ 。这和前面的 2 路归并是一致的。</p><h3 id="基数排序"><a class="header-anchor" href="#基数排序"></a>基数排序</h3><p>基数排序是一种很特别的排序方法，它不基于比较和移动进行排序，而基于关键字各位的大小进行排序。基数排序是一种借助多关键字排序的思想对单逻辑关键字进行排序的方法。</p><p>假设长度为 $n$ 的线性表中每个结点 $a_j$ 的关键字由 $d$ 元组（$k_{j}^{d-1} , k_{j}^{d-2} , \cdots , k_{j}^{1} , k_{j}^{0}$）组成，满足 $0 \le k_{j}^{i} \le r-1 \ (0\le j &lt;n , 0 \le i \le d-1) $。其中 $k_{j}^{d-1}$ 为主位关键字，$k_{j}^{0}$ 为最次位关键字。</p><p>为实现多关键字排序，通常有两种方法：</p><ol><li>最高位优先（MSD）法，按关键字位<font color="#faa755">权重递减</font>依次逐层划分成若干更小的子序列，最后将所有子序列依次连接成一个有序序列。</li><li>最低位优先（LSD）法，按关键字<font color="#faa755">权重递增</font>依次进行排序，最后形成一个有序序列。</li></ol><p>下面描述以 $r$ 为基数的最低位优先基数排序的过程，在排序过程中，使用 $r$ 个队列 $Q_0 , Q_1 , \cdots ,Q_{r-1}$ 。基数排序的过程如下：对 $i=0 , 1 , \cdots , d-1$ ，依次做一次 “分配”和“收集”（其实是一次稳定的排序过程）。</p><ol><li>分配：开始时，把 $Q_0 , Q_1 , \cdots , Q_{r-1}$ 各个队列置成空队列，然后依次考察线性表中的每个结点 $a_j \ (j=0 , 1 , \cdots , n-1)$ ，若 $a_j$ 的关键字 $k_{j}^{i} = k$，就把 $a_j$ 放进 $Q_k$ 队列中。</li><li>收集：把 $Q_0 , Q_1 , \cdots , Q_{r-1}$ 各个队列中的结点依次首尾相接，得到新的结点序列，从而组成新的线性表。</li></ol><p>基数排序<strong>算法的性能</strong>分析如下：</p><p>空间效率：趟排序需要的辅助存储空间为 $r$ （ $r$ 个队列：$r$ 个队头指针和r个队尾指针），但以后的排序中会重复使用这些队列，所以基数排序的空间复杂度为 $O®$。</p><p>时间效率：基数排序需要进行 $d$ 趟分配和收集，一趟分配需要 $O(n)$，一趟收集需要 $O®$ ，所以基数排序的时间复杂度为 $O(d(n+ r))$ ，它与序列的初始状态无关。</p><p>稳定性：对于基数排序算法而言，很重要一点就是按位排序时必须是稳定的。因此，这也保证了基数排序的稳定性。</p><p>基数排序<strong>擅长解决的问题</strong>：</p><ol><li>数据元素的关键字可以方便地拆分为 $d$ 组，且 $d$ 较小</li><li>每组关键字的取值范围不大，即 $r$ 较小</li><li>数据元素个数 $n$ 较大</li></ol><h2 id="外部排序"><a class="header-anchor" href="#外部排序"></a>外部排序</h2><h3 id="外部排序的基本概念"><a class="header-anchor" href="#外部排序的基本概念"></a>外部排序的基本概念</h3><p>在许多应用中，经常需要对大文件进行排序，因为文件中的记录很多、信息量庞大，无法将整个文件复制进内存中进行排序。因此，需要将待排序的记录存储在外存上，排序时再把数据一部分一部分地调入内存进行排序，在排序过程中需要多次进行内存和外存之间的交换。这种排序方法就称为<font color="#ea66a6">外部排序</font>。</p><h3 id="外部排序的方法"><a class="header-anchor" href="#外部排序的方法"></a>外部排序的方法</h3><p>文件通常是按块存储在磁盘上的，操作系统也是按块对磁盘上的信息进行读写的。因为磁盘读/写的机械动作所需的时间远远超过内存运算的时间（相比而言可以忽略不计），因此在外部排序过程中的时间代价主要考虑访问磁盘的次数，即 I/O 次数。<br>外部排序通常采用归并排序法。它包括两个相对独立的阶段：</p><ol><li>根据内存缓冲区大小，将外存上的文件分成若干长度为 $l$ 的子文件，依次读入内存并利用内部排序方法对它们进行排序，<br>并将排序后得到的有序子文件重新写回外存，称这些有序子文件为<font color="#ea66a6">归并段</font>或<font color="#ea66a6">顺串</font></li><li>对这些归并段进行逐趟归并，使归并段（有序子文件）逐渐由小到大，直至得到整个有序文件为止。</li></ol><p>一般地，对 $r$ 个初始归并段，做 $k$ 路平衡归并：</p><ol><li>最多只能有 $k$ 个段归并为一个；</li><li>每一趟归并中，若有 $m$ 个归并段参与归并，则经过这一趟处理得到  $\left \lceil \frac{m}{k} \right \rceil $ 个新的归并段。</li></ol><p>第一趟可将 $r$ 个初始归并段归并为 $\left \lceil \frac{r}{k} \right \rceil $ 个归并段，以后每趟归并将 $m$ 个归并段归并成 $\left \lceil \frac{m}{k} \right \rceil $ 个归并段，直至最后形成一个大的归并段为止。树的高度 $=\left \lceil \log_{k}{r} \right \rceil = $ 归并趟数 $S$ 。可见，只要增大归并路数 $k$ ，或减少初始归并段个数 $r$ ，都能减少归并趟数 $S$，进而减少读写磁盘的次数，达到提高外部排序速度的目的。</p><p>多路归并带来的<strong>负面影响</strong>：</p><ol><li>$k$ 路归并时，需要开辟 $k$ 个输入缓冲区，内存开销增加</li><li>每挑选一个关键字需要对比关键字 $k-1$ 次，内部归并所需时间增加</li></ol><h3 id="多路平衡归并与败者树"><a class="header-anchor" href="#多路平衡归并与败者树"></a>多路平衡归并与败者树</h3><p>增加归并路数 $k$ 能减少归并趟数 $S$，进而减少 I/O 次数。然而，增加归并路数 $k$ 时，内部归并的时间将增加。做内部归并时，在 $k$ 个元素中选择关键字最小的记录需要比较 $k-1$ 次。每趟归并 $n$ 个元素需要做 $(n- 1)(k- 1)$ 次比较，$S$ 趟归并总共需要的比较次数为 $$S(n-1)(k-1)=\left \lceil \log_{k}{r} \right \rceil (n-1)(k-1)=\frac{\left \lceil \log_{2}{r} \right \rceil(n-1)(k-1)}{\left \lceil \log_{2}{k} \right \rceil}$$式中，$\frac{k-1}{\left \lceil \log_{2}{k} \right \rceil}$ 随 $k$ 增长而增长，因此内部归并时间亦随 $k$ 的增长而增长。这将抵消由于增大 $k$ 而减少外存访问次数所得到的效益。因此，不能使用普通的内部归并算法。</p><p>为了使内部归并不受 $k$ 的增大的影响，引入了败者树。败者树是树形选择排序的一种变体，可视为一棵完全二叉树。$k$ 个叶结点分别存放 $k$ 个归并段在归并过程中当前参加比较的记录，内部结点用来记忆左右子树中的“失败者”，而让胜者往上继续进行比较，一直到根结点。若比较两个数，大的为失败者、小的为胜利者，则根结点指向的数为最小数。</p><p>因为 $k$ 路归并的败者树深度为 $\left \lceil \log_{2}{k} \right \rceil$， 因此 $k$ 个记录中选择最小关键字，最多需要 $\left \lceil \log_{2}{k} \right \rceil$ 次比较。所以总的比较次数为：$$S(n-1)\left \lceil \log_{2}{k} \right \rceil=\left \lceil \log_{k}{r} \right \rceil (n-1)\left \lceil \log_{2}{k} \right \rceil =(n-1)\left \lceil \log_{2}{r} \right \rceil$$可见，使用败者树后，内部归并的比较次数与 $k$ 无关了。因此，只要内存空间允许，增大归并路数 $k$ 将有效地减少归并树的高度，从而减少 I/O 次数，提高外部排序的速度。</p><p>值得说明的是，归并路数 $k$ 并不是越大越好。归并路数 $k$ 增大时，相应地需要增加输入缓冲区的个数。若可供使用的内存空间不变，势必要减少每个输入缓冲区的容量，使得内存、外存交换数据的次数增大。当 $k$ 值过大时，虽然归并趟数会减少，但读写外存的次数仍会增加。</p><h3 id="置换－选择排序（生成初始归并段）"><a class="header-anchor" href="#置换－选择排序（生成初始归并段）"></a>置换－选择排序（生成初始归并段）</h3><p>减少初始归并段个数 $r$ 也可以减少归并趟数 $S$ 。若总的记录个数为 $n$ ，每个归并段的长度为 $l$ ，则归并段的个数 $r=\left \lceil \frac{n}{l} \right \rceil $。采用内部排序方法得到的各个初始归并段长度都相同（除最后一段外），它依赖于内部排序时可用内存工作区的大小。因此，必须探索新的方法，用来产生更长的初始归并段。</p><p>设初始待排文件为 FI，初始归并段输出文件为 FO，内存工作区为 WA，FO 和 WA 的初始状态为空，WA 可容纳 $w$ 个记录。置换-选择算法的步骤如下:</p><ol><li>从 FI 输入 $w$ 个记录到工作区 WA。</li><li>从 WA 中选出其中关键字取最小值的记录，记为 MINIMAX 记录。</li><li>将 MINIMAX 记录输出到 FO 中去。</li><li>若 FI 不空，则从 FI 输入下一个记录到 WA 中。</li><li>从 WA 中所有关键字比 MINIMAX 记录的关键字大的记录中选出最小关键字记录，作为新的 MINIMAX 记录。</li><li>重复 3~5，直至在 WA 中选不出新的 MINIMAX 记录为止，由此得到一个初始归并段，输出一个归并段的结束标志到 FO 中去。</li><li>重复 2~6，直至 WA 为空。由此得到全部初始归并段。</li></ol><p>上述算法，在 WA 选择 MINIMAX 记录的过程需利用败者树来实现</p><h3 id="最佳归并树"><a class="header-anchor" href="#最佳归并树"></a>最佳归并树</h3><p>归并过程中的磁盘 I/O 次数 = 归并树的 WPL * 2</p><p>要让磁盘 I/O 次数最少，就要使归并树 WPL 最小，即哈夫曼树</p><p>将哈夫曼树的思想推广到 $m$ 叉树的情形，在归并树中，让记录数少的初始归并段最先归并，记录数多的初始归并段最晚归并，就可以建立总的 I/O 次数最少的最佳归并树。</p><p>若初始归并段不足以构成一棵严格 $k$ 叉树时，需添加长度为 0 的“虚段”，按照哈夫曼树的原则，权为 0 的叶子应离树根最远。</p><p>如何判定添加虚段的数目</p><p>设度为 0 的结点有 $n_0 (=n)$ 个，度为 $k$ 的结点有 $n_k$ 个，则对严格 $k$ 叉树有 $n_0=(k-1)n_k+1$，由此可得 $n_k=\frac{(n_0-1)}{(k-1)}$。</p><ul><li>若 $(n_0-1) \bmod (k-1)=0 $ ，则说明这 $n_0$ 个叶结点（初始归并段）正好可以构造 $k$ 叉归并树。此时，内结点有 $n_k$ 个。</li><li>若 $(n_0-1) \bmod (k-1) =u  \ne 0$ ，则说明对于这 $n_0$ 个叶结点，其中有 $u$ 个多余，不能包含在 $k$ 叉归并树中。为构造包含所有 $n_0$ 个初始归并段的 $k$ 叉归并树，应在原有 $n_k$ 个内结点的基础上再增加 1 个内结点，即再加上 $k-u-1$ 个空归并段，就可以建立归并树。</li></ul>]]></content>
    
    
    <summary type="html">排序</summary>
    
    
    
    <category term="数据结构" scheme="http://halo123.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="http://halo123.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>查找</title>
    <link href="http://halo123.top/2021/05/12/DataStructure/G_Search/"/>
    <id>http://halo123.top/2021/05/12/DataStructure/G_Search/</id>
    <published>2021-05-12T09:16:51.000Z</published>
    <updated>2021-05-14T11:54:17.069Z</updated>
    
    <content type="html"><![CDATA[<p>【考纲内容】</p><ol><li>查找的基本概念</li><li>顺序查找法</li><li>分块查找法</li><li>折半查找法</li><li>B 树及其基本操作、B+ 树的基本概念</li><li>散列表</li><li>查找算法的分析及应用</li></ol><p>【复习提示】</p><p>本章是考研命题的重点。对于散列查找，应掌握散列表的构造、冲突处理方法（各种方法的处理过程）、查找成功和查找失败的平均查找长度、散列查找的特征和性能分析。对于折半查找，应掌握折半查找的过程、构造判定树、分析平均查找长度等。B 树和 B+ 树是本章的难点。对于 B 树，考研大纲要求掌握插入、删除和查找的操作过程；对于B+树，仅要求了解其基本概念和性质。</p><h2 id="查找的基本概念"><a class="header-anchor" href="#查找的基本概念"></a>查找的基本概念</h2><ul><li>查找。在数据集合中寻找满足某种条件的数据元素的过程称为查找。查找的结果一般分为两种：一 是查找成功，即在数据集合中找到了满足条件的数据元素；二是查找失败。</li><li>查找表（查找结构）。用于查找的数据集合称为查找表，它由同一类型的数据元素（或记录）组成，可以是一个数组或链表等数据类型。对查找表经常进行的操作一般有 4 种：<ol><li>查询某个特定的数据元素是否在查找表中</li><li>检索满足条件的某个特定的数据元素的各种属性</li><li>在查找表中插入一个数据元素</li><li>从查找表中删除某个数据元素。</li></ol></li><li>静态查找表。若一个查找表的操作只涉及上述操作 1 和 2，则无须动态地修改查找表，此类查找表称为静态查找表。与此对应，需要动态地插入或删除的查找表称为动态查找表。适合静态查找表的查找方法有顺序查找、折半查找、散列查找等；适合动态查找表的查找方法有二叉排序树的查找、散列查找等。二叉平衡树和 B 树都是二叉排序树的改进。</li><li>关键字。数据元素中<font color="#faa755">唯一标识</font>该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的。例如，在由一个学生元素构成的数据集合中，学生元素中“学号”这一数据项的值唯一地标识一名学生。</li><li>平均查找长度。在查找过程中，一次查找的长度是指需要比较的关键字次数，而平均查找长度则是所有查找过程中进行关键字的比较次数的平均值，其数学定义为：$$ASL=\sum_{i=1}^{n}P_iC_i$$式中，$n$ 是查找表的长度；$P_i$ 是查找第 $i$ 个数据元素的概率，一般认为每个数据元素的查找概率相等，即 $P_i=\frac{1}{n}$；$C_i$ 是找到第 $i$ 个数据元素所需进行的比较次数。平均查找长度是衡量查找算法效率的最主要的指标。</li></ul><h2 id="顺序查找和折半查找"><a class="header-anchor" href="#顺序查找和折半查找"></a>顺序查找和折半查找</h2><h3 id="顺序查找"><a class="header-anchor" href="#顺序查找"></a>顺序查找</h3><p>顺序查找又称线性查找，主要用于在线性表中进行查找。顺序查找通常分为对一般的无序线性表的顺序查找和对按关键字有序的顺序表的顺序查找。下面分别进行讨论。</p><h4 id="一般线性表的顺序查找"><a class="header-anchor" href="#一般线性表的顺序查找"></a>一般线性表的顺序查找</h4><p>作为一种最直观的查找方法，其基本思想是从线性表的一端开始，逐个检查关键字是否满足给定的条件。若查找到某个元素的关键字满足给定条件，则查找成功，返回该元素在线性表中的位置；若已经查找到表的另一端，但还没有查找到符合给定条件的元素，则返回查找失败的信息。下面给出其算法，主要是为了说明其中引入的“哨兵”的作用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>   <span class="comment">// 查找表的数据结构（顺序表）</span></span><br><span class="line">    <span class="keyword">int</span> *elem;     <span class="comment">// 动态数组基址</span></span><br><span class="line">    <span class="keyword">int</span> TableLen;  <span class="comment">// 表的长度</span></span><br><span class="line">&#125; SSTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顺序查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search_Seq</span><span class="params">(SSTable ST, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    ST.elem[<span class="number">0</span>] = key;  <span class="comment">// &quot;哨兵&quot;，存放在数组索引0的位置</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = ST.TableLen; ST.elem[i] != key; --i) &#123;  <span class="comment">// 从后往前找</span></span><br><span class="line">        <span class="keyword">return</span> i;  <span class="comment">// 查找成功，则返回元素下标；查找失败，则返回0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述算法中，将 <code>ST.elem[0]</code> 称为“哨兵”。引入它的目的是使得 <code>Search_ Seq</code> 内的循环不必判断数组是否会越界，因为满足 <code>i==0</code> 时，循环一定会跳出。需要说明的是，在程序中引入“哨兵”并不是这个算法独有的。引入“哨兵”可以避免很多不必要的判断语句，从而提高程序效率。</p><p>对于有 $n$ 个元素的表，给定值 <code>key</code> 与表中第 $i$ 个元素相等，即定位第 $i$ 个元素时，需进行 $n-i+ 1$ 次关键字的比较，即 $C_i=n-i+1$。查找成功时，顺序查找的平均长度为$$ASL=\sum_{i=1}^{n}P_i(n-i+1)$$当每个元素的查找概率相等，即 $P_i=\frac{1}{n}$ 时，有：$$ASL=\sum_{i=1}^{n}P_i(n-i+1)=\frac{n+1}{2}$$查找不成功时，与表中各关键字的比较次数显然是 $n + 1$ 次，从而顺序查找不成功的平均查找长度为 $ASL=n+1$ 。</p><p>通常，查找表中记录的查找概率并不相等。若能预先得知每个记录的查找概率，则应先对记录的查找概率进行排序，使表中记录按查找概率由小至大重新排列。</p><p>综上所述，顺序查找的缺点是当 $n$ 较大时，平均查找长度较大，效率低；优点是对数据元素的存储没有要求，顺序存储或链式存储皆可。对表中记录的有序性也没有要求，无论记录是否按关键字有序，均可应用。同时还需注意，对线性的链表只能进行顺序查找。</p><h4 id="有序表顺序查找"><a class="header-anchor" href="#有序表顺序查找"></a>有序表顺序查找</h4><p>若在查找之前就已经知道表是关键字有序的，则查找失败时可以不用再比较到表的另一端就能返回查找失败的信息，从而降低顺序查找失败的平均查找长度。</p><p>假设表 <code>L</code> 是按关键字从小到大排列的，查找的顺序是从前往后，待查找元素的关键字为 <code>key</code>，当查找到第 $i$ 个元素时，发现第 $i$ 个元素对应的关键字小于 <code>key</code>，但第 $i+ 1$ 个元素对应的关键字大于 <code>key</code>，这时就可返回查找失败的信息，因为第 $i$ 个元素之后的元素的关键字均大于 <code>key</code>，所以表中不存在关键字为 <code>key</code> 的元素。</p><p>可以用查找判定树来描述有序顺序表的查找过程。树中的圆形结点表示有序顺序表中存在的元素；树中的矩形结点称为失败结点（若有 $n$ 个结点，则相应地有 $n + 1$ 个查找失败结点），它描述的是那些不在表中的数据值的集合。若查找到失败结点，则说明查找不成功。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/%E6%9C%89%E5%BA%8F%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%8A%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E5%88%A4%E5%AE%9A%E6%A0%91.png" alt="有序顺序表上的顺序查找判定树"></p><p>在有序表的顺序查找中，查找成功的平均查找长度和一般线性表的顺序查找一样。查找失败时，查找指针一定走到了某个失败结点。这些失败结点是我们虚构的空结点，实际上是不存在的，所以到达失败结点时所查找的长度等于它上面的一个圆形结点的所在层数。查找不成功的平均查找长度在相等查找概率的情形下为：$$ASL=\sum_{j=1}^{n} q_j(l_j-1)=\frac{1+2+\cdots+n+n}{n+1}=\frac{n}{2}+\frac{n}{n+1}$$式中，$q_j$ 是到达第 $j$ 个失败节点的概率，在相等查找概率的情况下，它为 $\frac{1}{n+1}$；$l_i$ 是第 $j$ 个失败结点所在的层数。</p><p>注意，有序表的顺序查找和后面的折半查找的思想是不一样的，且有序表的顺序查找中的线性表可以是链式存储结构。</p><h3 id="折半查找"><a class="header-anchor" href="#折半查找"></a>折半查找</h3><p>折半查找又称二分查找，它仅适用于<font color="#faa755">有序</font>的<font color="#faa755">顺序表</font>。</p><p>折半查找的基本思想：首先将给定值 <code>key</code> 与表中中间位置的元素比较，若相等，则查找成功，返回该元素的存储位置；若不等，则所需查找的元素只能在中间元素以外的前半部分或后半部分（例如，在查找表升序排列时，若给定值 <code>key</code> 大于中间元素，则所查找的元素只可能在后半部分）。然后在缩小的范围内继续进行同样的查找，如此重复，直到找到为止，或确定表中没有所需要查找的元素，则查找不成功，返回查找失败的信息。算法代码实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Binary_Search</span><span class="params">(SeqList L, ElemType key)</span> </span>&#123; <span class="comment">// 升序排列</span></span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = L.TableLen - <span class="number">1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;  <span class="comment">// 取中间位置</span></span><br><span class="line">        <span class="keyword">if</span> (L.elem[mid] == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;  <span class="comment">// 查找成功则返回所在位置</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (L.elem[mid] &gt; key) &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;  <span class="comment">//从前半部分继续查找&#125;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;  <span class="comment">// 从后半部分继续查找</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 查找失败，返回-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>折半查找的过程可用二叉树来描述，称为判定树。树中每个圆形结点表示一个记录，结点中的值为该记录的关键字值；树中最下面的叶结点都是方形的，它表示查找不成功的情况。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/%E6%8F%8F%E8%BF%B0%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE%E8%BF%87%E7%A8%8B%E7%9A%84%E5%88%A4%E5%AE%9A%E6%A0%91.png" alt="描述折半查找过程的判定树"></p><p>从判定树可以看出，查找成功时的查找长度为从根结点到目的结点的路径上的结点数，而查找不成功时的查找长度为从根结点到对应失败结点的父结点的路径上的结点数；每个结点值均大于其左子结点值，且均小于于其右子结点值。若有序序列有 $n$ 个元素，则对应的判定树有 $n$ 个圆形的非叶结点和 $n+ 1$ 个方形的叶结点。显然，判定树是一棵平衡二叉树。</p><p>由上述分析可知，用折半查找法查找到给定值的比较次数最多不会超过树的高度。在等概率查找时，查找成功的平均查找长度为：$$ASL=\frac{1}{n} \sum_{i=1}^{n} l_i=\frac{1}{n}(1\times 1+2\times 2+\cdots +h \times  2^{h-1})=\frac{n+1}{n} \log_{2}{(n+1)}-1\approx \log_{2}{(n+1)-1}$$式中，$h$ 是树的高度，并且元素个数为 $n$ 时树高 $h = \left \lceil \log_{2}{(n+1)} \right \rceil $。所以，折半查找的时间复杂度为 $O(\log_{2}{n})$，平均情况下比顺序查找的效率高。</p><p>因为折半查找需要方便地定位查找区域，所以它要求线性表必须具有随机存取的特性。因此，该查找法仅适合于顺序存储结构，不适合于链式存储结构，且要求元素按关键字有序排列。</p><h3 id="分块查找"><a class="header-anchor" href="#分块查找"></a>分块查找</h3><p>分块查找又称索引顺序查找，它吸取了顺序查找和折半查找各自的优点，既有动态结构，又适于快速查找。</p><p>分块查找的基本思想：将查找表分为若干子块。<font color="#faa755">块内</font>的元素可以<font color="#faa755">无序</font>，但<font color="#faa755">块间</font>的元素是<font color="#faa755">有序</font>的，即第一个块中的最大关键字小于第二个块中的所有记录的关键字，第二个块中的最大关键字小于第三个块中的所有记录的关键字，以此类推。再建立一个索引表，索引表中的每个元素含有各块的最大关键字和各块中的第一个元素的地址，索引表按关键字有序排列。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 索引表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType maxValue;</span><br><span class="line">    <span class="keyword">int</span> low,high;</span><br><span class="line">&#125;Index;</span><br><span class="line"><span class="comment">// 顺序表存储实际元素</span></span><br><span class="line">ElemType List[<span class="number">100</span>];</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="分块查找示意图"></p><p>分块查找的过程分为两步：</p><ol><li>在索引表中确定待查记录所在的块，可以顺序查找或折半查找索引表；</li><li>在块内顺序查找。</li></ol><p>若索引表中不包含目标关键字，则折半查找索引表最终停在 <code>low</code> &gt; <code>high</code> 要在 <code>low</code> 所指分块中查找。原因是最终 <code>low</code> 左边一定小于目标关键字，<code>high</code> 右边一 定大于目标关键字。而分块存储的索引表中保存的是各个分块的最大关键字。</p><p>分块查找的平均查找长度为索引查找和块内查找的平均长度之和。设索引查找和块内查找的平均查找长度分别为 $L_I$，$L_S$，则分块查找的平均查找长度为：$$ASL=L_I+L_S$$将长度为 $n$ 的查找表均匀地分为 $b$ 块，每块有 $s$ 个记录，在等概率情况下，若在块内和索引表中均采用顺序查找，则平均查找长度为：$$ASL=L_I+L_S=\frac{b+1}{2}+\frac{s+1}{2}=\frac{s^2+2s+n}{2s}$$此时，若 $s=\sqrt{n} $，则平均查找长度取最小值 $\sqrt{n}+1 $；若对索引表采用折半查找时，则平均查找长度为：$$ASL=L_1+L_2= \left \lceil \log_{2}{(b+1)} \right \rceil+\frac{s+1}{2}$$</p><h2 id="B-树和-B-树"><a class="header-anchor" href="#B-树和-B-树"></a>B 树和 B+ 树</h2><div class="tag link"><a class="link-card" title="B 树可视化" href="https://www.cs.usfca.edu/~galles/visualization/BTree.html"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@master/img/网站.svg"/></div><div class="right"><p class="text">B 树可视化</p><p class="url">https://www.cs.usfca.edu/~galles/visualization/BTree.html</p></div></a></div><h3 id="B-树及其基本操作"><a class="header-anchor" href="#B-树及其基本操作"></a>B 树及其基本操作</h3><p>B 树，又称多路平衡查找树，B 树中所有结点的孩子个数的最大值称为 B 树的阶，通常用 $m$ 表示。一棵 $m$ 阶 B 树或为空树，或为满足如下特性的 $m$ 叉树：</p><ol><li>树中每个结点至多有 $m$ 棵子树，即至多含有 $m-1$ 个关键字。</li><li>若根结点不是终端结点，则至少有两棵子树。</li><li>除根结点外的所有非叶结点至少有 $\left \lceil \frac{m}{2} \right \rceil $ 棵子树，即至少含有 $\left \lceil \frac{m}{2} \right \rceil -1$ 个关键字。（保证查找效率）</li><li>所有非叶结点的结构如下：[ $n$ | $P_0$ | $K_1$ | $P_1$ | $K_2$ | $P_2$ | $\cdots $| $K_n$ | $P_n$ ]。其中，$K_i\ (i=1,2,\cdots ,n)$ 为结点的关键字，且满足 $K_1&lt;K_2&lt;\cdots K_n$ ；$P_i\ (i=0,1,\cdots ,n)$ 为指向子树根结点的指针，且指针 $P_{i-1}$ 所指子树中所有结点的关键字均小于 $K_i$ ，$P_i$ 所指子树中所有结点的关键字均大于 $K_i$，$n \ (\left \lceil \frac{m}{2} \right \rceil -1\le n \le m-1)$ 为结点中关键字的个数。</li><li>所有的叶结点都出现在同一层次上，并且不带信息（可以视为外部结点或类似于折半查找判定树的查找失败结点，实际上这些结点不存在，指向这些结点的指针为空）。（对于任何一个结点，其所有子树的高度都要相同）</li></ol><p>$m$ 阶 B 树的核心特性：</p><ol><li>根节点的子树数 $\in [2,m]$，关键字数 $\in [i,m-1]$；其他结点的子树数 $\in [ \left \lceil \frac{m}{2} \right \rceil ,m ]$；关键字数 $\in [ \left \lceil \frac{m}{2} \right \rceil -1,m-1 ]$</li><li>对于任何一个结点，其所有子树的高度都要相同</li></ol><p>B 树是所有结点的平衡因子均等于 <font color="#faa755">0</font> 的多路平衡查找树。</p><p>下图所示的 B 树中所有结点的最大孩子数 $m=5$，因此它是一棵 5 阶 B 树，在 $m$ 阶 B 树中结点最多可以有 $m$ 个孩子。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/%E4%B8%80%E9%A2%975%E9%98%B6B%E6%A0%91%E7%9A%84%E5%AE%9E%E4%BE%8B.png" alt="一颗5阶B树的实例"></p><p>可以借助该实例来分析上述性质：</p><ol><li>结点的孩子个数等于该节点中关键字个数加 1。</li><li>如果根结点没有关键字就没有子树，此时 B 树为空；如果根节点有关键字，则其子树必然大于等于两棵，因为子树个数等于关键字个数加 1。</li><li>除根结点外的所有非终端结点至少有 $\left \lceil \frac{m}{2} \right \rceil = \left \lceil \frac{5}{2} \right \rceil =3$ 棵子树（即至少有 $\left \lceil \frac{m}{2} \right \rceil -1=\left \lceil \frac{5}{2} \right \rceil -1=2$ 个关键字），至多有 5 棵子树（即至多有 4 个关键字）。</li><li>结点中关键字从左到右递增有序，关键字两侧均有指向子树的指针，左边指针所指向子树的所有关键字均小于该关键字，右边指针所指子树的所有关键字均大于该关键字。或者看成下层结点关键字总是落在由上层结点关键字所划分的区间内，如第二层最左结点的关键字划分成了 3 个区间：$(-\infty, 5),(5, 11),(11, +\infty)$，该结点 3 个指针所指子树的关键字均落在这 3 个区间内。</li><li>所有叶结点均在第 4 层，代表查找失败的位置。</li></ol><h4 id="B-树的高度（磁盘存取次数）"><a class="header-anchor" href="#B-树的高度（磁盘存取次数）"></a>B 树的高度（磁盘存取次数）</h4><p>B 树中的大部分操作所需的磁盘存取次数与 B 树的高度成正比。</p><p>下面来分析 B 树在不同情况下的高度。当然，首先应该明确 B 树的高度不包括最后的不带任何信息的叶结点所处的那一层（有些书对 B 树的高度的定义中，包含最后的那一层）。</p><p>若 $n\ge 1$，则对任意一棵包含 $n$ 个关键字、高度为 $h$ 、阶数为 $m$ 的 B 树：</p><ol><li>因为 B 树中每个结点最多有 $m$ 棵子树， $m-1$ 个关键字，所以在一棵高度为 $h$ 的 $m$ 阶 B 树中关键字的个数应满足 $n\le (m-1)(1+m+m^2+\cdots +m<sup>{h-1}=m</sup>h-1)$ ，因此有 $h\ge \log_{m}{(n+1)}$ 。最小高度</li><li>若让每个结点中的关键字个数达到最少，则容纳同样多关键字的 B 树的高度达到最大。由 B 树的定义：第一层至少有 1 个结点；第二层至少有 2 个结点；除根结点外的每个非终端结点至少有 $\left \lceil \frac{m}{2} \right \rceil $ 棵子树，则第三层至少有 $ 2 \left \lceil \frac{m}{2} \right \rceil $ 个结点……第 $h+ 1$ 层至少有 $2(\left \lceil \frac{m}{2} \right \rceil )^{h-1}$ 个结点，注意到第 $h+ 1$ 层是不包含任何信息的叶结点。对于关键字个数为 $n$ 的 B 树，叶结点即查找不成功的结点为 $n+ 1$ ，由此有 $n+ 1\ge 2(\left \lceil \frac{m}{2} \right \rceil )^{h-1}$，即 $h\le \log_{\left \lceil \frac{m}{2} \right \rceil }{(\frac{n+1}{2})+1} $。</li></ol><p>故含 $n$ 个关键字、高度为 $h$ 、阶数为 $m$ 的 B 树有：$ \log_{m}{(n+1)}\le h\le \log_{\left \lceil \frac{m}{2} \right \rceil }{(\frac{n+1}{2})+1} $</p><h4 id="B-树的查找"><a class="header-anchor" href="#B-树的查找"></a>B 树的查找</h4><p>在 B 树上进行查找与二叉查找树很相似，只是每个结点都是多个关键字的有序表，在每个结点上所做的不是两路分支决定，而是根据该结点的子树所做的多路分支决定。B 树的查找包含两个基本操作：</p><ol><li>在B树中找结点；</li><li>在结点内找关键字。</li></ol><p>由于 B 树常存储在磁盘上，因此前一个查找操作是在磁盘上进行的，而后一个查找操作是在内存中进行的，即在找到目标结点后，先将结点信息读入内存，然后在结点内采用顺序查找法或折半查找法。在 B 树上查找到某个结点后，先在有序表中进行查找，若找到则查找成功，否则按照对应的指针信息到所指的子树中去查找。查找到叶结点时（对应指针为空指针），则说明树中没有对应的关键字，查找失败。</p><h4 id="B-树的插入"><a class="header-anchor" href="#B-树的插入"></a>B 树的插入</h4><p>与二叉查找树的插入操作相比，B树的插入操作要复杂得多。在二叉查找树中，仅需查找到需插入的终端结点的位置。但是,在 B 树中找到插入的位置后，并不能简单地将其添加到终端结点中，因为此时可能会导致整棵树不再满足 B 树定义中的要求。将关键字 key 插入 B 树的过程如下：</p><ol><li>定位。利用前述的 B 树查找算法，找出插入该关键字的<font color="#faa755">最低层</font>中的某个非叶结点（在 B 树中查找 key 时，会找到表示查找失败的叶结点，这样就确定了最底层非叶结点的插入位置。注意：插入位置一定是最低层中的某个非叶结点）。</li><li>插入。在 B 树中，每个非失败结点的关键字个数都在区间 $[\left \lceil \frac{m}{2} \right \rceil -1,m- 1]$ 内。插入后的结点关键字个数小于 $m$ ，可以直接插入；插入后检查被插入结点内关键字的个数，当插入后的结点关键字个数大于 $m-1$ 时，必须对结点进行分裂。</li></ol><p>分裂的方法是：取一个新结点，在插入 key 后的原结点，从中间位置（$\left \lceil \frac{m}{2} \right \rceil $）将其中的关键字分为两部分，左部分包含的关键字放在原结点中，右部分包含的关键字放到新结点中，中间位置（$\left \lceil \frac{m}{2} \right \rceil $）的结点插入原结点的父结点。若此时导致其父结点的关键字个数也超过了上限，则继续进行这种分裂操作，直至这个过程传到根结点为止，进而导致 B 树高度增 1。</p><h4 id="B-树的删除"><a class="header-anchor" href="#B-树的删除"></a>B 树的删除</h4><p>B 树中的删除操作与插入操作类似，但要稍微复杂一些，即要使得删除后的结点中的关键字个数 $\ge \left \lceil \frac{m}{2} \right \rceil -1$ ，因此将涉及结点的“合并”问题。</p><p>当被删关键字 $k$ 不在终端结点（最低层非叶结点）中时，可以用 $k$ 的前驱（或后继） $k’$ 来替代 $k$ ，然后在相应的结点中删除 $k’$， 关键字 $k$ 必定落在某个终端结点中，则转换成了被删关键字在终端结点中的情形。</p><ul><li>直接前驱：当前关键字左侧指针所指子树中“最右下”的元素。</li><li>直接后继：当前关键字右侧指针所指子树中“最左下”的元素。</li></ul><p>当被删关键字在终端结点（最低层非叶结点）中时，有下列三种情况：</p><ol><li>直接删除关键字。若被删除关键字所在结点的关键字个数 $\ge \left \lceil \frac{m}{2} \right \rceil -1$ ，表明删除该关键字后仍满足 B 树的定义，则直接删去该关键字。</li><li>兄弟够借。若被删除关键字所在结点删除前的关键字个数$=\left \lceil \frac{m}{2} \right \rceil -1$，且与此结点相邻的右（或左）兄弟结点的关键字个数$\ge \left \lceil \frac{m}{2} \right \rceil$，则需要调整该结点、右（或左）兄弟结点及其双亲结点（父子换位法），以达到新的平衡。当右兄弟很宽裕时，用当前结点的后继、后继的后继来填补空缺；当左兄弟很宽裕时，用当前结点的前驱、前驱的前驱来填补空缺。</li><li>兄弟不够借。若被删除关键字所在结点删除前的关键字个数 $=\left \lceil \frac{m}{2} \right \rceil -1$，且此时与该结点相邻的左、右兄弟结点的关键字个数均 $=\left \lceil \frac{m}{2} \right \rceil -1$，则将关键字删除后与左（或右）兄弟结点及双亲结点中的关键字进行合并。在合并过程中，双亲结点中的关键字个数会减 1 。 若其双亲结点是根结点且关键字个数减少至 0 （根结点关键字个数为 1 时，有 2 棵子树），则直接将根结点删除，合并后的新结点成为根；若双亲结点不是根结点，且关键字个数减少到 $=\left \lceil \frac{m}{2} \right \rceil -2$，则又要与它自己的兄弟结点进行调整或合并操作，并重复上述步骤，直至符合 B 树的要求为止。</li></ol><h3 id="B-树的基本概念"><a class="header-anchor" href="#B-树的基本概念"></a>B+ 树的基本概念</h3><p>B+ 树是应数据库所需而出现的一种 B 树的变形树。</p><p>一棵 $m$ 阶的 B+ 树需满足下列条件：</p><ol><li>每个分支结点最多有 $m$ 棵子树（孩子结点）。</li><li>非叶根结点至少有两棵子树，其他每个分支结点至少有 $\left \lceil \frac{m}{2} \right \rceil $ 棵子树。</li><li>结点的子树个数与关键字个数相等。</li><li>所有<font color="#faa755">叶结点包含全部关键字</font>及指向相应记录的指针，叶结点中将关键字按大小顺序排列，并且相邻叶结点按大小顺序相互链接起来。(支持顺序查找)</li><li>所有分支结点（可视为索引的索引）中仅包含它的各个子结点（即下一级的索引块）中关键字的最大值及指向其子结点的指针。（类似分块查找）</li></ol><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/B+%E6%A0%91%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="B+树结构示意图"></p><p>$m$ 阶的 B+ 树与 $m$ 阶的 B 树的主要差异如下：</p><ol><li>在 B+ 树中，具有 $n$ 个关键字的结点只含有 $n$ 棵子树，即每个关键字对应一棵子树；而在 B 树中，具有 $n$ 个关键字的结点含有 $n+1$ 棵子树。</li><li>在 B+ 树中，每个结点（非根内部结点）的关键字个数 $n$ 的范围是 $\left \lceil \frac{m}{2} \right \rceil \le n \le m$  （根结点：$1\le n \le m$）；在 B 树中，每个结点（非根内部结点）的关键字个数 $n$ 的范围是 $\left \lceil \frac{m}{2} \right \rceil -1 \le n \le m-1 $ （根结点：$1\le n \le m-1$）。</li><li>在 B+ 树中，叶结点包含信息，所有非叶结点仅起索引作用，非叶结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。</li><li>在 B+ 树中，叶结点包含了全部关键字，即在非叶结点中出现的关键字也会出现在叶结点中；而在 B 树中，叶结点包含的关键字和其他结点包含的关键字是不重复的。</li></ol><p>分支结点的某个关键字是其子树中最大关键字的副本。通常在 B+ 树中有两个头指针：一个指向根结点，另一个指向关键字最小的叶结点。因此，可以对 B+ 树进行两种查找运算：一种是从最小关键字开始的顺序查找，另一种是从根结点开始的多路查找。</p><p>B+ 树的查找、插入和删除操作和 B 树的基本类似。只是在查找过程中，非叶结点上的关键字值等于给定值时并不终止，而是继续向下查找，直到叶结点上的该关键字为止。所以，在 B+ 树中查找时，无论查找成功与否，每次查找都是一条从根结点到叶结点的路径。</p><p>在 B+ 树中，非叶结点不含有该关键字对应记录的存储地址。可以使一个磁盘块可以包含更多个关键字，使得 B+ 树的阶更大，树高更矮，读磁盘次数更少，查找更快。</p><h2 id="散列表"><a class="header-anchor" href="#散列表"></a>散列表</h2><h3 id="散列表的基本概念"><a class="header-anchor" href="#散列表的基本概念"></a>散列表的基本概念</h3><p>在前面介绍的线性表和树表的查找中，记录在表中的位置与记录的关键字之间不存在确定关系，因此，在这些表中查找记录时需进行一系列的关键字比较。这类查找方法建立在“比较”的基础上，查找的效率取决于比较的次数。</p><p>散列函数：一个把查找表中的关键字映射成该关键字对应的地址的函数，记为 <code>Hash(key)=Addr</code>  （这里的地址可以是数组下标、索引或内存地址等）。</p><p>散列函数可能会把两个或两个以上的不同关键字映射到同一地址，称这种情况为<font color="#ea66a6">冲突</font>，这些发生碰撞的不同关键字称为<font color="#ea66a6">同义词</font>。一方面，设计得好的散列函数应尽量减少这样的冲突；另一方面，由于这样的冲突总是不可避免的，所以还要设计好处理冲突的方法。</p><p>散列表：根据关键字而直接进行访问的数据结构。也就是说，散列表建立了关键字和存储地址之间的一种直接映射关系。</p><p>理想情况下，对散列表进行查找的时间复杂度为 $O(1)$，即与表中元素的个数无关。下面分别介绍常用的散列函数和处理冲突的方法。</p><h3 id="散列函数的构造方法"><a class="header-anchor" href="#散列函数的构造方法"></a>散列函数的构造方法</h3><p>在构造散列函数时，必须注意以下几点：</p><ol><li>散列函数的定义域必须包含全部需要存储的关键字，而值域的范围则依赖于散列表的大小或地址范围。</li><li>散列函数计算出来的地址应该能等概率、均匀地分布在整个地址空间中，从而减少冲突的发生。</li><li>散列函数应尽量简单，能够在较短的时间内计算出任一关键字对应的散列地址。</li></ol><p>下面介绍常用的散列函数：</p><h4 id="直接定址法"><a class="header-anchor" href="#直接定址法"></a>直接定址法</h4><p>直接取关键字的某个线性函数值为散列地址，散列函数为$H(\mathrm{key} )=\mathrm{key} $ 或 $H(\mathrm{key})=a\times \mathrm{key} +b$ 式中，$a$ 和 $b$ 是常数。</p><p>这种方法计算最简单，且不会产生冲突。它适合关键字的分布基本连续的情况，若关键字分布不连续，空位较多，则会造成存储空间的浪费。</p><h4 id="除留余数法"><a class="header-anchor" href="#除留余数法"></a>除留余数法</h4><p>这是一种最简单、最常用的方法，假定散列表表长为 $m$，取一个不大于 $m$ 但最接近或等于 $m$ 的<font color="#faa755">质数</font> $p$ ，利用以下公式把关键字转换成散列地址。散列函数为 $H(\mathrm{key})=\mathrm{key} % p$</p><p>除留余数法的关键是选好 $p$ ，使得每个关键字通过该函数转换后等概率地映射到散列空间上的任一地址，从而尽可能减少冲突的可能性。</p><h4 id="数字分析法"><a class="header-anchor" href="#数字分析法"></a>数字分析法</h4><p>设关键字是 $r$ 进制数（如十进制数），而 $r$ 个数码在各位上出现的频率不一定相同，可能在某些位上分布均匀一些， 每种数码出现的机会均等；而在某些位上分布不均匀，只有某几种数码经常出现，此时应<font color="#faa755">选取数码分布较为均匀的若干位作为散列地址</font>。这种方法适合于已知的关键字集合，若更换了关键字，则需要重新构造新的散列函数。</p><h4 id="平方取中法"><a class="header-anchor" href="#平方取中法"></a>平方取中法</h4><p>顾名思义，这种方法取关键字的平方值的中间几位作为散列地址。具体取多少位要视实际情况而定。这种方法得到的散列地址与关键字的每位都有关系，因此使得散列地址分布比较均匀，适用于关键字的每位取值都不够均匀或均小于散列地址所需的位数。<br>在不同的情况下，不同的散列函数具有不同的性能，因此不能笼统地说哪种散列函数最好。在实际选择中，采用何种构造散列函数的方法取决于关键字集合的情况，但目标是为了尽量降低产生冲突的可能性。</p><h3 id="处理冲突的方法"><a class="header-anchor" href="#处理冲突的方法"></a>处理冲突的方法</h3><p>应该注意到，任何设计出来的散列函数都不可能绝对地避免冲突。为此，必须考虑在发生冲突时应该如何处理，即为产生冲突的关键字寻找下一个“空”的 Hash 地址。用 $H_i$ 表示处理冲突中第 $i$ 次探测得到的散列地址，假设得到的另一个散列地址 $H_1$ 仍然发生冲突，只得继续求下一个地址 $H_2$，以此类推，直到 $H_k$ 不发生冲突为止，则 $H_k$ 为关键字在表中的地址。</p><h4 id="拉链法（链接法）"><a class="header-anchor" href="#拉链法（链接法）"></a>拉链法（链接法）</h4><p>显然，对于不同的关键字可能会通过散列函数映射到同一地址，为了避免非同义词发生冲突，可以把所有的同义词存储在一个线性链表中，这个线性链表由其散列地址唯一标识。假设散列地址为 $i$ 的同义词链表的头指针存放在散列表的第 $i$ 个单元中，因而查找、插入和删除操作主要在同义词链中进行。拉链法适用于经常进行插入和删除的情况。</p><h4 id="开放定址法"><a class="header-anchor" href="#开放定址法"></a>开放定址法</h4><p>所谓开放定址法，是指可存放新表项的空闲地址既向它的同义词表项开放，又向它的非同义词表项开放。其数学递推公式为$$H_i=H(\mathrm{key})+d_i % m$$式中，$H(\mathrm{key})$ 为散列函数；$i=0,1,2,\cdots ,k \ (k \le m-1)$；$m$ 表示散列表长；$d_i$ 为增量序列。取定某一增量序列后，对应的处理方法就是确定的。通常有以下 4 种取法：</p><ol><li>线性探测法。当 $d_i=0,1,2,\cdots ,m-1$ 时，称为线性探测法。这种方法的特点是：冲突发生时，顺序查看表中下一个单元（探测到表尾地址 $m-1$ 时，下一个探测地址是表首地址 0 ），直到找出一个空闲单元（当表未填满时一定能找到- 一个空闲单元）或查遍全表。线性探测法可能使第 $i$ 个散列地址的同义词存入第 $i+ 1$ 个散列地址，这样本应存入第 $i+1$ 个散列地址的元素就争夺第 $i+2$ 个散列地址的元素的地址…从而造成大量元素在相邻的散列地址上，“聚集”(或堆积）起来，大大降低了查找效率。</li><li>平方探测法。当 $d_{i} = {0^2} ,{1^2}, {-1^2} ,{2^2} ,{-2^2}, \cdots ,{k^2} ,{-k^2}$ 时，称为平方探测法，其中 $k \le \frac{m}{2}$ ，散列表长度 $m$ 必须是一个可以表示成 $4k+3$ 的素数，又称二次探测法。平方探测法是一种较好的处理冲突的方法，可以避免出现“堆积”问题，它的缺点是不能探测到散列表上的所有单元，但至少能探测到一半单元。</li><li>伪随机序列法。当 $d_i=$ 伪随机数序列时，称为伪随机序列法。</li><li>再散列法。除了原始的散列函数 $H(\mathrm{key})$ 之外，多准备几个散列函数，当散列函数冲突时，用下一个散列函数计算一个新地址，直到不冲突为止。</li></ol><p>注意：在开放定址的情形下，不能随便物理删除表中的已有元素，因为若删除元素，则会截断其他具有相同散列地址的元素的查找地址。因此，要删除-一个元素时，可给它做一个删除标记，进行逻辑删除。但这样做的副作用是:执行多次删除后，表面，上看起来散列表很满，实际上有许多位置未利用，因此需要定期维护散列表，要把删除标记的元素物理删除。</p><h3 id="散列查找及性能分析"><a class="header-anchor" href="#散列查找及性能分析"></a>散列查找及性能分析</h3><p>散列表的查找过程与构造散列表的过程基本一致。对于一个给定的关键字 key ，根据散列函数可以计算出其散列地址，执行步骤如下：</p><p>初始化： <code>Addr=Hash(key);</code></p><ol><li>检测查找表中地址为 <code>Addr</code> 的位置上是否有记录，若无记录，返回查找失败；若有记录，比较它与 <code>key</code> 的值，若相等，则返回查找成功标志，否则执行步骤 2 。</li><li>用给定的处理冲突方法计算“下一个散列地址”，并把 <code>Addr</code> 置为此地址，转入步骤 1 。</li></ol><p>对同一组关键字，设定相同的散列函数，则不同的处理冲突的方法得到的散列表不同，它们的平均查找长度也不同。</p><p>从散列表的查找过程可见：</p><ol><li>虽然散列表在关键字与记录的存储位置之间建立了直接映像，但由于“冲突”的产生，使得散列表的查找过程仍然是一个给定值和关键字进行比较的过程。因此，仍需要以平均查找长度作为衡量散列表的查找效率的度量。</li><li>散列表的查找效率取决于三个因素：散列函数、处理冲突的方法和装填因子。</li></ol><p>装填因子。散列表的装填因子一般记为 $\alpha $，定义为一个表的装满程度，即：$\alpha =\frac{n}{m}$ 式中 $n$ 表示表中记录数，$m$ 表示散列表长度。</p><p>散列表的平均查找长度依赖于散列表的装填因子 $\alpha $，而不直接依赖于 $n$ 或 $m$ 。直观地看，$\alpha $ 越大，表示装填的记录越“满”，发生冲突的可能性越大，反之发生冲突的可能性越小。</p>]]></content>
    
    
    <summary type="html">查找</summary>
    
    
    
    <category term="数据结构" scheme="http://halo123.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="http://halo123.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>小小世界</title>
    <link href="http://halo123.top/2021/05/11/Plan/%E5%B0%8F%E5%B0%8F%E4%B8%96%E7%95%8C/"/>
    <id>http://halo123.top/2021/05/11/Plan/%E5%B0%8F%E5%B0%8F%E4%B8%96%E7%95%8C/</id>
    <published>2021-05-11T11:46:48.000Z</published>
    <updated>2021-05-14T16:24:14.861Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原神"><a class="header-anchor" href="#原神"></a>原神</h2><h3 id="优菈角色PV「深夜酒馆的邂逅」"><a class="header-anchor" href="#优菈角色PV「深夜酒馆的邂逅」"></a>优菈角色PV「深夜酒馆的邂逅」</h3><p>2021年5月11日 PV链接</p><div class="tag link"><a class="link-card" title="【哔哩哔哩】优菈角色PV「深夜酒馆的邂逅」" href="https://www.bilibili.com/video/BV17b4y1f7Lt"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/bilibiliIcon.svg"/></div><div class="right"><p class="text">【哔哩哔哩】优菈角色PV「深夜酒馆的邂逅」</p><p class="url">https://www.bilibili.com/video/BV17b4y1f7Lt</p></div></a></div><h2 id="明日方舟"><a class="header-anchor" href="#明日方舟"></a>明日方舟</h2><h3 id="危机合约新赛季「光谱行动」"><a class="header-anchor" href="#危机合约新赛季「光谱行动」"></a>危机合约新赛季「光谱行动」</h3><p>2021年5月10日 放出<a href="https://www.bilibili.com/video/BV1264y117Py">宣传PV</a></p><p>2021年5月11日 <a href="https://t.bilibili.com/523468243217968769?tab=2">活动奖励服饰</a> 浅滩律动 - 蓝毒</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/%E6%B5%85%E6%BB%A9%E5%BE%8B%E5%8A%A8%E8%93%9D%E6%AF%92.jpg" alt="浅滩律动蓝毒"></p><h3 id="二周年庆「覆潮之下」"><a class="header-anchor" href="#二周年庆「覆潮之下」"></a>二周年庆「覆潮之下」</h3><p>2021年5月11日 116抽终于抽到了浊心斯卡蒂，116抽只出了两个6星，另一个是W，可惜我之前有了，加了一潜。两次触发伪保底，还好斯卡蒂没歪，可谓是：“最坏的情况下的最好结果。”</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/%E6%98%8E%E6%97%A5%E6%96%B9%E8%88%9F%E4%BA%8C%E5%91%A8%E5%B9%B4%E5%BA%86%E5%8D%A1%E6%B1%A0.jpg" alt="明日方舟二周年庆卡池"></p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/%E6%98%8E%E6%97%A5%E6%96%B9%E8%88%9F%E4%BA%8C%E5%91%A8%E5%B9%B4%E5%BA%86%E7%89%88%E6%9C%AC.jpg" alt="明日方舟二周年庆版本"></p><p>2021年5月14日 这简直离谱，今天把周年庆的拼图完成了，最后送了我 500 合成玉，同时今天也是卡池的最后一天，结果</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/%E4%BA%8C%E5%91%A8%E5%B9%B4%E5%BA%86%E5%AF%BB%E8%AE%BF%E8%AE%B0%E5%BD%95.png" alt="二周年庆寻访记录"></p><p>一开始我拉包，还以为只是个 5 星，就直接跳过，看到铃兰开始也以为是 5 星，但一想不对，这不是哪个有脆弱的辅助吗，啊这，这简直离谱，这样还是歪了没出凯尔希，之前的话要反过来说了：“最好的情况下的最坏结果。”</p><h2 id="动漫"><a class="header-anchor" href="#动漫"></a>动漫</h2>]]></content>
    
    
    <summary type="html">用于记录我所关注的二次元圈</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>源</title>
    <link href="http://halo123.top/2021/05/11/Plan/%E6%BA%90/"/>
    <id>http://halo123.top/2021/05/11/Plan/%E6%BA%90/</id>
    <published>2021-05-11T11:46:48.000Z</published>
    <updated>2021-05-20T04:35:05.517Z</updated>
    
    <content type="html"><![CDATA[<h3 id="三点钟啦，喝茶先啦"><a class="header-anchor" href="#三点钟啦，喝茶先啦"></a>三点钟啦，喝茶先啦</h3><h3 id="两面包夹芝士"><a class="header-anchor" href="#两面包夹芝士"></a>两面包夹芝士</h3><div class="tag link"><a class="link-card" title="【哔哩哔哩】3000块全没了！各位喝醉了一定要管好自己，我真服了！" href="https://www.bilibili.com/video/BV1cf4y1W771"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/bilibiliIcon.svg"/></div><div class="right"><p class="text">【哔哩哔哩】3000块全没了！各位喝醉了一定要管好自己，我真服了！</p><p class="url">https://www.bilibili.com/video/BV1cf4y1W771</p></div></a></div><div class="tag link"><a class="link-card" title="【萌娘百科】两面包夹芝士词条解释" href="https://zh.moegirl.org.cn/%E6%98%8E%E6%97%A5%E6%96%B9%E8%88%9F/%E6%A2%97#%E4%B8%A4%E9%9D%A2%E5%8C%85%E5%A4%B9%E8%8A%9D%E5%A3%AB"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/萌娘百科icon.jpg"/></div><div class="right"><p class="text">【萌娘百科】两面包夹芝士词条解释</p><p class="url">https://zh.moegirl.org.cn/%E6%98%8E%E6%97%A5%E6%96%B9%E8%88%9F/%E6%A2%97#%E4%B8%A4%E9%9D%A2%E5%8C%85%E5%A4%B9%E8%8A%9D%E5%A3%AB</p></div></a></div><p>相关梗：</p><ul><li>森蚺你闭嘴</li><li>我永远喜欢森蚺</li><li>为斯卡蒂献出心脏！</li><li>没⇝有⇝力↝量↺</li><li>这白开水怎么没味啊？</li><li>两面包夹芝士</li></ul><h3 id="这里的水很深，你把握不住孩子"><a class="header-anchor" href="#这里的水很深，你把握不住孩子"></a>这里的水很深，你把握不住孩子</h3><div class="tag link"><a class="link-card" title="【哔哩哔哩】潘子教育嘎子完整版" href="https://www.bilibili.com/video/BV1py4y1s7q1?p=1&t=117"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/bilibiliIcon.svg"/></div><div class="right"><p class="text">【哔哩哔哩】潘子教育嘎子完整版</p><p class="url">https://www.bilibili.com/video/BV1py4y1s7q1?p=1&t=117</p></div></a></div><p>相关梗：</p><ul><li>潘嘎之交</li><li>网上的东西都是虚拟的，你把握不住的孩子</li><li>挣W</li></ul><h3 id="我只会心疼哥哥"><a class="header-anchor" href="#我只会心疼哥哥"></a>我只会心疼哥哥</h3><div class="tag link"><a class="link-card" title="【哔哩哔哩】我只会心疼哥哥" href="https://www.bilibili.com/video/BV1U64y1D7oV"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/bilibiliIcon.svg"/></div><div class="right"><p class="text">【哔哩哔哩】我只会心疼哥哥</p><p class="url">https://www.bilibili.com/video/BV1U64y1D7oV</p></div></a></div><h3 id="折中"><a class="header-anchor" href="#折中"></a>折中</h3><p>中国人的性情是总喜欢调和折中的，譬如你说，这屋子太暗，须在这里开一个窗，大家一定不允许的。但如果你主张拆掉屋顶他们就来调和，愿意开窗了——《无声的中国》鲁迅</p><h3 id="ん？"><a class="header-anchor" href="#ん？"></a>ん？</h3><p>源于泽野弘之作曲的「UNICORN」</p><div class="tag link"><a class="link-card" title="【萌娘百科】UNICORN词条解释" href="https://zh.moegirl.org.cn/UNICORN"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/萌娘百科icon.jpg"/></div><div class="right"><p class="text">【萌娘百科】UNICORN词条解释</p><p class="url">https://zh.moegirl.org.cn/UNICORN</p></div></a></div><p>衍生梗：</p><ul><li>流れ变わったな（流向改变了）</li><li>完 全 勝 利（完 全 胜 利）</li><li>完 全 失 敗（完 全 失 败）</li></ul><p>相关作品：</p><div class="tag link"><a class="link-card" title="【哔哩哔哩】UC希望の花" href="https://www.bilibili.com/video/BV1rW411g7Sk"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/bilibiliIcon.svg"/></div><div class="right"><p class="text">【哔哩哔哩】UC希望の花</p><p class="url">https://www.bilibili.com/video/BV1rW411g7Sk</p></div></a></div><h3 id="杰哥不要啦"><a class="header-anchor" href="#杰哥不要啦"></a>杰哥不要啦</h3><div class="tag link"><a class="link-card" title="【萌娘百科】杰姐" href="https://zh.moegirl.org.cn/%E6%9D%B0%E5%A7%90"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/萌娘百科icon.jpg"/></div><div class="right"><p class="text">【萌娘百科】杰姐</p><p class="url">https://zh.moegirl.org.cn/%E6%9D%B0%E5%A7%90</p></div></a></div><div class="tag link"><a class="link-card" title="杰哥 不要啊 完整版" href="https://www.bilibili.com/video/BV1xK411G7eF?p=1&t=341"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/bilibiliIcon.svg"/></div><div class="right"><p class="text">杰哥 不要啊 完整版</p><p class="url">https://www.bilibili.com/video/BV1xK411G7eF?p=1&t=341</p></div></a></div><p>相关梗：</p><ul><li>我的房子还蛮大的</li><li>听你这么说，你很勇哦；开玩笑，我超勇的好不好</li></ul><h3 id="原神"><a class="header-anchor" href="#原神"></a>原神</h3><div class="tag link"><a class="link-card" title="【萌娘百科】原神一些梗汇总" href="https://zh.moegirl.org.cn/%E5%8E%9F%E7%A5%9E/%E6%A2%97"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/萌娘百科icon.jpg"/></div><div class="right"><p class="text">【萌娘百科】原神一些梗汇总</p><p class="url">https://zh.moegirl.org.cn/%E5%8E%9F%E7%A5%9E/%E6%A2%97</p></div></a></div>]]></content>
    
    
    <summary type="html">用于记录一些梗的出处</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>大事小事记</title>
    <link href="http://halo123.top/2021/05/11/Plan/%E5%A4%A7%E4%BA%8B%E5%B0%8F%E4%BA%8B%E8%AE%B0/"/>
    <id>http://halo123.top/2021/05/11/Plan/%E5%A4%A7%E4%BA%8B%E5%B0%8F%E4%BA%8B%E8%AE%B0/</id>
    <published>2021-05-11T11:40:48.000Z</published>
    <updated>2021-05-14T16:21:34.264Z</updated>
    
    <content type="html"><![CDATA[<h3 id="搜救驴友的救援队断水，得救的驴友却在山下烧水泡茶"><a class="header-anchor" href="#搜救驴友的救援队断水，得救的驴友却在山下烧水泡茶"></a>搜救驴友的救援队断水，得救的驴友却在山下烧水泡茶</h3><p>5月9日，北京房山蓝天救援队的队员们经历了一次最累、最危险却也最心酸的救援。他们历经18个小时，将18名受困驴友安全护送下山。</p><p>在找到驴友并得知他们十分缺水时，蓝天队员把自己的水送给他们，导致自己后半夜全部断水。而到了山下安全地带，一名年轻驴友竟从包里掏出两瓶水，还烧水泡起了茶。在队员询问：大家早就断水，怎么还会有水之后，这名驴友答道：做人需要留一手。</p><div class="tag link"><a class="link-card" title="【知乎】相关问题" href="https://www.zhihu.com/question/459310609"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/知乎icon.png"/></div><div class="right"><p class="text">【知乎】相关问题</p><p class="url">https://www.zhihu.com/question/459310609</p></div></a></div><h3 id="第七次全国人口普查数据"><a class="header-anchor" href="#第七次全国人口普查数据"></a>第七次全国人口普查数据</h3><p>2021年5月11日 公布第七次全国人口普查数据</p><div class="tag link"><a class="link-card" title="【国家统计局】第七次全国人口普查主要数据情况" href="http://www.stats.gov.cn/tjsj/zxfb/202105/t20210510_1817176.html"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E7%BD%91%E7%AB%99.svg"/></div><div class="right"><p class="text">【国家统计局】第七次全国人口普查主要数据情况</p><p class="url">http://www.stats.gov.cn/tjsj/zxfb/202105/t20210510_1817176.html</p></div></a></div><ol><li>人口总量。全国人口共 141178 万人，与 2010 年（第六次全国人口普查数据，下同）的 133972 万人相比，增加 7206 万人，增长 5.38%，年平均增长率为 0.53%，比 2000 年到 2010 年的年平均增长率 0.57%下降 0.04个百分点。数据表明，我国人口 10 年来继续保持低速增长态势。</li><li>户别人口。全国共有家庭户 49416 万户，家庭户人口为 129281 万人；集体户 2853 万户，集体户人口为 11897 万人。平均每个家庭户的人口为 2.62 人，比 2010 年的 3.10 人减少 0.48 人。家庭户规模继续缩小，主要是受我国人口流动日趋频繁和住房条件改善年轻人婚后独立居住等因素的影响。</li><li>人口地区分布。东部地区人口占 39.93%，中部地区占 25.83%，西部地区占 27.12%，东北地区占 6.98%。与 2010 年相比，东部地区人口所占比重上升 2.15 个百分点，中部地区下降 0.79 个百分点，西部地区上升 0.22 个百分点，东北地区下降 1.20 个百分点。人口向经济发达区域、城市群进一步集聚。</li><li>性别构成。男性人口为 72334 万人，占 51.24 %；女性人口为 68844 万人，占 48.76%。总人口性别比（以女性为 100，男性对女性的比例）为 105.07，与 2010 年基本持平，略有降低。出生人口性别比为 111.3，较 2010 年下降 6.8。我国人口的性别结构持续改善。</li><li>年龄构成。0—14 岁人口为 25338 万人，占 17.95%；15—59 岁人口为 89438 万人，占 63.35 %；60 岁及以上人口为 26402 万人，占 18.70%（其中，65 岁及以上人口为 19064 万人，占 13.50%）。与 2010 年相比，0—14 岁、15—59 岁、60 岁及以上人口的比重分别上升 1.35 个百分点、下降 6.79 个百分点、上升 5.44 个百分点。我国少儿人口比重回升，生育政策调整取得了积极成效。同时，人口老龄化程度进一步加深，未来一段时期将持续面临人口长期均衡发展的压力。</li><li>受教育程度人口。具有大学文化程度的人口为 21836 万人。与 2010 年相比，每 10 万人中具有大学文化程度的由 8930 人上升为 15467 人，15岁及以上人口的平均受教育年限由 9.08 年提高至 9.91 年，文盲率由 4.08%下降为 2.67%。受教育状况的持续改善反映了 10 年来我国大力发展高等教育以及扫除青壮年文盲等措施取得了积极成效，人口素质不断提高。</li><li>城乡人口。居住在城镇的人口为 90199 万人，占 63.89%；居住在乡村的人口为 50979万人，占 36.11%。与 2010 年相比，城镇人口增加 23642 万人，乡村人口减少 16436 万人，城镇人口比重上升 14.21 个百分点。随着我国新型工业化、信息化和农业现代化的深入发展和农业转移人口市民化政策落实落地，10 年来我国新型城镇化进程稳步推进，城镇化建设取得了历史性成就。</li><li>流动人口。人户分离人口为 49276 万人，其中，市辖区内人户分离人口为 11694 万人，流动人口为 37582 万人，其中，跨省流动人口为 12484 万人。与 2010 年相比，人户分离人口增长 88.52%，市辖区内人户分离人口增长 192.66%，流动人口增长 69.73%。我国经济社会持续发展，为人口的迁移流动创造了条件，人口流动趋势更加明显，流动人口规模进一步扩大。</li><li>民族人口。汉族人口为 128631 万人，占 91.11%；各少数民族人口为 12547 万人，占 8.89%。与 2010 年相比，汉族人口增长 4.93%，各少数民族人口增长 10.26%，少数民族人口比重上升 0.40 个百分点。民族人口稳步增长，充分体现了在中国共产党领导下，我国各民族全面发展进步的面貌。</li></ol><h3 id="技嘉宣称中国大陆代工制造为「低质量、低成本」"><a class="header-anchor" href="#技嘉宣称中国大陆代工制造为「低质量、低成本」"></a>技嘉宣称中国大陆代工制造为「低质量、低成本」</h3><p>2021年5月11日 事件技嘉作死</p><div class="tag link"><a class="link-card" title="【知乎】技嘉事件" href="https://www.zhihu.com/question/458796364"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/知乎icon.png"/></div><div class="right"><p class="text">【知乎】技嘉事件</p><p class="url">https://www.zhihu.com/question/458796364</p></div></a></div><details ><summary> 共青团中央动态 </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/%E5%85%B1%E9%9D%92%E5%9B%A2%E4%B8%AD%E5%A4%AEB%E7%AB%99%E6%8A%80%E5%98%89%E5%8A%A8%E6%80%81.png" alt="共青团中央B站技嘉动态"></p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/%E6%8A%80%E5%98%89%E4%BA%8B%E4%BB%B6.webp" alt="技嘉事件"></p>              </div>            </details>]]></content>
    
    
    <summary type="html">初衷用于记录我所关注的一些大事小事</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>图</title>
    <link href="http://halo123.top/2021/05/09/DataStructure/F_graph/"/>
    <id>http://halo123.top/2021/05/09/DataStructure/F_graph/</id>
    <published>2021-05-09T14:50:51.000Z</published>
    <updated>2021-05-14T11:54:11.735Z</updated>
    
    <content type="html"><![CDATA[<div class="tag link"><a class="link-card" title="C语言实现图数据结构" href="https://github.com/TheAlgorithms/C/tree/master/data_structures/graphs"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/GithubIcon.jpg"/></div><div class="right"><p class="text">C语言实现图数据结构</p><p class="url">https://github.com/TheAlgorithms/C/tree/master/data_structures/graphs</p></div></a></div><h2 id="图的基本概念"><a class="header-anchor" href="#图的基本概念"></a>图的基本概念</h2><h3 id="图的定义"><a class="header-anchor" href="#图的定义"></a>图的定义</h3><p>图 $G$ 由顶点集 $V$ 和边集 $E$ 组成，记为 $G=(V,E)$，其中 $V(G)$ 表示图 $G$ 中顶点的有限非空集；$E(G)$ 表示图 $G$ 中顶点之间的关系 （边）集合。若 $V= \{v_1,v_2,\dots v_n\}$，则用 $|V|$ 表示图 $G$ 中顶点的个数，也称图 $G$ 的阶，$E= \{(\mu,\nu)|\mu \in V,\nu \in V  \} $，用 $|E|$ 表示图 $G$ 中边的条数。</p><p>注意：线性表可以是空表，树可以是空树，但图不可以是空图。就是说，图中不能一个顶点也没有，图的顶点集 $V$ 一定非空，但边集 $E$ 可以为空，此时图中只有顶点而没有边。</p><p>下面是图的一些基本概念及术语。</p><h3 id="有向图和无向图"><a class="header-anchor" href="#有向图和无向图"></a>有向图和无向图</h3><p>若 $E$ 是有向边（也称弧）的有限集合时，则图 $G$ 为有向图。弧是顶点的有序对，记为 $ \langle v,w\rangle $ ，其中 $v$，$w$ 是顶点，$v$ 称为弧尾，$w$ 称为弧头， $\langle v, w \rangle $  称为从顶点 $v$ 到顶点 $w$ 的弧，也称 $v$ 邻接到 $w$，或 $w$ 邻接自 $v$。</p><p>若 $E$ 是无向边（简称边）的有限集合时，则图 $G$ 为无向图。边是顶点的无序对，记为 $(v,w)$ 或 $(w,v)$，因为$(v, w)=(w,v)$ 其中 $v$，$w$ 是顶点。可以说顶点 $w$ 和顶点 $v$ 互为邻接点。边 $(v, w)$ 依附于顶点 $w$ 和 $v$ ，或者说边 $(v, w)$ 和顶点 $v$，$w$ 相关联。</p><h3 id="简单图和多重图"><a class="header-anchor" href="#简单图和多重图"></a>简单图和多重图</h3><p>一个图 $G$ 若满足：</p><ol><li>不存在重复边；</li><li>不存在顶点到自身的边，则称图 $G$ 为简单图。</li></ol><p>数据结构中仅讨论简单图。</p><p>若图 $G$ 中某两个结点之间的边数多于一条，又允许顶点通过同一.条边和自己关联，则 $G$ 为多重图。多重图的定义和简单图是相对的。</p><h3 id="顶点的度、入度和出度"><a class="header-anchor" href="#顶点的度、入度和出度"></a>顶点的度、入度和出度</h3><p>图中每个顶点的度定义为以该顶点为一个端点的边的数目。</p><p>对于无向图，顶点 $v$  的度是指依附于该顶点的边的条数，记为 $\mathrm{TD} (v)$。</p><p>在具有 $n$ 个顶点、$e$ 条边的无向图中$$ \sum_{i=1}^{n} \mathrm{TD} (v_i)=2e $$即无向图的全部顶点的度的和等于边数的2倍，因为每条边和两个顶点相关联。</p><p>对于有向图，顶点 $v$ 的度分为入度和出度，入度是以顶点 $v$ 为终点的有向边的数目，记为 $\mathrm{ID}(v)$；而出度是以顶点 $v$ 为起点的有向边的数目，记为  $\mathrm{OD}(v)$。顶点 $v$ 的度等于其入度和出度之和，即 $\mathrm{TD} (v)=\mathrm{ID}(v)+\mathrm{OD}(v)$。</p><p>在具有 $n$ 个顶点、$e$ 条边的有向图中，$$\sum_{i=1}^{n} \mathrm{ID} (v_i)=\sum_{i=1}^{n} \mathrm{OD} (v_i)=e $$即有向图的全部顶点的入度之和与出度之和相等，并且等于边数。这是因为每条有向边都有一个起点和终点。</p><h3 id="路径、路径长度和回路"><a class="header-anchor" href="#路径、路径长度和回路"></a>路径、路径长度和回路</h3><p>顶点 $v_p$ 到顶点 $v_q$ 之间的一条路径是指顶点序列 $v_p,v_{i1},v_{i2},\dots ,v_{im},v_q$，当然关联的边也可以理解为路径的构成要素。</p><p>路径上边的数目称为路径长度。</p><p>第一个顶点和最后一个顶点相同的路径称为回路或环。若一个图有 $n$ 个顶点，并且有大于 $n-1$ 条边，则此图一定有环。</p><h3 id="简单路径、简单回路"><a class="header-anchor" href="#简单路径、简单回路"></a>简单路径、简单回路</h3><p>在路径序列中，顶点不重复出现的路径称为简单路径。</p><p>除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路称为简单回路。</p><h3 id="距离"><a class="header-anchor" href="#距离"></a>距离</h3><p>从顶点 $u$ 出发到顶点 $v$ 的最短路径若存在，则此路径的长度称为从 $u$ 到 $v$ 的距离；若从 $u$ 到 $v$ 根本不存在路径，则记该距离为无穷( $∞$ )</p><h3 id="连通、连通图"><a class="header-anchor" href="#连通、连通图"></a>连通、连通图</h3><p>在无向图中，若从顶点 $v$ 到顶点 $w$ 有路径存在，则称 $v$ 和 $w$ 是连通的。若图 $G$ 中任意两个顶点都是连通的，则称图 $G$ 为<font color="#ea66a6">连通图</font>，否则称为非连通图。</p><p>若图 $G$ 是连通图，则至少有 $n-1$ 条边。若 $G$ 是非连通图，则至多可能有 $C_{n-1}^{2}$ 条边</p><h3 id="强连通图"><a class="header-anchor" href="#强连通图"></a>强连通图</h3><p>在有向图中，若从顶点 $v$ 到顶点 $w$ 和从顶点 $w$ 到顶点 $v$ 之间都有路径，则称这两个顶点是强连通的。若图中任何一对顶点都是强连通的，则称此图为强连通图。</p><p>若 $G$ 是强连通图，则最少有 $n$ 条边（形成回路）</p><p>注意：强连通图、强连通分量只是针对有向图而言的。一般在无向图中讨论连通性，在有向图中考虑强连通性。</p><h3 id="子图"><a class="header-anchor" href="#子图"></a>子图</h3><p>设有两个图 $G=(V,E)$ 和 $G’=(V’,E’)$ ，若 $V’$ 是 $V$ 的子集，且 $E’$ 是 $E$ 的子集，则称 $G’$ 是 $G$ 的子图。若有满足 $V(G’)=V(G)$ 的子图 $G’$ ，则称其为 $G$ 的生成子图。</p><p>注意：并非 $V$ 和 $E$ 的任何子集都能构成 $G$ 的子图，因为这样的子集可能不是图，即 $E$ 的子集中的某些边关联的顶点可能不在这个 $V$ 的子集中。</p><h3 id="连通分量、强连通分量"><a class="header-anchor" href="#连通分量、强连通分量"></a>连通分量、强连通分量</h3><p>无向图中的极大连通子图称为连通分量。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E6%97%A0%E5%90%91%E5%9B%BE%E5%8F%8A%E5%85%B6%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F.png" alt="无向图及其连通分量"></p><p>有向图中的极大强连通子图称为有向图的强连通分量。</p><blockquote><p>注意：要区分极大连通子图和极小连通子图，极大连通子图是无向图的连通分量，极大即要求该连通子图包含其所有的边；极小连通子图是既要保持图连通又要使得边数最少的子图。</p></blockquote><h3 id="生成树、生成森林"><a class="header-anchor" href="#生成树、生成森林"></a>生成树、生成森林</h3><p>连通图的生成树是包含图中全部顶点的一个极小连通子图。若图中顶点数为 $n$ ，则它的生成树含有 $n-1$ 条边。</p><p>对生成树而言，若砍去它的一条边，则会变成非连通图，若加上一条边则会形成一个回路。</p><p>在非连通图中，连通分量的生成树构成了非连通图的生成森林。</p><h3 id="边的权和网"><a class="header-anchor" href="#边的权和网"></a>边的权和网</h3><p>在一个图中，每条边都可以标上具有某种含义的数值，该数值称为该边的权值。这种边上带有权值的图称为带权图，也称网。</p><p>带权路径长度：当图是带权图时，一条路径上所有边的权值之和，称为该路径的带权路径长度</p><h3 id="完全图"><a class="header-anchor" href="#完全图"></a>完全图</h3><p>无向完全图：无向图中任意两个顶点之间都存在边，若无向图的顶点数 $|V|=n$ ，则 $|E|\in [0,C_n^2]=[0,\frac{n(n-1)}{2} ] $</p><p>有向完全图：有向图中任意两个顶点之间都存在方向相反的两条弧，若有向图的顶点数 $|V|=n$ ，则 $|E|\in [0,2C_n^2]=[0,n(n-1) ] $</p><h3 id="稠密图、稀疏图"><a class="header-anchor" href="#稠密图、稀疏图"></a>稠密图、稀疏图</h3><p>边数很少的图称为稀疏图，反之称为稠密图。</p><p>稀疏和稠密本身是模糊的概念，稀疏图和稠密图常常是相对而言的。一般当图 $G$ 满足 $|E| &lt; |V|\log|V|$ 时，可以将 $G$ 视为稀疏图。</p><h3 id="树、有向树"><a class="header-anchor" href="#树、有向树"></a>树、有向树</h3><p>树：不存在回路，且连通的无向图。$n$ 个顶点的树，必有 $n-1$ 条边。</p><p>一个顶点的入度为0，其余顶点的入度均为 1 的有向图，称为有向树。</p><h2 id="图的存储及基本操作"><a class="header-anchor" href="#图的存储及基本操作"></a>图的存储及基本操作</h2><h3 id="邻接矩阵法"><a class="header-anchor" href="#邻接矩阵法"></a>邻接矩阵法</h3><p>所谓邻接矩阵存储，是指用一个一维数组存储图中顶点的信息，用一个二维数组存储图中边的信息（即各顶点之间的邻接关系），存储顶点之间邻接关系的二维数组称为邻接矩阵。</p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/有向图、无向图及网的邻接矩阵.png" alt="有向图、无向图及网的邻接矩阵" style="zoom:200%;" /><p>图的邻接矩阵存储结构定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertexNum 100  <span class="comment">// 顶点数目的最大值</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VertexType;  <span class="comment">// 顶点的数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> EdgeType;     <span class="comment">// 带权图中边上权值的数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    VertexType Vex[MaxVertexNum];               <span class="comment">// 顶点表</span></span><br><span class="line">    EdgeType Edge[MaxVertexNum][MaxVertexNum];  <span class="comment">// 邻接矩阵，边表</span></span><br><span class="line">    <span class="keyword">int</span> vexnum, arcnum;  <span class="comment">// 图的当前顶点数和边数/弧数</span></span><br><span class="line">&#125; MGraph;</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>在简单应用中，可直接用二维数组作为图的邻接矩阵（顶点信息等均可省略）。</li><li>当邻接矩阵中的元素仅表示相应的边是否存在时，<code>EdgeType</code> 可定义为值为 0 和 1 的枚举类型。</li><li>无向图的邻接矩阵是<font color="#faa755">对称矩阵</font>，对规模特大的邻接矩阵可采用<a href="http://halo123.top/2021/05/02/DataStructure/C_StacksAndQueues/#%E5%AF%B9%E7%A7%B0%E7%9F%A9%E9%98%B5">压缩存储</a>。</li><li>邻接矩阵表示法的空间复杂度为 $O(n^2)$，其中 $n$ 为图的顶点数 $|V|$。</li></ol><p>图的邻接矩阵存储表示法具有以下特点：</p><ol><li>对于无向图，邻接矩阵的第 $i$ 行（或第 $i$ 列）非零元素（或非 $∞$ 元素）的个数正好是第 $i$ 个顶点的度 $TD(v)$。时间复杂度 $O(|V|)$。</li><li>对于有向图，邻接矩阵的第 $i$ 行（或第 $i$ 列）非零元素（或非 $∞$ 元素）的个数正好是第 $i$ 个顶点的出度 $OD(v)$ [或入度 $ID(v)$ ]。第 $i$ 行结点的度即为，第 $i$ 行和列的非零元素（或非 $∞$ 元素）的个数之和。时间复杂度 $O(|V|)$。</li><li>设图 $G$ 的邻接矩阵为 $\mathbf{A} $，$\mathbf{A}^n$ 的元素  $A^n[i][j]$ 等于由顶点 $i$ 到顶点 $j$ 的长度为 $n$ 的路径的数目。（妙啊）</li><li>稠密图适合使用邻接矩阵的存储表示。</li><li>无向图的邻接矩阵一定是一个对称矩阵（并且唯一）。 因此，在实际存储邻接矩阵时只需存储上（或下）三角矩阵的元素。</li><li>用邻接矩阵法存储图，很容易确定图中任意两个顶点之间是否有边相连。但是，要确定图中有多少条边，则必须按行、按列对每个元素进行检测，所花费的时间代价很大。</li></ol><h3 id="邻接表法"><a class="header-anchor" href="#邻接表法"></a>邻接表法</h3><p>当一个图为稀疏图时，使用邻接矩阵法显然要浪费大量的存储空间，而图的邻接表法结合了顺序存储和链式存储方法，大大减少了这种不必要的浪费。</p><p>所谓邻接表，是指对图 $G$ 中的每个顶点 $v_i$ 建立一个单链表，第 $i$ 个单链表中的结点表示依附于顶点 $v_i$ 的边（对于有向图则是以顶点 $v_i$ 为尾的弧），这个单链表就称为顶点 $v_i$ 的边表（对于有向图则称为出边表）。边表的头指针和顶点的数据信息采用顺序存储（称为顶点表），所以在邻接表中存在两种结点：顶点表结点和边表结点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertexNum 100 <span class="comment">// 图中顶点数目的最大值</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VertexType;  <span class="comment">// 顶点的数据类型</span></span><br><span class="line"><span class="comment">// &quot;边/弧&quot;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> adjvex;            <span class="comment">// &quot;边/弧&quot;指向哪个结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">next</span>;</span>  <span class="comment">// 指向下一条弧的指针</span></span><br><span class="line">    <span class="comment">// InfoType info       // 边权值</span></span><br><span class="line">&#125; ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;顶点&quot;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span> &#123;</span></span><br><span class="line">    VertexType data;  <span class="comment">// 顶点信息</span></span><br><span class="line">    ArcNode *first;   <span class="comment">// 第一条边/弧</span></span><br><span class="line">&#125; VNode, AdjList[MaxVertexNum];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用邻接表存储的图</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    AdjList vertices;</span><br><span class="line">    <span class="keyword">int</span> vexnum, arcnum;</span><br><span class="line">&#125; ALGraph;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E6%97%A0%E5%90%91%E5%9B%BE%E9%82%BB%E6%8E%A5%E8%A1%A8%E8%A1%A8%E7%A4%BA%E6%B3%95%E5%AE%9E%E4%BE%8B.png" alt="无向图邻接表表示法实例"></p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E6%9C%89%E5%90%91%E5%9B%BE%E9%82%BB%E6%8E%A5%E8%A1%A8%E8%A1%A8%E7%A4%BA%E6%B3%95%E5%AE%9E%E4%BE%8B.png" alt="有向图邻接表表示法实例"></p><p>图的邻接表存储方法具有以下特点：</p><ol><li>若 $G$ 为无向图，则所需的存储空间为 $O(|V|+ 2|E|)$；若 $G$ 为有向图，则所需的存储空间为 $O(|V|+ |E|)$。前者的倍数 2 是由于无向图中，每条边在邻接表中出现了两次。</li><li>对于稀疏图，采用邻接表表示将极大地节省存储空间。</li><li>在邻接表中，给定一顶点，能很容易地找出它的所有邻边，因为只需要读取它的邻接表。在邻接矩阵中，相同的操作则需要扫描一行，花费的时间为 $O(n)$ 。 但是，若要确定给定的两个顶点间是否存在边，则在邻接矩阵中可以立刻查到，而在邻接表中则需要在相应结点对应的边表中查找另一结点，效率较低。</li><li>在有向图的邻接表表示中，求一个给定顶点的<font color="#faa755">出度</font>只需计算其邻接表中的结点个数；但求其顶点的<font color="#faa755">入度</font>则需要遍历全部的邻接表。因此，也有人采用逆邻接表的存储方式来加速求解给定顶点的入度。当然，这实际上与邻接表存储方式是类似的。</li><li>图的邻接表表示并不唯一，因为在每个项点对应的单链表中，各边结点的链接次序可以是任意的，它取决于建立邻接表的算法及边的输入次序。</li></ol><h3 id="十字链表法"><a class="header-anchor" href="#十字链表法"></a>十字链表法</h3><p>十字链表是<font color="#faa755">有向图</font>的一种链式存储结构。在十字链表中，对应于有向图中的每条弧有一个结点，对应于每个顶点也有一个结点。</p><p>弧结点中有 5 个域：尾域（<code>tailvex</code>） 和头域（<code>headvex</code>）分别指示弧尾和弧头这两个顶点在图中的位置；链域 <code>hlink</code> 指向弧头相同的下一条弧；链域 <code>tlink</code> 指向弧尾相同的下一条弧；<code>info</code> 域指向该弧的相关信息。这样，弧头相同的弧就在同一个链表上，弧尾相同的弧也在同一个链表上。</p><p>顶点结点中有 3 个域：<code>data</code> 域存放顶点相关的数据信息，如顶点名称；<code>firstin</code> 和 <code>firstout</code> 两个域分别指向以该顶点为弧头或弧尾的第一个弧结点。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8%E8%A1%A8%E7%A4%BA.png" alt="有向图的十字链表表示"></p><p>在十字链表中，既容易找到 $V_i$ 为尾的弧，又容易找到 $V_i$ 为头的弧，因而容易求得顶点的出度和入度。图的十字链表表示是不唯一的， 但一个十字链表表示确定一个 图。空间复杂度：$O(|V|+|E|)$</p><p>TODO 代码实现十字链表法</p><h3 id="邻接多重表法"><a class="header-anchor" href="#邻接多重表法"></a>邻接多重表法</h3><p>邻接多重表是<font color="#faa755">无向图</font>的另一种链式存储结构。</p><p>在邻接表中，容易求得顶点和边的各种信息，但在邻接表中求两个顶点之间是否存在边而对边执行删除等操作时，需要分别在两个顶点的边表中遍历，效率较低。</p><p>与十字链表类似，在邻接多重表中，每条边用一个结点表示，其结构如下所示。</p><p>其中，<code>mark</code> 为标志域，可用以标记该条边是否被搜索过；<code>ivex</code> 和 <code>jvex</code> 为该边依附的两个顶点在图中的位置；<code>ilink</code> 指向下一条依附于顶点 <code>ivex</code> 的边；<code>jlink</code> 指向下一条依附于顶点 <code>jvex</code> 的边，<code>info</code> 为指向和边相关的各种信息的指针域。</p><p>每个顶点也用一个结点表示，它由如下所示的两个域组成。</p><p>其中，<code>data</code> 域存储该顶点的相关信息，<code>firstedge</code> 域指示第一条依附于该顶点的边。</p><p>在邻接多重表中，所有依附于同一顶点的边串联在同一链表中，由于每条边依附于两个顶点，因此每个边结点同时链接在两个链表中。对无向图而言，其邻接多重表和邻接表的差别仅在于，同一条边在邻接表中用两个结点表示，而在邻接多重表中只有一个结点。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8%E8%A1%A8%E7%A4%BA.png" alt="无向图的邻接多重表表示"></p><p>空间复杂度：$O(|V|+|E|)$。</p><h3 id="图的基本操作"><a class="header-anchor" href="#图的基本操作"></a>图的基本操作</h3><p>图的基本操作是独立于图的存储结构的。而对于不同的存储方式，操作算法的具体实现会有着不同的性能。在设计具体算法的实现时，应考虑采用何种存储方式的算法效率会更高。</p><p>图的基本操作主要包括（仅抽象地考虑，故忽略掉各变量的类型）：</p><ul><li><code>Adjacent (G,x,y)</code>：判断图 $G$ 是否存在边  $ \langle x,y \rangle $  或 $(x,y)$。邻接矩阵时间复杂度：$O(1)$，邻接表时间复杂度：$O(1)\sim  O(|V|)$。</li><li><code>Neighbors (G,x)</code>：列出图 $G$ 中与结点 $x$ 邻接的边。邻接矩阵时间复杂度：$O(|V|)$；邻接表无向图时间复杂度：$O(1)\sim  O(|V|)$，邻接表有向图出边时间复杂度：$O(1)\sim O(|V|)$，邻接表有向图入边时间复杂度：$O(|E|)$。</li><li><code>InsertVertex(G,x)</code>：在图 $G$ 中插入顶点 $x$ 。邻接矩阵和邻接表时间复杂度：$O(1)$</li><li><code>DeleteVertex(G,x)</code>：从图 $G$ 中删除顶点 $x$。邻接矩阵无向图时间复杂度：$O(|V|)$，邻接表无向图时间复杂度：$O(1)\sim O(|E|)$；邻接矩阵有向图时间复杂度：$O(|V|)$，邻接表删出边：$O(1)\sim O(|V|)$，邻接表删入边：$O(|E|)$</li><li><code>AddEdge (G,x,y)</code>：若无向边 $(x, y)$ 或有向边 $ \langle x,y \rangle $ 不存在，则向图 $G$ 中添加该边。邻接矩阵 $O(1)$，邻接表 $O(1)$</li><li><code>RemoveEdge(G,x,y)</code>：若无向边 $(x, y)$ 或有向边 $ \langle x,y \rangle $ 存在，则从图 $G$ 中删除该边。邻接矩阵 $O(1)$，邻接表 $O(1) \sim O(|V|)$</li><li><code>FirstNeighbor(G,x)</code>：求图 $G$ 中顶点 $x$ 的第一个邻接点，若有则返回顶点号。若 $x$ 没有邻接点或图中不存在 $x$ ，则返回 -1。邻接矩阵无向图 $O(1)\sim O(|V|)$，邻接表无向图 $O(1)$；邻接矩阵有向图 $O(1)\sim O(|V|)$，邻接表有向图找出边邻接点：$O(1)$，邻接表有向图找入边邻接点：$O(1)\sim O(|E|)$</li><li><code>NextNeighbor (G,x,y)</code>：假设图 $G$ 中顶点 $y$ 是顶点 $x$ 的一个邻接点，返回除 $y$ 外顶点 $x$ 的下一个邻接点的顶点号，若 $y$ 是 $x$ 的最后一个邻接点，则返回 -1。邻接矩阵 $O(1)\sim O(|V|)$，邻接表 $O(1)$；</li><li><code>Get_edge_value(G,x,y)</code>：获取图 $G$ 中边 $(x, y)$ 或 $ \langle x,y \rangle $ 对应的权值。时间复杂度同 <code>Adjacent (G,x,y)</code></li><li><code>Set_edge_value(G,x,y,v)</code>：设置图 $G$ 中边 $(x, y)$ 或 $ \langle x,y \rangle $ 对应的权值为 $v$ 。时间复杂度同 <code>Adjacent (G,x,y)</code></li></ul><p>此外，还有图的遍历算法：按照某种方式访问图中的每个顶点且仅访问一次。图的遍历算法包括深度优先遍历和广度优先遍历。</p><p>TODO 分析十字链表法和邻接多重表法下的基本操作的时间复杂度</p><h2 id="图的遍历"><a class="header-anchor" href="#图的遍历"></a>图的遍历</h2><p>图的遍历是指从图中的某一顶点出发，按照某种搜索方法沿着图中的边对图中的所有顶点访问一次且仅访问一次。注意到树是一种特殊的图，所以树的遍历实际上也可视为一种特殊的图的遍历。图的遍历算法是求解图的连通性问题、拓扑排序和求关键路径等算法的基础。</p><p>图的遍历比树的遍历要复杂得多，因为图的任一顶点都可能和其余的顶点相邻接，所以在访问某个顶点后，可能沿着某条路径搜索又回到该顶点上。为避免同一顶点被访问多次，在遍历图的过程中，必须记下每个已访问过的顶点，为此可以设一个辅助数组 <code>visited[]</code> 来标记顶点是否被访问过。图的遍历算法主要有两种：广度优先搜索和深度优先搜索。</p><h3 id="广度优先搜索"><a class="header-anchor" href="#广度优先搜索"></a>广度优先搜索</h3><p>广度优先搜索（Breadth-First- Search, BFS）类似于二叉树的层序遍历算法。基本思想是：首先访问起始顶点 $v$ ，接着由 $v$ 出发，依次访问 $v$ 的各个未访问过的邻接顶点 $w_1,w_2,\dots ,w_i$ 然后依次访问 $w_1,w_2,\dots ,w_i$ 的所有未被访问过的邻接顶点；再从这些访问过的顶点出发，访问它们所有未被访问过的邻接顶点，直至图中所有顶点都被访问过为止。若此时图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作为始点，重复上述过程，直至图中所有顶点都被访问到为止。Dijkstra 单源最短路径算法和 Prim 最小生成树算法也应用了类似的思想。</p><p>换句话说，广度优先搜索遍历图的过程是以 $v$ 为起始点，由近至远依次访问和 $v$ 有路径相通且路径长度为 1，2，… 的顶点。广度优先搜索是一种分层的查找过程，每向前走一步可能访问一批顶点，不像深度优先搜索那样有往回退的情况，因此它不是一个递归的算法。为了实现逐层的访问，算法必须<font color="#faa755">借助一个辅助队列</font>，以记忆正在访问的顶点的下一层顶点。</p><p>广度优先遍历算法的伪代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> visited[MaxVertexNum];  <span class="comment">// 访问标记数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverse</span><span class="params">(Graph G)</span> </span>&#123;  <span class="comment">// 对图G进行广度优先遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i) &#123;</span><br><span class="line">        visited[i] = <span class="literal">false</span>;  <span class="comment">// 访问标记数组初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">InitQueue</span>(Q);                         <span class="comment">// 初始化辅助队列Q</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G.vexnum; ++j) &#123;  <span class="comment">// 从0号顶点开始遍历</span></span><br><span class="line">        <span class="keyword">if</span> (!visited[j]) &#123;  <span class="comment">// 对每个连通分量调用一次 BFS</span></span><br><span class="line">            <span class="built_in">BFS</span>(G, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//广度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Graph G, <span class="keyword">int</span> v)</span> </span>&#123;  <span class="comment">//从顶点v出发，广度优先遍历图G</span></span><br><span class="line">    <span class="built_in">visit</span>(v);               <span class="comment">//访问初始顶点v</span></span><br><span class="line">    visited[v] = <span class="literal">true</span>;      <span class="comment">//对v做已访问标记</span></span><br><span class="line">    <span class="built_in">Enqueue</span>(Q, v);          <span class="comment">//顶点v入队列Q</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isEmpty</span>(Q)) &#123;</span><br><span class="line">        <span class="built_in">DeQueue</span>(Q, v);  <span class="comment">//顶点v出队列</span></span><br><span class="line">        <span class="keyword">for</span> (w = <span class="built_in">FirstNeighbor</span>(G, v); w &gt;= <span class="number">0</span>; w = <span class="built_in">NextNeighbor</span>(G, v, w)) &#123;</span><br><span class="line">            <span class="comment">//检测v所有邻接点</span></span><br><span class="line">            <span class="keyword">if</span> (!visited[w]) &#123;      <span class="comment">// w为v的尚未访问的邻接顶点</span></span><br><span class="line">                <span class="built_in">visit</span>(w);           <span class="comment">//访问顶点w</span></span><br><span class="line">                visited[w] = <span class="literal">true</span>;  <span class="comment">//对w做已访问标记</span></span><br><span class="line">                <span class="built_in">EnQueue</span>(Q, w);      <span class="comment">//顶点w入队列</span></span><br><span class="line">            &#125;<span class="comment">// if</span></span><br><span class="line">        &#125;<span class="comment">// for</span></span><br><span class="line">    &#125;<span class="comment">// while</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>同一个图的邻接矩阵表示方式唯一，因此广度优先历序列唯一</li><li>同一个图邻接表表示方式不唯一，因此广度优先遍历序列不唯一</li></ul><p>辅助数组 <code>visited[]</code> 标志顶点是否被访问过，其初始状态为 <code>false</code> 。在图的遍历过程中，一旦某个顶点 $v_i$ 被访问，就立即置 <code>visited[i]</code> 为 <code>true</code> ，防止它被多次访问。</p><p>图的广度优先搜索的过程与二叉树的层序遍历是完全一致的， 这也说明了图的广度优先搜索遍历算法是二叉树的层次遍历算法的扩展。图的广度优先遍历还可用于求一些问题的最优解,</p><h4 id="BFS-算法的性能分析"><a class="header-anchor" href="#BFS-算法的性能分析"></a>BFS 算法的性能分析</h4><p>无论是邻接表还是邻接矩阵的存储方式，BFS 算法都需要借助一个辅助队列 <code>Q</code>，$n$ 个顶点均需入队一次，在最坏的情况下，空间复杂度为 $O(|V|)$ 。</p><p>采用邻接表存储方式时，每个顶点均需搜索一次（或入队一次）， 故时间复杂度为 $O(|V|)$ ，在搜索任一顶点的邻接点时，每条边至少访问一次，故时间复杂度为 $O(|E|)$ ， 算法总的时间复杂度为 $O(|V|+|E|)$。采用邻接矩阵存储方式时，查找每个顶点的邻接点所需的时间为 $O(|V|)$ ，故算法总的时间复杂度为 $O(|V|^2)$ 。</p><h4 id="广度优先生成树"><a class="header-anchor" href="#广度优先生成树"></a>广度优先生成树</h4><p>在广度遍历的过程中，我们可以得到一棵遍历树，称为广度优先生成树。需要注意的是，一给定图的邻接矩阵存储表示是唯一的，故其广度优先生成树也是唯一的，但由于邻接表存储表示不唯一， 故其广度优先生成树也是不唯一的。</p><h3 id="深度优先搜索"><a class="header-anchor" href="#深度优先搜索"></a>深度优先搜索</h3><p>与广度优先搜索不同，深度优先搜索（Depth-First-Search，DFS）类似于树的先序遍历。如其名称中所暗含的意思一样，这种搜索算法所遵循的搜索策略是尽可能“深”地搜索一个图。</p><p>它的基本思想如下：首先访问图中某一起始顶点 $v$ ，然后由 $v$ 出发，访问与 $v$ 邻接且未被访问的任一顶点 $w_1$，再访问与 $w_1$ 邻接且未被访问的任一顶点 $w_2$ …… 重复上述过程。当不能再继续向下访问时，依次退回到最近被访问的顶点，若它还有邻接顶点未被访问过，则从该点开始继续上述搜索过程，直至图中所有顶点均被访问过为止。</p><p>一般情况下，其递归形式的算法十分简洁，算法过程如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> visited[MaxVertexNum];  <span class="comment">// 访问标记数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">(Graph G)</span> </span>&#123;  <span class="comment">// 对图 G 进行深度优先遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.vexnum; ++v) &#123;</span><br><span class="line">        visited[v] = <span class="literal">false</span>;  <span class="comment">// 初始化已访问标记数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.vexnum; ++v) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[v]) &#123;</span><br><span class="line">            <span class="built_in">DFS</span>(G, v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Graph G, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">visit</span>(v);           <span class="comment">// 访问顶点 v</span></span><br><span class="line">    visited[v] = <span class="literal">true</span>;  <span class="comment">// 设已访问标记</span></span><br><span class="line">    <span class="keyword">for</span> (w = <span class="built_in">FirstNeighbor</span>(G, v); w &gt;= <span class="number">0</span>; w = <span class="built_in">NextNeighor</span>(G, v, w)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[w]) &#123;  <span class="comment">// w 为 u 的尚未访问的邻接顶点</span></span><br><span class="line">            <span class="built_in">DFS</span>(G, w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：图的邻接矩阵表示是唯一的，但对于邻接表来说，若边的输入次序不同，生成的邻接表也不同。因此，对于同样一个图，基于邻接矩阵的遍历所得到的 DFS 序列和 BFS 序列是唯一的，基于邻接表的遍历所得到的 DFS 序列和 BFS 序列是不唯一的。</p><h4 id="DFS-算法的性能分析"><a class="header-anchor" href="#DFS-算法的性能分析"></a>DFS 算法的性能分析</h4><p>DFS 算法是一个递归算法，需要借助一个递归工作栈，故其空间复杂度为 $O(|V|)$。</p><p>遍历图的过程实质上是对每个顶点查找其邻接点的过程，其耗费的时间取决于所用的存储结构。以邻接矩阵表示时，查找每个顶点的邻接点所需的时间为 $O(|V|)$ ，故总的时间复杂度为 $O(|V|^2)$。以邻接表表示时，查找所有顶点的邻接点所需的时间为 $O(E)$，访问顶点所需的时间为 $O(|V|)$，此时，总的时间复杂度为 $O(|V|+|E|)$ 。</p><h4 id="深度优先的生成树和生成森林"><a class="header-anchor" href="#深度优先的生成树和生成森林"></a>深度优先的生成树和生成森林</h4><p>与广度优先搜索一样，深度优先搜索也会产生一棵深度优先生成树。当然，这是有条件的，即对连通图调用 DFS 才能产生深度优先生成树，否则产生的将是深度优先生成森林。与BFS类似，基于邻接表存储的深度优先生成树是不唯一的。</p><h3 id="图的遍历与图的连通性"><a class="header-anchor" href="#图的遍历与图的连通性"></a>图的遍历与图的连通性</h3><p>图的遍历算法可以用来判断图的连通性。</p><p>对于无向图来说，若无向图是连通的，则从任一结点出发，仅需一次遍历就能够访问图中的所有顶点；若无向图是非连通的，则从某一个 顶点出发，一次遍历只能访问到该顶点所在连通分量的所有顶点，而对于图中其他连通分量的顶点，则无法通过这次遍历访问。对于有向图来说，若从初始点到图中的每个顶点都有路径，则能够访问到图中的所有顶点，否则不能访问到所有顶点。</p><p>故在 <code>BFSTraverse()</code> 或 <code>DFSTraverse()</code> 中添加了第二个 for 循环，再选取初始点，继续进行遍历，以防止一次无法遍历图的所有顶点。对于无向图，上述两个函数调用 <code>BFS(G,i)</code> 或 <code>DFS(G,i)</code> 的次数等于该图的连通分量数；而对于有向图则不是这样，因为一个连通的有向图分为强连通的和非强连通的，它的连通子图也分为强连通分量和非强连通量，非强连通分量一次调用 <code>BFS(G,i)</code> 或 <code>DFS(G, i)</code> 无法访问到该连通分量的所有顶点。</p><h2 id="图的应用"><a class="header-anchor" href="#图的应用"></a>图的应用</h2><p>本节是历年考查的重点。图的应用主要包括：最小生成（代价）树、最短路径、拓扑排序和关键路径。一般而言，这部分内容直接以算法设计题形式考查的可能性很小，而更多的是结合图的实例来考查算法的具体操作过程，读者必须学会手工模拟给定图的各个算法的执行过程。此外，还需掌握对给定模型建立相应的图去解决问题的方法。</p><h3 id="最小生成树"><a class="header-anchor" href="#最小生成树"></a>最小生成树</h3><p>一个连通图的生成树包含图的所有顶点，并且只含尽可能少的边。对于生成树来说，若砍去它的一条边，则会使生成树变成非连通图；若给它增加一条边， 则会形成图中的一条回路。</p><p>对于一个带权连通无向图 $G=(V, E)$，生成树不同，每棵树的权（即树中所有边上的权值之和）也可能不同。设 $R$ 为 $G$ 的所有生成树的集合，若 $T$ 为 $R$ 中边的权值之和最小的那棵生成树，则 $T$ 称为 $G$ 的<font color="#ea66a6">最小生成树</font>（Minimum-Spanning-Tree, MST）。</p><p>不难看出，最小生成树具有如下性质：</p><ol><li>最小生成树不是唯一的，即最小生成树的树形不唯一，$R$ 中可能有多个最小生成树。当图 $G$ 中的各边权值互不相等时， $G$ 的最小生成树是唯一的；若无向连通图 $G$ 的边数比顶点数少1，即 $G$ 本身是一棵树时，则 $G$ 的最小生成树就是它本身。</li><li>最小生成树的边的权值之和总是唯一的， 虽然最小生成树不唯一，但其对应的边的权值之和总是唯一的，而且是最小的。</li><li>最小生成树的边数为顶点数减 1。</li></ol><p>构造最小生成树有多种算法，但大多数算法都利用了最小生成树的下列性质：假设 $G=(V, E)$ 是一个带权连通无向图，$U$ 是顶点集 $V$ 的一个非空子集。若 $(u, v)$ 是一条具有最小权值的边，其中 $u\in U$，$v \in V-U$，则必存在一棵包含边 $(u, v)$ 的最小生成树。</p><p>基于该性质的最小生成树算法主要有 Prim 算法和 Kruskal 算法，它们都基于贪心算法的策略。对这两种算法应主要掌握算法的本质含义和基本思想，并能够手工模拟算法的实现步骤。</p><h4 id="Prim-算法"><a class="header-anchor" href="#Prim-算法"></a>Prim 算法</h4><p>Prim（普里姆）算法的执行非常类似于寻找图的最短路径的 Djkstra 算法。</p><p>Prim算法构造最小生成树的过程如下图所示。初始时从图中任取一顶点（如顶点1）加入树 $T$，此时树中只含有一个顶点，之后选择一个与当前 $T$ 中顶点集合距离最近的顶点，并将该顶点和相应的边加入$T$，每次操作后 $T$ 中的顶点数和边数都增1。以此类推，直至图中所有的顶点都并入 $T$，得到的 $T$ 就是最小生成树。此时 $T$ 中必然有 $n-1$ 条边。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/Prim%E7%AE%97%E6%B3%95%E6%9E%84%E9%80%A0%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="Prim算法构造最小生成树的过程"></p><p>Prim 算法的步骤如下：</p><ul><li>假设 $G= \{V, E\}$ 是连通图，其最小生成树 $T=(U,E_T)$，$E_T$ 是最小生成树中边的集合。</li><li>初始化：向空树 $T= (U, E_T)$ 中添加图 $G=(V, E)$ 的任一顶点 $u_0$，使 $U= \{u_0\}$ ，$E_T=\varnothing $。</li><li>循环（重复下列操作直至 $U=V$）：从图 $G$ 中选择满足 $\{(u, v)|u \in U, v \in V-U\}$ 且具有最小权值的边 $(u,v)$ 加入树 $T$，置 $U=U\cup \{ v\}$，$E_T= E_T \cup \{(u,v) \}$。</li></ul><p>Prim 算法的时间复杂度为 $O(|V|^2)$，不依赖于 $|E|$，因此它适用于求解<font color="#faa755">边稠密</font>的图的最小生成树。虽然采用其他方法能改进 Prim 算法的时间复杂度，但增加了实现的复杂性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ program to implement Prim&#x27;s Algorithm</span></span><br><span class="line"><span class="comment">// https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/graph/prim.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> PII = std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">const</span> std::vector&lt;std::vector&lt;PII&gt; &gt; &amp;graph)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// priority queue to maintain edges with respect to weights</span></span><br><span class="line">    std::priority_queue&lt;PII, std::vector&lt;PII&gt;, std::greater&lt;PII&gt; &gt; Q;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">bool</span>&gt; <span class="title">marked</span><span class="params">(graph.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> minimum_cost = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Q.<span class="built_in">push</span>(std::<span class="built_in">make_pair</span>(<span class="number">0</span>, x));</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// Select the edge with minimum weight</span></span><br><span class="line">        PII p = Q.<span class="built_in">top</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        x = p.second;</span><br><span class="line">        <span class="comment">// Checking for cycle</span></span><br><span class="line">        <span class="keyword">if</span> (marked[x] == <span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        minimum_cost += p.first;</span><br><span class="line">        marked[x] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> PII &amp;neighbor : graph[x]) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = neighbor.second;</span><br><span class="line">            <span class="keyword">if</span> (marked[y] == <span class="literal">false</span>) &#123;</span><br><span class="line">                Q.<span class="built_in">push</span>(neighbor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minimum_cost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nodes = <span class="number">0</span>, edges = <span class="number">0</span>;</span><br><span class="line">    std::cin &gt;&gt; nodes &gt;&gt; edges;  <span class="comment">// number of nodes &amp; edges in graph</span></span><br><span class="line">    <span class="keyword">if</span> (nodes == <span class="number">0</span> || edges == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::vector&lt;PII&gt; &gt; <span class="built_in">graph</span>(nodes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Edges with their nodes &amp; weight</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>, weight = <span class="number">0</span>;</span><br><span class="line">        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; weight;</span><br><span class="line">        graph[x].<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(weight, y));</span><br><span class="line">        graph[y].<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(weight, x));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Selecting 1 as the starting node</span></span><br><span class="line">    <span class="keyword">int</span> minimum_cost = <span class="built_in">prim</span>(<span class="number">1</span>, graph);</span><br><span class="line">    std::cout &lt;&lt; minimum_cost &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6</span></span><br><span class="line">    <span class="comment">// 10</span></span><br><span class="line">    <span class="comment">// 0 1 6</span></span><br><span class="line">    <span class="comment">// 0 2 5</span></span><br><span class="line">    <span class="comment">// 0 3 1</span></span><br><span class="line">    <span class="comment">// 1 3 5</span></span><br><span class="line">    <span class="comment">// 1 4 3</span></span><br><span class="line">    <span class="comment">// 2 3 4</span></span><br><span class="line">    <span class="comment">// 4 5 6</span></span><br><span class="line">    <span class="comment">// 3 5 4</span></span><br><span class="line">    <span class="comment">// 2 5 2</span></span><br><span class="line">    <span class="comment">// 3 4 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Kruskal-算法"><a class="header-anchor" href="#Kruskal-算法"></a>Kruskal 算法</h4><p>与 Prim 算法从顶点开始扩展最小生成树不同，Kruskal （克鲁斯卡尔）算法是一种按权值的递增次序选择合适的边来构造最小生成树的方法。</p><p>Kruskal 算法构造最小生成树的过程如下图所示。初始时为只有 $n$ 个顶点而无边的非连通图 $T= \{V, \{\}\}$，每个顶点自成一个连通分量，然后按照边的权值由小到大的顺序，不断选取当前未被选取过且权值最小的边，若该边依附的顶点落在 $T$ 中不同的连通分量上，则将此边加入 $T$ ，否则舍弃此边而选择下一条权值最小的边。以此类推，直至 $T$ 中所有顶点都在一个连通<br>分量上。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/Kruskal%E7%AE%97%E6%B3%95%E6%9E%84%E9%80%A0%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="Kruskal算法构造最小生成树的过程"></p><p>Kruskal算法的步骤如下：</p><ul><li>假设 $G=(V, E)$ 是连通图，其最小生成树 $T=(U, E_T)$。</li><li>初始化：$U=V$，$E_T=\varnothing$。即每个顶点构成一棵独立的树，$T$ 此时是一个仅含 $|V|$ 个顶点的森林。</li><li>循环（重复下列操作直至 $T$ 是一棵树）：按 $G$ 的边的权值递增顺序依次从 $E- E_T$ 中选择一条边，若这条边加入 $T$ 后不构成回路，则将其加入 $E_T$，否则舍弃，直到 $E_T$ 中含有 $n-1$ 条边。</li></ul><p>根据图的相关性质，若一条边连接了两棵不同树中的顶点，则对这两棵树来说，它必定是连通的，将这条边加入森林中，完成两棵树的合并，直到整个森林合并成一棵树。</p><p>通常在 Kruskal 算法中，采用堆来存放边的集合，因此每次选择最小权值的边只需 $O(\log|E|)$ 的时间。此外，由于生成树 $T$ 中的所有边可视为一个等价类，因此每次添加新的边的过程类似于求解等价类的过程，由此可以采用并查集的数据结构来描述 $T$，从而构造 $T$ 的时间复杂度为 $O(|E|\log_{2}{|E|})$ 。因此，Kruskal 算法适合于<font color="#faa755">边稀疏而顶点较多</font>的图。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/graph/kruskal.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;boost/multiprecision/cpp_int.hpp&gt;</span></span><br><span class="line"><span class="comment">// using namespace boost::multiprecision;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mx = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">int64_t</span>;</span><br><span class="line"></span><br><span class="line">std::array&lt;ll, mx&gt; parent;</span><br><span class="line">ll node, edge;</span><br><span class="line">std::vector&lt;std::pair&lt;ll, std::pair&lt;ll, ll&gt;&gt;&gt; edges;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initial</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; node + edge; ++i) &#123;</span><br><span class="line">        parent[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">root</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (parent[i] != i) &#123;</span><br><span class="line">        parent[i] = parent[parent[i]];</span><br><span class="line">        i = parent[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root_x = <span class="built_in">root</span>(x);  <span class="comment">// Disjoint set union by rank</span></span><br><span class="line">    <span class="keyword">int</span> root_y = <span class="built_in">root</span>(y);</span><br><span class="line">    parent[root_x] = root_y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll mincost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edge; ++i) &#123;</span><br><span class="line">        ll x = edges[i].second.first;</span><br><span class="line">        ll y = edges[i].second.second;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">root</span>(x) != <span class="built_in">root</span>(y)) &#123;</span><br><span class="line">            mincost += edges[i].first;</span><br><span class="line">            <span class="built_in">join</span>(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mincost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> from = <span class="number">0</span>, to = <span class="number">0</span>, cost = <span class="number">0</span>, totalcost = <span class="number">0</span>;</span><br><span class="line">        std::cin &gt;&gt; node &gt;&gt; edge;  <span class="comment">// Enter the nodes and edges</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="number">0</span> &amp;&amp; edge == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// Enter 0 0 to break out</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">initial</span>();  <span class="comment">// Initialise the parent array</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edge; ++i) &#123;</span><br><span class="line">            std::cin &gt;&gt; from &gt;&gt; to &gt;&gt; cost;</span><br><span class="line">            edges.<span class="built_in">emplace_back</span>(<span class="built_in">make_pair</span>(cost, std::<span class="built_in">make_pair</span>(from, to)));</span><br><span class="line">            totalcost += cost;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(edges.<span class="built_in">begin</span>(), edges.<span class="built_in">end</span>());</span><br><span class="line">        std::cout &lt;&lt; <span class="built_in">kruskal</span>() &lt;&lt; std::endl;</span><br><span class="line">        edges.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最短路径"><a class="header-anchor" href="#最短路径"></a>最短路径</h3><p>广度优先搜索查找最短路径只是对无权图而言的。当图是带权图时，把从一个顶点 $v_0$ 到图中其余任意一个顶点 $v_i$ 的一条路径（可能不止一条）所经过边上的权值之和，定义为该路径的带权路径长度，把带权路径长度最短的那条路径称为最短路径。</p><p>求解最短路径的算法通常都依赖于一种性质，即两点之间的最短路径也包含了路径上其他顶点间的最短路径。带权有向图 $G$ 的最短路径问题一般可分为两类：一是单源最短路径，即求图中某一顶点到其他各顶点的最短路径，可通过经典的 Dijkstra （迪杰斯特拉）算法求解；二是求每对顶点间的最短路径，可通过 Floyd（弗洛伊德）算法来求解。</p><h4 id="BFS-算法求无权图的单源最短路径"><a class="header-anchor" href="#BFS-算法求无权图的单源最短路径"></a>BFS 算法求无权图的单源最短路径</h4><p>无权图可以视为一种特殊的带权图，只是每条边的权值都为 1。</p><p>若图 $G=(V, E)$ 为非带权图，定义从顶点 $u$ 到顶点 $v$ 的最短路径 $d(u, v)$ 为从 $u$ 到 $v$ 的任何路径中最少的边数；若从 $u$ 到 $v$ 没有通路，则 $d(u,v)= \infty$ 。</p><p>使用 BFS，我们可以求解一个满足上述定义的非带权图的单源最短路径问题，这是由广度优先搜索总是按照距离由近到远来遍历图中每个顶点的性质决定的。</p><p>BFS 算法求解单源最短路径问题的伪算法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS_MIN_Distance</span><span class="params">(Graph G, <span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// d[i] 表示从 u 到 i 结点的最短路径</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i) &#123;</span><br><span class="line">        d[i] = INT_MAX;  <span class="comment">// 初始化路径长度</span></span><br><span class="line">        path[i] = <span class="number">-1</span>;    <span class="comment">// 最短路径从哪个顶点过来</span></span><br><span class="line">    &#125;</span><br><span class="line">    d[u] = <span class="number">0</span>;</span><br><span class="line">    visited[u] = <span class="literal">true</span>;     <span class="comment">// 标记已经访问过</span></span><br><span class="line">    <span class="built_in">EnQueue</span>(Q, u);         <span class="comment">// 加入队列</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isEmpty</span>(Q)) &#123;  <span class="comment">// BFS 算法主过程</span></span><br><span class="line">        <span class="built_in">DeQueue</span>(Q, u);     <span class="comment">// 顶点 u 出队列</span></span><br><span class="line">        <span class="keyword">for</span> (w = <span class="built_in">FirstNeighbor</span>(G, u); w &gt;= <span class="number">0</span>; w = <span class="built_in">NextNeighbor</span>(G, u, w)) &#123;</span><br><span class="line">            <span class="comment">//检测v所有邻接点</span></span><br><span class="line">            <span class="keyword">if</span> (!visited[w]) &#123;      <span class="comment">// w 为 u 的尚未访问的邻接顶点</span></span><br><span class="line">                d[w] = d[u] + <span class="number">1</span>;    <span class="comment">// 路径的长度加 1</span></span><br><span class="line">                path[w] = u;        <span class="comment">// 最短路径应从 u 到 w</span></span><br><span class="line">                visited[w] = <span class="literal">true</span>;  <span class="comment">// 对 w 做已访问标记</span></span><br><span class="line">                <span class="built_in">EnQueue</span>(Q, w);      <span class="comment">// 顶点 w 入队列</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Dijkstra-算法求单源最短路径问题"><a class="header-anchor" href="#Dijkstra-算法求单源最短路径问题"></a>Dijkstra 算法求单源最短路径问题</h4><p>Dijkstra 算法设置一个集合 $S$ 记录已求得的最短路径的顶点，初始时把源点 $v_0$ 放入 $S$ ，集合 $S$ 每并入一个新顶点 $v_i$，都要修改源点 $v_0$ 到集合 $V-S$ 中顶点当前的最短路径长度值。</p><p>在构造的过程中还设置了几个辅助数组：</p><ul><li><code>dist[]</code> ：记录从源点 $v_0$ 到其他各顶点当前的最短路径长度，它的初态为：若从 $v_0$ 到 $v_i$ 有弧，则 <code>dist[i]</code> 为弧上的权值；否则置 <code>dist[i]</code> 为 $\infty$。</li><li><code>path[]</code> ：<code>path[i]</code> 表示从源点到顶点 $i$ 之间的最短路径的前驱结点。在算法结束时，可根据其值追溯得到源点 $v_0$ 到顶点 $v_i$ 的最短路径。</li><li><code>final[]</code>：标记各顶点是否已找到最短路径。</li></ul><p>假设从顶点 0 出发，即 $v_0=0$ ，集合 $S$ 最初只包含顶点 0，邻接矩阵 <code>arcs</code> 表示带权有向图，<code>arcs[i][j]</code> 表示有向边 <code>&lt;i, j&gt;</code> 的权值，若不存在有向边 <code>&lt;i,j&gt;</code>, 则 <code>arcs[i][j]</code> 为 $\infty$。</p><p>Dijkstra 算法的步骤如下（不考虑对 <code>path[]</code> 的操作）：</p><ol><li>初始化：集合 $S$ 初始为 $\{0\}$，<code>dist[]</code> 的初始值 <code>dist[i]=arcs[0][i]</code>，$i=1,2,\cdots ,n-1$。</li><li>从顶点集合 $V-S$ 中选出 $v_j$，满足 <code>dist[j]</code>$=\mathrm{Min}$  $\{ $ <code>dist[i]</code> $| v_i \in V-S \}$，$v_j$ 就是当前求得的一条从 $v_0$ 出发的最短路径的终点，令 $S=S\cup \{j\}$。</li><li>修改从 $v_0$ 出发到集合 $V- S$ 上任一顶点 $v_k$ 可达的最短路径长度：若 <code>dist[j]</code>$+$<code>arcs[j][k]</code>$&lt;$<code>dist[k]</code>，则更新<code>dist[k]</code>$=$<code>dist[j]</code>$+$<code>arcs[j][k]</code>。</li><li>重复2和3操作共 $n-1$ 次，直到所有的顶点都包含在 $S$ 中。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/Dijkatra%E7%AE%97%E6%B3%95.png" alt="Dijkatra算法"></p><p>算法执行过程的说明如下：</p><ul><li>初始化：集合 $S$ 初始为 $\{v_1\}$，$v_1$可达以和 $v_2$，$v_5$ 不可达 $v_3$ 和 $v_4$，因此 <code>dist[]</code> 数组各元素的初值依次设置为<code>dist[2]=10</code>，<code>dist[3]=MAX_INF</code>，<code>dist[4]=MAX_INF</code>，<code>dist[5]=5</code>。</li><li>第一轮：选出最小值 <code>dist[5]</code>，将顶点 $v_5$ 并入集合 $S$ ，即此时已找到 $v_1$ 到 $v_5$ 的最短路径。当 $v_5$ 加入 $S$ 后，从  $v_1$  到集合 $V-S$ 中可达顶点的最短路径长度可能会产生变化。因此需要更新 <code>dist[]</code> 数组。 $v_5$ 可达 $v_2$ ，因  $v_1$→ $v_5$→$v_2$ 的距离 8 比 <code>dist[2]=10</code> 小，更新 <code>dist[2]=8</code>； $v_5$ 可达 $v_3$， $v_1$→ $v_5$ → $v_3$ 的距离 14，更新 <code>dist[3]=14</code>； $v_5$ 可达$v_4$， $v_1$→$v_5$→$v_4$ 的距离 7，更新 <code>dist[4]=7</code>。</li><li>第二轮：选出最小值 <code>dist[4]</code>，将顶点 $v_4$ 并入集合 $S$。继续更新 <code>dist[]</code> 数组。$v_4$ 不可达$v_2$，<code>dist[2]</code> 不变；$v_4$ 可达$v_3$，$v_1$→$v_5$→$v_4$→$v_3$ 的距离 13 比 <code>dist[3]</code> 小，故更新 <code>dist[3]=13</code>。</li><li>第三轮：选出最小值 <code>dist[2]</code>，将顶点 $v_2$ 并入集合 $S$。继续更新 <code>dist[]</code> 数组。$v_2$ 可达 $v_3$，$v_1$→$v_5$→$v_2$→$v_3$ 的距离 9比 <code>dist[3]</code> 小，更新 <code>dist[3]=9</code>。</li><li>第四轮：选出唯一最小值 <code>dist[3]</code>，将顶点 $v_3$ 并入集合 $S$，此时全部顶点都已包含在 $S$ 中。</li></ul><p>显然，Dijkstra 算法也是基于贪心策略的。</p><p>使用邻接矩阵表示时，时间复杂度为 $O(|V|^2)$。使用带权的邻接表表示时，虽然修改 <code>dist[]</code> 的时间可以减少，但由于在<code>dist[]</code> 中选择最小分量的时间不变，时间复杂度仍为 $O(|V|^2)$。</p><p>人们可能只希望找到从源点到某个特定顶点的最短路径，但这个问题和求解源点到其他所有顶点的最短路径一样复杂，时间复杂度也为 $O(|V|^2)$。</p><p>值得注意的是，边上带有负权值时，Dijkstra算法并不适用。若允许边上带有负权值，则在与 $S$ （已求得最短路径的顶点集，归入 $S$ 内的结点的最短路径不再变更）内某点（记为a）以负边相连的点（记为b）确定其最短路径时，其最短路径长度加上这条负边的权值结果可能小于 a 原先确定的最短路径长度，而此时 a在 Dijkstra 算法下是无法更新的。</p><h4 id="Floyd-算法求各顶点之间最短路径问题"><a class="header-anchor" href="#Floyd-算法求各顶点之间最短路径问题"></a>Floyd 算法求各顶点之间最短路径问题</h4><p>求所有顶点之间的最短路径问题描述如下：已知一个各边权值均大于 0 的带权有向图，对任意两个顶点 $v_i\ne v_j$，要求求出 $v_i$ 与 $v_j$ 之间的最短路径和最短路径长度。</p><p>Floyd 算法的基本思想是：递推产生一个 $n$ 阶方阵序列 $ A^{(-1)}\ ,A^{(0)},\cdots ,A^{(k)},\cdots A^{(n-1)}$，其中 $A^{(k)}[i][j]$ 表示从顶点 $v_i$ 到顶点 $v_j$ 的路径长度，$k$ 表示绕行第 $k$ 个顶点的运算步骤。</p><p>初始时，对于任意两个顶点 $v_i$ 和 $v_j$ ，若它们之间存在边，则以此边上的权值作为它们之间的最短路径长度；若它们之间不存在有向边，则以 $ \infty$ 作为它们之间的最短路径长度。以后逐步尝试在原路径中加入顶点 $k \ (k=0, 1,\cdots ,n-1)$ 作为中间顶点。若增加中间顶点后，得到的路径比原来的路径长度减少了，则以此新路径代替原路径。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Structure for storing a graph</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> vertexNum;</span><br><span class="line">    <span class="keyword">int</span> **edges;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Constructs a graph with V vertices and E edges</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createGraph</span><span class="params">(struct Graph *G, <span class="keyword">int</span> V)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    G-&gt;vertexNum = V;</span><br><span class="line">    G-&gt;edges = (<span class="keyword">int</span> **)<span class="built_in">malloc</span>(V * <span class="keyword">sizeof</span>(<span class="keyword">int</span> *));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        G-&gt;edges[i] = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(V * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; V; j++) G-&gt;edges[i][j] = INT_MAX;</span><br><span class="line">        G-&gt;edges[i][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Adds the given edge to the graph</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(struct Graph *G, <span class="keyword">int</span> src, <span class="keyword">int</span> dst, <span class="keyword">int</span> weight)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    G-&gt;edges[src][dst] = weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Utility function to print distances</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> dist[], <span class="keyword">int</span> V)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nThe Distance matrix for Floyd - Warshall\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; V; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dist[i * V + j] != INT_MAX)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, dist[i * V + j]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;INF\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The main function that finds the shortest path from a vertex</span></span><br><span class="line"><span class="comment">// to all other vertices using Floyd-Warshall Algorithm.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FloydWarshall</span><span class="params">(struct Graph *graph)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> V = graph-&gt;vertexNum;</span><br><span class="line">    <span class="keyword">int</span> dist[V][V];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialise distance array</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; V; j++) dist[i][j] = graph-&gt;edges[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Calculate distances</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; V; k++)</span><br><span class="line">        <span class="comment">// Choose an intermediate vertex</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++)</span><br><span class="line">            <span class="comment">// Choose a source vertex for given intermediate</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; V; j++)</span><br><span class="line">                <span class="comment">// Choose a destination vertex for above source vertex</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (dist[i][k] != INT_MAX &amp;&amp; dist[k][j] != INT_MAX &amp;&amp;</span><br><span class="line">                    dist[i][k] + dist[k][j] &lt; dist[i][j])</span><br><span class="line">                    <span class="comment">// If the distance through intermediate vertex is less than</span></span><br><span class="line">                    <span class="comment">// direct edge then update value in distance array</span></span><br><span class="line">                    dist[i][j] = dist[i][k] + dist[k][j];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Convert 2d array to 1d array for print</span></span><br><span class="line">    <span class="keyword">int</span> dist1d[V * V];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; V; j++) dist1d[i * V + j] = dist[i][j];</span><br><span class="line"></span><br><span class="line">    print(dist1d, V);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Driver Function</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> V, E;</span><br><span class="line">    <span class="keyword">int</span> src, dst, weight;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> <span class="title">G</span>;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter number of vertices: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;V);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter number of edges: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;E);</span><br><span class="line">    createGraph(&amp;G, V);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nEdge %d \nEnter source: &quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;src);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Enter destination: &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;dst);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Enter weight: &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;weight);</span><br><span class="line">        addEdge(&amp;G, src, dst, weight);</span><br><span class="line">    &#125;</span><br><span class="line">    FloydWarshall(&amp;G);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Floyd 算法的时间复杂度为 $O(|V|^3)$ 。不过由于其代码很紧凑，且并不包含其他复杂的数据结构，因此隐含的常数系数是很小的，即使对于中等规模的输入来说，它仍然是相当有效的。空间复杂度：$O(|V|^2)$</p><p>Floyd 算法允许图中有带负权值的边，但不允许有包含带负权值的边组成的回路。Floyd 算法同样适用于带权无向图，因为带权无向图可视为权值相同往返二重边的有向图。</p><p>也可以用单源最短路径算法来解决每对顶点之间的最短路径问题。轮流将每个顶点作为源点，并且在所有边权值均非负时，运行一次 Dijkstra 算法，其时间复杂度为 $O(|V|^3) $ 。</p><h3 id="有向无环图描述表达式"><a class="header-anchor" href="#有向无环图描述表达式"></a>有向无环图描述表达式</h3><p>有向无环图：若一个有向图中不存在环，则称为有向无环图，简称 DAG 图。</p><p>有向无环图是描述含有公共子式的表达式的有效工具。例如表达式：$$((a+b)\ast (b\ast (c+d)&gt;+(c +d)\ast e)\ast ((c+d)\ast e)$$可以用二叉树来表示。仔细观察该表达式，可发现有一些相同的子表达式 $(c + d)$ 和 $(c + d)\ast e$ ，而在二叉树中，它们也重复出现。若利用有向无环图，则可实现对相同子式的共享，从而节省存储空间。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%8F%8F%E8%BF%B0.png" alt="表达式描述"></p><h3 id="拓扑排序"><a class="header-anchor" href="#拓扑排序"></a>拓扑排序</h3><p>AOV 网：若用 DAG 图表示一个工程，其顶点表示活动，用有向边 $\langle V_i,V_j\rangle $ 表示活动 $V_i$；必须先于活动 $V_j$；进行的这样一种关系，则将这种有向图称为顶点表示活动的网络，记为 AOV 网。在 AOV 网中，活动 $V_i$ 是活动 $V_j$ 的直接前驱，活动 $V_j$ 是活动 $V_i$ 的直接后继，这种前驱和后继关系具有传递性，且任何活动 $V_i$ 不能以它自己作为自己的前驱或后继。</p><p>拓扑排序：在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序：</p><ul><li>每个顶点出现且只出现一次。</li><li>若顶点 A 在序列中排在顶点 B 的前面，则在图中不存在从顶点 B 到顶点 A 的路径。</li></ul><p>或定义为：拓扑排序是对有向无环图的顶点的一种排序， 它使得若存在一条从顶点 A 到顶点 B 的路径，则在排序中顶点 B 出现在顶点 A 的后面。每个 AOV 网都有一个或多个拓扑排序序列。</p><p>对一个 AOV 网进行拓扑排序的算法有很多，下面介绍比较常用的一种方法的步骤：</p><ol><li>AOV 网中选择一个没有前驱的顶点并输出。</li><li>从网中删除该顶点和所有以它为起点的有向边。</li><li>重复步骤 1 和 2 直到当前的 AOV 网为空或当前网中不存在无前驱的顶点为止。后一种情况说明有向图中必然存在环。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TopologicalSort</span><span class="params">(Graph G)</span> </span>&#123;</span><br><span class="line">    InitStack(S);  <span class="comment">//初始化栈，存储入度为0的顶点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            Push(S, i);  <span class="comment">//将所有入度为0的顶点进栈</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;           <span class="comment">//计数，记录当前已经输出的顶点数</span></span><br><span class="line">    <span class="keyword">while</span> (!IsEmpty(S)) &#123;    <span class="comment">//栈不空，则存在入度为0的顶点</span></span><br><span class="line">        Pop(S, i);           <span class="comment">//栈顶元素出栈</span></span><br><span class="line">        print[count++] = i;  <span class="comment">//输出顶点i</span></span><br><span class="line">        <span class="keyword">for</span> (p = G.vertices[i].firstarc; pip = p-&gt;nextarc) &#123;</span><br><span class="line">            <span class="comment">//将所有i指向的顶点的入度减1,并且将入度减为0的顶点压入栈s</span></span><br><span class="line">            v = p-&gt;adjvex;</span><br><span class="line">            <span class="keyword">if</span> (!(--indegree[v])) &#123;</span><br><span class="line">                Push(S, v);  <span class="comment">//入度为0， 则入栈</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; G.vexnum) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//排序失败，有向图中有回路</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">//拓扑排序成功</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于输出每个顶点的同时还要删除以它为起点的边，故拓扑排序的时间复杂度为 $O(|V|+|E|)$。此外，利用深度优先遍历也可实现拓扑排序。</p><p>TODO 深度优先遍历代码实现拓扑排序</p><p>对一个 AOV 网，如果采用下列步骤进行排序，则称之为逆拓扑排序：</p><ol><li>从 AOV 网中选择一个没有后继（出度为 0 ）的顶点并输出。</li><li>从网中删除该顶点和所有以它为终点的有向边。</li><li>重复步骤 1 和 2 直到当前的 AOV 网为空。</li></ol><p>用拓扑排序算法处理 AOV 网时，应注意以下问题：</p><ol><li>入度为零的顶点，即没有前驱活动的或前驱活动都已经完成的顶点，工程可以从这个顶点所代表的活动开始或继续。</li><li>若一个顶点有多个直接后继，则拓扑排序的结果通常不唯一；但若各个顶点已经排在一个线性有序的序列中，每个顶点有唯一的前驱后继关系，则拓扑排序的结果是唯一的。</li><li>由于 AOV 网中各顶点的地位平等，每个顶点编号是人为的，因此可以按拓扑排序的结果重新编号，生成 AOV 网的新的邻接存储矩阵，这种邻接矩阵可以是三角矩阵；但对于一般的图来说，若其邻接矩阵是三角矩阵，则存在拓扑序列；反之则不一定成立。</li></ol><p>TODO 逆拓扑排序DFS算法实现及其对环路的判断</p><h3 id="关键路径"><a class="header-anchor" href="#关键路径"></a>关键路径</h3><p>在带权有向图中，以顶点表示事件，以有向边表示活动，以边上的权值表示完成该活动的开销（如完成活动所需的时间），称之为用边表示活动的网络，简称 AOE 网。AOE 网和 AOV 网都是有向无环图，不同之处在于它们的边和顶点所代表的含义是不同的，AOE 网中的边有权值；而 AOV 网中的边无权值，仅表示顶点之间的前后关系。AOE 网具有以下两个性质：</p><ol><li>只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始；</li><li>只有在进入某顶点的各有向边所代表的活动都已结束时，该顶点所代表的事件才能发生。</li></ol><p>在 AOE 网中仅有一个入度为 0 的顶点，称为开始顶点（源点），它表示整个工程的开始；网中也仅存在一个出度为 0 的顶点，称为结束顶点（汇点），它表示整个工程的结束。</p><p>在 AOE 网中，有些活动是可以并行进行的。从源点到汇点的有向路径可能有多条，并且这些路径长度可能不同。完成不同路径上的活动所需的时间虽然不同，但是只有所有路径上的活动都已完成，整个工程才能算结束。因此，从源点到汇点的所有路径中，具有最大路径长度的路径称为<font color="#ea66a6">关键路径</font>，而把关键路径上的活动称为关键活动。</p><p>完成整个工程的最短时间就是关键路径的长度，即关键路径上各活动花费开销的总和。这是因为关键活动影响了整个工程的时间，即若关键活动不能按时完成，则整个工程的完成时间就会延长。因此，只要找到了关键活动，就找到了关键路径，也就可以得出最短完成时间。下面给出在寻找关键活动时所用到的几个参量的定义。</p><h4 id="事件-v-k-的最早发生时间-ve-k"><a class="header-anchor" href="#事件-v-k-的最早发生时间-ve-k"></a>事件 $v_k$ 的最早发生时间 $ve(k)$</h4><p>它是指从源点 $v_1$ 到顶点 $v_k$ 的最长路径长度。事件 $v_k$ 的最早发生时间决定了所有从 $v_k$ 开始的活动能够开工的最早时间。</p><h4 id="活动-a-i-的最早开始时间-e-i"><a class="header-anchor" href="#活动-a-i-的最早开始时间-e-i"></a>活动 $a_i$ 的最早开始时间 $e(i)$</h4><p>它是指该活动弧的起点所表示的事件的最早发生时间。若边 $\langle v_k,v_j\rangle $  表示活动 $a_i$ ，则有 $e(i)=ve(k)$)。</p><h4 id="事件-v-k-的最迟发生时间-vl-k"><a class="header-anchor" href="#事件-v-k-的最迟发生时间-vl-k"></a>事件 $v_k$ 的最迟发生时间 $vl(k)$</h4><p>它是指在不推迟整个工程完成的前提下，即保证它的后继事件 $v_j$ 在其最迟发生时间 $vl(j)$ 能够发生时，该事件最迟必须发生的时间。</p><h4 id="活动-a-i-的最迟开始时间-l-i"><a class="header-anchor" href="#活动-a-i-的最迟开始时间-l-i"></a>活动 $a_i$ 的最迟开始时间 $l(i)$</h4><p>它是指该活动弧的终点所表示的事件的最迟发生时间与该活动所需时间之差。若边 $\langle v_k,v_j\rangle $  表示活动 $a_i$ ，则有 $l(i)=vl(j)-\mathrm{Weight} (v_k,v_j)$)。</p><h4 id="活动-a-i-的时间余量"><a class="header-anchor" href="#活动-a-i-的时间余量"></a>活动 $a_i$ 的时间余量</h4><p>一个活动 $a_i$ 的最迟开始时间 $l(i)$和其最早开始时间 $e(i)$的差额 $d(i)= l(i)- e(i)$，它是指该活动完成的时间余量，即在不增加完成整个工程所需总时间的情况下，活动 $a_i$ 可以拖延的时间。若一个活动的时间余量为零，则说明该活动必须要如期完成，否则就会拖延整个工程的进度，所以称 $l(i)- e(i)= 0$ 即 $l(i)= e(i)$ 的活动 $a_i$ 是关键活动。</p><h4 id="求关键路径的步骤"><a class="header-anchor" href="#求关键路径的步骤"></a>求关键路径的步骤</h4><p>求关键路径的算法步骤如下：</p><ol><li>求所有事件的最早发生时间 $ve()$，从源点出发，令 $ve(源点)=0$，按拓扑有序求其余顶点的最早发生时间 $ve()$</li><li>求所有事件的最迟发生时间 $vl( )$，从汇点出发，令 $vl(汇点)= ve(汇点)$， 按逆拓扑有序求其余顶点的最迟发生时间 $vl()$</li><li>求所有活动的最早发生时间 $e()$，根据各顶点的 $ve()$ 值求所有弧的最早开始时间 $e()$</li><li>求所有活动的最迟发生时间 $l( )$，根据各顶点的 $vi()$ 值求所有孤的最迟开始时间的 $l()$</li><li>求所有活动的时间余量 $d( )$，求 AOE 网中所有活动的差额 $d()$，找出所有 $d()=0$ 的活动构成关键路径。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/%E6%B1%82%E8%A7%A3%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="求解关键路径的过程"></p><p>上图所示为求解关键路径的过程，简单说明如下：</p><ol><li>求 $ve()$ ：初始 $ve(1)=0$，在拓扑排序输出顶点过程中，求得 $ve(2)=3$，$ve(3)=2$，$ve(4)=max\{ve(2)+2,ve(3)+4\}=max\{5,6\}=6$，$ve(5)=6$，$ve(6)=max\{ve(5)+1,ve(4)+2,ve(3)+3\}=max\{7,8,5\}=8$。</li><li>求 $vl()$：初始 $vl(6)=8$，在逆拓扑排序出栈过程中，求得 $vl(5)=7$，$vl(4)=6$，$vl(3)=min\{vl(4)-4,vl(6)-3\}=min\{2,5\}=2$，$vl(2)=min\{vl(5)-3,vl(4)-2\}=min\{4,4\}=4$，$vl(1)=0$</li><li>弧的最早开始时间 $e()$ 等于该弧的起点的顶点 $ve()$，求得结果如上表所示</li><li>弧的最迟开始时间 $l(i)$ 等于该弧的终点的顶点 $vl()$ 减去该弧持续的时间，求得结果如上表所示</li><li>根据 $l(i)-e(i)=0$ 的关键活动，得到的关键路径为 $(v_1,v_3,v_4,v_6)$</li></ol><p>对于关键路径，需要注意以下几点：</p><ol><li>关键路径上的所有活动都是关键活动，它是决定整个工程的关键因素，因此可通过加快关键活动来缩短整个工程的工期。</li><li>但也不能任意缩短关键活动，因为一旦缩短到一定的程度，该关键活动就可能会变成非关键活动。</li><li>网中的关键路径并不唯一，且对于有几条关键路径的网，只提高一条关键路径上的关键活动速度并不能缩短整个工程的工期，只有加快那些包括在所有关键路径上的关键活动才能达到缩短工期的目的。</li></ol>]]></content>
    
    
    <summary type="html">图</summary>
    
    
    
    <category term="数据结构" scheme="http://halo123.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="http://halo123.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>树与二叉树</title>
    <link href="http://halo123.top/2021/05/07/DataStructure/E_Tree/"/>
    <id>http://halo123.top/2021/05/07/DataStructure/E_Tree/</id>
    <published>2021-05-07T11:30:51.000Z</published>
    <updated>2021-05-14T11:53:33.321Z</updated>
    
    <content type="html"><![CDATA[<p>【考纲内容】</p><ol><li>树的基本概念</li><li>二叉树的定义及其主要特征</li><li>二叉树的顺序存储结构和链式存储结构</li><li>二叉树的遍历</li><li>线索二叉树的基本概念和构造</li><li>树的存储结构</li><li>森林与二叉树的转换</li><li>树和森林的遍历</li><li>二叉排序树</li><li>平衡二叉树</li><li>哈夫曼树和哈夫曼编码</li></ol><p>【知识框架】</p><p>TODO 完成树与二叉树章节的知识框架</p><p>【复习提示】</p><p>本章内容多以选择题的形式考查，但也会出涉及树遍历相关的算法题。树和二叉树的性质、遍历操作、转换、存储结构和操作特性等，满二叉树、完全二叉树、线索二叉树、哈夫曼树的定义和性质，二叉排序树和二叉平衡树的性质和操作等，都是选择题必然会涉及的内容。</p><h2 id="树的基本概念"><a class="header-anchor" href="#树的基本概念"></a>树的基本概念</h2><h3 id="树的定义"><a class="header-anchor" href="#树的定义"></a>树的定义</h3><p>树是 $n \ (n\ge 0)$ 个节点的有限集。当 $n=0$ 时，称为空树。在任意一颗非空树中应满足：</p><ol><li>有且仅有一个特定的称为根的结点。</li><li>当 $n&gt;1$ 时，其余节点可分为 $m\ (m&gt;0)$ 个互不相交的有限集 $T_1,T_2,\dots ,T_m$，其中每个集合本身又是一棵树，并称为根的子树。</li></ol><p>显然，树的定义是递归的，即在树的定义中又用到了其自身，树是一种递归的数据结构。树作为一种逻辑结构，同时也是一种分层结构，具有以下两个特点：</p><ol><li>树的根结点没有前驱，除根结点外的所有结点有且只有一个前驱。</li><li>树中所有结点可以有零个或多个后继。</li></ol><p>树适合于表示具有层次结构的数据。树中的某个结点（除根结点外）最多只和上一层的一个结点（即其父结点）有直接关系，根结点没有直接上层结点，因此在 $n$ 个结点的树中有 $n-1$ 条边。而树中每个结点与其下一层的零个或多个结点（即其子女结点）有直接关系。</p><h3 id="基本术语"><a class="header-anchor" href="#基本术语"></a>基本术语</h3><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E6%A0%91%E7%9A%84%E6%A0%91%E5%BD%A2%E8%A1%A8%E7%A4%BA.png" alt="树的树形表示"></p><ul><li>考虑结点 K 。根 A 到结点 K 的唯一路径上的任意结点，称为结点 K 的<font color="#ea66a6">祖先</font>。如结点 B 是结点 K 的祖先，而结点 K 是结点 B 的<font color="#ea66a6">子孙</font>。路径上最接近结点 K 的结点 E 称为 K 的<font color="#ea66a6">双亲</font>，而 K 为结点 E 的<font color="#ea66a6">孩子</font>。根 A 是树中唯一没有双亲的结点。有相同双亲的结点称为<font color="#ea66a6">兄弟</font>，如结点 K 和结点 L 有相同的双亲 E，即 K 和 L 为兄弟。</li><li>树中一个结点的孩子个数称为该<font color="#ea66a6">结点的度</font>，树中结点的最大度数称为树的度。如结点 B 的度为 2，结点 D 的度为 3，树的度为 3。</li><li>度大于 0 的结点称为<font color="#ea66a6">分支结点</font>（又称非终端结点）；度为 0 （没有子女结点）的结点称为<font color="#ea66a6">叶子结点</font>（又称终端结点）。在分支结点中，每个结点的分支数就是该结点的度。</li><li><font color="#ea66a6">结点的层次</font>从树根开始定义，根结点为第 1 层，它的子结点为第 2 层，以此类推。双亲在同一层的结点互为<font color="#ea66a6">堂兄弟</font>，图中结点 G 与 E，F，H，I，J 互为堂兄弟。</li><li><font color="#ea66a6">结点的深度</font>是从根结点开始自顶向下逐层累加的。</li><li><font color="#ea66a6">结点的高度</font>是从叶结点开始自底向上逐层累加的。</li><li><font color="#ea66a6">树的高度</font>（或深度）是树中结点的最大层数。图中树的高度为4。</li><li>有序树和无序树。树中结点的各子树从左到右是有次序的，不能互换，称该树为<font color="#ea66a6">有序树</font>，否则称为<font color="#ea66a6">无序树</font>。假设图为有序树，若将子结点位置互换，则变成一棵不同的树。</li><li>路径和路径长度。树中两个结点之间的<font color="#ea66a6">路径</font>是由这两个结点之间所经过的结点序列构成的，而<font color="#ea66a6">路径长度</font>是路径上所经过的边的个数。注意：由于树中的分支是有向的，即从双亲指向孩子，所以树中的路径是从上向下的，同一双亲的两个孩子之间不存在路径。</li><li><font color="#ea66a6">森林</font>是 $m\  (m \ge 0)$ 棵互不相交的树的集合。森林的概念与树的概念十分相近，因为只要把树的根结点删去就成了森林。反之，只要给 $m$ 棵独立的树加上一个结点，并把这 $m$ 棵树作为该结点的子树，则森林就变成了树。</li></ul><p>度为 $m$ 的树与 $m$ 叉树：前者表示树中各节点最少存在一个最大为 $m$ 度的结点，而 $m$  叉树表示每个结点最多只能有 $m$ 个孩子的树</p><h3 id="树的性质"><a class="header-anchor" href="#树的性质"></a>树的性质</h3><p>树具有如下最基本的性质：</p><ol><li><p>树中的结点数等于所有结点的度数加 1 。</p></li><li><p>度为 $m$ 的树中第 $i$ 层上至多有 $m^{i-1}$ 个结点 $(i\ge 1)$。</p></li><li><p>高度为 $h$ 的 $m$ 叉树至多有 $\frac{m^h-1}{m-1} $ 个结点。</p></li><li><p>具有 $n$ 个结点的 $m$ 叉树的最小高度为 $\left \lceil \log_{m}{(n(m-1)+1) } \right \rceil $。<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p></li></ol><h2 id="二叉树的概念"><a class="header-anchor" href="#二叉树的概念"></a>二叉树的概念</h2><h3 id="二叉树的定义及其主要特性"><a class="header-anchor" href="#二叉树的定义及其主要特性"></a>二叉树的定义及其主要特性</h3><h4 id="二叉树的定义"><a class="header-anchor" href="#二叉树的定义"></a>二叉树的定义</h4><p>二叉树是另一种树形结构，其特点是每个结点至多只有两棵子树（即二叉树中不存在度大于 2 的结点），并且二叉树的子树有左右之分，其次序不能任意颠倒。</p><p>与树相似，二叉树也以递归的形式定义。二叉树是 $n\ (n\ge 0)$个结点的有限集合：</p><ol><li>或者为空二叉树，即 $n=0$ 。</li><li>或者由一个根结点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树又分别是一棵二叉树。</li></ol><p>二叉树是有序树，若将其左、右子树颠倒，则成为另一棵不同的二叉树。即使树中结点只有一颗子树，也要区分它是左子树还是右子树。</p><p>二叉树与度为 2 的有序树的区别：</p><ol><li>度为 2 的树至少有 3 个结点，而二叉树可以为空。</li><li>度为 2 的有序树的孩子的左右次序是相对于另一孩子而言的，若某个结点只有一个孩子，则这个孩子就无须区分其左右次序，而二叉树无论其孩子数是否为 2，均需确定其左右次序，即二叉树的结点次序不是相对于另一结点而言，而是确定的。</li></ol><h4 id="几个特殊的二叉树"><a class="header-anchor" href="#几个特殊的二叉树"></a>几个特殊的二叉树</h4><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E5%87%A0%E4%B8%AA%E7%89%B9%E6%AE%8A%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="几个特殊的二叉树"></p><p><strong>满二叉树</strong>。一棵高度为 $h$，且含有 $2^h-1$ 个结点的二叉树称为满二叉树，即树中的每层都含有最多的结点。满二叉树的叶子结点都集中在二叉树的最下一层，并且除叶子结点之外的每个结点度数均为 2 （不存在度为 1 的结点）。可以对满二叉树按层序编号：约定编号从根结点（根结点编号为 1 ）起，自上而下，自左向右。这样，每个结点对应一个编号，对于编号为 $i$ 的结点，若有双亲，则其双亲为 $\left \lfloor \frac{i}{2}  \right \rfloor$，若有左孩子，则左孩子为 $2i$ ；若有右孩子，则右孩子为 $2i+1$。</p><p><strong>完全二叉树</strong>。高度为 $h$、有 $n$ 个结点的二叉树，当且仅当其每个结点都与高度为 $h$ 的满二叉树中编号为 $1\sim n$ 的结点一一对应时，称为完全二叉树。就是对应相同高度的满二叉树缺失最下层最右边的一些连续叶子结点。其特点如下：</p><ol><li>若 $ i \le \left \lfloor \frac{n}{2}  \right \rfloor$，则结点 $i$ 为分支结点，否则为叶子结点。</li><li>叶子结点只可能在层次最大的两层上出现。对于最大层次中的叶子结点，都依次排列在该层最左边的位置上。</li><li>若有度为 1 的结点，则只可能有一个，且该结点只有左孩子而无右孩子（重要特征）。</li><li>按层序编号后，一旦出现某结点（编号为 $i$ ）为叶子结点或只有左孩子，则编号大于 $i$ 的结点均为叶子结点。</li><li>若 $n$ 为奇数，则每个分支结点都有左孩子和右孩子；若 $n$ 为偶数，则编号最大的分支结点（编号为 $\frac{n}{2}$ ）只有左孩子，没有右孩子，其余分支结点左、右孩子都有。</li></ol><p><strong>二叉排序树</strong>。一棵二叉树或者是空二叉树，或者是具有如下性质的二叉树：</p><ul><li>左子树上所有结点的关键字均小于根结点的关键字；</li><li>右子树上的所有结点的关键字均大于根结点的关键字；</li><li>左子树和右子树又各是一棵二叉排序树。</li></ul><p><strong>平衡二叉树</strong>。树上任一结点的左子树和右子树的深度之差不超过 1 。</p><h4 id="二叉树的性质"><a class="header-anchor" href="#二叉树的性质"></a>二叉树的性质</h4><p>（1）<font color="#FF666">非空二叉树上的叶子结点数等于度为 2 的结点数加 1</font>，即 $n_{0}=n_{2}+1$ 。</p><p>证明：设度为 0，1 和 2 的结点个数分别为 $n_{0}$，$n_{1}$ 和 $n_{2}$，结点总数 $n=n_{0}+n_{1}+n_{2}$。再看二叉树中的分支树，除根结点外，其余结点都有一个分支进入，设 $B$ 为分支总数，则 $n=B+1$ 。由于这些分支是由度为 1 或 2 的结点射出的，所以又有 $B=n_{1}+2n_{2}$。于是得 $n_{0}+n_{1}+n_{2}=n_{1}+2n_{2}+1$ ，则 $n_{0}=n_{2}+1$。</p><p>拓展到任意一棵树，若结点数量为 $n$，则边的数量为 $n-1$。</p><p>（2）非空二叉树上第 $k$ 层上至多有 $2^{k-1}$ 个结点 （ $k \ge 1$ ），可扩至 m 叉树</p><p>（3）高度为 $h$ 的二叉树至多有 $2^h-1$ 个结点（ $h \ge 1$ ）。高度为 $h$ 的 $m$ 叉树至多有 $\frac{m^h-1}{m-1} $ 个结点，推出。</p><p>（4）具有 $n$ 个（$n&gt;0$）结点的完全二叉树的高度 $h$ 为 $\left \lceil \log_{2}{(n+1)}  \right \rceil $ 或  $\left \lfloor \log_{2}{n}  \right \rfloor +1$</p><p>证明：高度为 $h$ 的满二叉树共有 $2^h-1$ 个结点，高度为 $h-1$ 的满二叉树共有 $2^{h-1}-1$ 个结点，可得：$$2^{h-1}-1&lt;n\le 2^{h}-1$$ $$2^{h-1}&lt;n+1\le 2^{h}$$ $$h-1&lt;\log{2}{(n+1)} \le h$$ $$h=\left \lceil \log_{2}{(n+1)}  \right \rceil $$</p><p>高度为 $h-1$ 的满二叉树共有 $2^{h-1}-1$ 个结点，高为 $h$ 的完全二叉树至少有 $2^{h-1}$ 个结点，至多有 $2^{h}-1$ 个结点，可得：$$2^{h-1} \le n &lt; 2^{h}$$ $$h-1 \le \log{2}{n} &lt; h$$ $$h= \left \lfloor \log_{2}{n}  \right \rfloor +1$$</p><p>（5）对于完全二叉树，可以由的结点数 $n$ 推出度为 0、1 和 2 的结点个数为 $n_0$、$n_1$和 $n_2$。</p><ul><li>完全二叉树最多只有一个度为 1 1 的结点，即：$n_{1}=0或1$ ；</li><li>$n_{0}=n_{2}+1$，两边各加上 $n_2$ 可得： $n_0+n_2=2n_2+1$ 可推出 $n_0+n_2$ 一定为奇数；</li></ul><p>根据上两个推论得：</p><ul><li>若完全二叉树有 $2k$ （偶数）个结点，则必有 $n_1=1,\ n_0=k , \ n_2=k-1$</li><li>若完全二叉树有 $2k-1$ （奇数）个结点，则必有 $n_1=0,\ n_0=k , \ n_2=k-1$</li></ul><h3 id="二叉树的存储结构"><a class="header-anchor" href="#二叉树的存储结构"></a>二叉树的存储结构</h3><h4 id="顺序存储结构"><a class="header-anchor" href="#顺序存储结构"></a>顺序存储结构</h4><p>二叉树的顺序存储是指用一组地址连续的存储单元依次<wavy>自上而下</wavy>、<wavy>自左至右</wavy>存储完全二叉树上的结点元素，即将完全二叉树上编号为 $i$ 的结点元素存储在一维数组下标为 $i-1$ 的分量中。（这种存储结构建议从数组下标 1 开始存储树中的结点）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">bool</span> isEmpty;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TreeNode t[MaxSize];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MaxSize; i++) &#123;</span><br><span class="line">        t[i].isEmpty = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依据二叉树的性质，完全二叉树和满二叉树采用顺序存储比较合适，树中结点的序号可以唯一地反映结点之间的逻辑关系，这样既能最大可能地节省存储空间，又能利用数组元素的下标值确定结点在二叉树中的位置，以及结点之间的关系。</p><p>但对于一般的二叉树，为了让数组下标能反映二叉树中结点之间的逻辑关系，只能添加一些并不存在的空结点，让其每个结点与完全二叉树上的结点相对照，再存储到一维数组的相应分量中。然而，在最坏情况下，一个高度为 $h$ 且只有 $h$ 个结点的单支树却需要占据近 $2^h-1$ 个存储单元。</p><h4 id="链式存储结构"><a class="header-anchor" href="#链式存储结构"></a>链式存储结构</h4><p>由于顺序存储的空间利用率较低，因此二叉树一般都采用链式存储结构，用链表结点来存储二叉树中的每个结点。在二叉树中，结点结构通常包括若干数据域和若干指针域，二叉链表至少包含3个域：数据域 <code>data</code>、左指针域 <code>lchild</code> 和右指针域 <code>rchild</code>。$n$ 个节点的二叉链表共有 $n+1$ 个空链域。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span>  <span class="comment">// 左右孩子指针</span></span><br><span class="line">    <span class="comment">// struct BiTNode *parent;  // 根据实际需求决定是否加父指针</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一棵空树</span></span><br><span class="line">    BiTree root = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入根节点</span></span><br><span class="line">    root = (BiTree)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(BiTNode));</span><br><span class="line">    root-&gt;data = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">    root-&gt;lchild = <span class="literal">nullptr</span>;</span><br><span class="line">    root-&gt;rchild = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入新结点</span></span><br><span class="line">    BiTNode *p = (BiTNode *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(BiTNode));</span><br><span class="line">    p-&gt;data = &#123;<span class="number">2</span>&#125;;</span><br><span class="line">    p-&gt;lchild = <span class="literal">nullptr</span>;</span><br><span class="line">    p-&gt;rchild = <span class="literal">nullptr</span>;</span><br><span class="line">    root-&gt;lchild = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到指定结点的左右孩子结点十分容易，但如果要寻找父节点只能从根结点开始遍历寻找。可以在结构体中额外定义父节点指针（三叉链表）。</p><h2 id="二叉树的遍历和线索二叉树"><a class="header-anchor" href="#二叉树的遍历和线索二叉树"></a>二叉树的遍历和线索二叉树</h2><h3 id="二叉树的遍历"><a class="header-anchor" href="#二叉树的遍历"></a>二叉树的遍历</h3><p>二叉树的遍历是指按某条搜索路径访问树中每个结点，使得每个结点均被访问一次，而且仅被访问一次。由于二叉树是一种非线性结构，每个结点都可能有两棵子树，因而需要寻找一种规律，以便使二叉树上的结点能排列在一个线性队列上，进而便于遍历。</p><p>由二叉树的递归定义可知，遍历一棵二叉树便要决定对根结点 N、左子树 L​ 和右子树 R 的访问顺序。按照先遍历左子树再遍历右子树的原则，常见的遍历次序有先序（NLR）、中序（LNR）和后序（LRN）三种遍历算法，其中“序”指的是根结点在何时被访问。</p><h4 id="先序遍历"><a class="header-anchor" href="#先序遍历"></a>先序遍历</h4><p>先序遍历（ PreOrder ）的操作过程如下：</p><p>若二叉树为空，则什么也不做；否则，</p><ol><li>访问根结点；</li><li>先序遍历左子树；</li><li>先序遍历右子树。</li></ol><p>对应的递归算法如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">visit</span>(T);             <span class="comment">// 访问根节点</span></span><br><span class="line">        <span class="built_in">PreOrder</span>(T-&gt;lchild);  <span class="comment">// 递归遍历左子树</span></span><br><span class="line">        <span class="built_in">PreOrder</span>(T-&gt;rchild);  <span class="comment">// 递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中序遍历"><a class="header-anchor" href="#中序遍历"></a>中序遍历</h4><p>中序遍历（ InOrder ）的操作过程如下：</p><p>若二叉树为空，则什么也不做；否则，</p><ul><li>中序遍历左子树；</li><li>访问根结点；</li><li>中序遍历右子树。</li></ul><p>对应的递归算法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">InOrder</span>(T-&gt;lchild);  <span class="comment">// 递归遍历左子树</span></span><br><span class="line">        <span class="built_in">visit</span>(T);            <span class="comment">// 访问根节点</span></span><br><span class="line">        <span class="built_in">InOrder</span>(T-&gt;rchild);  <span class="comment">// 递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后序遍历"><a class="header-anchor" href="#后序遍历"></a>后序遍历</h4><p>后序遍历（ PostOrder ）的操作过程如下：</p><p>若二叉树为空，则什么也不做；否则，</p><ol><li>后序遍历左子树；</li><li>后序遍历右子树；</li><li>访问根结点。</li></ol><p>对应的递归算法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">PostOrder</span>(T-&gt;lchild);  <span class="comment">// 递归遍历左子树</span></span><br><span class="line">        <span class="built_in">PostOrder</span>(T-&gt;rchild);  <span class="comment">// 递归遍历右子树</span></span><br><span class="line">        <span class="built_in">visit</span>(T);              <span class="comment">// 访问根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三种遍历算法中，递归遍历左、右子树的顺序都是固定的，只是访问根结点的顺序不同。不管采用哪种遍历算法，每个结点都访问一次且仅访问一次，故时间复杂度都是 $O(n)$ 。在递归遍历中，递归工作栈的栈深恰好为树的深度，所以在最坏情况下，二叉树是有 $n$ 个结点且深度为 $n$ 的单支树，遍历算法的空间复杂度为 $O(n)$。</p><p>TODO 递归算法和非递归算法的转换</p><h4 id="层次遍历"><a class="header-anchor" href="#层次遍历"></a>层次遍历</h4><p>要进行层次遍历，需要借助一个队列。先将二叉树根结点入队，然后出队，访问出队结点，若它有左子树，则将左子树根结点入队；若它有右子树，则将右子树根结点入队。然后出队，访问出队结点…如此反复，直至队列为空。</p><p>二叉树的层次遍历算法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    LinkQueue Q;</span><br><span class="line">    <span class="built_in">InirQueue</span>(Q);  <span class="comment">// 初始化辅助队列</span></span><br><span class="line">    BiTree p;</span><br><span class="line">    <span class="built_in">EnQueue</span>(Q, T);  <span class="comment">// 将根结点入队</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isEmpty</span>(Q)) &#123;</span><br><span class="line">        <span class="built_in">DeQueue</span>(Q, p);  <span class="comment">// 对头结点出队</span></span><br><span class="line">        <span class="built_in">visit</span>(p);       <span class="comment">// 访问出队结点</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lchild != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">EnQueue</span>(Q, p-&gt;lchild);  <span class="comment">// 左孩子入队,入队指针</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;rchild != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">EnQueue</span>(Q, p-&gt;rchild);  <span class="comment">// 右孩子入队</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="由遍历序列构造二又树"><a class="header-anchor" href="#由遍历序列构造二又树"></a>由遍历序列构造二又树</h4><p>若只给出一棵二叉树的前/中/后/层序遍历序列中的一种，不能唯一确定一棵二叉树。必须有中序遍历和其他任意一种遍历序列才能确定唯一一种二叉树。</p><p>先序序列和中序序列：在先序遍历序列中，第一个结点一定是二叉树的根结点；而在中序遍历中，根结点必然将中序序列分割成两个子序列，前一个子序列是根结点的左子树的中序序列，后一个子序列是根结点的右子树的中序序列。根据这两个子序列，在先序序列中找到对应的左子序列和右子序列。在先序序列中，左子序列的第一个结点是左子树的根结点，右子序列的第一个结点是右子树的根结点。如此递归地进行下去，便能唯一地确定这棵二叉树。</p><p>类似，由二叉树的后序序列和中序序列，层序序列和中序序列也可以唯一地确定一棵二叉树。找到树的根节点，并根据<br>中序序列划分左右子树，再找至左右子树根节点。</p><h3 id="线索二叉树"><a class="header-anchor" href="#线索二叉树"></a>线索二叉树</h3><h4 id="线索二叉树的基本概念"><a class="header-anchor" href="#线索二叉树的基本概念"></a>线索二叉树的基本概念</h4><p>遍历二叉树是以一定的规则将二叉树中的结点排列成一个线性序列，从而得到几种遍历序列，使得该序列中的每个结点（第一个和最后一个结点除外）都有一个直接前驱和直接后继。</p><p>传统的二叉链表存储仅能体现一种父子关系，不能直接得到结点在遍历中的前驱或后继。前面提到，在含 $n$ 个结点的二叉树中，有 $n+1$ 个空指针。这是因为每个叶结点有 2 个空指针，每个度为 1 的结点有 1 个空指针，空指针总数为 $2n_{0} + n_1$ ，又 $n_{0}=n_{2}+ 1$，所以空指针总数为 $n_0+n_1+n_2+1=n+1$ 。由此设想能否利用这些空指针来存放指向其前驱或后继的指针？这样就可以像遍历单链表那样方便地遍历二叉树。引入线索二叉树正是为了加快查找结点前驱和后继的速度。</p><p>规定：若无左子树，令 <code>lchild</code> 指向其前驱结点；若无右子树，令 <code>rchild</code> 指向其后继结点。还需增加两个标志域（<code>ltag</code>、<code>rtag</code>）标识指针域是指向左（右）孩子还是指向前驱（后继）。当 tag 值等于 0 时，表示指针指向孩子，等于 1 时，表示指针指向线索。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E4%B8%AD%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="中序线索二叉树"></p><p>线索二叉树的存储结构描述如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ltag, rtag;  <span class="comment">// 左右线索标志，0指向孩子，1指向线索</span></span><br><span class="line">&#125; ThreadNode, *ThreadTree;</span><br></pre></td></tr></table></figure><p>以这种结点结构构成的二叉链表作为二叉树的存储结构，称为<font color="#ea66a6">线索链表</font>，其中指向结点前驱和后继的指针称为<font color="#ea66a6">线索</font>。加上线索的二叉树称为<font color="#ea66a6">线索二叉树</font>。</p><h4 id="中序线索二叉树的构造"><a class="header-anchor" href="#中序线索二叉树的构造"></a>中序线索二叉树的构造</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局遍历 pre 指向当前访问结点的前驱</span></span><br><span class="line">ThreadNode *pre = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历二叉树并进行线索化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThread</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">InThread</span>(T-&gt;lchild);  <span class="comment">// 中序遍历左子树</span></span><br><span class="line">        <span class="built_in">visit</span>(T);             <span class="comment">// 访问根节点并线索化</span></span><br><span class="line">        <span class="built_in">InThread</span>(T-&gt;rchild);  <span class="comment">// 中序遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(ThreadNode *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;lchild == <span class="literal">nullptr</span>) &#123;  <span class="comment">// 左子树为空，建立前驱线索</span></span><br><span class="line">        q-&gt;lchild = pre;</span><br><span class="line">        q-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pre != <span class="literal">nullptr</span> &amp;&amp; pre-&gt;rchild == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        pre-&gt;rchild = q;  <span class="comment">// 建立前驱结点的后继线索</span></span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = q;  <span class="comment">// 将 pre 指针指向当前结点（即下一个访问结点的前驱结点）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序线索化二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateInThread</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">InThread</span>(T);  <span class="comment">// 中序线索化除最后一个结点的其他结点</span></span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;rchild == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;  <span class="comment">// 注意：处理最后一个结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="先序线索二叉树的构造"><a class="header-anchor" href="#先序线索二叉树的构造"></a>先序线索二叉树的构造</h4><blockquote><p>当 <code>ltag == 0</code> 时，才能对左子树先序线索化</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局遍历 pre 指向当前访问结点的前驱</span></span><br><span class="line">ThreadNode *pre = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先序遍历二叉树并进行线索化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreThread</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">visit</span>(T);                  <span class="comment">// 访问根节点并线索化</span></span><br><span class="line">        <span class="keyword">if</span> (T-&gt;ltag == <span class="number">0</span>) &#123;        <span class="comment">// 注意：需要判断lchild不是前驱线索</span></span><br><span class="line">            <span class="built_in">PreThread</span>(T-&gt;lchild);  <span class="comment">// 先序遍历左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">PreThread</span>(T-&gt;rchild);  <span class="comment">// 先序遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(ThreadNode *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;lchild == <span class="literal">nullptr</span>) &#123;  <span class="comment">// 左子树为空，建立前驱线索</span></span><br><span class="line">        q-&gt;lchild = pre;</span><br><span class="line">        q-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pre != <span class="literal">nullptr</span> &amp;&amp; pre-&gt;rchild == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        pre-&gt;rchild = q;  <span class="comment">// 建立前驱结点的后继线索</span></span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = q;  <span class="comment">// 将 pre 指针指向当前结点（即下一个访问结点的前驱结点）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先序线索化二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateInThread</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">PreThread</span>(T);  <span class="comment">// 先序线索化除最后一个结点的其他结点</span></span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;rchild == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;  <span class="comment">// 处理最后一个结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后序线索二叉树的构造"><a class="header-anchor" href="#后序线索二叉树的构造"></a>后序线索二叉树的构造</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局遍历 pre 指向当前访问结点的前驱</span></span><br><span class="line">ThreadNode *pre = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历二叉树并进行线索化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostThread</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">PostThread</span>(T-&gt;lchild);  <span class="comment">// 后序遍历左子树</span></span><br><span class="line">        <span class="built_in">PostThread</span>(T-&gt;rchild);  <span class="comment">// 后序遍历右子树</span></span><br><span class="line">        <span class="built_in">visit</span>(T);               <span class="comment">// 访问根节点并线索化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(ThreadNode *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;lchild == <span class="literal">nullptr</span>) &#123;  <span class="comment">// 左子树为空，建立前驱线索</span></span><br><span class="line">        q-&gt;lchild = pre;</span><br><span class="line">        q-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pre != <span class="literal">nullptr</span> &amp;&amp; pre-&gt;rchild == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        pre-&gt;rchild = q;  <span class="comment">// 建立前驱结点的后继线索</span></span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = q;  <span class="comment">// 将 pre 指针指向当前结点（即下一个访问结点的前驱结点）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序线索化二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateInThread</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">PostThread</span>(T);  <span class="comment">// 后序线索化除最后一个结点的其他结点</span></span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;rchild == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;  <span class="comment">// 注意：处理最后一个结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线索二叉树的遍历"><a class="header-anchor" href="#线索二叉树的遍历"></a>线索二叉树的遍历</h4><p>在中序线索二叉树中找到指定结点 <code>*p</code> 的中序后继 <code>next</code>：</p><ol><li><p>若 <code>p-&gt;rtag == 1</code>，则  <code>next = p-&gt;rchild</code></p></li><li><p>若  <code>p-&gt;rtag == 0</code>，则  <code>next</code> 等于 <code>p</code> 的右子树中最左下的结点</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到以 p 为根的子树中，第一个被中序遍历的结点</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">FirstNode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 循环找到最左下结点（不一定是叶结点）</span></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;ltag == <span class="number">0</span>)&#123;</span><br><span class="line">        p = p-&gt;lchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在中序线索二叉树中找到结点 p 的后继结点</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">NextNode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 右子树中最左下结点</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;rtag == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">FirstNode</span>(p-&gt;rchild);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123; <span class="comment">// rtag==1 直接返回后继线索</span></span><br><span class="line">        <span class="keyword">return</span> p-&gt;rchild; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对中序线索二叉树进行中序遍历</span></span><br><span class="line"><span class="comment">// 利用线索实现的非递归算法 空间复杂度 O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(ThreadNode *T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ThreadNode *p = <span class="built_in">FirstNode</span>(T);p != <span class="literal">nullptr</span>;p = <span class="built_in">NextNode</span>(p))&#123;</span><br><span class="line">        <span class="built_in">visit</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在中序线索二叉树中找到指定结点 <code>*p</code> 的中序前驱 <code>pre</code>：</p><ol><li>若 <code>p-&gt;ltag == 1</code>，则  <code>pre = p-&gt;lchild</code></li><li>若  <code>p-&gt;ltag == 0</code>，则  <code>pre</code> 等于 <code>p</code> 的左子树中最右下的结点</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到以 p 为根的子树中，最后一个被中序遍历的结点</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">LastNode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 循环找到最右下结点(不一定是叶结点)</span></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;rtag == <span class="number">0</span>)&#123;</span><br><span class="line">        p = p-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在中序线索二叉树中找到结点 p 的前驱结点</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">PreNode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 左子树中最右下结点</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ltag == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">LastNode</span>(p-&gt;lchild);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123; <span class="comment">// ltag==1 直接返回前驱线索</span></span><br><span class="line">        <span class="keyword">return</span> p-&gt;lchild; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对中序线索二叉树进行逆向中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RevInOrder</span><span class="params">(ThreadNode *T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ThreadNode *p = <span class="built_in">LastNode</span>(T);p != <span class="literal">nullptr</span>;p = <span class="built_in">PreNode</span>(p))&#123;</span><br><span class="line">        <span class="built_in">visit</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>先序线索二叉树找指定结点 <code>*p</code> 的先序后继 <code>next</code></p><ol><li>若 <code>p-&gt;rtag == 1</code>，则 <code>next = p-&gt;rchild</code>；</li><li>若 <code>p-&gt;rtag == 0</code>，则 <code>p</code> 必有右孩子，分成两种情况考虑：<ul><li>若 <code>p</code> 有左孩子则先序后继为左孩子；</li><li>若没有左孩子则先序后继为右孩子</li></ul></li></ol><p>TODO 代码实现先序线索二叉树的后继遍历</p><p>在先序线索二叉树中找到指定结点 <code>*p</code> 的先序前驱 <code>pre</code></p><ol><li>若 <code>p-&gt;ltag == 1</code>，则 <code>next = p-&gt; lchild</code>；</li><li>若 <code>p-&gt;ltag == 0</code>，则 <code>p</code> 必有左孩子。二叉链表在先序遍历中，左右子树中的结点只可能是根的后继，不可能是前驱，故找不到先序前驱。三叉链表在先序遍历中，如果能找到 <code>p</code> 的父节点：<ul><li><code>p</code> 为左孩子，<code>p</code> 的父节点即为其前驱结点；</li><li><code>p</code> 是右孩子，其左兄弟为空，<code>p</code> 的父节点即为其前驱结点；</li><li><code>p</code> 是右孩子，其左兄弟非空，<code>p</code> 的前驱为左兄弟子树中最后一个被先序遍历的结点；</li><li>如果 <code>p</code> 是根结点，则 <code>p</code> 没有先序前驱。</li></ul></li></ol><hr><p>在后序线索二叉树找到指定结点 <code>*p</code> 的后序前驱 <code>pre</code>：</p><ol><li>若 <code>p-&gt;ltag == 1</code>，则 <code>pre = p-&gt;lchild</code></li><li>若 <code>p-&gt;ltag == 0</code>，则 <code>p</code> 必有左孩子，若 <code>p</code> 有右孩子，则后序前驱为右孩子；若 <code>p</code> 没有右孩子，则后序前驱为左孩子</li></ol><p>TODO 后序前驱遍历代码实现</p><p>在后序线索二叉树中找到指定结点 <code>*p</code> 的后序后继 <code>next</code>：</p><ol><li>若 <code>p-&gt;rtag == 1</code>，则 <code>next = p-&gt;rchild</code></li><li>若 <code>p-&gt;rtag == 0</code>，则 <code>p</code> 必有右孩子。二叉链表在后序遍历中，左右子树中的结点只可能是根的前驱，不可能是后继。三叉链表在后序遍历中，如果能找到 <code>p</code> 的父节点：<ul><li><code>p</code> 是右孩子，<code>p</code> 的父节点即为其后继结点；</li><li><code>p</code> 是左孩子，其右兄弟为空，<code>p</code> 的父节点即为其后继结点；</li><li><code>p</code> 是左孩子，其右兄弟非空，<code>p</code> 的后继为右兄弟子树中第一个被后序遍历的结点；</li><li>如果 <code>p</code> 是根节点，则 <code>p</code> 没有后继结点</li></ul></li></ol><h2 id="树、森林"><a class="header-anchor" href="#树、森林"></a>树、森林</h2><h3 id="树的存储结构"><a class="header-anchor" href="#树的存储结构"></a>树的存储结构</h3><p>树的存储方式有多种，既可采用顺序存储结构，又可采用链式存储结构，但无论采用何种存储方式，都要求能唯一地反映树中各结点之间的逻辑关系，这里介绍 3 种常用的存储结构。</p><h4 id="双亲表示法（顺序存储）"><a class="header-anchor" href="#双亲表示法（顺序存储）"></a>双亲表示法（顺序存储）</h4><p>这种存储方式采用一组连续空间来存储每个结点，同时在每个结点中增设一个伪指针，指示其<wavy>双亲结点</wavy>在数组中的位置。根结点下标为 0，其伪指针域为 -1。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E6%A0%91%E7%9A%84%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95.png" alt="树的双亲表示法"></p><p>双亲表示法的存储结构描述如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;     <span class="comment">// 数据元素</span></span><br><span class="line">    <span class="keyword">int</span> partent;  <span class="comment">// 双亲位置域</span></span><br><span class="line">&#125; PTNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PTNode nodoes[MAX_TREE_SIZE];  <span class="comment">// 双亲表示</span></span><br><span class="line">    <span class="keyword">int</span> n;                         <span class="comment">// 结点数</span></span><br><span class="line">&#125; PTree；</span><br></pre></td></tr></table></figure><h4 id="孩子表示法（顺序-链式存储）"><a class="header-anchor" href="#孩子表示法（顺序-链式存储）"></a>孩子表示法（顺序+链式存储）</h4><p>孩子表示法是将每个结点的孩子结点都用单链表链接起来形成一个线性结构，此时 $n$ 个结点就有 $n$ 个孩子链表（叶子结点的孩子链表为空表）。这种存储方式寻找子女的操作非常直接，而寻找双亲的操作需要遍历 $n$ 个结点中孩子链表指针域所指向的 $n$ 个孩子链表。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> child;            <span class="comment">// 孩子结点在数组中的位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span>  <span class="comment">// 下一个孩子</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">firstChild</span>;</span>  <span class="comment">// 第一个孩子</span></span><br><span class="line">&#125; CTBox;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    CTBox nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="keyword">int</span> n, r;  <span class="comment">// 结点数和根的位置</span></span><br><span class="line">&#125; CTree;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E5%AD%A9%E5%AD%90%E5%92%8C%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95.png" alt="孩子和孩子兄弟表示法"></p><h4 id="孩子兄弟表示法（链式存储）"><a class="header-anchor" href="#孩子兄弟表示法（链式存储）"></a>孩子兄弟表示法（链式存储）</h4><p>孩子兄弟表示法又称二叉树表示法，即以二叉链表作为树的存储结构。孩子兄弟表示法使每个结点包括三部分内容：结点值、指向结点第一个孩子结点的指针，及指向结点下一个兄弟结点的指针（沿此域可以找到结点的所有兄弟结点）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>, *<span class="title">nextsibling</span>;</span>  <span class="comment">// 第一个孩子和右兄弟指针</span></span><br><span class="line">&#125; CSNode, *CSTree;</span><br></pre></td></tr></table></figure><p>这种存储表示法比较灵活，其最大的优点是可以方便地实现树转换为二叉树的操作，易于查找结点的孩子等，但缺点是从当前结点查找其双亲结点比较麻烦。若为每个结点增设一个 <code>parent</code> 域指向其父结点，则查找结点的父结点也很方便。</p><h3 id="树、森林与二叉树的转换"><a class="header-anchor" href="#树、森林与二叉树的转换"></a>树、森林与二叉树的转换</h3><p>由于二叉树和树都可以用二叉链表作为存储结构，因此以二叉链表作为媒介可以导出树与二叉树的一个对应关系，即给定一棵树， 可以找到唯一的一棵二叉树与之对应。从物理结构上看，它们的二叉链表是相同的，只是解释不同而已。</p><p>树转换为二叉树的规则：每个结点左指针指向它的第一个孩子，右指针指向它在树中的相邻右兄弟，这个规则又称“左孩子右兄弟”。由于根结点没有兄弟，所以对应的二叉树没有右子树。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB.png" alt="树与二叉树的对应关系"></p><p>树转换成二叉树的画法：</p><ol><li>在兄弟结点之间加一连线；</li><li>对每个结点，只保留它与第一个孩子的连线，而与其他孩子的连线全部抹掉；</li><li>以树根为轴心，顺时针旋转45°。</li></ol><p>将森林转换为二叉树的规则与树类似。先将森林中的每棵树转换为二叉树，由于任何一棵和树对应的二叉树的右子树必空，若把森林中第二棵树根视为第一棵树根的右兄弟，即将第二棵树对应的二叉树当作第一棵二叉树根的右子树，将第三棵树对应的二叉树当作第二棵二叉树根的右子…以此类推，就可以将森林转换为二叉树。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E6%A3%AE%E6%9E%97%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB.png" alt="森林与二叉树的对应关系"></p><p>森林转换成二叉树的画法：</p><ol><li>将森林中的每棵树转换成相应的二叉树</li><li>每棵树的根也可视为兄弟关系，在每棵树的根之间加一根连线；</li><li>以第一棵树的根为轴心顺时针旋转45°。</li></ol><p>二叉树转换为森林的规则：若二叉树非空，则二叉树的根及其左子树为第一棵树的二叉树形式，故将根的右链断开。二叉树根的右子树又可视为一个由除第一棵树 外的森林转换后的二叉树，应用同样的方法，直到最后只剩一棵没有右子树的二叉树为止，最后再将每棵二叉树依次转换成树，就得到了原森林。二叉树转换为树或森林是唯一的。</p><h3 id="树和森林的遍历"><a class="header-anchor" href="#树和森林的遍历"></a>树和森林的遍历</h3><p>树的遍历是指用某种方式访问树中的每个结点，且仅访问一次。主要有两种方式（深度优先遍历）：</p><ol><li>先根遍历。若树非空，先访问根结点，再依次遍历根结点的每棵子树，遍历子树时仍遵循先根后子树的规则。其遍历序列与这棵树相应二叉树的先序序列相同。</li><li>后根遍历。若树非空，先依次遍历根结点的每棵子树，再访问根结点，遍历子树时仍遵循先子树后根的规则。其遍历序列与这棵树相应二叉树的中序序列相同。</li></ol><p>另外，树也有层次遍历（广度优先遍历），与二叉树的层次遍历思想基本相同，即按层序依次访问各结点。</p><p>按照森林和树相互递归的定义，可得到森林的两种遍历方法。</p><ol><li>先序遍历森林。若森林为非空，则按如下规则进行遍历（效果等同于依次对各个树进行先根遍历）：<ul><li>访问森林中第一棵树的根结点。</li><li>先序遍历第一棵树中根结点的子树森林。</li><li>先序遍历除去第一棵树之后剩余的树构成的森林。</li></ul></li><li>中序遍历森林。森林为非空时，按如下规则进行遍历（效果等同于依次对各个树进行后根遍历）：<ul><li>中序遍历森林中第一棵树的根结点的子树森林。</li><li>访问第一棵树的根结点。</li><li>中序遍历除去第一棵树之后剩余的树构成的森林。</li></ul></li></ol><h2 id="树与二叉树的应用"><a class="header-anchor" href="#树与二叉树的应用"></a>树与二叉树的应用</h2><h3 id="二叉排序树（BST）"><a class="header-anchor" href="#二叉排序树（BST）"></a>二叉排序树（BST）</h3><h4 id="二叉排序树的定义"><a class="header-anchor" href="#二叉排序树的定义"></a>二叉排序树的定义</h4><p>二叉排序树（也称二叉查找树）或者是一棵空树，或者是具有下列特性的二叉树：</p><ol><li>若左子树非空，则左子树上所有结点的值均小于根结点的值。</li><li>若右子树非空，则右子树上所有结点的值均大于根结点的值。</li><li>左、右子树也分别是一棵二叉排序树。</li></ol><p>根据二叉排序树的定义，左子树结点值 &lt; 根结点值 &lt; 右子树结点值，所以对二叉排序树进行中序遍历，可以得到一个<font color="#FF666">递增</font>的有序序列。</p><h4 id="二叉排序树的查找"><a class="header-anchor" href="#二叉排序树的查找"></a>二叉排序树的查找</h4><p>二叉排序树的查找是从根结点开始，沿某个分支逐层向下比较的过程。若二叉排序树非空，先将给定值与根结点的关键字比较，若相等，则查找成功；若不等，如果小于根结点的关键字，则在根结点的左子树上查找，否则在根结点的右子树上查找。这显然是一个递归的过程。</p><p>二叉排序树的非递归查找算法，最坏空间复杂度 $O(1)$ ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉排序树的结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; BSTNode, *BSTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在二叉排序树中查找值为 key 的结点</span></span><br><span class="line"><span class="function">BSTNode *<span class="title">BST_Search</span><span class="params">(BSTree T, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (T != <span class="literal">nullptr</span> &amp;&amp; key != T-&gt;key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; T-&gt;key) &#123;</span><br><span class="line">            T = T-&gt;lchild;  <span class="comment">// 小于 在左子树上查找</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            T = T-&gt;rchild;  <span class="comment">// 大于 在右子树上查找</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二叉排序树的递归查找算法实现，最坏空间复杂度 $O(h)$ ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BSTNode *<span class="title">BST_Search</span><span class="params">(BSTree T, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;  <span class="comment">// 查找失败</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key == T-&gt;key) &#123;</span><br><span class="line">        <span class="keyword">return</span> T;  <span class="comment">// 查找成功</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; T-&gt;key) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">BST_Search</span>(T-&gt;lchild, key);  <span class="comment">// 在左子树中查找</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">BST_Search</span>(T-&gt;rchild, key);  <span class="comment">// 在右子树中找</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉排序树的插入"><a class="header-anchor" href="#二叉排序树的插入"></a>二叉排序树的插入</h4><p>二叉排序树作为一种动态树表，其特点是树的结构通常不是一次生成的，而是在查找过程中，当树中不存在关键字值等于给定值的结点时再进行插入的。</p><p>插入结点的过程如下：若原二叉排序树为空，则直接插入结点；否则，若关键字 key 小于根结点值，则插入到左子树，若关键字 key 大于根结点值，则插入到右子树。插入的结点一定是一个新添加的叶结点，且是查找失败时的查找路径上访问的最后一个结点的左孩子或右孩子。</p><p>二叉排序树插入操作的算法描述如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在二叉排序树插入关键字为 k 的新结点（递归实现）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BST_Insert</span><span class="params">(BSTree &amp;T, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">nullptr</span>) &#123;  <span class="comment">// 树为空，新插入的结点为根结点</span></span><br><span class="line">        T = (BSTree)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(BSTNode));</span><br><span class="line">        T-&gt;key = k;</span><br><span class="line">        T-&gt;lchild = T-&gt;rchild = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k == T-&gt;key) &#123;  <span class="comment">// 树中存在相同关键字结点。插入失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; T-&gt;key) &#123;  <span class="comment">// 插入到T的左子树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">BST_Insert</span>(T-&gt;lchild, k);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 插入到T的右子树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">BST_Insert</span>(T-&gt;rchild, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TODO 实现二叉排序树插入操作的非递归实现</p><h4 id="二叉排序树的构造"><a class="header-anchor" href="#二叉排序树的构造"></a>二叉排序树的构造</h4><p>构造二叉排序树的算法描述如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Creat_BST</span><span class="params">(BSTree &amp;T, <span class="keyword">int</span> str[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    T = <span class="literal">nullptr</span>;  <span class="comment">// 初始时T为空树</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123; <span class="comment">// 依次将每个关键字插入到二叉排序树中</span></span><br><span class="line">        <span class="built_in">BST_Insert</span>(T, str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉排序树的删除"><a class="header-anchor" href="#二叉排序树的删除"></a>二叉排序树的删除</h4><p>在二叉排序树中删除一个结点时，不能把以该结点为根的子树上的结点都删除，必须先把被删除结点从存储二叉排序树的链表上摘下，将因删除结点而断开的二叉链表重新链接起来，同时确保二叉排序树的性质不会丢失。删除操作的实现过程按 3 种情况来处理：</p><ol><li>若被删除结点是叶结点，则直接删除，不会破坏二叉排序树的性质。</li><li>若结点 z 只有一棵左子树或右子树，则让 z 的子树成为 z 父结点的子树，替代 z 的位置。</li><li>若结点 z 有左、右两棵子树，则令 z 的直接后继（或直接前驱）替代 z，然后从二叉排序树中删去这个直接后继（或直接前驱），这样就转换成了第一或第二种情况。</li></ol><h4 id="二叉排序树的查找效率分析"><a class="header-anchor" href="#二叉排序树的查找效率分析"></a>二叉排序树的查找效率分析</h4><p>二叉排序树的查找效率，主要取决于树的高度。</p><p>若二叉排序树的左、右子树的高度之差的绝对值不超过 1，则这样的二叉排序树称为平衡二叉树，它的平均查找长度为 $O(\log_{2}{n})$ 。</p><p>若二叉排序树是一个只有右（左）孩子的单支树（类似于有序的单链表），则其平均查找长度为 $O(n)$。在最坏情况下，即构造二叉排序树的输入序列是有序的，则会形成一个倾斜的单支树，此时二叉排序树的性能显著变坏，树的高度也增加为元素个数 $n$ 。</p><p>从查找过程看，二叉排序树与二分查找相似。就平均时间性能而言，二叉排序树上的查找和二分查找差不多。但二分查找的判定树唯一，而二叉排序树的查找不唯一，相同的关键字其插入顺序不同可能生成不同的二叉排序树，</p><h3 id="平衡二叉树⭐"><a class="header-anchor" href="#平衡二叉树⭐"></a>平衡二叉树⭐</h3><h4 id="平衡二叉树的定义"><a class="header-anchor" href="#平衡二叉树的定义"></a>平衡二叉树的定义</h4><p>为避免树的高度增长过快，降低二叉排序树的性能，规定在插入和删除二叉树结点时，要保证任意结点的左、右子树高度差的绝对值不超过 1， 将这样的二叉树称为平衡二叉树（Balanced Binary Tree），简称平衡树（ AVL 树）。定义结点左子树与右子树的高度差为该<font color="#ea66a6">结点的平衡因子</font>，则平衡二叉树结点的平衡因子的值只可能是 -1、0 或 1。</p><p>因此，平衡二叉树可定义为或者是一棵空树，或者是具有下列性质的二叉树：它的左子树和右子树都是平衡二叉树，且左子树和右子树的高度差的绝对值不超过 1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 平衡二叉树结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> balance;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; AVLNode, *AVLTree;</span><br></pre></td></tr></table></figure><h4 id="平衡二叉树的插入"><a class="header-anchor" href="#平衡二叉树的插入"></a>平衡二叉树的插入</h4><p>二叉排序树保证平衡的基本思想如下：每当在二叉排序树中插入（或删除）一个结点时，首先检查其插入路径上的结点是否因为此次操作而导致了不平衡。若导致了不平衡，则先找到插入路径上离插入结点最近的平衡因子的绝对值大于 1 的结点 A，再对以 A 为根的子树，在保持二叉排序树特性的前提下，调整各结点的位置关系，使之重新达到平衡。</p><p>注意：每次调整的对象都是<font color="#ea66a6">最小不平衡子树</font>，即以插入路径上离插入结点最近的平衡因子的绝对值大于 1 的结点作为根的子树。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E6%9C%80%E5%B0%8F%E4%B8%8D%E5%B9%B3%E8%A1%A1%E5%AD%90%E6%A0%91%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="最小不平衡子树示意图"></p><p>平衡二叉树的插入过程的前半部分与二叉排序树相同，但在新结点插入后，若造成查找路径上的某个结点不再平衡，则需要做出相应的调整。可将调整的规律归纳为下列 4 种情况：</p><ol><li>LL 平衡旋转（右单旋转）。由于在结点 A 的左孩子（L）的左子树（L）上插入了新结点，A 的平衡因子由 1 增至 2，导致以 A 为根的子树失去平衡，需要一次向右的旋转操作。 将 A 的左孩子 B 向右上旋转代替 A 成为根结点，将 A 结点向右下旋转成为 B 的右子树的根结点，而 B 的原右子树则作为 A 结点的左子树。如下图所示，其中结点旁的数值代表结点的平衡因子，而用方块表示相应结点的子树，下方数值代表该子树的高度。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/LL%E5%B9%B3%E8%A1%A1%E6%97%8B%E8%BD%AC.png" alt="LL平衡旋转"></p><ol start="2"><li>RR 平衡旋转（左单旋转）。由于在结点 A 的右孩子（ R ）的右子树（ R ）。上插入了新结点，A 的平衡因子由 -1 减至 -2，导致以 A 为根的子树失去平衡，需要一次向左的旋转操作。将 A 的右孩子 B 向左，上旋转代替 A 成为根结点，将 A 结点向左下旋转成为 B 的左子树的根结点，而 B 的原左子树则作为 A 结点的右子树。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/RR%E5%B9%B3%E8%A1%A1%E6%97%8B%E8%BD%AC.png" alt="RR平衡旋转"></p><ol start="3"><li>LR 平衡旋转（先左后右双旋转）。由于在 A 的左孩子（L）的右子树（R）。上插入新结点，A 的平衡因子由 1 增至 2，导致以 A 为根的子树失去平衡，需要进行两次旋转操作，先左旋转后右旋转。先将 A 结点的左孩子 B 的右子树的根结点 C 向左上旋转提升到 B 结点的位置，然后再把该 C 结点向右上旋转提升到 A 结点的位置。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/LR%E5%B9%B3%E8%A1%A1%E6%97%8B%E8%BD%AC.png" alt="LR平衡旋转"></p><ol start="4"><li>RL 平衡旋转（先右后左双旋转）。由于在 A 的右孩子（R）的左子树（L）。上插入新结点，A 的平衡因子由 -1 减至 -2，导致以 A 为根的子树失去平衡，需要进行两次旋转操作，先右旋转后左旋转。先将 A 结点的右孩子 B 的左子树的根结点 C 向右上旋转提升到 B 结点的位置，然后再把该 C 结点向左上旋转提升到 A 结点的位置。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/RL%E5%B9%B3%E8%A1%A1%E6%97%8B%E8%BD%AC.png" alt="RL平衡旋转"></p><p>假设关键字序列为 <code>&#123;15, 3, 7, 10, 9, 8&#125;</code>，通过该序列生成平衡二叉树的过程如下图所示。(d) 插入 7 后导致不平衡，最小不平衡子树的根为 15，插入位置为其左孩子的右子树，故执行 LR 旋转，先左后右双旋转，调整后的结果如图 (e) 所示。图 (g) 插入 9 后导致不平衡，最小不平衡子树的根为 15，插入位置为其左孩子的左子树，故执行 LL 旋转，右单旋转，调整后的结果如图 (h) 所示。图 (i) 插入 8 后导致不平衡，最小不平衡子树的根为 7，插入位置为其右孩子的左子树，故执行 RL 旋转，先右后左双旋转，调整后的结果如图 (j) 所示。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B.png" alt="平衡二叉树的生成过程"></p><h4 id="平衡二叉树的查找"><a class="header-anchor" href="#平衡二叉树的查找"></a>平衡二叉树的查找</h4><p>在平衡二叉树上进行查找的过程与二叉排序树的相同。因此，在查找过程中，与给定值进行比较的关键字个数不超过树的深度。假设以 $n_h$ 表示深度为 $h$ 的平衡树中含有的最少结点数。显然，有 $n_0=0,n_1=1,n_2=2$ ，并且有 $n_h=n_{h-1}+n_{h-2}+1$ 。 可以证明，含有 $n$ 个结点的平衡二叉树的最大深度为 $O(\log_{2}{n})$，因此平衡二叉树的平均查找长度为 $O(\log_{2}{n})$ 。</p><h3 id="哈夫曼树和哈夫曼编码"><a class="header-anchor" href="#哈夫曼树和哈夫曼编码"></a>哈夫曼树和哈夫曼编码</h3><h4 id="哈夫曼树的定义"><a class="header-anchor" href="#哈夫曼树的定义"></a>哈夫曼树的定义</h4><p>在许多应用中，树中结点常常被赋予一个表示某种意义的数值，称为该<font color="#ea66a6">结点的权</font>（如：表示结点的重要性）。</p><p>从树的根到任意结点的路径长度（经过的边数）与该结点上权值的乘积，称为该<font color="#ea66a6">结点的带权路径长度</font>。</p><p>树中所有叶结点的带权路径长度之和称为该<font color="#ea66a6">树的带权路径长度</font>，记为 $$WPL=\sum_{i=1}^{n} w_il_i$$ 式中，$w_i$ 是第 $i$ 个叶结点所带的权值，$l_i$ 是该叶结点到根结点的路径长度。</p><p>在含有 $n$ 个带权叶结点的二叉树中，其中带权路径长度（WPL）最小的二叉树称为<font color="#ea66a6">哈夫曼树</font>，也称最优二叉树。</p><h4 id="哈夫曼树的构造"><a class="header-anchor" href="#哈夫曼树的构造"></a>哈夫曼树的构造</h4><p>给定 $n$ 个权值分别为 $w_i,\ w_2,\dots ,w_n$ 的结点，构造哈夫曼树的算法描述如下：</p><ol><li>将这 $n$ 个结点分别作为 $n$ 棵仅含一个结点的二叉树，构成森林 $F$。</li><li>构造一个新结点，从 $F$ 中选取两棵根结点权值最小的树作为新结点的左、右子树，并且将新结点的权值置为左、右子树上根结点的权值之和。</li><li>从 $F$ 中删除刚才选出的两棵树，同时将新得到的树加入 $F$ 中。</li><li>重复步骤 2 和 3，直至 $F$ 中只剩下一棵树为止。</li></ol><p>从上述构造过程中可以看出哈夫曼树具有如下特点：</p><ol><li>每个初始结点最终都成为叶结点，且权值越小的结点到根结点的路径长度越大。</li><li>构造过程中共新建了$n-1$个结点（双分支结点），因此哈夫曼树的结点总数为 $2n-1$ 。</li><li>每次构造都选择 2 棵树作为新结点的孩子，因此哈夫曼树中不存在度为 1 的结点。</li></ol><h4 id="哈夫曼编码"><a class="header-anchor" href="#哈夫曼编码"></a>哈夫曼编码</h4><p>在数据通信中：</p><ul><li>若对每个字符用相等长度的二进制位表示，称这种编码方式为<font color="#ea66a6">固定长度编码</font>。</li><li>若允许对不同字符用不等长的二进制位表示，则这种编码方式称为<font color="#ea66a6">可变长度编码</font>。</li></ul><p>可变长度编码比固定长度编码要好得多，其特点是对频率高的字符赋以短编码，而对频率较低的字符则赋以较长一些的编码，从而可以使字符的平均编码长度减短，起到压缩数据的效果。哈夫曼编码是一种被广泛应用而且非常有效的数据压缩编码。</p><p>若没有一个编码是另一个编码的前缀，则称这样的编码为<font color="#ea66a6">前缀编码</font>。举例:设计字符 A，B 和 C 对应的编码 0，101 和 100 是前缀编码。对前缀编码的解码很简单，因为没有一个编码是其他编码的前缀。所以识别出第一个编码，将它翻译为原码，再对余下的编码文件重复同样的解码操作。例如，码串 00101100 可被唯一地翻译为0，0，101 和 100。另举反例：如果再将字符 D 的编码设计为 00，此时 0 是 00 的前缀，那么这样的码串的前两位就无法唯一翻译。</p><p>由哈夫曼树得到哈夫曼编码是很自然的过程。首先，将每个出现的字符当作一个独立的结点，其权值为它出现的频度（或次数），构造出对应的哈夫曼树。显然，所有字符结点都出现在叶结点中。我们可将字符的编码解释为从根至该字符的路径上边标记的序列，其中边标记为 0 表示“转向左孩子”，标记为 1 表示“转向右孩子”。</p><p>注意：0 和 1 究竟是表示左子树还是右子树没有明确规定。左、右孩子结点的顺序是任意的，所以构造出的哈夫曼树并不唯一，但各哈夫曼树的带权路径长度 WPL 相同且为最优。此外，如有若干权值相同的结点，则构造出的哈夫曼树更可能不同，但 WPL 必然相同且是最优的。</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>推导过程：$$\frac{m^{h-1}-1}{m-1}&lt;n\le \frac{m^h-1}{m-1}$$ $$m^{h-1}&lt;n(m-1)+1\le m^h $$ $$ h-1 &lt; \log_{m}{(n(m-1)+1)} \le h $$ $$h_{min}= \left \lceil \log_{m}{(n(m-1)+1) } \right \rceil $$ <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
    <summary type="html">树</summary>
    
    
    
    <category term="数据结构" scheme="http://halo123.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="http://halo123.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>串</title>
    <link href="http://halo123.top/2021/05/07/DataStructure/D_String/"/>
    <id>http://halo123.top/2021/05/07/DataStructure/D_String/</id>
    <published>2021-05-07T03:54:51.000Z</published>
    <updated>2021-05-14T11:54:02.478Z</updated>
    
    <content type="html"><![CDATA[<p>【知识框架】</p><p>TODO 完成串知识框架</p><p>【复习提示】</p><p>本章是统考大纲第 6 章内容，采纳读者建议单独作为一章，统考大纲只要求掌握字符串模式匹配，需重点掌握 KMP 匹配算法的原理及 next 数组的推理过程，手工求 <code>next</code> 数组可以先计算出部分匹配值表然后再变形，或根据公式来求解。了解 <code>nextval</code> 数组的求解方法。</p><h2 id="串的定义和实现"><a class="header-anchor" href="#串的定义和实现"></a>串的定义和实现</h2><p>字符串简称串，计算机上非数值处理的对象基本都是字符串数据。我们常见的信息检索系统（如搜索引擎）、文本编辑程序（如Word）、问答系统、自然语言翻译系统等，都是以字符串数据作为处理对象的。本章详细介绍字符串的存储结构及相应的操作。</p><h3 id="串的定义"><a class="header-anchor" href="#串的定义"></a>串的定义</h3><p>串（string）是由零个或多个字符组成的有限序列。一般记为$$S=’ a_1a_2\dots a_n \ (n\ge 0)'$$其中，$S$ 是串名，单引号括起来的字符序列是串的值；$a_i$可以是字母、数字或其他字符；串中字符的个数 $n$ 称为串的长度。$n=0$ 时的串称为空串（用 $\varnothing$ 表示）。</p><ul><li>串中任意个<font color="#FF666">连续的</font>字符组成的子序列称为该串的<font color="#ea66a6">子串</font>（包括空串）</li><li>包含子串的串相应地称为<font color="#ea66a6">主串</font>。</li><li>某个字符在串中的序号称为该<font color="#ea66a6">字符在串中的位置</font>（序号从1开始）。</li><li><font color="#ea66a6">子串在主串中的位置</font>以子串的第一个字符在主串中的位置来表示。</li><li>当两个串的长度相等且每个对应位置的字符都相等时，称这两个串是相等的。</li></ul><blockquote><p>需要注意的是，由一个或多个空格（空格是特殊字符）组成的串称为空格串（注意，空格串不是空串），其长度为串中空格字符的个数。</p></blockquote><p>串的逻辑结构和线性表极为相似，区别仅在于串的数据对象限定为字符集。在基本操作上，串和线性表有很大差别。线性表的基本操作主要以单个元素作为操作对象，如查找、插入或删除某个元素等；而串的基本操作通常以子串作为操作对象，如查找、插入或删除一个子串等。</p><h3 id="串的存储结构"><a class="header-anchor" href="#串的存储结构"></a>串的存储结构</h3><h4 id="定长顺序存储表示"><a class="header-anchor" href="#定长顺序存储表示"></a>定长顺序存储表示</h4><p>类似于线性表的顺序存储结构，用一组地址连续的存储单元存储串值的字符序列。在串的定长顺序存储结构中，为每个串变量分配一个固定长度的存储区，即定长数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLEN 255</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch[MAXLEN];  <span class="comment">// 每个分量存储一个字符串</span></span><br><span class="line">    <span class="keyword">int</span> length;       <span class="comment">// 串的实际长度</span></span><br><span class="line">&#125; SString;</span><br></pre></td></tr></table></figure><p>串的实际长度只能小于等于 <code>MAXLEN</code>，超过预定义长度的串值会被舍去，称为截断。串长有两种表示方法：</p><ul><li>一是如上述定义描述的那样，用一个额外的变量 <code>length</code> 来存放串的长度</li><li>二是在串值后面加一个不计入串长的结束标记字符“\0”， 此时的串长为隐含值。</li></ul><p>在一些串的操作（如插入、联接等）中，若串值序列的长度超过上界 <code>MAXLEN</code>，约定用“截断”法处理，要克服这种弊端，只能不限定串长的最大长度，即采用动态分配的方式。</p><h4 id="堆分配存储表示"><a class="header-anchor" href="#堆分配存储表示"></a>堆分配存储表示</h4><p>堆分配存储表示仍然以一组地址连续的存储单元存放串值的字符序列，但它们的存储空间是在程序执行过程中动态分配得到的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLEN 255</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *ch;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125; HString;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitHString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HString S;</span><br><span class="line">    S.ch = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(MAXLEN * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>));</span><br><span class="line">    S.length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在C语言中，存在一个称之为“堆”的自由存储区，并用 <code>malloc()</code> 和 <code>free()</code> 函数来完成动态存储管理。利用 <code>malloc()</code> 为每个新产生的串分配一块实际串长所需的存储空间，若分配成功，则返回一个指向起始地址的指针，作为串的基地址，这个串由 <code>ch</code> 指针来指示；若分配失败，则返回 <code>NULL</code>。已分配的空间可用 <code>free()</code> 释放掉。</p><p>上述两种存储表示通常为高级程序设计语言所采用。块链存储表示仅做简单介绍。</p><h4 id="块链存储表示"><a class="header-anchor" href="#块链存储表示"></a>块链存储表示</h4><p>类似于线性表的链式存储结构，也可采用链表方式存储串值。由于串的特殊性（每个元素只有一个字符），在具体实现时，每个结点既可以存放一个字符，也可以存放多个字符。每个结点称为块，整个链表称为块链结构。最后一个结点占不满时通常用 <code>#</code> 补上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch[<span class="number">4</span>]; <span class="comment">// 每个结点存多个字符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125; StringNode, * String;</span><br></pre></td></tr></table></figure><h3 id="串的基本操作"><a class="header-anchor" href="#串的基本操作"></a>串的基本操作</h3><ul><li><code>StrAssign(&amp;T,chars)</code>：赋值操作。把串 T 赋值为 chars</li><li><code>StrCopy(&amp;T,S)</code>：复制操作。由串 S 复制得到串 T</li><li><code>StrEmpty(S)</code>：判空操作。若 S 为空串，则返回 TRUE，否则返回 FALSE</li><li><code>StrCompare(S, T)</code>：比较操作。若 S&gt;T，则返回值 &gt;0 ；若S=T，则返回值 =0 ；若 S&lt;T，则返回值 &lt;0</li><li><code>StrLength(S)</code>：求串长。返回串 S 的元素个数</li><li><code>SubString (&amp;Sub,S,pos,len)</code>：求子串。用 Sub 返回串 S 的第 pos 个字符起长度为 len 的子串</li><li><code>Concat (&amp;T,S1,S2)</code>：串联接。用 T 返回由 S1 和 S2 联接而成的新串</li><li><code>Index(S,T)</code>：定位操作。若主串 S 中存在与串 T 值相同的子串，则返回它在主串 S 中第一次出现的位置；否则函数值为0</li><li><code>ClearString(&amp;S)</code>：清空操作。将 S 清为空串</li><li><code>DestroyString(&amp;S)</code>：销毁串。将串S销毁</li></ul><p>不同的高级语言对串的基本操作集可以有不同的定义方法。在上述定义的操作中，串赋值 <code>StrAssign</code>、串比较 <code>StrCompare</code>、求串长 <code>StrLength</code>、串联接 <code>Concat</code> 及求子串 <code>SubString</code> 五种操作构成串类型的最小操作子集，即这些操作不可能利用其他串操作来实现；反之，其他串操作（除串清除 <code>ClearString</code> 和串销毁 <code>DestroyString</code> 外）均可在该最小操作子集上实现。</p><p>例如，可利用判等、求串长和求子串等操作实现定位函数 <code>Index(S, T)</code>。算法思想为：在主串 $S$ 中取从第一个字符起、长度和串 $T$ 相等的子串，与串 $T$ 比较，若相等则求得函数值为 $i$，否则 $i$ 值增1，直至串 $S$ 中不存在和串 $T$ 相等的子串为止。</p><h4 id="实现求子串"><a class="header-anchor" href="#实现求子串"></a>实现求子串</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求子串。用 Sub 返回串 S 的第 pos 个字符起长度为 len 的子串</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SubString</span><span class="params">(SString &amp;Sub, SString S, <span class="keyword">int</span> pos, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 子串范围越界</span></span><br><span class="line">    <span class="keyword">if</span> (pos + len - <span class="number">1</span> &gt; S.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt; pos + len; i++) &#123;</span><br><span class="line">        Sub.ch[i - pos + <span class="number">1</span>] = S.ch[i];</span><br><span class="line">    &#125;</span><br><span class="line">    Sub.length = len;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现比较操作"><a class="header-anchor" href="#实现比较操作"></a>实现比较操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较操作。若 S&gt;T，则返回值 &gt;0 ；若S=T，则返回值 =0 ；若 S&lt;T，则返回值 &lt;0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrCompare</span><span class="params">(SString S, SString T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= S.length &amp;&amp; i &lt;= T.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S.ch[i] != T.ch[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> S.ch[i] - T.ch[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 扫描过所有字符都相同，则长度长的串更大</span></span><br><span class="line">    <span class="keyword">return</span> S.length - T.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现定位操作"><a class="header-anchor" href="#实现定位操作"></a>实现定位操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定位操作。</span></span><br><span class="line"><span class="comment">// 若主串 S 中存在与串 T 值相同的子串，则返回它在主串 S 中第一次出现的位置；</span></span><br><span class="line"><span class="comment">// 否则函数值为0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index</span><span class="params">(SString S, SString T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>, n = S.length, m = T.length;</span><br><span class="line">    SString sub;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n - m + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">SubString</span>(sub, S, i, m);        <span class="comment">// 求子串</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">StrCompare</span>(sub, T) != <span class="number">0</span>) &#123;  <span class="comment">// 比较操作</span></span><br><span class="line">            ++i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i;  <span class="comment">// 返回子串在主串中的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="串的模式匹配"><a class="header-anchor" href="#串的模式匹配"></a>串的模式匹配</h2><h3 id="简单的模式匹配算法"><a class="header-anchor" href="#简单的模式匹配算法"></a>简单的模式匹配算法</h3><p>子串的定位操作通常称为串的模式匹配，它求的是子串（常称模式串）在主串中的位置。这里采用定长顺序存储结构，给出一种不依赖于其他串操作的暴力匹配算法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 朴素模式匹配算法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index2</span><span class="params">(SString S, SString T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">1</span>;  <span class="comment">// 指向主串开始匹配的位置</span></span><br><span class="line">    <span class="keyword">int</span> i = k;  <span class="comment">// 主串匹配时的匹配位置 </span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;  <span class="comment">// 子串匹配时对应的位置</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= S.length &amp;&amp; j &lt;= T.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S.ch[i] == T.ch[j]) &#123;  <span class="comment">// 相等检查下一个字符</span></span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 有不相等检查下一个子串</span></span><br><span class="line">            k++;</span><br><span class="line">            i = k; <span class="comment">// 如果不设置k，i=i-j+2</span></span><br><span class="line">            j = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果因为主串匹配完导致结束需要判断子串是否刚好匹配</span></span><br><span class="line">    <span class="comment">// 如果j超出边界说明子串得到匹配</span></span><br><span class="line">    <span class="keyword">if</span> (j &gt; T.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述算法中，分别用计数指针 $i$ 和 $j$ 指示主串 $S$ 和模式串 $T$ 中当前正待比较的字符位置。算法思想为：从主串 $S$ 的第一个字符起，与模式 $T$ 的第一个字符比较，若相等，则继续逐个比较后续字符；否则从主串的下一个字符起，重新和模式的字符比较；以此类推，直至模式 $T$ 中的每个字符依次和主串 $S$ 中的一个连续的字符序列相等，则称匹配成功，函数值为与模式 $T$ 中第一个字符相等的字符在主串 $S$ 中的序号，否则称匹配不成功，函数值为零。将主串中与模式串长度相同的子串搞出来，挨个与模式串对比当子串与模式串某个对应字符不匹配时，就立即放弃当前子串，转而检索下一个子串。</p><p>若 $m$ 为模式串长度，$n$ 为主串长度，则</p><ul><li>匹配成功的最好时间复杂度为：$O(m)$</li><li>匹配失败的最好时间复杂度为：$O(n-m+1)=O(n-m)\approx O(n)$</li><li>匹配成功的最坏时间复杂度为：$O(nm-m^2+m)\approx O(nm)$</li></ul><p>最坏情况：每个子串的前 $m-1$ 个字符都和模式串匹配，只有第 $m$ 个字符不匹配；</p><p>比较好的情况：每个子串的第 1 个字符就与模式串不匹配。</p><h3 id="KMP算法"><a class="header-anchor" href="#KMP算法"></a>KMP算法</h3><blockquote><p>由D. E.Knuth，J.H.Morris和 V.R.Pratt 提出，因此称为KMP算法</p></blockquote><p>推荐直接看视频理解思想：<a href="https://www.bilibili.com/video/BV1b7411N798?p=35">数据结构，KPM算法</a></p><p>概况是对朴素模式匹配算法的优化，通过引入next数组来减少回溯。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// KMP算法思想</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index_KMP</span><span class="params">(SString S, SString T, <span class="keyword">int</span> next[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= S.length &amp;&amp; j &lt;= T.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || S.ch[i] == T.ch[j]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j]; <span class="comment">// 模式串向右移动</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &gt; T.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> i - T.length;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="求模式串的next数组"><a class="header-anchor" href="#求模式串的next数组"></a>求模式串的next数组</h4><ul><li>串的前缀：包含第一个字符，且不包含最后一个字符的子串。</li><li>串的后缀：包含最后一个字符，且不包含第一个字符的子串.</li></ul><p>next数组手算方法：当第 j 个字符匹配失败，由前 1~j-1 个字符组成的串记为 S，则：next[j] = S的最长相等前缀长度+1，特别的 next[1] = 0；此外存在next[2]时 next[2] = 1。</p><h4 id="KMP算法性能分析"><a class="header-anchor" href="#KMP算法性能分析"></a>KMP算法性能分析</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取next数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_next</span><span class="params">(SString T, <span class="keyword">int</span> next[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; T.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || T.ch[i] == T.ch[j]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// KMP算法实现</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index_KMP</span><span class="params">(SString S, SString T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> next[T.length + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">get_next</span>(T, next);</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= S.length &amp;&amp; j &lt;= T.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || S.ch[i] == T.ch[j]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &gt; T.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> i - T.length;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>KMP算法平均时间复杂度：$O(n+m)$</p><h4 id="KMP算法优化"><a class="header-anchor" href="#KMP算法优化"></a>KMP算法优化</h4><p>next 数组在某些情况下尚有缺陷，还可以进一步优化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nextval</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_nextval</span><span class="params">(SString T, <span class="keyword">int</span> nextval[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    nextval[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; T.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || T.ch[i] == T.ch[j]) &#123;</span><br><span class="line">            nextval[i] = j;</span><br><span class="line">            <span class="keyword">if</span> (T.ch[i] != T.ch[j]) &#123;</span><br><span class="line">                nextval[i] = j;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nextval[i] = nextval[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = nextval[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">字符串模式匹配</summary>
    
    
    
    <category term="数据结构" scheme="http://halo123.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="http://halo123.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
