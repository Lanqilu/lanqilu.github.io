<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HALO</title>
  
  <subtitle>HALO</subtitle>
  <link href="http://halo123.top/atom.xml" rel="self"/>
  
  <link href="http://halo123.top/"/>
  <updated>2021-05-11T12:26:41.268Z</updated>
  <id>http://halo123.top/</id>
  
  <author>
    <name>HALO</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>小小世界</title>
    <link href="http://halo123.top/2021/05/11/Plan/%E5%B0%8F%E5%B0%8F%E4%B8%96%E7%95%8C/"/>
    <id>http://halo123.top/2021/05/11/Plan/%E5%B0%8F%E5%B0%8F%E4%B8%96%E7%95%8C/</id>
    <published>2021-05-11T11:46:48.000Z</published>
    <updated>2021-05-11T12:26:41.268Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原神"><a class="header-anchor" href="#原神"></a>原神</h2><h3 id="优菈角色PV「深夜酒馆的邂逅」"><a class="header-anchor" href="#优菈角色PV「深夜酒馆的邂逅」"></a>优菈角色PV「深夜酒馆的邂逅」</h3><p>2021年5月11日 PV链接</p><div class="tag link"><a class="link-card" title="【哔哩哔哩】优菈角色PV「深夜酒馆的邂逅」" href="https://www.bilibili.com/video/BV17b4y1f7Lt"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/哔哩哔哩icon.svg"/></div><div class="right"><p class="text">【哔哩哔哩】优菈角色PV「深夜酒馆的邂逅」</p><p class="url">https://www.bilibili.com/video/BV17b4y1f7Lt</p></div></a></div><h2 id="明日方舟"><a class="header-anchor" href="#明日方舟"></a>明日方舟</h2><h3 id="危机合约新赛季「光谱行动」"><a class="header-anchor" href="#危机合约新赛季「光谱行动」"></a>危机合约新赛季「光谱行动」</h3><p>2021年5月10日 放出<a href="https://www.bilibili.com/video/BV1264y117Py">宣传PV</a></p><p>2021年5月11日 <a href="https://t.bilibili.com/523468243217968769?tab=2">活动奖励服饰</a> 浅滩律动 - 蓝毒</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/%E6%B5%85%E6%BB%A9%E5%BE%8B%E5%8A%A8%E8%93%9D%E6%AF%92.jpg" alt="浅滩律动蓝毒"></p><h3 id="二周年庆「覆潮之下」"><a class="header-anchor" href="#二周年庆「覆潮之下」"></a>二周年庆「覆潮之下」</h3><p>2021年5月11日 116抽终于抽到了浊心斯卡蒂，116抽只出了两个6星，另一个是W，可惜我之前有了，加了一潜。两次触发伪保底，还好斯卡蒂没歪，可谓是最坏的情况下的最好结果。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/%E6%98%8E%E6%97%A5%E6%96%B9%E8%88%9F%E4%BA%8C%E5%91%A8%E5%B9%B4%E5%BA%86%E5%8D%A1%E6%B1%A0.jpg" alt="明日方舟二周年庆卡池"></p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/%E6%98%8E%E6%97%A5%E6%96%B9%E8%88%9F%E4%BA%8C%E5%91%A8%E5%B9%B4%E5%BA%86%E7%89%88%E6%9C%AC.jpg" alt="明日方舟二周年庆版本"></p><h2 id="动漫"><a class="header-anchor" href="#动漫"></a>动漫</h2>]]></content>
    
    
    <summary type="html">初衷用于记录我所关注的二次元圈</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>大事小事记</title>
    <link href="http://halo123.top/2021/05/11/Plan/%E5%A4%A7%E4%BA%8B%E5%B0%8F%E4%BA%8B%E8%AE%B0/"/>
    <id>http://halo123.top/2021/05/11/Plan/%E5%A4%A7%E4%BA%8B%E5%B0%8F%E4%BA%8B%E8%AE%B0/</id>
    <published>2021-05-11T11:40:48.000Z</published>
    <updated>2021-05-11T12:28:16.785Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第七次全国人口普查数据"><a class="header-anchor" href="#第七次全国人口普查数据"></a>第七次全国人口普查数据</h3><p>2021年5月11日 公布第七次全国人口普查数据</p><div class="tag link"><a class="link-card" title="【国家统计局】第七次全国人口普查主要数据情况" href="http://www.stats.gov.cn/tjsj/zxfb/202105/t20210510_1817176.html"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E7%BD%91%E7%AB%99.svg"/></div><div class="right"><p class="text">【国家统计局】第七次全国人口普查主要数据情况</p><p class="url">http://www.stats.gov.cn/tjsj/zxfb/202105/t20210510_1817176.html</p></div></a></div><ol><li>人口总量。全国人口共 141178 万人，与 2010 年（第六次全国人口普查数据，下同）的 133972 万人相比，增加 7206 万人，增长 5.38%，年平均增长率为 0.53%，比 2000 年到 2010 年的年平均增长率 0.57%下降 0.04个百分点。数据表明，我国人口 10 年来继续保持低速增长态势。</li><li>户别人口。全国共有家庭户 49416 万户，家庭户人口为 129281 万人；集体户 2853 万户，集体户人口为 11897 万人。平均每个家庭户的人口为 2.62 人，比 2010 年的 3.10 人减少 0.48 人。家庭户规模继续缩小，主要是受我国人口流动日趋频繁和住房条件改善年轻人婚后独立居住等因素的影响。</li><li>人口地区分布。东部地区人口占 39.93%，中部地区占 25.83%，西部地区占 27.12%，东北地区占 6.98%。与 2010 年相比，东部地区人口所占比重上升 2.15 个百分点，中部地区下降 0.79 个百分点，西部地区上升 0.22 个百分点，东北地区下降 1.20 个百分点。人口向经济发达区域、城市群进一步集聚。</li><li>性别构成。男性人口为 72334 万人，占 51.24 %；女性人口为 68844 万人，占 48.76%。总人口性别比（以女性为 100，男性对女性的比例）为 105.07，与 2010 年基本持平，略有降低。出生人口性别比为 111.3，较 2010 年下降 6.8。我国人口的性别结构持续改善。</li><li>年龄构成。0—14 岁人口为 25338 万人，占 17.95%；15—59 岁人口为 89438 万人，占 63.35 %；60 岁及以上人口为 26402 万人，占 18.70%（其中，65 岁及以上人口为 19064 万人，占 13.50%）。与 2010 年相比，0—14 岁、15—59 岁、60 岁及以上人口的比重分别上升 1.35 个百分点、下降 6.79 个百分点、上升 5.44 个百分点。我国少儿人口比重回升，生育政策调整取得了积极成效。同时，人口老龄化程度进一步加深，未来一段时期将持续面临人口长期均衡发展的压力。</li><li>受教育程度人口。具有大学文化程度的人口为 21836 万人。与 2010 年相比，每 10 万人中具有大学文化程度的由 8930 人上升为 15467 人，15岁及以上人口的平均受教育年限由 9.08 年提高至 9.91 年，文盲率由 4.08%下降为 2.67%。受教育状况的持续改善反映了 10 年来我国大力发展高等教育以及扫除青壮年文盲等措施取得了积极成效，人口素质不断提高。</li><li>城乡人口。居住在城镇的人口为 90199 万人，占 63.89%；居住在乡村的人口为 50979万人，占 36.11%。与 2010 年相比，城镇人口增加 23642 万人，乡村人口减少 16436 万人，城镇人口比重上升 14.21 个百分点。随着我国新型工业化、信息化和农业现代化的深入发展和农业转移人口市民化政策落实落地，10 年来我国新型城镇化进程稳步推进，城镇化建设取得了历史性成就。</li><li>流动人口。人户分离人口为 49276 万人，其中，市辖区内人户分离人口为 11694 万人，流动人口为 37582 万人，其中，跨省流动人口为 12484 万人。与 2010 年相比，人户分离人口增长 88.52%，市辖区内人户分离人口增长 192.66%，流动人口增长 69.73%。我国经济社会持续发展，为人口的迁移流动创造了条件，人口流动趋势更加明显，流动人口规模进一步扩大。</li><li>民族人口。汉族人口为 128631 万人，占 91.11%；各少数民族人口为 12547 万人，占 8.89%。与 2010 年相比，汉族人口增长 4.93%，各少数民族人口增长 10.26%，少数民族人口比重上升 0.40 个百分点。民族人口稳步增长，充分体现了在中国共产党领导下，我国各民族全面发展进步的面貌。</li></ol><h3 id="技嘉宣称中国大陆代工制造为「低质量、低成本」"><a class="header-anchor" href="#技嘉宣称中国大陆代工制造为「低质量、低成本」"></a>技嘉宣称中国大陆代工制造为「低质量、低成本」</h3><p>2021年5月11日 事件技嘉作死</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/%E5%85%B1%E9%9D%92%E5%9B%A2%E4%B8%AD%E5%A4%AEB%E7%AB%99%E6%8A%80%E5%98%89%E5%8A%A8%E6%80%81.png" alt="共青团中央B站技嘉动态"></p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/%E6%8A%80%E5%98%89%E4%BA%8B%E4%BB%B6.webp" alt="技嘉事件"></p><div class="tag link"><a class="link-card" title="【知乎】技嘉事件" href="https://www.zhihu.com/question/458796364"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/知乎icon.png"/></div><div class="right"><p class="text">【知乎】技嘉事件</p><p class="url">https://www.zhihu.com/question/458796364</p></div></a></div>]]></content>
    
    
    <summary type="html">初衷用于记录我所关注的一些大事小事</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>数据结构——图</title>
    <link href="http://halo123.top/2021/05/09/DataStructure/F_graph/"/>
    <id>http://halo123.top/2021/05/09/DataStructure/F_graph/</id>
    <published>2021-05-09T14:50:51.000Z</published>
    <updated>2021-05-11T07:20:14.716Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图的基本概念"><a class="header-anchor" href="#图的基本概念"></a>图的基本概念</h2><h3 id="图的定义"><a class="header-anchor" href="#图的定义"></a>图的定义</h3><p>图 $G$ 由顶点集 $V$ 和边集 $E$ 组成，记为 $G=(V,E)$，其中 $V(G)$ 表示图 $G$ 中顶点的有限非空集；$E(G)$ 表示图 $G$ 中顶点之间的关系 （边）集合。若 $V= {v_1,v_2,\dots v_n}$，则用 $|V|$ 表示图 $G$ 中顶点的个数，也称图 $G$ 的阶，$E= {(\mu,\nu)|\mu \in V,\nu \in V  } $，用 $|E|$ 表示图 $G$ 中边的条数。</p><p>注意：线性表可以是空表，树可以是空树，但图不可以是空图。就是说，图中不能一个顶点也没有，图的顶点集 $V$ 一定非空，但边集 $E$ 可以为空，此时图中只有顶点而没有边。</p><p>下面是图的一些基本概念及术语。</p><h4 id="有向图和无向图"><a class="header-anchor" href="#有向图和无向图"></a>有向图和无向图</h4><p>若 $E$ 是有向边（也称弧）的有限集合时，则图 $G$ 为有向图。弧是顶点的有序对，记为 $&lt;v, w&gt;$ ，其中 $v$，$w$ 是顶点，$v$ 称为弧尾，$w$ 称为弧头，$&lt;v, w&gt;$ 称为从顶点 $v$ 到顶点 $w$ 的弧，也称 $v$ 邻接到 $w$，或 $w$ 邻接自 $v$。</p><p>若 $E$ 是无向边（简称边）的有限集合时，则图 $G$ 为无向图。边是顶点的无序对，记为 $(v,w)$ 或 $(w,v)$，因为$(v, w)=(w,v)$ 其中 $v$，$w$ 是顶点。可以说顶点 $w$ 和顶点 $v$ 互为邻接点。边 $(v, w)$ 依附于顶点 $w$ 和 $v$ ，或者说边 $(v, w)$ 和顶点 $v$，$w$ 相关联。</p><h4 id="简单图和多重图"><a class="header-anchor" href="#简单图和多重图"></a>简单图和多重图</h4><p>一个图 $G$ 若满足：</p><ol><li>不存在重复边；</li><li>不存在顶点到自身的边，则称图 $G$ 为简单图。</li></ol><p>数据结构中仅讨论简单图。</p><p>若图 $G$ 中某两个结点之间的边数多于一条，又允许顶点通过同一.条边和自己关联，则 $G$ 为多重图。多重图的定义和简单图是相对的。</p><h4 id="顶点的度、入度和出度"><a class="header-anchor" href="#顶点的度、入度和出度"></a>顶点的度、入度和出度</h4><p>图中每个顶点的度定义为以该顶点为一个端点的边的数目。</p><p>对于无向图，顶点 $v$  的度是指依附于该顶点的边的条数，记为 $\mathrm{TD} (v)$。</p><p>在具有 $n$ 个顶点、$e$ 条边的无向图中，$\sum_{i=1}^{n} \mathrm{TD} (v_i)=2e$，即无向图的全部顶点的度的和等于边数的2倍，因为每条边和两个顶点相关联。</p><p>对于有向图，顶点 $v$ 的度分为入度和出度，入度是以顶点 $v$ 为终点的有向边的数目，记为 $\mathrm{ID}(v)$；而出度是以顶点 $v$ 为起点的有向边的数目，记为  $\mathrm{OD}(v)$。顶点 $v$ 的度等于其入度和出度之和，即 $\mathrm{TD} (v)=\mathrm{ID}(v)+\mathrm{OD}(v)$。</p><p>在具有 $n$ 个顶点、$e$ 条边的有向图中，$\sum_{i=1}^{n} \mathrm{ID} (v_i)=\sum_{i=1}^{n} \mathrm{OD} (v_i)=e$，即有向图的全部顶点的入度之和与出度之和相等，并且等于边数。这是因为每条有向边都有一个起点和终点。</p><h4 id="路径、路径长度和回路"><a class="header-anchor" href="#路径、路径长度和回路"></a>路径、路径长度和回路</h4><p>顶点 $v_p$ 到顶点 $v_q$ 之间的一条路径是指顶点序列 $v_p,v_{i1},v_{i2},\dots ,v_{im},v_q$，当然关联的边也可以理解为路径的构成要素。</p><p>路径上边的数目称为路径长度。</p><p>第一个顶点和最后一个顶点相同的路径称为回路或环。若一个图有 $n$ 个顶点，并且有大于 $n-1$ 条边，则此图一定有环。</p><h4 id="简单路径、简单回路"><a class="header-anchor" href="#简单路径、简单回路"></a>简单路径、简单回路</h4><p>在路径序列中，顶点不重复出现的路径称为简单路径。</p><p>除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路称为简单回路。</p><h4 id="距离"><a class="header-anchor" href="#距离"></a>距离</h4><p>从顶点 $u$ 出发到顶点 $v$ 的最短路径若存在，则此路径的长度称为从 $u$ 到 $v$ 的距离；若从 $u$ 到 $v$ 根本不存在路径，则记该距离为无穷( $∞$ )</p><h4 id="连通、连通图"><a class="header-anchor" href="#连通、连通图"></a>连通、连通图</h4><p>在无向图中，若从顶点 $v$ 到顶点 $w$ 有路径存在，则称 $v$ 和 $w$ 是连通的。若图 $G$ 中任意两个顶点都是连通的，则称图 $G$为<font color="#ea66a6">连通图</font>，否则称为非连通图。</p><p>若图 $G$ 是连通图，则至少有 $n-1$ 条边。若 $G$ 是非连通图，则至多可能有 $C_{n-1}^{2}$ 条边</p><h4 id="强连通图、"><a class="header-anchor" href="#强连通图、"></a>强连通图、</h4><p>在有向图中，若从顶点 $v$ 到顶点 $w$ 和从顶点 $w$ 到顶点 $v$ 之间都有路径，则称这两个顶点是强连通的。若图中任何一对顶点都是强连通的，则称此图为强连通图。</p><p>若 $G$ 是强连通图，则最少有 $n$ 条边（形成回路）</p><p>注意：强连通图、强连通分量只是针对有向图而言的。一般在无向图中讨论连通性，在有向图中考虑强连通性。</p><h4 id="子图"><a class="header-anchor" href="#子图"></a>子图</h4><p>设有两个图 $G=(V,E)$ 和 $G’=(V’,E’)$ ，若 $V’$ 是 $V$ 的子集，且 $E’$ 是 $E$ 的子集，则称 $G’$ 是 $G$ 的子图。若有满足 $V(G’)=V(G)$ 的子图 $G’$ ，则称其为 $G$ 的生成子图。</p><p>注意：并非 $V$ 和 $E$ 的任何子集都能构成 $G$ 的子图，因为这样的子集可能不是图，即 $E$ 的子集中的某些边关联的顶点可能不在这个 $V$ 的子集中。</p><h4 id="连通分量、强连通分量"><a class="header-anchor" href="#连通分量、强连通分量"></a>连通分量、强连通分量</h4><p>无向图中的极大连通子图称为连通分量。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E6%97%A0%E5%90%91%E5%9B%BE%E5%8F%8A%E5%85%B6%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F.png" alt="无向图及其连通分量"></p><p>有向图中的极大强连通子图称为有向图的强连通分量。</p><blockquote><p>注意：要区分极大连通子图和极小连通子图，极大连通子图是无向图的连通分量，极大即要求该连通子图包含其所有的边；极小连通子图是既要保持图连通又要使得边数最少的子图。</p></blockquote><h4 id="生成树、生成森林"><a class="header-anchor" href="#生成树、生成森林"></a>生成树、生成森林</h4><p>连通图的生成树是包含图中全部顶点的一个极小连通子图。若图中顶点数为 $n$ ，则它的生成树含有 $n-1$ 条边。</p><p>对生成树而言，若砍去它的一条边，则会变成非连通图，若加上一条边则会形成一个回路。</p><p>在非连通图中，连通分量的生成树构成了非连通图的生成森林。</p><h4 id="边的权和网"><a class="header-anchor" href="#边的权和网"></a>边的权和网</h4><p>在一个图中，每条边都可以标上具有某种含义的数值，该数值称为该边的权值。这种边上带有权值的图称为带权图，也称网。</p><p>带权路径长度：当图是带权图时，一条路径上所有边的权值之和，称为该路径的带权路径长度</p><h4 id="完全图"><a class="header-anchor" href="#完全图"></a>完全图</h4><p>无向完全图：无向图中任意两个顶点之间都存在边，若无向图的顶点数 $|V|=n$ ，则 $|E|\in [0,C_n^2]=[0,\frac{n(n-1)}{2} ] $</p><p>有向完全图：有向图中任意两个顶点之间都存在方向相反的两条弧，若有向图的顶点数 $|V|=n$ ，则 $|E|\in [0,2C_n^2]=[0,n(n-1) ] $</p><h4 id="稠密图、稀疏图"><a class="header-anchor" href="#稠密图、稀疏图"></a>稠密图、稀疏图</h4><p>边数很少的图称为稀疏图，反之称为稠密图。</p><p>稀疏和稠密本身是模糊的概念，稀疏图和稠密图常常是相对而言的。一般当图 $G$ 满足 $|E| &lt; |V|\log|V|$ 时，可以将 $G$ 视为稀疏图。</p><h4 id="树、有向树"><a class="header-anchor" href="#树、有向树"></a>树、有向树</h4><p>树：不存在回路，且连通的无向图。$n$ 个顶点的树，必有 $n-1$ 条边。</p><p>一个顶点的入度为0，其余顶点的入度均为 1 的有向图，称为有向树。</p><h2 id="图的存储及基本操作"><a class="header-anchor" href="#图的存储及基本操作"></a>图的存储及基本操作</h2><h3 id="邻接矩阵法"><a class="header-anchor" href="#邻接矩阵法"></a>邻接矩阵法</h3><p>所谓邻接矩阵存储，是指用一个一维数组存储图中顶点的信息，用一个二维数组存储图中边的信息（即各顶点之间的邻接关系），存储顶点之间邻接关系的二维数组称为邻接矩阵。</p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/有向图、无向图及网的邻接矩阵.png" alt="有向图、无向图及网的邻接矩阵" style="zoom:200%;" /><p>图的邻接矩阵存储结构定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertexNum 100  <span class="comment">// 顶点数目的最大值</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VertexType;  <span class="comment">// 顶点的数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> EdgeType;     <span class="comment">// 带权图中边上权值的数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    VertexType Vex[MaxVertexNum];               <span class="comment">// 顶点表</span></span><br><span class="line">    EdgeType Edge[MaxVertexNum][MaxVertexNum];  <span class="comment">// 邻接矩阵，边表</span></span><br><span class="line">    <span class="keyword">int</span> vexnum, arcnum;  <span class="comment">// 图的当前顶点数和边数/弧数</span></span><br><span class="line">&#125; MGraph;</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>在简单应用中，可直接用二维数组作为图的邻接矩阵（顶点信息等均可省略）。</li><li>当邻接矩阵中的元素仅表示相应的边是否存在时，<code>EdgeType</code> 可定义为值为 0 和 1 的枚举类型。</li><li>无向图的邻接矩阵是<font color="#faa755">对称矩阵</font>，对规模特大的邻接矩阵可采用<a href="http://halo123.top/2021/05/02/DataStructure/C_StacksAndQueues/#%E5%AF%B9%E7%A7%B0%E7%9F%A9%E9%98%B5">压缩存储</a>。</li><li>邻接矩阵表示法的空间复杂度为 $O(n^2)$，其中 $n$ 为图的顶点数 $|V|$。</li></ol><p>图的邻接矩阵存储表示法具有以下特点：</p><ol><li>对于无向图，邻接矩阵的第 $i$ 行（或第 $i$ 列）非零元素（或非 $∞$ 元素）的个数正好是第 $i$ 个顶点的度 $TD(v)$。时间复杂度 $O(|V|)$。</li><li>对于有向图，邻接矩阵的第 $i$ 行（或第 $i$ 列）非零元素（或非 $∞$ 元素）的个数正好是第 $i$ 个顶点的出度 $OD(v)$ [或入度 $ID(v)$ ]。第 $i$ 行结点的度即为，第 $i$ 行和列的非零元素（或非 $∞$ 元素）的个数之和。时间复杂度 $O(|V|)$。</li><li>设图 $G$ 的邻接矩阵为 $\mathbf{A} $，$\mathbf{A}^n$ 的元素  $A^n[i][j]$ 等于由顶点 $i$ 到顶点 $j$ 的长度为 $n$ 的路径的数目。（妙啊）</li><li>稠密图适合使用邻接矩阵的存储表示。</li><li>无向图的邻接矩阵一定是一个对称矩阵（并且唯一）。 因此，在实际存储邻接矩阵时只需存储上（或下）三角矩阵的元素。</li><li>用邻接矩阵法存储图，很容易确定图中任意两个顶点之间是否有边相连。但是，要确定图中有多少条边，则必须按行、按列对每个元素进行检测，所花费的时间代价很大。</li></ol><h3 id="邻接表法"><a class="header-anchor" href="#邻接表法"></a>邻接表法</h3><p>当一个图为稀疏图时，使用邻接矩阵法显然要浪费大量的存储空间，而图的邻接表法结合了顺序存储和链式存储方法，大大减少了这种不必要的浪费。</p><p>所谓邻接表，是指对图 $G$ 中的每个顶点 $v_i$ 建立一个单链表，第 $i$ 个单链表中的结点表示依附于顶点 $v_i$ 的边（对于有向图则是以顶点 $v_i$ 为尾的弧），这个单链表就称为顶点 $v_i$ 的边表（对于有向图则称为出边表）。边表的头指针和顶点的数据信息采用顺序存储（称为顶点表），所以在邻接表中存在两种结点：顶点表结点和边表结点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertexNum 100 <span class="comment">// 图中顶点数目的最大值</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VertexType;  <span class="comment">// 顶点的数据类型</span></span><br><span class="line"><span class="comment">// &quot;边/弧&quot;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> adjvex;            <span class="comment">// &quot;边/弧&quot;指向哪个结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">next</span>;</span>  <span class="comment">// 指向下一条弧的指针</span></span><br><span class="line">    <span class="comment">// InfoType info       // 边权值</span></span><br><span class="line">&#125; ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;顶点&quot;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span> &#123;</span></span><br><span class="line">    VertexType data;  <span class="comment">// 顶点信息</span></span><br><span class="line">    ArcNode *first;   <span class="comment">// 第一条边/弧</span></span><br><span class="line">&#125; VNode, AdjList[MaxVertexNum];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用邻接表存储的图</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    AdjList vertices;</span><br><span class="line">    <span class="keyword">int</span> vexnum, arcnum;</span><br><span class="line">&#125; ALGraph;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E6%97%A0%E5%90%91%E5%9B%BE%E9%82%BB%E6%8E%A5%E8%A1%A8%E8%A1%A8%E7%A4%BA%E6%B3%95%E5%AE%9E%E4%BE%8B.png" alt="无向图邻接表表示法实例"></p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E6%9C%89%E5%90%91%E5%9B%BE%E9%82%BB%E6%8E%A5%E8%A1%A8%E8%A1%A8%E7%A4%BA%E6%B3%95%E5%AE%9E%E4%BE%8B.png" alt="有向图邻接表表示法实例"></p><p>图的邻接表存储方法具有以下特点：</p><ol><li>若 $G$ 为无向图，则所需的存储空间为 $O(|V|+ 2|E|)$；若 $G$ 为有向图，则所需的存储空间为 $O(|V|+ |E|)$。前者的倍数 2 是由于无向图中，每条边在邻接表中出现了两次。</li><li>对于稀疏图，采用邻接表表示将极大地节省存储空间。</li><li>在邻接表中，给定一顶点，能很容易地找出它的所有邻边，因为只需要读取它的邻接表。在邻接矩阵中，相同的操作则需要扫描一行，花费的时间为 $O(n)$ 。 但是，若要确定给定的两个顶点间是否存在边，则在邻接矩阵中可以立刻查到，而在邻接表中则需要在相应结点对应的边表中查找另一结点，效率较低。</li><li>在有向图的邻接表表示中，求一个给定顶点的<font color="#faa755">出度</font>只需计算其邻接表中的结点个数；但求其顶点的<font color="#faa755">入度</font>则需要遍历全部的邻接表。因此，也有人采用逆邻接表的存储方式来加速求解给定顶点的入度。当然，这实际上与邻接表存储方式是类似的。</li><li>图的邻接表表示并不唯一，因为在每个项点对应的单链表中，各边结点的链接次序可以是任意的，它取决于建立邻接表的算法及边的输入次序。</li></ol><h3 id="十字链表法"><a class="header-anchor" href="#十字链表法"></a>十字链表法</h3><p>十字链表是<font color="#faa755">有向图</font>的一种链式存储结构。在十字链表中，对应于有向图中的每条弧有一个结点，对应于每个顶点也有一个结点。</p><p>弧结点中有 5 个域：尾域（<code>tailvex</code>） 和头域（<code>headvex</code>）分别指示弧尾和弧头这两个顶点在图中的位置；链域 <code>hlink</code> 指向弧头相同的下一条弧；链域 <code>tlink</code> 指向弧尾相同的下一条弧；<code>info</code> 域指向该弧的相关信息。这样，弧头相同的弧就在同一个链表上，弧尾相同的弧也在同一个链表上。</p><p>顶点结点中有 3 个域：<code>data</code> 域存放顶点相关的数据信息，如顶点名称；<code>firstin</code> 和 <code>firstout</code> 两个域分别指向以该顶点为弧头或弧尾的第一个弧结点。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8%E8%A1%A8%E7%A4%BA.png" alt="有向图的十字链表表示"></p><p>在十字链表中，既容易找到 $V_i$ 为尾的弧，又容易找到 $V_i$ 为头的弧，因而容易求得顶点的出度和入度。图的十字链表表示是不唯一的， 但一个十字链表表示确定一个 图。空间复杂度：$O(|V|+|E|)$</p><p>TODO 代码实现十字链表法</p><h3 id="邻接多重表法"><a class="header-anchor" href="#邻接多重表法"></a>邻接多重表法</h3><p>邻接多重表是<font color="#faa755">无向图</font>的另一种链式存储结构。</p><p>在邻接表中，容易求得顶点和边的各种信息，但在邻接表中求两个顶点之间是否存在边而对边执行删除等操作时，需要分别在两个顶点的边表中遍历，效率较低。</p><p>与十字链表类似，在邻接多重表中，每条边用一个结点表示，其结构如下所示。</p><p>其中，<code>mark</code> 为标志域，可用以标记该条边是否被搜索过；<code>ivex</code> 和 <code>jvex</code> 为该边依附的两个顶点在图中的位置；<code>ilink</code> 指向下一条依附于顶点 <code>ivex</code> 的边；<code>jlink</code> 指向下一条依附于顶点 <code>jvex</code> 的边，<code>info</code> 为指向和边相关的各种信息的指针域。</p><p>每个顶点也用一个结点表示，它由如下所示的两个域组成。</p><p>其中，<code>data</code> 域存储该顶点的相关信息，<code>firstedge</code> 域指示第一条依附于该顶点的边。</p><p>在邻接多重表中，所有依附于同一顶点的边串联在同一链表中，由于每条边依附于两个顶点，因此每个边结点同时链接在两个链表中。对无向图而言，其邻接多重表和邻接表的差别仅在于，同一条边在邻接表中用两个结点表示，而在邻接多重表中只有一个结点。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8%E8%A1%A8%E7%A4%BA.png" alt="无向图的邻接多重表表示"></p><p>空间复杂度：$O(|V|+|E|)$。</p><h3 id="图的基本操作"><a class="header-anchor" href="#图的基本操作"></a>图的基本操作</h3><p>图的基本操作是独立于图的存储结构的。而对于不同的存储方式，操作算法的具体实现会有着不同的性能。在设计具体算法的实现时，应考虑采用何种存储方式的算法效率会更高。</p><p>图的基本操作主要包括（仅抽象地考虑，故忽略掉各变量的类型）：</p><ul><li><code>Adjacent (G,x,y)</code>：判断图 $G$ 是否存在边 $&lt;x,y&gt;$ 或 $(x,y)$。邻接矩阵时间复杂度：$O(1)$，邻接表时间复杂度：$O(1)\sim  O(|V|)$。</li><li><code>Neighbors (G,x)</code>：列出图 $G$ 中与结点 $x$ 邻接的边。邻接矩阵时间复杂度：$O(|V|)$；邻接表无向图时间复杂度：$O(1)\sim  O(|V|)$，邻接表有向图出边时间复杂度：$O(1)\sim O(|V|)$，邻接表有向图入边时间复杂度：$O(|E|)$。</li><li><code>InsertVertex(G,x)</code>：在图 $G$ 中插入顶点 $x$ 。邻接矩阵和邻接表时间复杂度：$O(1)$</li><li><code>DeleteVertex(G,x)</code>：从图 $G$ 中删除顶点 $x$。邻接矩阵无向图时间复杂度：$O(|V|)$，邻接表无向图时间复杂度：$O(1)\sim O(|E|)$；邻接矩阵有向图时间复杂度：$O(|V|)$，邻接表删出边：$O(1)\sim O(|V|)$，邻接表删入边：$O(|E|)$</li><li><code>AddEdge (G,x,y)</code>：若无向边 $(x, y)$ 或有向边 $&lt;x, y&gt;$ 不存在，则向图 $G$ 中添加该边。邻接矩阵 $O(1)$，邻接表 $O(1)$</li><li><code>RemoveEdge(G,x,y)</code>：若无向边 $(x, y)$ 或有向边 $&lt;x, y&gt;$ 存在，则从图 $G$ 中删除该边。邻接矩阵 $O(1)$，邻接表 $O(1) \sim O(|V|)$</li><li><code>FirstNeighbor(G,x)</code>：求图 $G$ 中顶点 $x$ 的第一个邻接点，若有则返回顶点号。若 $x$ 没有邻接点或图中不存在 $x$ ，则返回 -1。邻接矩阵无向图 $O(1)\sim O(|V|)$，邻接表无向图 $O(1)$；邻接矩阵有向图 $O(1)\sim O(|V|)$，邻接表有向图找出边邻接点：$O(1)$，邻接表有向图找入边邻接点：$O(1)\sim O(|E|)$</li><li><code>NextNeighbor (G,x,y)</code>：假设图 $G$ 中顶点 $y$ 是顶点 $x$ 的一个邻接点，返回除 $y$ 外顶点 $x$ 的下一个邻接点的顶点号，若 $y$ 是 $x$ 的最后一个邻接点，则返回 -1。邻接矩阵 $O(1)\sim O(|V|)$，邻接表 $O(1)$；</li><li><code>Get_edge_value(G,x,y)</code>：获取图 $G$ 中边 $(x, y)$ 或 $&lt;x, y&gt;$ 对应的权值。时间复杂度同 <code>Adjacent (G,x,y)</code></li><li><code>Set_edge_value(G,x,y,v)</code>：设置图 $G$ 中边 $(x, y)$ 或 $&lt;x, y&gt;$ 对应的权值为 $v$ 。时间复杂度同 <code>Adjacent (G,x,y)</code></li></ul><p>此外，还有图的遍历算法：按照某种方式访问图中的每个顶点且仅访问一次。图的遍历算法包括深度优先遍历和广度优先遍历。</p><p>TODO 分析十字链表法和邻接多重表法下的基本操作的时间复杂度</p><h2 id="图的遍历"><a class="header-anchor" href="#图的遍历"></a>图的遍历</h2><p>图的遍历是指从图中的某一顶点出发，按照某种搜索方法沿着图中的边对图中的所有顶点访问一次且仅访问一次。注意到树是一种特殊的图，所以树的遍历实际上也可视为一种特殊的图的遍历。图的遍历算法是求解图的连通性问题、拓扑排序和求关键路径等算法的基础。</p><p>图的遍历比树的遍历要复杂得多，因为图的任一顶点都可能和其余的顶点相邻接，所以在访问某个顶点后，可能沿着某条路径搜索又回到该顶点上。为避免同一顶点被访问多次，在遍历图的过程中，必须记下每个已访问过的顶点，为此可以设一个辅助数组 <code>visited[]</code> 来标记顶点是否被访问过。图的遍历算法主要有两种：广度优先搜索和深度优先搜索。</p><h3 id="广度优先搜索"><a class="header-anchor" href="#广度优先搜索"></a>广度优先搜索</h3><p>广度优先搜索（Breadth-First- Search, BFS）类似于二叉树的层序遍历算法。基本思想是：首先访问起始顶点 $v$ ，接着由 $v$ 出发，依次访问 $v$ 的各个未访问过的邻接顶点 $w_1,w_2,\dots ,w_i$ 然后依次访问 $w_1,w_2,\dots ,w_i$ 的所有未被访问过的邻接顶点；再从这些访问过的顶点出发，访问它们所有未被访问过的邻接顶点，直至图中所有顶点都被访问过为止。若此时图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作为始点，重复上述过程，直至图中所有顶点都被访问到为止。Dijkstra 单源最短路径算法和 Prim 最小生成树算法也应用了类似的思想。</p><p>换句话说，广度优先搜索遍历图的过程是以 $v$ 为起始点，由近至远依次访问和 $v$ 有路径相通且路径长度为 1，2，… 的顶点。广度优先搜索是一种分层的查找过程，每向前走一步可能访问一批顶点，不像深度优先搜索那样有往回退的情况，因此它不是一个递归的算法。为了实现逐层的访问，算法必须<font color="#faa755">借助一个辅助队列</font>，以记忆正在访问的顶点的下一层顶点。</p><p>广度优先遍历算法的伪代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> visited[MAX_VERTEX_NUM];  <span class="comment">// 访问标记数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//广度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Graph G, <span class="keyword">int</span> v)</span> </span>&#123;  <span class="comment">//从顶点v出发，广度优先遍历图G</span></span><br><span class="line">    <span class="built_in">visit</span>(v);  <span class="comment">//访问初始顶点v</span></span><br><span class="line">    visited[v] = TRUE;  <span class="comment">//对v做已访问标记</span></span><br><span class="line">    <span class="built_in">Enqueue</span>(Q, v);  <span class="comment">//顶点v入队列Q</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isEmpty</span>(Q)) &#123;</span><br><span class="line">        <span class="built_in">DeQueue</span>(Q, v);  <span class="comment">//顶点v出队列</span></span><br><span class="line">        <span class="keyword">for</span> (w = <span class="built_in">FirstNeighbor</span>(G, v); w &gt;= <span class="number">0</span>; w = <span class="built_in">NextNeighbor</span>(G, v, w))</span><br><span class="line">            <span class="comment">//检测v所有邻接点</span></span><br><span class="line">            <span class="keyword">if</span> (!visited[w]) &#123;      <span class="comment">// w为v的尚未访问的邻接顶点</span></span><br><span class="line">                <span class="built_in">visit</span>(w);           <span class="comment">//访问顶点w</span></span><br><span class="line">                visited[w] = TRUE;  <span class="comment">//对w做已访问标记</span></span><br><span class="line">                <span class="built_in">EnQueue</span>(Q, w);      <span class="comment">//顶点w入队列</span></span><br><span class="line">            &#125;                       </span><br><span class="line">    &#125;                              </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同一个图的邻接矩阵表示方式唯一，因此广度优先历序列唯一</p><p>同一个图邻接表表示方式不唯一，因此广度优先遍历序列不唯一</p>]]></content>
    
    
    <summary type="html">图</summary>
    
    
    
    <category term="数据结构" scheme="http://halo123.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构——树与二叉树</title>
    <link href="http://halo123.top/2021/05/07/DataStructure/E_Tree/"/>
    <id>http://halo123.top/2021/05/07/DataStructure/E_Tree/</id>
    <published>2021-05-07T11:30:51.000Z</published>
    <updated>2021-05-09T14:43:20.900Z</updated>
    
    <content type="html"><![CDATA[<p>【考纲内容】</p><ol><li>树的基本概念</li><li>二叉树的定义及其主要特征</li><li>二叉树的顺序存储结构和链式存储结构</li><li>二叉树的遍历</li><li>线索二叉树的基本概念和构造</li><li>树的存储结构</li><li>森林与二叉树的转换</li><li>树和森林的遍历</li><li>二叉排序树</li><li>平衡二叉树</li><li>哈夫曼树和哈夫曼编码</li></ol><p>【知识框架】</p><p>TODO 完成树与二叉树章节的知识框架</p><p>【复习提示】</p><p>本章内容多以选择题的形式考查，但也会出涉及树遍历相关的算法题。树和二叉树的性质、遍历操作、转换、存储结构和操作特性等，满二叉树、完全二叉树、线索二叉树、哈夫曼树的定义和性质，二叉排序树和二叉平衡树的性质和操作等，都是选择题必然会涉及的内容。</p><h2 id="树的基本概念"><a class="header-anchor" href="#树的基本概念"></a>树的基本概念</h2><h3 id="树的定义"><a class="header-anchor" href="#树的定义"></a>树的定义</h3><p>树是 $n \ (n\ge 0)$ 个节点的有限集。当 $n=0$ 时，称为空树。在任意一颗非空树中应满足：</p><ol><li>有且仅有一个特定的称为根的结点。</li><li>当 $n&gt;1$ 时，其余节点可分为 $m\ (m&gt;0)$ 个互不相交的有限集 $T_1,T_2,\dots ,T_m$，其中每个集合本身又是一棵树，并称为根的子树。</li></ol><p>显然，树的定义是递归的，即在树的定义中又用到了其自身，树是一种递归的数据结构。树作为一种逻辑结构，同时也是一种分层结构，具有以下两个特点：</p><ol><li>树的根结点没有前驱，除根结点外的所有结点有且只有一个前驱。</li><li>树中所有结点可以有零个或多个后继。</li></ol><p>树适合于表示具有层次结构的数据。树中的某个结点（除根结点外）最多只和上一层的一个结点（即其父结点）有直接关系，根结点没有直接上层结点，因此在 $n$ 个结点的树中有 $n-1$ 条边。而树中每个结点与其下一层的零个或多个结点（即其子女结点）有直接关系。</p><h3 id="基本术语"><a class="header-anchor" href="#基本术语"></a>基本术语</h3><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E6%A0%91%E7%9A%84%E6%A0%91%E5%BD%A2%E8%A1%A8%E7%A4%BA.png" alt="树的树形表示"></p><ul><li>考虑结点 K 。根 A 到结点 K 的唯一路径上的任意结点，称为结点 K 的<font color="#ea66a6">祖先</font>。如结点 B 是结点 K 的祖先，而结点 K 是结点 B 的<font color="#ea66a6">子孙</font>。路径上最接近结点 K 的结点 E 称为 K 的<font color="#ea66a6">双亲</font>，而 K 为结点 E 的<font color="#ea66a6">孩子</font>。根 A 是树中唯一没有双亲的结点。有相同双亲的结点称为<font color="#ea66a6">兄弟</font>，如结点 K 和结点 L 有相同的双亲 E，即 K 和 L 为兄弟。</li><li>树中一个结点的孩子个数称为该<font color="#ea66a6">结点的度</font>，树中结点的最大度数称为树的度。如结点 B 的度为 2，结点 D 的度为 3，树的度为 3。</li><li>度大于 0 的结点称为<font color="#ea66a6">分支结点</font>（又称非终端结点）；度为 0 （没有子女结点）的结点称为<font color="#ea66a6">叶子结点</font>（又称终端结点）。在分支结点中，每个结点的分支数就是该结点的度。</li><li><font color="#ea66a6">结点的层次</font>从树根开始定义，根结点为第 1 层，它的子结点为第 2 层，以此类推。双亲在同一层的结点互为<font color="#ea66a6">堂兄弟</font>，图中结点 G 与 E，F，H，I，J 互为堂兄弟。</li><li><font color="#ea66a6">结点的深度</font>是从根结点开始自顶向下逐层累加的。</li><li><font color="#ea66a6">结点的高度</font>是从叶结点开始自底向上逐层累加的。</li><li><font color="#ea66a6">树的高度</font>（或深度）是树中结点的最大层数。图中树的高度为4。</li><li>有序树和无序树。树中结点的各子树从左到右是有次序的，不能互换，称该树为<font color="#ea66a6">有序树</font>，否则称为<font color="#ea66a6">无序树</font>。假设图为有序树，若将子结点位置互换，则变成一棵不同的树。</li><li>路径和路径长度。树中两个结点之间的<font color="#ea66a6">路径</font>是由这两个结点之间所经过的结点序列构成的，而<font color="#ea66a6">路径长度</font>是路径上所经过的边的个数。注意：由于树中的分支是有向的，即从双亲指向孩子，所以树中的路径是从上向下的，同一双亲的两个孩子之间不存在路径。</li><li><font color="#ea66a6">森林</font>是 $m\  (m \ge 0)$ 棵互不相交的树的集合。森林的概念与树的概念十分相近，因为只要把树的根结点删去就成了森林。反之，只要给 $m$ 棵独立的树加上一个结点，并把这 $m$ 棵树作为该结点的子树，则森林就变成了树。</li></ul><p>度为 $m$ 的树与 $m$ 叉树：前者表示树中各节点最少存在一个最大为 $m$ 度的结点，而 $m$  叉树表示每个结点最多只能有 $m$ 个孩子的树</p><h3 id="树的性质"><a class="header-anchor" href="#树的性质"></a>树的性质</h3><p>树具有如下最基本的性质：</p><ol><li><p>树中的结点数等于所有结点的度数加 1 。</p></li><li><p>度为 $m$ 的树中第 $i$ 层上至多有 $m^{i-1}$ 个结点 $(i\ge 1)$。</p></li><li><p>高度为 $h$ 的 $m$ 叉树至多有 $\frac{m^h-1}{m-1} $ 个结点。</p></li><li><p>具有 $n$ 个结点的 $m$ 叉树的最小高度为 $\left \lceil \log_{m}{(n(m-1)+1) } \right \rceil $。<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p></li></ol><h2 id="二叉树的概念"><a class="header-anchor" href="#二叉树的概念"></a>二叉树的概念</h2><h3 id="二叉树的定义及其主要特性"><a class="header-anchor" href="#二叉树的定义及其主要特性"></a>二叉树的定义及其主要特性</h3><h4 id="二叉树的定义"><a class="header-anchor" href="#二叉树的定义"></a>二叉树的定义</h4><p>二叉树是另一种树形结构，其特点是每个结点至多只有两棵子树（即二叉树中不存在度大于 2 的结点），并且二叉树的子树有左右之分，其次序不能任意颠倒。</p><p>与树相似，二叉树也以递归的形式定义。二叉树是 $n\ (n\ge 0)$个结点的有限集合：</p><ol><li>或者为空二叉树，即 $n=0$ 。</li><li>或者由一个根结点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树又分别是一棵二叉树。</li></ol><p>二叉树是有序树，若将其左、右子树颠倒，则成为另一棵不同的二叉树。即使树中结点只有一颗子树，也要区分它是左子树还是右子树。</p><p>二叉树与度为 2 的有序树的区别：</p><ol><li>度为 2 的树至少有 3 个结点，而二叉树可以为空。</li><li>度为 2 的有序树的孩子的左右次序是相对于另一孩子而言的，若某个结点只有一个孩子，则这个孩子就无须区分其左右次序，而二叉树无论其孩子数是否为 2，均需确定其左右次序，即二叉树的结点次序不是相对于另一结点而言，而是确定的。</li></ol><h4 id="几个特殊的二叉树"><a class="header-anchor" href="#几个特殊的二叉树"></a>几个特殊的二叉树</h4><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E5%87%A0%E4%B8%AA%E7%89%B9%E6%AE%8A%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="几个特殊的二叉树"></p><p><strong>满二叉树</strong>。一棵高度为 $h$，且含有 $2^h-1$ 个结点的二叉树称为满二叉树，即树中的每层都含有最多的结点。满二叉树的叶子结点都集中在二叉树的最下一层，并且除叶子结点之外的每个结点度数均为 2 （不存在度为 1 的结点）。可以对满二叉树按层序编号：约定编号从根结点（根结点编号为 1 ）起，自上而下，自左向右。这样，每个结点对应一个编号，对于编号为 $i$ 的结点，若有双亲，则其双亲为 $\left \lfloor \frac{i}{2}  \right \rfloor$，若有左孩子，则左孩子为 $2i$ ；若有右孩子，则右孩子为 $2i+1$。</p><p><strong>完全二叉树</strong>。高度为 $h$、有 $n$ 个结点的二叉树，当且仅当其每个结点都与高度为 $h$ 的满二叉树中编号为 $1\sim n$ 的结点一一对应时，称为完全二叉树。就是对应相同高度的满二叉树缺失最下层最右边的一些连续叶子结点。其特点如下：</p><ol><li>若 $ i \le \left \lfloor \frac{n}{2}  \right \rfloor$，则结点 $i$ 为分支结点，否则为叶子结点。</li><li>叶子结点只可能在层次最大的两层上出现。对于最大层次中的叶子结点，都依次排列在该层最左边的位置上。</li><li>若有度为 1 的结点，则只可能有一个，且该结点只有左孩子而无右孩子（重要特征）。</li><li>按层序编号后，一旦出现某结点（编号为 $i$ ）为叶子结点或只有左孩子，则编号大于 $i$ 的结点均为叶子结点。</li><li>若 $n$ 为奇数，则每个分支结点都有左孩子和右孩子；若 $n$ 为偶数，则编号最大的分支结点（编号为 $\frac{n}{2}$ ）只有左孩子，没有右孩子，其余分支结点左、右孩子都有。</li></ol><p><strong>二叉排序树</strong>。一棵二叉树或者是空二叉树，或者是具有如下性质的二叉树：</p><ul><li>左子树上所有结点的关键字均小于根结点的关键字；</li><li>右子树上的所有结点的关键字均大于根结点的关键字；</li><li>左子树和右子树又各是一棵二叉排序树。</li></ul><p><strong>平衡二叉树</strong>。树上任一结点的左子树和右子树的深度之差不超过 1 。</p><h4 id="二叉树的性质"><a class="header-anchor" href="#二叉树的性质"></a>二叉树的性质</h4><p>（1）<font color="#FF666">非空二叉树上的叶子结点数等于度为 2 的结点数加 1</font>，即 $n_{0}=n_{2}+1$ 。</p><p>证明：设度为 0，1 和 2 的结点个数分别为 $n_{0}$，$n_{1}$ 和 $n_{2}$，结点总数 $n=n_{0}+n_{1}+n_{2}$。再看二叉树中的分支树，除根结点外，其余结点都有一个分支进入，设 $B$ 为分支总数，则 $n=B+1$ 。由于这些分支是由度为 1 或 2 的结点射出的，所以又有 $B=n_{1}+2n_{2}$。于是得 $n_{0}+n_{1}+n_{2}=n_{1}+2n_{2}+1$ ，则 $n_{0}=n_{2}+1$。</p><p>拓展到任意一棵树，若结点数量为 $n$，则边的数量为 $n-1$。</p><p>（2）非空二叉树上第 $k$ 层上至多有 $2^{k-1}$ 个结点 （ $k \ge 1$ ），可扩至 m 叉树</p><p>（3）高度为 $h$ 的二叉树至多有 $2^h-1$ 个结点（ $h \ge 1$ ）。高度为 $h$ 的 $m$ 叉树至多有 $\frac{m^h-1}{m-1} $ 个结点，推出。</p><p>（4）具有 $n$ 个（$n&gt;0$）结点的完全二叉树的高度 $h$ 为 $\left \lceil \log_{2}{(n+1)}  \right \rceil $ 或  $\left \lfloor \log_{2}{n}  \right \rfloor +1$</p><p>证明：高度为 $h$ 的满二叉树共有 $2^h-1$ 个结点，高度为 $h-1$ 的满二叉树共有 $2^{h-1}-1$ 个结点，可得：$$2^{h-1}-1&lt;n\le 2^{h}-1$$ $$2^{h-1}&lt;n+1\le 2^{h}$$ $$h-1&lt;\log{2}{(n+1)} \le h$$ $$h=\left \lceil \log_{2}{(n+1)}  \right \rceil $$</p><p>高度为 $h-1$ 的满二叉树共有 $2^{h-1}-1$ 个结点，高为 $h$ 的完全二叉树至少有 $2^{h-1}$ 个结点，至多有 $2^{h}-1$ 个结点，可得：$$2^{h-1} \le n &lt; 2^{h}$$ $$h-1 \le \log{2}{n} &lt; h$$ $$h= \left \lfloor \log_{2}{n}  \right \rfloor +1$$</p><p>（5）对于完全二叉树，可以由的结点数 $n$ 推出度为 0、1 和 2 的结点个数为 $n_0$、$n_1$和 $n_2$。</p><ul><li>完全二叉树最多只有一个度为 1 1 的结点，即：$n_{1}=0或1$ ；</li><li>$n_{0}=n_{2}+1$，两边各加上 $n_2$ 可得： $n_0+n_2=2n_2+1$ 可推出 $n_0+n_2$ 一定为奇数；</li></ul><p>根据上两个推论得：</p><ul><li>若完全二叉树有 $2k$ （偶数）个结点，则必有 $n_1=1,\ n_0=k , \ n_2=k-1$</li><li>若完全二叉树有 $2k-1$ （奇数）个结点，则必有 $n_1=0,\ n_0=k , \ n_2=k-1$</li></ul><h3 id="二叉树的存储结构"><a class="header-anchor" href="#二叉树的存储结构"></a>二叉树的存储结构</h3><h4 id="顺序存储结构"><a class="header-anchor" href="#顺序存储结构"></a>顺序存储结构</h4><p>二叉树的顺序存储是指用一组地址连续的存储单元依次<wavy>自上而下</wavy>、<wavy>自左至右</wavy>存储完全二叉树上的结点元素，即将完全二叉树上编号为 $i$ 的结点元素存储在一维数组下标为 $i-1$ 的分量中。（这种存储结构建议从数组下标 1 开始存储树中的结点）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">bool</span> isEmpty;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TreeNode t[MaxSize];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MaxSize; i++) &#123;</span><br><span class="line">        t[i].isEmpty = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依据二叉树的性质，完全二叉树和满二叉树采用顺序存储比较合适，树中结点的序号可以唯一地反映结点之间的逻辑关系，这样既能最大可能地节省存储空间，又能利用数组元素的下标值确定结点在二叉树中的位置，以及结点之间的关系。</p><p>但对于一般的二叉树，为了让数组下标能反映二叉树中结点之间的逻辑关系，只能添加一些并不存在的空结点，让其每个结点与完全二叉树上的结点相对照，再存储到一维数组的相应分量中。然而，在最坏情况下，一个高度为 $h$ 且只有 $h$ 个结点的单支树却需要占据近 $2^h-1$ 个存储单元。</p><h4 id="链式存储结构"><a class="header-anchor" href="#链式存储结构"></a>链式存储结构</h4><p>由于顺序存储的空间利用率较低，因此二叉树一般都采用链式存储结构，用链表结点来存储二叉树中的每个结点。在二叉树中，结点结构通常包括若干数据域和若干指针域，二叉链表至少包含3个域：数据域 <code>data</code>、左指针域 <code>lchild</code> 和右指针域 <code>rchild</code>。$n$ 个节点的二叉链表共有 $n+1$ 个空链域。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span>  <span class="comment">// 左右孩子指针</span></span><br><span class="line">    <span class="comment">// struct BiTNode *parent;  // 根据实际需求决定是否加父指针</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一棵空树</span></span><br><span class="line">    BiTree root = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入根节点</span></span><br><span class="line">    root = (BiTree)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(BiTNode));</span><br><span class="line">    root-&gt;data = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">    root-&gt;lchild = <span class="literal">nullptr</span>;</span><br><span class="line">    root-&gt;rchild = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入新结点</span></span><br><span class="line">    BiTNode *p = (BiTNode *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(BiTNode));</span><br><span class="line">    p-&gt;data = &#123;<span class="number">2</span>&#125;;</span><br><span class="line">    p-&gt;lchild = <span class="literal">nullptr</span>;</span><br><span class="line">    p-&gt;rchild = <span class="literal">nullptr</span>;</span><br><span class="line">    root-&gt;lchild = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到指定结点的左右孩子结点十分容易，但如果要寻找父节点只能从根结点开始遍历寻找。可以在结构体中额外定义父节点指针（三叉链表）。</p><h2 id="二叉树的遍历和线索二叉树"><a class="header-anchor" href="#二叉树的遍历和线索二叉树"></a>二叉树的遍历和线索二叉树</h2><h3 id="二叉树的遍历"><a class="header-anchor" href="#二叉树的遍历"></a>二叉树的遍历</h3><p>二叉树的遍历是指按某条搜索路径访问树中每个结点，使得每个结点均被访问一次，而且仅被访问一次。由于二叉树是一种非线性结构，每个结点都可能有两棵子树，因而需要寻找一种规律，以便使二叉树上的结点能排列在一个线性队列上，进而便于遍历。</p><p>由二叉树的递归定义可知，遍历一棵二叉树便要决定对根结点 N、左子树 L​ 和右子树 R 的访问顺序。按照先遍历左子树再遍历右子树的原则，常见的遍历次序有先序（NLR）、中序（LNR）和后序（LRN）三种遍历算法，其中“序”指的是根结点在何时被访问。</p><h4 id="先序遍历"><a class="header-anchor" href="#先序遍历"></a>先序遍历</h4><p>先序遍历（ PreOrder ）的操作过程如下：</p><p>若二叉树为空，则什么也不做；否则，</p><ol><li>访问根结点；</li><li>先序遍历左子树；</li><li>先序遍历右子树。</li></ol><p>对应的递归算法如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">visit</span>(T);             <span class="comment">// 访问根节点</span></span><br><span class="line">        <span class="built_in">PreOrder</span>(T-&gt;lchild);  <span class="comment">// 递归遍历左子树</span></span><br><span class="line">        <span class="built_in">PreOrder</span>(T-&gt;rchild);  <span class="comment">// 递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中序遍历"><a class="header-anchor" href="#中序遍历"></a>中序遍历</h4><p>中序遍历（ InOrder ）的操作过程如下：</p><p>若二叉树为空，则什么也不做；否则，</p><ul><li>中序遍历左子树；</li><li>访问根结点；</li><li>中序遍历右子树。</li></ul><p>对应的递归算法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">InOrder</span>(T-&gt;lchild);  <span class="comment">// 递归遍历左子树</span></span><br><span class="line">        <span class="built_in">visit</span>(T);            <span class="comment">// 访问根节点</span></span><br><span class="line">        <span class="built_in">InOrder</span>(T-&gt;rchild);  <span class="comment">// 递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后序遍历"><a class="header-anchor" href="#后序遍历"></a>后序遍历</h4><p>后序遍历（ PostOrder ）的操作过程如下：</p><p>若二叉树为空，则什么也不做；否则，</p><ol><li>后序遍历左子树；</li><li>后序遍历右子树；</li><li>访问根结点。</li></ol><p>对应的递归算法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">PostOrder</span>(T-&gt;lchild);  <span class="comment">// 递归遍历左子树</span></span><br><span class="line">        <span class="built_in">PostOrder</span>(T-&gt;rchild);  <span class="comment">// 递归遍历右子树</span></span><br><span class="line">        <span class="built_in">visit</span>(T);              <span class="comment">// 访问根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三种遍历算法中，递归遍历左、右子树的顺序都是固定的，只是访问根结点的顺序不同。不管采用哪种遍历算法，每个结点都访问一次且仅访问一次，故时间复杂度都是 $O(n)$ 。在递归遍历中，递归工作栈的栈深恰好为树的深度，所以在最坏情况下，二叉树是有 $n$ 个结点且深度为 $n$ 的单支树，遍历算法的空间复杂度为 $O(n)$。</p><p>TODO 递归算法和非递归算法的转换</p><h4 id="层次遍历"><a class="header-anchor" href="#层次遍历"></a>层次遍历</h4><p>要进行层次遍历，需要借助一个队列。先将二叉树根结点入队，然后出队，访问出队结点，若它有左子树，则将左子树根结点入队；若它有右子树，则将右子树根结点入队。然后出队，访问出队结点…如此反复，直至队列为空。</p><p>二叉树的层次遍历算法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    LinkQueue Q;</span><br><span class="line">    <span class="built_in">InirQueue</span>(Q);  <span class="comment">// 初始化辅助队列</span></span><br><span class="line">    BiTree p;</span><br><span class="line">    <span class="built_in">EnQueue</span>(Q, T);  <span class="comment">// 将根结点入队</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isEmpty</span>(Q)) &#123;</span><br><span class="line">        <span class="built_in">DeQueue</span>(Q, p);  <span class="comment">// 对头结点出队</span></span><br><span class="line">        <span class="built_in">visit</span>(p);       <span class="comment">// 访问出队结点</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lchild != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">EnQueue</span>(Q, p-&gt;lchild);  <span class="comment">// 左孩子入队,入队指针</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;rchild != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">EnQueue</span>(Q, p-&gt;rchild);  <span class="comment">// 右孩子入队</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="由遍历序列构造二又树"><a class="header-anchor" href="#由遍历序列构造二又树"></a>由遍历序列构造二又树</h4><p>若只给出一棵二叉树的前/中/后/层序遍历序列中的一种，不能唯一确定一棵二叉树。必须有中序遍历和其他任意一种遍历序列才能确定唯一一种二叉树。</p><p>先序序列和中序序列：在先序遍历序列中，第一个结点一定是二叉树的根结点；而在中序遍历中，根结点必然将中序序列分割成两个子序列，前一个子序列是根结点的左子树的中序序列，后一个子序列是根结点的右子树的中序序列。根据这两个子序列，在先序序列中找到对应的左子序列和右子序列。在先序序列中，左子序列的第一个结点是左子树的根结点，右子序列的第一个结点是右子树的根结点。如此递归地进行下去，便能唯一地确定这棵二叉树。</p><p>类似，由二叉树的后序序列和中序序列，层序序列和中序序列也可以唯一地确定一棵二叉树。找到树的根节点，并根据<br>中序序列划分左右子树，再找至左右子树根节点。</p><h3 id="线索二叉树"><a class="header-anchor" href="#线索二叉树"></a>线索二叉树</h3><h4 id="线索二叉树的基本概念"><a class="header-anchor" href="#线索二叉树的基本概念"></a>线索二叉树的基本概念</h4><p>遍历二叉树是以一定的规则将二叉树中的结点排列成一个线性序列，从而得到几种遍历序列，使得该序列中的每个结点（第一个和最后一个结点除外）都有一个直接前驱和直接后继。</p><p>传统的二叉链表存储仅能体现一种父子关系，不能直接得到结点在遍历中的前驱或后继。前面提到，在含 $n$ 个结点的二叉树中，有 $n+1$ 个空指针。这是因为每个叶结点有 2 个空指针，每个度为 1 的结点有 1 个空指针，空指针总数为 $2n_{0} + n_1$ ，又 $n_{0}=n_{2}+ 1$，所以空指针总数为 $n_0+n_1+n_2+1=n+1$ 。由此设想能否利用这些空指针来存放指向其前驱或后继的指针？这样就可以像遍历单链表那样方便地遍历二叉树。引入线索二叉树正是为了加快查找结点前驱和后继的速度。</p><p>规定：若无左子树，令 <code>lchild</code> 指向其前驱结点；若无右子树，令 <code>rchild</code> 指向其后继结点。还需增加两个标志域（<code>ltag</code>、<code>rtag</code>）标识指针域是指向左（右）孩子还是指向前驱（后继）。当 tag 值等于 0 时，表示指针指向孩子，等于 1 时，表示指针指向线索。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E4%B8%AD%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="中序线索二叉树"></p><p>线索二叉树的存储结构描述如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ltag, rtag;  <span class="comment">// 左右线索标志，0指向孩子，1指向线索</span></span><br><span class="line">&#125; ThreadNode, *ThreadTree;</span><br></pre></td></tr></table></figure><p>以这种结点结构构成的二叉链表作为二叉树的存储结构，称为<font color="#ea66a6">线索链表</font>，其中指向结点前驱和后继的指针称为<font color="#ea66a6">线索</font>。加上线索的二叉树称为<font color="#ea66a6">线索二叉树</font>。</p><h4 id="中序线索二叉树的构造"><a class="header-anchor" href="#中序线索二叉树的构造"></a>中序线索二叉树的构造</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局遍历 pre 指向当前访问结点的前驱</span></span><br><span class="line">ThreadNode *pre = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历二叉树并进行线索化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThread</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">InThread</span>(T-&gt;lchild);  <span class="comment">// 中序遍历左子树</span></span><br><span class="line">        <span class="built_in">visit</span>(T);             <span class="comment">// 访问根节点并线索化</span></span><br><span class="line">        <span class="built_in">InThread</span>(T-&gt;rchild);  <span class="comment">// 中序遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(ThreadNode *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;lchild == <span class="literal">nullptr</span>) &#123;  <span class="comment">// 左子树为空，建立前驱线索</span></span><br><span class="line">        q-&gt;lchild = pre;</span><br><span class="line">        q-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pre != <span class="literal">nullptr</span> &amp;&amp; pre-&gt;rchild == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        pre-&gt;rchild = q;  <span class="comment">// 建立前驱结点的后继线索</span></span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = q;  <span class="comment">// 将 pre 指针指向当前结点（即下一个访问结点的前驱结点）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序线索化二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateInThread</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">InThread</span>(T);  <span class="comment">// 中序线索化除最后一个结点的其他结点</span></span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;rchild == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;  <span class="comment">// 注意：处理最后一个结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="先序线索二叉树的构造"><a class="header-anchor" href="#先序线索二叉树的构造"></a>先序线索二叉树的构造</h4><blockquote><p>当 <code>ltag == 0</code> 时，才能对左子树先序线索化</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局遍历 pre 指向当前访问结点的前驱</span></span><br><span class="line">ThreadNode *pre = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先序遍历二叉树并进行线索化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreThread</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">visit</span>(T);                  <span class="comment">// 访问根节点并线索化</span></span><br><span class="line">        <span class="keyword">if</span> (T-&gt;ltag == <span class="number">0</span>) &#123;        <span class="comment">// 注意：需要判断lchild不是前驱线索</span></span><br><span class="line">            <span class="built_in">PreThread</span>(T-&gt;lchild);  <span class="comment">// 先序遍历左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">PreThread</span>(T-&gt;rchild);  <span class="comment">// 先序遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(ThreadNode *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;lchild == <span class="literal">nullptr</span>) &#123;  <span class="comment">// 左子树为空，建立前驱线索</span></span><br><span class="line">        q-&gt;lchild = pre;</span><br><span class="line">        q-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pre != <span class="literal">nullptr</span> &amp;&amp; pre-&gt;rchild == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        pre-&gt;rchild = q;  <span class="comment">// 建立前驱结点的后继线索</span></span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = q;  <span class="comment">// 将 pre 指针指向当前结点（即下一个访问结点的前驱结点）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先序线索化二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateInThread</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">PreThread</span>(T);  <span class="comment">// 先序线索化除最后一个结点的其他结点</span></span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;rchild == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;  <span class="comment">// 处理最后一个结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后序线索二叉树的构造"><a class="header-anchor" href="#后序线索二叉树的构造"></a>后序线索二叉树的构造</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局遍历 pre 指向当前访问结点的前驱</span></span><br><span class="line">ThreadNode *pre = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历二叉树并进行线索化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostThread</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">PostThread</span>(T-&gt;lchild);  <span class="comment">// 后序遍历左子树</span></span><br><span class="line">        <span class="built_in">PostThread</span>(T-&gt;rchild);  <span class="comment">// 后序遍历右子树</span></span><br><span class="line">        <span class="built_in">visit</span>(T);               <span class="comment">// 访问根节点并线索化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(ThreadNode *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;lchild == <span class="literal">nullptr</span>) &#123;  <span class="comment">// 左子树为空，建立前驱线索</span></span><br><span class="line">        q-&gt;lchild = pre;</span><br><span class="line">        q-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pre != <span class="literal">nullptr</span> &amp;&amp; pre-&gt;rchild == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        pre-&gt;rchild = q;  <span class="comment">// 建立前驱结点的后继线索</span></span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = q;  <span class="comment">// 将 pre 指针指向当前结点（即下一个访问结点的前驱结点）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序线索化二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateInThread</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">PostThread</span>(T);  <span class="comment">// 后序线索化除最后一个结点的其他结点</span></span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;rchild == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;  <span class="comment">// 注意：处理最后一个结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线索二叉树的遍历"><a class="header-anchor" href="#线索二叉树的遍历"></a>线索二叉树的遍历</h4><p>在中序线索二叉树中找到指定结点 <code>*p</code> 的中序后继 <code>next</code>：</p><ol><li><p>若 <code>p-&gt;rtag == 1</code>，则  <code>next = p-&gt;rchild</code></p></li><li><p>若  <code>p-&gt;rtag == 0</code>，则  <code>next</code> 等于 <code>p</code> 的右子树中最左下的结点</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到以 p 为根的子树中，第一个被中序遍历的结点</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">FirstNode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 循环找到最左下结点（不一定是叶结点）</span></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;ltag == <span class="number">0</span>)&#123;</span><br><span class="line">        p = p-&gt;lchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在中序线索二叉树中找到结点 p 的后继结点</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">NextNode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 右子树中最左下结点</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;rtag == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">FirstNode</span>(p-&gt;rchild);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123; <span class="comment">// rtag==1 直接返回后继线索</span></span><br><span class="line">        <span class="keyword">return</span> p-&gt;rchild; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对中序线索二叉树进行中序遍历</span></span><br><span class="line"><span class="comment">// 利用线索实现的非递归算法 空间复杂度 O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(ThreadNode *T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ThreadNode *p = <span class="built_in">FirstNode</span>(T);p != <span class="literal">nullptr</span>;p = <span class="built_in">NextNode</span>(p))&#123;</span><br><span class="line">        <span class="built_in">visit</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在中序线索二叉树中找到指定结点 <code>*p</code> 的中序前驱 <code>pre</code>：</p><ol><li>若 <code>p-&gt;ltag == 1</code>，则  <code>pre = p-&gt;lchild</code></li><li>若  <code>p-&gt;ltag == 0</code>，则  <code>pre</code> 等于 <code>p</code> 的左子树中最右下的结点</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到以 p 为根的子树中，最后一个被中序遍历的结点</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">LastNode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 循环找到最右下结点(不一定是叶结点)</span></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;rtag == <span class="number">0</span>)&#123;</span><br><span class="line">        p = p-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在中序线索二叉树中找到结点 p 的前驱结点</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">PreNode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 左子树中最右下结点</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ltag == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">LastNode</span>(p-&gt;lchild);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123; <span class="comment">// ltag==1 直接返回前驱线索</span></span><br><span class="line">        <span class="keyword">return</span> p-&gt;lchild; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对中序线索二叉树进行逆向中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RevInOrder</span><span class="params">(ThreadNode *T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ThreadNode *p = <span class="built_in">LastNode</span>(T);p != <span class="literal">nullptr</span>;p = <span class="built_in">PreNode</span>(p))&#123;</span><br><span class="line">        <span class="built_in">visit</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>先序线索二叉树找指定结点 <code>*p</code> 的先序后继 <code>next</code></p><ol><li>若 <code>p-&gt;rtag == 1</code>，则 <code>next = p-&gt;rchild</code>；</li><li>若 <code>p-&gt;rtag == 0</code>，则 <code>p</code> 必有右孩子，分成两种情况考虑：<ul><li>若 <code>p</code> 有左孩子则先序后继为左孩子；</li><li>若没有左孩子则先序后继为右孩子</li></ul></li></ol><p>TODO 代码实现先序线索二叉树的后继遍历</p><p>在先序线索二叉树中找到指定结点 <code>*p</code> 的先序前驱 <code>pre</code></p><ol><li>若 <code>p-&gt;ltag == 1</code>，则 <code>next = p-&gt; lchild</code>；</li><li>若 <code>p-&gt;ltag == 0</code>，则 <code>p</code> 必有左孩子。二叉链表在先序遍历中，左右子树中的结点只可能是根的后继，不可能是前驱，故找不到先序前驱。三叉链表在先序遍历中，如果能找到 <code>p</code> 的父节点：<ul><li><code>p</code> 为左孩子，<code>p</code> 的父节点即为其前驱结点；</li><li><code>p</code> 是右孩子，其左兄弟为空，<code>p</code> 的父节点即为其前驱结点；</li><li><code>p</code> 是右孩子，其左兄弟非空，<code>p</code> 的前驱为左兄弟子树中最后一个被先序遍历的结点；</li><li>如果 <code>p</code> 是根结点，则 <code>p</code> 没有先序前驱。</li></ul></li></ol><hr><p>在后序线索二叉树找到指定结点 <code>*p</code> 的后序前驱 <code>pre</code>：</p><ol><li>若 <code>p-&gt;ltag == 1</code>，则 <code>pre = p-&gt;lchild</code></li><li>若 <code>p-&gt;ltag == 0</code>，则 <code>p</code> 必有左孩子，若 <code>p</code> 有右孩子，则后序前驱为右孩子；若 <code>p</code> 没有右孩子，则后序前驱为左孩子</li></ol><p>TODO 后序前驱遍历代码实现</p><p>在后序线索二叉树中找到指定结点 <code>*p</code> 的后序后继 <code>next</code>：</p><ol><li>若 <code>p-&gt;rtag == 1</code>，则 <code>next = p-&gt;rchild</code></li><li>若 <code>p-&gt;rtag == 0</code>，则 <code>p</code> 必有右孩子。二叉链表在后序遍历中，左右子树中的结点只可能是根的前驱，不可能是后继。三叉链表在后序遍历中，如果能找到 <code>p</code> 的父节点：<ul><li><code>p</code> 是右孩子，<code>p</code> 的父节点即为其后继结点；</li><li><code>p</code> 是左孩子，其右兄弟为空，<code>p</code> 的父节点即为其后继结点；</li><li><code>p</code> 是左孩子，其右兄弟非空，<code>p</code> 的后继为右兄弟子树中第一个被后序遍历的结点；</li><li>如果 <code>p</code> 是根节点，则 <code>p</code> 没有后继结点</li></ul></li></ol><h2 id="树、森林"><a class="header-anchor" href="#树、森林"></a>树、森林</h2><h3 id="树的存储结构"><a class="header-anchor" href="#树的存储结构"></a>树的存储结构</h3><p>树的存储方式有多种，既可采用顺序存储结构，又可采用链式存储结构，但无论采用何种存储方式，都要求能唯一地反映树中各结点之间的逻辑关系，这里介绍 3 种常用的存储结构。</p><h4 id="双亲表示法（顺序存储）"><a class="header-anchor" href="#双亲表示法（顺序存储）"></a>双亲表示法（顺序存储）</h4><p>这种存储方式采用一组连续空间来存储每个结点，同时在每个结点中增设一个伪指针，指示其<wavy>双亲结点</wavy>在数组中的位置。根结点下标为 0，其伪指针域为 -1。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E6%A0%91%E7%9A%84%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95.png" alt="树的双亲表示法"></p><p>双亲表示法的存储结构描述如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;     <span class="comment">// 数据元素</span></span><br><span class="line">    <span class="keyword">int</span> partent;  <span class="comment">// 双亲位置域</span></span><br><span class="line">&#125; PTNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PTNode nodoes[MAX_TREE_SIZE];  <span class="comment">// 双亲表示</span></span><br><span class="line">    <span class="keyword">int</span> n;                         <span class="comment">// 结点数</span></span><br><span class="line">&#125; PTree；</span><br></pre></td></tr></table></figure><h4 id="孩子表示法（顺序-链式存储）"><a class="header-anchor" href="#孩子表示法（顺序-链式存储）"></a>孩子表示法（顺序+链式存储）</h4><p>孩子表示法是将每个结点的孩子结点都用单链表链接起来形成一个线性结构，此时 $n$ 个结点就有 $n$ 个孩子链表（叶子结点的孩子链表为空表）。这种存储方式寻找子女的操作非常直接，而寻找双亲的操作需要遍历 $n$ 个结点中孩子链表指针域所指向的 $n$ 个孩子链表。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> child;            <span class="comment">// 孩子结点在数组中的位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span>  <span class="comment">// 下一个孩子</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">firstChild</span>;</span>  <span class="comment">// 第一个孩子</span></span><br><span class="line">&#125; CTBox;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    CTBox nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="keyword">int</span> n, r;  <span class="comment">// 结点数和根的位置</span></span><br><span class="line">&#125; CTree;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E5%AD%A9%E5%AD%90%E5%92%8C%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95.png" alt="孩子和孩子兄弟表示法"></p><h4 id="孩子兄弟表示法（链式存储）"><a class="header-anchor" href="#孩子兄弟表示法（链式存储）"></a>孩子兄弟表示法（链式存储）</h4><p>孩子兄弟表示法又称二叉树表示法，即以二叉链表作为树的存储结构。孩子兄弟表示法使每个结点包括三部分内容：结点值、指向结点第一个孩子结点的指针，及指向结点下一个兄弟结点的指针（沿此域可以找到结点的所有兄弟结点）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>, *<span class="title">nextsibling</span>;</span>  <span class="comment">// 第一个孩子和右兄弟指针</span></span><br><span class="line">&#125; CSNode, *CSTree;</span><br></pre></td></tr></table></figure><p>这种存储表示法比较灵活，其最大的优点是可以方便地实现树转换为二叉树的操作，易于查找结点的孩子等，但缺点是从当前结点查找其双亲结点比较麻烦。若为每个结点增设一个 <code>parent</code> 域指向其父结点，则查找结点的父结点也很方便。</p><h3 id="树、森林与二叉树的转换"><a class="header-anchor" href="#树、森林与二叉树的转换"></a>树、森林与二叉树的转换</h3><p>由于二叉树和树都可以用二叉链表作为存储结构，因此以二叉链表作为媒介可以导出树与二叉树的一个对应关系，即给定一棵树， 可以找到唯一的一棵二叉树与之对应。从物理结构上看，它们的二叉链表是相同的，只是解释不同而已。</p><p>树转换为二叉树的规则：每个结点左指针指向它的第一个孩子，右指针指向它在树中的相邻右兄弟，这个规则又称“左孩子右兄弟”。由于根结点没有兄弟，所以对应的二叉树没有右子树。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB.png" alt="树与二叉树的对应关系"></p><p>树转换成二叉树的画法：</p><ol><li>在兄弟结点之间加一连线；</li><li>对每个结点，只保留它与第一个孩子的连线，而与其他孩子的连线全部抹掉；</li><li>以树根为轴心，顺时针旋转45°。</li></ol><p>将森林转换为二叉树的规则与树类似。先将森林中的每棵树转换为二叉树，由于任何一棵和树对应的二叉树的右子树必空，若把森林中第二棵树根视为第一棵树根的右兄弟，即将第二棵树对应的二叉树当作第一棵二叉树根的右子树，将第三棵树对应的二叉树当作第二棵二叉树根的右子…以此类推，就可以将森林转换为二叉树。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E6%A3%AE%E6%9E%97%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB.png" alt="森林与二叉树的对应关系"></p><p>森林转换成二叉树的画法：</p><ol><li>将森林中的每棵树转换成相应的二叉树</li><li>每棵树的根也可视为兄弟关系，在每棵树的根之间加一根连线；</li><li>以第一棵树的根为轴心顺时针旋转45°。</li></ol><p>二叉树转换为森林的规则：若二叉树非空，则二叉树的根及其左子树为第一棵树的二叉树形式，故将根的右链断开。二叉树根的右子树又可视为一个由除第一棵树 外的森林转换后的二叉树，应用同样的方法，直到最后只剩一棵没有右子树的二叉树为止，最后再将每棵二叉树依次转换成树，就得到了原森林。二叉树转换为树或森林是唯一的。</p><h3 id="树和森林的遍历"><a class="header-anchor" href="#树和森林的遍历"></a>树和森林的遍历</h3><p>树的遍历是指用某种方式访问树中的每个结点，且仅访问一次。主要有两种方式（深度优先遍历）：</p><ol><li>先根遍历。若树非空，先访问根结点，再依次遍历根结点的每棵子树，遍历子树时仍遵循先根后子树的规则。其遍历序列与这棵树相应二叉树的先序序列相同。</li><li>后根遍历。若树非空，先依次遍历根结点的每棵子树，再访问根结点，遍历子树时仍遵循先子树后根的规则。其遍历序列与这棵树相应二叉树的中序序列相同。</li></ol><p>另外，树也有层次遍历（广度优先遍历），与二叉树的层次遍历思想基本相同，即按层序依次访问各结点。</p><p>按照森林和树相互递归的定义，可得到森林的两种遍历方法。</p><ol><li>先序遍历森林。若森林为非空，则按如下规则进行遍历（效果等同于依次对各个树进行先根遍历）：<ul><li>访问森林中第一棵树的根结点。</li><li>先序遍历第一棵树中根结点的子树森林。</li><li>先序遍历除去第一棵树之后剩余的树构成的森林。</li></ul></li><li>中序遍历森林。森林为非空时，按如下规则进行遍历（效果等同于依次对各个树进行后根遍历）：<ul><li>中序遍历森林中第一棵树的根结点的子树森林。</li><li>访问第一棵树的根结点。</li><li>中序遍历除去第一棵树之后剩余的树构成的森林。</li></ul></li></ol><h2 id="树与二叉树的应用"><a class="header-anchor" href="#树与二叉树的应用"></a>树与二叉树的应用</h2><h3 id="二叉排序树（BST）"><a class="header-anchor" href="#二叉排序树（BST）"></a>二叉排序树（BST）</h3><h4 id="二叉排序树的定义"><a class="header-anchor" href="#二叉排序树的定义"></a>二叉排序树的定义</h4><p>二叉排序树（也称二叉查找树）或者是一棵空树，或者是具有下列特性的二叉树：</p><ol><li>若左子树非空，则左子树上所有结点的值均小于根结点的值。</li><li>若右子树非空，则右子树上所有结点的值均大于根结点的值。</li><li>左、右子树也分别是一棵二叉排序树。</li></ol><p>根据二叉排序树的定义，左子树结点值 &lt; 根结点值 &lt; 右子树结点值，所以对二叉排序树进行中序遍历，可以得到一个<font color="#FF666">递增</font>的有序序列。</p><h4 id="二叉排序树的查找"><a class="header-anchor" href="#二叉排序树的查找"></a>二叉排序树的查找</h4><p>二叉排序树的查找是从根结点开始，沿某个分支逐层向下比较的过程。若二叉排序树非空，先将给定值与根结点的关键字比较，若相等，则查找成功；若不等，如果小于根结点的关键字，则在根结点的左子树上查找，否则在根结点的右子树上查找。这显然是一个递归的过程。</p><p>二叉排序树的非递归查找算法，最坏空间复杂度 $O(1)$ ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉排序树的结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; BSTNode, *BSTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在二叉排序树中查找值为 key 的结点</span></span><br><span class="line"><span class="function">BSTNode *<span class="title">BST_Search</span><span class="params">(BSTree T, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (T != <span class="literal">nullptr</span> &amp;&amp; key != T-&gt;key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; T-&gt;key) &#123;</span><br><span class="line">            T = T-&gt;lchild;  <span class="comment">// 小于 在左子树上查找</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            T = T-&gt;rchild;  <span class="comment">// 大于 在右子树上查找</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二叉排序树的递归查找算法实现，最坏空间复杂度 $O(h)$ ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BSTNode *<span class="title">BST_Search</span><span class="params">(BSTree T, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;  <span class="comment">// 查找失败</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key == T-&gt;key) &#123;</span><br><span class="line">        <span class="keyword">return</span> T;  <span class="comment">// 查找成功</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; T-&gt;key) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">BST_Search</span>(T-&gt;lchild, key);  <span class="comment">// 在左子树中查找</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">BST_Search</span>(T-&gt;rchild, key);  <span class="comment">// 在右子树中找</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉排序树的插入"><a class="header-anchor" href="#二叉排序树的插入"></a>二叉排序树的插入</h4><p>二叉排序树作为一种动态树表，其特点是树的结构通常不是一次生成的，而是在查找过程中，当树中不存在关键字值等于给定值的结点时再进行插入的。</p><p>插入结点的过程如下：若原二叉排序树为空，则直接插入结点；否则，若关键字 key 小于根结点值，则插入到左子树，若关键字 key 大于根结点值，则插入到右子树。插入的结点一定是一个新添加的叶结点，且是查找失败时的查找路径上访问的最后一个结点的左孩子或右孩子。</p><p>二叉排序树插入操作的算法描述如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在二叉排序树插入关键字为 k 的新结点（递归实现）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BST_Insert</span><span class="params">(BSTree &amp;T, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">nullptr</span>) &#123;  <span class="comment">// 树为空，新插入的结点为根结点</span></span><br><span class="line">        T = (BSTree)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(BSTNode));</span><br><span class="line">        T-&gt;key = k;</span><br><span class="line">        T-&gt;lchild = T-&gt;rchild = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k == T-&gt;key) &#123;  <span class="comment">// 树中存在相同关键字结点。插入失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; T-&gt;key) &#123;  <span class="comment">// 插入到T的左子树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">BST_Insert</span>(T-&gt;lchild, k);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 插入到T的右子树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">BST_Insert</span>(T-&gt;rchild, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TODO 实现二叉排序树插入操作的非递归实现</p><h4 id="二叉排序树的构造"><a class="header-anchor" href="#二叉排序树的构造"></a>二叉排序树的构造</h4><p>构造二叉排序树的算法描述如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Creat_BST</span><span class="params">(BSTree &amp;T, <span class="keyword">int</span> str[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    T = <span class="literal">nullptr</span>;  <span class="comment">// 初始时T为空树</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123; <span class="comment">// 依次将每个关键字插入到二叉排序树中</span></span><br><span class="line">        <span class="built_in">BST_Insert</span>(T, str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉排序树的删除"><a class="header-anchor" href="#二叉排序树的删除"></a>二叉排序树的删除</h4><p>在二叉排序树中删除一个结点时，不能把以该结点为根的子树上的结点都删除，必须先把被删除结点从存储二叉排序树的链表上摘下，将因删除结点而断开的二叉链表重新链接起来，同时确保二叉排序树的性质不会丢失。删除操作的实现过程按 3 种情况来处理：</p><ol><li>若被删除结点是叶结点，则直接删除，不会破坏二叉排序树的性质。</li><li>若结点 z 只有一棵左子树或右子树，则让 z 的子树成为 z 父结点的子树，替代 z 的位置。</li><li>若结点 z 有左、右两棵子树，则令 z 的直接后继（或直接前驱）替代 z，然后从二叉排序树中删去这个直接后继（或直接前驱），这样就转换成了第一或第二种情况。</li></ol><h4 id="二叉排序树的查找效率分析"><a class="header-anchor" href="#二叉排序树的查找效率分析"></a>二叉排序树的查找效率分析</h4><p>二叉排序树的查找效率，主要取决于树的高度。</p><p>若二叉排序树的左、右子树的高度之差的绝对值不超过 1，则这样的二叉排序树称为平衡二叉树，它的平均查找长度为 $O(\log_{2}{n})$ 。</p><p>若二叉排序树是一个只有右（左）孩子的单支树（类似于有序的单链表），则其平均查找长度为 $O(n)$。在最坏情况下，即构造二叉排序树的输入序列是有序的，则会形成一个倾斜的单支树，此时二叉排序树的性能显著变坏，树的高度也增加为元素个数 $n$ 。</p><p>从查找过程看，二叉排序树与二分查找相似。就平均时间性能而言，二叉排序树上的查找和二分查找差不多。但二分查找的判定树唯一，而二叉排序树的查找不唯一，相同的关键字其插入顺序不同可能生成不同的二叉排序树，</p><h3 id="平衡二叉树⭐"><a class="header-anchor" href="#平衡二叉树⭐"></a>平衡二叉树⭐</h3><h4 id="平衡二叉树的定义"><a class="header-anchor" href="#平衡二叉树的定义"></a>平衡二叉树的定义</h4><p>为避免树的高度增长过快，降低二叉排序树的性能，规定在插入和删除二叉树结点时，要保证任意结点的左、右子树高度差的绝对值不超过 1， 将这样的二叉树称为平衡二叉树（Balanced Binary Tree），简称平衡树（ AVL 树）。定义结点左子树与右子树的高度差为该<font color="#ea66a6">结点的平衡因子</font>，则平衡二叉树结点的平衡因子的值只可能是 -1、0 或 1。</p><p>因此，平衡二叉树可定义为或者是一棵空树，或者是具有下列性质的二叉树：它的左子树和右子树都是平衡二叉树，且左子树和右子树的高度差的绝对值不超过 1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 平衡二叉树结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> balance;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; AVLNode, *AVLTree;</span><br></pre></td></tr></table></figure><h4 id="平衡二叉树的插入"><a class="header-anchor" href="#平衡二叉树的插入"></a>平衡二叉树的插入</h4><p>二叉排序树保证平衡的基本思想如下：每当在二叉排序树中插入（或删除）一个结点时，首先检查其插入路径上的结点是否因为此次操作而导致了不平衡。若导致了不平衡，则先找到插入路径上离插入结点最近的平衡因子的绝对值大于 1 的结点 A，再对以 A 为根的子树，在保持二叉排序树特性的前提下，调整各结点的位置关系，使之重新达到平衡。</p><p>注意：每次调整的对象都是<font color="#ea66a6">最小不平衡子树</font>，即以插入路径上离插入结点最近的平衡因子的绝对值大于 1 的结点作为根的子树。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E6%9C%80%E5%B0%8F%E4%B8%8D%E5%B9%B3%E8%A1%A1%E5%AD%90%E6%A0%91%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="最小不平衡子树示意图"></p><p>平衡二叉树的插入过程的前半部分与二叉排序树相同，但在新结点插入后，若造成查找路径上的某个结点不再平衡，则需要做出相应的调整。可将调整的规律归纳为下列 4 种情况：</p><ol><li>LL 平衡旋转（右单旋转）。由于在结点 A 的左孩子（L）的左子树（L）上插入了新结点，A 的平衡因子由 1 增至 2，导致以 A 为根的子树失去平衡，需要一次向右的旋转操作。 将 A 的左孩子 B 向右上旋转代替 A 成为根结点，将 A 结点向右下旋转成为 B 的右子树的根结点，而 B 的原右子树则作为 A 结点的左子树。如下图所示，其中结点旁的数值代表结点的平衡因子，而用方块表示相应结点的子树，下方数值代表该子树的高度。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/LL%E5%B9%B3%E8%A1%A1%E6%97%8B%E8%BD%AC.png" alt="LL平衡旋转"></p><ol start="2"><li>RR 平衡旋转（左单旋转）。由于在结点 A 的右孩子（ R ）的右子树（ R ）。上插入了新结点，A 的平衡因子由 -1 减至 -2，导致以 A 为根的子树失去平衡，需要一次向左的旋转操作。将 A 的右孩子 B 向左，上旋转代替 A 成为根结点，将 A 结点向左下旋转成为 B 的左子树的根结点，而 B 的原左子树则作为 A 结点的右子树。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/RR%E5%B9%B3%E8%A1%A1%E6%97%8B%E8%BD%AC.png" alt="RR平衡旋转"></p><ol start="3"><li>LR 平衡旋转（先左后右双旋转）。由于在 A 的左孩子（L）的右子树（R）。上插入新结点，A 的平衡因子由 1 增至 2，导致以 A 为根的子树失去平衡，需要进行两次旋转操作，先左旋转后右旋转。先将 A 结点的左孩子 B 的右子树的根结点 C 向左上旋转提升到 B 结点的位置，然后再把该 C 结点向右上旋转提升到 A 结点的位置。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/LR%E5%B9%B3%E8%A1%A1%E6%97%8B%E8%BD%AC.png" alt="LR平衡旋转"></p><ol start="4"><li>RL 平衡旋转（先右后左双旋转）。由于在 A 的右孩子（R）的左子树（L）。上插入新结点，A 的平衡因子由 -1 减至 -2，导致以 A 为根的子树失去平衡，需要进行两次旋转操作，先右旋转后左旋转。先将 A 结点的右孩子 B 的左子树的根结点 C 向右上旋转提升到 B 结点的位置，然后再把该 C 结点向左上旋转提升到 A 结点的位置。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/RL%E5%B9%B3%E8%A1%A1%E6%97%8B%E8%BD%AC.png" alt="RL平衡旋转"></p><p>假设关键字序列为 <code>&#123;15, 3, 7, 10, 9, 8&#125;</code>，通过该序列生成平衡二叉树的过程如下图所示。(d) 插入 7 后导致不平衡，最小不平衡子树的根为 15，插入位置为其左孩子的右子树，故执行 LR 旋转，先左后右双旋转，调整后的结果如图 (e) 所示。图 (g) 插入 9 后导致不平衡，最小不平衡子树的根为 15，插入位置为其左孩子的左子树，故执行 LL 旋转，右单旋转，调整后的结果如图 (h) 所示。图 (i) 插入 8 后导致不平衡，最小不平衡子树的根为 7，插入位置为其右孩子的左子树，故执行 RL 旋转，先右后左双旋转，调整后的结果如图 (j) 所示。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B.png" alt="平衡二叉树的生成过程"></p><h4 id="平衡二叉树的查找"><a class="header-anchor" href="#平衡二叉树的查找"></a>平衡二叉树的查找</h4><p>在平衡二叉树上进行查找的过程与二叉排序树的相同。因此，在查找过程中，与给定值进行比较的关键字个数不超过树的深度。假设以 $n_h$ 表示深度为 $h$ 的平衡树中含有的最少结点数。显然，有 $n_0=0,n_1=1,n_2=2$ ，并且有 $n_h=n_{h-1}+n_{h-2}+1$ 。 可以证明，含有 $n$ 个结点的平衡二叉树的最大深度为 $O(\log_{2}{n})$，因此平衡二叉树的平均查找长度为 $O(\log_{2}{n})$ 。</p><h3 id="哈夫曼树和哈夫曼编码"><a class="header-anchor" href="#哈夫曼树和哈夫曼编码"></a>哈夫曼树和哈夫曼编码</h3><h4 id="哈夫曼树的定义"><a class="header-anchor" href="#哈夫曼树的定义"></a>哈夫曼树的定义</h4><p>在许多应用中，树中结点常常被赋予一个表示某种意义的数值，称为该<font color="#ea66a6">结点的权</font>（如：表示结点的重要性）。</p><p>从树的根到任意结点的路径长度（经过的边数）与该结点上权值的乘积，称为该<font color="#ea66a6">结点的带权路径长度</font>。</p><p>树中所有叶结点的带权路径长度之和称为该<font color="#ea66a6">树的带权路径长度</font>，记为 $$WPL=\sum_{i=1}^{n} w_il_i$$ 式中，$w_i$ 是第 $i$ 个叶结点所带的权值，$l_i$ 是该叶结点到根结点的路径长度。</p><p>在含有 $n$ 个带权叶结点的二叉树中，其中带权路径长度（WPL）最小的二叉树称为<font color="#ea66a6">哈夫曼树</font>，也称最优二叉树。</p><h4 id="哈夫曼树的构造"><a class="header-anchor" href="#哈夫曼树的构造"></a>哈夫曼树的构造</h4><p>给定 $n$ 个权值分别为 $w_i,\ w_2,\dots ,w_n$ 的结点，构造哈夫曼树的算法描述如下：</p><ol><li>将这 $n$ 个结点分别作为 $n$ 棵仅含一个结点的二叉树，构成森林 $F$。</li><li>构造一个新结点，从 $F$ 中选取两棵根结点权值最小的树作为新结点的左、右子树，并且将新结点的权值置为左、右子树上根结点的权值之和。</li><li>从 $F$ 中删除刚才选出的两棵树，同时将新得到的树加入 $F$ 中。</li><li>重复步骤 2 和 3，直至 $F$ 中只剩下一棵树为止。</li></ol><p>从上述构造过程中可以看出哈夫曼树具有如下特点：</p><ol><li>每个初始结点最终都成为叶结点，且权值越小的结点到根结点的路径长度越大。</li><li>构造过程中共新建了$n-1$个结点（双分支结点），因此哈夫曼树的结点总数为 $2n-1$ 。</li><li>每次构造都选择 2 棵树作为新结点的孩子，因此哈夫曼树中不存在度为 1 的结点。</li></ol><h4 id="哈夫曼编码"><a class="header-anchor" href="#哈夫曼编码"></a>哈夫曼编码</h4><p>在数据通信中：</p><ul><li>若对每个字符用相等长度的二进制位表示，称这种编码方式为<font color="#ea66a6">固定长度编码</font>。</li><li>若允许对不同字符用不等长的二进制位表示，则这种编码方式称为<font color="#ea66a6">可变长度编码</font>。</li></ul><p>可变长度编码比固定长度编码要好得多，其特点是对频率高的字符赋以短编码，而对频率较低的字符则赋以较长一些的编码，从而可以使字符的平均编码长度减短，起到压缩数据的效果。哈夫曼编码是一种被广泛应用而且非常有效的数据压缩编码。</p><p>若没有一个编码是另一个编码的前缀，则称这样的编码为<font color="#ea66a6">前缀编码</font>。举例:设计字符 A，B 和 C 对应的编码 0，101 和 100 是前缀编码。对前缀编码的解码很简单，因为没有一个编码是其他编码的前缀。所以识别出第一个编码，将它翻译为原码，再对余下的编码文件重复同样的解码操作。例如，码串 00101100 可被唯一地翻译为0，0，101 和 100。另举反例：如果再将字符 D 的编码设计为 00，此时 0 是 00 的前缀，那么这样的码串的前两位就无法唯一翻译。</p><p>由哈夫曼树得到哈夫曼编码是很自然的过程。首先，将每个出现的字符当作一个独立的结点，其权值为它出现的频度（或次数），构造出对应的哈夫曼树。显然，所有字符结点都出现在叶结点中。我们可将字符的编码解释为从根至该字符的路径上边标记的序列，其中边标记为 0 表示“转向左孩子”，标记为 1 表示“转向右孩子”。</p><p>注意：0 和 1 究竟是表示左子树还是右子树没有明确规定。左、右孩子结点的顺序是任意的，所以构造出的哈夫曼树并不唯一，但各哈夫曼树的带权路径长度 WPL 相同且为最优。此外，如有若干权值相同的结点，则构造出的哈夫曼树更可能不同，但 WPL 必然相同且是最优的。</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>推导过程：$$\frac{m^{h-1}-1}{m-1}&lt;n\le \frac{m^h-1}{m-1}$$ $$m^{h-1}&lt;n(m-1)+1\le m^h $$ $$ h-1 &lt; \log_{m}{(n(m-1)+1)} \le h $$ $$h_{min}= \left \lceil \log_{m}{(n(m-1)+1) } \right \rceil $$ <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
    <summary type="html">树</summary>
    
    
    
    <category term="数据结构" scheme="http://halo123.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构——串</title>
    <link href="http://halo123.top/2021/05/07/DataStructure/D_String/"/>
    <id>http://halo123.top/2021/05/07/DataStructure/D_String/</id>
    <published>2021-05-07T03:54:51.000Z</published>
    <updated>2021-05-07T12:51:59.544Z</updated>
    
    <content type="html"><![CDATA[<p>【知识框架】</p><p>TODO 完成串知识框架</p><p>【复习提示】</p><p>本章是统考大纲第 6 章内容，采纳读者建议单独作为一章，统考大纲只要求掌握字符串模式匹配，需重点掌握 KMP 匹配算法的原理及 next 数组的推理过程，手工求 <code>next</code> 数组可以先计算出部分匹配值表然后再变形，或根据公式来求解。了解 <code>nextval</code> 数组的求解方法。</p><h2 id="串的定义和实现"><a class="header-anchor" href="#串的定义和实现"></a>串的定义和实现</h2><p>字符串简称串，计算机上非数值处理的对象基本都是字符串数据。我们常见的信息检索系统（如搜索引擎）、文本编辑程序（如Word）、问答系统、自然语言翻译系统等，都是以字符串数据作为处理对象的。本章详细介绍字符串的存储结构及相应的操作。</p><h3 id="串的定义"><a class="header-anchor" href="#串的定义"></a>串的定义</h3><p>串（string）是由零个或多个字符组成的有限序列。一般记为$$S=’ a_1a_2\dots a_n \ (n\ge 0)'$$其中，$S$ 是串名，单引号括起来的字符序列是串的值；$a_i$可以是字母、数字或其他字符；串中字符的个数 $n$ 称为串的长度。$n=0$ 时的串称为空串（用 $\varnothing$ 表示）。</p><ul><li>串中任意个<font color="#FF666">连续的</font>字符组成的子序列称为该串的<font color="#ea66a6">子串</font>（包括空串）</li><li>包含子串的串相应地称为<font color="#ea66a6">主串</font>。</li><li>某个字符在串中的序号称为该<font color="#ea66a6">字符在串中的位置</font>（序号从1开始）。</li><li><font color="#ea66a6">子串在主串中的位置</font>以子串的第一个字符在主串中的位置来表示。</li><li>当两个串的长度相等且每个对应位置的字符都相等时，称这两个串是相等的。</li></ul><blockquote><p>需要注意的是，由一个或多个空格（空格是特殊字符）组成的串称为空格串（注意，空格串不是空串），其长度为串中空格字符的个数。</p></blockquote><p>串的逻辑结构和线性表极为相似，区别仅在于串的数据对象限定为字符集。在基本操作上，串和线性表有很大差别。线性表的基本操作主要以单个元素作为操作对象，如查找、插入或删除某个元素等；而串的基本操作通常以子串作为操作对象，如查找、插入或删除一个子串等。</p><h3 id="串的存储结构"><a class="header-anchor" href="#串的存储结构"></a>串的存储结构</h3><h4 id="定长顺序存储表示"><a class="header-anchor" href="#定长顺序存储表示"></a>定长顺序存储表示</h4><p>类似于线性表的顺序存储结构，用一组地址连续的存储单元存储串值的字符序列。在串的定长顺序存储结构中，为每个串变量分配一个固定长度的存储区，即定长数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLEN 255</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch[MAXLEN];  <span class="comment">// 每个分量存储一个字符串</span></span><br><span class="line">    <span class="keyword">int</span> length;       <span class="comment">// 串的实际长度</span></span><br><span class="line">&#125; SString;</span><br></pre></td></tr></table></figure><p>串的实际长度只能小于等于 <code>MAXLEN</code>，超过预定义长度的串值会被舍去，称为截断。串长有两种表示方法：</p><ul><li>一是如上述定义描述的那样，用一个额外的变量 <code>length</code> 来存放串的长度</li><li>二是在串值后面加一个不计入串长的结束标记字符“\0”， 此时的串长为隐含值。</li></ul><p>在一些串的操作（如插入、联接等）中，若串值序列的长度超过上界 <code>MAXLEN</code>，约定用“截断”法处理，要克服这种弊端，只能不限定串长的最大长度，即采用动态分配的方式。</p><h4 id="堆分配存储表示"><a class="header-anchor" href="#堆分配存储表示"></a>堆分配存储表示</h4><p>堆分配存储表示仍然以一组地址连续的存储单元存放串值的字符序列，但它们的存储空间是在程序执行过程中动态分配得到的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLEN 255</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *ch;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125; HString;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitHString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HString S;</span><br><span class="line">    S.ch = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(MAXLEN * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>));</span><br><span class="line">    S.length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在C语言中，存在一个称之为“堆”的自由存储区，并用 <code>malloc()</code> 和 <code>free()</code> 函数来完成动态存储管理。利用 <code>malloc()</code> 为每个新产生的串分配一块实际串长所需的存储空间，若分配成功，则返回一个指向起始地址的指针，作为串的基地址，这个串由 <code>ch</code> 指针来指示；若分配失败，则返回 <code>NULL</code>。已分配的空间可用 <code>free()</code> 释放掉。</p><p>上述两种存储表示通常为高级程序设计语言所采用。块链存储表示仅做简单介绍。</p><h4 id="块链存储表示"><a class="header-anchor" href="#块链存储表示"></a>块链存储表示</h4><p>类似于线性表的链式存储结构，也可采用链表方式存储串值。由于串的特殊性（每个元素只有一个字符），在具体实现时，每个结点既可以存放一个字符，也可以存放多个字符。每个结点称为块，整个链表称为块链结构。最后一个结点占不满时通常用 <code>#</code> 补上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch[<span class="number">4</span>]; <span class="comment">// 每个结点存多个字符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125; StringNode, * String;</span><br></pre></td></tr></table></figure><h3 id="串的基本操作"><a class="header-anchor" href="#串的基本操作"></a>串的基本操作</h3><ul><li><code>StrAssign(&amp;T,chars)</code>：赋值操作。把串 T 赋值为 chars</li><li><code>StrCopy(&amp;T,S)</code>：复制操作。由串 S 复制得到串 T</li><li><code>StrEmpty(S)</code>：判空操作。若 S 为空串，则返回 TRUE，否则返回 FALSE</li><li><code>StrCompare(S, T)</code>：比较操作。若 S&gt;T，则返回值 &gt;0 ；若S=T，则返回值 =0 ；若 S&lt;T，则返回值 &lt;0</li><li><code>StrLength(S)</code>：求串长。返回串 S 的元素个数</li><li><code>SubString (&amp;Sub,S,pos,len)</code>：求子串。用 Sub 返回串 S 的第 pos 个字符起长度为 len 的子串</li><li><code>Concat (&amp;T,S1,S2)</code>：串联接。用 T 返回由 S1 和 S2 联接而成的新串</li><li><code>Index(S,T)</code>：定位操作。若主串 S 中存在与串 T 值相同的子串，则返回它在主串 S 中第一次出现的位置；否则函数值为0</li><li><code>ClearString(&amp;S)</code>：清空操作。将 S 清为空串</li><li><code>DestroyString(&amp;S)</code>：销毁串。将串S销毁</li></ul><p>不同的高级语言对串的基本操作集可以有不同的定义方法。在上述定义的操作中，串赋值 <code>StrAssign</code>、串比较 <code>StrCompare</code>、求串长 <code>StrLength</code>、串联接 <code>Concat</code> 及求子串 <code>SubString</code> 五种操作构成串类型的最小操作子集，即这些操作不可能利用其他串操作来实现；反之，其他串操作（除串清除 <code>ClearString</code> 和串销毁 <code>DestroyString</code> 外）均可在该最小操作子集上实现。</p><p>例如，可利用判等、求串长和求子串等操作实现定位函数 <code>Index(S, T)</code>。算法思想为：在主串 $S$ 中取从第一个字符起、长度和串 $T$ 相等的子串，与串 $T$ 比较，若相等则求得函数值为 $i$，否则 $i$ 值增1，直至串 $S$ 中不存在和串 $T$ 相等的子串为止。</p><h4 id="实现求子串"><a class="header-anchor" href="#实现求子串"></a>实现求子串</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求子串。用 Sub 返回串 S 的第 pos 个字符起长度为 len 的子串</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SubString</span><span class="params">(SString &amp;Sub, SString S, <span class="keyword">int</span> pos, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 子串范围越界</span></span><br><span class="line">    <span class="keyword">if</span> (pos + len - <span class="number">1</span> &gt; S.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt; pos + len; i++) &#123;</span><br><span class="line">        Sub.ch[i - pos + <span class="number">1</span>] = S.ch[i];</span><br><span class="line">    &#125;</span><br><span class="line">    Sub.length = len;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现比较操作"><a class="header-anchor" href="#实现比较操作"></a>实现比较操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较操作。若 S&gt;T，则返回值 &gt;0 ；若S=T，则返回值 =0 ；若 S&lt;T，则返回值 &lt;0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrCompare</span><span class="params">(SString S, SString T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= S.length &amp;&amp; i &lt;= T.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S.ch[i] != T.ch[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> S.ch[i] - T.ch[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 扫描过所有字符都相同，则长度长的串更大</span></span><br><span class="line">    <span class="keyword">return</span> S.length - T.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现定位操作"><a class="header-anchor" href="#实现定位操作"></a>实现定位操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定位操作。</span></span><br><span class="line"><span class="comment">// 若主串 S 中存在与串 T 值相同的子串，则返回它在主串 S 中第一次出现的位置；</span></span><br><span class="line"><span class="comment">// 否则函数值为0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index</span><span class="params">(SString S, SString T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>, n = S.length, m = T.length;</span><br><span class="line">    SString sub;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n - m + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">SubString</span>(sub, S, i, m);        <span class="comment">// 求子串</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">StrCompare</span>(sub, T) != <span class="number">0</span>) &#123;  <span class="comment">// 比较操作</span></span><br><span class="line">            ++i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i;  <span class="comment">// 返回子串在主串中的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="串的模式匹配"><a class="header-anchor" href="#串的模式匹配"></a>串的模式匹配</h2><h3 id="简单的模式匹配算法"><a class="header-anchor" href="#简单的模式匹配算法"></a>简单的模式匹配算法</h3><p>子串的定位操作通常称为串的模式匹配，它求的是子串（常称模式串）在主串中的位置。这里采用定长顺序存储结构，给出一种不依赖于其他串操作的暴力匹配算法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 朴素模式匹配算法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index2</span><span class="params">(SString S, SString T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">1</span>;  <span class="comment">// 指向主串开始匹配的位置</span></span><br><span class="line">    <span class="keyword">int</span> i = k;  <span class="comment">// 主串匹配时的匹配位置 </span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;  <span class="comment">// 子串匹配时对应的位置</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= S.length &amp;&amp; j &lt;= T.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S.ch[i] == T.ch[j]) &#123;  <span class="comment">// 相等检查下一个字符</span></span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 有不相等检查下一个子串</span></span><br><span class="line">            k++;</span><br><span class="line">            i = k; <span class="comment">// 如果不设置k，i=i-j+2</span></span><br><span class="line">            j = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果因为主串匹配完导致结束需要判断子串是否刚好匹配</span></span><br><span class="line">    <span class="comment">// 如果j超出边界说明子串得到匹配</span></span><br><span class="line">    <span class="keyword">if</span> (j &gt; T.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述算法中，分别用计数指针 $i$ 和 $j$ 指示主串 $S$ 和模式串 $T$ 中当前正待比较的字符位置。算法思想为：从主串 $S$ 的第一个字符起，与模式 $T$ 的第一个字符比较，若相等，则继续逐个比较后续字符；否则从主串的下一个字符起，重新和模式的字符比较；以此类推，直至模式 $T$ 中的每个字符依次和主串 $S$ 中的一个连续的字符序列相等，则称匹配成功，函数值为与模式 $T$ 中第一个字符相等的字符在主串 $S$ 中的序号，否则称匹配不成功，函数值为零。将主串中与模式串长度相同的子串搞出来，挨个与模式串对比当子串与模式串某个对应字符不匹配时，就立即放弃当前子串，转而检索下一个子串。</p><p>若 $m$ 为模式串长度，$n$ 为主串长度，则</p><ul><li>匹配成功的最好时间复杂度为：$O(m)$</li><li>匹配失败的最好时间复杂度为：$O(n-m+1)=O(n-m)\approx O(n)$</li><li>匹配成功的最坏时间复杂度为：$O(nm-m^2+m)\approx O(nm)$</li></ul><p>最坏情况：每个子串的前 $m-1$ 个字符都和模式串匹配，只有第 $m$ 个字符不匹配；</p><p>比较好的情况：每个子串的第 1 个字符就与模式串不匹配。</p><h3 id="KMP算法"><a class="header-anchor" href="#KMP算法"></a>KMP算法</h3><blockquote><p>由D. E.Knuth，J.H.Morris和 V.R.Pratt 提出，因此称为KMP算法</p></blockquote><p>推荐直接看视频理解思想：<a href="https://www.bilibili.com/video/BV1b7411N798?p=35">数据结构，KPM算法</a></p><p>概况是对朴素模式匹配算法的优化，通过引入next数组来减少回溯。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// KMP算法思想</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index_KMP</span><span class="params">(SString S, SString T, <span class="keyword">int</span> next[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= S.length &amp;&amp; j &lt;= T.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || S.ch[i] == T.ch[j]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j]; <span class="comment">// 模式串向右移动</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &gt; T.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> i - T.length;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="求模式串的next数组"><a class="header-anchor" href="#求模式串的next数组"></a>求模式串的next数组</h4><ul><li>串的前缀：包含第一个字符，且不包含最后一个字符的子串。</li><li>串的后缀：包含最后一个字符，且不包含第一个字符的子串.</li></ul><p>next数组手算方法：当第 j 个字符匹配失败，由前 1~j-1 个字符组成的串记为 S，则：next[j] = S的最长相等前缀长度+1，特别的 next[1] = 0；此外存在next[2]时 next[2] = 1。</p><h4 id="KMP算法性能分析"><a class="header-anchor" href="#KMP算法性能分析"></a>KMP算法性能分析</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取next数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_next</span><span class="params">(SString T, <span class="keyword">int</span> next[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; T.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || T.ch[i] == T.ch[j]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// KMP算法实现</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index_KMP</span><span class="params">(SString S, SString T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> next[T.length + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">get_next</span>(T, next);</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= S.length &amp;&amp; j &lt;= T.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || S.ch[i] == T.ch[j]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &gt; T.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> i - T.length;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>KMP算法平均时间复杂度：$O(n+m)$</p><h4 id="KMP算法优化"><a class="header-anchor" href="#KMP算法优化"></a>KMP算法优化</h4><p>next 数组在某些情况下尚有缺陷，还可以进一步优化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nextval</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_nextval</span><span class="params">(SString T, <span class="keyword">int</span> nextval[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    nextval[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; T.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || T.ch[i] == T.ch[j]) &#123;</span><br><span class="line">            nextval[i] = j;</span><br><span class="line">            <span class="keyword">if</span> (T.ch[i] != T.ch[j]) &#123;</span><br><span class="line">                nextval[i] = j;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nextval[i] = nextval[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = nextval[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">字符串模式匹配</summary>
    
    
    
    <category term="数据结构" scheme="http://halo123.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构——栈和队列</title>
    <link href="http://halo123.top/2021/05/02/DataStructure/C_StacksAndQueues/"/>
    <id>http://halo123.top/2021/05/02/DataStructure/C_StacksAndQueues/</id>
    <published>2021-05-02T08:35:51.000Z</published>
    <updated>2021-05-07T12:51:54.721Z</updated>
    
    <content type="html"><![CDATA[<p>【考纲内容】</p><ul><li>栈和队列的基本概念</li><li>栈和队列的顺序存储结构</li><li>栈和队列的链式存储结构</li><li>栈和队列的应用</li><li>特殊矩阵的压缩存储</li></ul><p>【知识框架】</p><p>TODO 制作栈和队列章节的脑图</p><p>【复习提示】</p><p>本章通常以选择题的形式考查，题目不算难，但命题的形式比较灵活，其中栈（出入栈的过程、出栈序列的合法性）和队列的操作及其特征是重点。由于它们均是线性表的应用和推广，因此也容易出现在算法设计题中。此外，栈和队列的顺序存储、链式存储及其特点、双端队列的特点、栈和队列的常见应用，以及数组和特殊矩阵的压缩存储都是读者必须掌握的内容。</p><h2 id="栈"><a class="header-anchor" href="#栈"></a>栈</h2><h3 id="栈的基本概念"><a class="header-anchor" href="#栈的基本概念"></a>栈的基本概念</h3><h4 id="栈的定义"><a class="header-anchor" href="#栈的定义"></a>栈的定义</h4><p>栈（Stack）：只允许在一端进行插入或删除操作的线性表。首先栈是一种线性表，但限定这种线性表只能在某一端进行插入和删除操作。</p><p>栈顶（Top）：线性表允许进行插入删除的那一端。</p><p>栈底（Bottom）：固定的，不允许进行插入和删除的另一端。</p><p>空栈：不含任何元素的空表。</p><p>假设某个栈 $S = (a_{1},a_2, a_3,a_4,a_5)$，则 $a_1$ 为栈底元素，$a_5$ 为栈顶元素。由于栈只能在栈顶进行插入和删除操作，进栈次序依次为 $a_{1},a_2, a_3,a_4,a_5$ 而出栈次序为 $a_{5},a_4, a_3,a_2,a_1$。由此可见，栈的操作特性可以明显地概括为后进先出（Last In First Out，LIFO）。</p><p>栈的数学性质：$n$ 个不同元素进栈，出栈元素不同排列的个数为 $\frac{1}{n+1}C_{2n}^{n}  $。上述公式称为<wavy>卡特兰（Catalan）数</wavy>，可采用数学归纳法证明。</p><h4 id="找的基本操作"><a class="header-anchor" href="#找的基本操作"></a>找的基本操作</h4><ul><li><code>InitStack(&amp;S)</code>：初始化一个空栈 S。</li><li><code>StackEmpty(S)</code>：判断一个栈是否为空，若栈 S 为空则返回 true，否则返回 false。</li><li><code>Push(&amp;S,x)</code>：进栈，若栈 S 未满，则将 x 加入使之成为新栈顶。</li><li><code>Pop(&amp;S,&amp;x)</code>：出栈，若栈 S 非空，则弹出栈顶元素，并用 x 返回。</li><li><code>GetTop(S, &amp;x) </code>：读栈顶元素，若栈 S 非空，则用 x 返回栈项元素。</li><li><code>DestroyStack(&amp;S)</code>：销毁栈，并释放栈 S 占用的存储空间。</li></ul><h3 id="栈的顺序存储结构"><a class="header-anchor" href="#栈的顺序存储结构"></a>栈的顺序存储结构</h3><p>栈是一种操作受限的线性表，类似于线性表，它也有对应的两种存储方式。</p><h4 id="顺序栈的实现"><a class="header-anchor" href="#顺序栈的实现"></a>顺序栈的实现</h4><p>采用顺序存储的栈称为<font color="#ea66a6">顺序栈</font>，它利用一组地址连续的存储单元存放自栈底到栈顶的数据元素，同时附设一个指针（top）指示当前栈项元素的位置。栈的顺序存储类型可描述为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">&#125; SqStack;</span><br></pre></td></tr></table></figure><ul><li>栈顶指针：<code>S.top</code>，初始时设置 <code>S.top=-1</code>；</li><li>栈顶元素：<code>S.data[S.top]</code>；</li><li>进栈操作：栈不满时，栈顶指针先加1，再送值到栈顶元素。</li><li>出栈操作：栈非空时，先取栈顶元素值，再将栈项指针减 1。</li><li>栈空条件：<code>S.top==-1</code>；</li><li>栈满条件：<code>S.top==MaxSize-1</code></li><li>栈长：<code>S.top+1</code></li></ul><p>由于顺序栈的入栈操作受数组上界的约束，当对栈的最大使用空间估计不足时，有可能发生栈上溢，此时应及时向用户报告消息，以便及时处理，避免出错。</p><h4 id="顺序栈的基本运算"><a class="header-anchor" href="#顺序栈的基本运算"></a>顺序栈的基本运算</h4><p>初始化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    S.top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断栈空：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StackEmpty</span><span class="params">(SqStack S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进栈：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(SqStack &amp;S,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == MaxSize<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    S.data[++S.top] = x;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当找不满时， top 先加 1，再入栈。</p><p>出栈：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S,<span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    X = S.data[S.top--];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取栈顶元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S,<span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    X = S.data[S.top];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：这里 top 指向的是栈顶元素，所以进栈操作为 <code>S.data[++S.top]=x</code>，出栈操作为<code>x=S.data[S.top--]</code>。</p><p>若栈顶指针初始化为 <code>S.top=0</code>，即 top 指向栈顶元素的下一位置，则入栈操作变为<code>S.data[S.top++]=x</code>; 出栈操作变为 <code>x=S.data[--S.top]</code>。 相应的栈空、栈满条件也会发生变化。</p></blockquote><h4 id="共享栈"><a class="header-anchor" href="#共享栈"></a>共享栈</h4><p>利用栈底位置相对不变的特性，可让两个顺序栈共享一个维数组空间，将两个栈的栈底分<br>别设置在共享空间的<font color="#faa755">两端</font>，两个栈顶向共享空间的中间延伸。</p><p>两个栈的栈顶指针都指向栈顶元素，<code>top0=-1</code>时0号栈为空，<code>top1=MaxSize</code> 时1号栈为<br>空；仅当两个栈顶指针相邻（<code>top1-top0=1</code>） 时，判断为栈满。当0号栈进栈时 top0 先加1<br>再赋值，1号栈进栈时 top1 先减1再赋值；出栈时则刚好相反。</p><p>共享栈是为了更有效地利用存储空间，两个栈的空间相互调节，只有在整个存储空间被占满<br>时才发生溢。其存取数据的时间复杂度均为$O(1)$，所以对存取效率没有什么影响。</p><h3 id="栈的链式存储结构"><a class="header-anchor" href="#栈的链式存储结构"></a>栈的链式存储结构</h3><p>采用链式存储的栈称为链栈，链栈的优点是便于多个栈共享存储空间和提高其效率，且不存在栈满上溢的情况。通常采用单链表实现，并规定所有操作都是在单链表的表头进行的。拢的链式存储类型可描述为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; *LiStack;</span><br></pre></td></tr></table></figure><p>采用链式存储，便于结点的插入与删除。链栈的操作与链表类似，入栈和出栈的操作都在链表的表头进行。需要注意的是，对于带头结点和不带头结点的链栈，具体的实现会有所不同。</p><h2 id="队列"><a class="header-anchor" href="#队列"></a>队列</h2><h3 id="队列的基本概念"><a class="header-anchor" href="#队列的基本概念"></a>队列的基本概念</h3><h4 id="队列的定义"><a class="header-anchor" href="#队列的定义"></a>队列的定义</h4><p>队列（Queue）简称队，也是一种操作受限的线性表，只允许在表的一端进行插入，而在表的另一端进行删除。向队列中插入元素称为入队或进队；删除元素称为出队或离队。这和我们日常生活中的排队是一致的，最早排队的也是最早离队的，其操作的特性是先进先出（First In First Out，FIFO）。</p><ul><li>队头（Front）：允许删除的一端，又称队首。</li><li>队尾（Rear）：允许插入的一端。</li><li>空队列：不含任何元素的空表。</li></ul><h4 id="队列常见的基本操作"><a class="header-anchor" href="#队列常见的基本操作"></a>队列常见的基本操作</h4><ul><li><code>InitQueue(&amp;Q)</code>：初始化队列，构造一个空队列 Q。</li><li><code>QueueEmpty(Q)</code>：判队列空，若队列 Q 为空返回 true，否则返回 false。</li><li><code>EnQueue(&amp;Q,x)</code>：入队，若队列 Q 未满，将 x 加入，使之成为新的队尾。</li><li><code>DeQueue (&amp;Q, &amp;X)</code>：出队，若队列 Q 非空，删除队头元素，并用 x 返回。</li><li><code>GetHead(Q,&amp;x)</code>：读队头元素，若队列 Q 非空，则将队头元素赋值给 x。</li></ul><h3 id="队列的顺序存储结构"><a class="header-anchor" href="#队列的顺序存储结构"></a>队列的顺序存储结构</h3><h4 id="队列的顺序存储"><a class="header-anchor" href="#队列的顺序存储"></a>队列的顺序存储</h4><p>队列的顺序实现是指分配一块连续的存储单元存放队列中的元素，并附设两个指针：队头指<br>针 front 指向队头元素，队尾指针 rear 指向队尾元素的下一个位置（不同教材对 front 和 rear 的定义可能不同，例如，可以让 rear 指向队尾元素、front 指向队头元素。对于不同的定义，出队入队的操作是不同的）。队列的顺序存储类型可描述为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> front,rear;</span><br><span class="line">&#125; SqQueue;</span><br></pre></td></tr></table></figure><ul><li>初始状态（队空条件）：<code>Q.front==Q.rear==0</code>。</li><li>进队操作：队不满时，先送值到队尾元素，再将队尾指针加 1。</li><li>出队操作：队不空时，先取队头元素值，再将队头指针加 1。</li></ul><p>这样的顺序存储只能进行一次的排满队和出队的操作。</p><h4 id="循环队列"><a class="header-anchor" href="#循环队列"></a>循环队列</h4><p>这里引出循环队列的概念将顺序队列臆造为一个环状的空间，即把存储队列元素的表从逻辑上视为一个环，称为循环队列。当队首指针 <code>Q. front=MaxSize-1</code> 后，再前进一个位置就自动到 0，这可以利用除法取余运算来实现。</p><ul><li>初始时：<code>Q.front=Q.rear=0</code></li><li>队首指针进1：<code>Q.front=(Q.front+1)%MaxSize</code></li><li>队尾指针进1：<code>Q.rear=(Q.rear+1)%MaxSize</code></li><li>队列长度：<code>(Q.rear+MaxSize-Q.front)%MaxSize</code></li></ul><p>为了区分队空还是 队满的情况，有3种处理方式：</p><ol><li>牺牲一个单元来区分队空和队满，入队时少用一个队列单元，这是较为普遍的做法约定以“队头指针在队尾指针的下一位置作为队满的标志”。<ul><li>队满条件：<code>(Q.rear+1)%MaxSize==Q.front</code></li><li>队空条件：<code>Q.front==Q.rear</code></li><li>队中元素个数：<code>(Q.rear-Q.front+MaxSize)%MaxSize</code></li></ul></li><li>类型中增设表示元素个数的数据成员。这样，队空的条件为<code>Q.size==0</code>；队满的条件为   <code>Q.size==MaxSize</code>。这两种情况都有<code>Q.front==Q.rear</code>。</li><li>类型中增设 tag 数据成员，以区分是队满还是队空。每次删除操作成功，都令<code>tag=0</code>；每次插入操作成功时，都令<code>tag=1</code>。<ul><li>tag 等于 0 时，若因删除导致<code>Q.front==Q.rear</code>，则为队空；</li><li>tag 等于 1 时，若因插入导致<code>Q.front==Q.rear</code>，则为队满。</li></ul></li></ol><h4 id="循环队列的操作"><a class="header-anchor" href="#循环队列的操作"></a>循环队列的操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QueueEmpty</span><span class="params">(SqQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear==Q.front)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q.rear+<span class="number">1</span>)%MaxSize==Q.front)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Q.data[Q.rear]=x;</span><br><span class="line">    Q.rear=(Q.rear+<span class="number">1</span>)%MaxSize;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(SqQueue &amp;Q,<span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear==Q.front)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    Q.front = (Q.front+<span class="number">1</span>)%MaxSize;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得队头值</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetHeaf</span><span class="params">(SqQueue &amp;Q,<span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear==Q.front)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列的链式存储结构"><a class="header-anchor" href="#队列的链式存储结构"></a>队列的链式存储结构</h3><h4 id="队列的链式存储"><a class="header-anchor" href="#队列的链式存储"></a>队列的链式存储</h4><p>队列的链式表示称为链队列，它实际上是一个同时带有队头指针和队尾指针的单链表。头指针指向队头结点，尾指针指向队尾结点，即单链表的最后一个结点（注意与顺序存储的不同）。队列的链式存储类型可以描述为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> &#123;</span>  <span class="comment">// 链式队列结点</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>  <span class="comment">// 链式队列</span></span><br><span class="line">    LinkNode *front, *rear;</span><br><span class="line">&#125; LinkQueue;</span><br></pre></td></tr></table></figure><h4 id="带头结点链式队列的基本操作"><a class="header-anchor" href="#带头结点链式队列的基本操作"></a>带头结点链式队列的基本操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="comment">// 初始化（带头结点）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始时 front、rear 都指向头节点</span></span><br><span class="line">    Q.front = Q.rear = (LinkNode *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(LinkNode));</span><br><span class="line">    Q.front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">(LinkQueue Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.front == Q.rear) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    LinkNode *s = (LinkNode *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(LinkNode));</span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Q.rear-&gt;next = s;</span><br><span class="line">    Q.rear = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q, <span class="keyword">int</span> &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.front == Q.rear) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 空队列</span></span><br><span class="line">    &#125;</span><br><span class="line">    LinkNode *p = Q.front-&gt;next;</span><br><span class="line">    x = p-&gt;data;              <span class="comment">// 变量x返回队头元素</span></span><br><span class="line">    Q.front-&gt;next = p-&gt;next;  <span class="comment">// 修改头结点的next指针</span></span><br><span class="line">    <span class="keyword">if</span> (Q.rear == p) &#123;     <span class="comment">// 如果删除的是队列中的最后一个结点</span></span><br><span class="line">        Q.rear = Q.front;  <span class="comment">// 设置队列为空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// QueueByChain.cpp</span></span><br></pre></td></tr></table></figure><h4 id="不带头结点链式队列的基本操作"><a class="header-anchor" href="#不带头结点链式队列的基本操作"></a>不带头结点链式队列的基本操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化（不带头结点）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    Q.front = <span class="literal">NULL</span>;</span><br><span class="line">    Q.rear = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">(LinkQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    LinkNode *s = (LinkNode *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(LinkNode));</span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        Q.front = s;</span><br><span class="line">        Q.rear = s;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Q.rear-&gt;next = s;</span><br><span class="line">        Q.rear = s</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队</span></span><br><span class="line"><span class="keyword">bool</span> <span class="built_in">DeQueue</span>(LinkQueue &amp;Q, <span class="keyword">int</span> &amp;x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.front == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 空队列</span></span><br><span class="line">    &#125;</span><br><span class="line">    LinkNode *p = Q.front;</span><br><span class="line">    x = p-&gt;data;            <span class="comment">// 变量x返回队头元素</span></span><br><span class="line">    Q.front = p-&gt;next;      <span class="comment">// 修改头结点的next指针</span></span><br><span class="line">    <span class="keyword">if</span> (Q.rear == p) &#123;      <span class="comment">// 如果删除的是队列中的最后一个结点</span></span><br><span class="line">        Q.front = <span class="literal">nullptr</span>;  <span class="comment">// 设置队列为空</span></span><br><span class="line">        Q.rear = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// QueueByChainWithoutHead.cpp</span></span><br></pre></td></tr></table></figure><h3 id="双端队列"><a class="header-anchor" href="#双端队列"></a>双端队列</h3><p>双端队列是指允许两端都可以进行入队和出队操作的队列。其元素的逻辑结构仍是线性结构。将队列的两端分别称为前端和后端，两端都可以入队和出队。</p><ul><li>栈：只允许从一端插入和删除的线性表</li><li>队列：只允许从一端插入、另一端删除的线性表</li><li>双端队列：只允许从两端插入、两端删除的线性表</li><li>输入受限的双端队列：只允许从一端插入、 两端删除的线性表</li><li>输出受限的双端队列：只允许从两端插入、一端删除的线性表</li></ul><h2 id="栈和队列的应用"><a class="header-anchor" href="#栈和队列的应用"></a>栈和队列的应用</h2><h3 id="栈在括号匹配中的应用"><a class="header-anchor" href="#栈在括号匹配中的应用"></a>栈在括号匹配中的应用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据结构</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> top;  <span class="comment">// 栈顶指针</span></span><br><span class="line">&#125; SqStack;</span><br><span class="line"><span class="comment">// 初始化栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 判断栈是否为空</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StackEmpty</span><span class="params">(SqStack S)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 入栈</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(SqStack &amp;S, <span class="keyword">char</span> x)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 出栈</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S, <span class="keyword">char</span> &amp;x)</span> </span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 括号匹配</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bracketCheck</span><span class="params">(<span class="keyword">char</span> str[], <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    SqStack S;</span><br><span class="line">    <span class="built_in">InitStack</span>(S);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">&#x27;(&#x27;</span> || str[i] == <span class="string">&#x27;[&#x27;</span> || str[i] == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">Push</span>(S, str[i]);  <span class="comment">// 扫描左括号入栈</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">StackEmpty</span>(S)) &#123;  <span class="comment">// 扫描右括号，如果栈空</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;     <span class="comment">// 匹配失败</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> topElem;</span><br><span class="line">            <span class="built_in">Pop</span>(S, topElem);  <span class="comment">// 栈顶元素出栈</span></span><br><span class="line">            <span class="keyword">if</span> (str[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; topElem != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (str[i] == <span class="string">&#x27;]&#x27;</span> &amp;&amp; topElem != <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (str[i] == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; topElem != <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">StackEmpty</span>(S);  <span class="comment">// 检查完全部括号后，栈空说明匹配成功</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// BracketCheck.cpp</span></span><br></pre></td></tr></table></figure><h3 id="栈在表达式求值的应用"><a class="header-anchor" href="#栈在表达式求值的应用"></a>栈在表达式求值的应用</h3><h4 id="算数表达式"><a class="header-anchor" href="#算数表达式"></a>算数表达式</h4><p>算数表达式由三个部分组成：操作数、运算符、界限符（即括号，反映计算的先后顺序）</p><ul><li>中缀表达式：运算符在两个操作数的中间，如 <code>a + b</code>，<code>a + b - c</code>，<code>a + b - c * d</code></li><li>后缀表达式：运算符在两个操作数的后面，如 <code>a b +</code>，<code>a b + c -</code> ，<code>a b + c d * - </code></li><li>前缀表达式：运算符在两个操作数的前面，如 <code>+ a b </code>，<code>- + a b c</code> ，<code>- + a b * c d</code></li></ul><h4 id="中缀转后缀"><a class="header-anchor" href="#中缀转后缀"></a>中缀转后缀</h4><p><strong>中缀转后缀</strong>的手算方法：</p><ol><li>确定中缀表达式中各个运算符的运算顺序</li><li>选择下一个运算符，按照「左操作数 右操作数 运算符」的方式组合成一个新的操作数</li><li>如果还有运算符没被处理，就继续步骤2</li></ol><blockquote><p>注意：保证手算和计算机算结果相同，需要遵循“左优先”原则，即只要左边的运算符能先计算就优先计算左边的。（可以保证运算顺序唯一）</p></blockquote><p>中缀转后缀的机算方法：</p><ul><li>初始化一个栈，用于保存暂时还不能确定运算顺序的运算符。</li><li>从左到右处理各个元素，直到末尾。可能遇到三种情况：<ol><li>遇到操作数。直接加入后缀表达式</li><li>遇到界限符。遇到 <code>(</code> 直接入栈；遇到 <code>)</code> 则依次弹出栈内运算符并加入后缀表达式，直到弹出 <code>(</code> 为止。注意：<code>)</code> 不加入后缀表达式。</li><li>遇到运算符。依次弹出栈中优先级高于或等于当前运算符的所有运算符，并加入后缀表达式，若碰到 <code>(</code> 或栈空则停止。之后再把当前运算符入栈。</li></ol></li><li>按上述方法处理完所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式。</li></ul><p>后缀表达式结果的手算方法：从左往右扫描，每遇到一个运算符，就让运算符前面最近的两个操作数执行对应运算，合体为一个操作数。</p><p>用栈实现后缀表达式的计算：</p><ol><li>从左往右扫描下一个元素，直到处理完所有元素</li><li>若扫描到操作数则压入栈，并回到步骤1；否则执行步骤3</li><li>若扫描到运算符，则弹出两个栈顶元素（先出栈的是“右操作数”），执行相应运算，运算结果压回栈顶，回到步骤1</li></ol><h4 id="中缀转前缀"><a class="header-anchor" href="#中缀转前缀"></a>中缀转前缀</h4><p>前缀表达式较后缀表达式用的较少</p><p><strong>中缀转前缀</strong>的手算方法：</p><ol><li>确定中缀表达式中各个运算符的运算顺序</li><li>选择下一个运算符，按照「运算符 左操作数 右操作数」的方式组合成一个新的操作数</li><li>如果还有运算符没被处理，就继续步骤2</li></ol><blockquote><p>注意：同样为保证手算和计算机算结果相同，需要遵循“右优先”原则，即只要右边的运算符能先计算，就优先算右边的。</p></blockquote><p>用栈实现前缀表达式的计算：</p><ol><li><wavy>从右往左</wavy>扫描下一个元素，直到处理完所有元素</li><li>若扫描到操作数则压入栈，并回到步骤1；否则执行步骤3</li><li>若扫描到运算符，则弹出两个栈顶元素（先出栈的是“左操作数”），执行相应运算，运算结果压回栈顶，回到步骤1</li></ol><h4 id="中缀表达式的计算"><a class="header-anchor" href="#中缀表达式的计算"></a>中缀表达式的计算</h4><p>用栈实现中缀表达式的计算（中缀转后缀+后缀表达式求值）：</p><ol><li>初始化两个栈，操作数栈和运算符栈</li><li>若扫描到操作数，压入操作数栈</li><li>若扫描到运算符或界限符，则按照“中缀转后缀”相同的逻辑压入运算符栈（期间也会弹出运算符，每当弹出一个运算符时，就需要再弹出两个操作数栈的栈顶元素并执行相应运算，运算结果再压回操作数栈）</li></ol><p>TODO 中缀表达式的计算的代码实现</p><h3 id="栈在递归的应用"><a class="header-anchor" href="#栈在递归的应用"></a>栈在递归的应用</h3><p>函数调用的特点：最后被调用的函数最先执行结束（LIFO）</p><p>函数调用时，需要用一个栈存储：调用返回地址；实参；局部变量</p><p>适合用“递归”算法解决：可以把原始问题转换为属性相同，但规模较小的问题。必须注意递归模型不能是循环定义的，其必须满足下面的两个条件，即递归表达式（递归体）和边界条件（递归出口）。</p><p>缺点：太多层递归可能会导致栈溢出</p><p>例如，计算正整数的阶乘 $n!$ ：</p><p>$$\mathrm{factorial}(n)=\begin{cases}<br>n*\mathrm{factorial}(n-1), &amp; n&gt;1 \\<br>1, &amp; n=1 \\<br>1, &amp; n=0<br>\end{cases}$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算正整数 n!</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n * <span class="built_in">factorial</span>(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="built_in">factorial</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求斐波那契数列：</p><p>$$\mathrm{Fib}(n)=\begin{cases}<br>\mathrm{Fib}(n-1)+\mathrm{Fib}(n-2), &amp; n&gt;1 \\<br>1, &amp; n=1 \\<br>0, &amp; n=0<br>\end{cases}$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算斐波那契数列</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Fib</span>(n - <span class="number">1</span>) + <span class="built_in">Fib</span>(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d,&quot;</span>, <span class="built_in">Fib</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E9%80%92%E5%BD%92%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B.png" alt="斐波那契数列递归计算过程"></p><p>显然，在递归调用的过程中，<code>Fib(3)</code> 被计算了2次，<code>Fib(2)</code> 被计算了3次。<code>Fib(1)</code> 被调用了5次，<code>Fib(0)</code>被调用了3次。所以，递归的效率低下，但优点是代码简单，容易理解。</p><p>可以将递归算法转换为非递归算法，通常需要借助找来实现这种转换。</p><h3 id="队列在层次遍历中的应用"><a class="header-anchor" href="#队列在层次遍历中的应用"></a>队列在层次遍历中的应用</h3><p>层次遍历二叉树的过程：</p><ol><li>根节点入队</li><li>若队空（所有结点都已处理完毕），则结束遍历；否则重复步骤3操作。</li><li>队列中第一个结点出队，并访问之。若其有左孩子，则将左孩子入队；若其有右孩子，则将右孩子入队，返回步骤2。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="层次遍历二叉树的过程"></p><h3 id="队列在图的广度优先遍历的应用"><a class="header-anchor" href="#队列在图的广度优先遍历的应用"></a>队列在图的广度优先遍历的应用</h3><p>详见“图”章节，思想类似于树的层次遍历</p><h3 id="队列在计算机系统中的应用"><a class="header-anchor" href="#队列在计算机系统中的应用"></a>队列在计算机系统中的应用</h3><p>多个进程争抢着使用有限的系统资源时，FCFS ( First Come First Service）先来先服务是一种常用策略。</p><h2 id="特殊矩阵的压缩存储"><a class="header-anchor" href="#特殊矩阵的压缩存储"></a>特殊矩阵的压缩存储</h2><p>矩阵在计算机图形学、工程计算中占有举足轻重的地位。在数据结构中考虑的是如何用最小的内存空间来存储同样的一组数据。所以，我们不研究矩阵及其运算等，而把精力放在如何将矩阵更有效地存储在内存中，并能方便地提取矩阵中的元素。</p><h3 id="数组的定义"><a class="header-anchor" href="#数组的定义"></a>数组的定义</h3><p><font color="#ea66a6">数组</font>是由 $n\ (n\ge 1)$ 个相同类型的数据元素构成的有限序列，每个数据元素称为一个数组元素，每个元素在 $n$ 个线性关系中的序号称为该元素的下标，下标的取值范围称为数组的维界。</p><p>数组与线性表的关系：数组是线性表的推广。一维数组可视为一个线性表；二维数组可视为其元素也是定长线性表的线性表，以此类推。数组一旦被定义，其维数和维界就不再改变。因此，除结构的初始化和销毁外，数组只会有存取元素和修改元素的操作。</p><h3 id="数组的存储结构"><a class="header-anchor" href="#数组的存储结构"></a>数组的存储结构</h3><p>大多数计算机语言都提供了数组数据类型，逻辑意义上的数组可采用计算机语言中的数组数据类型进行存储，一个数组的所有元素在内存中占用一段连续的存储空间。</p><p>以一维数组 <code>A[0...n-1]</code> 为例，其存储结构关系式为：$$LOC(a_i)=LOC(a_0)+i\times L （0\le i &lt; n）$$ 其中，$LOC$ 是内存地址，$L$ 是每个数组元素所占的存储单元。</p><p>对于多维数组，有两种映射方法：按行优先（一行一行存，一行存完存下一行）和按列优先（一列一列存，一列存完存下一列）。以二维数组为例：</p><p>按行优先存储的基本思想是：先行后列，先存储行号较小的元素，行号相等先存储列号较小的元素。设二维数组的行下标与列下标的范围分别为 $[0, h_1]$ 与 $[0, h_2]$，则存储结构关系式为：$$LOC(a_{i,j})=LOC(a_{0,0})+[i \times (h_2+1) +j] \times L$$ 当以列优先方式存储时， 得出存储结构关系式为：$$LOC(a_{i,j})=LOC(a_{0,0})+[j \times (h_1+1) +i] \times L$$</p><h3 id="矩阵的压缩存储"><a class="header-anchor" href="#矩阵的压缩存储"></a>矩阵的压缩存储</h3><p>普通矩阵可用二维数组存储，特殊矩阵可以压缩存储空间。</p><p>压缩存储：指为多个值相同的元素只分配一个存储空间，对零元素不分配存储空间。其目的是为了节省存储空间。</p><p>特殊矩阵：指具有许多相同矩阵元素或零元素，并且这些相同矩阵元素或零元素的分布有一定规律性的矩阵。常见的特殊矩阵有对称矩阵、上（下）三角矩阵、对角矩阵等。</p><p>特殊矩阵的压缩存储方法：找出特殊矩阵中值相同的矩阵元素的分布规律，把那些呈现规律性分布的、值相同的多个矩阵元素压缩存储到一个存储空间中。</p><h4 id="对称矩阵"><a class="header-anchor" href="#对称矩阵"></a>对称矩阵</h4><p>若对一个 $n$ 阶方阵 $A[1…n] [1…n]$ 中的任意一个元素 $a_{i,j}$ 都有 $a_{i,j}=a_{j,i}\ (a \le i,j \le n)$ ，称为对称矩阵。对于一个 $n$ 阶方阵，其中的元素可以划分为3个部分，即上三角区（$i &lt; j$）、主对角线（$i=j$）和下三角区（$i &gt;j$）。</p><p>$$\begin{bmatrix}<br>a_{1,1} &amp; a_{1,2} &amp; \dots  &amp; a_{1,n} \\<br>a_{2,1} &amp; a_{2,2} &amp; \dots &amp; a_{2,n} \\<br>\vdots  &amp;  \vdots &amp; \ddots  &amp; \vdots \\<br>a_{n,1} &amp; a_{n,2} &amp; \dots  &amp;  a_{n,n}<br>\end{bmatrix}$$</p><p>对于 $n$ 阶对称矩阵，上三角区的所有元素和下三角区的对应元素相同，若仍采用二维数组存放，则会浪费几乎一半的空间，为此将对称矩阵 $A[1…n] [1…n]$ 存放在一维数组 $B[\frac{n(n+1)}{2} ]$ 中，即元素 $a_{i,j}$ 存放在 $b_k$ 中。只按<wavy>行优先</wavy>原则将各元素存入一维数组中，存放下三角部分（含主对角）的元素。</p><p>在数组 $B$ 中，位于元素 $a_{i,j} \ (i \ge j)$ 前面的元素个数为：</p><ul><li>第1行：1个元素 $(a_{1,1})$</li><li>第2行：2个元素 $(a_{2,1},a_{2,2})$</li><li>……</li><li>第 $ i-1 $ 行：$i-1$ 个元素 $(a_{i-1,1},a_{i-1,2},\dots ,a_{i-1,i-1})$</li><li>第 $i$ 行：$j-1$ 个元素 $(a_{i,1},a_{i,2},\dots a_{i,j-1})$</li></ul><p>因此，元素 $a_{i,j}$ 在数组 $B$ 中的下标 $k=1 +2+ \dots +(i - 1) + j- 1 = \frac{i(i-1)}{2}+j-1$ （数组下标从0开始）。因此，元素下标之间的对应关系如下：</p><p>$$k = \begin{cases}<br>\frac{i(i-1)}{2}+j-1, &amp; i \ge j \\<br>\frac{j(j-1)}{2}+i-1, &amp; i &lt; j<br>\end{cases}$$</p><p>TODO 对称矩阵压缩代码实现</p><h4 id="三角矩阵"><a class="header-anchor" href="#三角矩阵"></a>三角矩阵</h4><p>$$\begin{bmatrix}<br>a_{1,1} &amp;  \\<br>a_{2,1} &amp; a_{2,2} \\<br>\vdots &amp; \vdots &amp; \ddots  \\<br>a_{n,1} &amp; a_{n,2} &amp; \cdots &amp; a_{n,n}<br>\end{bmatrix}<br>\begin{bmatrix}<br>a_{1,1}&amp; a_{1,2} &amp; \cdots &amp; a_{1,n} \\<br>&amp; a_{2,2} &amp; \cdots &amp;a_{2,n} \\<br>&amp;  &amp; \ddots &amp; \vdots \\<br>&amp;  &amp;  &amp; a_{n,n}<br>\end{bmatrix} $$</p><p>下三角矩阵中，上三角区的所有元素均为同一常量。其存储思想与对称矩阵类似，不同之处在于存储完下三角区和主对角线上的元素之后，紧接着存储对角线上方的常量一次，故可以将下三角矩阵 $A[1\dots n][1\dots n]$ 压缩存储在 $B[\frac{n(n+1)}{2}+1]$ 中。元素下标之间的对应关系为：</p><p>$$k = \begin{cases} \frac{i(i-1)}{2}+j-1, &amp; i \ge j \\ \frac{n(n+1)}{2}, &amp; i &lt; j \end{cases}$$</p><p>上三角矩阵中，下三角区的所有元素均为同一常量。只需存储主对角线、上三角区上的元素和下三角区的常量一次，可将其压缩存储在 $B[\frac{n(n+1)}{2}+1]$ 中，元素下标之间的对应关系如下：</p><p>$$ k = \begin{cases}<br>\frac{(i-1)(2n-i+2)}{2}+(j-i), &amp; i \ge j \\<br>\frac{n(n+1)}{2}, &amp; i &lt; j<br>\end{cases} $$</p><p>TODO 三角矩阵压缩代码实现</p><h4 id="三对角矩阵"><a class="header-anchor" href="#三对角矩阵"></a>三对角矩阵</h4><p>对角矩阵也称带状矩阵。对于 $n$ 阶方阵 $\mathit{A} $ 中任一元素 $a_{i,j}$ ，当 $|i-j|&gt;1$ 时，有 $a_{i,j}=0 \ (1\le i,j \le n)$ ，则称为三对角矩阵。</p><p>$$\begin{bmatrix}<br>a_{1,1}&amp; a_{1,2}&amp;   &amp;  \\<br>a_{2,1}&amp; a_{2,2}&amp; a_{2,3} &amp;   &amp;   \\<br>&amp; a_{3,2}&amp; a_{3,3} &amp; a_{3,4}  &amp;   \\<br>&amp; &amp;\ddots &amp;\ddots &amp;  \ddots &amp;  \\<br>&amp;&amp; &amp;a_{n-1,n-2} &amp; a_{n-1,n-1} &amp; a_{n-1,n} \\<br>&amp;&amp; &amp; &amp; a_{n,n-1} &amp; a_{n,n}<br>\end{bmatrix} $$</p><p>在三对角矩阵中，所有非零元素都集中在以主对角线为中心的3条对角线区域，其他区域的元素都为0。</p><p>三对角矩阵 $\mathit{A} $ 也可以采用压缩存储，将3条对角线上的元素按<wavy>行优先</wavy>方式存放在一维数组 $B[3n-2]$ 中，且 $a_{1,1}$ 存放于 $B[0]$ 中。</p><p>三对角矩阵 $\mathit{A} $ 3对角线上的元素 $a_{i,j} \ (1 \le i,j \le n,\ |i-j| \le 1)$ 在一维数组 $B$ 中存放的下标为 $k=2i+j-3$</p><p>反之，若己知三对角线矩阵中某元素 $a_{i,j}$， 存放于一维数组 $B$ 的第 $k$ 个位置，则可得 $i=\left \lfloor {\frac{k+1}{3}+1} \right \rfloor $ ，$j=k-2i+3$</p><p>TODO 三对角矩阵压缩实现</p><h3 id="稀疏矩阵"><a class="header-anchor" href="#稀疏矩阵"></a>稀疏矩阵</h3><p>矩阵中非零元素的个数 $t$，相对矩阵元素的个数 $s$ 来说非常少，即 $s\gg t$ 的矩阵称为稀疏矩阵。例如，一个矩阵的阶为100×100，该矩阵中只有少于100个非零元素。</p><p>若采用常规的方法存储稀疏矩阵，则相当浪费存储空间，因此仅存储非零元素。但通常零元素的分布没有规律，所以仅存储非零元素的值是不够的，还要存储它所在的行和列。因此，将非零元素及其相应的行和列构成一个三元组（行标，列标，值）。然后再按照某种规律存储这些三元组。稀疏矩阵压缩存储后便失去了随机存取特性。</p><p>稀疏矩阵的三元组既可以采用数组存储，也可以采用十字链表法存储。</p><p>TODO 稀疏矩阵两种方法的C++语言实现</p>]]></content>
    
    
    <summary type="html">描述。</summary>
    
    
    
    <category term="数据结构" scheme="http://halo123.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构——线性表</title>
    <link href="http://halo123.top/2021/04/27/DataStructure/B_LinearList/"/>
    <id>http://halo123.top/2021/04/27/DataStructure/B_LinearList/</id>
    <published>2021-04-27T09:02:51.000Z</published>
    <updated>2021-04-27T09:02:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>【考纲内容】</p><ul><li>线性表的定义和基本操作</li><li>线性表的实现（顺序储存；链式储存；线性表的应用）</li></ul><p>【知识框架】</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-mind-map-a@master/DataStructure/%E7%BA%BF%E6%80%A7%E8%A1%A8.svg" alt="线性表"></p><p>【复习提示】</p><p>线性表是考研命题的重点。这类算法题实现起来比较容易而且代码量较少，但却要求具有最优的性能（时间、空间复杂度），才能获得满分。因此，应牢固掌握线性表的各种基本操作（基于两种存储结构），在平时的学习中多注重培养动手能力。另外，需要提醒的是，算法最重要的是思想！考场上的时间有限，在试卷上不一定要求代码具有实际的可执行性，因此应尽力表达出算法的思想和步骤，而不必过于拘泥每个细节。注意算法题只能用C/C++语言实现。</p><h2 id="线性表的定义和基本操作"><a class="header-anchor" href="#线性表的定义和基本操作"></a>线性表的定义和基本操作</h2><h3 id="线性表的定义"><a class="header-anchor" href="#线性表的定义"></a>线性表的定义</h3><p><font color="#ea66a6">线性表</font>是具有相同数据类型的 $n \ (n≥0)$ 个数据元素的有限序列，其中 $n$ 为表长，当 $n=0$ 时线性表是一个空表。若用 $L$ 命名线性表，则其一般表示为：$$L=(a_1,a_2,\cdots ,a_i,a_{i+1},\cdots ,a_n)$$ 式中，$a_1$ 是唯一的“第一个”数据元素，又称表头元素；$a_n$ 是唯一的“最后一个”数据元素，又称表尾元素。</p><ul><li>除第一个元素外，每个元素有且仅有一个直接前驱。</li><li>除最后一个元素外，每个元素有且仅有一个直接后继。</li></ul><p>以上就是线性表的逻辑特性，这种线性有序的逻辑结构正是线性表名字的由来。线性表的特点如下：</p><ul><li>表中元素的个数有限</li><li>表中元素具有逻辑上的顺序性，表中元素有其先后次序</li><li>表中元素都是<a href="https://halo123.top/2021/04/27/DataStructure/A_Introduction/#%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0">数据元素</a>，每个元素都是单个元素</li><li>表中元素的数据类型都相同，这意味着每个元素占有相同大小的存储空间</li><li>表中元素具有抽象性，即仅讨论元素间的逻辑关系，而不考虑元素究竟表示什么内容。</li></ul><div class="note danger no-icon flat"><p>注意：线性表是一种逻辑结构，表示元素之间一对一的相邻关系。顺序表和链表是指存储结构，两者属于不同层面的概念，因此不要将其混淆。</p></div><h3 id="线性表的基本操作"><a class="header-anchor" href="#线性表的基本操作"></a>线性表的基本操作</h3><p>一个数据结构的基本操作是指其最核心、最基本的操作。其他较复杂的操作可通过调用其基本操作来实现。线性表的主要操作如下：</p><ul><li><code>InitList(&amp;L)</code>：初始化表。构造一个空的线性表。</li><li><code>Length(L)</code>：求表长。返回线性表 L 的长度，即 L 中数据元素的个数。</li><li><code>LocateElem(L,e)</code>：按值查找操作。在表 L 中查找具有给定关键字值的元素。</li><li><code>GetElem(L,i)</code>：按位查找操作。获取表 L 中第 i 个位置的元素的值。</li><li><code>ListInsert(&amp;L,i,e)</code>：插入操作。在表 L 中的第 i 个位置上插入指定元素 e 。</li><li><code>ListDelete(&amp;L,i,&amp;e)</code>：删除操作。删除表 L 中第 i 个位置的元素，并用 e 返回删除元素的值。</li><li><code>PrintList(L)</code>：输出操作。按前后顺序输出线性表 L 的所有元素值。</li><li><code>Empty(L)</code>：判空操作。若 L 为空表，则返回 true，否则返回 false。</li><li><code>DestroyList(&amp;L)</code>：销毁操作。销毁线性表，并释放线性表 L 所占用的内存空间。</li></ul><h2 id="线性表的顺序表示"><a class="header-anchor" href="#线性表的顺序表示"></a>线性表的顺序表示</h2><h3 id="顺序表的定义"><a class="header-anchor" href="#顺序表的定义"></a>顺序表的定义</h3><p>线性表的顺序存储又称<font color="#ea66a6">顺序表</font>。它是用一组地址连续的存储单元依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。第1个元素存储在线性表的起始位置，第 $i$ 个元素的存储位置后面紧接着存储的是第 $i+1$ 个元素，称 $i$ 为元素 $a_i$ 在线性表中的位序。因此，顺序表的特点是表中元素的<wavy>逻辑顺序与其物理顺序相同</wavy>。</p><p>假设线性表 L 储存的起始位置为 <code>LOC(A)</code>，<code>sizeof(ElemType)</code> 是每个数据元素所占用储存空间的大小，则表 L 所对应的顺序存储如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt="线性表的顺序存储结构"></p><blockquote><p>注意：线性表中元素的位序是从 1 开始的，而数组中元素的下标是从 0 开始的。</p></blockquote><h3 id="顺序表的实现方式"><a class="header-anchor" href="#顺序表的实现方式"></a>顺序表的实现方式</h3><h4 id="静态分配"><a class="header-anchor" href="#静态分配"></a>静态分配</h4><p>假定线性表的元素类型为 <code>ElemType</code>（以下具体操作使用<code>int</code>类型），则线性表的顺序存储类型描述为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10             <span class="comment">// 定义线性表的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];    <span class="comment">// 顺序表的元素</span></span><br><span class="line">    <span class="keyword">int</span> length;                <span class="comment">// 顺序表的当前长度</span></span><br><span class="line">&#125; StaticSqList;                <span class="comment">// 顺序表的类型定义 Sq:sequence</span></span><br></pre></td></tr></table></figure><p>一维数组可以是静态分配的，也可以是动态分配的。在静态分配时，由于数组的大小和空间事先已经固定，一旦空间占满，再加入新的数据将会产生溢出，进而导致程序崩溃。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一个顺序表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(StaticSqList &amp;L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Maxsize; i++) &#123;</span><br><span class="line">        L.data[i] = <span class="number">0</span>;  <span class="comment">// 将所有数据元素设置默认值(可省略)</span></span><br><span class="line">    &#125;</span><br><span class="line">    L.length = <span class="number">0</span>;       <span class="comment">// 顺序表初始长度为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    StaticSqList L;     <span class="comment">// 声明一个顺序表</span></span><br><span class="line">    <span class="built_in">InitList</span>(L);        <span class="comment">// 初始化顺序表</span></span><br><span class="line">    <span class="comment">// ...  相关操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动态分配"><a class="header-anchor" href="#动态分配"></a>动态分配</h4><p>而在动态分配时，存储数组的空间是在程序执行过程中通过动态存储分配语句分配的，一旦数据空间占满，就另外开辟一块更大的存储空间，用以替换原来的存储空间，从而达到扩充存储数组空间的目的，而不需要为线性表一次性地划分所有空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InitSize 10           <span class="comment">// 表长度的初始定义</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType *data;           <span class="comment">// 指示动态分配数组的指针</span></span><br><span class="line">    <span class="keyword">int</span> MaxSize,length;       <span class="comment">// 数组的最大容量和当前个数</span></span><br><span class="line">&#125; DynamicSqList;              <span class="comment">// 动态分配数组顺序表的类型定义 </span></span><br></pre></td></tr></table></figure><p>C 的初始动态分配语句为：<code>L.data = (ElemType*)malloc(sizeof(ElemType) * InitSize);</code></p><p>C++ 的初始动态分配语句为：<code>L.data = new ElemType[InitSize];</code></p><blockquote><p>注意：动态分配并不是链式存储，它同样属于顺序存储结构，物理结构没有变化，依然是随机存取方式，只是分配的空间大小可以在运行时决定。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(DynamicSqList &amp;L)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用malloc函数申请一片连续的储存空间</span></span><br><span class="line">    L.data = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>(InitSize * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line">    L.MaxSize = InitSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态增加数组的长度</span></span><br><span class="line"><span class="comment"> * @param L 顺序表</span></span><br><span class="line"><span class="comment"> * @param len 在原基础上扩展的大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IncreaseSize</span><span class="params">(DynamicSqList &amp;L, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = L.data;</span><br><span class="line">    L.data = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>((L.MaxSize + len) * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; i++) &#123;     <span class="comment">// 将数据复制到新区域</span></span><br><span class="line">        L.data[i] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    L.MaxSize += len;    <span class="comment">// 增加顺序表的最大长度</span></span><br><span class="line">    <span class="built_in">free</span>(p);             <span class="comment">// 释放原来的内存空间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    DynamicSqList L;     <span class="comment">// 声明一个顺序表</span></span><br><span class="line">    <span class="built_in">InitList</span>(L);         <span class="comment">// 初始化顺序表</span></span><br><span class="line">    <span class="comment">// ... 插入操作</span></span><br><span class="line">    <span class="built_in">IncreaseSize</span>(L,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="顺序表的特点"><a class="header-anchor" href="#顺序表的特点"></a>顺序表的特点</h3><ul><li>随机访问，即通过首地址和元素序号可在时间 $O(1)$ 内找到指定的元素。</li><li>存储密度高，每个结点只存储数据元素。</li><li>拓展容量不方便（即便采用动态分配的方式实现，拓展长度的时间复杂度也比较高）</li><li>插入、删除操作不方便，逻辑上相邻的元素物理上也相邻，所以插入和删除操作需要移动大量元素。</li></ul><h3 id="顺序表上基本操作的实现"><a class="header-anchor" href="#顺序表上基本操作的实现"></a>顺序表上基本操作的实现</h3><h4 id="插入操作"><a class="header-anchor" href="#插入操作"></a>插入操作</h4><p>在顺序表 L 的第 i（1≤i≤<code>L.length+1</code>）个位置插入新元素 e。</p><ul><li>若 i 的输入不合法，则返回 false，表示插入失败；</li><li>否则，将顺序表的第 i 个元素及其后的所有元素右移一个位置，腾出一个空位置插入新元素 element，顺序表长度增加 1，插入成功，返回 true。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入操作</span></span><br><span class="line"><span class="comment"> * @param L 顺序表</span></span><br><span class="line"><span class="comment"> * @param i 位置</span></span><br><span class="line"><span class="comment"> * @param element 要插入的元素</span></span><br><span class="line"><span class="comment"> * @return 插入成功true,失败false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(StaticSqList &amp;L, <span class="keyword">int</span> i, <span class="keyword">int</span> element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断i的范围是否有效</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 储存已满不能插入</span></span><br><span class="line">    <span class="keyword">if</span> (L.length &gt;= Maxsize) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将第i个元素及之后的元素后移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = L.length; j &gt;= i; j--) &#123;</span><br><span class="line">        L.data[j] = L.data[j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在位置 i 处放入e</span></span><br><span class="line">    L.data[i - <span class="number">1</span>] = element;</span><br><span class="line">    <span class="comment">// 线性表长度加1</span></span><br><span class="line">    L.length++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最好情况：在表尾插入（即 $i = n+1$ ）,元素后移语句不执行，时间复杂度为 $O(1)$。</li><li>最坏情况：在表头插入（即 $i = 1$）,元素后移语句将执行 $n$ 次，时间复杂度为 $O(n)$。</li><li>平均情况：假设 $p_i \ (p_i=\frac{1}{n+1} )$ 是在第 $i$ 个位置上插入一个结点的概率，则在长度为 $n$ 的线性表中插入一个结点时，所需移动结点的平均次数为：</li></ul><p>$$\sum_{i=1}^{n+1}p_{i}\left(n-i+1\right) = \sum_{i=1}^{n+1}\frac{1}{n+1}\left(n-i+1\right) = \frac{1}{n+1}\sum_{i=1}^{n+1}\left(n-i+1\right) = \frac{1}{n+1}\frac{n\left(n+1\right)}{2}=\frac{n}{2}$$ 因此，线性表插入算法的平均时间复杂度为 $O(n)$。</p><h4 id="删除操作"><a class="header-anchor" href="#删除操作"></a>删除操作</h4><p>删除顺序表 L 中第 i（1≤i≤<code>L.length+1</code>）个位置的元素，若成功则返回 true，并将被删除的元素用引用变量 element 返回，否则返回 false。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除操作</span></span><br><span class="line"><span class="comment"> * @param L</span></span><br><span class="line"><span class="comment"> * @param i</span></span><br><span class="line"><span class="comment"> * @param element</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListDelete</span><span class="params">(StaticSqList &amp;L, <span class="keyword">int</span> i, <span class="keyword">int</span> &amp;element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断i的范围是否有效</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将被删除的元素赋值给element</span></span><br><span class="line">    element = L.data[i - <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 将第i个位置后的元素前移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; L.length; j++) &#123;</span><br><span class="line">        L.data[j - <span class="number">1</span>] = L.data[j];</span><br><span class="line">    &#125;</span><br><span class="line">    L.length--;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最好情况：删除表尾元素（即 $i = n$ ），无须移动元素，时间复杂度为 $O(1)$。</li><li>最坏情况：删除表头元素（即 $i = 1$），需移动除第一个元素外的所有元素，时间复杂度为 $O(n)$。</li><li>平均情况：假设 $p_i \ (p_i=\frac {1}{n} )$ 是删除第 $i$ 个位置上结点的概率，则在长度为 $n$ 的线性表中删除一个结点时，所需移动结点的平均次数为：</li></ul><p>$$\sum_{i=1}^{n}p_{i}\left(n-i\right) = \sum_{i=1}^{n}\frac{1}{n}\left(n-i\right) = \frac{1}{n}\sum_{i=1}^{n}\left(n-i\right) = \frac{1}{n}\frac{n\left(n-1\right)}{2}=\frac{n-1}{2}$$ 因此，线性表删除算法的平均时间复杂度为 $O(n)$。</p><h4 id="按位查找"><a class="header-anchor" href="#按位查找"></a>按位查找</h4><p>在顺序表 L 中，获取第 i 个位置的元素的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按位查找</span></span><br><span class="line"><span class="comment"> * @param L</span></span><br><span class="line"><span class="comment"> * @param i</span></span><br><span class="line"><span class="comment"> * @return 第i个位置的元素的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetElem</span><span class="params">(StaticSqList L, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> L.data[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(1)$</p><h4 id="按值查找"><a class="header-anchor" href="#按值查找"></a>按值查找</h4><p>在顺序表 L 中查找第一个元素值等于 element 的元素，并返回其位序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按值查找</span></span><br><span class="line"><span class="comment"> * @param L</span></span><br><span class="line"><span class="comment"> * @param element 需要查找的元素值</span></span><br><span class="line"><span class="comment"> * @return 查找到则返回位序(索引+1)，否则返回0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem</span><span class="params">(StaticSqList L, <span class="keyword">int</span> element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L.data[i] == element) &#123;</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>; <span class="comment">// 下标为 i 的元素值等于 element,返回其位序 i+1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最好情况：查找的元素就在表头，仅需比较一次，时间复杂度为 $O(1)$。</li><li>最坏情况：查找的元素在表尾（或不存在）时，需要比较 $n$ 次，时间复杂度为 $O(n)$。</li><li>平均情况：假设 $p_i \ (p_i=\frac {1}{n})$ 是查找的元素在第 i （1≤i≤L. length）个位置上的概率，则在长度为 $n$ 的线性表中查找值为 e 的元素所需比较的平均次数为：</li></ul><p>$$\sum_{i=1}^{n}p_{i}\times i = \sum_{i=1}^{n}\frac{1}{n}\times i  =  \frac{1}{n}\frac{n\left(n+1\right)}{2}=\frac{n+1}{2}$$ 因此，线性表按值查找算法的平均时间复杂度为 $O(n)$。</p><h2 id="线性表的链式表示"><a class="header-anchor" href="#线性表的链式表示"></a>线性表的链式表示</h2><p>顺序表可以随时存取表中的任意一个元素，它的存储位置可以用一个简单直观的公式表示，但插入和删除操作需要移动大量元素。链式存储线性表时，不需要使用地址连续的存储单元，即不要求逻辑上相邻的元素在物理位置上也相邻，它通过“链”建立起数据元素之间的逻辑关系，因此插入和删除操作不需要移动元素，而只需修改指针，但也会失去顺序表可随机存取的优点。</p><h3 id="单链表的定义"><a class="header-anchor" href="#单链表的定义"></a>单链表的定义</h3><p>线性表的链式存储又称<font color="#ea66a6">单链表</font>，它是指通过一组任意的存储单元来存储线性表中的数据元素。为了建立数据元素之间的线性关系，对每个链表结点，除存放元素自身的信息外，还需要存放一个指向其后继的指针。单链表中结点类型的描述如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;             <span class="comment">// 每个结点存放的一个数据元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span>   <span class="comment">// 指针指向下一个结点</span></span><br><span class="line">&#125; LNode, *LinkList;</span><br></pre></td></tr></table></figure><ul><li><code>data</code>为数据域，存放数据元素;</li><li><code>next</code>为指针域，存放其后继结点的地址。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化不带头结点的空单链表函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    L = <span class="literal">NULL</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用单链表可以解决顺序表需要大量连续存储单元的缺点，但单链表附加指针域，也存在浪费存储空间的缺点。由于单链表的元素离散地分布在存储空间中，所以单链表是非随机存取的存储结构，即不能直接找到表中某个特定的结点。查找某个特定的结点时，需要从表头开始遍历，依次查找。</p><p>通常用头指针来标识一个单链表，如单链表 L，头指针为 NULL 时表示一个空表。此外，为了操作上的方便，在单链表第一个结点之前附加一个结点， 称为<font color="#ea66a6">头结点</font>。头结点的数据域可以不设任何信息，也可以记录表长等信息。头结点的指针域指向线性表的第一个元素结点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化带头结点的空单链表函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    L = (LNode *) <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(LNode)); <span class="comment">// 分配一个头结点</span></span><br><span class="line">    <span class="keyword">if</span>(L == <span class="literal">NULL</span>)&#123; <span class="comment">// 内存不足，分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 头结点之后暂时还没有结点 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>头结点和头指针的区分：不管带不带头结点，头指针始终指向链表的第一个结点， 而头结点是带头结点的链表中的第一个结点，结点内通常不存储信息。</p><p>引入头结点后，可以带来两个优点：</p><ol><li>由于第一个数据结点的位置被存放在头结点的指针域中，所以在链表的第一个位置上的操作和在表的其他位置上的操作一致，无须进行特殊处理。</li><li>无论链表是否为空，其头指针都指向头结点的非空指针（空表中头结点的指针域为空），因此空表和非空表的处理也就得到了统一。</li></ol><h3 id="单链表上基本操作的实现"><a class="header-anchor" href="#单链表上基本操作的实现"></a>单链表上基本操作的实现</h3><h4 id="按位序插入（带头结点）"><a class="header-anchor" href="#按位序插入（带头结点）"></a>按位序插入（带头结点）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按位序插入（带头结点）</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到第i-1个结点 GetElem</span></span><br><span class="line">    LNode *p;   <span class="comment">// 指针p指向当前扫描到的结点</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;  <span class="comment">// 当前p指向的是第几个结点</span></span><br><span class="line">    p = L;      <span class="comment">// L指向头结点，头结点是第0个结点</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span> &amp;&amp; j &lt; i - <span class="number">1</span>) &#123;  <span class="comment">// 循环找到第 i-1 个结点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) &#123;  <span class="comment">// i值不合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将e插入到i-1结点之后 InsertNextNode</span></span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(LNode));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;  <span class="comment">// 将结点s连接到p之后</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最好情况：插入的元素就在表头，时间复杂度为 $O(1)$。</li><li>最坏情况：插入的元素在表尾时，时间复杂度为 $O(n)$。</li><li>平均时间复杂度： $O(n)$。</li></ul><h4 id="按位序插入（不带头结点）"><a class="header-anchor" href="#按位序插入（不带头结点）"></a>按位序插入（不带头结点）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按位序插入（不带头结点）</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;  <span class="comment">// 插入第1个结点操作与其他结点操作不同</span></span><br><span class="line">        LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(LNode));</span><br><span class="line">        s-&gt;data = e;</span><br><span class="line">        s-&gt;next = L;</span><br><span class="line">        L = s;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LNode *p;   <span class="comment">// 指针p指向当前扫描到的结点</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;  <span class="comment">// 当前p指向的是第几个结点</span></span><br><span class="line">    p = L;      <span class="comment">// L指向头结点，头结点是第0个结点</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span> &amp;&amp; j &lt; i - <span class="number">1</span>) &#123;  <span class="comment">// 循环找到第 i-1 个结点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) &#123;  <span class="comment">// i值不合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(LNode));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;  <span class="comment">// 将结点s连接到p之后</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="指定结点的后插操作"><a class="header-anchor" href="#指定结点的后插操作"></a>指定结点的后插操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后插操作：在p结点之后插入元素e</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertNextNode</span><span class="params">(LNode *p, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(LNode));</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">nullptr</span>) &#123;  <span class="comment">// 内存分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;data = e; </span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(1)$。</p><h4 id="指定结点的前插操作"><a class="header-anchor" href="#指定结点的前插操作"></a>指定结点的前插操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前插操作</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertPriorNode</span><span class="params">(LNode *p, <span class="keyword">int</span> element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> *s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(LNode));</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;        <span class="comment">// 新结点s连到p之后 ⭐</span></span><br><span class="line">    s-&gt;data = p-&gt;data;  <span class="comment">// 将p中元素覆盖到s中 </span></span><br><span class="line">    p-&gt;data = element;  <span class="comment">// p中元素覆盖为e</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>指针后插，数据交换。</p></blockquote><p>时间复杂度：$O(1)$。</p><h4 id="按位序删除（带头结点）"><a class="header-anchor" href="#按位序删除（带头结点）"></a>按位序删除（带头结点）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按位序删除</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListDelete</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i, <span class="keyword">int</span> &amp;e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找</span></span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span> &amp;&amp; j &lt; i - <span class="number">1</span>) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span> || p-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    LNode *q = p-&gt;next;  <span class="comment">// 使q指向被删除的结点</span></span><br><span class="line">    e = q-&gt;data;         <span class="comment">// 用e返回元素的值</span></span><br><span class="line">    p-&gt;next = q-&gt;next;   <span class="comment">// 将*q结点从链中断开</span></span><br><span class="line">    <span class="built_in">free</span>(q);             <span class="comment">// 释放结点储存空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最好情况：删除的元素就在表头，时间复杂度为 $O(1)$。</li><li>最坏情况：删除的元素在表尾时，时间复杂度为 $O(n)$。</li><li>平均时间复杂度： $O(n)$。</li></ul><h4 id="删除指定结点"><a class="header-anchor" href="#删除指定结点"></a>删除指定结点</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteNode</span><span class="params">(LNode *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *q = p-&gt;next;      <span class="comment">// 使q指向*p的后继结点</span></span><br><span class="line">    p-&gt;data = p-&gt;next-&gt;data; <span class="comment">// 和后继结点交换数据域</span></span><br><span class="line">    p-&gt;next = q-&gt;next;       <span class="comment">// 将*q结点从链中断开</span></span><br><span class="line">    <span class="built_in">free</span>(q);                 <span class="comment">// 释放后继结点的储存空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(1)$。</p><blockquote><p>注意：上段代码无法解决 p 结点时尾结点时的删除问题，删除尾结点需要从头开始查找</p></blockquote><h4 id="按位查找（带头结点）"><a class="header-anchor" href="#按位查找（带头结点）"></a>按位查找（带头结点）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按位查找，返回第i个元素</span></span><br><span class="line"><span class="function">LNode *<span class="title">GetElement</span><span class="params">(LinkList L, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span> &amp;&amp; j &lt; i) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最好情况：查找的元素就在表头，时间复杂度为 $O(1)$。</li><li>最坏情况：查找的元素在表尾时，时间复杂度为 $O(n)$。</li><li>平均时间复杂度： $O(n)$。</li></ul><h4 id="按值查找-v2"><a class="header-anchor" href="#按值查找-v2"></a>按值查找</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LNode *<span class="title">LocateElem</span><span class="params">(LinkList L, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    LNode *p = L-&gt;next;</span><br><span class="line">    <span class="comment">// 从第一个结点开始查找数据域为e的结点</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span> &amp;&amp; p-&gt;data != e) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最好情况：查找的元素就在表头，时间复杂度为 $O(1)$。</li><li>最坏情况：查找的元素在表尾（或不存在）时，时间复杂度为 $O(n)$。</li><li>平均时间复杂度： $O(n)$。</li></ul><h4 id="求单链表的长度"><a class="header-anchor" href="#求单链表的长度"></a>求单链表的长度</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求表的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    LNode *p = L;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(n)$。</p><h4 id="头插法建立单链表"><a class="header-anchor" href="#头插法建立单链表"></a>头插法建立单链表</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkList <span class="title">List_HeadInsert</span><span class="params">(LinkList &amp;L)</span> </span>&#123;</span><br><span class="line">    LNode *s;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(LNode));</span><br><span class="line">    L-&gt;next = <span class="literal">nullptr</span>;  <span class="comment">// 初始空链表</span></span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    <span class="keyword">while</span> (x &gt; <span class="number">9999</span>) &#123;  <span class="comment">// 输入值大于9999表示结束</span></span><br><span class="line">        s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(LNode));  <span class="comment">// 后插操作</span></span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        s-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = s;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>重要应用：链表逆置</p></blockquote><h4 id="尾插法建立单链表"><a class="header-anchor" href="#尾插法建立单链表"></a>尾插法建立单链表</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkList <span class="title">List_TailInsert</span><span class="params">(LinkList &amp;L)</span> </span>&#123;</span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(LNode)); <span class="comment">// 建立头结点</span></span><br><span class="line">    LNode *s, *r = L;  <span class="comment">// r指针为表尾指针</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    cin &gt;&gt; x;  <span class="comment">// 输入结点的数据</span></span><br><span class="line">    <span class="keyword">while</span> (x &gt; <span class="number">9999</span>) &#123;   <span class="comment">// 输入值大于9999表示结束</span></span><br><span class="line">        s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(LNode));</span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        r-&gt;next = s;</span><br><span class="line">        r = s;    <span class="comment">// r指向新的表尾结点</span></span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(n)$</p><h3 id="双链表"><a class="header-anchor" href="#双链表"></a>双链表</h3><p>单链表结点中只有一个指向其后继的指针，使得单链表只能从头结点依次顺序地向后遍历。要访问某个结点的前驱结点（插入、删除操作时），只能从头开始遍历，访问后继结点的时间复杂度为 $O(1)$ ，访问前驱结点的时间复杂度为 $O(n)$。</p><p>为了克服单链表的上述缺点，引入了双链表，双链表结点中有两个指针 prior 和 next，分别指向其前驱结点和后继结点，双链表中结点类型的描述如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;  <span class="comment">// 数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>, *<span class="title">next</span>;</span>  <span class="comment">// 前驱指针和后继指针</span></span><br><span class="line">&#125; DNode, *DLinklist;</span><br></pre></td></tr></table></figure><p>双链表在单链表的结点中增加了一个指向其前驱的 prior 指针，因此双链表中的按值查找和按位查找的操作与单链表的相同。但双链表在插入和删除操作的实现上，与单链表有着较大的不同。这是因为“链”变化时也需要对 prior 指针做出修改，其关键是保证在修改的过程中不断链。此外，双链表可以很方便地找到其前驱结点，因此，插入、删除操作的时间复杂度仅为 $O(1)$。</p><h4 id="双链表的插入"><a class="header-anchor" href="#双链表的插入"></a>双链表的插入</h4><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E5%8F%8C%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E7%BB%93%E7%82%B9%E8%BF%87%E7%A8%8B.png" alt="双链表插入结点过程"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InertNextDNode</span><span class="params">(DNode *p, DNode *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span> || s == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;next = p-&gt;next;  <span class="comment">// ① 将结点*s插入到结点*p之后</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        p-&gt;next-&gt;prior = s; <span class="comment">// ②</span></span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;prior = p; <span class="comment">// ③</span></span><br><span class="line">    p-&gt;next = s;  <span class="comment">// ④</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的语句顺序不是唯一的， 但也不是任意的，① 和 ② 两步必须在 ④ 步之前，否则 <code>*p</code> 的后继结点的指针就会丢掉，导致插入失败。</p><h4 id="双链表的删除"><a class="header-anchor" href="#双链表的删除"></a>双链表的删除</h4><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E5%8F%8C%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9%E8%BF%87%E7%A8%8B.png" alt="双链表删除结点过程"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 双链表的删除操作</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteNextDNode</span><span class="params">(DNode *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DNode *q = p-&gt;next;  <span class="comment">// 找到p的后继结点q</span></span><br><span class="line">    <span class="keyword">if</span> (q == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// p没有后继结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next = q-&gt;next; <span class="comment">// ①</span></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        q-&gt;next-&gt;prior = p; <span class="comment">// ②</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双链表的循环"><a class="header-anchor" href="#双链表的循环"></a>双链表的循环</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后向遍历</span></span><br><span class="line"><span class="keyword">while</span>(p != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">    <span class="comment">// 相关处理...</span></span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前向遍历</span></span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">    <span class="comment">// 相关处理...</span></span><br><span class="line">    p = p-&gt;prior;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前向变量（跳过头结点）</span></span><br><span class="line"><span class="keyword">while</span> (p-&gt;prior != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">    <span class="comment">// 相关处理...</span></span><br><span class="line">    p = p-&gt;prior;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双链表不可随机存取，按位查找、按值查找操作都只能用遍历的方式实现。时间复杂度 $O(n)$。</p><h3 id="循环链表"><a class="header-anchor" href="#循环链表"></a>循环链表</h3><h4 id="循环单链表"><a class="header-anchor" href="#循环单链表"></a>循环单链表</h4><p>循环单链表和单链表的区别在于，表中最后一个结点的指针不是NULL，而改为指向头结点，从而整个链表形成一个环。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;             <span class="comment">// 每个结点存放的一个数据元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span>   <span class="comment">// 指针指向下一个结点</span></span><br><span class="line">&#125; LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化带头结点的空单链表函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    L = (LNode *) <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(LNode)); <span class="comment">// 分配一个头结点</span></span><br><span class="line">    <span class="keyword">if</span>(L == <span class="literal">NULL</span>)&#123; <span class="comment">// 内存不足，分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;next = L; <span class="comment">// 头结点next指向头结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断循环单链表是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next == L)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断结点p是否为循环单链表的表尾结点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isTail</span><span class="params">(LinkList L,LNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next == L)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="循环双链表"><a class="header-anchor" href="#循环双链表"></a>循环双链表</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化空的循环双链表</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitDLinkList</span><span class="params">(Dlinklist &amp;L)</span></span>&#123;</span><br><span class="line">    L = (DNode *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(DNode));</span><br><span class="line">    <span class="keyword">if</span>(L == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;prior = L;</span><br><span class="line">    L-&gt;next = L;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断循环双链表是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">(DLinkList L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next == L)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断结点p是否为循环双链表的表尾结点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isTail</span><span class="params">(DLinkList L,DNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next == L)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态链表"><a class="header-anchor" href="#静态链表"></a>静态链表</h3><p>静态链表借助数组来描述线性表的链式存储结构，结点也有数据域 data 和指针域 next，与前面所讲的链表中的指针不同的是，这里的指针是结点的相对地址（数组下标），又称游标。和顺序表一样，静态链表也要预先分配一块连续的内存空间。</p><p>静态链表结构类型的描述如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10  <span class="comment">// 静态链表的最大长度</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span>       <span class="comment">// 静态链表结构类型的定义</span></span><br><span class="line">    <span class="keyword">int</span> data;       <span class="comment">// 存储数据元素</span></span><br><span class="line">    <span class="keyword">int</span> next;       <span class="comment">// 下一个元素的数组下标</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>静态链表以 <code>next==-1</code> 作为其结束的标志。静态链表的插入、删除操作与动态链表的相同，只需要修改指针，而不需要移动元素。总体来说，静态链表没有单链表使用起来方便，但在一些不支持指针的高级语言（如Basic）中，这是一种非常巧妙的设计方法。</p><p>王道书中对静态链表定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10  <span class="comment">// 静态链表的最大长度</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span>       <span class="comment">// 静态链表结构类型的定义</span></span><br><span class="line">    <span class="keyword">int</span> data;       <span class="comment">// 存储数据元素</span></span><br><span class="line">    <span class="keyword">int</span> next;       <span class="comment">// 下一个元素的数组下标</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125; SLinkList[MaxSize];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testSLinkList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">x</span>;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size x = %d\n&quot;</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(x)); <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">a</span>[<span class="title">MaxSize</span>];</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size a = %d\n&quot;</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(a)); <span class="comment">// 80</span></span><br><span class="line"></span><br><span class="line">    SLinkList b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size b = %d\n&quot;</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(b));  <span class="comment">// 80</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">testSLinkList</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：增、删操作不需要大量移动元素</p><p>缺点：不能随机存取，只能从头结点开始依次往后查找；容量固定不可变</p><p>适用场景：不支持指针的语言；数据元素量固定不变的场景（如操作系统的文件分配表FAT）</p><h2 id="顺序表和链表的比较"><a class="header-anchor" href="#顺序表和链表的比较"></a>顺序表和链表的比较</h2><h3 id="逻辑结构与物理结构"><a class="header-anchor" href="#逻辑结构与物理结构"></a>逻辑结构与物理结构</h3><ul><li><p>采用顺序存储时，逻辑上相邻的元素，对应的物理存储位置也相邻。</p></li><li><p>采用链式存储时，逻辑上相邻的元素，物理存储位置则不一定相邻，对应的逻辑关系是通过指针链接来表示的。</p></li></ul><h3 id="存取（读写）方式"><a class="header-anchor" href="#存取（读写）方式"></a>存取（读写）方式</h3><p>顺序表可以顺序存取，也可以随机存取，链表只能从表头顺序存取元素。</p><p>例如在第 $i$ 个位置上执行存或取的操作，顺序表仅需一次访问，而链表则需从表头开始依次访问 $i$ 次。</p><h3 id="查找、插入和删除操作"><a class="header-anchor" href="#查找、插入和删除操作"></a>查找、插入和删除操作</h3><p>对于按值查找，顺序表无序时，两者的时间复杂度均为 $O(n)$ ；顺序表有序时，可采用折半查找，此时的时间复杂度为 $O(log_2n)$ 。</p><p>对于按序号查找，顺序表支持随机访问，时间复杂度仅为 $O(1)$ ，而链表的平均时间复杂度为 $O(n)$ 。</p><p>顺序表的插入、删除操作，平均需要移动半个表长的元素。链表的插入、删除操作，只需修改相关结点的指针域即可。</p><p>由于链表的每个结点都带有指针域，故而存储密度不够大。</p><h3 id="空间分配"><a class="header-anchor" href="#空间分配"></a>空间分配</h3><p>顺序存储在静态存储分配情形下，一旦存储空间装满就不能扩充，若再加入新元素，则会出<br>现内存溢出，因此需要预先分配足够大的存储空间。</p><p>预先分配过大，可能会导致顺序表后部大量闲置；预先分配过小，又会造成溢出。动态存储分配虽然存储空间可以扩充，但需要移动大量元素，导致操作效率降低，而且若内存中没有更大块的连续存储空间，则会导致分配失败。</p><p>链式存储的结点空间只在需要时申请分配，只要内存有空间就可以分配，操作灵活、高效。</p><h3 id="实际中选取存储结构"><a class="header-anchor" href="#实际中选取存储结构"></a>实际中选取存储结构</h3><h4 id="基于存储的考虑"><a class="header-anchor" href="#基于存储的考虑"></a>基于存储的考虑</h4><p>难以估计线性表的长度或存储规模时，不宜采用顺序表;链表不用事先估计存储规模，但链表的存储密度较低，显然链式存储结构的存储密度是小于 1 的。</p><h4 id="基于运算的考虑"><a class="header-anchor" href="#基于运算的考虑"></a>基于运算的考虑</h4><p>在顺序表中按序号访问 $a_1$ 的时间复杂度为 $O(1)$ ，而链表中按序号访问的时间复杂度为 $O(n)$，因此若经常做的运算是按序号访问数据元素，则显然顺序表优于链表。</p><p>在顺序表中进行插入、删除操作时，平均移动表中一半的元素，当数据元素的信息量较大且<br>表较长时，这一点是不应忽视的；在链表中进行插入、删除操作时，虽然也要找插入位置，但操作主要是比较操作，从这个角度考虑显然后者优于前者。</p><h3 id="基于环境的考虑"><a class="header-anchor" href="#基于环境的考虑"></a>基于环境的考虑</h3><p>顺序表容易实现，任何高级语言中都有数组类型；链表的操作是基于指针的，相对来讲，前者实现较为简单，这也是用户考虑的一个因素。</p><p>总之，两种存储结构各有长短，选择哪一种由实际问题的主要因素决定。通常较稳定的线性表选择顺序存储，而频繁进行插入、删除操作的线性表（即动态性较强）宜选择链式存储。</p>]]></content>
    
    
    <summary type="html">线性表是考研命题的重点。</summary>
    
    
    
    <category term="数据结构" scheme="http://halo123.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构——绪论</title>
    <link href="http://halo123.top/2021/04/27/DataStructure/A_Introduction/"/>
    <id>http://halo123.top/2021/04/27/DataStructure/A_Introduction/</id>
    <published>2021-04-27T05:57:51.000Z</published>
    <updated>2021-04-27T05:57:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考资料：《王道2021年数据结构》、《王道2022年数据结构》</p><p>考纲内容：</p><ul><li>数据结构相关的概念和术语</li><li>数据结构的三要素：逻辑结构、物理结构和数据运算</li><li>算法时间复杂度和空间复杂度的分析与计算</li></ul><p>知识框架【<a href="http://naotu.baidu.com/file/31bf2da9f8174f5094142a42bc93407d?token=ac53487f0f7b5d19">百度脑图链接</a>】：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-mind-map-a@master/DataStructure/%E7%BB%AA%E8%AE%BA.svg" alt="绪论"></p><h2 id="数据结构的基本概念"><a class="header-anchor" href="#数据结构的基本概念"></a>数据结构的基本概念</h2><h3 id="基本概念和术语"><a class="header-anchor" href="#基本概念和术语"></a>基本概念和术语</h3><h4 id="数据"><a class="header-anchor" href="#数据"></a>数据</h4><p>数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。数据是计算机程序加工的原料。</p><h4 id="数据元素"><a class="header-anchor" href="#数据元素"></a>数据元素</h4><p>数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。一个数据元素可由若干<font color="#ea66a6">数据项</font>组成，数据项是构成数据元素的不可分割的最小单位。例如，学生记录就是一个数据元素，它由学号、姓名、性别等数据项组成。</p><h4 id="数据对象"><a class="header-anchor" href="#数据对象"></a>数据对象</h4><p><font color="#ea66a6">数据对象</font>是具有<wavy>相同性质</wavy>的数据元素的集合，是数据的一个子集。例如，整数数据对象是集合 $N=\left \{ 0,\pm 1,\pm 2,\cdots   \right \} $。</p><h4 id="数据类型"><a class="header-anchor" href="#数据类型"></a>数据类型</h4><p>数据类型是一个值的集合和定义在此集合上的一组操作的总称。</p><ol><li><font color="#ea66a6">原子类型</font>。其值不可再分的数据类型。</li><li><font color="#ea66a6">结构类型</font>。其值可以再分解为若干成分（分量）的数据类型。</li><li><font color="#ea66a6">抽象数据类型</font>。抽象数据组织及与之相关的操作。</li></ol><h4 id="数据结构"><a class="header-anchor" href="#数据结构"></a>数据结构</h4><p><font color="#ea66a6">数据结构</font>是相互之间存在<wavy>一种或多种特定关系</wavy>的数据元素的集合。在任何问题中，数据元素都不是孤立存在的，它们之间存在某种关系，这种数据元素相互之间的关系称为结构（Structure）。数据结构包括三方面的内容：<wavy>逻辑结构</wavy>、<wavy>存储结构</wavy>和<wavy>数据的运算</wavy>。</p><p>数据的逻辑结构和存储结构是密不可分的两个方面，一个算法的设计取决于所选定的逻辑结构，而算法的实现依赖于所采用的存储结构。</p><h3 id="数据结构三要素"><a class="header-anchor" href="#数据结构三要素"></a>数据结构三要素</h3><h4 id="数据的逻辑结构"><a class="header-anchor" href="#数据的逻辑结构"></a>数据的逻辑结构</h4><p><font color="#ea66a6">逻辑结构</font>是指数据元素之间的逻辑关系，即从逻辑关系上描述数据。它与数据的存储无关，是独立于计算机的。数据的逻辑结构分为线性结构和非线性结构，线性表是典型的线性结构；集合、树和图是典型的非线性结构。数据的逻辑结构分类如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-mind-map-a@master/DataStructure/%E6%95%B0%E6%8D%AE%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84.1x5hbujljy9s.svg" alt="数据逻辑结构"></p><ul><li>集合。结构中的数据元素之间除“同属一个集合”外，别无其他关系。</li><li>线性结构。结构中的数据元素之间只存在一对一的关系。</li><li>树形结构。结构中的数据元素之间存在一对多的关系。</li><li>图状结构或网状结构。结构中的数据元素之间存在多对多的关系。</li></ul><h4 id="数据的存储结构"><a class="header-anchor" href="#数据的存储结构"></a>数据的存储结构</h4><p><font color="#ea66a6">存储结构</font>是指数据结构在计算机中的表示（又称映像），也称物理结构。它包括数据元素的表示和关系的表示。数据的存储结构是用计算机语言实现的逻辑结构，它依赖于计算机语言。数据的存储结构主要有顺序存储、链式存储、索引存储和散列存储。</p><ul><li><font color="#ea66a6">顺序存储</font>。把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。<ul><li>优点是可以实现随机存取，每个元素占用最少的存储空间；</li><li>缺点是只能使用相邻的一整块存储单元，因此可能产生较多的外部碎片。</li></ul></li><li><font color="#ea66a6">链式存储</font>。不要求逻辑上相邻的元素在物理位置上也相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系。<ul><li>优点是不会出现碎片现象，能充分利用所有存储单元；</li><li>缺点个元素因存储指针而占用额外的存储空间，且只能实现顺序存取。</li></ul></li><li><font color="#ea66a6">索引存储</font>。在存储元素信息的同时，还建立附加的索引表。索引表中的每项称为索引项，索引项的一般形式是（关键字，地址）。<ul><li>优点是检索速度快；</li><li>缺点是附加的索引表额外占用存储空间。另外，增加和删除数据时也要修改索引表，因而会花费较多的时间。</li></ul></li><li><font color="#ea66a6">散列存储</font>。根据元素的关键字直接计算出该元素的存储地址，又称哈希（Hash）存储。<ul><li>优点是检索、增加和删除结点的操作都很快；</li><li>缺点是若散列函数不好，则可能出现元素存储单元的冲突，而解决冲突会增加时间和空间开销。</li></ul></li></ul><h4 id="数据的运算"><a class="header-anchor" href="#数据的运算"></a>数据的运算</h4><p>施加在数据上的运算包括运算的定义和实现。运算的定义是针对逻辑结构的，指出运算的功能；运算的实现是针对存储结构的，指出运算的具体操作步骤。</p><h2 id="算法和算法评价"><a class="header-anchor" href="#算法和算法评价"></a>算法和算法评价</h2><h3 id="算法的基本概念"><a class="header-anchor" href="#算法的基本概念"></a>算法的基本概念</h3><p>算法（Algorithm）是对特定问题求解步骤的一种描述，它是指令的有限序列，其中的每条指令表示一个或多个操作。此外，一个算法还具有下列5个重要特性：</p><ol><li>有穷性。一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。</li><li>确定性。算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出。</li><li>可行性。算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。</li><li>输入。一个算法有零个或多个输入，这些输入取自于某个特定的对象的集合。</li><li>输出。一个算法有一个或多个输出，这些输出是与输入有着某种特定关系的量。</li></ol><p>通常，设计一个“好”的算法应考虑达到以下目标：</p><ol><li>正确性。算法应能够正确地解决求解问题。</li><li>可读性。算法应具有良好的可读性，以帮助人们理解。</li><li>健壮性。输入非法数据时，算法能适当地做出反应或进行处理，而不会产生莫名其妙的输出结果。</li><li>效率与低存储量需求。效率是指算法执行的时间，存储量需求是指算法执行过程中所需要的最大存储空间，这两者都与问题的规模有关。</li></ol><h3 id="算法效率的度量"><a class="header-anchor" href="#算法效率的度量"></a>算法效率的度量</h3><p>算法效率的度量是通过时间复杂度和 空间复杂度来描述的。</p><h4 id="时间复杂度"><a class="header-anchor" href="#时间复杂度"></a>时间复杂度</h4><p>一个语句的频度是指该语句在算法中被重复执行的次数。算法中所有语句的频度之和记为 $T(n)$ ，它是该算法问题规模 $n$ 的函数，时间复杂度主要分析 $T(n)$ 的<font color="#faa755">数量级</font>。算法中基本运算（最深层循环内的语句）的频度与 $T(n)$ 同数量级，因此通常采用算法中基本运算的频度 $f(n)$ 来分析算法的时间复杂度<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。因此，算法的时间复杂度记为: $$T(n)=O(f(n))$$式中，$O$的含义是$T(n)$的数量级，其严格的数学定义是：若 $T(n)$ 和 $f(n)$ 是定义在正整数集合上的两个函数，则存在正常数 $C$ 和 $n_0$ ,使得当 $n\ge n_0$ 时，都满足 $0 \le T(n) \le Cf(n)$ 。</p><p>算法的时间复杂度不仅依赖于问题的规模 $n$ ,也取决于待输入数据的性质（如输入数据元素的初始状态）。例如，在数组<code>A[0...n-1]</code>中，查找给定值 <code>k</code> 的算法大致如下：</p><ol><li><code>i = n-1;</code></li><li><code>while(i&gt;=0&amp;&amp;(A[i]!=k))</code></li><li><code>i--</code></li><li><code>return i;</code></li></ol><p>该算法中语句3（基本运算）的频度不仅与问题规模 $n$ 有关，而且与输入实例中<code>A</code>的各元素的取值及<code>k</code>的取值有关：</p><ul><li>若<code>A</code>中没有与<code>k</code>相等的元素，则语句3的频度 $f(n)=n$。</li><li>若 <code>A</code> 的最后一个元素等于 <code>k</code>，则语句3的频度 $f(n)$ 是常数 0。</li></ul><p><font color="#ea66a6">最坏时间复杂度</font>是指在最坏情况下，算法的时间复杂度。</p><p><font color="#ea66a6">平均时间复杂度</font>是指所有可能输入实例在等概率出现的情况下，算法的期望运行时间。</p><p><font color="#ea66a6">最好时间复杂度</font>是指在最好情况下，算法的时间复杂度。</p><p>一般总是考虑在最坏情况下的时间复杂度，以保证算法的运行时间不会比它更长。在分析一个程序的时间复杂性时，有以下两条规则：</p><ol><li>加法规则：$$T(n)=T_{1}(n)+T_{2}(n)=O(f(n))+O(g(n))=O(max(f(n),g(n)))$$</li><li>乘法规则：$$T(n)=T_{1}(n)\times  T_{2}(n)=O(f(n))\times O(g(n))=O(f(n)\times g(n))$$</li></ol><p>常见的渐进时间复杂度为$$O(1)&lt;O(log_{2}n)&lt;O(n)&lt;O(nlog_{2}n)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)$$</p><h4 id="空间复杂度"><a class="header-anchor" href="#空间复杂度"></a>空间复杂度</h4><p>算法的空间复杂度 $S(n)$ 定义为该算法所耗费的储存空间，它是问题规模 $n$ 的函数。记为：$$S(n)=O(g(n))$$一个程序在执行时除需要储存空间来存放本身所用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储一些为实现计算所需信息的辅助空间。若输入数据所占空间只取决于问题本身，和算法无关，则只需分析除输入和程序之外的额外空间。</p><blockquote><p>算法<font color="#ea66a6">原地工作</font>是指算法所需的辅助空间为常量，即 $O(1)$ 。</p></blockquote><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>取$f(n)$中随$n$增长最快的项，将其系数置为1作为时间复杂度的度量。例如，$f(n)=a{n}^{3}+b{n}^{2}+cn$的时间复杂度为$O({n}^{3})$。 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
    <summary type="html">描述</summary>
    
    
    
    <category term="数据结构" scheme="http://halo123.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>学习资源整理</title>
    <link href="http://halo123.top/2021/04/26/DataCollection/LearningResource/"/>
    <id>http://halo123.top/2021/04/26/DataCollection/LearningResource/</id>
    <published>2021-04-26T07:00:51.000Z</published>
    <updated>2021-05-10T12:04:50.321Z</updated>
    
    <content type="html"><![CDATA[<h2 id="课程学习计划"><a class="header-anchor" href="#课程学习计划"></a>课程学习计划</h2><h3 id="学习路线"><a class="header-anchor" href="#学习路线"></a>学习路线</h3><ul><li><a href="https://www.processon.com/view/link/60867464e401fd06e0b00d5e">前端学习路线</a></li><li><a href="https://www.processon.com/view/link/608677c85653bb2fcf8b46e3">Java后端学习路线</a></li><li><a href="https://github.com/ccloli/developer-roadmap-zh-CN">Web开发路线图中文</a></li></ul><h2 id="视频课程"><a class="header-anchor" href="#视频课程"></a>视频课程</h2><h3 id="基础课程"><a class="header-anchor" href="#基础课程"></a>基础课程</h3><ul><li><a href="https://www.bilibili.com/video/BV1EW411u7th">计算机科学速成课</a></li><li><a href="https://www.bilibili.com/video/BV1YE411D7nH">操作系统</a></li><li><a href="https://www.bilibili.com/video/BV1BE411D7ii">计算机组成原理</a></li><li><a href="https://www.bilibili.com/video/BV1b7411N798">数据结构</a></li><li><a href="https://www.bilibili.com/video/BV19E411D78Q">计算机网络</a></li><li><a href="https://www.bilibili.com/video/BV1aW411Q7x1">线性代数</a></li><li><a href="https://www.bilibili.com/video/BV1Eb411u7Fw">高等数学</a></li></ul><h3 id="后端技术课程"><a class="header-anchor" href="#后端技术课程"></a>后端技术课程</h3><ul><li><a href="https://www.bilibili.com/video/BV1G4411c7N4">设计模式(Java演示)</a></li><li><a href="https://www.bilibili.com/video/BV1gE411A7H8">ArrayList原理</a></li><li><a href="https://www.bilibili.com/video/BV1TE41177mP">Java核心编程思想</a></li></ul><h3 id="前端技术课程"><a class="header-anchor" href="#前端技术课程"></a>前端技术课程</h3><ul><li><a href="https://www.bilibili.com/video/BV1pE411q7FU">前端入门</a></li><li><a href="https://www.bilibili.com/video/BV1ux411d75J">JavaScript</a></li><li><a href="https://www.bilibili.com/video/BV1k4411w7sV">Js DOM BOM</a></li><li><a href="https://www.bilibili.com/video/BV1a4411w7Gx">jQuery</a></li><li><a href="https://www.bilibili.com/video/BV1YW411T7yy">Bootstrap</a></li><li><a href="https://www.bilibili.com/video/BV1YW411T7vd">less</a></li><li><a href="https://www.bilibili.com/video/BV18s411E7T5">Gulp</a></li><li><a href="https://www.bilibili.com/video/BV1VZ4y1M7ZC">ECharts</a></li><li><a href="https://www.bilibili.com/video/BV1ox411M7P2">Ajax上</a></li><li><a href="https://www.bilibili.com/video/BV15x411E7xH">Ajax下</a></li><li><a href="https://www.bilibili.com/video/BV19t411Q768">Node.js</a></li><li><a href="https://www.bilibili.com/video/BV14Z4y1u7pi">TypeScript</a></li><li><a href="https://www.bilibili.com/video/BV1wy4y1D7JT">React</a></li></ul><h3 id="深度学习"><a class="header-anchor" href="#深度学习"></a>深度学习</h3><ul><li><a href="https://www.bilibili.com/video/BV164411b7dx">吴恩达机器学习系列课程</a></li><li><a href="https://www.bilibili.com/video/BV1FT4y1E74V">吴恩达深度学习</a></li><li><a href="https://www.bilibili.com/video/BV1Rv411y7oE">Pytorch</a></li></ul><h2 id="技术书单"><a class="header-anchor" href="#技术书单"></a>技术书单</h2><ul><li><a href="https://book.douban.com/subject/35175321/">JavaScript高级程序设计 第4版</a></li><li><a href="https://book.douban.com/subject/26346017/">Java 8函数式编程</a></li></ul><h2 id="技术文章博客"><a class="header-anchor" href="#技术文章博客"></a>技术文章博客</h2><ul><li><a href="http://hollischuang.gitee.io/tobetopjavaer/#/">Java工程师成神之路</a></li><li><a href="https://github.com/ruanyf/weekly">科技爱好者周刊</a></li><li><a href="https://github.com/mqyqingfeng/Blog">前端冴羽的博客</a></li></ul><h2 id="项目学习计划"><a class="header-anchor" href="#项目学习计划"></a>项目学习计划</h2><ul><li><a href="https://www.bilibili.com/video/BV1dQ4y1A75e">谷粒学院</a></li><li><a href="https://www.bilibili.com/video/BV1np4y1C7Yf">谷粒商城</a></li></ul><h3 id="电商项目"><a class="header-anchor" href="#电商项目"></a>电商项目</h3><ul><li><a href="http://www.macrozheng.com/#/">mall</a></li></ul><h3 id="博客项目"><a class="header-anchor" href="#博客项目"></a>博客项目</h3><ul><li><a href="https://github.com/halo-dev/halo">halo</a></li><li><a href="https://docs.halo.run/">halo项目文档</a></li><li><a href="https://gitee.com/moxi159753/mogu_blog_v2">蘑菇博客</a></li></ul><h3 id="后台管理系统"><a class="header-anchor" href="#后台管理系统"></a>后台管理系统</h3><ul><li><a href="https://github.com/elunez/eladmin">EL-ADMIN 后台管理系统</a></li></ul><h3 id="基础技术项目"><a class="header-anchor" href="#基础技术项目"></a>基础技术项目</h3><ul><li><a href="https://github.com/judasn/IntelliJ-IDEA-Tutorial">IntelliJ IDEA 简体中文专题教程</a></li><li><a href="https://github.com/iluwatar/java-design-patterns">Java设计模式</a></li><li><a href="https://github.com/hansonwang99/JavaCollection">Java自学编程之路CodeSheep</a></li><li><a href="https://github.com/xkcoding/spring-boot-demo">SpringBootDemo</a></li><li><a href="https://github.com/jackzhenguo/python-small-examples">Python小例子</a></li><li><a href="https://github.com/MLEveryday/100-Days-Of-ML-Code">机器学习100天</a></li><li><a href="https://github.com/Snailclimb/JavaGuide">JavaGuide</a></li><li><a href="https://github.com/0voice/interview_internal_reference">大厂面试题</a></li><li><a href="https://github.com/kon9chunkit/GitHub-Chinese-Top-Charts">GitHub中文排行榜</a></li><li><a href="https://github.com/521xueweihan/HelloGitHub">HelloGitHub</a></li></ul><h3 id="大学课程共享"><a class="header-anchor" href="#大学课程共享"></a>大学课程共享</h3><ul><li><a href="https://github.com/QSCTech/zju-icicles">浙江大学课程攻略共享计划</a></li><li><a href="https://github.com/PKUanonym/REKCARC-TSC-UHT">清华大学计算机系课程攻略</a></li><li><a href="https://github.com/lib-pku/libpku">北京大学课程资料民间整理</a></li><li><a href="https://github.com/USTC-Resource/USTC-Course">中国科学技术大学课程资源</a></li><li><a href="https://github.com/c-hj/SJTU-Courses">上海交通大学课程资源分享</a></li><li><a href="https://www.yuque.com/0xffff.one/cs-learning/intro">华南师范大学0xFFFF CS </a></li></ul><h3 id="Web学习资源"><a class="header-anchor" href="#Web学习资源"></a>Web学习资源</h3><ul><li><a href="https://github.com/sindresorhus/awesome">Web开发使用到的库</a></li><li><a href="https://github.com/bmorelli25/Become-A-Full-Stack-Web-Developer">成为Web全栈工程师</a></li><li><a href="https://github.com/dexteryy/spellbook-of-modern-webdev">现代Web开发魔法全书</a></li></ul><h3 id="前端GitHub学习资源"><a class="header-anchor" href="#前端GitHub学习资源"></a>前端GitHub学习资源</h3><ul><li><a href="https://github.com/trekhleb/javascript-algorithms">javascript-algorithms</a>（基于javascript的算法和数据结构）</li><li><a href="https://github.com/goldbergyoni/nodebestpractices">nodebestpractices</a>（Node.js最佳实践）</li><li><a href="https://github.com/getify/You-Dont-Know-JS">You-Dont-Know-JS</a>（你不知道的js这本书的开源版本）</li><li><a href="https://github.com/ryanmcdermott/clean-code-javascript">clean-code-javascript</a>（教你如何写出更好可读性的js代码）</li><li><a href="https://github.com/30-seconds/30-seconds-of-code">30-seconds-of-code</a>（开发时常用的简短代码）</li><li><a href="https://github.com/30-seconds/30-seconds-of-css">30-seconds-of-css</a></li></ul><p>注：github后面加1s进入VScodeWeb可以更好的阅读代码，例如：<a href="https://github1s.com/trekhleb/javascript-algorithms">https://github1s.com/trekhleb/javascript-algorithms</a></p><h3 id="算法Github学习资源"><a class="header-anchor" href="#算法Github学习资源"></a>算法Github学习资源</h3><ul><li><a href="https://github.com/TheAlgorithms/Python">TheAlgorithms/Python</a>（Python 实现算法）</li><li><a href="https://github.com/TheAlgorithms/Java">TheAlgorithms/Java</a>（Java 实现算法）</li><li><a href="https://github.com/wangzheng0822/algo">数据结构和算法必知必会的50个代码实现</a></li><li><a href="https://github.com/halfrost/LeetCode-Go">LeetCode题解Go语言实现</a></li><li><a href="https://github.com/youngyangyang04/leetcode-master">LeetCode「代码随想录」</a></li></ul><h2 id="在线工具网站"><a class="header-anchor" href="#在线工具网站"></a>在线工具网站</h2><blockquote><p>以下内容来自<a href="https://www.bilibili.com/video/BV1L64y1i7HY">CodeSheep</a>，浏览器书签导入文件：<a href="https://pan.baidu.com/s/1wtK-xsEHZoEWx-eo_rX_aQ">百度云盘</a>【提取码：3chy】</p></blockquote><h3 id="画图工具"><a class="header-anchor" href="#画图工具"></a>画图工具</h3><ul><li><a href="https://www.processon.com/">在线画图工具ProcessOn</a></li><li><a href="https://app.diagrams.net/">在线画图工具draw.io</a></li><li><a href="http://www.mindline.cn/webapp">在线思维导图工具</a></li><li><a href="http://haha98k.com/">PlantUML在线编辑器</a></li></ul><h3 id="开发辅助工具"><a class="header-anchor" href="#开发辅助工具"></a>开发辅助工具</h3><h4 id="在线编解码工具"><a class="header-anchor" href="#在线编解码工具"></a>在线编解码工具</h4><ul><li><a href="https://base64.supfree.net/">BASE64加密解密</a></li><li><a href="https://www.zxgj.cn/g/md5">MD5编码工具</a></li><li><a href="http://www.fly63.com/tool/cipher/">AES/DES加解密</a></li><li><a href="http://jwt.calebb.net/">JWT解码工具</a></li><li><a href="https://www.matools.com/code-convert-ascii">ASCII编解码工具</a></li><li><a href="https://www.zxgj.cn/g/unicode">Unicode编解码工具</a></li><li><a href="https://www.zxgj.cn/g/utf8">UTF-8编解码工具</a></li><li><a href="https://www.zxgj.cn/g/enstring">字符串编解码工具</a></li><li><a href="http://tool.chinaz.com/tools/urlencode.aspx?jdfwkey=lbixz1">URL编解码工具</a></li></ul><h4 id="在线转换工具"><a class="header-anchor" href="#在线转换工具"></a>在线转换工具</h4><ul><li><a href="http://www.fly63.com/tool/ascii/">在线ASCII码对照表</a></li><li><a href="https://www.zxgj.cn/g/jinzhi">通用进制转换工具</a></li><li><a href="http://www.binaryconvert.com/">在线浮点数十进制转换</a></li><li><a href="https://www.zxgj.cn/g/yansezhi">RGB颜色转换</a></li><li><a href="https://www.zxgj.cn/g/unix">时间戳转换工具</a></li><li><a href="http://www.fly63.com/tool/unitable/">计量单位换算工具</a></li><li><a href="http://www.json.cn/">在线JSON解析</a></li><li><a href="https://prettier.io/playground/">在线JS代码格式化工具</a></li><li><a href="https://www.zxgj.cn/g/sqlformat">SQL压缩/格式化工具</a></li><li><a href="https://www.zxgj.cn/g/jsonxml">JSON和XML在线转换</a></li><li><a href="http://www.fly63.com/tool/jsonyaml/">JSON/YAML在线转换</a></li><li><a href="http://www.fly63.com/tool/renmingbi/">人民币大小写转换工具</a></li></ul><h4 id="正则表达式工具"><a class="header-anchor" href="#正则表达式工具"></a>正则表达式工具</h4><ul><li><a href="https://jex.im/regulex/#!flags=&amp;re=%5E(a%7Cb)*%3F%24">正则表达式可视化工具</a></li><li><a href="https://regexr.com/">正则表达式调试工具</a></li></ul><h4 id="网络工具"><a class="header-anchor" href="#网络工具"></a>网络工具</h4><ul><li><a href="https://www.ip138.com/">IP地址归属地查询</a></li><li><a href="https://www.ipip.net/ip.html">IP地址查询</a></li><li><a href="http://www.fly63.com/php/http/">HTTP在线接口测试工具</a></li></ul><h4 id="在线编译运行工具"><a class="header-anchor" href="#在线编译运行工具"></a>在线编译运行工具</h4><ul><li><a href="https://c.runoob.com/">在线编译工具套装</a></li><li><a href="http://jsrun.net/">在线编译工具 JSRun</a></li><li><a href="https://rextester.com/">C#在线编译运行</a></li><li><a href="https://www.onlinegdb.com/">C/C–在线编译调试</a></li></ul><h4 id="可视化-格式化工具"><a class="header-anchor" href="#可视化-格式化工具"></a>可视化/格式化工具</h4><ul><li><a href="https://animpen.com/">在线前端编辑器 AnimPen</a></li><li><a href="https://codepen.io/">在线前端编辑器 CodePen</a></li><li><a href="https://flourish.studio/">在线数据可视化</a></li><li><a href="https://enjoycss.com/">在线CSS代码可视化工具</a></li><li><a href="https://www.zxgj.cn/g/xmlformat">XML格式化工具</a></li></ul><h4 id="在线生成器"><a class="header-anchor" href="#在线生成器"></a>在线生成器</h4><ul><li><a href="https://www.zxgj.cn/g/uuid">UUID在线生成器</a></li><li><a href="https://www.zxgj.cn/g/suijishu">随机数生成器</a></li></ul><h4 id="其他常用工具"><a class="header-anchor" href="#其他常用工具"></a>其他常用工具</h4><ul><li><a href="https://www.digitalocean.com/community/tools/nginx#?">在线Nginx配置工具</a></li><li><a href="http://www.fly63.com/tool/textdiff/">在线对比工具</a></li><li><a href="https://www.crx4chrome.com/">在线Chrome浏览器插件</a></li><li><a href="http://www.docway.net/">在线接口文档管理工具</a></li></ul><h3 id="在线素材库"><a class="header-anchor" href="#在线素材库"></a>在线素材库</h3><ul><li><a href="http://pngimg.com/">免费透明背景图片素材</a></li><li><a href="https://emoji.svend.cc/">Emoji表情搜索</a></li><li><a href="https://emojiisland.com/">Emoji表情包下载</a></li><li><a href="https://www.iconfinder.com/">ICON图标在线下载</a></li><li><a href="https://feathericons.com/">open source icons</a></li><li><a href="https://www.iconfont.cn/">阿里巴巴矢量图标库</a></li><li><a href="https://fabiaoqing.com/">表情包在线网站</a></li><li><a href="https://bz.zzzmh.cn/">极简壁纸</a></li><li><a href="https://wall.alphacoders.com/">Wallpaper Abyss壁纸</a></li><li><a href="https://pluspng.com/">免费PNG图片库</a></li><li><a href="https://pixabay.com/zh/">Pixabay图片素材库</a></li><li><a href="https://unsplash.com/">Unsplash图片素材库</a></li><li><a href="http://www.pexels.com/">Pexels图片素材库</a></li><li><a href="https://images.nasa.gov/">NASA图片视频素材库</a></li></ul><h3 id="设计制作类工具"><a class="header-anchor" href="#设计制作类工具"></a>设计制作类工具</h3><ul><li><a href="https://www.uupoop.com/#/old">在线PS</a></li><li><a href="https://www.weixinsyt.com/">在线音频剪辑</a></li><li><a href="https://www.kapwing.com/">在线视频剪辑</a></li><li><a href="http://www.uugai.com/">免费logo在线制作</a></li><li><a href="https://www.qt86.com/">艺术字体在线生成</a></li><li><a href="https://tableconvert.com/">在线表格转换工具</a></li><li><a href="https://www.designcap.com/">在线海报设计工具</a></li><li><a href="https://bigjpg.com/">图片智能放大工具</a></li><li><a href="https://mh.cli.im/">二维码美化器</a></li><li><a href="https://carbon.now.sh/">在线代码截图工具</a></li><li><a href="https://www.remove.bg/zh">在线抠图工具</a></li><li><a href="http://www.fly63.com/php/ico/">ICO图标在线生成</a></li><li><a href="http://www.fly63.com/tool/svg2img/">SVG转PNG工具</a></li><li><a href="http://www.fly63.com/tool/giftxt/">视频转GIF工具</a></li><li><a href="http://www.fly63.com/tool/ewm/">二维码在线生成器</a></li><li><a href="http://www.fly63.com/php/decoder/">二维码在线解码</a></li></ul><h3 id="写作辅助工具"><a class="header-anchor" href="#写作辅助工具"></a>写作辅助工具</h3><ul><li><a href="https://www.eteste.com/">在线字数统计</a></li><li><a href="https://mdnice.com/">mdnice markdown排版工具</a></li><li><a href="http://md.aclickall.com/">md2all markdown排版工具</a></li><li><a href="https://picx.xpoet.cn/">图片上传 | PicX 图床神器</a></li><li><a href="https://sm.ms/">在线免费图床</a></li><li><a href="https://imgkr.com/">图壳图床</a></li><li><a href="https://urlify.cn/">在线短链接工具</a></li><li><a href="http://www.fly63.com/tool/textreplace/">在线文本替换</a></li></ul><h3 id="在线办公工具"><a class="header-anchor" href="#在线办公工具"></a>在线办公工具</h3><ul><li><a href="https://tools.pdf24.org/zh/">pdf在线处理套装1</a></li><li><a href="https://smallpdf.com/cn/pdf-tools">pdf在线处理套装2</a></li><li><a href="https://cn.office-converter.com/">在线多媒体转换器合集</a></li><li><a href="https://ocr.wdku.net/">在线文字识别工具</a></li><li><a href="https://docsmall.com/">在线文件压缩工具</a></li></ul><h3 id="文档笔记工具"><a class="header-anchor" href="#文档笔记工具"></a>文档笔记工具</h3><ul><li><a href="https://www.yinxiang.com/">印象笔记</a></li><li><a href="https://note.youdao.com/">有道笔记</a></li><li><a href="https://www.onenote.com/">OneNote</a></li><li><a href="https://mubu.com/">幕布</a></li><li><a href="https://www.wiz.cn/">为知笔记</a></li><li><a href="https://shimo.im/">石墨文档</a></li><li><a href="https://simplenote.com/">Simplenote</a></li><li><a href="https://www.yuque.com/">语雀</a></li></ul><h3 id="在线编程学习"><a class="header-anchor" href="#在线编程学习"></a>在线编程学习</h3><ul><li><a href="https://www.bilibili.com/">哔哩哔哩</a></li><li><a href="https://www.dotcpp.com/">C语言网</a></li><li><a href="https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5">cppreference</a></li><li><a href="https://www.icourse163.org/">中国大学MOOC</a></li><li><a href="https://open.163.com/">网易公开课</a></li><li><a href="https://www.nowcoder.com/">牛客网</a></li><li><a href="https://codegym.cc/">CodeGym</a></li><li><a href="https://beginnersbook.com/">BeginnersBook</a></li><li><a href="http://www.javased.com/">JavaSED</a></li><li><a href="https://www.codecademy.com/">codecademy</a></li><li><a href="https://www.coursera.org/">Coursera</a></li><li><a href="https://stackoverflow.com/">StackOverFlow</a></li><li><a href="https://leetcode-cn.com/">LeetCode</a></li><li><a href="https://www.lintcode.com/">LintCode</a></li></ul><h3 id="在线教程和文档"><a class="header-anchor" href="#在线教程和文档"></a>在线教程和文档</h3><ul><li><a href="https://git-scm.com/book/zh/v2">Git中文教程</a></li><li><a href="http://svnbook.red-bean.com/nightly/zh/index.html">SVN中文手册</a></li><li><a href="https://jquery.cuishifeng.cn/">jQuery API中文文档</a></li><li><a href="https://www.nginx.cn/doc/index.html">Nginx中文文档</a></li><li><a href="https://kafka.apachecn.org/">Kafka中文文档</a></li><li><a href="https://mybatis.org/mybatis-3/zh/index.html">Mybatis中文文档</a></li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/">微信小程序官方文档</a></li><li><a href="http://nodejs.cn/learn/">Nodejs中文教程文档</a></li><li><a href="http://httpd.apache.org/docs/">Apache Web Server文档</a></li><li><a href="https://www.springcloud.cc/spring-reference.html">Spring文档中文版</a></li><li><a href="https://studygolang.com/pkgdoc">Golang标准库文档中文版</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/index.html">Java 8官方文档</a></li><li><a href="http://maven.apache.org/guides/">Maven官方文档</a></li><li><a href="http://tomcat.apache.org/tomcat-8.0-doc/index.html">Tomcat 8官方文档</a></li><li><a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/">Spring Boot官方文档</a></li><li><a href="https://www.rabbitmq.com/documentation.html">RabbitMQ官方文档</a></li><li><a href="http://rocketmq.apache.org/docs/quick-start/">RocketMQ官方文档</a></li><li><a href="https://dubbo.apache.org/zh/docs/">Dubbo中文文档</a></li><li><a href="https://netty.io/wiki/index.html">Netty官方文档</a></li><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html">Elasticsearch官方文档</a></li><li><a href="https://spring.io/projects/spring-cloud">Spring Cloud官方文档</a></li><li><a href="https://docs.docker.com/get-started/">Docker官方文档</a></li><li><a href="https://kubernetes.io/zh/docs/home/">kubernetes中文文档</a></li><li><a href="https://www.thymeleaf.org/documentation.html">thymeleaf官方文档</a></li><li><a href="https://cn.vuejs.org/v2/guide/">Vue.js中文文档</a></li><li><a href="https://reactjs.org/docs/getting-started.html">React.js官方文档</a></li><li><a href="https://www.jenkins.io/zh/doc/">Jenkins中文文档</a></li></ul><h2 id="资源下载"><a class="header-anchor" href="#资源下载"></a>资源下载</h2><h3 id="图书资源"><a class="header-anchor" href="#图书资源"></a>图书资源</h3><ul><li><a href="https://www.bookzz.ren/">Bookzz</a>（电子书下载网站）</li><li><a href="https://gitee.com/SnailClimb/awesome-cs">计算机优质书籍搜罗-学习路线推荐</a></li></ul>]]></content>
    
    
    <summary type="html">各种学习资源整理</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Flex布局</title>
    <link href="http://halo123.top/2021/04/24/WebFrontEnd/FlexLayout/"/>
    <id>http://halo123.top/2021/04/24/WebFrontEnd/FlexLayout/</id>
    <published>2021-04-24T15:59:51.000Z</published>
    <updated>2021-04-25T08:41:51.000Z</updated>
    
    <content type="html"><![CDATA[<details ><summary> 参考文章 </summary>              <div class='content'>              <div class="tag link"><a class="link-card" title="Flex布局语法教程——阮一峰" href="https://www.runoob.com/w3cnote/flex-grammar.html"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E7%BD%91%E7%AB%99.svg"/></div><div class="right"><p class="text">Flex布局语法教程——阮一峰</p><p class="url">https://www.runoob.com/w3cnote/flex-grammar.html</p></div></a></div><div class="tag link"><a class="link-card" title="flex 布局的基本概念——MDN教程" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E7%BD%91%E7%AB%99.svg"/></div><div class="right"><p class="text">flex 布局的基本概念——MDN教程</p><p class="url">https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox</p></div></a></div>              </div>            </details><h2 id="Flex布局是什么"><a class="header-anchor" href="#Flex布局是什么"></a>Flex布局是什么</h2><p>Flex 是 <code>Flexible Box</code> 的缩写，意为“弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>行内元素也可以使用 Flex 布局。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Webkit 内核的浏览器，必须加上<code>-webkit</code>前缀。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-flex; <span class="comment">/* Safari */</span></span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，设为 Flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效。</p><h2 id="基本概念"><a class="header-anchor" href="#基本概念"></a>基本概念</h2><p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称“<strong>容器</strong>”。</p><p>它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称“<strong>项目</strong>”。</p><p><img src="https://www.runoob.com/wp-content/uploads/2015/07/3791e575c48b3698be6a94ae1dbff79d.png" alt="Flex 布局"></p><p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做 main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。</p><p>项目默认沿主轴排列。单个项目占据的主轴空间叫做 main size，占据的交叉轴空间叫做 cross size。</p><h2 id="容器属性"><a class="header-anchor" href="#容器属性"></a>容器属性</h2><p>以下6个属性设置在容器上：</p><ul><li><a href="#flex-direction%E5%B1%9E%E6%80%A7">flex-direction</a></li><li><a href="#flex-wrap%E5%B1%9E%E6%80%A7">flex-wrap</a></li><li><a href="#flex-flow%E5%B1%9E%E6%80%A7">flex-flow</a></li><li><a href="#justify-content%E5%B1%9E%E6%80%A7">justify-content</a></li><li><a href="#align-items%E5%B1%9E%E6%80%A7">align-items</a></li><li><a href="#align-content%E5%B1%9E%E6%80%A7">align-content</a></li></ul><h3 id="flex-direction属性"><a class="header-anchor" href="#flex-direction属性"></a><code>flex-direction</code>属性</h3><p>flex-direction 属性决定主轴的方向（即项目的排列方向）。它可能有4个值：</p><ul><li>column-reverse：主轴为垂直方向，起点在下沿。</li><li>column：主轴为垂直方向，起点在上沿。</li><li>row（默认值）：主轴为水平方向，起点在左端。</li><li>row-reverse：主轴为水平方向，起点在右端。</li></ul><p><img src="https://www.runoob.com/wp-content/uploads/2015/07/0cbe5f8268121114e87d0546e53cda6e.png" alt="flex-direction 属性"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="flex-wrap属性"><a class="header-anchor" href="#flex-wrap属性"></a><code>flex-wrap</code>属性</h3><p>默认情况下，项目都排在一条线（又称“轴线”）上。flex-wrap 属性定义，如果一条轴线排不下，如何换行。</p><p><img src="https://www.runoob.com/wp-content/uploads/2015/07/903d5b7df55779c03f2687a7d4d6bcea.png" alt=""></p><p>它可能取三个值：</p><ul><li>nowrap（默认）：不换行</li><li>wrap：换行，第一行在上方</li><li>wrap-reverse：换行，第一行在下方</li></ul><p><img src="https://www.runoob.com/wp-content/uploads/2015/07/9da1f23965756568b4c6ea7124db7b9a.png" alt="nowrap"><br><img src="https://www.runoob.com/wp-content/uploads/2015/07/3c6b3c8b8fe5e26bca6fb57538cf72d9.jpg" alt="wrap"><br><img src="https://www.runoob.com/wp-content/uploads/2015/07/fb4cf2bab8b6b744b64f6d7a99cd577c.jpg" alt="wrap-reverse"></p><h3 id="flex-flow属性"><a class="header-anchor" href="#flex-flow属性"></a><code>flex-flow</code>属性</h3><p>flex-flow 属性是 flex-directio n属性和 flex-wrap 属性的简写形式，默认值为 row nowrap。</p><h3 id="justify-content属性"><a class="header-anchor" href="#justify-content属性"></a><code>justify-content</code>属性</h3><p>justify-content 属性定义了项目在主轴上的对齐方式。它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</p><ul><li>flex-start（默认值）：左对齐</li><li>flex-end：右对齐</li><li>center： 居中</li><li>space-between：两端对齐，项目之间的间隔都相等。</li><li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li></ul><p><img src="https://www.runoob.com/wp-content/uploads/2015/07/c55dfe8e3422458b50e985552ef13ba5.png" alt="justify-content 属性"></p><h3 id="align-items属性"><a class="header-anchor" href="#align-items属性"></a><code>align-items</code>属性</h3><p>align-items 属性定义项目在交叉轴上如何对齐。它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下：</p><ul><li>flex-start：交叉轴的起点对齐。</li><li>flex-end：交叉轴的终点对齐。</li><li>center：交叉轴的中点对齐。</li><li>baseline: 项目的第一行文字的基线对齐。</li><li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li></ul><p><img src="https://www.runoob.com/wp-content/uploads/2015/07/2b0c39c7e7a80d5a784c8c2ca63cde17.png" alt="align-items 属性"></p><h3 id="align-content属性"><a class="header-anchor" href="#align-content属性"></a><code>align-content</code>属性</h3><p>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。该属性可能取6个值：</p><ul><li>flex-start：与交叉轴的起点对齐。</li><li>flex-end：与交叉轴的终点对齐。</li><li>center：与交叉轴的中点对齐。</li><li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li><li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li><li>stretch（默认值）：轴线占满整个交叉轴。</li></ul><p><img src="https://www.runoob.com/wp-content/uploads/2015/07/f10918ccb8a13247c9d47715a2bd2c33.png" alt="align-content属性"></p><h2 id="项目属性"><a class="header-anchor" href="#项目属性"></a>项目属性</h2><p>以下6个属性设置在项目上：</p><ul><li><a href="#order%E5%B1%9E%E6%80%A7">order</a></li><li><a href="#flex-grow%E5%B1%9E%E6%80%A7">flex-grow</a></li><li><a href="#flex-shrink%E5%B1%9E%E6%80%A7">flex-shrink</a></li><li><a href="#flex-basis%E5%B1%9E%E6%80%A7">flex-basis</a></li><li><a href="#flex-basis%E5%B1%9E%E6%80%A7">flex</a></li><li><a href="#flex-basis%E5%B1%9E%E6%80%A7">align-self</a></li></ul><h3 id="order属性"><a class="header-anchor" href="#order属性"></a><code>order</code>属性</h3><p>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: &lt;integer&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.runoob.com/wp-content/uploads/2015/07/59e399c72daafcfcc20ede36bf32f266.png" alt="order 属性"></p><h3 id="flex-grow属性"><a class="header-anchor" href="#flex-grow属性"></a><code>flex-grow</code>属性</h3><p>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: &lt;number&gt;; <span class="comment">/* default 0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.runoob.com/wp-content/uploads/2015/07/f41c08bb35962ed79e7686f735d6cd78.png" alt="flex-grow 属性"></p><p>如果所有项目的 flex-grow 属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的 flex-grow 属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p><h3 id="flex-shrink属性"><a class="header-anchor" href="#flex-shrink属性"></a><code>flex-shrink</code>属性</h3><p>flex-shrink 属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: &lt;number&gt;; <span class="comment">/* default 1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.runoob.com/wp-content/uploads/2015/07/240d3e960043a729bb3ff5e34987904f.jpg" alt="flex-shrink 属性"></p><p>如果所有项目的 flex-shrink 属性都为1，当空间不足时，都将等比例缩小。如果一个项目的 flex-shrink 属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。</p><h3 id="flex-basis属性"><a class="header-anchor" href="#flex-basis属性"></a><code>flex-basis</code>属性</h3><p>flex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-basis</span>: &lt;length&gt; | auto; <span class="comment">/* default auto */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它可以设为跟 width 或 height 属性一样的值（比如350px），则项目将占据固定空间。</p><h3 id="flex属性"><a class="header-anchor" href="#flex属性"></a><code>flex</code>属性</h3><p>flex 属性是 flex-grow, flex-shrink 和 flex-basis 的简写，默认值为0 1 auto。后两个属性可选。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: none | [ &lt;<span class="string">&#x27;flex-grow&#x27;</span>&gt; &lt;<span class="string">&#x27;flex-shrink&#x27;</span>&gt;? || &lt;<span class="string">&#x27;flex-basis&#x27;</span>&gt; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。</p><p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p><h3 id="align-self属性"><a class="header-anchor" href="#align-self属性"></a><code>align-self</code>属性</h3><p>align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。默认值为 auto，表示继承父元素的align-items 属性，如果没有父元素，则等同于 stretch。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该属性可能取6个值，除了auto，其他都与 align-items 属性完全一致。</p><p><img src="https://www.runoob.com/wp-content/uploads/2015/07/55b19171b8b6b9487d717bf2ecbba6de.png" alt="align-self 属性"></p>]]></content>
    
    
    <summary type="html">Flex布局，可以简便、完整、响应式地实现各种页面布局</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>文本样式测试</title>
    <link href="http://halo123.top/2021/04/24/Blog/%E6%96%87%E6%9C%AC%E6%A0%B7%E5%BC%8F%E6%B5%8B%E8%AF%95/"/>
    <id>http://halo123.top/2021/04/24/Blog/%E6%96%87%E6%9C%AC%E6%A0%B7%E5%BC%8F%E6%B5%8B%E8%AF%95/</id>
    <published>2021-04-24T03:04:20.000Z</published>
    <updated>2021-05-04T07:12:53.848Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>该文章参考自 Akilar 的 《<a href="https://akilar.top/posts/615e2dec/">基于 Butterfly 的外挂标签引入</a>》，通过整理，便于个人相关样式开发</p></blockquote><h2 id="分栏"><a class="header-anchor" href="#分栏"></a>分栏</h2><h3 id="预设选择第一个-默认"><a class="header-anchor" href="#预设选择第一个-默认"></a>预设选择第一个(默认)</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">样式示例</button></li><li class="tab"><button type="button" data-href="#分栏-2">对应源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><div class="tabs" id="默认名称"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#默认名称-1">默认名称 1</button></li><li class="tab"><button type="button" data-href="#默认名称-2">默认名称 2</button></li><li class="tab"><button type="button" data-href="#默认名称-3">默认名称 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="默认名称-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="默认名称-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="默认名称-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs %&#125;</span><br><span class="line">&lt;!-- tab 默认名称 --&gt;</span><br><span class="line">**This is Tab 1.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**This is Tab 2.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**This is Tab 3.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="预设指定选择"><a class="header-anchor" href="#预设指定选择"></a>预设指定选择</h3><div class="tabs" id="预设指定选择"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#预设指定选择-1">样式示例</button></li><li class="tab"><button type="button" data-href="#预设指定选择-2">对应源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="预设指定选择-1"><div class="tabs" id="默认名称"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#默认名称-1">分栏1</button></li><li class="tab active"><button type="button" data-href="#默认名称-2">分栏2</button></li><li class="tab"><button type="button" data-href="#默认名称-3">分栏3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="默认名称-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content active" id="默认名称-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="默认名称-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="预设指定选择-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs 默认名称, 2 %&#125;</span><br><span class="line">&lt;!-- tab 分栏1 --&gt;</span><br><span class="line">**This is Tab 1.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 分栏2 --&gt;</span><br><span class="line">**This is Tab 2.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 分栏3 --&gt;</span><br><span class="line">**This is Tab 3.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="行内文本样式"><a class="header-anchor" href="#行内文本样式"></a>行内文本样式</h2><div class="tabs" id="行内文本样式"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#行内文本样式-1">样式示例</button></li><li class="tab"><button type="button" data-href="#行内文本样式-2">对应源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="行内文本样式-1"><ul><li><u>文本内容</u></li><li><emp>文本内容</emp></li><li><wavy>文本内容</wavy></li><li><del>文本内容</del></li><li><kbd>文本内容</kbd></li><li><psw>文本内容</psw></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="行内文本样式-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% u 文本内容 %&#125;</span><br><span class="line">&#123;% emp 文本内容 %&#125;</span><br><span class="line">&#123;% wavy 文本内容 %&#125;</span><br><span class="line">&#123;% del 文本内容 %&#125;</span><br><span class="line">&#123;% kbd 文本内容 %&#125;</span><br><span class="line">&#123;% psw 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="折叠框"><a class="header-anchor" href="#折叠框"></a>折叠框</h2><div class="tabs" id="折叠框"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#折叠框-1">样式示例</button></li><li class="tab"><button type="button" data-href="#折叠框-2">对应源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="折叠框-1"><details ><summary> 查看图片测试 </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg" alt=""></p>              </div>            </details><details green><summary> 查看代码测试 </summary>              <div class='content'>              <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello,World!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details yellow><summary> 查看列表测试 </summary>              <div class='content'>              <p>DONE 列表显示有偏移需要修改</p><ul><li>hello</li><li>hello</li></ul>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="折叠框-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;% folding 查看图片测试 %&#125;</span><br><span class="line"></span><br><span class="line">![](https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;volantis-x&#x2F;cdn-wallpaper&#x2F;abstract&#x2F;41F215B9-261F-48B4-80B5-4E86E165259E.jpeg)</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding green, 查看代码测试 %&#125;</span><br><span class="line">假装这里有代码块（代码块没法嵌套代码块）</span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding yellow, 查看列表测试 %&#125;</span><br><span class="line"></span><br><span class="line">- hello</span><br><span class="line">- hello</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="引用"><a class="header-anchor" href="#引用"></a>引用</h2><h3 id="simple-样式"><a class="header-anchor" href="#simple-样式"></a>simple 样式</h3><div class="tabs" id="simple-样式"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#simple-样式-1">样式示例</button></li><li class="tab"><button type="button" data-href="#simple-样式-2">对应源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="simple-样式-1"><div class="note simple"><p>默认 提示块标签</p></div><div class="note default simple"><p>default 提示块标签</p></div><div class="note primary simple"><p>primary 提示块标签</p></div><div class="note success simple"><p>success 提示块标签</p></div><div class="note info simple"><p>info 提示块标签</p></div><div class="note warning simple"><p>warning 提示块标签</p></div><div class="note danger simple"><p>danger 提示块标签</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="simple-样式-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note simple %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default simple %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary simple %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success simple %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info simple %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning simple %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger simple %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="modern-样式"><a class="header-anchor" href="#modern-样式"></a>modern 样式</h3><div class="tabs" id="modern-样式"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#modern-样式-1">样式示例</button></li><li class="tab"><button type="button" data-href="#modern-样式-2">对应源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="modern-样式-1"><div class="note modern"><p>默认 提示块标签</p></div><div class="note default modern"><p>default 提示块标签</p></div><div class="note primary modern"><p>primary 提示块标签</p></div><div class="note success modern"><p>success 提示块标签</p></div><div class="note info modern"><p>info 提示块标签</p></div><div class="note warning modern"><p>warning 提示块标签</p></div><div class="note danger modern"><p>danger 提示块标签</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="modern-样式-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note modern %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default modern %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary modern %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success modern %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info modern %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning modern %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger modern %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="flat-样式"><a class="header-anchor" href="#flat-样式"></a>flat 样式</h3><div class="tabs" id="flat-样式"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#flat-样式-1">样式示例</button></li><li class="tab"><button type="button" data-href="#flat-样式-2">对应源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="flat-样式-1"><div class="note flat"><p>默认 提示块标签</p></div><div class="note default flat"><p>default 提示块标签</p></div><div class="note primary flat"><p>primary 提示块标签</p></div><div class="note success flat"><p>success 提示块标签</p></div><div class="note info flat"><p>info 提示块标签</p></div><div class="note warning flat"><p>warning 提示块标签</p></div><div class="note danger flat"><p>danger 提示块标签</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="flat-样式-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note flat %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default flat %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary flat %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success flat %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info flat %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning flat %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger flat %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="disabled-样式"><a class="header-anchor" href="#disabled-样式"></a>disabled 样式</h3><div class="tabs" id="默认名称"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#默认名称-1">样式示例</button></li><li class="tab"><button type="button" data-href="#默认名称-2">对应源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="默认名称-1"><div class="note disabled"><p>默认 提示块标签</p></div><div class="note default disabled"><p>default 提示块标签</p></div><div class="note primary disabled"><p>primary 提示块标签</p></div><div class="note success disabled"><p>success 提示块标签</p></div><div class="note info disabled"><p>info 提示块标签</p></div><div class="note warning disabled"><p>warning 提示块标签</p></div><div class="note danger disabled"><p>danger 提示块标签</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="默认名称-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note disabled %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default disabled %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary disabled %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success disabled %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info disabled %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning disabled %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger disabled %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="no-icon-样式"><a class="header-anchor" href="#no-icon-样式"></a>no-icon 样式</h3><div class="tabs" id="默认名称"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#默认名称-1">样式示例</button></li><li class="tab"><button type="button" data-href="#默认名称-2">对应源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="默认名称-1"><div class="note no-icon flat"><p>默认 提示块标签</p></div><div class="note default no-icon flat"><p>default 提示块标签</p></div><div class="note primary no-icon flat"><p>primary 提示块标签</p></div><div class="note success no-icon flat"><p>success 提示块标签</p></div><div class="note info no-icon flat"><p>info 提示块标签</p></div><div class="note warning no-icon flat"><p>warning 提示块标签</p></div><div class="note danger no-icon flat"><p>danger 提示块标签</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="默认名称-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note no-icon %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default no-icon %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary no-icon %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success no-icon %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info no-icon %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning no-icon %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger no-icon %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="复选列表"><a class="header-anchor" href="#复选列表"></a>复选列表</h2><div class="tabs" id="默认名称"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#默认名称-1">样式示例</button></li><li class="tab"><button type="button" data-href="#默认名称-2">对应源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="默认名称-1"><div class='checkbox'><input type="checkbox" />            <p>纯文本测试</p>            </div><div class='checkbox checked'><input type="checkbox" checked="checked"/>            <p>支持简单的 <a href="https://guides.github.com/features/mastering-markdown/">markdown</a> 语法</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>支持自定义颜色</p>            </div><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>绿色 + 默认选中</p>            </div><div class='checkbox yellow checked'><input type="checkbox" checked="checked"/>            <p>黄色 + 默认选中</p>            </div><div class='checkbox cyan checked'><input type="checkbox" checked="checked"/>            <p>青色 + 默认选中</p>            </div><div class='checkbox blue checked'><input type="checkbox" checked="checked"/>            <p>蓝色 + 默认选中</p>            </div><div class='checkbox plus green checked'><input type="checkbox" checked="checked"/>            <p>增加</p>            </div><div class='checkbox minus yellow checked'><input type="checkbox" checked="checked"/>            <p>减少</p>            </div><div class='checkbox times red checked'><input type="checkbox" checked="checked"/>            <p>叉</p>            </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="默认名称-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% checkbox 纯文本测试 %&#125;</span><br><span class="line">&#123;% checkbox checked, 支持简单的 [markdown](https:&#x2F;&#x2F;guides.github.com&#x2F;features&#x2F;mastering-markdown&#x2F;) 语法 %&#125;</span><br><span class="line">&#123;% checkbox red, 支持自定义颜色 %&#125;</span><br><span class="line">&#123;% checkbox green checked, 绿色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox yellow checked, 黄色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox cyan checked, 青色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox blue checked, 蓝色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox plus green checked, 增加 %&#125;</span><br><span class="line">&#123;% checkbox minus yellow checked, 减少 %&#125;</span><br><span class="line">&#123;% checkbox times red checked, 叉 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="单选列表"><a class="header-anchor" href="#单选列表"></a>单选列表</h2><div class="tabs" id="默认名称"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#默认名称-1">样式示例</button></li><li class="tab"><button type="button" data-href="#默认名称-2">对应源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="默认名称-1"><div class='checkbox'><input type="radio" />            <p>纯文本测试</p>            </div><div class='checkbox checked'><input type="radio" checked="checked"/>            <p>支持简单的 <a href="https://guides.github.com/features/mastering-markdown/">markdown</a> 语法</p>            </div><div class='checkbox red'><input type="radio" />            <p>支持自定义颜色</p>            </div><div class='checkbox green'><input type="radio" />            <p>绿色</p>            </div><div class='checkbox yellow'><input type="radio" />            <p>黄色</p>            </div><div class='checkbox cyan'><input type="radio" />            <p>青色</p>            </div><div class='checkbox blue'><input type="radio" />            <p>蓝色</p>            </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="默认名称-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% radio 纯文本测试 %&#125;</span><br><span class="line">&#123;% radio checked, 支持简单的 [markdown](https:&#x2F;&#x2F;guides.github.com&#x2F;features&#x2F;mastering-markdown&#x2F;) 语法 %&#125;</span><br><span class="line">&#123;% radio red, 支持自定义颜色 %&#125;</span><br><span class="line">&#123;% radio green, 绿色 %&#125;</span><br><span class="line">&#123;% radio yellow, 黄色 %&#125;</span><br><span class="line">&#123;% radio cyan, 青色 %&#125;</span><br><span class="line">&#123;% radio blue, 蓝色 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="时间轴"><a class="header-anchor" href="#时间轴"></a>时间轴</h2><div class="tabs" id="默认名称"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#默认名称-1">样式示例</button></li><li class="tab"><button type="button" data-href="#默认名称-2">对应源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="默认名称-1"><div class="timeline"><div class="timenode"><div class="meta"><p><p>2020-07-24 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases">2.6.6 -&gt; 3.0</a></p></p></div><div class="body"><ol><li>如果有 <code>hexo-lazyload-image</code> 插件，需要删除并重新安装最新版本，设置 <code>lazyload.isSPA: true</code>。</li><li>2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 <code>use_cdn: true</code> 则需要删除。</li><li>2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。</li><li>2.x 版本的置顶 <code>top: true</code> 改为了 <code>pin: true</code>，并且同样适用于 <code>layout: page</code> 的页面。</li><li>如果使用了 <code>hexo-offline</code> 插件，建议卸载，3.0 版本默认开启了 pjax 服务。</li></ol></div></div><div class="timenode"><div class="meta"><p><p>2020-05-15 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.6">2.6.3 -&gt; 2.6.6</a></p></p></div><div class="body"><p>不需要额外处理。</p></div></div><div class="timenode"><div class="meta"><p><p>2020-04-20 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3">2.6.2 -&gt; 2.6.3</a></p></p></div><div class="body"><ol><li>全局搜索 <code>seotitle</code> 并替换为 <code>seo_title</code>。</li><li>group 组件的索引规则有变，使用 group 组件的文章内，<code>group: group_name</code> 对应的组件名必须是 <code>group_name</code>。</li><li>group 组件的列表名优先显示文章的 <code>short_title</code> 其次是 <code>title</code>。</li></ol></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="默认名称-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;% timeline %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% timenode 2020-07-24 [2.6.6 -&gt; 3.0](https:&#x2F;&#x2F;github.com&#x2F;volantis-x&#x2F;hexo-theme-volantis&#x2F;releases) %&#125;</span><br><span class="line"></span><br><span class="line">1. 如果有 &#96;hexo-lazyload-image&#96; 插件，需要删除并重新安装最新版本，设置 &#96;lazyload.isSPA: true&#96;。</span><br><span class="line">2. 2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 &#96;use_cdn: true&#96; 则需要删除。</span><br><span class="line">3. 2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。</span><br><span class="line">4. 2.x 版本的置顶 &#96;top: true&#96; 改为了 &#96;pin: true&#96;，并且同样适用于 &#96;layout: page&#96; 的页面。</span><br><span class="line">5. 如果使用了 &#96;hexo-offline&#96; 插件，建议卸载，3.0 版本默认开启了 pjax 服务。</span><br><span class="line"></span><br><span class="line">&#123;% endtimenode %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% timenode 2020-05-15 [2.6.3 -&gt; 2.6.6](https:&#x2F;&#x2F;github.com&#x2F;volantis-x&#x2F;hexo-theme-volantis&#x2F;releases&#x2F;tag&#x2F;2.6.6) %&#125;</span><br><span class="line"></span><br><span class="line">不需要额外处理。</span><br><span class="line"></span><br><span class="line">&#123;% endtimenode %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% timenode 2020-04-20 [2.6.2 -&gt; 2.6.3](https:&#x2F;&#x2F;github.com&#x2F;volantis-x&#x2F;hexo-theme-volantis&#x2F;releases&#x2F;tag&#x2F;2.6.3) %&#125;</span><br><span class="line"></span><br><span class="line">1. 全局搜索 &#96;seotitle&#96; 并替换为 &#96;seo_title&#96;。</span><br><span class="line">2. group 组件的索引规则有变，使用 group 组件的文章内，&#96;group: group_name&#96; 对应的组件名必须是 &#96;group_name&#96;。</span><br><span class="line">2. group 组件的列表名优先显示文章的 &#96;short_title&#96; 其次是 &#96;title&#96;。</span><br><span class="line"></span><br><span class="line">&#123;% endtimenode %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="链接卡片"><a class="header-anchor" href="#链接卡片"></a>链接卡片</h2><div class="tabs" id="默认名称"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#默认名称-1">样式示例</button></li><li class="tab"><button type="button" data-href="#默认名称-2">对应源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="默认名称-1"><div class="tag link"><a class="link-card" title="糖果屋教程贴" href="https://akilar.top/posts/615e2dec/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/Akilarlxh/akilarlxh.github.io/img/siteicon/favicon.ico"/></div><div class="right"><p class="text">糖果屋教程贴</p><p class="url">https://akilar.top/posts/615e2dec/</p></div></a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="默认名称-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% link 糖果屋教程贴, https:&#x2F;&#x2F;akilar.top&#x2F;posts&#x2F;615e2dec&#x2F;, https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;Akilarlxh&#x2F;akilarlxh.github.io&#x2F;img&#x2F;siteicon&#x2F;favicon.ico %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="github-卡片-ghcard"><a class="header-anchor" href="#github-卡片-ghcard"></a>github 卡片 ghcard</h2><h3 id="用户信息卡片"><a class="header-anchor" href="#用户信息卡片"></a>用户信息卡片</h3><div class="tabs" id="默认名称"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#默认名称-1">样式示例</button></li><li class="tab"><button type="button" data-href="#默认名称-2">对应源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="默认名称-1"><table><thead><tr><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/Lanqilu"><img src="https://github-readme-stats.vercel.app/api/?username=Lanqilu&show_owner=true"/></a></th><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/Lanqilu"><img src="https://github-readme-stats.vercel.app/api/?username=Lanqilu&theme=vue&show_owner=true"/></a></th></tr></thead><tbody><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/Lanqilu"><img src="https://github-readme-stats.vercel.app/api/?username=Lanqilu&theme=buefy&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/Lanqilu"><img src="https://github-readme-stats.vercel.app/api/?username=Lanqilu&theme=solarized-light&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/Lanqilu"><img src="https://github-readme-stats.vercel.app/api/?username=Lanqilu&theme=onedark&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/Lanqilu"><img src="https://github-readme-stats.vercel.app/api/?username=Lanqilu&theme=solarized-dark&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/Lanqilu"><img src="https://github-readme-stats.vercel.app/api/?username=Lanqilu&theme=algolia&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/Lanqilu"><img src="https://github-readme-stats.vercel.app/api/?username=Lanqilu&theme=calm&show_owner=true"/></a></td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="默认名称-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| &#123;% ghcard Lanqilu %&#125; | &#123;% ghcard Lanqilu, theme&#x3D;vue %&#125; |</span><br><span class="line">| -- | -- |</span><br><span class="line">| &#123;% ghcard Lanqilu, theme&#x3D;buefy %&#125; | &#123;% ghcard Lanqilu, theme&#x3D;solarized-light %&#125; |</span><br><span class="line">| &#123;% ghcard Lanqilu, theme&#x3D;onedark %&#125; | &#123;% ghcard Lanqilu, theme&#x3D;solarized-dark %&#125; |</span><br><span class="line">| &#123;% ghcard Lanqilu, theme&#x3D;algolia %&#125; | &#123;% ghcard Lanqilu, theme&#x3D;calm %&#125; |</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="仓库信息卡片"><a class="header-anchor" href="#仓库信息卡片"></a>仓库信息卡片</h3><div class="tabs" id="默认名称"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#默认名称-1">样式示例</button></li><li class="tab"><button type="button" data-href="#默认名称-2">对应源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="默认名称-1"><table><thead><tr><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/Lanqilu/JavaDemo"><img src="https://github-readme-stats.vercel.app/api/pin/?username=Lanqilu&repo=JavaDemo&show_owner=true"/></a></th><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/Lanqilu/JavaDemo"><img src="https://github-readme-stats.vercel.app/api/pin/?username=Lanqilu&repo=JavaDemo&theme=vue&show_owner=true"/></a></th></tr></thead><tbody><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/Lanqilu/JavaDemo"><img src="https://github-readme-stats.vercel.app/api/pin/?username=Lanqilu&repo=JavaDemo&theme=buefy&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/Lanqilu/JavaDemo"><img src="https://github-readme-stats.vercel.app/api/pin/?username=Lanqilu&repo=JavaDemo&theme=solarized-light&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/Lanqilu/JavaDemo"><img src="https://github-readme-stats.vercel.app/api/pin/?username=Lanqilu&repo=JavaDemo&theme=onedark&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/Lanqilu/JavaDemo"><img src="https://github-readme-stats.vercel.app/api/pin/?username=Lanqilu&repo=JavaDemo&theme=solarized-dark&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/Lanqilu/JavaDemo"><img src="https://github-readme-stats.vercel.app/api/pin/?username=Lanqilu&repo=JavaDemo&theme=algolia&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/Lanqilu/JavaDemo"><img src="https://github-readme-stats.vercel.app/api/pin/?username=Lanqilu&repo=JavaDemo&theme=calm&show_owner=true"/></a></td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="默认名称-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| &#123;% ghcard Lanqilu&#x2F;JavaDemo %&#125; | &#123;% ghcard Lanqilu&#x2F;JavaDemo, theme&#x3D;vue %&#125; |</span><br><span class="line">| -- | -- |</span><br><span class="line">| &#123;% ghcard Lanqilu&#x2F;JavaDemo, theme&#x3D;buefy %&#125; | &#123;% ghcard Lanqilu&#x2F;JavaDemo, theme&#x3D;solarized-light %&#125; |</span><br><span class="line">| &#123;% ghcard Lanqilu&#x2F;JavaDemo, theme&#x3D;onedark %&#125; | &#123;% ghcard Lanqilu&#x2F;JavaDemo, theme&#x3D;solarized-dark %&#125; |</span><br><span class="line">| &#123;% ghcard Lanqilu&#x2F;JavaDemo, theme&#x3D;algolia %&#125; | &#123;% ghcard Lanqilu&#x2F;JavaDemo, theme&#x3D;calm %&#125; |</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="音频"><a class="header-anchor" href="#音频"></a>音频</h2><div class="tabs" id="默认名称"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#默认名称-1">样式示例</button></li><li class="tab"><button type="button" data-href="#默认名称-2">对应源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="默认名称-1"><p>歌曲名：<a href="https://music.163.com/#/song?id=1398894062">从远方奔赴一场</a></p><div class="note danger no-icon flat"><p>danger 播放时注意调整音量</p></div><div class="audio"><audio controls preload><source src='http://onedrive.whl123456.top/video/%E6%88%91%E7%9A%84%E8%A7%86%E9%A2%91%E5%BA%93/%E4%BB%8E%E8%BF%9C%E6%96%B9%E5%A5%94%E8%B5%B4%E4%B8%80%E5%9C%BA.mp3' type='audio/mp3'>Your browser does not support the audio tag.</audio></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="默认名称-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% audio http:&#x2F;&#x2F;onedrive.whl123456.top&#x2F;video&#x2F;%E6%88%91%E7%9A%84%E8%A7%86%E9%A2%91%E5%BA%93&#x2F;%E4%BB%8E%E8%BF%9C%E6%96%B9%E5%A5%94%E8%B5%B4%E4%B8%80%E5%9C%BA.mp3 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="视频"><a class="header-anchor" href="#视频"></a>视频</h2><div class="tabs" id="默认名称"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#默认名称-1">样式示例</button></li><li class="tab"><button type="button" data-href="#默认名称-2">对应源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="默认名称-1"><div class="videos" col='1'><div class="video"><video controls preload><source src='http://onedrive.whl123456.top/video/%E6%88%91%E7%9A%84%E8%A7%86%E9%A2%91%E5%BA%93/%E7%BE%8E%E5%88%B0%E7%AA%92%E6%81%AF%E7%9A%84%E4%BA%AC%E9%98%BF%E5%B0%BC-Lifeisbeautiful.67833543.mp4' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='http://onedrive.whl123456.top/video/%E6%88%91%E7%9A%84%E8%A7%86%E9%A2%91%E5%BA%93/%E3%80%90RADWIMPS%E3%80%91%E3%80%8A%E5%A4%A9%E6%B0%94%E4%B9%8B%E5%AD%90%E3%80%8B%E7%89%87%E4%B8%AD%E6%9B%B2%E3%80%8E%E3%82%B0%E3%83%A9%E3%83%B3%E3%83%89%E3%82%A8%E3%82%B9%E3%82%B1%E3%83%BC%E3%83%97%E3%80%8F%E5%AE%8C%E6%95%B4%E7%89%88MV%E3%80%90%E4%B8%AD%E5%AD%97%E3%80%91.125772545.mp4' type='video/mp4'>Your browser does not support the video tag.</video></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="默认名称-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% videos, 1 %&#125;</span><br><span class="line">&#123;% video http:&#x2F;&#x2F;onedrive.whl123456.top&#x2F;video&#x2F;%E6%88%91%E7%9A%84%E8%A7%86%E9%A2%91%E5%BA%93&#x2F;%E7%BE%8E%E5%88%B0%E7%AA%92%E6%81%AF%E7%9A%84%E4%BA%AC%E9%98%BF%E5%B0%BC-Lifeisbeautiful.67833543.mp4 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% video http:&#x2F;&#x2F;onedrive.whl123456.top&#x2F;video&#x2F;%E6%88%91%E7%9A%84%E8%A7%86%E9%A2%91%E5%BA%93&#x2F;%E3%80%90RADWIMPS%E3%80%91%E3%80%8A%E5%A4%A9%E6%B0%94%E4%B9%8B%E5%AD%90%E3%80%8B%E7%89%87%E4%B8%AD%E6%9B%B2%E3%80%8E%E3%82%B0%E3%83%A9%E3%83%B3%E3%83%89%E3%82%A8%E3%82%B9%E3%82%B1%E3%83%BC%E3%83%97%E3%80%8F%E5%AE%8C%E6%95%B4%E7%89%88MV%E3%80%90%E4%B8%AD%E5%AD%97%E3%80%91.125772545.mp4 %&#125;</span><br><span class="line">&#123;% endvideos %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><div class="tabs" id="默认名称"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#默认名称-1">样式示例</button></li><li class="tab"><button type="button" data-href="#默认名称-2">对应源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="默认名称-1"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="默认名称-2"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
    
    
    <summary type="html">外挂标签测试使用</summary>
    
    
    
    <category term="测试" scheme="http://halo123.top/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="测试" scheme="http://halo123.top/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>线性代数——行列式</title>
    <link href="http://halo123.top/2021/04/23/LinearAlgebra/A_Determinant/"/>
    <id>http://halo123.top/2021/04/23/LinearAlgebra/A_Determinant/</id>
    <published>2021-04-23T03:26:54.000Z</published>
    <updated>2021-04-23T06:52:41.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二阶与三阶行列式"><a class="header-anchor" href="#二阶与三阶行列式"></a>二阶与三阶行列式</h2><p>二阶行列式，记作：</p><div>$$\begin{vmatrix}  a_{1} & a_{2}\\  b_{1} & b_{2}\end{vmatrix}$$</div><p>三阶行列式，记作：</p><div>$$\begin{vmatrix}a_{1} & a_{2} & a_{3}\\b_{1} & b_{2} & b_{3}\\c_{1} & c_{2} & c_{3}\end{vmatrix}$$</div><div>$$\begin{vmatrix} a_{1} & a_{2} & a_{3}\\ b_{1} & b_{2} & b_{3}\\ c_{1} & c_{2} & c_{3}\end{vmatrix}= a_{1}b_{2}c_{3}+a_{2}b_{3}c_{1}+a_{3}b_{1}c_{2}-a_{3}b_{2}c_{1}-a_{1}b_{3}c_{2}$$</div><p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E4%B8%89%E9%98%B6%E8%A1%8C%E5%88%97%E5%BC%8F%E7%9A%84%E8%AE%A1%E7%AE%97.png" alt="三阶行列式的计算"></p><h2 id="全排列和对换"><a class="header-anchor" href="#全排列和对换"></a>全排列和对换</h2><h3 id="排列及其逆序数"><a class="header-anchor" href="#排列及其逆序数"></a>排列及其逆序数</h3><p>把$n$个不同的元素排成一列，叫做这$n$个元素的全排列（也简称<font color="#ea66a6">排列</font>）<br>$n$个不同元素的所有排列的种数，通常用$P_{n}$表示：</p><span>$$P_{n}=n\cdot(n-1)\cdot\dots\cdot3\cdot2\cdot1=n!$$</span>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;二阶与三阶行列式&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#二阶与三阶行列式&quot;&gt;&lt;/a&gt;二阶与三阶行列式&lt;/h2&gt;
&lt;p&gt;二阶行列式，记作：&lt;/p&gt;
&lt;div&gt;
$$\begin{vmatrix}
  a_{1} &amp; a_{2}\\
  b</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>物理层</title>
    <link href="http://halo123.top/2021/04/22/ComputerNetworks/B_PhysicalLayer/"/>
    <id>http://halo123.top/2021/04/22/ComputerNetworks/B_PhysicalLayer/</id>
    <published>2021-04-22T14:22:00.631Z</published>
    <updated>2021-04-22T14:24:39.061Z</updated>
    
    <content type="html"><![CDATA[<h2 id="物理层的基本概念"><a class="header-anchor" href="#物理层的基本概念"></a>物理层的基本概念</h2><p>物理层解决如何在连接各种计算机的传输媒体上<font color="#FF666">传输数据比特流</font>，而不是指具体的传输媒体。</p><p>物理层主要任务:确定与传输媒体<font color="#faa755">接口</font>有关的一些特性(定义标准)</p><ol><li><p>机械特性:定义物理连接的特性，规定物理连接时所采用的规格、接口形状、<font color="#faa755">引线数目</font>、<font color="#faa755">引脚数量</font>和排列情况。</p></li><li><p>电气特性:规定传输二进制位时，线路上信号的<font color="#faa755">电压范围</font>、阻抗匹配、传输<font color="#faa755">速率</font>和<font color="#faa755">距离</font>限制等。</p><blockquote><p>某网络在物理层规定，信号的电平用+10V<sub>+15V表示二进制0，用-10V</sub>-15V表示二进制1，电线长度限于15m以内</p></blockquote></li><li><p>功能特性:指明某条线上出现的某一<font color="#faa755">电平表示何种意义</font>，接口部件的信号线的用途。</p><blockquote><p>描述一个物理层接口引脚处于高电平时的含义时</p></blockquote></li><li><p>规程特性:(过程特性) 定义各条物理线路的工作<font color="#faa755">规程和时序</font>关系。</p></li></ol><h1>通信基础</h1><h2 id="1-基本概念"><a class="header-anchor" href="#1-基本概念"></a>1 基本概念</h2><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B8%E5%9E%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B.png" alt="典型的数据通信模型" style="object-fit: cover; border-radius: 10px; width: 100%;" /><p>通信的目的是<font color="#faa755">传送信息</font>。</p><p><font color="#ea66a6">数据</font>:传送信息的实体，通常是有意义的符号序列。</p><p><font color="#ea66a6">信号</font>:数据的电气或电磁的表现，是数据在传输过程中的<font color="#faa755">存在形式</font>。</p><ul><li>数字信号:代表消息的参数取值是离散的。取值仅允许为有限的几个离散数值的数据(或信号)称为数字数据(或数字信号)。</li><li>模拟信号:代表消息的参数取值是连续的。连续变化的数据(或信号)称为模拟数据(或模拟信号);</li></ul><p><font color="#ea66a6">信源</font>:产生和发送数据的源头。</p><p><font color="#ea66a6">信宿</font>:接收数据的终点。</p><p><font color="#ea66a6">信道</font>:信号的传输媒介。一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接收信道。</p><ul><li><p>信道按传输<font color="#ef5b9c">信号形式</font>的不同可分为传送模拟信号的<font color="#faa755">模拟信道</font>和传送数字信号的<font color="#faa755">数字信道</font>两大类;</p></li><li><p>信道按传输<font color="#ef5b9c">介质</font>的不同可分为<font color="#faa755">无线信道</font>和<font color="#faa755">有线信道</font>。</p></li></ul><p>从通信双方信息的交互方式看，可分为三种基本方式:</p><ol><li><font color="#ea66a6">单工通信</font>。只有一个方向的通信而没有反方向的交互，仅需要<font color="#FF666">一条</font>信道。例如，无线电广播、电视广播就属于这种类型。</li><li><font color="#ea66a6">半双工通信</font>。通信的双方都可以发送或接收信息，但任何一方都<font color="#faa755">不能同时</font>发送和接收信息，此时需要<font color="#FF666">两条</font>信道。(对讲机)</li><li><font color="#ea66a6">全双工通信</font>。通信双方可以同时发送和接收信息，也需要<font color="#FF666">两条</font>信道。</li></ol><p>数据传输方式可分为串行传输和并行传输。</p><ul><li><font color="#ea66a6">串行传输</font>是指一个一个的比特按照时间顺序传输(出于经济上的考虑，远距离通信通常采用串行传输)</li><li><font color="#ea66a6">并行传输</font>是指多个比特通过多条通信信道同时传输。</li></ul><hr><p><font color="#ea66a6">码元</font>是指用一个<font color="#FF666">固定时长</font>的<font color="#FF666">信号波形</font>(数字脉冲)表示一位k进制数字，代表不同离散数值的基本波形，是数字通信中数字信号的计量单位，这个时长内的信号称为<font color="#ea66a6">k进制码元</font>，而该时长称为<font color="#ea66a6">码元宽度</font>。1码元可以携带多个比特的信息量。例如，在使用二进制编码时，只有两种不同的码元: 一种代表0状态，另一种代表1状态。</p><p>速率也称数据率，指的是数据的<font color="#FF666">传输速率</font>，表示单位时间内传输的数据量。可以用<font color="#faa755">码元传输速率</font>和<font color="#faa755">信息传输速率</font>表示。</p><ul><li><font color="#ea66a6">码元传输速率</font>。又称码元速率、波形速率、调制速率、符号速率等，它表示单位时间内数字通信系统所传输的码元个数(也可称为<font color="#faa755">脉冲个数或信号变化的次数</font>)，单位是<font color="#FF666">波特</font>(Baud)。 1波特表示数字通信系统每秒传输一个码元。这里的码元可以是多进制的，也可以是二进制的，但码元速率与进制数无关。<font color="#FF666">1s传输多少个码元</font></li><li><font color="#ea66a6">信息传输速率</font>。又称信息速率、比特率等，它表示单位时间内数字通信系统传输的二进制码元个数(即比特数)，单位是比特/秒(b/s)。<font color="#FF666">1s传输多少个比特</font></li></ul><blockquote><p>关系:<font color="#faa755">若一个码元携带n比特的信息量，则M波特率的码元传输速率所对应的信息传输速率为M×n bit/s</font>。</p></blockquote><p><font color="#ea66a6">带宽</font>:表示在单位时间内从网络中的某一点到另一点所能通过的“<font color="#faa755">最高数据率</font>”，常用来表示网络的通信线路所能传输数据的能力。单位是b/s。</p><h2 id="font-color-d9730d-2-奈奎斯特定理与香农定理-font"><a class="header-anchor" href="#font-color-d9730d-2-奈奎斯特定理与香农定理-font"></a><font color="#d9730d">2 奈奎斯特定理与香农定理</font></h2><p>影响失真程度的影响因素:</p><ol><li>码元传输速率,速率越快失真越严重</li><li>信号传输距离,距离越远失真越严重</li><li>噪声干扰,干扰越多失真越严重</li><li>传输媒体质量,质量越差失真越严重</li></ol><p>具体的信道所能通过的频率范围总是有限的(信道带宽).信号中的许多高频分量往往不能通过信道,否则在传输中会衰减,导致接收端收到的信号波形<font color="#faa755">失去码元之间清晰界限</font>,这种现象称为<font color="#ea66a6">码间串扰</font></p><p><font color="#ea66a6">信道带宽</font>:是信道能通过的最高频率和最低频率之差.</p><h3 id="奈奎斯特定理"><a class="header-anchor" href="#奈奎斯特定理"></a>奈奎斯特定理</h3><p>奈奎斯特(Nyquist)定理又称<font color="#ea66a6">奈氏准则</font>，它指出在理想低通(没有噪声、带宽有限)的信道中，极限码元传输率为2W波特，其中<font color="#faa755">W</font>是理想低通信道的带宽，单位为<font color="#FF666">Hz</font>。若用<font color="#faa755">V</font>表示每个码元离散电平的数目(码元的离散电平数目是指有多少种不同的码元，比如有16种不同的码元，则需要4位二进制位，因此数据传输率是码元传输率的4倍)，则极限数据率为</p><p>理想低通信道下的极限数据传输率= 2W log<sub>2</sub>V (单位为b/s)</p><p>对于奈氏准则，可以得出以下结论:</p><ol><li>在任何信道中，码元传输的速率是有上限的。若传输速率超过此上限，就会出现严重的码间串扰问题(指在接收端收到的信号波形失去了码元之间的清晰界限)，使得接收端不可能完全正确识别码元。</li><li>信道的频带越宽(即通过的信号高频分量越多)，就可用更高的速率进行码元的有效传输。</li><li>奈氏准则给出了码元传输速率的限制，但并未对信息传输速率给出限制，即未对一个码元可以对应多少个二进制位给出限制。</li></ol><p>由于码元的传输速率受奈氏准则的制约，所以要提高数据的传输速率，就必须设法使每个码元携带更多个比特的信息量，此时就需要采用多元制的调制方法。</p><h3 id="香农定理"><a class="header-anchor" href="#香农定理"></a>香农定理</h3><p><font color="#ea66a6">噪声</font>存在于所有的电子设备和通信信道中。由于噪声随机产生，它的瞬时值有时会很大，因此噪声会使接收端对码元的判决产生错误。但是噪声的影响是相对的，若信号较强，那么噪声影响相对较小。因此，<font color="#ea66a6">信噪比</font>就很重要。</p><p>香农(Shannon)定理给出了带宽受限且有高斯白噪声干扰的信道的极限数据传输率，当用此速率进行传输时，可以做到不产生误差。香农定理定义为</p><p><font color="#faa755">信道的极限数据传输率 = Wlog<sub>2</sub>(1+S/N) (单位为b/s)</font></p><p>式中，W为信道的带宽，S为信道所传输信号的平均功率，N为信道内部的高斯噪声功率。S/N为信噪比，即信号的平均功率与噪声的平均功率之比，<font color="#FF666">信噪比 = 10log<sub>10</sub>(S/N) (单位为dB)</font>，例如如当S/N= 10时，信噪比为10dB，而当S/N= 1000时，信噪比为30dB。</p><p>对于香农定理，可以得出以下结论:</p><ol><li>信道的带宽或信道中的信噪比越大，信息的极限传输速率越高。</li><li>对一定的传输带宽和一定的信噪比，信息传输速率的上限是确定的。</li><li>只要信息的传输速率低于信道的极限传输速率，就能找到某种方法来实现无差错的传输。</li><li>香农定理得出的是极限信息传输速率，实际信道能达到的传输速率要比它低不少。</li></ol><p>从香农定理可以看出，若信道带宽W或信噪比SIN没有上限(实际信道当然不可能这样)，则信道的极限信息传输速率也没有上限。</p><p>奈氏准则只考虑了带宽与极限码元传输速率的关系，而香农定理不仅考虑到了带宽，也考虑到了信噪比。这从另一个侧面表明，一个码元对应的二进制位数是有限的。</p><h2 id="3-编码与调制"><a class="header-anchor" href="#3-编码与调制"></a>3 编码与调制</h2><p>信道上传送信号的两种形式:基带信号和宽带信号</p><ul><li><p>基带信号:将数字信号1和0直接用两种不同的电压表示，再送到<font color="#faa755">数字信道</font>上去传输(<font color="#faa755">基带传输</font>)</p><blockquote><p><font color="#ef5b9c">来自信源的信号</font>，像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。基带信号就是发出的直接表达了要传输的信息的信号，比如我们说话的声波就是基带信号。</p></blockquote></li><li><p>宽带信号:将基带信号进行调制后形成的频分复用模拟信号，再传送到<font color="#faa755">模拟信道</font>上去传输(<font color="#faa755">宽带传输</font>)</p><blockquote><p>把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输(即仅在一段频率范围内能够通过信道)。</p></blockquote></li></ul><p>在传输距离较<font color="#faa755">近</font>时，计算机网络采用<font color="#ef5b9c">基带传输</font>方式(近距离衰减小，从而信号内容不易发生变化)</p><p>在传输距离较<font color="#faa755">远</font>时，计算机网络采用<font color="#ef5b9c">宽带传输</font>方式(远距离衰减大，即使信号变化大也能最后过滤出来基带信号)</p><h3 id="数字数据编码为数字信号"><a class="header-anchor" href="#数字数据编码为数字信号"></a>数字数据编码为数字信号</h3><p>数字数据编码用于基带传输中，即在基本不改变数字数据信号频率的情况下，直接传输数字信号。具体用什么样的数字信号表示0及用什么样的数字信号表示1就是所谓的编码。编码的规则有多种，只要能有效地把1和0区分开即可，常用的编码方式有以下几种，如下图所示。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E5%AD%97%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F.png" alt="常用的数字数据编码方式" style="object-fit: cover; border-radius: 10px; width: 80%;" /><ol><li><p>归零编码(RZ)</p><p>在归零编码中用高电平代表1、低电平代表0 (或者相反)，每个时钟周期的中间均跳变到低电平(归零)，接收方根据该跳变调整本方的时钟基准，这就为传输双方提供了自同步机制。由于归零需要占用一部分带宽，因此传输效率受到了一定的影响。</p></li><li><p>非归零编码(NRZ)</p><p>非归零编码与RZ编码的区别是不用归零,一个周期可以全部用来传输数据。但NRZ编码无法传递时钟信号，双方难以同步，因此若想传输高速同步数据，则需要都带有时钟线。</p></li><li><p>反向非归零编码(NRZI)</p><p>反向非归零码与NRZ编码的区别是用信号的翻转代表0、信号保持不变代表1。翻转的信号本身可以作为一种通知机制。这种编码方式集成了前两种编码的优点，既能传输时钟信号，又能尽量不损失系统带宽。USB2.0通信的编码方式就是NRZI编码。</p></li><li><p>曼彻斯特编码(Manchester Encoding)</p><p>曼彻斯特编码将一个码元分成两个相等的间隔，前一个间隔为高电平而后一个间隔为低电平表示码元1;码元0的表示方法则正好相反。当然，也可采用相反的规定。该编码的特点是，在每个码元的中间出现电平跳变，位中间的跳变既作为时钟信号(可用于同步)，又作为数据信号，但它所占的频带宽度是原始基带宽度的两倍。<font color="#faa755">以太网使用的编码方式就是曼彻斯特编码</font>。</p></li><li><p>差分曼彻斯特编码</p><p>差分曼彻斯特编码常用于局域网传输,其规则是,若码元为1,则前半个码元的电平与上一个码元的后半个码元的电平相同;若码元为0，则情形相反。该编码的特点是，在每个码元的中间都有一次电平的跳转，可以实现自同步，且<font color="#faa755">抗干扰性较好</font>。</p></li><li><p>4B/5B编码</p><p>将欲发送数据流的每4位作为一组，然后按照4B/5B编码规则将其转换成相应的5位码。5位码共32种组合，但只采用其中的16种对应16种不同的4位码，其他的16种作为控制码(帧的开始和结束、线路的状态信息等)或保留。</p></li></ol><h3 id="数字数据调制为模拟信号"><a class="header-anchor" href="#数字数据调制为模拟信号"></a>数字数据调制为模拟信号</h3><p>数字数据调制技术在发送端将数字信号转换为模拟信号,而在接收端将模拟信号还原为数字信号，分别对应于调制解调器的调制和解调过程。基本的调制方法有如下几种:</p><ol><li>幅移键控(ASK)。通过改变载波信号的振幅来表示数字信号1和0，而载波的频率和相位都不改变。比较容易实现，但抗干扰能力差。调幅(AM)</li><li>频移键控(FSK)。 通过改变载波信号的频率来表示数字信号1和0，而载波的振幅和相位都不改变。容易实现，抗干扰能力强，目前应用较为广泛。调频(FM)</li><li>相移键控(PSK)。 通过改变载波信号的相位来表示数字信号1和0，而载波的振幅和频率都不改变。它又分为绝对调相和相对调相。调相</li><li>正交振幅调制(QAM)。在频率相同的前提下，将ASK与PSK结合起来，形成叠加信号。设波特率为B,采用m个相位，每个相位有n种振幅，则该QAM技术的数据传输率R为:R= Blog<sub>2</sub>(mn) (单位为b/s).调幅+调相</li></ol><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E5%AD%97%E8%B0%83%E5%88%B6%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F.png" alt="数字调制的三种方式" style="object-fit: cover; border-radius: 10px; width: 900%;" /><h3 id="模拟数据编码为数字信号"><a class="header-anchor" href="#模拟数据编码为数字信号"></a>模拟数据编码为数字信号</h3><p>这种编码方式最典型的例子是常用于对音频信号进行编码的<font color="#ea66a6">脉码调制(PCM)</font>。它主要包括三个步骤，即采样、量化和编码。</p><p><font color="#ea66a6">采样定理</font>:在通信领域，带宽是指信号最高频率与最低频率之差，单位为Hz。因此，将模拟信号转换成数字信号时，假设原始信号中 的最大频率为$f$,那么采样频率$f_{采样}$必须大于等于最大频率$f$的两倍，才能保证采样后的数字信号完整保留原始模拟信号的信息(只需记住结论)。另外，采样定理又称奈奎斯特定理。</p><ol><li><font color="#ea66a6">采样</font>:是指对模拟信号进行周期性扫描，把时间上连续的信号变成时间上离散的信号。根据采样定理，当采样的频率大于等于模拟数据的频带带宽(最高变化频率)的两倍时，所得的离散信号可以无失真地代表被采样的模拟数据。</li><li><font color="#ea66a6">量化</font>:是把采样取得的电平幅值按照一定的分级标度转化为对应的数字值并取整数，这样就把连续的电平幅值转换为了离散的数字量。采样和量化的实质就是分割和转换。</li><li><font color="#ea66a6">编码</font>:是把量化的结果转换为与之对应的二进制编码。</li></ol><h3 id="模拟数据调制为模拟信号"><a class="header-anchor" href="#模拟数据调制为模拟信号"></a>模拟数据调制为模拟信号</h3><p>为了实现传输的有效性，可能需要较高的频率。这种调制方式还可以使用频分复用(FDM)技术，充分利用带宽资源。电话机和本地局交换机采用模拟信号传输模拟数据的编码方式;模拟的声音数据是加载到模拟的载波信号中传输的。</p><h3 id="4-电路交换、报文交换与分组交换"><a class="header-anchor" href="#4-电路交换、报文交换与分组交换"></a>4 电路交换、报文交换与分组交换</h3><p>P40</p><h1>传输介质</h1><p><font color="#ea66a6">传输介质</font>也称传输媒体，它是发送设备和接收设备之间的<font color="#faa755">物理通路</font>。</p><blockquote><p><font color="#faa755">传输媒体并不是物理层</font>。传输媒体在物理层的下面，因为物理层是体系结构的第一层， 因此有时称传输媒体为0层。在传输媒体中传输的是信号，但传输媒体并不知道所传输的信号代表什么意思。但物理层规定了电气特性，因此能够识别所传送的比特流。</p></blockquote><p>传输介质可分为导向传输介质和非导向传输介质。</p><ul><li><font color="#ea66a6">导向传输介质</font>中，电磁波被导向沿着固体媒介(铜线或光纤)传播</li><li><font color="#ea66a6">非导向传输介质</font>可以是空气、真空或海水等</li></ul><h2 id="双绞线、同轴电缆、光纤与无线传输介质"><a class="header-anchor" href="#双绞线、同轴电缆、光纤与无线传输介质"></a>双绞线、同轴电缆、光纤与无线传输介质</h2><h3 id="双绞线"><a class="header-anchor" href="#双绞线"></a>双绞线</h3><p>双绞线是最常用的古老传输介质,它由两根采用一定规则并排绞合的、相互绝缘的铜导线组成。<font color="#faa755">绞合可以减少对相邻导线的电磁干扰</font>。</p><p>为了进一步提高抗电磁干扰能力，可在双绞线的外面再加上一个由<font color="#faa755">金属丝</font>编织成的屏蔽层，这就是屏蔽双绞线(STP)。无屏蔽层的双绞线称为非屏蔽双绞线(UTP)。</p><p>它们的结构如图下所示。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%8F%8C%E7%BB%9E%E7%BA%BF%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="双绞线的结构" style="object-fit: cover; border-radius: 10px; width: 100%;" /><p>双绞线价格便宜，是最常用的传输介质之一，在局域网和传统电话网中普遍使用。</p><p>双绞线的带宽取决于铜线的粗细和传输的距离。</p><p>模拟传输和数字传输都可使用双绞线，其通信距离一般为几千米到数十千米。</p><p>距离太远时，对于<font color="#ef5b9c">模拟传输</font>，要用<font color="#ef5b9c">放大器</font>放大衰减的信号;对于<font color="#faa755">数字传输</font>，要用<font color="#faa755">中继器</font>将失真的信号整形。</p><h3 id="同轴电缆"><a class="header-anchor" href="#同轴电缆"></a>同轴电缆</h3><p>同轴电缆由内导体、绝缘层、网状编织屏蔽层和塑料外层构成，如下图所示。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%90%8C%E8%BD%B4%E7%94%B5%E7%BC%86%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="同轴电缆的结构" style="object-fit: cover; border-radius: 10px; width: 80%;" /><p>按特性阻抗数值的不同，通常将同轴电缆分为两类: 50Ω同轴电缆和75Ω同轴电缆。</p><ul><li>50Ω同轴电缆主要用于传送基带数字信号，又称<font color="#ea66a6">基带同轴电缆</font>，它在局域网中应用广泛;</li><li>75Ω同轴电缆主要用于传送宽带信号，又称<font color="#ea66a6">宽带同轴电缆</font>，主要用于有线电视系统。</li></ul><p>由于外导体屏蔽层的作用，同轴电缆具有良好的抗干扰特性，被广泛用于传输较高速率的数据，其传输距离更远，但价格较双绞线贵。</p><h3 id="光纤"><a class="header-anchor" href="#光纤"></a>光纤</h3><p>光纤通信就是利用光导纤维(简称光纤)传递光脉冲来进行通信。有光脉冲表示1，无光脉冲表示0。可见光的频率约为10<sup>8</sup>MHz，因此光纤通信系统的带宽范围极大。</p><p>光纤在发送端有光源，可以采用发光二极管或半导体激光器，它们在电脉冲作用下能产生出光脉冲;在接收端用光电二极管做成光检测器，在检测到光脉冲时可还原出电脉冲。</p><p>光纤主要由<font color="#faa755">纤心</font>和<font color="#faa755">包层</font>构成，光波通过纤心进行传导，包层较纤心有较低的折射率。当光线从高折射率的介质射向低折射率的介质时，其折射角大于入射角。因此，如果入射角足够大，那么就会出现全反射，即光线碰到包层时会折射回纤心，这个过程不断重复，光也就沿着光纤传输下去。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%89%E6%B3%A2%E5%9C%A8%E7%BA%A4%E5%BF%83%E4%B8%AD%E7%9A%84%E4%BC%A0%E6%92%AD.png" alt="光波在纤心中的传播" style="object-fit: cover; border-radius: 10px; width: 100%;" /><p>只要从纤心中射到纤心表面的光线的入射角大于某个临界角度，就会产生全反射。因此，从不同角，度入射的多束光线可在一条光纤中传输， 这种光纤称为<font color="#ea66a6">多模光纤</font>，多模光纤的光源为<font color="#faa755">发光二极管</font>。光脉冲在多模光纤中传输时会逐渐展宽，造成失真，因此多模光纤只适合于<font color="#faa755">近距离传输</font>。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%A4%9A%E6%A8%A1%E5%85%89%E7%BA%A4.png" alt="多模光纤" style="object-fit: cover; border-radius: 10px; width: 100%;" /><p>光纤的直径减小到仅一个光波长度时，光纤就像一根波导 那样，可使光线一直向前传播， 而不会产生多次反射，这样的光纤就是单模光纤。 单模光纤的纤心很细，直径只有几微米，制造成本较高。同时，单模光纤的光源为<font color="#faa755">定向性很好的激光二极管</font>，因此单模光纤的衰减较小，适合<font color="#faa755">远距离传输</font>。</p><p>光纤的特点:</p><ol><li>传输损耗小，中继距离长，对远距离传输特别经济。</li><li>抗雷电和电磁干扰性能好。</li><li>无串音干扰，保密性好，也不易被窃听或截取数据。</li><li>体积小，重量轻。</li></ol><h3 id="无线传输介质（非导向传播介质）"><a class="header-anchor" href="#无线传输介质（非导向传播介质）"></a>无线传输介质（非导向传播介质）</h3><p>无线通信已广泛应用于移动电话领域，构成蜂窝式无线电话网。随着便携式计算机的出现，以及在军事、野外等特殊场合下移动通信联网的需要，促进了数字化移动通信的发展，现在无线局域网产品的应用已非常普遍。</p><h4 id="无线电波"><a class="header-anchor" href="#无线电波"></a>无线电波</h4><p>无线电波具有<font color="#faa755">较强的穿透能力</font>，可以传输很长的距离，所以它被广泛应用于通信领域，如无线手机通信、计算机网络中的无线局域网(WLAN)等。因为无线电波使信号向所有方向散播,因此有效距离范围内的接收设备无须对准某个方向，就可与无线电波发射者进行通信连接，大大简化了通信连接。这也是无线电传输的最重要优点之一。</p><h4 id="微波、红外线和激光"><a class="header-anchor" href="#微波、红外线和激光"></a>微波、红外线和激光</h4><p>目前高带宽的无线通信主要使用三种技术:微波、红外线和激光。它们都需要发送方和接收方之间存在一条视线(Line-of-sight) 通路，有很强的方向性，都沿直线传播，有时统称这三者为视线介质。不同的是，红外通信和激光通信把要传输的信号分别转换为各自的信号格式，即红外光信号和激光信号，再直接在空间中传播。</p><p>微波通信的频率较高，频段范围也很宽，载波频率通常为2~40GHz,因而通信信道的容量大。例如，一个带宽为2MHz的频段可容纳500条语音线路，若用来传输数字信号，数据率可达数兆比特/秒。与通常的无线电波不同，微波通信的信号是沿直线传播的，因此在地面的传播距离有限，超过一定距离后就要用中继站来接力。</p><p>卫星通信利用地球同步卫星作为中继来转发微波信号，可以克服地面微波通信距离的限制。三颗相隔120°的同步卫星几乎能覆盖整个地球表面，因而基本能实现全球通信。卫星通信的优点是通信容量大、距离远、覆盖广、广播通信和多址通信，缺点是端到端传播时延长，一般为 250~270ms、受气候影响大（强风、太阳黑子爆发、日凌）、误码率较高、成本高。</p><h1>物理层设备</h1><h2 id="中继器"><a class="header-anchor" href="#中继器"></a>中继器</h2><p>诞生原因:由于存在损耗，在线路上传输的信号功率会逐渐衰减，衰减到一定程度时将造成信号失真，因此会导致接收错误。</p><p>中继器的功能:对信号进行<font color="#faa755">再生和还原</font>，对衰减的信号进行放大，保持与原数据相同，以增加信号传输的距离，延长网络的长度。<font color="#FF666">再生数字信号</font></p><p>中继器的两端:</p><ul><li>两端的网络部分是网段，而不是子网，适用于完全相同的两类网络的互连，且两个网段速率要相同。</li><li>中继器只将任何电缆段上的数据发送到另一段电缆上，它仅作用于信号的电气部分，并不管数据中是否有错误数据或不适于网段的数据。</li><li>两端可连相同媒体，也可连不同媒体。</li><li>中继器两端的网段一定要是同一个协议。</li></ul><p>中继器又称转发器，主要功能是将信号整形并放大再转发出去，以消除信号经过一长段电缆后，因噪声或其他原因而造成的失真和衰减，使信号的波形和强度达到所需要的要求，进而扩大网络传输的距离。其原理是信号再生(而非简单地将衰减的信号放大)。中继器有两个端口，数据从一个端口输入，再从另一个端口发出。端口仅作用于信号的电气部分，而不管数据中是否有错误数据或不适于网段的数据。</p><p>中继器是局域网环境下用来扩大网络规模的最简单、最廉价的互联设备。使用中继器连接的几个网段仍然是一个局域网。一般情况下，中继器的两端连接的是相同的媒体，但有的中继器也可以完成不同媒体的转接工作。但由于中继器工作在物理层，因此它不能连接两个具有不同速率的局域网。中继器两端的网络部分是网段，而不是子网。中继器若出现故障，对相邻两个网段的工作都将产生影响。</p><p>从理论上讲，中继器的使用数目是无限的，网络因而也可以无限延长。但事实上这不可能,因为网络标准中对信号的延迟范围做了具体的规定，<font color="#faa755">中继器只能在此规定范围内进行有效的工作，否则会引起网络故障</font>。例如，在采用粗同轴电缆的10BASE5 以太网规范中，互相串联的中继器的个数不能超过4个，而且用4个中继器串联的5段通信介质中只有3段可以挂接计算机，其余两段只能用作扩展通信范围的链路段，不能挂接计算机。这就是所谓的“<font color="#faa755">5-4-3规则</font>”。</p><blockquote><p>注意:放大器和中继器都起放大作用，只不过放大器放大的是模拟信号,原理是将衰减的信号放大，而中继器放大的是数字信号，原理是将衰减的信号整形再生。如果某个网络设备具有存储转发的功能，那么可以认为它能连接两个不同的协议，如果该网络设备没有存储转发功能，那么认为它不能连接两个不同的协议。中继器是没有存储转发功能的，因此它不能连接两个速率不同的网段，中继器两端的网段一定要使用同一个协议。</p></blockquote><h3 id="集线器-多口中继器"><a class="header-anchor" href="#集线器-多口中继器"></a>集线器(多口中继器)</h3><p>集线器(Hub)实质上是一个多端口的中继器，它也工作在物理层。当Hub工作时，一个端口接收到数据信号后，由于信号在从端口到Hub的传输过程中已有衰减，所以Hub便将该信号进行整形放大，使之<font color="#faa755">再生(恢复)到发送时的状态</font>，紧接着转发到其他所有(除输入端口外)处于工作状态的端口。如果同时有两个或多个端口输入，那么输出时会发生冲突，致使这些数据都无效。从Hub的工作方式可以看出，它在网络中只起信号放大和转发作用，目的是扩大网络的传输范围，而<font color="#faa755">不具备信号的定向传送能力</font>，即信号传输的方向是固定的，是一个标准的共享式设备。</p><p>Hub主要使用双绞线组建共享网络，是从服务器连接到桌面的最经济方案。在交换式网络中，Hub直接与交换机相连，将交换机端口的数据送到桌面上。使用Hub组网灵活，它把所有结点的通信集中在以其为中心的结点上，对结点相连的工作站进行集中管理，不让出问题的工作站影响整个网络的正常运行，并且用户的加入和退出也很自由。</p><p>由Hub组成的网络是共享式网络，但逻辑上仍是一个总线网。Hub的每个端口连接的网络部分是同一个网络的不同网段，同时Hub也只能在半双工状态下工作，网络的吞吐率因而受到限制.</p><blockquote><p>注意:多台计算机必须会发生同时通信的情形，因此集线器不能分割冲突域，所有集线器的端口都属于同一个冲突域。集线器在一个时钟周期中只能传输一组信息，如果一台集线器连接的机器数目较多，且多台机器经常需要同时通信，那么将导致信息碰撞，使得集线器的工作效率很差。比如，一个带宽为10Mb/s的集线器上连接了8台计算机，当这8台计算机同时工作时，每台计算机真正所拥有的带宽为10/8Mb/s = 1.25Mb/s.</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;物理层的基本概念&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#物理层的基本概念&quot;&gt;&lt;/a&gt;物理层的基本概念&lt;/h2&gt;
&lt;p&gt;物理层解决如何在连接各种计算机的传输媒体上&lt;font color=&quot;#FF666&quot;&gt;传输数据比特流&lt;/font&gt;，而不</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://halo123.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://halo123.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络体系结构</title>
    <link href="http://halo123.top/2021/04/22/ComputerNetworks/A_LayeredArchitecture/"/>
    <id>http://halo123.top/2021/04/22/ComputerNetworks/A_LayeredArchitecture/</id>
    <published>2021-04-22T14:09:39.308Z</published>
    <updated>2021-04-22T14:24:51.844Z</updated>
    
    <content type="html"><![CDATA[<h1>计算机网络概述</h1><h2 id="1-计算机网络的概念"><a class="header-anchor" href="#1-计算机网络的概念"></a>1 计算机网络的概念</h2><p>计算机网络：是一个将分散的、具有独立功能的<font color="#FF666">计算机系统</font>，通过<font color="#FF666">通信设备</font>与<font color="#FF666">线路</font>连接起来，由功能完善的<font color="#FF666">软件</font>实现<font color="#FF666">资源共享</font>和<font color="#FF666">信息传递</font>的系统。</p><p>简而言之，计算机网络就是一些<font color="#e03e3e">互联</font>的、<font color="#e03e3e">自治</font>的计算机系统的集合。（互联：互联互通；自治：无主从关系）</p><h2 id="2-计算机网络的功能"><a class="header-anchor" href="#2-计算机网络的功能"></a>2 计算机网络的功能</h2><h3 id="font-color-d9730d-数据通信-font"><a class="header-anchor" href="#font-color-d9730d-数据通信-font"></a><font color="#d9730d">数据通信</font></h3><p>它是计算机网络最基本和最重要的功能，用来实现联网计算机之间的各种信息的传输，并将将分散在不同地理位置的计算机联系起来，进行统一的调配、控制和管理。比如，文件传输、电子邮件等应用，离开了计算机网络将无法实现。</p><h3 id="font-color-d9730d-资源共享-font"><a class="header-anchor" href="#font-color-d9730d-资源共享-font"></a><font color="#d9730d">资源共享</font></h3><p>资源共享可以是软件共享、数据共享，也可以是硬件共享。使计算机网络中的资源互通有无分工协作，从而极大地提高硬件资源、软件资源和数据资源的利用率</p><h3 id="分布式处理"><a class="header-anchor" href="#分布式处理"></a>分布式处理</h3><p>当计算机网络中的某个计算机系统负荷过重时，可以将其处理的某个复杂任务分配给网络中的其他计算机系统，从而利用空闲计算机资源以提高整个系统的利用率。</p><h3 id="提高可靠性"><a class="header-anchor" href="#提高可靠性"></a>提高可靠性</h3><p>计算机网络中的各台计算机可以通过网络互为替代机。</p><h3 id="负载均衡"><a class="header-anchor" href="#负载均衡"></a>负载均衡</h3><p>将工作任务均衡地分配给计算机网络中的各台计算机。</p><hr><p>除以上几大主要功能外，计算机网络还可以实现电子化办公与服务、远程教育、娱乐等功能，满足了社会的需求，方便了人们学习、工作和生活，具有巨大的经济效益。</p><h2 id="3-计算机网络的组成"><a class="header-anchor" href="#3-计算机网络的组成"></a>3 计算机网络的组成</h2><h3 id="组成部分上来看"><a class="header-anchor" href="#组成部分上来看"></a>组成部分上来看</h3><p>一个完整的计算机网络主要由硬件、软件、协议三大部分组成，缺一不可。</p><ul><li>硬件主要由主机（也称端系统）、通信链路（如双绞线、光纤）、交换设备（如路由器、交换机等）和通信处理机（如网卡）等组成。</li><li>软件主要包括各种实现资源共享的软件和方便用户使用的各种工具软件（如网络操作系统、邮件收发程序、FTP程序、聊天程序等）。软件部分多属于应用层。</li><li><font color="#faa755">协议是计算机网络的核心</font>，如同交通规则制约汽车驾驶一样，协议规定了网络传输数据时所遵循的规范。</li></ul><h3 id="font-color-d9730d-从工作方式上看-font"><a class="header-anchor" href="#font-color-d9730d-从工作方式上看-font"></a><font color="#d9730d">从工作方式上看</font></h3><p>计算机网络（这里主要指 internet）可分为边缘部分和核心部分。</p><ul><li>边缘部分由所有连接到因特网上、供用户直接使用的主机组成，用来进行通信（如传输数据、音频或视频）和资源共享；（C/S方式和P2P方式）</li><li>核心部分由大量的网络和连接这些网络的路由器组成，它为边缘部分提供连通性和交换服务。</li></ul><p>图1.1给出了这两部分的示意图。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9B%A0%E7%89%B9%E7%BD%91%E7%9A%84%E6%A0%B8%E5%BF%83%E9%83%A8%E5%88%86%E4%B8%8E%E8%BE%B9%E7%BC%98%E9%83%A8%E5%88%86.png" alt="因特网的核心部分与边缘部分" style="object-fit: cover; border-radius: 10px; width: 80%; " /><h3 id="font-color-d9730d-从功能组成上看-font"><a class="header-anchor" href="#font-color-d9730d-从功能组成上看-font"></a><font color="#d9730d">从功能组成上看</font></h3><p>计算机网络由通信子网和资源子网组成。</p><ul><li>通信子网由各种传输介质、通信设备和相应的网络协议组成，它使网络具有数据传输、交换、控制和存储的能力，实现联网计算机之间的<font color="#faa755">数据通信</font>。</li><li>资源子网是实现<font color="#faa755">资源共享</font>功能的设备及其软件的集合，向网络用户提供共享其他计算机上的硬件资源、软件资源和数据资源的服务。</li></ul><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%B5%84%E6%BA%90%E5%AD%90%E7%BD%91%E5%92%8C%E9%80%9A%E4%BF%A1%E5%AD%90%E7%BD%91.png" alt="资源子网和通信子网" style="object-fit: cover; border-radius: 10px; width: 80%;" /><h2 id="4-计算机网络的分类"><a class="header-anchor" href="#4-计算机网络的分类"></a>4 计算机网络的分类</h2><h3 id="按分布范分类"><a class="header-anchor" href="#按分布范分类"></a>按分布范分类</h3><ul><li>广域网（WAN）。广域网的任务是提供长距离通信，运送主机所发送的数据，其覆盖范围通常为几十千米到几千千米的区域，因而有时也称远程网。广域网是因特网的核心部分。连接广域网的各结点交换机的链路一般都是高速链路，具有较大的通信容量。（交换技术）</li><li>城域网（MAN）。城域网的覆盖范围可以跨越几个街区甚至整个城市，覆盖范围约为5~50km。城域网大多采用以太网技术，因此有时也常并入局域网的范围进行讨论。</li><li>局域网（LAN）。局域网一般用微机或工作站通过高速线路相连，覆盖范围较小，通常为几十米到几千米的区域。局域网在计算机配置的数量上没有太多的限制，少的可以只有两台，多的可达几百台。传统上，局域网使用广播技术，而广域网使用交换技术。（广播技术）</li><li>个人区域网（PAN）。个人区域网是指在个人工作的地方将消费电子设备（如平板电脑、智能手机等）用无线技术连接起来的网络，也常称为无线个人区域网（WPAN），其覆盖的区域直径约为10m。</li></ul><blockquote><p>:bulb: 注意：若中央处理器之间的距离非常近（如仅1m的数量级或甚至更小），则一般就称之为多处理器系统，而不称它为计算机网络。</p></blockquote><h3 id="按使用者分类"><a class="header-anchor" href="#按使用者分类"></a>按使用者分类</h3><ul><li>公用网（ Public network）。指电信公司出资建造的大型网络。“公用”的意思是指所有愿意按电信公司的规定交纳费用的人都可以使用这种网络，因此也称公众网。</li><li>专用网（ Private Network）。指某个部门为满足本单位特殊业务的需要而建造的网络。这种网络不向本单位以外的人提供服务。例如铁路、电力、军队等部门的专用网。</li></ul><h3 id="按交换技术分类"><a class="header-anchor" href="#按交换技术分类"></a>按交换技术分类</h3><p>交换技术是指各台主机之间、各通信设备之间或主机与通信设备之间为交换信息所采用的数据格式和交换装置的方式。</p><p>按交换技术可将网络分为如下几种</p><ul><li><p>电路交换网络。在源结点和目的结点之间建立一条专用的通路用于传送数据，包括建立连接、传输数据和断开连接三个阶段。最典型的电路交换网是传统电话网络。</p><blockquote><p>该类网络的主要特点是整个报文的比特流连续地从源点直达终点，好像是在一条管道中传送。优点是数据直接传送、时延小。缺点是线路利用率低、不能充分利用线路容量、不便于进行差错控制</p></blockquote></li><li><p>报文交换网络。用户数据加上源地址、目的地址、校验码等辅助信息，然后封装成报文整个报文传送到相邻结点，全部存储后，再转发给下一个结点，重复这一过程直到到达目的结点。每个报文可以单独选择到达目的结点的路径。</p><blockquote><p>报文交换网络。用户数据加上源地址、目的地址、校验码等辅助信息，然后封装成报文整个报文传送到相邻结点，全部存储后，再转发给下一个结点，重复这一过程直到到达目的结点。每个报文可以单独选择到达目的结点的路径。</p></blockquote></li><li><p>分组交换网络，也称包交换网络。其原理是将数据分成较短的固定长度的数据块，在每个数据块中加上目的地址、源地址等辅助信息组成分组（包），以存储-转发方式传输其主要特点是单个分组（它只是整个报文的一部分）传送到相邻结点，存储后查找转发表，转发到下一个结点。除具备报文交换网络的优点外，分组交换网络还具有自身的优点：缓冲易于管理；包的平均时延更小，网络占用的平均缓冲区更少；更易于标准化；更适合应用。现在的主流网络基本上都可视为分组交换网络。</p></li></ul><h3 id="按拓扑结构分类"><a class="header-anchor" href="#按拓扑结构分类"></a>按拓扑结构分类</h3><p>网络拓扑结构是指由网中结点（路由器、主机等）与通信线路（网线）之间的几何关系（如总线形、环形）表示的网络结构，主要指通信子网的拓扑结构按网络的拓扑结构，主要分为总线形、星形、环形和网状形网络等。</p><p>星形、总线形和环形网络多用于局域网，网状形网络多用于广域网。</p><h3 id="按传输介质分类"><a class="header-anchor" href="#按传输介质分类"></a>按传输介质分类</h3><p>传输介质可分为有线和无线两大类，因此网络可以分为有线网络和无线网络。有线网络又分为双绞线网络、同轴电缆网络等。无线网络又可分为蓝牙、微波、无线电等类型</p><h3 id="按传输技术分类"><a class="header-anchor" href="#按传输技术分类"></a>按传输技术分类</h3><ul><li>广播式网络。所有联网计算机都共享一个公共通信信道。当一台计算机利用共享通信信道发送报文分组时，所有其他的计算机都会“收听”到这个分组。接收到该分组的计算机将通过检查目的地址来决定是否接收该分组局域网基本上都采用广播式通信技术，广域网中的无线、卫星通信网络也采用广播式通信技术。</li><li>点对点网络。每条物理线路连接一对计算机。如果通信的两台主机之间没有直接连接的线路，那么它们之间的分组传输就要通过中间结点的接收、存储和转发，直至目的结点。</li></ul><p><font color="#e03e3e">是否采用分组存储转发与路由选择机制是点对点式网络与广播式网络的重要区别</font>，广域网基本都属于点对点网络。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%E7%AC%AC1%E8%8A%82%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.svg" alt="第一节思维导图" style="object-fit: cover; border-radius: 10px; width: 100%;"/><h2 id="5-计算机网络的标准化工作"><a class="header-anchor" href="#5-计算机网络的标准化工作"></a>5 计算机网络的标准化工作</h2><h3 id="标准的分类"><a class="header-anchor" href="#标准的分类"></a>标准的分类</h3><ol><li>法定标准，由权威机构制定的正式的、合法的标准（OSI）</li><li>事实标准，某些公司的产品在竞争中占据了主流，时间长了，这些产品中的协议和技术就成了标准（TCP/IP）</li></ol><p>计算机网络的标准化对计算机网络的发展和推广起到了极为重要的作用。</p><p>因特网的所有标准都以RFC（ Request For Comments）的形式在因特网上发布，但并非每个RFC都是因特网标准，RFC要上升为因特网的正式标准需经过以下4个阶段</p><ol><li>因特网草案（ Internet Draft）。这个阶段还不是RFC文档。</li><li>建议标准（ Proposed Standard）。从这个阶段开始就成为RFC文档。</li><li>草案标准（ Draft Standard）。</li><li>因特网标准（ Internet Standard）</li></ol><p>此外，还有实验的RFC和提供信息的RFC。各种RFC之间的关系如图1.3所示。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%90%84%E7%A7%8DRFC%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="各种RFC之间的关系" style="object-fit: cover; border-radius: 10px; width: 80%;" /><p>在国际上，负责制定、实施相关网络标准的标准化组织众多，主要有如下几个</p><ul><li>国际标准化组织（ISO）。制定的主要网络标准或规范有OSI参考模型、HDLC等。</li><li>国际电信联盟（ITU）。其前身为国际电话电报咨询委员会（CCITT），其下属机构ITU-T制定了大量有关远程通信的标准。</li><li>国际电气电子工程师协会（IEEE）。世界上最大的专业技术团体，由计算机和工程学专业人士组成。IEEE在通信领域最著名的研究成果是802标准</li></ul><h2 id="6-计算机网络的性能指标"><a class="header-anchor" href="#6-计算机网络的性能指标"></a>6 计算机网络的性能指标</h2><h3 id="速率-Speed"><a class="header-anchor" href="#速率-Speed"></a>速率(Speed)</h3><p>网络中的速率是指连接到计算机网络上的主机在数字信道上传送数据的速率，也称数据率或比特率，单位为b/s（比特秒）（或bit/s，有时也写为bps）。数据率较高时，可用kb/s（k=10<sup>3</sup>​）、Mbs（M=10<sup>5</sup>）或Gbs（G=10<sup>9</sup>）表示。在计算机网络中，通常把最高数据率称为带宽。</p><h3 id="带宽-Bandwidth"><a class="header-anchor" href="#带宽-Bandwidth"></a>带宽(Bandwidth)</h3><p>本来表示通信线路允许通过的信号频带范围，单位是赫兹（Hz）。而在计算机网络中，带宽表示网络的通信线路所能传送数据的能力，是数字信道所能传送的“<font color="#faa755">最高数据率</font>”的同义语，单位是比特/秒（bs）。</p><h3 id="吞吐量-Throughput"><a class="header-anchor" href="#吞吐量-Throughput"></a>吞吐量(Throughput)</h3><p>指<font color="#faa755">单位时间</font>内通过某个网络（或信道、接口）的数据量。吞吐量受网络带宽或网络额定速率的限制。</p><h3 id="时延-Delay"><a class="header-anchor" href="#时延-Delay"></a>时延(Delay)</h3><p>指数据（一个报文或分组）从网络（或链路）的一端传送到另一端所需要的总时间，它由4部分构成：发送时延、传播时延、处理时延和排队时延。</p><ul><li><p>发送时延。结点将分组的所有比特推向（传输）链路所需的时间，即从发送分组的第一个比特算起，到该分组的最后一个比特发送完毕所需的时间，因此也称传输时延。</p><blockquote><p>计算公式为：发送时延=分组长度/信道宽度(发送速率)</p></blockquote></li><li><p>传播时延。电磁波在信道中传播一定的距离需要花费的时间，即一个比特从链路的端传播到另一端所需的时间。</p><blockquote><p>计算公式为：传播时延=信道长度/电磁波在信道上的传播速率</p></blockquote></li><li><p>处理时延。数据在交换结点为存储转发而进行的一些必要的处理所花费的时间。例如，分析分组的首部、从分组中提取数据部分、进行差错检验或査找适当的路由等。</p></li><li><p>排队时延。分组在进入路由器后要先在输入队列中排队等待处理。路由器确定转发端口后，还要在输出队列中排队等待转发，这就产生了排队时延。</p></li></ul><p>因此，数据在网络中经历的总时延就是以上4部分时延之和：<font color="#faa755">总时延=发送时延+传播时延+处理时延+排队时延</font></p><blockquote><p>:bulb: 注意：做题时，排队时延和处理时延一般可忽略不计（除非题目另有说明）。另外，<font color="#faa755">对于高速链路，提高的仅是数据发送速率而非比特在链路上的传播速率</font>。提高数据的发送速率只是为了减少数据的发送时延</p></blockquote><p>类比车站机场安检过程</p><h3 id="时延带宽积"><a class="header-anchor" href="#时延带宽积"></a>时延带宽积</h3><p>指发送端发送的第一个比特即将到达终点时，发送端已经发出了多少个比特，因此又称以比特为单位的链路长度，即<font color="#faa755">时延带宽积=传播时延×信道带宽</font>。 考虑—个代表链路的圆柱形管道，其长度表示链路的传播时延，横截面积表示链路带宽，则时延带宽积表示该管道可以容纳的比特数量。以比特为单位的链路长度，即“某端链路现在有多少比特”（容量）</p><h3 id="往返时延-Round-Trip-Time-RTT"><a class="header-anchor" href="#往返时延-Round-Trip-Time-RTT"></a>往返时延(Round-Trip Time,RTT)</h3><p>指从发送端发送数据开始，到发送端收到来自接收端的确认(接收端收到数据后立即发送确认)，总共经历的时延。在互联网中，往返时延还包括各中间结点的处理时延、排队时延及转发数据时的发送时延。RTT越大，在收到确认之前，可以发送的数据越多。</p><h3 id="信道利用率"><a class="header-anchor" href="#信道利用率"></a>信道利用率</h3><p>指出某一信道有百分之多少的时间是有数据通过的，即<font color="#faa755">信道利用率 = 有数据通过时间/(有+无)数据通过时间</font>。</p><p>网络利用率：信道利用率加权平均值</p><h1>计算机网络体系结构与参考模型</h1><h2 id="1-计算机网络分层结构"><a class="header-anchor" href="#1-计算机网络分层结构"></a>1 计算机网络分层结构</h2><h3 id="为什么要分层"><a class="header-anchor" href="#为什么要分层"></a>为什么要分层</h3><p>对于发送文件前要完成的工作:</p><ol><li>发起通信的计算机必须将数据通信的通路进行激活。</li><li>要告诉网络如何识别目的主机。</li><li>发起通信的计算机要查明目的主机是否开机，并且与网络连接正常。</li><li>发起通信的计算机要弄清楚，对方计算机中文件管理程序是否已经做好准备工作。</li><li>确保差错和意外可以解决。</li></ol><p>两个系统中实体间的通信是一个很复杂的过程，为了降低协议设计和调试过程的复杂性，也为了便于对网络进行研究、实现和维护，促进标准化工作，通常对计算机网络的体系结构以分层的方式进行建模。</p><h3 id="分层的基本原则"><a class="header-anchor" href="#分层的基本原则"></a>分层的基本原则</h3><p>我们把计算机网络的各层及其协议的集合称为<font color="#ea66a6">网络的体系结构</font>(Architecture)。 换言之，计算机网络的体系结构就是这个计算机网络及其所应完成的<font color="#faa755">功能</font>的精确定义，它是计算机网络中的层次、各层的协议及层间接口的集合。需要强调的是，这些功能究竟是用何种硬件或软件完成的，则是一个遵循这种体系结构的实现（Implementation）问题。体系结构是抽象的，而实现是具体的，是真正在运行的计算机硬件和软件。。</p><p>计算机网络的体系结构通常都具有可分层的特性，它将复杂的大系统分成若干较容易实现的层次。分层的基本原则如下：</p><ol><li>每层都实现一种相对<font color="#faa755">独立</font>的功能，降低大系统的复杂度。</li><li>各层之间<font color="#faa755">界面自然清晰</font>，易于理解，相互交流尽可能少。</li><li>各层功能的精确定义独立于具体的实现方法，可以采用<font color="#faa755">最合适的技术</font>来实现。</li><li>保持<font color="#faa755">下层对上层的独立性</font>，<font color="#faa755">上层单向使用下层提供的服务</font>。</li><li>整个分层结构应能促进标准化工作。</li></ol><p>由于分层后各层之间相对独立，灵活性好，因而分层的体系结构易于更新(替换单个模块)，易于调试，易于交流，易于抽象，易于标准化。但<font color="#0f7b6c">层次越多</font>，有些功能在不同层中难免重复出现，产生额外的开销，导致整体运行效率越低。<font color="#0f7b6c">层次越少</font>，就会使每层的协议太复杂。因此，在分层时应考虑层次的清晰程度与运行效率间的折中、层次数量的折中。</p><h3 id="计算机网络层次结构"><a class="header-anchor" href="#计算机网络层次结构"></a>计算机网络层次结构</h3><p>依据一定的规则，将分层后的网络从低层到高层依次称为第1层、第2.层…第n层，通常还为每层取一个特定的名称，如第1层的名称为<font color="#faa755">物理层</font>。</p><p>在计算机网络的分层结构中，第n层中的活动元素通常称为n层实体。具体来说，<font color="#ea66a6">实体</font>指任何可发送或接收信息的硬件或软件进程，通常是一个特定的软件模块。不同机器上的同一层称为对等层，同一层的实体称为<font color="#ea66a6">对等实体</font>。n层实体实现的服务为 n+ 1 层所利用。在这种情况下，n层被称为服务提供者，n+1 层则服务于用户。</p><p>每一层还有自己传送的数据单位，其名称、大小、含义也各有不同。</p><p>在计算机网络体系结构的各个层次中，每个报文都分为两部分：一是<font color="#faa755">数据部分</font>， 即SDU；二是<font color="#faa755">控制信息部分</font>，即PCI，它们共同组成PDU。</p><ul><li><font color="#ea66a6">服务数据单元</font>(SDU)：为完成用户所要求的功能而应传送的数据。第n层的服务数据单元记为n-SDU。</li><li><font color="#ea66a6">协议控制信息</font>(PCI)：控制协议操作的信息。第n层的协议控制信息记为n-PCI。</li><li><font color="#ea66a6">协议数据单元</font>(PDU)：对等层次之间传送的数据单位称为该层的PDU。第n层的协议数据单元记为n-PDU。在实际的网络中，每层的协议数据单元都有一个通俗的名称，如物理层的PDU称为比特，链路层的PDU称为帧，网络层的PDU称为分组，传输层的PDU称为报文。</li></ul><p>在各层间传输数据时，把从第n+1层收到的PDU作为第n层的SDU，加上第n层的PCI，就变成了第n层的PDU，交给第n-1层后作为SDU发送，接收方接收时做相反的处理，因此可知三者的关系为n-SDU + n-PCI= n-PDU= (n-1)-SDU，其变换过程如图1.5所示。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E6%95%B0%E6%8D%AE%E5%8D%95%E5%85%83%E7%9A%84%E8%81%94%E7%B3%BB.png" alt="网络各层数据单元的联系" style="object-fit: cover; border-radius: 10px; width: 80%;" /><p>具体地，层次结构的含义包括以下几方面：</p><ol><li>第 n 层的实体不仅要使用第 n-1 层的服务来实现自身定义的功能，还要向第 n+1 层提供本层的服务，该服务是第 n 层及其下面各层提供的服务总和。</li><li>最低层只提供服务，是整个层次结构的基础；中间各层既是下一层的服务使用者，又是上一层的服务提供者；最高层面向用户提供服务。</li><li>上一层只能通过相邻层间的接口使用下一层的服务，而不能调用其他层的服务；下一层所提供服务的实现细节对上一层透明。</li><li>两台主机通信时，对等层在逻辑上有一条直接信道，表现为不经过下层就把信息传送到对方。</li></ol><h3 id="概念总结"><a class="header-anchor" href="#概念总结"></a>概念总结</h3><ol><li>网络体系结构是从功能上描述计算机网络结构。</li><li>计算机网络体系结构简称网络体系结构是分层结构。</li><li>每层遵循某个/些网络协议以完成本层功能。</li><li>计算机网络体系结构是计算机网络的各层及其协议的集合。</li><li>第 n 层在向 n+1 层提供服务时，此服务不仅包含第 n 层本身的功能，还包含由下层服务提供的功能。</li><li>仅仅在相邻层间有接口，且所提供服务的具体实现细节对上一层完全屏蔽。</li><li>体系结构是抽象的，而实现是指能运行的一些软件和硬件。</li></ol><h2 id="2-计算机网络协议、接口、服务的概念"><a class="header-anchor" href="#2-计算机网络协议、接口、服务的概念"></a>2 计算机网络协议、接口、服务的概念</h2><h3 id="协议"><a class="header-anchor" href="#协议"></a>协议</h3><p>协议，就是规则的集合。在网络中要做到有条不紊地交换数据，就必须遵循一些事先约定好的规则。这些规则明确规定了所交换的数据的格式及有关的同步问题。这些为进行网络中的数据交换而建立的规则、标准或约定称为网络协议（ Network Protocol ），它是控制两个(或多个)对等实体进行通信的规则的集合，是<font color="#e03e3e">水平</font>的。不对等实体之间是没有协议的，比如用 TCP/IP 协议栈通信的两个结点，结点A的传输层和结点 B 的传输层之间存在协议，但结点A的传输层和结点B的网络层之间不存在协议。网络协议也简称为协议。</p><p>协议由语法、语义和同步三部分组成。</p><ul><li>语法：规定了传输数据的格式；</li><li>语义：规定了所要完成的功能，即需要发出何种控制信息、完成何种动作及做出何种应答；</li><li>同步：规定了执行各种操作的条件、时序关系等，即事件实现顺序的详细说明。</li></ul><p>一个完整的协议通常应具有线路管理(建立、释放连接)、差错控制、数据转换等功能。</p><h3 id="接口"><a class="header-anchor" href="#接口"></a>接口</h3><p>接口是同一结点内相邻两层间交换信息的连接点，是一个系统内部的规定。每层只能为紧邻的层次之间定义接口，不能跨层定义接口。在典型的接口上，同一结点相邻两层的实体通过服务访问点（Service Access Point，SAP）进行交互。服务是通过 SAP 提供给上层使用的，第 n 层的 SAP 就是第 n+1 层可以访问第 n 层服务的地方（上层使用下层服务的入口，下层为上层提供的接口）。每个 SAP 都有一个能够标识它的地址。SAP 是一个抽象的概念，它实际上是一个逻辑接口（类似于邮政信箱），但和通常所说的两个设备之间的硬件接口是很不一样的。</p><h3 id="服务"><a class="header-anchor" href="#服务"></a>服务</h3><p>服务是指下层为紧邻的上层提供的功能调用（单向），它是<font color="#e03e3e">垂直</font>的。对等实体在协议的控制下，使得本层能为上一层提供服务，但要实现本层协议还需要使用下一层所提供的服务。</p><p>上层使用下层所提供的服务时必须与下层交换一些命令，这些命令在OSI中称为服务原语。</p><p>OSI将原语划分为4类:</p><ol><li>请求(Request)。 由服务用户发往服务提供者，请求完成某项工作。</li><li>指示( Indication)。由服务提供者发往服务用户，指示用户做某件事情。</li><li>响应(Response)。 由服务用户发往服务提供者，作为对指示的响应。</li><li>证实(Confirmation)。由服务提供者发往服务用户，作为对请求的证实。</li></ol><p>这4类原语用于不同的功能，如建立连接、传输数据和断开连接等。有应答服务包括全部4类原语，而无应答服务则只有请求和指示两类原语。</p><p>一定要注意，协议和服务在概念上是不一样的。</p><ul><li>首先，只有本层协议的实现才能保证向上一层提供服务。本层的服务用户只能看见服务而无法看见下面的协议，即下面的协议对上层的服务用户是透明的。</li><li>其次，协议是“水平的”，即协议是控制对等实体之间通信的规则。但服务是“垂直的”，即服务是由下层通过层间接口向上层提供的。</li><li>另外，并非在一层内完成的全部功能都称为服务，只有那些能够被高一层实体 “看得见”的功能才称为服务。</li></ul><p>协议、接口、服务三者之间的关系如图1.7所示。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%8D%8F%E8%AE%AE%E3%80%81%E6%8E%A5%E5%8F%A3%E3%80%81%E6%9C%8D%E5%8A%A1%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="协议、接口、服务三者之间的关系" style="object-fit: cover; border-radius: 10px; width: 80%;" /><hr><p>计算机网络提供的服务可按以下三种方式分类。</p><h4 id="面向连接服务与无连接服务"><a class="header-anchor" href="#面向连接服务与无连接服务"></a>面向连接服务与无连接服务</h4><p>在面向连接服务中，通信前双方必须先建立连接，分配相应的资源（如缓冲区），以保证通信能正常进行，传输结束后释放连接和所占用的资源。因此这种服务可以分为连接建立、数据传输和连接释放三个阶段。例如TCP就是一种面向连接服务的协议。</p><p>在无连接服务中，通信前双方不需要先建立连接，需要发送数据时可直接发送，把每个带有目的地址的包（报文分组）传送到线路上，由系统选定路线进行传输。这是一种不可靠的服务。这种服务常被描述为“尽最大努力交付”（Best-Effort-Delivery），它并不保证通信的可靠性。例如IP、UDP就是一种无连接服务的协议。</p><h4 id="可靠服务和不可靠服务"><a class="header-anchor" href="#可靠服务和不可靠服务"></a>可靠服务和不可靠服务</h4><p>可靠服务是指网络具有纠错、检错、应答机制，能保证数据正确、可靠地传送到目的地。不可靠服务是指网络只是尽量正确、可靠地传送，而不能保证数据正确、可靠地传送到目的地，是一种尽力而为的服务。</p><p>对于提供不可靠服务的网络，其网络的正确性、可靠性要由应用或用户来保障。例如，用户收到信息后要判断信息的正确性，如果不正确，那么用户要把出错信息报告给信息的发送者，以便发送者采取纠正措施。通过用户的这些措施，可以把不可靠的服务变成可靠的服务。</p><blockquote><p>注意：在一层内完成的全部功能并非都称之为服务，只有那些能够被高一层实体“看得见”的功能才能称为服务。</p></blockquote><h4 id="有应答服务和无应答服务"><a class="header-anchor" href="#有应答服务和无应答服务"></a>有应答服务和无应答服务</h4><p>有应答服务是指接收方在收到数据后向发送方给出相应的应答，该应答由传输系统内部自动实现，而不由用户实现。所发送的应答既可以是肯定应答，也可以是否定应答，通常在接收到的数据有错误时发送否定应答。例如，文件传输服务就是一种有应答服务。</p><p>无应答服务是指接收方收到数据后不自动给出应答。若需要应答，则由高层实现。例如，对于WWW服务，客户端收到服务器发送的页面文件后不给出应答。</p><h2 id="3-ISO-OSI参考模型"><a class="header-anchor" href="#3-ISO-OSI参考模型"></a>3 ISO/OSI参考模型</h2><p>国际标准化组织（ISO）提出的网络体系结构模型，称为开放系统互连参考模型（OSI/ RM）,通常简称为OSI参考模型。OSI有7层，自下而上依次为物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p><ul><li>高三层统称为<font color="#FF666">资源子网</font>，它相当于计算机系统，完成<font color="#faa755">数据的处理</font>等功能。</li><li>传输层承上启下。</li><li>低三层统称为<font color="#FF666">通信子网</font>，它是为了联网而附加的通信设备，完成<font color="#faa755">数据的传输</font>功能；</li></ul><p>OSI的层次结构如图1.8所示。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSI%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" alt="OSI的层次结构" style="object-fit: cover; border-radius: 10px; width: 100%;" /><p>下面详述OSI参考模型各层的功能。</p><h3 id="应用层（Application-Layer）"><a class="header-anchor" href="#应用层（Application-Layer）"></a>应用层（Application Layer）</h3><p>应用层是 OSI 模型的最高层，是用户与网络的界面。应用层为特定类型的网络应用提供访问 OSI 环境的手段。因为用户的实际应用多种多样，这就要求应用层采用不同的应用协议来解决不同类型的应用要求，因此应用层是最复杂的一层，使用的协议也最多。典型的协议有用于文件传：送的FTP、用于电子邮件的SMTP、用于万维网的HTTP等。</p><h3 id="表示层（Presentation-Layer）"><a class="header-anchor" href="#表示层（Presentation-Layer）"></a>表示层（Presentation Layer）</h3><p>表示层主要处理在两个通信系统中交换信息的表示方式。不同机器采用的编码和表示方法不同，使用的数据结构也不同。为了使不同表示方法的数据和信息之间能互相交换，表示层采用抽象的标准方法定义数据结构，并采用标准的编码形式。数据压缩、加密和解密也是表示层可提供的数据表示变换功能。</p><p>功能一：数据格式变换</p><p>功能二：数据加密解密</p><p>功能三：数据压缩和恢复</p><h3 id="会话层（Session-Layer）"><a class="header-anchor" href="#会话层（Session-Layer）"></a>会话层（Session Layer）</h3><p>会话层允许不同主机上的各个进程之间进行会话。会话层利用传输层提供的端到端的服务，向表示层提供它的增值服务。这种服务主要为表示层实体或用户进程建立连接并在连接上有序地传输数据，这就是会话，也称建立同步（SYN）。</p><p>会话层负责管理主机间的会话进程，包括建立、管理及终止进程间的会话。会话层可以使用校验点使通信会话在通信失效时从校验点继续恢复通信，实现数据同步。</p><p>功能一：建立、管理、终止会话</p><p>功能二：使用校验点可使会话在通信失效时从校验点/同步点继续恢复通信，实现数据同步。</p><h3 id="传输层（Transport-Layer）"><a class="header-anchor" href="#传输层（Transport-Layer）"></a>传输层（Transport Layer）</h3><p>传输层也称运输层，传输单位是报文段（TCP） 或用户数据报（UDP），传输层负责主机中两个进程之间的通信，功能是为端到端连接提供可靠的传输服务，为端到端连接提供流量控制、差错控制、服务质量、数据传输管理等服务。</p><p>数据链路层提供的是点到点的通信，传输层提供的是端到端的通信，两者不同。</p><p>通俗地说，点到点可以理解为主机到主机之间的通信，一个点是指一个硬件地址或IP地址，网络中参与通信的主机是通过硬件地址或IP地址标识的；端到端的通信是指运行在不同主机内的两个进程之间的通信，一个进程由一个端口来标识，所以称端到端通信。</p><p>使用传输层的服务，高层用户可以直接进行端到端的数据传输，从而忽略通信子网的存在。通过传输层的屏蔽，高层用户看不到子网的交替和变化。由于一台主机可同时运行多个进程，因此传输层具有复用和分用的功能。复用是指多个应用层进程可同时使用下面传输层的服务，分用是指传输层把收到的信息分别交付给上面应用层中相应的进程。</p><p>传输层的协议有TCP、UDP。</p><p>功能一：可靠传输、不可靠传输</p><p>功能二：差错控制</p><p>功能三：流量控制</p><p>功能四：复用分用</p><h3 id="网络层（Network-Layer）"><a class="header-anchor" href="#网络层（Network-Layer）"></a>网络层（Network Layer）</h3><p>主要任务是把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务。网络层传输单位是数据报。（分组是对数据报进行分割后的结果）</p><p>它关心的是通信子网的运行控制，主要任务是把网络层的协议数据单元（分组）从源端传到目的端，为分组交换网上的不同主机提供通信服务。关键问题是对分组进行路由选择，并实现流量控制、拥塞控制、差错控制和网际互联等功能。</p><p>如图1.10所示，结点A向结点B传输一个分组时，既可经过边a、c、g,也可经过边b、h，有很多条可以选择的路由，而网络层的作用就是根据网络的情况，利用相应的路由算法计算出一条合适的路径,使这个分组可以顺利到达结点B。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%9F%90%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="某网络结构图" style="object-fit: cover; border-radius: 10px; width: 80%;" /><p>流量控制与数据链路层的流量控制含义一样，都是协调 A 的发送速率和 B 的接收速率。</p><p>差错控制是通信两结点之间约定的特定检错规则，如奇偶校验码，接收方根据这个规则检查接收到的分组是否出现差错，如果出现了差错，那么能纠错就纠错，不能纠错就丢弃，确保向上层提交的数据都是无误的。</p><p>如果图1.9中的结点都处于来不及接收分组而要丢弃大量分组的情况，那么网络就处于拥塞状态，拥塞状态使得网络中的两个结点无法正常通信。网络层要采取一定的措施来缓解这种拥塞，这就是拥塞控制。</p><p>因特网是一个很大的互联网，它由大量异构网络通过路由器（Router）相互连接起来。因特网的主要网络层协议是无连接的网际协议（Internet Protocol，IP）和许多路由选择协议，因此因特网的网络层也称网际层或IP层。</p><p>注意，网络层中的“网络”一词并不是我们通常谈及的具体网络，而是在计算机网络体系结构中使用的专有名词。</p><p>网络层的协议有IP、IPX、ICMP、IGMP、ARP、 RARP和OSPF等。</p><p>功能一：路由选择</p><p>功能二：流量控制</p><p>功能三：差错控制</p><p>功能四：拥塞控制</p><h3 id="数据链路层（Data-Link-Layer）"><a class="header-anchor" href="#数据链路层（Data-Link-Layer）"></a>数据链路层（Data Link Layer）</h3><p>数据链路层的传输单位是帧，任务是将网络层传来的IP数据报组装成帧。数据链路层的功能可以概括为成帧、差错控制、流量控制和传输管理等。</p><p>由于外界噪声的干扰，原始的物理连接在传输比特流时可能发生错误。如图1.8 所示，左边结点想向右边结点传输数字0，于是发出了信号A；但传输过程中受到干扰，信号A变成了信号B，而信号B又刚好代表1，右边结点接收到信号B时，就会误以为左边结点传送了数字1，从而发生差错。两个结点之间如果规定了数据链路层协议，那么就可以检测出这些差错，然后把收到的错误信息丢弃，这就是差错控制功能。</p><p>如图1.8 所示，在两个相邻结点之间传送数据时，由于两个结点性能的不同，可能结点A发送数据的速率会比结点B接收数据的速率快,如果不加控制，那么结点B就会丢弃很多来不及接收的正确数据，造成传输线路效率的下降。流量控制可以协调两个结点的速率，使结点A发送数据的速率刚好是结点B可以接收的速率。</p><p>广播式网络在数据链路层还要处理新的问题，即如何控制对共享信道的访问。数据链路层的一个特殊的子层一介 质访问子层，就是专门处理这个问题的。</p><p>典型的数据链路层协议有SDLC、HDLC、PPP、STP和帧中继等。</p><p>功能一：成帧（定义帧的开始和结束）</p><p>功能二：差错控制（帧错、位错）</p><p>功能三：流量控制</p><p>功能四：访问（接入）控制 控制对信道的访问</p><h3 id="物理层（Physical-Layer）"><a class="header-anchor" href="#物理层（Physical-Layer）"></a>物理层（Physical Layer）</h3><p>物理层的传输单位是比特，任务是透明的传输比特流，功能是在物理媒体上为数据端设备透明地传输原始比特流。</p><p>透明传输：指不管所传数据是什么样的比特组合都应当能够在链路上传送。</p><p>物理层主要定义数据终端设备（DTE）和数据通信设备（DCE）的物理与逻辑连接方法，所以物理层协议也称物理层接口标准。由于在通信技术的早期阶段，通信规则称为规程（Procedure），因此物理层协议也称物理层规程。</p><p>物理层接口标准很多，如 EIA-232C、EIA/TIA RS-449、CCITT 的 X.21 等。在计算机网络的复习过程中，不要忽略对各层传输协议的记忆，到了后期，读者对链路层、网络层、传输层和应用层的协议会比较熟悉，但往往容易忽视物理层的协议。</p><p>物理层主要研究以下内容:</p><p>① 通信链路与通信结点的连接需要一些电路接口，物理层规定了这些接口的一些参数，如机械形状和尺寸、交换电路的数量和排列等，例如，笔记本电脑上的网线接口，就是物理层规定的内容之一。</p><p>② 物理层也规定了通信链路上传输的信号的意义和电气特征。例如物理层规定信号A代表数字0，那么当结点要传输数字0时，就会发出信号A，当结点接收到信号A时，就知道自己接收到的实际上是数字0。</p><p>注意，传输信息所利用的一些物理媒体，如双绞线、光缆、无线信道等，并不在物理层协议之内而在物理层协议下面。因此，有人把物理媒体当作第0层。</p><p>功能一：定义接口特性</p><p>功能二：定义传输模式（单工、半双工、双工）</p><p>功能三：定义传输速率</p><p>功能四：比特同步</p><p>功能五：比特编码</p><h2 id="4-TCP-IP模型与OSI参考模型的比较"><a class="header-anchor" href="#4-TCP-IP模型与OSI参考模型的比较"></a>4 TCP/IP模型与OSI参考模型的比较</h2><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%8D%E5%90%8C%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B.png" alt="不同参考模型" style="object-fit: cover; border-radius: 10px; width: 100%;" /><p>OSI参考模型与TCP/IP参考模型相同点</p><ol><li>首先，二者都采取分层的体系结构，将庞大且复杂的问题划分为若干较容易处理的、范围较小的问题，而且分层的功能也大体相似。</li><li>其次，二者都是基于独立的协议栈的概念。</li><li>最后，二者都可以解决异构网络的互联，实现世界上不同厂家生产的计算机之间的通信。</li></ol><p>OSI参考模型与TCP/IP参考模型不同点</p><ol><li>OSI参考模型的最大贡献就是精确定义了三个主要概念：服务、协议和接口，这与现代的面向对象程序设计思想非常吻合。而 TCP/IP 模型在这三个概念上却没有明确区分，不符合软件工程的思想。</li><li>OSI参考模型产生在协议发明之前，没有偏向于任何特定的协议，通用性良好。但设计者在协议方面没有太多经验，不知道把哪些功能放到哪一层更好。TCP/IP模型正好相反，首先出现的是协议，模型实际上是对已有协议的描述，因此不会出现协议不能匹配模型的情况，但该模型不适合于任何其他非TCP/IP的协议栈。</li><li>TCP/IP 模型在设计之初就考虑到了多种异构网的互联问题，并将网际协议（ IP ）作为一个单独的重要层次。OSI 参考模型最初只考虑到用一种标准的公用数据网将各种不同的系统互联。OSI参考模型认识到网际协议 IP 的重要性后，只好在网络层中划分出一个子层来完成类似于 TCP/IP 模型中的 IP 的功能。</li><li>OSI参考模型在网络层支持无连接和面向连接的通信，但在传输层仅有面向连接的通信。而 TCP/IP 模型认为可靠性是端到端的问题，因此它在网际层仅有一种无连接的通信模式，但传输层支持无连接和面向连接两种模式。这个不同点常常作为考查点。</li></ol><blockquote><p>面向连接分为三个阶段，第一是建立连接，在此阶段，发出一个建立连接的请求。只有在连接成功建立之后，才能开始数据传输，这是第二阶段。接着，当数据传输完毕，必须释放连接。而面向无连接没有这么多阶段，它直接进行数据传输。</p></blockquote><p>无连接和面向连接</p><table><thead><tr><th>模型</th><th>ISO/OSI参考模型</th><th>TCP/IP模型</th></tr></thead><tbody><tr><td>网络层</td><td>无连接+面向连接</td><td>无连接</td></tr><tr><td>传输层</td><td>面向连接</td><td>无连接+面向连接</td></tr></tbody></table><p>无论是 OSI 参考模型还是 TCP/IP 模型，都不是完美的，对二者的讨论和批评都很多。OSI 参考模型的设计者从工作的开始，就试图建立一个全世界的计算机网络都要遵循的统一标准。 从技术角度来看，他们希望追求一种完美的理想状态，这也导致基于 OSI 参考模型的软件效率极低。OSI参考模型缺乏市场与商业动力，结构复杂，实现周期长，运行效率低，这是它未能达到预期目标的重要原因</p><p>学习计算机网络时，我们往往采取折中的办法，即综合 OSI 和 TCP/IP 的优点，采用一种如图1.13所示的只有五层协议的体系结构，即我们所熟知的物理层、数据链路层、网络层、传输层和应用层。本书也采用这种体系结构进行讨论。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E7%9A%84%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E5%9E%8B.png" alt="图1.13 网络的五层协议结构模型" style="object-fit: cover; border-radius: 10px; width: 100%;" /><p>最后简单介绍使用通信协议栈进行通信的结点的数据传输过程。每个协议栈的最顶端都是一个面向用户的接口，下面各层是为通信服务的协议。用户传输一个数据报时，通常给出用户能够理解的自然语言，然后通过应用层，将自然语言会转化为用于通信的通信数据。通信数据到达传输层，作为传输层的数据部分（传输层SDU），加上传输层的控制信息（传输层PCI），组成传输层的 PDU ,然后交到网络层，传输层的PDU下放到网络层后，就成为网络层的SDU，然后加上网络层的 PCI ，又组成了网络层的PDU，下放到数据链路层，就这样层层下放，层层包裹，最后形成的数据报通过通信线路传输，到达接收方结点协议栈，接收方再逆向地逐层把“包裹”拆开，然后把收到的数据提交给用户，如下图所示。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E6%A0%88%E7%9A%84%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B%E7%A4%BA%E4%BE%8B.png" alt="图1.14 通信协议栈的通信过程示例" style="object-fit: cover; border-radius: 10px; width: 100%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;计算机网络概述&lt;/h1&gt;
&lt;h2 id=&quot;1-计算机网络的概念&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#1-计算机网络的概念&quot;&gt;&lt;/a&gt;1 计算机网络的概念&lt;/h2&gt;
&lt;p&gt;计算机网络：是一个将分散的、具有独立功能的&lt;font color=&quot;#F</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://halo123.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://halo123.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>处理机调度</title>
    <link href="http://halo123.top/2021/04/22/OperatingSystem/C_ProcessorDispatching/"/>
    <id>http://halo123.top/2021/04/22/OperatingSystem/C_ProcessorDispatching/</id>
    <published>2021-04-22T02:19:05.000Z</published>
    <updated>2021-04-30T10:05:39.932Z</updated>
    
    <content type="html"><![CDATA[<h2 id="调度概念"><a class="header-anchor" href="#调度概念"></a>调度概念</h2><h3 id="调度的基本概念"><a class="header-anchor" href="#调度的基本概念"></a>调度的基本概念</h3><p>在多道程序系统中，进程的数量往往多于处理机的个数，因此进程争用处理机的情况在所难免。处理机调度是对处理机进行<font color="#faa755">分配</font>，即从就绪队列中按照一定的算法(公平、高效)选择一个进程并将处理机分配给它运行，以实现进程并发地执行。</p><p><font color="#faa755">处理机调度是多道程序操作系统的基础，是操作系统设计的核心问题。</font></p><h3 id="调度的层次"><a class="header-anchor" href="#调度的层次"></a>调度的层次</h3><p>一个作业从提交开始直到完成，往往要经历以下三级调度：</p><ol><li><p><font color="#faa755">作业调度</font>。又称高级调度，其主要任务是按一定的原则从外存上处于后备状态的作业中挑选一个(或多个)作业，给它(们)分配内存、输入/输出设备等必要的资源，并<font color="#faa755">建立相应的进程</font>(建立PCB)，以使它(们)<font color="#faa755">获得竞争处理机的权利</font>。简言之，作业调度就是内存与辅存之间的调度。对于每个作业只调入一次、调出一次。多道批处理系统中大多配有作业调度，而其他系统中通常不需要配置作业调度。作业调度的执行频率较低，通常为几分钟一次。</p><blockquote><p>高级调度是辅存(外存)与内存之间的调度。每个作业只调入一次，调出一次。作业调入时会建立相应的PCB，作业调出时才撤销PCB。高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。</p></blockquote></li><li><p>中级调度。又称<font color="#faa755">内存调度</font>，其作用是<font color="#faa755">提高内存利用率</font>和<font color="#faa755">系统吞吐量</font>。为此，应将那些暂时不能运行的进程<font color="#faa755">调至外存等待</font>(虚拟内存)，把此时的进程状态称为<font color="#FF666">挂起态</font>。当它们已具备运行条件且内存又稍有空闲时，由中级调度来决定把外存上的那些已具备运行条件的就绪进程，再重新调入内存，并修改其状态为就绪态，挂在就绪队列上等待。</p><blockquote><p>暂时调到外存等待的进程状态为挂起状态。值得注意的是，PCB并不会一起调到外存，而是会常驻内存。PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。被挂起的进程PCB会被放到的<font color="#faa755">挂起队列</font>中。一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。</p></blockquote><blockquote><p>暂时调到外存等待的进程状态为挂起状态(挂起态，suspend)，挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态。五状态模型→七状态模型</p></blockquote><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%B8%83%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B.png" alt="七状态模型" style="object-fit: cover; border-radius: 10px; width: 100%;" /></li><li><p><font color="#faa755">进程调度</font>。又称低级调度，其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。进程调度是操作系统中<font color="#FF666">最基本的一种调度</font>，在一般的操作系统中都必须配置进程调度。进程调度的<font color="#faa755">频率很高</font>，一般几十毫秒一次。</p></li></ol><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%84%E7%90%86%E6%9C%BA%E7%9A%84%E4%B8%89%E7%BA%A7%E8%B0%83%E5%BA%A6.png" alt="处理机的三级调度" style="object-fit: cover; border-radius: 10px; width: 100%;" /><table><thead><tr><th></th><th>要做什么</th><th>调度发生在</th><th>发生频率</th><th>对进程状态的影响</th></tr></thead><tbody><tr><td>高级调度(作业调度)</td><td>按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程</td><td>外存→内存(面向作业)</td><td>最低</td><td>无→创建态→就绪态</td></tr><tr><td>中级调度(内存调度)</td><td>按照某种规则，从挂起队列中选择合适的进程将其数据调回内存</td><td>外存→内存(面向进程)</td><td>中等</td><td>挂起态→就绪态(阻塞挂起→阻塞态)</td></tr><tr><td>低级调度(进程调度)</td><td>按照某种规则，从就绪队列中选择一个进程为其分配处理机</td><td>内存→CPU</td><td>最高</td><td>就绪态→运行态</td></tr></tbody></table><h3 id="三级调度的联系"><a class="header-anchor" href="#三级调度的联系"></a>三级调度的联系</h3><p>作业调度从外存的后备队列中选择一批作业进入内存，为它们建立进程，这些进程被送入就绪队列，进程调度从就绪队列中选出一个进程，并把其状态改为运行态，把CPU分配给它。</p><p>中级调度是为了提高内存的利用率，系统将那些暂时不能运行的进程挂起来。当内存空间宽松时，通过中级调度选择具备运行条件的进程，将其唤醒。</p><ol><li>作业调度为进程活动做准备，进程调度使进程正常活动起来，中级调度将暂时不能运行的进程挂起，中级调度处于作业调度和进程调度之间。</li><li>作业调度次数少，中级调度次数略多，进程调度频率最高。</li><li>进程调度是最基本的，不可或缺。</li></ol><h2 id="调度的时机、切换与过程"><a class="header-anchor" href="#调度的时机、切换与过程"></a>调度的时机、切换与过程</h2><h3 id="调度的时机"><a class="header-anchor" href="#调度的时机"></a>调度的时机</h3><p>进程调度和切换程序是操作系统内核程序。</p><p><font color="#faa755">需要进行进程调度与切换的情况</font>：</p><ul><li>当前运行的进程<font color="#faa755">主动放弃</font>处理机：进程正常终止；运行过程中发生异常而终止；进程主动请求阻塞(如等待I/O)</li><li>当前运行的进程<font color="#faa755">被动放弃</font>处理机：分给进程的时间片用完；有更紧急的事需要处理(如I/O中断)；有更高优先级的进程进入就绪队列</li></ul><p>请求调度的事件发生后，才可能运行进程调度程序，调度了新的就绪进程后，才会进行进程间的切换。理论上这三件事情应该顺序执行，但在实际设计中，操作系统内核程序运行时，若某时发生了引起进程调度的因素，则不一定能够马上进行调度与切换。</p><p>现代操作系统中，<font color="#faa755">不能进行进程的调度与切换的情况</font>有以下几种：</p><ol><li><p><font color="#faa755">在处理中断的过程中</font>。中断处理过程复杂，在实现上很难做到进程切换，而且中断处理是系统工作的一部分，逻辑上不属于某一进程，不应被剥夺处理机资源。</p></li><li><p><font color="#faa755">进程在操作系统内核程序临界区中</font>。进入临界区后，需要独占式地访问共享数据，理论上必须加锁，以防止其他并行程序进入，在解锁前不应切换到其他进程运行，以加快该共享数据的释放。</p><blockquote><p>临界资源：一个时间段内只允许一个进程使用的资源。各进程需要<font color="#faa755">互斥</font>地访问临界资源</p><p>临界区：访问临界资源的那段代码。</p><p>内核程序临界区一般是用来访问某种内核数据结构的，比如进程的就绪队列(由各就绪进程的PCB组成)</p></blockquote><blockquote><p>如果还没退出内核程序临界区(还没解锁)就进行进程调度，但是进程调度相关的程序也需要访问就绪队列，但此时就绪队列被锁住了，因此又无法顺利进行进程调度，内核程序临界区访问的临界资源如果不尽快释放的话，极有可能<br>影响到操作系统内核的其他管理工作。因此在访问内核程序临界区期间不能进行调度与切换。</p><p>在打印机打印完成之前，进程一直处于临界区内，临界资源不会解锁。但打印机又是慢速设备，此时如果一直不允许进程调度的话就会导致CPU一直空闲，普通临界区访问的临界资源不会直接影响操作系统内核的管理工作。因此在访问普通临界区时可以进行调度与切换。</p></blockquote></li><li><p><font color="#faa755">其他需要完全屏蔽中断的原子操作过程中</font>。如加锁、解锁、中断现场保护、恢复等原子操作。在原子过程中，连中断都要屏蔽，更不应该进行进程调度与切换。</p></li></ol><p>若在上述过程中发生了引起调度的条件，则不能马上进行调度和切换，应置系统的请求调度标志，直到上述过程结束后才进行相应的调度与切换。应该进行进程调度与切换的情况如下：</p><ol><li>发生引起调度条件且当前进程无法继续运行下去时，可以马上进行调度与切换。若操作系统只在这种情况下进行进程调度，则是<font color="#faa755">非剥夺调度</font>。</li><li>中断处理结束或自陷处理结束后，返回被中断进程的用户态程序执行现场前，若置上请求调度标志，即可马上进行进程调度与切换。若操作系统支持这种情况下的运行调度程序，则实现了<font color="#faa755">剥夺方式</font>的调度。</li></ol><h3 id="调度的切换与过程"><a class="header-anchor" href="#调度的切换与过程"></a>调度的切换与过程</h3><p>进程切换往往在调度完成后立刻发生，它要求<font color="#faa755">保存原进程当前切换点的现场信息</font>，<font color="#faa755">恢复被调度进程的现场信息</font>。</p><ol><li>对原来运行进程各种数据的保存</li><li>对新的进程各种数据的恢复</li></ol><p>现场切换时，操作系统内核将原进程的现场信息推入当前进程的内核堆栈来保存它们，并更新堆栈指针。内核完成从新进程的内核栈中装入新进程的现场信息、更新当前运行进程空间指针、重设PC寄存器等相关工作之后，开始运行新的进程。</p><blockquote><p>注意：进程切换是<font color="#faa755">有代价的</font>，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。</p></blockquote><p>“狭义的进程调度”与“进程切换&quot;的区别：</p><ul><li><p>狭义的进程调度指的是从就绪队列中选中一个要运行的进程。(这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况就需要进程切换)</p></li><li><p>进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程。</p></li></ul><p>广义的进程调度包含了选择一个进程和进程切换两个步骤。</p><h2 id="进程调度方式"><a class="header-anchor" href="#进程调度方式"></a>进程调度方式</h2><p>所谓进程调度方式，是指当某个进程正在处理机上执行时，若有某个更为重要或紧迫的进程需要处理，即有优先权更高的进程进入就绪队列，此时应如何分配处理机。通常有以下两种进程调度方式:</p><ol><li><p>非剥夺调度方式，又称非抢占方式。非剥夺调度方式是指当-一个进程正在处理机上执行时，即使有某个更为重要或紧迫的进程进入就绪队列，仍然让正在执行的进程继续执行，直到该进程完成或发生某种事件而进入阻塞态时，才把处理机分配给更为重要或紧迫的进程。</p><blockquote><p>在非剥夺调度方式下，一旦把CPU分配给-一个进程，该进程就会保持CPU直到终止或转换到等待态。这种方式的优点是实现简单、系统开销小，适用于大多数的批处理系统，但它不能用于分时系统和大多数的实时系统。</p></blockquote></li><li><p>剥夺调度方式，又称抢占方式。剥夺调度方式是指当一个进程正在处理机上执行时，若有某个更为重要或紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给这个更为重要或紧迫的进程。</p><blockquote><p>采用剥夺式的调度，对提高系统吞吐率和响应效率都有明显的好处。但“剥夺”不是一种任意性行为，必须遵循一定的原则，主要有优先权、短进程优先和时间片原则等。</p></blockquote></li></ol><h2 id="调度的基本准则"><a class="header-anchor" href="#调度的基本准则"></a>调度的基本准则</h2><p>不同的调度算法具有不同的特性，在选择调度算法时，必须考虑算法的特性。为了比较处理机调度算法的性能，人们提出了很多评价准则，下 面介绍其中主要的几种:</p><ol><li><p>CPU利用率。CPU是计算机系统中最重要和昂贵的资源之一，所以应尽可能使CPU保持“忙”状态，使这一资源利用率最高。<font color="#faa755">利用率=忙碌的时间/总时间</font>。</p></li><li><p>系统吞吐量。表示单位时间内CPU完成作业的数量。长作业需要消耗较长的处理机时间，因此会降低系统的吞吐量。而对于短作业，它们所需要消耗的处理机时间较短，因此能提高系统的吞吐量 。调度算法和方式的不同，也会对系统的吞吐量产生较大的影响。<font color="#faa755">系统的吞吐量=总共完成了多少道作业/总共花了多少时间</font>。</p></li><li><p>周转时间。周转时间是指从作业提交到作业完成所经历的时间，是作业等待、在就绪队列中排队、在处理机上运行及进行输入/输出操作所花费时间的总和。</p><ul><li><font color="#ea66a6">周转时间</font><font color="#faa755">＝作业完成时间-作业提交时问</font>；</li><li><font color="#ea66a6">平均周转时间</font><font color="#faa755">＝各作业周转时间之和/作业数</font>；</li><li><font color="#ea66a6">带权周转时间</font><font color="#faa755">=作业周转时间/作业实际运行时间</font>；</li><li><font color="#ea66a6">平均带权周转时间</font><font color="#faa755">=各作业周转时间之和/作业数</font>；</li></ul></li><li><p>等待时间。等待时间指进程处于等处理机状态的时间之和，等待时间越长，用户满意度越低。处理机调度算法实际上并不影响作业执行或输入/输出操作的时间，只影响作业在就绪队列中等待所花的时间。因此，<font color="#faa755">衡量一个调度算法的优劣，常常只需简单地考察等待时间</font>。当然，与前面指标类似，也有“平均等待时间”来评价整体性能。</p><blockquote><p>对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在等待I/O完成的期间其实进程也是在被服务的，所以不计入等待时间。</p><p>对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。</p></blockquote></li><li><p>响应时间。响应时间指从用户提交请求到系统首次产生响应所用的时间。在交互式系统中，周转时间不可能是最好的评价准则，一般采用响应时间作为衡量调度算法的重要准则之一。从用户角度来看，调度策略应尽量降低响应时间，使响应时间处在用户能接受的范围之内。</p></li></ol><h2 id="典型的调度算法"><a class="header-anchor" href="#典型的调度算法"></a>典型的调度算法</h2><p>操作系统中存在多种调度算法，有的调度算法适用于作业调度，有的调度算法适用于进程调度 ，有的调度算法两者都适用。下面介绍几种常用的调度算法。</p><h3 id="先来先服务-FCFS-调度算法"><a class="header-anchor" href="#先来先服务-FCFS-调度算法"></a>先来先服务(FCFS)调度算法</h3><table><thead><tr><th>知识点</th><th>相关内容</th></tr></thead><tbody><tr><td>算法思想</td><td>主要从“公平”的角度考虑（类似于我们生活中排队买东西的例子）</td></tr><tr><td>算法规则</td><td>按照作业/进程到达的先后顺序进行服务</td></tr><tr><td>用于作业/进程调度</td><td>用于作业调度时，考虑的是哪个作业先到达后备队列<br/>用于进程调度时，考虑的是哪个进程先到达就绪队列</td></tr><tr><td>是否可抢占</td><td>非抢占式的算法</td></tr><tr><td>优点</td><td>公平、算法实现简单</td></tr><tr><td>缺点</td><td>排在长作业(进程)后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好。FCFS算法对长作业有利，对短作业不利</td></tr><tr><td>是否会导致饥饿</td><td>不会</td></tr></tbody></table><p>先来先服务（FCFS，First Come First Serve）调度算法是一种最简单的调度算法 ，它既可用于作业调度，又可用于进程调度。在作业调度中，算法每次从后备作业队列中选择最先进入该队列的一个或几个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列。</p><p>在进程调度中，FCFS 调度算法每次从就绪队列中选择最先进入该队列的进程，将处理机分配给它，使之投入运行，直到完成或因某种原因而阻塞时才释放处理机。</p><p>下面通过一个实例来说明FCFS调度算法的性能。假设系统中有4个作业，它们的提交时间分别是8、8.4、 8.8、 9，运行时间依次是2、 1、 0.5、 0.2，系统采用 FCFS 调度算法，这组作业的平均等待时间、平均周转时间和平均带权周转时间见下表。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/FCFS%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD.png" alt="FCFS调度算法的性能" style="object-fit: cover; border-radius: 10px; width: 100%;" /><ul><li>周转时间 = 完成时间 - 提交时间</li><li>带权周转时间 = 周转时间 / 运行时间</li><li>等待时间 = 周转时间 - 运行时间 ( - I/O操作时间）如果有I/O操作的进程</li></ul><p>FCFS调度算法属于不可剥夺算法。从表面上看，它对所有作业都是公平的，但若一个长作业先到达系统，就会使后面的许多短作业等待很长时间，因此它不能作为分时系统和实时系统的主要调度策略。但它常被结合在其他调度策略中使用。例如，在使用优先级作为调度策略的系统中，往往对多个具有相同优先级的进程按FCFS原则处理。</p><p>FCFS调度算法的特点是算法简单，但效率低；对长作业比较有利，但对短作业不利(相对SJF和高响应比) ；有利于CPU繁忙型作业，而不利于I/O繁忙型作业。</p><h3 id="短作业优先算法（SJF）"><a class="header-anchor" href="#短作业优先算法（SJF）"></a>短作业优先算法（SJF）</h3><table><thead><tr><th>知识点</th><th>相关内容</th></tr></thead><tbody><tr><td>算法思想</td><td>追求最少的平均等待时间、最少的平均周转时间、最少的平均平均带权周转时间</td></tr><tr><td>算法规则</td><td>最短的作业/进程优先得到服务（所谓“最短”，是指要求服务时间最短）</td></tr><tr><td>用于作业/进程调度</td><td>即可用于作业调度，也可用于进程调度。<br/>用于进程调度时称为“短进程优先（SPF，Shortest Process First）算法”</td></tr><tr><td>是否可抢占</td><td>SJF 和 SPF 是非抢占式的算法。<br/>但是也有抢占式的版本最短剩余时间优先算法（SRTN，Shortest Remaining Time Next）</td></tr><tr><td>优点</td><td>“ 最短的”平均等待时间、平均周转时间</td></tr><tr><td>缺点</td><td>不公平。对短作业有利，对长作业不利。可能产生饥饿现象。<br/>另外，作业/进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先</td></tr><tr><td>是否会导致饥饿</td><td>会。如果源源不断地有短作业/进程到来，可能使长作业/进程长时间得不到服务，产生“饥饿”现象。<br/>如果一直得不到服务，则称为“饿死</td></tr></tbody></table><blockquote><p>最短剩余时间优先算法（SRTN）：每当有进程加入<font color="#FF666">就绪队列改变</font>时就需要调度，如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，当前运行进程重新回到就绪队列。另外，当一个<font color="#FF666">进程完成</font>时也需要调度。</p></blockquote><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/SJF%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD.png" alt="SJF调度算法的性能" style="object-fit: cover; border-radius: 10px; width: 100%;" /><p>注意几个小细节：</p><ol><li><p>如果题目中未特别说明，所提到的“短作业/进程优先算法”默认是非抢占式的。</p></li><li><p>很多书上都会说“SJF调度算法的平均等待时间、平均周转时间最少”</p><blockquote><p>严格来说，这个表述是错误的，不严谨的。之前的例子表明，最短剩余时间优先算法得到的平均等待时间、平均周转时间还要更少。应该加上一个条件“在所有进程同时可运行时，采用SJF调度算法的平均等待时间、平均周转时间最少”；或者说“在所有进程都几乎同时到达时，采用SJF调度算法的平均等待时间、平均周转时间最少”；如果不加上述前提条件，则应该说“抢占式的短作业/进程优先调度算法（最短剩余时间优先，SRNT算法）的平均等待时间、平均周转时间最少”。</p></blockquote></li><li><p>虽然严格来说，SJF的平均等待时间、平均周转时间并不一定最少，但相比于其他算法（如FCFS） ，SJF依然可以获得较少的平均等待时间、平均周转时间</p></li><li><p>如果选择题中遇到“SJF 算法的平均等待时间、平均周转时间最少”的选项，那最好判断其他选项是不是有很明显的错误，如果没有更合适的选项，那也应该选择该选项</p></li></ol><hr><ul><li>FCFS算法是在每次调度的时候选择一个等待时间最长的作业(进程)为其服务。但是没有考虑到作业的运行时间，因此导致了对短作业不友好的问题。</li><li>SJF算法是选择一个执行时间最短的作业为其服务。但是又完全不考虑各个作业的等待时间，因此导致了对长作业不友好的问题，甚至还会造成饥饿问题。</li></ul><h3 id="高响应比优先调度算法（HRRN）"><a class="header-anchor" href="#高响应比优先调度算法（HRRN）"></a>高响应比优先调度算法（HRRN）</h3><table><thead><tr><th>知识点</th><th>相关内容</th></tr></thead><tbody><tr><td>算法思想</td><td>要综合考虑作业/进程的等待时间和要求服务的时间</td></tr><tr><td>算法规则</td><td>在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务。响应比=（等待时间 + 要求服务时间）/ 要求服务时间</td></tr><tr><td>用于作业/进程调度</td><td>即可用于作业调度，也可用于进程调度</td></tr><tr><td>是否可抢占</td><td>非抢占式的算法。因此只有当前运行的作业/进程主动放弃处理机时，才需要调度，才需要计算响应比</td></tr><tr><td>优点</td><td>综合考虑了等待时间和运行时间（要求服务时间）<br/>等待时间相同时，要求服务时间短的优先（SJF 的优点）<br/>要求服务时间相同时，等待时间长的优先（FCFS 的优点）<br/>对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题</td></tr><tr><td>是否会导致饥饿</td><td>不会</td></tr></tbody></table><p>根据响应比公式可知：</p><ol><li>作业的等待时间相同时，要求服务时间越短，响应比越高，有利于短作业</li><li>要求服务时间相同时，作业的响应比由其等待时间决定，等待时间越长，其响应比越高， 因而它实现的是先来先服务。</li><li>对于长作业，作业的响应比可以随等待时间的增加而提高， 等待时间足够长时，其响应 比便可升到很高，从而也可获得处理机。因此，克服了饥饿状态，兼顾了长作业。</li></ol><p>注：以上三种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标，但是不关心“响应时间”，也并不区分任务的紧急程度，因此对于用户来说，交互性很糟糕。因此这三种算法一般适合用于早期的批处理系统，当然，FCFS算法也常结合其他的算法使用，在现在也扮演着很重要的角色。</p><h3 id="时间片轮转调度算法（RR）"><a class="header-anchor" href="#时间片轮转调度算法（RR）"></a>时间片轮转调度算法（RR）</h3><table><thead><tr><th>知识点</th><th>相关内容</th></tr></thead><tbody><tr><td>算法思想</td><td>公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</td></tr><tr><td>算法规则</td><td>按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如100ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。</td></tr><tr><td>用于作业/进程调度</td><td>用于进程调度（只有作业放入内存建立了相应的进程后，才能被分配处理机时间片）</td></tr><tr><td>是否可抢占</td><td>若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法。由时钟装置发出时钟中断来通知CPU时间片已到</td></tr><tr><td>优点</td><td>公平；响应快，适用于分时操作系统;</td></tr><tr><td>缺点</td><td>由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度。</td></tr><tr><td>是否会导致饥饿</td><td>不会</td></tr></tbody></table><p>如果时间片太大，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间。因此时间片不能太大。</p><p>另一方面，进程调度、切换是有时间代价的(保存、恢复运行环境)，因此如果时间片太小，会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。可见时间片也不能太小。</p><p>一般来说，设计时间片时要让切换进程的开销占比不超过1%</p><h3 id="优先级调度算法"><a class="header-anchor" href="#优先级调度算法"></a>优先级调度算法</h3><table><thead><tr><th>知识点</th><th>相关内容</th></tr></thead><tbody><tr><td>算法思想</td><td>随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序</td></tr><tr><td>算法规则</td><td>每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程</td></tr><tr><td>用于作业/进程调度</td><td>既可用于作业调度，也可用于进程调度。甚至，还会用于I/O调度</td></tr><tr><td>是否可抢占</td><td>抢占式、非抢占式都有。做题时的区别在于：非抢占式只需在进程主动放弃处理机时进行调度即可，而抢占式还需在就绪队列变化时，检查是否会发生抢占。</td></tr><tr><td>优点</td><td>用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活地调整对各种作业/进程的偏好程度。</td></tr><tr><td>缺点</td><td>若源源不断地有高优先级进程到来，则可能导致饥饿</td></tr><tr><td>是否会导致饥饿</td><td>会</td></tr></tbody></table><p>非抢占式的优先级调度算法：每次调度时选择当前已到达且优先级最高的进程。当前进程主动放弃处理机时发生调度。</p><p>抢占式的优先级调度算法：每次调度时选择当前已到达且优先级最高的进程。当前进程主动放弃处理机时发生调度。另外，当就绪队列发生改变时也需要检查是会发生抢占。</p><p>就绪队列未必只有一个，可以按照不同优先级来组织。另外，也可以把优先级高的进程排在更靠近队头的位置。</p><p>根据优先级是否可以动态改变，可将优先级分为静态优先级和动态优先级两种：</p><ul><li>静态优先级：创建进程时确定，之后一直不变。</li><li>动态优先级：创建进程时有一个初始值，之后会根据情况动态地调整优先级。</li></ul><p>如何合理地设置各类进程的优先级? 通常：</p><ul><li><p>系统进程优先级高于用户进程</p></li><li><p>前台进程优先级高于后台进程</p></li><li><p>操作系统更偏好I/O型进程（或称I/O繁忙型进程），与I/O型进程相对的是计算型进程（或称CPU繁忙型进程）</p><blockquote><p>I/O设备和CPU可以并行工作。如果优先让I/O繁忙型进程优先运行的话，则越有可能让I/O设备尽早地投入工作，则资源利用率、系统吞吐量都会得到提升</p></blockquote></li></ul><p>如果采用的是动态优先级，什么时候应该调整? 可以从追求公平、提升资源利用率等角度考虑。</p><ul><li>如果某进程在就绪队列中等待了很长时间，则可以适当提升其优先级</li><li>如果某进程占用处理机运行了很长时间，则可适当降低其优先级</li><li>如果发现一个进程频繁地进行I/O操作，则可适当提升其优先级</li></ul><blockquote><p>Linux 中每个进程都有一个优先数，进程能否占用处理器的优先权取决于进程的优先数，优先数越小则优先权越高。Windows中每一个线程在内核中有一个优先级顺序，这个顺序的取值范围是0-31，数字越大优先级越高。</p></blockquote><h3 id="多级反馈队列调度算法（融合了前几种算法的优点）"><a class="header-anchor" href="#多级反馈队列调度算法（融合了前几种算法的优点）"></a>多级反馈队列调度算法（融合了前几种算法的优点）</h3><table><thead><tr><th>知识点</th><th>相关内容</th></tr></thead><tbody><tr><td>算法思想</td><td>对其他调度算法的折中权衡</td></tr><tr><td>算法规则</td><td>设置多级就绪队列，各级队列优先级从高到低，时间片从小到大<br/>新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾<br/>只有第k级队列为空时，才会为k+1级队头的进程分配时间片</td></tr><tr><td>用于作业/进程调度</td><td>用于进程调度</td></tr><tr><td>是否可抢占</td><td>抢占式的算法。在k级队列的进程运行过程中，若更上级的队列(1~k-1级)中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回k级队列队尾。</td></tr><tr><td>优点</td><td>对各类型进程相对公平（FCFS的优点）；<br/>每个新到达的进程都可以很快就得到响应（RR的优点）；<br/>短进程只用较少的时间就可完成（SPF的优点）；<br/>不必实现估计进程的运行时间（避免用户作假）<br/>可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I/O密集型进程（可以将因I/O而阻塞的进程重新放回原队列，这样I/O型讲程就可以保持较高优先级</td></tr><tr><td>是否会导致饥饿</td><td>会</td></tr></tbody></table><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95.png" alt="多级反馈队列调度算法" style="object-fit: cover; border-radius: 10px; width: 100%;" /><h2 id="进程同步、互斥"><a class="header-anchor" href="#进程同步、互斥"></a>进程同步、互斥</h2><ol><li>为什么要引入进程同步的概念？</li><li>不同的进程之间会存在什么关系？</li><li>当单纯用本节介绍的方法解决这些问题时会遇到什么新的问题吗？</li></ol><h3 id="进程同步的基本概念"><a class="header-anchor" href="#进程同步的基本概念"></a>进程同步的基本概念</h3><p>在多道程序环境下，进程是井发执行的，不同进程之间存在着不同的相互制约关系。为了协调进程之间的相互制约关系，引入了进程同步的概念。</p><h4 id="同步"><a class="header-anchor" href="#同步"></a>同步</h4><p><font color="#ea66a6">同步</font>亦称<font color="#FF666">直接制约关系</font>，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上<font color="#FF666">协调</font>它们的<font color="#FF666">工作次序</font>而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。</p><h4 id="互斥"><a class="header-anchor" href="#互斥"></a>互斥</h4><p><font color="#ea66a6">互斥</font>也称<font color="#FF666">间接制约关系</font>。当一个进程进入临界区使用临界资源时，另一个进程必须等待，当占用临界资源的进程退出临界区后，另一进程才允许去访问此临界资源。</p><p>例如，在仅有一台打印机的系统中，有两个进程A和进程B，若进程A需要打印时，系统已将打印机分配给进程B，则进程A必须阻塞。一旦进程B将打印机释放，系统便将进程A唤醒，并将其由阻塞态变为就绪态。</p><p>为禁止两个进程同时进入临界区，同步机制应遵循以下准则：</p><ol><li>空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区。</li><li>忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待。</li><li>有限等待。对请求访问的进程，应保证能在有限时间内进入临界区。</li><li>让权等待。当进程不能进入临界区时，应立即释放处理器，防止进程忙等待。</li></ol><h4 id="临界资源"><a class="header-anchor" href="#临界资源"></a>临界资源</h4><p>虽然多个进程可以共享系统中的各种资源，但其中许多资源一次只能为一个进程所用，我们将一次仅允许一个进程使用的资源称为临界资源。许多物理设备都属于临界资源，如打印机等。此外，还有许多变量、数据等都可以被若干进程共享，也属于临界资源。</p><p>对临界资源的访问，必须互斥地进行，在每个进程中，访问临界资源的那段代码称为临界区。为了保证临界资源的正确使用，可把临界资源的访问过程分成4个部分：</p><ol><li>进入区。为了进入临界区使用临界资源，在进入区要检查是否可以进入临界区，若能进入临界区，则应设置正在访问临界区的标志，以阻止其他进程同时进入临界区。（“上锁”）</li><li>临界区。进程中访问临界资源的那段代码，又称<font color="#FF666">临界段</font>。</li><li>退出区。将正在访问临界区的标志清除。（“解锁”）</li><li>剩余区。代码中的其余部分。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    entry section;     <span class="comment">// 进入区</span></span><br><span class="line">    critical section;  <span class="comment">// 临界区</span></span><br><span class="line">    exit section;      <span class="comment">// 退出区</span></span><br><span class="line">    remainder section; <span class="comment">// 剩余区</span></span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><h3 id="临界区互斥的软件实现方法"><a class="header-anchor" href="#临界区互斥的软件实现方法"></a>临界区互斥的软件实现方法</h3><ol><li>理解各个算法的思想、原理</li><li>结合上小节学习的“实现互斥的四个逻辑部分”，重点理解各算法在进入区、退出区都做了什么</li><li>分析各算法存在的缺陷（结合“实现互斥要遵循的四个原则”进行分析）</li></ol><p>在进入区设置并检查一些标志来标明是否有进程在临界区中，若已有进程在临界区，则在进入区通过循环检查进行等待，进程离开临界区后则在退出区修改标志。</p><h4 id="单标志法"><a class="header-anchor" href="#单标志法"></a>单标志法</h4><p>算法思想：两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予。</p><p>该算法设置一个公用整型变量 turn，用于指示被允许进入临界区的进程编号，即若 <code>turn=0</code> ,则允许 P<sub>0</sub> 进程进入临界区。该算法可确保每次只允许一个进程进入临界区。但两个进程必须交替进入临界区，若某个进程不再进入临界区，则另一个进程也将无法进入临界区（违背“空闲让进”）。这样很容易造成资源利用不充分。</p><p>若 P<sub>0</sub>  顺利进入临界区并从临界区离开，则此时临界区是空闲的，但 P<sub>1</sub> 并没有进入临界区的打算，<code>turn=1</code> 一直成立， P<sub>0</sub> 就无法再次进入临界区（一直被while死循环困住）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> turn = <span class="number">0</span>;      <span class="comment">// turn表示当前允许进入临界区的进程号</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// P0 进程</span></span><br><span class="line"><span class="keyword">while</span>(trun != <span class="number">0</span>);  <span class="comment">// 进入区</span></span><br><span class="line">critical section;  <span class="comment">// 临界区</span></span><br><span class="line">turn = <span class="number">1</span>;          <span class="comment">// 退出区</span></span><br><span class="line">remainder section; <span class="comment">// 剩余区</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// P1 进程</span></span><br><span class="line"><span class="keyword">while</span>(trun != <span class="number">1</span>);  <span class="comment">// 进入区</span></span><br><span class="line">critical section;  <span class="comment">// 临界区</span></span><br><span class="line">turn = <span class="number">0</span>;          <span class="comment">// 退出区</span></span><br><span class="line">remainder section; <span class="comment">// 剩余区</span></span><br></pre></td></tr></table></figure><h4 id="双标志法先检查"><a class="header-anchor" href="#双标志法先检查"></a>双标志法先检查</h4><p>算法思想：设置一个布尔型数组<code>flag[]</code>，数组中各个元素用来标记各进程想进入临界区的意愿，比如<code>flag[0] =true</code>意味着0号进程 P<sub>0</sub> 现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志<code>flag[i]</code>设为true，之后开始访问临界区。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> flag[<span class="number">2</span>];    <span class="comment">// 表示进入临界区意愿的数组</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>; <span class="comment">// 刚开始设置两个进程都不想进入临界区</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// P0 进程</span></span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>]);   <span class="comment">// ①</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;   <span class="comment">// ③</span></span><br><span class="line">critical section;  </span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;          </span><br><span class="line">remainder section; </span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// P1 进程</span></span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">0</span>]);    <span class="comment">// ② 如果此时P0想进入临界区，P1就一直循环等待</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;    <span class="comment">// ④</span></span><br><span class="line">critical section;  </span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;          </span><br><span class="line">remainder section; </span><br></pre></td></tr></table></figure><p>优点：不用交替进入，可连续使用</p><p>缺点： P<sub>0</sub> 和 P<sub>1</sub> 可能同时进入临界区。按序列①②③④执行时，执行时，会同时进入临界区（违背“忙则等待”）。即在检查对方的 flag 后和切换自己的 flag 前有一段时间，结果都检查通过。这里的问题出在检查和修改操作不能一次进行（不是原子性操作）。</p><h4 id="双标志法后检查"><a class="header-anchor" href="#双标志法后检查"></a>双标志法后检查</h4><p>算法思想：双标志先检查法的改版。前一个算法的问题是先“检查”后“上锁”，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题。因此，人们又想到先“上锁”后“检查”的方法，来避免上述问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> flag[<span class="number">2</span>];    <span class="comment">// 表示进入临界区意愿的数组</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>; <span class="comment">// 刚开始设置两个进程都不想进入临界区</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// P0 进程</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>; </span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>]);</span><br><span class="line">critical section;  </span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;          </span><br><span class="line">remainder section; </span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// P1 进程</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">0</span>]);    <span class="comment">// 如果此时P0想进入临界区，P1就一直循环等待</span></span><br><span class="line">critical section;  </span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;          </span><br><span class="line">remainder section; </span><br></pre></td></tr></table></figure><p>两个进程几乎同时都想进入临界区时，它们分别将自己的标志值 flag 设置为 true，并且同时检测对方的状态（执行while语句） ，发现对方也要进入临界区时，双方互相谦让，结果谁也进不了临界区，从而导致“饥饿”现象。</p><h4 id="Peterson’s-Algorithm"><a class="header-anchor" href="#Peterson’s-Algorithm"></a>Peterson’s Algorithm</h4><p>算法思想：双标志后检查法中，两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。Gary L. Peterson 想到了一种方法，如果双方都争着想进入临界区，那可以让进程尝试“谦让”，主动让对方先使用临界区。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> flag[<span class="number">2</span>];    <span class="comment">// 表示进入临界区意愿的数组</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>; <span class="comment">// 刚开始设置两个进程都不想进入临界区</span></span><br><span class="line"><span class="keyword">int</span> turn = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pi 进程</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>; </span><br><span class="line">turn = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>] &amp;&amp; turn==<span class="number">1</span>);</span><br><span class="line">critical section;  </span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;          </span><br><span class="line">remainder section; </span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pj 进程</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>                <span class="comment">// 表示自己想进入临界区</span></span><br><span class="line">turn = <span class="number">0</span>;                     <span class="comment">// 可以优先让对方进入临界区</span></span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">0</span>] &amp;&amp; turn==<span class="number">0</span>);    <span class="comment">// 对方想进，且最后一次是自己“让梨”，那自己就循环等待</span></span><br><span class="line">critical section;  </span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;          </span><br><span class="line">remainder section; </span><br></pre></td></tr></table></figure><p>具体如下：</p><ul><li>考虑进程 P<sub>0</sub> ，一旦设置<code>flag[0] = true</code>，就表示它想要进入临界区，同时<code>turn = 1</code>，此时若进程 P<sub>1</sub> ，已在临界区中，符合进程 P<sub>0</sub> 中的 while 循环条件，则 P<sub>0</sub> 不能进入临界区。</li><li>若 P<sub>1</sub> 不想要进入临界区，即<code>flag[1] = false</code>，循环条件不符合，则 P<sub>0</sub> 可以顺利进入，反之亦然。</li></ul><p>本算法的基本思想是算法一和算法三的结合。利用flag解决临界资源的互斥访问，而利用 turn 解决“饥饿”现象。</p><h3 id="临界区互斥的硬件实现方法"><a class="header-anchor" href="#临界区互斥的硬件实现方法"></a>临界区互斥的硬件实现方法</h3><p>理解本节介绍的硬件实现，对学习后面的信号量很有帮助。计算机提供了特殊的硬件指令，允许对一个字中的内容进行检测和修正，或对两个字的内容进行交换等。通过硬件支持实现临界段问题的方法称为低级方法，或称元方法。</p><h4 id="中断屏蔽方法"><a class="header-anchor" href="#中断屏蔽方法"></a>中断屏蔽方法</h4><p>利用“开/关中断指令”实现（与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况）</p><p>当一个进程正在使用处理机执行它的临界区代码时，防止其他进程进入其临界区进行访问的最简方法是，禁止一切中断发生，或称之为屏蔽中断、关中断。</p><p>因为CPU只在发生中断时引起进程切换，因此屏蔽中断能够保证当前运行的进程让临界区代码顺利地执行完，进而保证互斥的正确实现，然后执行开中断。其典型模式为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">关中断;  &#x2F;&#x2F; 关中断后即不允许当前进程被中断，也必然不会发生进程切换</span><br><span class="line">临界区;</span><br><span class="line">开中断;  &#x2F;&#x2F; 直到当前进程访问完临界区，再执行开中断指令，才有可能有别的进程上处理机并访问临界区</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>优点：简单、高效</p><p>缺点：不适用于多处理机；只适用于操作系统内核进程，不适用于用户进程（因为开/关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险）</p><p>这种方法限制了处理机交替执行程序的能力，因此执行的效率会明显降低。对内核来说，在它执行更新变量或列表的几条指令期间，关中断是很方便的，但将关中断的权力交给用户则很不明智，若一个进程关中断后不再开中断，则系统可能会因此终止。</p><h4 id="TestAndSet-指令"><a class="header-anchor" href="#TestAndSet-指令"></a>TestAndSet 指令</h4><p>简称TS指令，也有地方称为 TestAndSetLock 指令，或TSL指令。这条指令是原子操作，即执行该代码时不允许被中断 。其功能是读出指定标志后把该标志设置为真。指令的逻辑功能描述如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 布尔型共享变量 lock 表示当前临界区是否被加锁</span></span><br><span class="line"><span class="comment">// true表示已加锁，false 表示未加锁</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TestAndSet</span> <span class="params">(<span class="keyword">bool</span> *lock)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> old;</span><br><span class="line">    old = *lock;  <span class="comment">// old用来存放 lock 原来的值</span></span><br><span class="line">    *lock = <span class="literal">true</span>; <span class="comment">// 无论之前是否已加锁，都将 lock 设为 true</span></span><br><span class="line">    <span class="keyword">return</span> old;   <span class="comment">// 返回 lock 原来的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TSL 指令实现互斥的算法逻辑</span></span><br><span class="line"><span class="keyword">while</span> (TestAndSet (&amp;lock)); <span class="comment">// 上锁并检查</span></span><br><span class="line"><span class="comment">// 临界区代码</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">lock  <span class="literal">false</span>; <span class="comment">// 解锁</span></span><br><span class="line"><span class="comment">// 剩余区代码</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>若刚开始 lock 是 false ，则 TSL 返回的 old 值为 false ，while 循环条件不满足，直接跳过循环，进入临界区。若刚开始lock是 true，则执行 TLS 后 old 返回的值为 true，while 循环条件满足，会一直循环，直到当前访问临界区的进程在退出区进行“解锁”。</p><p>相比软件实现方法，TSL 指令把“上锁”和“检查”操作用硬件的方式变成了一气呵成的原子操作。</p><p>优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境</p><p>缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行 TSL 指令，从而导致“忙等”。</p><h4 id="Swap-指令"><a class="header-anchor" href="#Swap-指令"></a>Swap 指令</h4><p>有的地方也叫Exchange指令，或简称XCHG指令。</p><p>Swap指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。以下是用C语言描述的逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swap 指令：该指令的功能是交换两个字（字节）的内容</span></span><br><span class="line">Swap(<span class="keyword">bool</span> *a, <span class="keyword">bool</span> *b)&#123;</span><br><span class="line">    <span class="keyword">bool</span> temp;</span><br><span class="line">    temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Swap 指令实现互斥的算法逻辑</span></span><br><span class="line"><span class="comment">// lock 表示当前临界区是否被加锁</span></span><br><span class="line"><span class="keyword">bool</span> old = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (old == <span class="literal">true</span>)&#123;</span><br><span class="line">    Swap(&amp;lock, &amp;old);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 临界区代码</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">lock  <span class="literal">false</span>; <span class="comment">// 解锁</span></span><br><span class="line"><span class="comment">// 剩余区代码</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>逻辑上来看 Swap 和 TSL 并无太大区别，都是先记录下此时临界区是否已经被上锁（记录在old变量上)，再将上锁标记 lock 设置为 true，最后检查 old，如果 old 为 false 则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区。</p><p>优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境</p><p>缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”。</p><h3 id="⭐信号量机制（高频考点）"><a class="header-anchor" href="#⭐信号量机制（高频考点）"></a>⭐信号量机制（高频考点）</h3><p>信号量机制是一种功能较强的机制，可用来解决互斥与同步问题，它只能被两个标准的原语 wait(S) 和 signal(S) 访问，也可记为“P操作”和“V操作”。(来自荷兰语 proberen 检测 和 verhogen 释放 )</p><p>原语是指完成某种功能且<font color="#faa755">不被分割</font>、<font color="#faa755">不被中断</font>执行的操作序列，通常可由硬件来实现（关中断/开中断指令实现）。例如，前述的 Test-and-Set 和 Swap 指令就是由硬件实现的原子操作。原语功能的不被中断执行特性在单处理机上可由软件通过屏蔽中断方法实现。</p><p>原语之所以不能被中断执行，是因为原语对变量的操作过程若被打断，可能会去运行另一个对同一变量的操作过程，从而出现临界段问题。若能够找到一种解决临界段问题的元方法，就可以实现对共享变量操作的原子性。</p><p>用户进程可以通过使用操作系统提供的<font color="#FF666">一对原语</font>来对<font color="#FF666">信号量</font>进行操作，从而很方便的实现了进程互斥、进程同步。</p><p>一对原语：wait(S) 原语和 signal(S) 原语，可以把原语理解为我们自己写的函数，函数名分别为 wait 和 signal，括号里的信号量 S 其实就是函数调用时传入的一个参数。</p><p><font color="#ea66a6">信号量</font>其实就是一个变量（<font color="#33a3dc">可以是一个整数，也可以是更复杂的记录型变量</font>），可以用一个信号量来表示，<font color="#FF666">系统中某种资源的数量</font>，比如：系统中只有一台打印机，就可以设置一个初值为1的信号量。</p><h4 id="整型信号量"><a class="header-anchor" href="#整型信号量"></a>整型信号量</h4><p>用一个<font color="#FF666">整数型的变量</font>作为信号量，用来表示系统中某种资源的数量。</p><blockquote><p>与普通整数变量的区别：对信号量的操作只有三种，即初始化、P操作、V操作</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> S = <span class="number">1</span>; <span class="comment">// 初始化整形信号量S,表示当前系统中可用的某资源数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span> <span class="params">(<span class="keyword">int</span> S)</span> </span>&#123;     <span class="comment">// wait 原语,相当于“进入区”</span></span><br><span class="line">    <span class="keyword">while</span> (S &lt;= <span class="number">0</span>);    <span class="comment">// 如果资源数不够，就一直循环等待</span></span><br><span class="line">    S = S - <span class="number">1</span>;         <span class="comment">// 如果资源数够，则占用一个资源</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span> <span class="params">(<span class="keyword">int</span> S)</span> </span>&#123;  <span class="comment">// signal 原语，相当于“退出区”</span></span><br><span class="line">    S = S + <span class="number">1</span>;         <span class="comment">// 使用完资源后，在退出区释放资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：“检查”和“上锁”一气呵成，避免了并发、异步导致的问题</p><p>缺点：不满足“让权等待”原则，会发生“忙等”</p><h4 id="记录型信号量"><a class="header-anchor" href="#记录型信号量"></a>记录型信号量</h4><p>整型信号量的缺陷是存在“忙等”问题，因此人们又提出了“记录型信号量”，即用记录型数据结构表示的信号量。</p><p>记录型信号量是不存在“忙等”现象的进程同步机制。除需要一个用于代表资源数目的整型变量value外，再增加一个进程链表L，用于链接所有等待该资源的进程。记录型信号量得名于采用了记录型的数据结构。记录型信号量可描述为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*记录型信号量*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;         <span class="comment">// 剩余资源数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">L</span>;</span> <span class="comment">// 等待队列</span></span><br><span class="line">&#125; semaphore;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 某进程需要使用资源时，通过wait 原语申请</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span> <span class="params">(semaphore S)</span> </span>&#123;</span><br><span class="line">    S.value--;</span><br><span class="line">    <span class="keyword">if</span> (S.value &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 如果剩余资源数不够，使用block原语使进程从运行态进入阻塞态</span></span><br><span class="line">        <span class="comment">// 并把挂到信号量S的等待队列(即阻塞队列)中</span></span><br><span class="line">        add <span class="keyword">this</span> process to S.L; </span><br><span class="line">        block(S.L); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>wait 操作，<code>S.value--</code>表示进程请求一个 该类资源，当<code>S.value &lt; 0</code>时，表示该类资源已分配完毕，因此进程应调用block原语，进行自我阻塞，放弃处理机，并插入该类资源的等待队列<code>S.L</code>，可见该机制遵循了“让权等待”的准则。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进程使用完资源后，通过signal原语释放</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span> <span class="params">(semaphore S)</span> </span>&#123;</span><br><span class="line">    S.value++;</span><br><span class="line">    <span class="keyword">if</span> (S.value &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        remove a process P from S.L; </span><br><span class="line">        wakeup(P);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>signal操作，表示进程释放一个资源，使系统中可供分配的该类资源数增1，因此有<code>S.value++</code>。若加1后仍是<code>S.value≤0</code>，则表示在<code>S.L</code>中仍有等待该资源的进程被阻塞，因此还应调用 wakeup 原语，将<code>S.L</code>中的第一个等待进程唤醒。</p><h4 id="信号量机制实现进程互斥"><a class="header-anchor" href="#信号量机制实现进程互斥"></a>信号量机制实现进程互斥</h4><ol><li>分析并发进程的关键活动，划定临界区（如：对临界资源打印机的访问就应放在临界区）</li><li>设置互斥信号量 mutex ，初值为1</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*信号量机制实现互斥*/</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;  <span class="comment">// 初始化信号量</span></span><br><span class="line"></span><br><span class="line">P1()&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    P(mutex);  <span class="comment">// 准备开始访问临界资源，加锁</span></span><br><span class="line">    <span class="comment">// P1临界区代码段...</span></span><br><span class="line">    V(mutex);  <span class="comment">// 使用临界资源后需要解锁</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P2()&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    P(mutex);  <span class="comment">// 准备开始访问临界资源，加锁</span></span><br><span class="line">    <span class="comment">// P2临界区代码段...</span></span><br><span class="line">    V(mutex);  <span class="comment">// 使用临界资源后需要解锁</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当没有进程在临界区时，任意一个进程要进入临界区，就要执行P操作，把 mutex 的值减为0，然后进入临界区；</li><li>当有进程存在于临界区时，mutex 的值为0，再有进程要进入临界区，执行P操作时将会被阻塞，直至在临界区中的进程退出，这样便实现了临界区的互斥。</li></ul><p>互斥是不同进程对同一信号量进行P，V操作实现的，一个进程成功对信号量执行了P操作后进入临界区，并在退出临界区后，由该进程本身对该信号量执行 V 操作，表示当前没有进程进入临界区，可以让其他进程进入。</p><p>下面简单总结一下PV操作在同步互斥中的应用：在同步问题中，若某个行为要用到某种资源，则在这个行为前面P这种资源一下；若某个行为会提供某种资源，则在这个行为后面V这种资源一下。在互斥问题中, P，V操作要紧夹使用互斥资源的那个行为，中间不能有其他冗余代码。</p><p>注意：对不同的临界资源需要设置不同的互斥信号量。</p><p>P、V操作必须成对出现。缺少P(mutex)就不能保证临界资源的互斥访问。缺少V(mutex)会导致资源永不被释放，等待进程永不被唤醒。</p><h4 id="信号量机制实现进程同步"><a class="header-anchor" href="#信号量机制实现进程同步"></a>信号量机制实现进程同步</h4><p>进程同步：要让各并发进程按要求有序地推进。让本来异步并发的进程互相配合，有序推进。</p><ol><li>分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作（或两句代码）</li><li>设置同步信号量S，初始为0</li><li>在“前操作”之后执行V(S)</li><li>在“后操作”之前执行P(S)</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*信号量机制实现进程同步*/</span></span><br><span class="line">semaphore S = <span class="number">0</span>;  <span class="comment">// 初始化信号量</span></span><br><span class="line"></span><br><span class="line">P1()&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    x;    <span class="comment">// 语句x</span></span><br><span class="line">    V(S); <span class="comment">// 告诉进程P2，语句己经完成</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P2()&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    P(S); <span class="comment">// 检查语句x是否运行完成</span></span><br><span class="line">    y;    <span class="comment">// 检查无误，运行 语句</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>若先执行到 V(S) 操作，则 S++ 后 S=1 。之后当执行到 P(S) 操作时，由于S=1，表示有可用资源，会执行 S-- , S的值变回0，P2进程不会执行block原语，而是继续往下执行代码；</li><li>若先执行到 P(S) 操作，由于S=0，S-- 后S=-1，表示此时没有可用资源，因此P操作中会执行block原语，主动请求阻塞。之后当执行完代码x，继而执行 V(S) 操作，S++，使S变回0，由于此时有进程在该信号量对应的阻塞队列中，因此会在V操作中执行wakeup原语，唤醒P2进程。这样P2就可以继续执行代码y了</li></ul><h4 id="信号量机制实现前驱关系"><a class="header-anchor" href="#信号量机制实现前驱关系"></a>信号量机制实现前驱关系</h4><p>信号量也可用来描述程序之间或语句之间的前驱关系。下图给出了一个前驱图，其中S1、S2、S3…S6是最简单的程序段（只有一条语句）。为使各程序段能正确执行，应设置若干初始值为“ 0” 的信号量。 例如，为保证S1 → S2，S1 → S3 的前驱关系，应分别设置信号量a1，a2。同样，为保证S2 → S4，S2 → S5，S3 → S6，S4 → S6，S5 → S6，应设置信号量b1，b2，c，d，e。</p><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%89%8D%E9%A9%B1%E5%9B%BE%E4%B8%BE%E4%BE%8B.png" alt="前驱图举例" style="object-fit: cover; border-radius: 10px; width: 70%;" /><ol><li>要为每一对前驱关系各设置一个同步变量</li><li>在“前操作”之后对相应的同步变量执行 V 操作</li><li>在“后操作”之前对相应的同步变量执行 P 操作</li></ol><p>实现算法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">semaphore a1=a2=b1=b2=c=d=e=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">P1()&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    S1;</span><br><span class="line">    V(a1);</span><br><span class="line">    V(a2);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P2()&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    P(a1);</span><br><span class="line">    S2;</span><br><span class="line">    V(b1);</span><br><span class="line">    V(b2);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P3()&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    P(a2);</span><br><span class="line">    S3;</span><br><span class="line">    V(e);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P4()&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    P(b1);</span><br><span class="line">    S4;</span><br><span class="line">    V(c);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P5()&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    P(b2);</span><br><span class="line">    S5;</span><br><span class="line">    V(d);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P6()&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    P(c);</span><br><span class="line">    P(d);</span><br><span class="line">    P(e);</span><br><span class="line">    S6;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分析进程同步和互斥问题的方法步骤"><a class="header-anchor" href="#分析进程同步和互斥问题的方法步骤"></a>分析进程同步和互斥问题的方法步骤</h3><ol><li>关系分析。找出问题中的进程数，并分析它们之间的同步和互斥关系。同步、互斥、前驱关系直接按照上面例子中的经典范式改写。</li><li>整理思路。找出解决问题的关键点，并根据做过的题目找出求解的思路。根据进程的操作流程确定P操作、V操作的大致顺序。</li><li>设置信号量。根据上面的两步，设置需要的信号量，确定初值，完善整理。(互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少)</li></ol><h4 id="生产者消费者问题"><a class="header-anchor" href="#生产者消费者问题"></a>生产者消费者问题</h4><p>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。（注: 这里的“产品”理解为某种数据）</p><ul><li>生产者、消费者共享一个初始为空、大小为n的缓冲区。</li><li>只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待。（同步关系。缓冲区满时，生产者要等待消费者取走产品）</li><li>只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。（同步关系。缓冲区空时，消费者要等待生产者放入产品）</li><li>缓冲区是临界资源，各进程必须互斥地访问。（互斥关系）</li></ul><p>如何用信号量机制(P、 V操作)实现生产者、消费者进程的这些功能呢？</p><p>思路：</p><ul><li>生产者每次要消耗§一个空闲缓冲区，并生产(V)一个产品。</li><li>消费者每次要消耗§一个产品，并释放一个空闲缓冲区(V)。</li><li>往缓冲区放入/取走产品需要互斥。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;  <span class="comment">// 互斥信号量，实现对缓冲区的互斥访问</span></span><br><span class="line">semaphore empty = n;  <span class="comment">// 同步信号量，表示空闲缓冲区的数量</span></span><br><span class="line">semaphore full = <span class="number">0</span>;   <span class="comment">// 同步信号量，表示产品的数量，也即非空缓冲区的数量</span></span><br><span class="line"></span><br><span class="line">producer()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 生产产品...</span></span><br><span class="line">        P(empty); <span class="comment">// 消耗一个空闲缓冲区</span></span><br><span class="line">        P(mutex);</span><br><span class="line">        <span class="comment">// 把产品放入缓冲区...</span></span><br><span class="line">        V(mutex);</span><br><span class="line">        V(full);  <span class="comment">// 增加一个产品</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">consumer()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(full); <span class="comment">// 消耗一个产品(非空缓冲区)</span></span><br><span class="line">        P(mutex);</span><br><span class="line">        <span class="comment">// 从缓冲区取走一个产品...</span></span><br><span class="line">        V(mutex);</span><br><span class="line">        V(empty); <span class="comment">// 增加一个空闲缓冲区</span></span><br><span class="line">        <span class="comment">// 使用产品...        </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现互斥是在同一进程中进行一对PV操作；</li><li>实现两进程的同步关系，是在其中一个进程中执行P，另进程中执行V</li><li>实现互斥的P操作一定要在实现同步的P操作之后。否则可能会产生“死锁”</li><li>V操作不会导致进程阻塞，因此两个V操作顺序可以交换。</li></ul><h4 id="多生产者多消费者问题"><a class="header-anchor" href="#多生产者多消费者问题"></a>多生产者多消费者问题</h4><p>桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放-一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。</p><p>多指多类，而不是多个</p><p>互斥关系：对缓冲区(盘子)的访问要互斥地进行</p><p>同步关系：</p><ol><li>父亲将苹果放入盘子后，女儿才能取苹果</li><li>母亲将橘子放入盘子后，儿子才能取橘子</li><li>只有盘子为空时， 父亲或母亲才能放入水果，“盘子为空”这个事件可以由儿子或女儿触发，事件发生后才允许父亲或母亲放水果</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore apple = <span class="number">0</span>;  <span class="comment">// 盘中中有几个苹果</span></span><br><span class="line">semaphore orange = <span class="number">0</span>; <span class="comment">// 盘中有几个橘子</span></span><br><span class="line">semaphore plate = <span class="number">1</span>;  <span class="comment">// 盘中还可以放多少个水果</span></span><br><span class="line"></span><br><span class="line">dad()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 准备苹果...</span></span><br><span class="line">        P(plate);  <span class="comment">// 检查盘子还可以放多少水果</span></span><br><span class="line">        P(mutex);</span><br><span class="line">        <span class="comment">// 把苹果放入盘子...</span></span><br><span class="line">        V(mutex);</span><br><span class="line">        V(apple);  <span class="comment">// 告诉女儿苹果数量+1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">mom()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 准备橘子...</span></span><br><span class="line">        P(plate);  <span class="comment">// 检查盘子还可以放多少水果</span></span><br><span class="line">        P(mutex);</span><br><span class="line">        <span class="comment">// 把橘子放入盘子...</span></span><br><span class="line">        V(mutex);</span><br><span class="line">        V(orange);  <span class="comment">// 告诉儿子橘子数量+1</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">daughter()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(apple);  <span class="comment">// 检查是否有苹果</span></span><br><span class="line">        P(mutex);</span><br><span class="line">        <span class="comment">// 从盘中取出苹果...</span></span><br><span class="line">        V(mutex);</span><br><span class="line">        V(plate);  <span class="comment">// 盘子水果数-1</span></span><br><span class="line">        <span class="comment">// 吃掉苹果...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">son()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(orange);  <span class="comment">// 检查是否有橘子</span></span><br><span class="line">        P(mutex);</span><br><span class="line">        <span class="comment">// 从盘中取出橘子...</span></span><br><span class="line">        V(mutex);</span><br><span class="line">        V(plate);  <span class="comment">// 盘子水果数-1</span></span><br><span class="line">        <span class="comment">// 吃掉橘子...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>本题可以不设置互斥变量mutex，因为本题缓冲区的大小为1，在任何时刻，apple、 orange、 plate 三个同步信号量中最多只有一个是1。因此在任何时刻，最多只有一个进程的P操作不会被阻塞，并顺利地进入临界区</p><p>总结：在生产者消费者问题中，如果缓冲区大小为1，那么有可能不需要设置互斥信号量就可以实现互斥访问缓冲区的功能。当然，这不是绝对的，要具体问题具体分析。</p></blockquote><h4 id="吸烟者问题"><a class="header-anchor" href="#吸烟者问题"></a>吸烟者问题</h4><p>假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一 支烟，抽烟者需要有三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料再桌上，这个过程一直重复（让三个抽烟者轮流地抽烟）</p><p>本质上这题也属于“生产者-消费者”问题，更详细的说应该是“可生产多种产品的单生产者——多消费者”。</p><p>桌子可以抽象为容量为1的缓冲区，要互斥访问。</p><p>同步关系(从事件的角度来分析)：</p><ul><li>桌上有组合一 → 第一个抽烟者取走东西</li><li>桌上有组合二 → 第二个抽烟者取走东西</li><li>桌上有组合三 → 第三个抽烟者取走东西</li><li>发出完成信号 → 供应者将下一个组合放到桌上</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">semaphore offer1 = <span class="number">0</span>;</span><br><span class="line">semaphore offer2 = <span class="number">0</span>;</span><br><span class="line">semaphore offer3 = <span class="number">0</span>;</span><br><span class="line">semaphore finish = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// 用于实现&quot;三个抽烟者轮流抽烟&quot;</span></span><br><span class="line"></span><br><span class="line">provider()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// offer1</span></span><br><span class="line">            V(offer1);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// offer2</span></span><br><span class="line">             V(offer2);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="comment">// offer3</span></span><br><span class="line">             V(offer3);</span><br><span class="line">        &#125;</span><br><span class="line">        i = (i+<span class="number">1</span>)%<span class="number">3</span>; </span><br><span class="line">        P(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">smoker1()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(offer1);</span><br><span class="line">        <span class="comment">// 拿offer1并处理...</span></span><br><span class="line">        V(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">smoker2()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(offer2);</span><br><span class="line">        <span class="comment">// 拿offer2并处理...</span></span><br><span class="line">        V(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">smoker3()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(offer3);</span><br><span class="line">        <span class="comment">// 拿offer3并处理...</span></span><br><span class="line">        V(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="读者写者问题"><a class="header-anchor" href="#读者写者问题"></a>读者写者问题</h4><p><strong>问题描述</strong>：有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程(读进程或写进程)同时访问共享数据时则可能导致数据不一致的错误。因此要求：</p><ol><li>允许多个读者可以同时对文件执行读操作；</li><li>只允许一个写者往文件中写信息；</li><li>任一写者在完成写操作之前不允许其他读者或写者工作；</li><li>写者执行写操作前，应让已有的读者和写者全部退出。</li></ol><p><strong>问题分析</strong>：</p><ol><li>关系分析。由题目分析读者和写者是互斥的，写者和写者也是互斥的，而读者和读者不存在互斥问题。</li><li>整理思路。两个进程，即读者和写者。写者是比较简单的，它和任何进程互斥，用互斥信号量的P操作、V操作即可解决。读者的问题比较复杂，它必须在实现与写者互斥的同时，实现与其他读者的同步，因此简单的一对P操作、V操作是无法解决问题的。这里用到了一个计数器，用它来判断当前是否有读者读文件。当有读者时，写者是无法写文件的，此时读者会一直占用文件，当没有读者时，写者才可以写文件。同时，这里不同读者对计数器的访问也应该是互斥的。</li><li>信号量设置。首先设置信号量count为计数器，用于记录当前读者的数量，初值为0；设置mutex为互斥信号量，用于保护更新count变量时的互斥；设置互斥信号量rw，用于保证读者和写者的互斥访问。</li></ol><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">semaphore rw = <span class="number">1</span>; <span class="comment">// 用于实现对文件的互斥访问。表示当前是否有进程在访问共享文件</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;    <span class="comment">// 记录当前有几个读进程在访问文件</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">writer()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(rw);</span><br><span class="line">        <span class="comment">// 写文件...</span></span><br><span class="line">        V(rw);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reader()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123; </span><br><span class="line">        P(mutex);  <span class="comment">// 各读进程互斥访问count</span></span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>)&#123; </span><br><span class="line">            P(rw); <span class="comment">// 第一个读进程负责“加锁”</span></span><br><span class="line">        &#125;</span><br><span class="line">        count++;   <span class="comment">// 访问文件的读进程数+1</span></span><br><span class="line">        V(mutex);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 读文件...</span></span><br><span class="line">        </span><br><span class="line">        P(mutex);  <span class="comment">// 各读进程互斥访问count</span></span><br><span class="line">        count--;   <span class="comment">// 访问文件的读进程数+1</span></span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">            V(rw); <span class="comment">// 最后一个读进程负责“解锁”</span></span><br><span class="line">        &#125;</span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>潜在的问题：只要有读进程还在读，写进程就要一直阻塞等待，可能“饿死”。因此，这种算法中，读进程是优先的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">semaphore rw = <span class="number">1</span>; <span class="comment">// 用于实现对文件的互斥访问。表示当前是否有进程在访问共享文件</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;    <span class="comment">// 记录当前有几个读进程在访问文件</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore w= <span class="number">1</span>; <span class="comment">// 用于实现&quot;写优先&quot;</span></span><br><span class="line"></span><br><span class="line">writer()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(w);</span><br><span class="line">        P(rw);</span><br><span class="line">        <span class="comment">// 写文件...</span></span><br><span class="line">        V(rw);</span><br><span class="line">        V(w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reader()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123; </span><br><span class="line">        P(w);</span><br><span class="line">        P(mutex);  <span class="comment">// 各读进程互斥访问count</span></span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>)&#123; </span><br><span class="line">            P(rw); <span class="comment">// 第一个读进程负责“加锁”</span></span><br><span class="line">        &#125;</span><br><span class="line">        count++;   <span class="comment">// 访问文件的读进程数+1</span></span><br><span class="line">        V(mutex);</span><br><span class="line">        V(w);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 读文件...</span></span><br><span class="line">        </span><br><span class="line">        P(mutex);  <span class="comment">// 各读进程互斥访问count</span></span><br><span class="line">        count--;   <span class="comment">// 访问文件的读进程数+1</span></span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">            V(rw); <span class="comment">// 最后一个读进程负责“解锁”</span></span><br><span class="line">        &#125;</span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结论：在这种算法中，连续进入的多个读者可以同时读文件；写者和其他进程不能同时访问文件；写者不会饥饿，但也并不<br>是真正的“写优先&quot;，而是相对公平的先来先服务原则。有些书上把这个算法称为读写公平法，即读写程具有样的优先级。</p><p>其核心思想在于设置了一个计数器count用来记录当前正在访问共享文件的读进程数。我们可以用count的值来判断当前进入的进程是否是第一个/最后一个读进程，从而做出不同的处理。</p><p>另外，对count变量的检查和赋值不能一气呵成导致了一些错误，如果需要实现“一气呵成”，自然应该想到用互斥信号量。</p><h4 id="哲学家进餐问题"><a class="header-anchor" href="#哲学家进餐问题"></a>哲学家进餐问题</h4><p><strong>问题描述</strong>：一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子（一根一根地拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。</p><p><strong>问题分析</strong>：</p><ol><li>关系分析。5名哲学家与左右邻居对其中间筷子的访问是互斥关系。</li><li>整理思路。显然，这里有5个进程。本题的关键是如何让一名哲学家拿到左右两根筷子而不造成死锁或饥饿现象。解决方法有两个：一是让他们同时拿两根筷子；二是对每名哲学家的动作制定规则，避免饥饿或死锁现象的发生。</li><li>信号量设置。定义互斥信号量数组<code>chopstick[5]= &#123;1,1,1,1,1&#125;</code>，用于对5个筷子的互斥访问。哲学家按顺序编号为0~4，哲学家<code>i</code>左边筷子的编号为<code>i</code>，哲学家右边筷子的编号为<code>(i + 1)%5</code>。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">Pi()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(chopstick[i]);       <span class="comment">// 拿左</span></span><br><span class="line">        P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]); <span class="comment">// 拿右</span></span><br><span class="line">        eat;</span><br><span class="line">        V(chopstick[i]);       <span class="comment">// 放左</span></span><br><span class="line">        V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]); <span class="comment">// 放右</span></span><br><span class="line">        think;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该算法存在以下问题：当5名哲学家都想要进餐并分别拿起左边的筷子时（都恰好执行完<code>wait(chopstick[i]); </code>）筷子已被拿光，等到他们再想拿右边的筷子时（执行<code>wait(chopstick[(i + 1)%5]);</code>）就全被阻塞，因此出现了死锁。</p><p>为防止死锁发生，可对哲学家进程施加一些限制条件，比如：</p><ul><li>至多允许4名哲学家同时进餐；这样可以保证至少有一个哲学家是可以拿到左右两只筷子的。设置初始值为4的信号量。</li><li>对哲学家顺序编号，要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子， 另一个会直接阻塞。这就避免了占有一支后再等待另一只的情况。判断序号奇偶</li><li>仅当一名哲学家左右两边的筷子都可用时，才允许他抓起筷子；</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">Pi()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(mutex);</span><br><span class="line">        P(chopstick[i]);       <span class="comment">// 拿左</span></span><br><span class="line">        P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]); <span class="comment">// 拿右</span></span><br><span class="line">        V(mutex);</span><br><span class="line">        eat;</span><br><span class="line">        V(chopstick[i]);       <span class="comment">// 放左</span></span><br><span class="line">        V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]); <span class="comment">// 放右</span></span><br><span class="line">        think;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些进程之间只存在互斥关系，但是与之前接触到的互斥关系不同的是，每个进程都需要同时持有两个临界资源，因此就有“死锁&quot;问题的隐患。</p><h3 id="管程"><a class="header-anchor" href="#管程"></a>管程</h3><p>在信号量机制中，每个要访问临界资源的进程都必须自备同步的PV操作，大量分散的同步操作给系统管理带来了麻烦，且容易因同步操作不当而导致系统死锁。于是，便产生了一种新的进程同步工具——管程。 管程的特性保证了进程互斥，无须程序员自己实现互斥，从而降低了死锁发生的可能性。同时管程提供了条件变量，可以让程序员灵活地实现进程同步。</p><h4 id="管程的定义和基本特征"><a class="header-anchor" href="#管程的定义和基本特征"></a>管程的定义和基本特征</h4><p>系统中的各种硬件资源和软件资源，均可用数据结构抽象地描述其资源特性，即用少量信息和对资源所执行的操作来表征该资源，而忽略它们的内部结构和实现细节。</p><p>利用共享数据结构抽象地表示系统中的共享资源，而把对该数据结构实施的操作定义为一组过程。进程对共享资源的申请、释放等操作，都通过这组过程来实现，这组过程还可以根据资源情况，或接受或阻塞进程的访问，确保每次仅有一个进程使用共享资源，这样就可以统一管理对共享资源的所有访问，实现进程互斥。</p><p>这个代表共享资源的数据结构，以及由对该共享数据结构实施操作的一组过程所组成的资源管理程序，称为管程（monitor）。</p><p>管程定义了一个数据结构和能为并发进程所执行(在该数据结构上)的一组操作，这组操作能同步进程和改变管程中的数据。</p><p>管程是一种特殊的软件模块，有这些部分组成：</p><ol><li>局部于管程的共享数据结构说明；</li><li>对该数据结构进行操作的一组过程；</li><li>对局部于管程的共享数据设置初始值的语句；</li><li>管程有一个名字。</li></ol><p>熟悉面向对象程序设计的读者看到管程的组成后，会立即联想到管程很像一个类 (class)。</p><p>管程的基本特征：</p><ol><li>局部于管程的数据只能被局部于管程的过程所访问；</li><li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据；</li><li>每次仅允许一个进程在管程内执行某个内部过程。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*管程伪代码*/</span></span><br><span class="line">monitor ProducerConsumer</span><br><span class="line">    condition full, empty;  <span class="comment">// 条件变量用来实现同步(排队)</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;  <span class="comment">// 缓冲区中的产品数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Item item)</span></span>&#123;  <span class="comment">// 把产品item 放入缓冲区 </span></span><br><span class="line">        <span class="keyword">if</span>(count==N)&#123;</span><br><span class="line">            wait(full);</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">        insert_item(item);</span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">1</span>)&#123;</span><br><span class="line">            signal(empty)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Item <span class="title">remove</span><span class="params">()</span></span>&#123;  <span class="comment">// 从缓冲区中取走一个产品</span></span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">            wait(empty);</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span>(count==N<span class="number">-1</span>)&#123;</span><br><span class="line">            signal(full);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> remove_item();</span><br><span class="line">    &#125;</span><br><span class="line">end monitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者进程</span></span><br><span class="line">producer()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        item = producer_item();</span><br><span class="line">        ProducerConsumer.insert(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者进程</span></span><br><span class="line">consumer()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        item = ProducerConsumer.remove();</span><br><span class="line">        consumer_item(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由编译器负责实现各进程互斥地进入管程中的过程</p><p>引入管程的目的无非就是要更方便地实现进程互斥和同步。</p><ol><li>需要在管程中定义共享数据（如生产者消费者问题的缓冲区）</li><li>需要在管程中定义用于访问这些共享数据的“入口”——其实就是一些函数（如生产者消费者问题中，可以定义一个函数用于将产品放入缓冲区，再定义一个函数用于从缓冲区取出产品）</li><li>只有通过这些特定的“入口”才能访问共享数据</li><li>管程中有很多“入口”，但是每次只能开放其中一个“入口”，并且只能让一个进程或线程进入（如生产者消费者问题中，各进程需要互斥地访问共享缓冲区。管程的这种特性即可保证一个时间段内最多只会有一个进程在访问缓冲区。注意：这种互斥特性是由编译器负责实现的，程序员不用关心）</li><li>可在管程中设置条件变量及等待/唤醒操作以解决同步问题。可以让一个进程或线程在条件变量上等待（此时，该进程应先释放管程的使用权，也就是让出“入口”）；可以通过唤醒操作将等待在条件变量上的进程或线程唤醒。</li></ol><p>Java中，如果用关键字 synchronized 来描述一个函数， 那么这个函数同一时间段内只能被一个线程调用</p><h2 id="死锁"><a class="header-anchor" href="#死锁"></a>死锁</h2><h3 id="死锁的概念"><a class="header-anchor" href="#死锁的概念"></a>死锁的概念</h3><h4 id="死锁的定义"><a class="header-anchor" href="#死锁的定义"></a>死锁的定义</h4><p>在多道程序系统中，由于多个进程的并发执行，改善了系统资源的利用率并提高了系统的处理能力。然而，多个进程的并发执行也带来了新的问题——死锁。 所谓<font color="#ea66a6">死锁</font>，是指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。</p><p>下面通过一些实例来说明死锁现象。</p><p>先看生活中的一个实例。在一条河上有一座桥，桥面很窄，只能容纳一辆汽车通行。若有两辆汽车分别从桥的左右两端驶上该桥，则会出现下述冲突情况：此时，左边的汽车占有桥面左边的一段，要想过桥还需等待右边的汽车让出桥面右边的一段；右边的汽车占有桥面右边的一段，要想过桥还需等待左边的汽车让出桥面左边的段。此时，若左右两边的汽车都只能向前行驶，则两辆汽车都无法过桥。</p><p>在计算机系统中也存在类似的情况。例如，某计算机系统中只有一台打印机和一台输入设备，进程P1正占用输入设备，同时又提出使用打印机的请求，但此时打印机正被进程P2所占用，而P2在未释放打印机之前，又提出请求使用正被P1占用的输入设备。这样，两个进程相互无休止地等待下去，均无法继续执行，此时两个进程陷入死锁状态。</p><h4 id="死锁、饥饿、死循环的区别"><a class="header-anchor" href="#死锁、饥饿、死循环的区别"></a>死锁、饥饿、死循环的区别</h4><p>死锁：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。</p><p>饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象。比如：在短进程优先(SPF) 算法中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程“饥饿”。</p><p>死循环：某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug导致的，有时是程序员故意设计的。</p><p>共同点：都是进程无法顺利向前推进的现象，(故意设计的死循环除外)</p><p>区别：</p><ol><li>死锁一定是“循环等待对方手里的资源”导致的，因此如果有死锁现象，那至少有两个或两个以上的进程同时发生死锁。另外，发生死锁的进程一定处于阻塞态。</li><li>可能只有一个进程发生饥饿。发生饥饿的进程既可能是阻塞态（如长期得不到需要的I/O设备），也可能是就绪态（长期得不到处理机）</li><li>可能只有一个进程发生死循环。死循环的进程可以上处理机运行（可以是运行态），只不过无法像期待的那样顺利推进。死锁和饥饿问题是由于操作系统分配资源的策略不合理导致的，而死循环是由代码逻辑的错误导致的。死锁和饥<br>饿是管理者（操作系统）的问题，死循环是被管理者的问题。</li></ol><h4 id="死锁产生的原因"><a class="header-anchor" href="#死锁产生的原因"></a>死锁产生的原因</h4><p><strong>系统资源的竞争</strong></p><p>通常系统中拥有的不可剥夺资源，其数量不足以满足多个进程运行的需要，使得进程在运行过程中，会因争夺资源而陷入僵局，如磁带机、打印机等。只有对不可剥夺资源的竞争才可能产生死锁，对可剥夺资源的竞争是不会引起死锁的。</p><p><strong>进程推进顺序非法</strong></p><p>进程在运行过程中，<font color="#faa755">请求和释放资源的顺序不当</font>，也同样会导致死锁。例如，并发进程P1，P2分别保持了资源R1，R2，而进程P1申请资源R2、进程P2申请资源R1时，两者都会因为所需资源被占用而阻塞。</p><p><font color="#faa755">信号量使用不当也会造成死锁</font>。进程间彼此相互等待对方发来的消息，也会使得这些进程间无法继续向前推进。例如，进程A等待进程B发的消息，进程B又在等待进程A发的消息，可以看出进程A和B不是因为竞争同一资源，而是在等待对方的资源导致死锁。</p><p><strong>死锁产生的必要条件</strong></p><p>产生死锁必须同时满足以下4个条件，只要其中任意一个条件不成立，死锁就不会发生。</p><ol><li><font color="#FF666">互斥条件</font>：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的（因为进程不用阻塞等待这种资源）。</li><li><font color="#FF666">不剥夺条件</font>：进程所获得的资源在未使用完之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放）。</li><li><font color="#FF666">请求并保持条件</font>：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</li><li><font color="#FF666">循环等待条件</font>：存在一种进程资源的循环等待链，链中每个进程已获得的资源同时被链中下一个进程所请求。</li></ol><blockquote><p>注意❗ 发生死锁时一定有循环等待，但是发生循环等待时未必死锁（循环等待是死锁的必要不充分条件）</p><p>如果同类资源数大于1，则即使有循环等待，也未必发生死锁。但如果系统中每类资源都只有一个，那循环等待就是死锁的充分必要条件了。</p></blockquote><p>总之，对不可剥夺资源的不合理分配，可能导致死锁。</p><h3 id="死锁的处理策略"><a class="header-anchor" href="#死锁的处理策略"></a>死锁的处理策略</h3><p>为使系统不发生死锁，必须设法破坏产生死锁的4个必要条件之一，或允许死锁产生，但当死锁发生时能检测出死锁，并有能力实现恢复。</p><ol><li>死锁预防。设置某些限制条件，破坏产生死锁的4个必要条件中的一个或几个，以防止发生死锁。</li><li>避免死锁。在资源的动态分配过程中，用某种方法防止系统进入不安全状态，从而避免死锁。</li><li>死锁的检测及解除。无须采取任何限制性措施，允许进程在运行过程中发生死锁。通过系统的检测机构及时地检<br>测出死锁的发生，然后采取某种措施解除死锁。</li></ol><p>预防死锁和避免死锁都属于事先预防策略，预防死锁的限制条件比较严格，实现起来较为简单，但往往导致系统的效率低，资源利用率低：避免死锁的限制条件相对宽松，资源分配后需要通过算法来判断是否进入不安全状态，实现起来较为复杂。</p><table><thead><tr><th>处理策略</th><th>资源分配策略</th><th>各种可能模式</th><th>主要优点</th><th>主要缺点</th></tr></thead><tbody><tr><td>死锁预防</td><td>保守，宁可资源闲置</td><td>一次请求所有资源，资源剥夺，资源按序分配</td><td>适用于突发式处理的进程，不必进行剥夺</td><td>效率低，进程初始化时间延长；剥夺次数过多；不便灵活申请新资源</td></tr><tr><td>死锁避免</td><td>是“预防”和“检测”的折中（在运行时判断是否可能死锁）</td><td>寻找可能的安全允许顺序</td><td>不必进行剥夺</td><td>必须知道将来的资源需求；进程不能被长时间阻塞</td></tr><tr><td>死锁检测</td><td>宽松，只要允许就分配资源</td><td>定期检查死锁是否已经发生</td><td>不延长进程初始化时间，允许对死锁进行现场处理</td><td>通过剥夺解除死锁，造成损失</td></tr></tbody></table><h3 id="死锁预防"><a class="header-anchor" href="#死锁预防"></a>死锁预防</h3><p>防止死锁的发生只需破坏死锁产生的4个必要条件之一即可。</p><p>1.<strong>破坏互斥条件</strong></p><p>若允许系统资源都能共享使用，则系统不会进入死锁状态。但有些资源根本不能同时访问，如打印机等临界资源只能互斥使用。所以，破坏互斥条件而预防死锁的方法不太可行，而且在有的场合应该保护这种互斥性。</p><p>比如: SPOOLing 技术。操作系统可以采用 SPOOLing 技术把独占设备在逻辑上改造成共享设备。比如，用 SPOOLing 技术将打印机改造为共享设备。</p><p>2.<strong>破坏不剥夺条件</strong></p><p>当一个已保持了某些不可剥夺资源的进程请求新的资源而得不到满足时，它<font color="#faa755">必须释放已经保持的所有资源</font>，待以后需要时再重新申请。这意味着，一个进程已占有的资源会被暂时释放，或者说是被剥夺，或从而破坏了不剥夺条件。</p><ol><li>该策略实现起来比较复杂；</li><li>释放已获得的资源可能造成前一阶段工作的失效；</li><li>反复地申请和释放资源会增加系统开销，降低系统吞吐量。</li></ol><p>这种方法常用于状态易于保存和恢复的资源，如CPU的寄存器及内存资源，一般不能用于打印机之类的资源。</p><p>3.<strong>破坏请求并保持条件</strong></p><p>采用预先静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不把它投入运行。一旦投入运行，这些资源就一直归它所有，不再提出其他资源请求，这样就可以保证系统不会发生死锁。</p><p>这种方式实现简单，但缺点也显而易见，系统资源被严重浪费，其中有些资源可能仅在运行初期或运行快结束时才使用，甚至根本不使用。而且还会导致“饥饿”现象，由于个别资源长期被其他进程占用时，将致使等待该资源的进程迟迟不能开始运行。</p><p>4.<strong>破坏循环等待条件</strong></p><p>为了破坏循环等待条件，可采用顺序资源分配法。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源一次申请完。</p><p>原理分析：一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象。</p><p>这种方法存在的问题是，编号必须相对稳定，这就限制了新类型设备的增加；尽管在为资源编号时己考虑到大多数作业实际使用这些资源的顺序，但也经常会发生作业使用资源的顺序与系统规定顺序不同的情况，造成资源的浪费；此外，这种按规定次序申请资源的方法，也必然会给用户的编程带来麻烦。</p><h3 id="死锁避免"><a class="header-anchor" href="#死锁避免"></a>死锁避免</h3><p>避免死锁同样属于事先预防策略，但并不是事先采取某种限制措施破坏死锁的必要条件，而是在资源动态分配过程中，防止系统进入不安全状态，以避免发生死锁。这种方法所施加的限制条件较弱，可以获得较好的系统性能。</p><h4 id="系统安全状态"><a class="header-anchor" href="#系统安全状态"></a>系统安全状态</h4><p>避免死锁的方法中，允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次分配的安全性。若此次分配不会导致系统进入不安全状态，则允许分配；否则让进程等待。</p><p>所谓<font color="#ea66a6">安全状态</font>，是指系统能按某种进程推进顺序（P1，P2，…，Pn）为每个进程 Pi 分配其所需的资源，直至满足每个进程对资源的最大需求，使每个进程都可顺序完成。此时称 P1，P2，…，Pn 为安全序列。若系统无法找到一个安全序列，则称系统处于不安全状态。</p><p>并非所有的不安全状态都是死锁状态，但当系统进入不安全状态后，便可能进入死锁状态；反之，只要系统处于安全状态，系统便可避免进入死锁状态。</p><p>如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，就可能发生死锁（<font color="#FF666">处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态</font>）</p><p>因此可以在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求。这也是“银行家算法”的核心思想。</p><h4 id="银行家算法"><a class="header-anchor" href="#银行家算法"></a>银行家算法</h4><p>银行家算法是最著名的死锁避免算法，其思想是：把操作系统视为银行家，操作系统管理的资源相当于银行家管理的资金，进程向操作系统请求分配资源相当于用户向银行家贷款。操作系统按照银行家制定的规则为进程分配资源。进程运行之前先声明对各种资源的最大需求量，当进程在执行中继续申请资源时，先测试该进程已占用的资源数与本次申请的资源数之和是否超过该进程声明的最大需求量。若超过则拒绝分配资源，若未超过则再测试系统现存的资源能否满足该进程尚需的最大资源量，若能满足则按当前的申请量分配资源，否则也要推迟分配。</p><p>核心思想：在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待。</p><p>假设系统中有n个进程，m种资源。每个进程在运行前先声明对各种资源的最大需求数，则可用一个n*m的矩阵（可用二维数组实现）表示所有进程对各种资源的最大需求数。不妨称为<font color="#FF666">最大需求矩阵Max</font>，<code>Max[i, j]=K</code>表示进程 P_i 最多需要K个资源R_j。同理，系统可以用一个n*m的<font color="#FF666">分配矩阵 Allocation</font>表示对所有进程的资源分配情况。Max - Allocation = Need矩阵，表示各进程最多还需要多少各类资源。另外，还要用一个长度为m的<font color="#FF666">一维数组Available</font>表示当前系统中还有多少可用资源。</p><p>某进程Pi向系统申请资源，可用一个长度为m的<font color="#FF666">一维数组Request</font>；表示本次申请的各种资源量。</p><p>数据结构：</p><ul><li>长度为m的一维数组Available表示还有多少可用资源；</li><li>n*m矩阵Max表示各进程对资源的最大需求数；</li><li>n*m矩阵Allocation表示已经给各进程分配了多少资源；</li><li>Max-Allocation=Need 矩阵表示各进程最多还需要多少资源；</li><li>用长度为m的一位数组Request表示进程此次申请的各种资源数</li></ul><p>可用银行家算法预判本次分配是否会导致系统进入不安全状态：</p><ol><li>如果 <code>Request_i[j] ≤ Need[i, j]</code> (0≤j≤m) 便转向第2步，否则认为出错。【检查此次申请是否超过了之前声明的最大需求数】</li><li>如果 <code>Request_i[j] ≤ Available[j]</code> (0≤j≤m) 便转向第3步，否则表示尚无足够资源，Pi必须等待。【检查此时系统剩余的可用资源是否还能满足这次请求】</li><li>系统试探着把资源分配给进程Pi，并修改相应的数据（并非真的分配，修改数值只是为了做预判）<code>Available = Available - Request_i;</code>、<code>Allocation[i, j] = Allocation[i, j] + Request_i[j];</code>【试探着分配，更改各数据结构】</li><li>操作系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态。若安全，才正式分配；否则，恢复相应数据，让进程阻塞等待。【用安全性算法检查此次分配是否会导致系统进入不安全状态】</li></ol><p>安全性算法步骤：检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列，并把该进程持有的资源全部回收。不断重复上述过程看是否能将所有进程都加入安全序列。</p><h3 id="死锁检测和解除"><a class="header-anchor" href="#死锁检测和解除"></a>死锁检测和解除</h3><h4 id="死锁检测"><a class="header-anchor" href="#死锁检测"></a>死锁检测</h4><p>为了能对系统是否已发生了死锁进行检测，必须：</p><ol><li>用某种数据结构来保存资源的请求和分配信息；</li><li>提供一种算法，利用上述信息来检测系统是否已进入死锁状态。</li></ol><h4 id="资源分配图"><a class="header-anchor" href="#资源分配图"></a>资源分配图</h4><p>系统死锁可利用资源分配图来描述。</p><p>资源分配图两种结点：</p><ul><li>进程节点：对应一个进程</li><li>资源节点：对应一类资源，一类资源可能有多个</li></ul><p>资源分配图两种边：</p><ul><li>进程节点 → 资源节点：表示进程申请几个资源（每条边代表一个）</li><li>资源节点 → 进程节点：表示已经为进程分配了几个资源（每条边代表一个）</li></ul><img src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E7%A4%BA%E4%BE%8B.png" alt="资源分配示例" style="object-fit: cover; border-radius: 10px; width: 50%;" /><h4 id="死锁定理"><a class="header-anchor" href="#死锁定理"></a>死锁定理</h4><p>简化资源分配图可检测系统状态 是否为死锁状态。简化方法如下：</p><p>在资源分配图中，找出既不阻塞又不孤点的进程P_i （即找出一条有向边与它相连，且该有向边对应资源的申请数量小于等于系统中已有的空闲资源数量，如上图在，R1没有空闲资源，R2 有一个空闲资源。若所有连接该进程的边均满足上述条件，则这个进程能继续运行直至完成，然后释放它所占有的所有资源)。消去它所有的请求边和分配边，使之成为孤立的结点。在图中，P1 是满足这一条件的进程结点， 将P1的所有边消去。</p><p>进程 P_i 所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程。进程P2就满足这样的条件。根据上面方法进行一系列简化后，若能消去图中所有的边，则称该图是可完全简化的。此时一定没有发生死锁（相当于能找到一个安全序列）。</p><p>S 为死锁的条件是当且仅当 S 状态的资源分配图是不可完全简化的，该条件为死锁定理。</p><h4 id="死锁解除"><a class="header-anchor" href="#死锁解除"></a>死锁解除</h4><p>一旦检测出死锁，就应立即采取相应的措施来解除死锁。死锁解除的主要方法有：</p><ol><li>资源剥夺法。挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源而处于资源匮乏的状态。</li><li>撤销进程法。强制撤销部分甚至全部死锁进程并剥夺这些进程的资源。撒销的原则可以按进程优先级和撤销进程代价的高低进行。</li><li>进程回退法。让一(或多)个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而非被剥夺。要求系统保持进程的历史信息，设置还原点。</li></ol><p>如何决定“对谁动手”？</p><ol><li>进程优先级</li><li>已执行多长时间</li><li>还要多久能完成</li><li>进程已经使用了多少资源</li><li>进程是交互式的还是批处理式的</li></ol>]]></content>
    
    
    <summary type="html">描述</summary>
    
    
    
    <category term="操作系统" scheme="http://halo123.top/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://halo123.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Unit 1</title>
    <link href="http://halo123.top/2021/04/21/EnglishVocabulary/Unit%201/"/>
    <id>http://halo123.top/2021/04/21/EnglishVocabulary/Unit%201/</id>
    <published>2021-04-21T14:45:40.000Z</published>
    <updated>2021-04-30T10:05:39.914Z</updated>
    
    <content type="html"><![CDATA[<h2 id="state"><a class="header-anchor" href="#state"></a>state</h2><p><strong>state</strong></p><ul><li>v. (尤指清楚谨慎地)声称，宣称，声明</li><li>n. 政府，国家，州；状态，情况</li><li>adj. 国有的，国家的</li></ul><p><strong>例句</strong></p><ul><li>He <font color="#33a3dc">stated</font> that “all hell will <font color="#faa755">break loose</font>, politically and morally, all over the world.”<ul><li>他宣称，“政治和道德混乱将在全球范围内发生”。</li></ul></li><li>to seek permission from <font color="#33a3dc">state</font> regulators  寻求州监管部门的批准</li><li>a <font color="#33a3dc">state</font> of mind 心境，心态</li><li>Happiness is a state of mind, and depends very little on outward circumstances.——Helen Keller</li></ul><p><strong>派生</strong></p><ul><li>statement n. 声明；陈述，叙述；报表，清单</li><li>state-owned adj. 国有的；国营的；州立的</li><li>state-owned enterprise 国有企业</li></ul><h3 id="派生词"><a class="header-anchor" href="#派生词"></a>派生词</h3><p><strong>understate</strong></p><ul><li>v. 轻描淡写地叙述；淡化[某事的重要性或严重性]（表述不充分）</li><li>underestimate 低估</li></ul><p><strong>overstate</strong></p><ul><li>v. 把…讲得过分；夸大，夸张(= exaggerate)  ex = e = out</li><li>overestimate 高估</li></ul><p><strong>例句</strong></p><ul><li>Despite the breathtakingly sad opening chapters, Tyler’s delicate perceptiveness gives the novel an <font color="#33a3dc">understated</font> warmth.<ul><li>breathtakingly adv. 惊人地；令人激动地；Tips：副词翻译成very</li><li>delicate  adj. 微妙的；精美的，雅致的；柔和的；易碎的；纤弱的；清淡可口的</li><li>perceptiveness  n. 洞察力；感知力；直觉</li></ul></li></ul><h3 id="近义词"><a class="header-anchor" href="#近义词"></a>近义词</h3><h4 id="v-声称，宣称，声明"><a class="header-anchor" href="#v-声称，宣称，声明"></a>v. 声称，宣称，声明</h4><hr><table><thead><tr><th>词汇</th><th>解释</th></tr></thead><tbody><tr><td>declare</td><td>v. 公布，宣布；宣称(…为事实)，表明(态度、意图等)；申报(因纳税物品、收入等)</td></tr></tbody></table><p><strong>例句</strong></p><ul><li><p>“Play is not frivolous,” the academy’s report declares.</p><ul><li>frivolous adj. 无聊的；轻佻的；琐碎的；</li><li>frivolity n. 轻浮；轻薄；轻率</li><li>fried chips</li><li>fry 浮</li></ul></li><li><p>to declare sex discrimination in jury selection to be unconstitutional</p><ul><li>sex discrimination 性别歧视</li><li>jury 陪审团</li><li>unconstitutional adj. 违反宪法的</li></ul></li><li><p>I <font color="#faa755">declare</font> after all there is no enjoyment like reading.——<em>Pride and Prejudice</em>, Jane Austen</p><ul><li>As Jane Austen said in <em>Pride and Prejudice</em>, …</li></ul></li></ul><p><strong>派生</strong></p><ul><li>declaration</li><li>declarative</li></ul><hr><table><thead><tr><th>词汇</th><th>解释</th></tr></thead><tbody><tr><td>claim</td><td>v. 自称，声称，断言(未经证明或可能错误的事)；<font color="#faa755">要求</font>(拥有)，认领；<font color="#faa755">索取</font>，索(款)；(战争、事故等)夺去(生命)</td></tr><tr><td></td><td>n. 声称，说法；(根据权利而提出的)要求，索赔；(对某事物的)权利，所有权</td></tr></tbody></table><p><strong>释义推导</strong>：索取，索款 → 求拿回某物，要求拥有某物 → 拥有某事物的所有权 → (战争、事故等)夺去(生命)  → 战争等要求拥有某人的生命</p><p><strong>形近</strong></p><ul><li>calm adj. 静的，平静的；沉着的 |  v. 使平静；使镇定</li></ul><p><strong>例句</strong></p><ul><li><p>despite some <font color="#33a3dc">claims</font> to the contrary</p><ul><li>to the contrary 相反地</li><li>by contrast 与……相反的是</li><li>in contrast to 与……形成对照</li><li>counter 对抗 contra-</li><li>Tips：词根词缀原则，元音替换，意思不变；(元音)顺序改变，意思不变；发音相近，意思相近。例如：center → centri-  （eccentric adj. 古怪的，反常的【中心的外围，就离谱】）</li></ul></li><li><p>They claim that the theory of video game violence <font color="#FF666">is built on</font> rotten foundations.</p><ul><li>is built on 建立在</li><li>rotten  adj. 腐烂的；堕落的；恶臭的；虚弱的；极坏的</li><li>rod n. 棒；→ rod- 腐蚀的</li><li>erode vt. 腐蚀，侵蚀 【暴露在外面受到腐蚀】erosion n.</li><li>corrode vt. 侵蚀；损害 【接触收到腐蚀】corrosion n.</li></ul></li><li><p>Love does not claim possession, but gives freedom.——Tagore</p></li></ul><p><strong>派生</strong></p><ul><li>claimant n. 原告；[贸易] 索赔人；提出要求者</li></ul><hr><table><thead><tr><th>词汇</th><th>解释</th></tr></thead><tbody><tr><td>proclaim</td><td>vt. (正式)宣告，公布；声明；明确显示</td></tr></tbody></table><p><strong>例句</strong></p><ul><li>Correlations which confidently <font color="#33a3dc">proclaimed</font> that gaming led to violent behavior <font color="#FF666">were shown to</font> likely be the spurious by-product of factors such as family violence.<ul><li>Correlations n. 相关性</li><li>spurious adj. 假的；伪造的；欺骗的</li></ul></li></ul><hr><table><thead><tr><th>词汇</th><th>解释</th></tr></thead><tbody><tr><td>pronounce</td><td>v. 发音；宣判；断言；正式宣布(或公布)</td></tr></tbody></table><p><strong>派生</strong></p><ul><li>pronunciation n. 发音；读法</li><li>pronouncement n. 声明；宣告；公告；判决</li></ul><p><strong>拓展</strong></p><ul><li>enounce vt. 宣言；声明；说出；发音清晰地读出</li><li>enunciate v. 发音；阐明；宣布</li><li>articulate v. 清晰地发（音）；明确有力地表达；用关节连接；使相互连贯 | adj. 发音清晰的；口才好的；有关节的</li><li>artisan n. 工匠，技工【偏技术】</li><li>craftman n. 工匠 【偏制造】</li></ul><hr><table><thead><tr><th>词汇</th><th>解释</th></tr></thead><tbody><tr><td>announce</td><td>v. 宣布，宣告；通知，告知；郑重</td></tr></tbody></table><p><strong>例句</strong></p><ul><li>Last month, Facebook <font color="#33a3dc">announced</font> partnerships with outside groups to help fact-check stories on its site and to more clearly <font color="#faa755">denote</font> which ones may be false.<ul><li>脸书于上月宣布与外部团队开展合作，目的是帮助对其网站信息内容进行事实核查，并更加明确地标注哪些可能是虚假内容。</li><li>note ，denote（vt. 表示，指示），de-、dis、di = away（开，分离）</li><li>false product、copycat product</li></ul></li></ul><p><strong>派生</strong></p><ul><li>announcement n.宣布，公布；通告，声明</li></ul><hr><table><thead><tr><th>词汇</th><th>解释</th></tr></thead><tbody><tr><td>assert</td><td>v. （肯定地）断言，坚称；维护（权利或权威）；坚持（主张）</td></tr></tbody></table><ul><li>cert-</li><li>certainty n. 确定性</li></ul><p><strong>考点</strong></p><ul><li>the administration was <font color="#faa755">in essence</font> <font color="#33a3dc">asserting</font> that …<ul><li>in essence  本质上；其实；大体上</li><li>政府实际上是在坚持这样的主张……</li></ul></li></ul><p><strong>派生</strong></p><ul><li>assertion n. 断言；肯定有力的主张</li><li>assertive adj. 坚定自信的；坚决主张的</li></ul><hr><table><thead><tr><th>词汇</th><th>解释</th></tr></thead><tbody><tr><td>affirm</td><td>v. 肯定属实，申明，断言</td></tr></tbody></table><p><strong>考点</strong></p><ul><li>to <font color="#33a3dc">affirm</font> the importance of the humanities and social sciences<ul><li>肯定人文学科和社会学科的重要性</li><li>humanities  人文学科</li><li>social sciences 社会学科</li></ul></li></ul><p><strong>派生</strong></p><ul><li>affirmative  [əˈfɜːmətɪv]  adj. 肯定的，同意的 | n. 肯定，同意</li><li>affirmation [ˌæfɜːˈmeɪʃ(ə)n] n. 肯定，确认；情感上的支持（或鼓励）</li></ul><hr><table><thead><tr><th>词汇</th><th>解释</th></tr></thead><tbody><tr><td>allege</td><td>v. （未提出证据）断言，声称</td></tr></tbody></table><p><strong>派生</strong></p><ul><li>allegation n. （无证据的）说法，指控</li><li>alleged adj. 声称的；被断言的；涉嫌的</li><li>allegiance  n. 效忠，忠诚；忠贞 = loyalty = fidelity</li></ul><p><strong>拓展</strong></p><ul><li>so-called adj. 所谓的；号称的</li><li>supposed adj. 据说的，所谓的</li><li>据说 should = be supposed to</li><li>What is that supposed to be 这什么鬼</li></ul><h4 id="n-状况，情况"><a class="header-anchor" href="#n-状况，情况"></a>n. 状况，情况</h4><table><thead><tr><th>词汇</th><th>解释</th></tr></thead><tbody><tr><td>condition</td><td>n. 状况，状态；处境；条件，条款；前提；疾病；健康状况； [~s]环境，条件</td></tr><tr><td></td><td>v. 使习惯于，使适应；养护（头发等）</td></tr></tbody></table><p><strong>考点</strong></p><ul><li>geographic conditions (which are) peculiar to America<ul><li>peculiar  adj. 特殊的；独特的；奇怪的；罕见的</li><li>美国特有的地理条件</li><li>geo- 地理</li></ul></li><li>weather conditions 天气情况</li></ul><p><strong>派生</strong></p><ul><li>conditional  adj. 有条件的，有前提的</li><li>conditioner n. 护发素；调节器</li><li>hair conditioner 护发素</li></ul><p><strong>拓展</strong></p><ul><li>lotion n. 洗液；洗涤剂</li><li>bath wash 沐浴液</li><li>shampoo n. 洗发；洗发液</li><li>air conditioning 空调</li></ul><hr><table><thead><tr><th>词汇</th><th>解释</th></tr></thead><tbody><tr><td>situation</td><td>n. 形势，情况，局面；所处位置，环境</td></tr></tbody></table><p><strong>扩展</strong></p><ul><li>create a situation 造成局面</li><li>assess/review a situation 评判局势，分析局势</li><li>assessment n. 评价；评定；鉴定；估价</li><li>deal with a situation 应付局面</li><li>copy with 应付</li></ul><h2 id="change"><a class="header-anchor" href="#change"></a>change</h2><table><thead><tr><th>词汇</th><th>解释</th></tr></thead><tbody><tr><td>change</td><td>v.改变，更改；转换，更换，替换；兑换；换乘</td></tr><tr><td></td><td>n.变化，变更，变革；零钱，硬币</td></tr><tr><td>exchange</td><td>v. 交换；[货币的]兑换；交流；互访</td></tr><tr><td></td><td>n. 短暂的交流；交流，互访</td></tr><tr><td>exchange rate</td><td>汇率；兑换率</td></tr></tbody></table><p><strong>考点</strong></p><ul><li>climate change 气候变化</li></ul><h3 id="近义词-v2"><a class="header-anchor" href="#近义词-v2"></a>近义词</h3><h4 id="v-改变，更改"><a class="header-anchor" href="#v-改变，更改"></a>v. 改变，更改</h4><table><thead><tr><th>词汇</th><th>解释</th></tr></thead><tbody><tr><td>move</td><td>v.（使）移动；改变；采取行动；搬家；影响；<font color="#faa755">感动</font>；动议，提议</td></tr><tr><td></td><td>n.移动；改变；步骤；<font color="#faa755">行动，举措</font></td></tr><tr><td>movement</td><td>n. 移动；运动；变化；发展；乐章</td></tr></tbody></table><p><strong>考点</strong></p><ul><li>to back such radical moves<ul><li>支持这样的激进行动</li><li>back v. 支持</li><li>backer  n. 支持者；赞助人；援助者 =  supporter = sponsor</li><li>radical  adj. 激进的；根本的；彻底的</li><li>radicalism n. 激进主义</li></ul></li></ul><p><strong>拓展</strong></p><ul><li>Who Moved My Cheese？《谁动了我的奶酪？》</li><li>Sometimes your whole life <font color="#faa755">boils down to</font> one insane move.——Avatar<ul><li>boil down to  归结为</li><li>insane adj. 疯狂的；</li><li>sane adj. 健全的；理智的；</li><li>sanity n. 明智；头脑清楚；精神健全；通情达理</li><li>insanity n. 疯狂；精神错乱；精神病；愚顽</li></ul></li></ul><hr><table><thead><tr><th>词汇</th><th>解释</th></tr></thead><tbody><tr><td>shift</td><td>v. 转移，移动；转移（注意力等）；转变，改变（意见等）；推卸</td></tr><tr><td></td><td>n. 转变；<font color="#faa755">轮班</font>；轮班职工</td></tr></tbody></table><p><strong>例句</strong></p><ul><li>The aim was to include enough features to <font color="#faa755">draw interest away from</font> iPhones and Android-supported phones, but the new BlackBerry devices failed to <font color="#faa755">catch on</font> and the company <font color="#33a3dc">shifted</font> its engineering resources <font color="#faa755">back to</font> its QNX division as car makers started developing software.<ul><li>features  n. 产品特点，特征；（杂志）特约专栏</li><li>draw interest away from 转移兴趣；（短语看介词）</li><li>draw interest into 将兴趣转移到</li><li>catch on 抓住，流行</li><li>division  n. [数] 除法；部门；分配；分割；师（军队）；赛区</li><li>divide v. （使）分开，分成；分配，分担；分隔；（道路）分叉；使产生分歧；（数）除，除以</li><li>黑莓公司的目标是包含足够多的特色(功能)来转移人们对苹果和安卓手机的关注，但新款黑莓手机未能流行起来，而且随着汽车制造商开始开发软件，黑莓将其设计资源转回到QNX系统研发部门。</li></ul></li></ul><hr><table><thead><tr><th>词汇</th><th>解释</th></tr></thead><tbody><tr><td>switch</td><td>v. 打开，关闭；改变；转换（职业、政策、生活方式等）；交换</td></tr><tr><td></td><td>n. 开关；彻底改变</td></tr></tbody></table><ul><li>switch A into B = turn A into B</li></ul><p><strong>考点</strong></p><ul><li>to switch to the nursing school 转到护理学院</li></ul><hr><table><thead><tr><th>词汇</th><th>解释</th></tr></thead><tbody><tr><td>transition</td><td>v. 转变；过渡</td></tr><tr><td></td><td>n. 转变，过渡；变革，变迁</td></tr><tr><td>transitional</td><td>adj. 变迁的；过渡期的</td></tr></tbody></table><p><strong>例句</strong></p><ul><li>But all energy transitions, such as that from coal to hydrocarbons in the 20th century, take many decades.<ul><li>但所有的能源过渡，比如20世纪从煤炭到碳氢化合物的过渡，都需要几十年的时间。</li><li>low-Carbon life 低碳生活</li></ul></li></ul><hr><table><thead><tr><th>词汇</th><th>解释</th></tr></thead><tbody><tr><td>transform</td><td>v. 使彻底改变（尤指变得更好）；改造；使改观</td></tr><tr><td>transformer</td><td>n. 变压器；改革者</td></tr><tr><td>transformation</td><td>n. 彻底的改变；巨变</td></tr></tbody></table><p><strong>考点</strong></p><ul><li>to transform their thought processes 彻底改变他们的思考过程</li></ul><p><strong>拓展</strong></p><ul><li>transform sb/sth (from sth) into sth</li><li>The movie transformed her almost overnight from an unknown schoolgirl into a megastar.<ul><li>megastar n. 超级巨星</li></ul></li><li>reform v. 改进，改革；（使）改过自新</li></ul><hr><table><thead><tr><th>词汇</th><th>解释</th></tr></thead><tbody><tr><td>alter</td><td>v. （尤指以相对细微但却显著的方式）改变（性质或成分）；修改（衣服使更合身）</td></tr><tr><td>alteration</td><td>n. 改变，变更</td></tr></tbody></table><p><strong>例句</strong></p><ul><li>You can remind yourself to notice your thoughts in a nonjudgmental manner, without trying to change or alter them right away.<ul><li>remind  sb to do sth 提醒某人做某事</li><li>remind sb of sth 提醒某人某事</li><li>right away = at once = instantly = immediately 立刻</li><li>你可以提醒自己以一种不加评判的方式去审视自己的想法，而不是试图立即转换或改变它们。</li></ul></li><li>Remember what should be remembered, and forget what should be forgotten. Alter what is changeable,<br>and accept what is mutable.——The Catcher in the Rye<ul><li>mute 哑巴；哑的 【 /mute all 】</li><li>mutable  adj. 可变的，易变的；反复无常的，用情不专的【说不出来，琢磨不定】</li></ul></li></ul><p><strong>拓展</strong></p><ul><li>alternate adj. 交替的，轮流的；间隔的，每隔（……天等）的；（一或多个事物）另外的，可供选择的；（两者）互不相容的；另类的，非传统的；（叶、芽）互生的 | v. （使）交替，（使）轮流</li><li>alternation n. 交替，轮流，间隔</li><li>alternative n. 二中择一；供替代的选择</li><li>option n. [计] 选项；选择权；买卖的特权</li></ul><hr><table><thead><tr><th>词汇</th><th>解释</th></tr></thead><tbody><tr><td>modify</td><td>v. （略微地）修改，更改，改进，改造；修饰，限定</td></tr><tr><td>modification</td><td>n. 修改，改进</td></tr><tr><td>modifier</td><td>n. 修饰语；修正的人</td></tr></tbody></table><hr><table><thead><tr><th>词汇</th><th>解释</th></tr></thead><tbody><tr><td>convert</td><td>[kənˈvɜːt ] v. （使形态、性质、功能）改变；改变（观点、原则或做事方式）；改建，改造；换算； （使）改变信仰</td></tr><tr><td></td><td>[ˈkɒnvɜːt] n. 改变信仰者</td></tr><tr><td>conversion</td><td>n. 转变；转换；（宗教或信仰的）改变，皈依</td></tr><tr><td>convertible</td><td>adj. 可改变的 n. 有活动折篷的汽车</td></tr></tbody></table><p>-vert、-vers 转变</p><p><strong>考点</strong></p><ul><li>to convert our lives to data 把我们的生活转化为数据</li></ul><hr><table><thead><tr><th>词汇</th><th>解释</th></tr></thead><tbody><tr><td>transfer</td><td>v.（使）转移，<font color="#faa755">（使）调职</font>；转移（感情）； 传染（疾病）； 转让（权力等）；<font color="#faa755">转乘，换乘</font></td></tr><tr><td>transference</td><td>n. 转移；调动；转让</td></tr></tbody></table><ul><li>transfer station 中转站</li><li>terminal station 终点站</li></ul><p><strong>例句</strong></p><ul><li>&quot;Someone was trying to set up a new payee and <font color="#33a3dc">transfer</font> a seven figure sum, &quot; he said.<ul><li>-ee 被……人 employee，payee</li><li>-or/-er ……人 employer，payer</li><li>figure 数字</li><li>summary；summarize</li></ul></li></ul><hr><table><thead><tr><th>词汇</th><th>解释</th></tr></thead><tbody><tr><td>transplant</td><td>n. （器官）移植</td></tr><tr><td></td><td>v. 移植；移栽；（使）移居</td></tr></tbody></table><ul><li>plant<ul><li>n. 植物；<font color="#faa755">工厂；发电厂</font></li><li>v. 播（种）；种植；<font color="#faa755">放置，使固定</font></li></ul></li></ul>]]></content>
    
    
    <summary type="html">描述</summary>
    
    
    
    <category term="英语词汇" scheme="http://halo123.top/categories/%E8%8B%B1%E8%AF%AD%E8%AF%8D%E6%B1%87/"/>
    
    
    <category term="英语" scheme="http://halo123.top/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>考研资料收集</title>
    <link href="http://halo123.top/2021/04/21/DataCollection/EntranceExaminationResource/"/>
    <id>http://halo123.top/2021/04/21/DataCollection/EntranceExaminationResource/</id>
    <published>2021-04-21T09:06:12.000Z</published>
    <updated>2021-04-21T13:40:07.000Z</updated>
    
    <content type="html"><![CDATA[<Script Language="JavaScript"> 　　var timedate= new Date("December 25,2021"); 　　var times="研究生考试"; 　　var now = new Date(); 　　var date = timedate.getTime() - now.getTime(); 　　var time = Math.floor(date / (1000 * 60 * 60 * 24)); 　　if (time >= 0) ; document.write("<div title='初试时间预测为2021年12月24日-25日，12月倒数第二周的周六周日，具体时间以教育局公布为准'><font color=#343a40>现在离2022年"+times+"还有: <font color=#dc3545><b>"+time +"</b></font> 天</font></div>"); </Script> <h2 id="📚考研资料"><a class="header-anchor" href="#📚考研资料"></a>📚考研资料</h2><p><a href="https://mp.weixin.qq.com/s/5TNZQG0QBWf1IrOd8L9NGA">好好考研公众号，网课推荐</a><br><a href="https://note.youdao.com/ynoteshare1/index.html?id=fcce8b92cbcedbcbe9b34e27c2275ea9&amp;type=note">好好考研公众号，每日更新资料</a></p><h3 id="考研英语资料"><a class="header-anchor" href="#考研英语资料"></a>考研英语资料</h3><table><thead><tr><th>2022资料</th><th>百度云盘链接</th><th>提取码</th></tr></thead><tbody><tr><td>2022英语唐迟资料合集</td><td><a href="https://pan.baidu.com/s/12KUkxOukT-QIBbpJgO6R7A">云盘链接</a></td><td>ufh6</td></tr><tr><td>2022英语刘晓燕资料合集（高教版）</td><td><a href="https://pan.baidu.com/s/1RLFcQ6KLDwsWk5euTmbv0A">云盘链接</a></td><td>fa7q</td></tr><tr><td>2022英语刘晓燕资料合集（启航版）</td><td><a href="https://pan.baidu.com/s/1XAkWIgmBG1vXdHkeC0e7dA">云盘链接</a></td><td>jbpg</td></tr><tr><td>2022英语朱伟资料合集</td><td><a href="http://pan.baidu.com/s/1rEFa8e0-7Qm11fJo9T0aNQ">云盘链接</a></td><td>u985</td></tr></tbody></table><hr><table><thead><tr><th>2021资料</th><th>百度云盘链接</th><th>提取码</th></tr></thead><tbody><tr><td>2021英语唐迟资料合集</td><td><a href="https://pan.baidu.com/s/1-bIRqHH_N6A6xuDX3eEw5Q">云盘链接</a></td><td>bgfa</td></tr><tr><td>2021英语刘晓燕资料合集（高教版）</td><td><a href="https://pan.baidu.com/s/1YneD1u3YhbXl5yKPVzM2CQ">云盘链接</a></td><td>4h97</td></tr><tr><td>2021英语刘晓燕资料合集（启航版）</td><td><a href="https://pan.baidu.com/s/1vmlzGjD4YwG_JcHoNW9Hmw">云盘链接</a></td><td>tbuh</td></tr></tbody></table><h3 id="考研政治资料"><a class="header-anchor" href="#考研政治资料"></a>考研政治资料</h3><table><thead><tr><th>2022资料</th><th>百度云盘链接</th><th>提取码</th></tr></thead><tbody><tr><td>2022政治徐涛资料合集</td><td><a href="https://pan.baidu.com/s/1oX7YB9pN5fRNnfHttEidwA">云盘链接</a></td><td>phyg</td></tr></tbody></table><hr><table><thead><tr><th>2021资料</th><th>百度云盘链接</th><th>提取码</th></tr></thead><tbody><tr><td>2021政治肖秀荣资料合集</td><td><a href="https://pan.baidu.com/s/1oL_EwF0WwOhYih0SVNqbXg">云盘链接</a></td><td>gbwk</td></tr><tr><td>2021政治徐涛资料合集</td><td><a href="https://pan.baidu.com/s/1jHTsjdSYc6qfhTtp0lE5KA">云盘链接</a></td><td>73rf</td></tr></tbody></table><h3 id="考研数学资料"><a class="header-anchor" href="#考研数学资料"></a>考研数学资料</h3><table><thead><tr><th>2022资料</th><th>百度云盘链接</th><th>提取码</th></tr></thead><tbody><tr><td>2022数学汤家凤资料合集（文都版）</td><td><a href="https://pan.baidu.com/s/1pSWXHJfDzou_5x7lMvjKuA">云盘链接</a></td><td>49sj</td></tr><tr><td>2022数学汤家凤资料合集（新文道版）</td><td><a href="https://pan.baidu.com/s/1KwaRNs0yLBEV9GgEgWIhWQ">云盘链接</a></td><td>a678</td></tr><tr><td>2022数学武忠祥资料合集</td><td><a href="https://pan.baidu.com/s/1QSwjqeTShMwf5uwUNykWRw">云盘链接</a></td><td>sjnp</td></tr><tr><td>2022数学张宇资料合集</td><td><a href="https://pan.baidu.com/s/1J81U7MXeBZUrJb-b2X3sYw">云盘链接</a></td><td>gshh</td></tr><tr><td>2022数学李永乐资料合集</td><td><a href="https://pan.baidu.com/s/1HPVw62L5B2X1fZ1rEqTyTg">云盘链接</a></td><td>u985</td></tr></tbody></table><hr><table><thead><tr><th>2021资料</th><th>百度云盘链接</th><th>提取码</th></tr></thead><tbody><tr><td>2021数学汤家凤资料合集</td><td><a href="https://pan.baidu.com/s/1Vcv3UWsxbBNopIqeyXQcwg">云盘链接</a></td><td>kxvq</td></tr></tbody></table><h3 id="计算机408资料"><a class="header-anchor" href="#计算机408资料"></a>计算机408资料</h3><table><thead><tr><th>2022资料</th><th>百度云盘链接</th><th>提取码</th></tr></thead><tbody><tr><td>2022年计算机资料合集</td><td><a href="https://pan.baidu.com/s/1ADIdKQ_xHOnhgetC1ZiRqA">云盘链接</a></td><td>gihh</td></tr></tbody></table><hr><table><thead><tr><th>2021资料</th><th>百度云盘链接</th><th>提取码</th></tr></thead><tbody><tr><td>2021年计算机资料合集</td><td><a href="https://pan.baidu.com/s/1PKi1g5N03f3nt40TUIX7uA">云盘链接</a></td><td>q5xg</td></tr><tr><td>2021年计算机资料合集</td><td><a href="https://pan.baidu.com/s/1Rcwo6MYwEJZQOvq7KzkXFA">云盘链接</a></td><td>3333</td></tr></tbody></table><br/><blockquote><p>资料来源：<a href="https://mp.weixin.qq.com/s/Knp9-UbYStQXAS3vjuDZrA">研料库公众号</a>、好好考研</p></blockquote><h3 id="其他资料"><a class="header-anchor" href="#其他资料"></a>其他资料</h3><p>微信公众号：</p><ul><li>给力考研资料</li><li>好好考研</li><li>槟果考研</li><li>小白考研</li><li>灰灰考研(计算机)</li></ul><p>官方<a href="https://yz.chsi.com.cn/">中国研究生招生信息网(研招网)</a></p><h2 id="🧭知乎有关问题及回答"><a class="header-anchor" href="#🧭知乎有关问题及回答"></a>🧭知乎有关问题及回答</h2><p><a href="https://zhuanlan.zhihu.com/p/352816017">2022考研全程复习规划</a><br><a href="https://www.zhihu.com/question/20462634/answer/728661676">考研规划，看这一篇就够了！</a><br><a href="https://zhuanlan.zhihu.com/p/72965483">考研资料书推荐大全+考研经验分享</a></p><h3 id="各大院校官网"><a class="header-anchor" href="#各大院校官网"></a>各大院校官网</h3><h2 id="📆考研公共课规划"><a class="header-anchor" href="#📆考研公共课规划"></a>📆考研公共课规划</h2>]]></content>
    
    
    <summary type="html">资料来源于公众号</summary>
    
    
    
    <category term="考研" scheme="http://halo123.top/categories/%E8%80%83%E7%A0%94/"/>
    
    
    <category term="考研" scheme="http://halo123.top/tags/%E8%80%83%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>Web前端入门之CSS</title>
    <link href="http://halo123.top/2021/04/19/WebFrontEnd/PrimerCSS/"/>
    <id>http://halo123.top/2021/04/19/WebFrontEnd/PrimerCSS/</id>
    <published>2021-04-19T15:51:35.000Z</published>
    <updated>2021-04-30T10:05:39.985Z</updated>
    
    <content type="html"><![CDATA[<details ><summary> 参考资料 </summary>              <div class='content'>              <div class="tag link"><a class="link-card" title="CSS参考手册" href="http://css.doyoe.com/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E7%BD%91%E7%AB%99.svg"/></div><div class="right"><p class="text">CSS参考手册</p><p class="url">http://css.doyoe.com/</p></div></a></div><div class="tag link"><a class="link-card" title="w3cschool" href="https://www.w3school.com.cn/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E7%BD%91%E7%AB%99.svg"/></div><div class="right"><p class="text">w3cschool</p><p class="url">https://www.w3school.com.cn/</p></div></a></div><div class="tag link"><a class="link-card" title="黑马程序员Web前端入门教程" href="https://www.bilibili.com/video/BV1pE411q7FU"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E7%BD%91%E7%AB%99.svg"/></div><div class="right"><p class="text">黑马程序员Web前端入门教程</p><p class="url">https://www.bilibili.com/video/BV1pE411q7FU</p></div></a></div>              </div>            </details><h2 id="CSS-简介"><a class="header-anchor" href="#CSS-简介"></a>CSS 简介</h2><ol><li>CSS 是层叠样式表 ( Cascading Style Sheets ) 的简称。有时我们也会称之为 CSS 样式表或级联样式表。</li><li>CSS 是也是一种标记语言。</li><li>CSS 主要用于设置 HTML 页面中的文本内容（字体、大小、对齐方式等）、图片的外形（宽高、边框样式、边距等）以及版面的布局和外观显示样式。</li><li>CSS 让我们的网页更加丰富多彩，布局更加灵活自如。简单理解：CSS 可以美化 HTML , 让 HTML 更漂亮， 让页面布局更简单。</li><li>CSS 最大价值: 由 HTML 专注去做结构呈现，样式交给 CSS，即 结构 ( HTML ) 与样式( CSS ) 相分离。</li></ol><h3 id="CSS-语法规范"><a class="header-anchor" href="#CSS-语法规范"></a>CSS 语法规范</h3><ol><li>使用 HTML 时，需要遵从一定的规范，CSS 也是如此。要想熟练地使用 CSS 对网页进行修饰，首先需要了解CSS 样式规</li><li>CSS 规则由两个主要的部分构成：选择器以及一条或多条声明。</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span>&#123;</span><br><span class="line"><span class="attribute">color</span>:red;</span><br><span class="line"><span class="attribute">font-size</span>:<span class="number">25px</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>选择器是用于指定 CSS 样式的 HTML 标签，花括号内是对该对象设置的具体样式</li><li>属性和属性值以“键值对”的形式出现</li><li>属性是对指定的对象设置的样式属性，例如字体大小、文本颜色等</li><li>属性和属性值之间用英文<code>:</code>分开</li><li>多个“键值对”之间用英文<code>;</code>进行区分</li></ol><p>所有的样式，都包含在 <code>&lt;style&gt;</code> 标签内，表示是样式表。<code>&lt;style&gt;</code> 一般写到 <code>&lt;/head&gt;</code> 上方，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">h4</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">color</span>: blue;</span></span><br><span class="line"><span class="css">      <span class="attribute">font-size</span>: <span class="number">100px</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="CSS代码风格"><a class="header-anchor" href="#CSS代码风格"></a>CSS代码风格</h3><p>样式空格风格</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*选择器（标签）和大括号中间保留空格*/</span></span><br><span class="line"><span class="selector-tag">h3</span> &#123;</span><br><span class="line">  <span class="comment">/*属性值前面，冒号后面，保留一个空格*/</span></span><br><span class="line">  <span class="attribute">color</span>: pink;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>样式格式书写</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*紧凑格式*/</span></span><br><span class="line"><span class="selector-tag">h3</span> &#123; <span class="attribute">color</span>: deeppink;<span class="attribute">font-size</span>: <span class="number">20px</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*展开格式(推荐,更直观)*/</span></span><br><span class="line"><span class="selector-tag">h3</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: pink;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">20px</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>样式大小写风格</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*小写格式(推荐)*/</span></span><br><span class="line"><span class="selector-tag">h3</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*大写格式*/</span></span><br><span class="line"><span class="selector-tag">H3</span> &#123;</span><br><span class="line">  <span class="attribute">COLOR</span>: PINK;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CSS选择器"><a class="header-anchor" href="#CSS选择器"></a>CSS选择器</h2><h3 id="选择器的作用"><a class="header-anchor" href="#选择器的作用"></a>选择器的作用</h3><p>选择器(选择符)就是根据不同需求把不同的标签选出来这就是选择器的作用。简单来说，就是选择标签用的。</p><p>选择器分为基础选择器和复合选择器两个大类。</p><h3 id="CSS-基础选择器"><a class="header-anchor" href="#CSS-基础选择器"></a>CSS 基础选择器</h3><p>基础选择器又包括：标签选择器、类选择器、id 选择器和通配符选择器</p><h4 id="标签选择器"><a class="header-anchor" href="#标签选择器"></a>标签选择器</h4><p>标签选择器（元素选择器）是指用 HTML 标签名称作为选择器，按标签名称分类，为页面中某一类标签指定统一的 CSS 样式。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">标签选择器&#123;</span><br><span class="line">  属性：属性值</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：能快速为页面中同类型的标签统一设置样式。<br>缺点：不能设计差异化样式,只能选择全部的当前标签。</p><h4 id="类选择器"><a class="header-anchor" href="#类选择器"></a>类选择器</h4><p>如果想要差异化选择不同的标签，单独选一个或者某几个标签，可以使用类选择器。</p><p>结构需要用class属性来调用class类的意思，<code>&lt;div class=&quot;类名&quot;&gt; 变红色 &lt;/div&gt;</code></p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.类名&#123;</span><br><span class="line">  属性：属性值</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果想要差异化选择不同的标签，单独选一个或者某几个标签，可以使用类选择器。</li><li>类选择器在 HTML 中以 class 属性表示，在 CSS 中，类选择器以一个点“.”号显示。</li><li>类选择器使用“.”（英文点号）进行标识，后面紧跟类名（自定义，我们自己命名的）。</li><li>可以理解为给这个标签起了一个名字，来表示。</li><li>长名称或词组可以使用中横线来为选择器命名。</li><li>不要使用纯数字、中文等命名，尽量使用英文字母来表示。</li><li>命名要有意义，尽量使别人一眼就知道这个类名的目的。</li><li>命名规范：见资料（<a href="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/%E8%B5%84%E6%96%99/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%E6%89%8B%E5%86%8C.doc">Web 前端开发规范手册.doc</a>）</li></ol><h4 id="多类名选择器"><a class="header-anchor" href="#多类名选择器"></a>多类名选择器</h4><p>我们可以给一个标签指定多个类名，从而达到更多的选择目的。 这些类名都可以选出这个标签。简单理解就是一个标签有多个名字。</p><p>多类名的具体使用，类名之间用空格隔开：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;red font20&quot;&gt;嘤嘤嘤&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>在标签class 属性中写多个类名</li><li>多个类名中间必须用空格分开</li><li>这个标签就可以分别具有这些类名的样式</li></ol><p>多类名开发中使用场景：</p><ol><li>可以把一些标签元素相同的样式(共同的部分)放到一个类里面。</li><li>这些标签都可以调用这个公共的类然后再调用自己独有的类。</li><li>从而节省CSS代码，统一修改也非常方便。</li></ol><h4 id="ID-选择器"><a class="header-anchor" href="#ID-选择器"></a>ID 选择器</h4><p>id 选择器可以为标有特定 id 的 HTML 元素指定特定的样式。</p><p>HTML 元素以 id 属性来设置 id 选择器，CSS 中 id 选择器以 “#” 来定义。语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#id名 &#123;</span><br><span class="line">  属性1: 属性值1;  </span><br><span class="line">  ...</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>注意：id 属性只能在每个 HTML 文档中出现一次</p><p>id 选择器和类选择器的区别：</p><ol><li>类选择器（class）好比人的名字，一个人可以有多个名字，同时一个名字也可以被多个人使用。</li><li>id 选择器好比人的身份证号码，全中国是唯一的，不得重复。</li><li>id 选择器和类选择器最大的不同在于使用次数上。</li><li>类选择器在修改样式中用的最多，id 选择器一般用于页面唯一性的元素上，经常和 JavaScript 搭配使用。</li></ol><h4 id="通配符选择器"><a class="header-anchor" href="#通配符选择器"></a>通配符选择器</h4><p>在 CSS 中，通配符选择器使用 “*” 定义，它表示选取页面中所有元素（标签）。语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  属性<span class="number">1</span>: 属性值<span class="number">1</span>;  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通配符选择器不需要调用，自动就给所有的元素使用样式，特殊情况才使用(如清除所有的元素标签的内外边距)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="基础选择器总结"><a class="header-anchor" href="#基础选择器总结"></a>基础选择器总结</h4><table><thead><tr><th>基础选择器</th><th>作用</th><th>特点</th><th>使用情况</th><th>用法</th></tr></thead><tbody><tr><td>标签选择器</td><td>可以选出所有相同的标签</td><td>不能差异化选择</td><td>较多</td><td><code>p &#123;color: red;&#125;</code></td></tr><tr><td>类选择器</td><td>可以选出1个或者多个标签</td><td>可以根据需求选择</td><td>非常多</td><td><code>.nav &#123;color: red;&#125;</code></td></tr><tr><td>id选择器</td><td>一次只能选择1个标签</td><td>相同id属性只能在每一个HTML文档中出现一次</td><td>一般和JavaScript搭配</td><td><code>#nav &#123;color: red;&#125;</code></td></tr><tr><td>通配符选择器</td><td>选择所有的标签</td><td>选择所有</td><td>特殊情况下使用</td><td><code>* &#123;color: red;&#125;</code></td></tr></tbody></table><h3 id="关系选择器"><a class="header-anchor" href="#关系选择器"></a>关系选择器</h3><p>简单的选择器包括标签选择器、类选择器、ID 选择器和通配符选择器。如果把两个选择器组合在一起，就形成了一个复杂关系的选择器。在 HTML5 文档结构中，通过关系选择器可以精确匹配结构中特定关系元素。</p><h4 id="包含选择器"><a class="header-anchor" href="#包含选择器"></a>包含选择器</h4><p>包含选择器通过空格连接两个选择器，前面选择器表示包含的祖先元素，后面选择器表示被包含的后代元素。</p><ul><li>优点：可以匹配特定的结构内指定对象，用于缩小匹配范围。</li><li>缺点： 匹配范围较大，影响的层级不受限制。</li></ul><p>案例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 网页模板 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span> 网页标题 <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span> 页脚标题 <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure><p>实现以下目标：</p><ul><li>定义网页标题的字体大小为 18px</li><li>定义页脚标题的字体大小为 12px</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">header</span> <span class="selector-tag">h1</span>&#123;<span class="attribute">font-size</span>:<span class="number">18px</span>;&#125;</span><br><span class="line"><span class="selector-tag">footer</span> <span class="selector-tag">h1</span>&#123;<span class="attribute">font-size</span>:<span class="number">12px</span>;&#125;</span><br></pre></td></tr></table></figure><h4 id="子选择器"><a class="header-anchor" href="#子选择器"></a>子选择器</h4><p>子选择器使用尖括号（<code>&gt;</code>）连接两个选择器，前面选择器表示要匹配的父元素，后面选择器表示被包含的匹配子对象。</p><ul><li>优点：比包含选择器匹配的范围更小，从层级结构上来看匹配目标更明确。</li><li>缺点：与包含选择器相比，匹配范围优先，用户需要熟悉文档结构。</li></ul><iframe width="100%" height="300" src="//jsrun.net/9e3Kp/embedded/html,css,result/dark" allowfullscreen="allowfullscreen" frameborder="0"></iframe><h4 id="相邻选择器"><a class="header-anchor" href="#相邻选择器"></a>相邻选择器</h4><p>相邻选择器使用加号（<code>+</code>）连接两个选择器，前面选择器匹配特定元素，后面选择器根据结构关系，指定同级、相邻的匹配元素。</p><ul><li>优点：在结构中能够准确找到同级、相邻的元素。</li><li>缺点：需要熟悉文档结构。</li></ul><h4 id="兄弟选择器"><a class="header-anchor" href="#兄弟选择器"></a>兄弟选择器</h4><p>兄弟选择器使用波浪线（<code>~</code>）连接两个选择器，前面</p><iframe height="400" style="width: 100%;" scrolling="no" title="Swiper.js实现响应式博客卡片滑块轮播" src="https://animpen.com/embed/oMbZtH?tab=rlt,html" frameborder="no"  allowtransparency="true" allowfullscreen="true"></iframe><h2 id="CSS字体属性"><a class="header-anchor" href="#CSS字体属性"></a>CSS字体属性</h2><p>CSS Fonts (字体)属性用于定义字体系列、大小、粗细、和文字样式(如斜体)。</p><h3 id="字体系列"><a class="header-anchor" href="#字体系列"></a>字体系列</h3><p>CSS使用<code>font-family</code>属性定义文本的字体系列。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123; </span><br><span class="line">  <span class="attribute">font</span>- family: Arial, <span class="string">&quot;Microsoft Yahei&quot;</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>各种字体之间必须使用英文状态下的逗号隔开</li><li>般情况下，如果有空格隔开的多个单词组成的字体加引号。</li><li>尽量使用系统默认自带字体，保证在任何用户的浏览器中都能正确显示</li></ul><h3 id="字体大小"><a class="header-anchor" href="#字体大小"></a>字体大小</h3><p>CSS 使用 <code>font-size</code> 属性定义字体大小。 语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;  </span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">20px</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>px（像素）大小是我们网页的最常用的单位</li><li>谷歌浏览器默认的文字大小为16px</li><li>不同浏览器可能默认显示的字号大小不一致，我们尽量给一个明确值大小，不要默认大小</li><li>可以给 body 指定整个页面文字的大小</li></ol><h3 id="字体粗细"><a class="header-anchor" href="#字体粗细"></a>字体粗细</h3><p>CSS 使用 <code>font-weight</code> 属性设置文本字体的粗细。语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;  </span><br><span class="line">  <span class="attribute">font-weight</span>: bold; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>normal</td><td>默认值（不加粗）</td></tr><tr><td>bold</td><td>定义加粗</td></tr><tr><td>100-900</td><td>400等同于normal，700等同于bold，注意这个数字后面不加单位</td></tr></tbody></table><h3 id="字体样式"><a class="header-anchor" href="#字体样式"></a>字体样式</h3><p>CSS 使用 <code>font-style</code> 属性设置文本的风格。语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;  </span><br><span class="line">  <span class="attribute">font-style</span>: normal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性值</th><th>作用</th></tr></thead><tbody><tr><td>normal</td><td>默认值，浏览器会显示标准的字体样式<code>font- style: normal;</code></td></tr><tr><td>italic</td><td>浏览器会显示斜体的字体样式。</td></tr></tbody></table><h3 id="字体的综合写法"><a class="header-anchor" href="#字体的综合写法"></a>字体的综合写法</h3><p>字体属性可以把以上文字样式综合来写, 这样可以更节约代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123; </span><br><span class="line">  <span class="attribute">font</span>: font-style  font-weight  font-size/line-height  font-family;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 font 属性时，必须按上面语法格式中的顺序书写，<font color="#FF666">不能更换顺序</font>，并且各个属性间以空格隔开 不需要设置的属性可以省略（取默认值），但必须保留 <code>font-size</code> 和 <code>font-family</code> 属性，否则 font 属性将不起作用。</p><h3 id="字体总结"><a class="header-anchor" href="#字体总结"></a>字体总结</h3><table><thead><tr><th>属性</th><th>表示</th><th>注意点</th></tr></thead><tbody><tr><td><code>font-size</code></td><td>字号</td><td>通常用的单位是 px 像素，一定要跟上单位</td></tr><tr><td><code>font-family</code></td><td>字体</td><td>实际工作中按照团队约定来写字体</td></tr><tr><td><code>font-weight</code></td><td>字体粗细</td><td>记住加粗是700或者bold，不加粗是normal或者400记住数字不要跟单位</td></tr><tr><td><code>font-style</code></td><td>字体样式</td><td>记住倾斜是italic，不倾斜是normal。工作中我们最常用normal</td></tr><tr><td><code>font</code></td><td>字体连写</td><td>字体连写是有顺序的不能随意换位置；其中字号和字体必须同时出现</td></tr></tbody></table><h2 id="CSS文本属性"><a class="header-anchor" href="#CSS文本属性"></a>CSS文本属性</h2><p>CSS Text (文本)属性可定义文本的外观，比如文本的颜色、对齐文本、装饰文本、文本缩进、行间距等。</p><h3 id="文本颜色"><a class="header-anchor" href="#文本颜色"></a>文本颜色</h3><p>color 属性用于定义文本的颜色。语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123; </span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>表示</th><th>属性值</th></tr></thead><tbody><tr><td>预定义的颜色</td><td>red、green、blue等</td></tr><tr><td>十六进制(常用)</td><td>#FF0000、#FF6600等</td></tr><tr><td>RGB代码</td><td>rgb(255,0,0)、rgb(100%,0%,0%)</td></tr></tbody></table><h3 id="文本对齐"><a class="header-anchor" href="#文本对齐"></a>文本对齐</h3><p><code>text-align</code> 属性用于设置元素内文本内容的<font color="#FF666">水平</font>对齐方式。语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123; </span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性值</th><th>解释</th></tr></thead><tbody><tr><td>left</td><td>左对齐（默认值）</td></tr><tr><td>right</td><td>右对齐</td></tr><tr><td>center</td><td>居中对齐</td></tr></tbody></table><h3 id="修饰文本"><a class="header-anchor" href="#修饰文本"></a>修饰文本</h3><p><code>text-decoration</code>属性规定添加到文本的修饰。可以给文本添加下划线、删除线、上划线等。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123; </span><br><span class="line">  <span class="attribute">text-decoration</span>：underline；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>none</td><td>默认，没有装饰线</td></tr><tr><td>underline</td><td>下划线</td></tr><tr><td>overline</td><td>上划线</td></tr><tr><td>line-through</td><td>删除线</td></tr></tbody></table><h3 id="文本缩进"><a class="header-anchor" href="#文本缩进"></a>文本缩进</h3><p><code>text-indent</code>属性用来指定文本的第一行的缩进，通常是将段落的首行缩进。语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123; </span><br><span class="line">  <span class="attribute">text-indent</span>：<span class="number">20px</span>；</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span> &#123; </span><br><span class="line">  <span class="attribute">text-indent</span>：<span class="number">2em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>em</code> 是一个相对单位，就是当前元素（font-size) 1 个文字的大小，如果当前元素没有设置大小，则会按照父元素的 1 个文字大小。</p></blockquote><h3 id="行间距"><a class="header-anchor" href="#行间距"></a>行间距</h3><p><code>line-height</code> 属性用于设置行间的距离（行高）。可以控制文字行与行之间的距离。语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123; </span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">26px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>行高的文本分为：上间距、文本高度和下间距，这三者大小之和 = 行间距</p><h3 id="文本属性总结"><a class="header-anchor" href="#文本属性总结"></a>文本属性总结</h3><table><thead><tr><th>属性</th><th>表示</th><th>注意点</th></tr></thead><tbody><tr><td>color</td><td>文本颜色</td><td>常用十六进制表示颜色</td></tr><tr><td>text-align</td><td>文本对齐</td><td>设定文字水平对齐方式</td></tr><tr><td>text-indent</td><td>文本缩进</td><td>可以设置首行缩进</td></tr><tr><td>text-decoration</td><td>文本修饰</td><td>添加或去除下划线</td></tr><tr><td>line-height</td><td>行高</td><td>控制行间距</td></tr></tbody></table><h2 id="CSS样式表"><a class="header-anchor" href="#CSS样式表"></a>CSS样式表</h2><p>按照 CSS 样式书写的位置（或者引入的方式），CSS 样式表可以分为三大类：行内样式表（行内式）、内部样式表（嵌入式）、外部样式表（链接式）。</p><h3 id="行内样式表（行内式）"><a class="header-anchor" href="#行内样式表（行内式）"></a>行内样式表（行内式）</h3><p>行内样式表（内联样式表）是在元素标签内部的 <code>style</code> 属性中设定 CSS 样式。适合于修改简单样式。语法：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;color: red; font-size: 12px;&quot;&gt;一拳一个嘤嘤怪&lt;/div&gt;</span><br></pre></td></tr></table></figure><ol><li>style 其实就是标签的属性，在双引号中间，写法要符合 CSS 规范</li><li>可以控制当前的标签设置样式</li><li>由于书写繁琐，并且没有体现出结构与样式相分离的思想，所以不推荐大量使用，只有对当前元素添加简单样式的时候，可以考虑使用</li><li>使用行内样式表设定 CSS，通常也被称为行内式引入</li></ol><h3 id="内部样式表（嵌入式）"><a class="header-anchor" href="#内部样式表（嵌入式）"></a>内部样式表（嵌入式）</h3><p>内部样式表（内嵌样式表）是写到html页面内部. 是将所有的 CSS 代码抽取出来，单独放到一个 <code>&lt;style&gt;</code> 标签中，语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  <span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><ol><li><code>&lt;style&gt;</code> 标签理论上可以放在 HTML 文档的任何地方，但一般会放在文档的<code>&lt;head&gt;</code>标签中</li><li>通过此种方式，可以方便控制当前整个页面中的元素样式设置</li><li>代码结构清晰，但是并没有实现结构与样式完全分离</li><li>使用内部样式表设定 CSS，通常也被称为嵌入式引入，这种方式是我们练习时常用的方式</li></ol><h3 id="外部样式表（链接式）"><a class="header-anchor" href="#外部样式表（链接式）"></a>外部样式表（链接式）</h3><p>实际开发都是外部样式表. 适合于样式比较多的情况. 核心是:样式单独写到CSS 文件中，之后把CSS文件引入到 HTML 页面中使用.<br>引入外部样式表分为两步：</p><ol><li>新建一个后缀名为 .css 的样式文件，把所有 CSS 代码都放入此文件中。</li><li>在 HTML 页面中，使用<code>&lt;link&gt;</code> 标签引入这个文件。<br>语法：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel&#x3D;&quot;stylesheet&quot;  href&#x3D;&quot;css文件路径&quot;&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;details &gt;&lt;summary&gt; 参考资料 &lt;/summary&gt;
              &lt;div class=&#39;content&#39;&gt;
              &lt;div class=&quot;tag link&quot;&gt;&lt;a class=&quot;link-card&quot; title=&quot;CSS参</summary>
      
    
    
    
    <category term="Web前端" scheme="http://halo123.top/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="CSS" scheme="http://halo123.top/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>知识Tips</title>
    <link href="http://halo123.top/2021/04/19/KnowledgeTips/%E7%9F%A5%E8%AF%86Tips/"/>
    <id>http://halo123.top/2021/04/19/KnowledgeTips/%E7%9F%A5%E8%AF%86Tips/</id>
    <published>2021-04-19T14:04:03.000Z</published>
    <updated>2021-04-30T10:05:39.928Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为何众多计算机语言要从1970年1月1日开始算起？"><a class="header-anchor" href="#为何众多计算机语言要从1970年1月1日开始算起？"></a>为何众多计算机语言要从1970年1月1日开始算起？</h2><p>最初计算机操作系统是32位，而时间也是用32位表示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Integer.MAX_VALUE);</span><br><span class="line"><span class="comment">// OutPut: 2147483647</span></span><br></pre></td></tr></table></figure><p>Integer 在JAVA内用32位表示，因此32位能表示的值是2147483647。</p><p>另外1年365天的总秒数是 31536000s，2147483647/31536000 = 68.1，也就是说32位能表示的最长时间是68年，从1970年开始的话，加上68.1，实际最终到2038年01月19日03时14分07秒，便会到达时间，过了这个时间点，所有32位操作系统时间便会变为10000000 00000000 00000000 00000000，算下来也就是1901年12月13日20时45分52秒，这样便会出现时间回归的现象，很多软件便会运行异常了。</p><p>到这里，问题的答案已经显现出来了，那就是：因为用32位来表示时间的间隔是68年，而最早出现的UNIX操作系统考虑到计算机产生的年代和应用的时限综合取了1970年1月1日作为UNIX TIME的纪元时间(开始时间)。</p><p>至于时间回归的现象相信随着64为操作系统的产生逐渐得到解决，因为用64位操作系统可以表示到 292,277,026,596年12月4日15时30分08秒，相信我们的N代子孙，哪怕地球毁灭那天都不用愁不够用了，因为这个时间已经是千亿年以后了。</p><blockquote><p>来源：<a href="https://developer.51cto.com/art/201508/488060.htm">为何众多计算机语言要从1970年1月1日开始算起？</a></p></blockquote>]]></content>
    
    
    <summary type="html">一些小知识</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Web前端入门之HTML</title>
    <link href="http://halo123.top/2021/04/18/WebFrontEnd/PrimerHTML/"/>
    <id>http://halo123.top/2021/04/18/WebFrontEnd/PrimerHTML/</id>
    <published>2021-04-18T14:11:16.000Z</published>
    <updated>2021-04-19T15:50:55.000Z</updated>
    
    <content type="html"><![CDATA[<details ><summary> 参考资料 </summary>              <div class='content'>              <div class="tag link"><a class="link-card" title="Web前端入门教程" href="https://www.bilibili.com/video/BV1pE411q7FU"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E7%BD%91%E7%AB%99.svg"/></div><div class="right"><p class="text">Web前端入门教程</p><p class="url">https://www.bilibili.com/video/BV1pE411q7FU</p></div></a></div><div class="tag link"><a class="link-card" title="W3CSchool" href="http://www.w3school.com.cn/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E7%BD%91%E7%AB%99.svg"/></div><div class="right"><p class="text">W3CSchool</p><p class="url">http://www.w3school.com.cn/</p></div></a></div><div class="tag link"><a class="link-card" title="MDN" href="https://developer.mozilla.org"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E7%BD%91%E7%AB%99.svg"/></div><div class="right"><p class="text">MDN</p><p class="url">https://developer.mozilla.org</p></div></a></div>              </div>            </details><h2 id="概念"><a class="header-anchor" href="#概念"></a>概念</h2><h3 id="什么是网页"><a class="header-anchor" href="#什么是网页"></a>什么是网页?</h3><ol><li>网站是指在因特网上根据一定的规则，使用 HTML 等制作的用于展示特定内容相关的网页集合。</li><li>网页是网站中的一“页”，通常是 HTML 格式的文件，它要通过浏览器来阅读。</li><li>网页是构成网站的基本元素，它通常由图片、链接、文字、声音、视频等元素组成。通常我们看到的网页，常见以 .htm 或 .html 后缀结尾的文件，因此将其俗称为 HTML 文件。</li></ol><h3 id="什么是HTML？"><a class="header-anchor" href="#什么是HTML？"></a>什么是HTML？</h3><ol><li>HTML 指的是超文本标记语言 (Hyper Text Markup Language) ，它是用来描述网页的一种语言。</li><li>HTML 不是一种编程语言，而是一种标记语言 (markup language)。 标记语言是一套标记标签 (markup tag)。</li></ol><h3 id="浏览器"><a class="header-anchor" href="#浏览器"></a>浏览器</h3><p>浏览器是网页显示、运行的平台。常用的浏览器：Google Chrome、Microsoft Edge、IE、Apple Safari、FireFox、Opera</p><p>负责读取网页内容，整理讯息，计算网页的显示方式并显示页面</p><table><thead><tr><th>浏览器</th><th>内核</th><th>备注</th></tr></thead><tbody><tr><td>IE</td><td>Trident</td><td>IE及一些具有双核的浏览器如360极速浏览器等</td></tr><tr><td>FireFox</td><td>Gecko</td><td>火狐浏览器内核</td></tr><tr><td>Safari</td><td>Webkit</td><td>苹果浏览器内核</td></tr><tr><td>Chromium</td><td>Blink</td><td>Chrome、Opera、新版Edge浏览器内核。Blink是WebKit的分支</td></tr></tbody></table><p>目前国内一般浏览器都会采用 Webkit/Blink 内核，如 360、UC、QQ、搜狗等。</p><h3 id="Web标准"><a class="header-anchor" href="#Web标准"></a>Web标准</h3><p>Web 标准是由 <a href="https://www.w3.org/">W3C 组织</a>和其他标准化组织制定的一系列标准的集合。W3C（万维网联盟）是国际最著名的标准化组织。</p><p>遵循 Web 标准除了可以让不同的开发人员写出的页面更标准、更统一外，还有以下优点：</p><ol><li>让 Web 的发展前景更广阔。</li><li>内容能被更广泛的设备访问。</li><li>更容易被搜寻引擎搜索。</li><li>降低网站流量费用。</li><li>使网站更易于维护。</li><li>提高页面浏览速度。</li></ol><p>Web标准的构成：主要包括结构(Structure)、表现(Presentation)和行为(Behavior)三个方面。</p><table><thead><tr><th>标准</th><th>说明</th></tr></thead><tbody><tr><td>结构</td><td>结构用于对网页元素进行整理和分类。如HTML</td></tr><tr><td>表现</td><td>表现用于设置网页元素的版式、颜色、大小等外观样式。主要指的是CSS</td></tr><tr><td>行为</td><td>行为是指网页模型的定义及交互的编写。如Javascript</td></tr></tbody></table><p><strong>结构写到 HTML 文件中， 表现写到 CSS 文件中， 行为写到 JavaScript 文件中</strong></p><h2 id="HTML-标签的导读"><a class="header-anchor" href="#HTML-标签的导读"></a>HTML 标签的导读</h2><h3 id="HTML语法规则"><a class="header-anchor" href="#HTML语法规则"></a>HTML语法规则</h3><ol><li>HTML 标签是由尖括号包围的关键词，例如 <code>&lt;html&gt;</code>。</li><li>HTML 标签通常是成对出现的，例如 <code>&lt;html&gt;</code> 和 <code>&lt;/html&gt;</code> ，我们称为<strong>双标签</strong>。标签对中的第一个标签是开始标签，第二个标签是结束标签。</li><li>有些特殊的标签必须是单个标签（极少情况），例如 <code>&lt;br /&gt;</code>，我们称为<strong>单标签</strong>。</li></ol><h3 id="标签的关系"><a class="header-anchor" href="#标签的关系"></a>标签的关系</h3><p>双标签关系可以分为两类：包含关系和并列关系</p><p>包含关系：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span> <span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p>并列关系：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="基本结构标签"><a class="header-anchor" href="#基本结构标签"></a>基本结构标签</h3><p>每个网页都会有一个基本的结构标签（也称为骨架标签），页面内容也是在这些基本标签上书写</p><table><thead><tr><th>标签名</th><th>定义</th><th>说明</th></tr></thead><tbody><tr><td><code>&lt;html&gt;&lt;/html&gt;</code></td><td>HTML标签</td><td>页面中最大的标签，我们称之为根标签</td></tr><tr><td><code>&lt;head&gt;&lt;/head&gt;</code></td><td>文档的头部</td><td>注意在head标签中我们必须要设置的标签是title</td></tr><tr><td><code>&lt;title&gt;&lt;/title&gt;</code></td><td>文档的标题</td><td>让页面拥有一个属于自己的网页标题</td></tr><tr><td><code>&lt;body&gt;&lt;/body&gt;</code></td><td>文档的主体</td><td>元素包含文档的所有内容，页面内容基本都是放到body里面的</td></tr></tbody></table><h3 id="HTML基本骨架"><a class="header-anchor" href="#HTML基本骨架"></a>HTML基本骨架</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;!DOCTYPE html&gt;</code>：文档类型声明标签，告诉浏览器这个页面采取 HTML 5 版本来显示页面。</li><li><code>&lt;html lang=&quot;en&quot;&gt;</code>：<code>lang</code> 语言种类，用来定义当前文档显示的语言。en定义语言为英语，zh-CN定义语言为中文。简单来说,定义为 en 就是英文网页，定义为 zh-CN 就是中文网页。其实对于文档显示来说，定义成 en 的文档也可以显示中文，定义成 zh-CN 的文档也可以显示英文，这个属性对浏览器和搜索引擎(百度.谷歌等)还是有作用的。</li><li><code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code>：设置字符集，charset 常用的值有：GB2312 、BIG5 、GBK 和 UTF-8，其中 UTF-8 也被称为万国码，基本包含了全世界所有国家需要用到的字符。尽量统一写成标准的 “UTF-8”，不要写成  “utf8” 或 “UTF8”。</li></ul><h2 id="HTML常用的标签"><a class="header-anchor" href="#HTML常用的标签"></a>HTML常用的标签</h2><h3 id="标题标签"><a class="header-anchor" href="#标题标签"></a>标题标签</h3><p>为了使网页更具有语义化，我们经常会在页面中用到标题标签。HTML 提供了 6 个等级的网页标题，即<code>&lt;h1&gt;</code> - <code>&lt;h6&gt;</code> 。具体实现：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>标题一共六级选,<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>文字加粗一行显。<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>由大到小依次减，<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>从重到轻随之变。<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span>语法规范书写后，<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h6</span>&gt;</span>具体效果刷新见。<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br></pre></td></tr></table></figure><p>特点：</p><ol><li>加了标题的文字会变的加粗，字号也会依次变大。</li><li>一个标题独占一行。</li></ol><h3 id="段落标签"><a class="header-anchor" href="#段落标签"></a>段落标签</h3><p>在网页中，要把文字有条理地显示出来，就需要将这些文字分段显示。在 HTML 标签中，<code>&lt;p&gt;</code> (paragraph)标签用于定义段落，它可以将整个网页分为若干个段落。具体实现：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span> 我是一个段落标签 <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>特点：</p><ol><li>文本在一个段落中会根据浏览器窗口的大小自动换行。</li><li>段落和段落之间保有空隙。</li></ol><h3 id="换行标签"><a class="header-anchor" href="#换行标签"></a>换行标签</h3><p>在 HTML 中，一个段落中的文字会从左到右依次排列，直到浏览器窗口的右端，然后才自动换行。如果希望某段文本强制换行显示，就需要使用换行标签 <code>&lt;br /&gt;</code>(break)。具体实现：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>特点：</p><ol><li><code>&lt;br /&gt;</code> 是个单标签。</li><li><code>&lt;br /&gt;</code> 标签只是简单地开始新的一行，跟段落不一样，段落之间会插入一些垂直的间距。</li></ol><h3 id="文本格式化标签"><a class="header-anchor" href="#文本格式化标签"></a>文本格式化标签</h3><p>在网页中，有时需要为文字设置粗体、斜体 或下划线等效果，这时就需要用到 HTML 中的文本格式化标签，使文字以特殊的方式显示。</p><table><thead><tr><th>语义</th><th>标签</th></tr></thead><tbody><tr><td>加粗</td><td><code>&lt;strong&gt;&lt;/strong&gt;</code>或者<code>&lt;b&gt;&lt;/b&gt;</code></td></tr><tr><td>倾斜</td><td><code>&lt;em&gt;&lt;/em&gt;</code>或者<code>&lt;i&gt;&lt;/i&gt;</code></td></tr><tr><td>删除线</td><td><code>&lt;del&gt;&lt;/del&gt;</code>或者<code>&lt;s&gt;&lt;/s&gt;</code></td></tr><tr><td>下划线</td><td><code>&lt;ins&gt;&lt;/ins&gt;</code>或者<code>&lt;u&gt;&lt;/u&gt;</code></td></tr></tbody></table><h3 id="div和span标签"><a class="header-anchor" href="#div和span标签"></a><code>div</code>和<code>span</code>标签</h3><p><code>&lt;div&gt;</code> (division)和 <code>&lt;span&gt;</code>是没有语义的，它们就是一个盒子，用来装内容的。</p><p>特点：</p><ol><li><code>&lt;div&gt;</code> 标签用来布局，但是现在<font color="#FF666">一行只能放一个</font><code>&lt;div&gt;</code>。 大盒子</li><li><code>&lt;span&gt;</code> 标签用来布局，<font color="#FF666">一行上可以多个</font> <code>&lt;span&gt;</code>。小盒子</li></ol><h3 id="图片标签"><a class="header-anchor" href="#图片标签"></a>图片标签</h3><p>在 HTML 标签中，<code>&lt;img&gt;</code>(image)标签用于定义 HTML 页面中的图像。具体实现：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;图像URL&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><code>src</code> 是<code>&lt;img&gt;</code>标签的必须属性，它用于指定图像文件的路径和文件名。</p><p>图像标签的其他属性：</p><table><thead><tr><th>属性</th><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>src</td><td>图片路径</td><td>规定显示图像的 URL</td></tr><tr><td>alt</td><td>文本</td><td>替换文本。图像不能显示的文字</td></tr><tr><td>title</td><td>文本</td><td>提示文本。鼠标放到图像上，显示的文字</td></tr><tr><td>width</td><td>像素</td><td>设置图像的宽度</td></tr><tr><td>height</td><td>像素</td><td>设置图像的高度</td></tr><tr><td>border</td><td>像素</td><td>设置图像的边框粗细</td></tr></tbody></table><p>图像标签注意点：</p><ol><li>图像标签可以拥有多个属性，必须写在标签名的后面。</li><li>属性之间不分先后顺序，标签名与属性、属性与属性之间均以空格分开。</li><li>属性采取键值对的格式，即 key=“value&quot; 的格式，属性 =“属性值”。</li></ol><h3 id="路径"><a class="header-anchor" href="#路径"></a>路径</h3><p>分为相对路径和绝对路径：</p><p>相对路径：以引用文件所在位置为参考基础，而建立出的目录路径。简单来说，图片相对于 HTML 页面的位置。</p><table><thead><tr><th>相对路径分类</th><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>同一级目录</td><td></td><td>图像文件位于HTML文件同-级如<code>&lt;img src=&quot;baidu.gif&quot; /&gt;</code></td></tr><tr><td>下一级目录</td><td><code>/</code></td><td>图像文件位于HTML文件下一级如<code>&lt;img src=&quot;images/baidu.gif&quot; /&gt;</code></td></tr><tr><td>上一级目录</td><td><code>../</code></td><td>图像文件位于HTML文件上一级如<code>&lt;img src=&quot;../baidu.gif&quot; /&gt;</code></td></tr></tbody></table><p>特点：相对路径是从代码所在的这个文件出发，去寻找目标文件的，而我们这里所说的上一级 、下一级和同一级就是 图片相对于 HTML 页面的位置。</p><p>绝对路径：是指目录下的绝对位置，直接到达目标位置，通常是从盘符开始的路径。</p><p>例如，<code>&quot;D:\web\img\logo.gif&quot;</code>或完整的网络地址<code>&quot;http://www.xxx.cn/images/logo.gif&quot;</code></p><h3 id="链接标签"><a class="header-anchor" href="#链接标签"></a>链接标签</h3><p>ahchor 链接的语法格式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;跳转目标&quot;</span> <span class="attr">target</span>=<span class="string">&quot;目标窗口的弹出方式&quot;</span>&gt;</span> 文本或图像 <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>属性：</p><ol><li><code>href</code>：用于指定链接目标的url地址，必须属性</li><li>target:用于指定链接页面的打开方式<code>_self</code>默认值，<code>_blank</code>新窗口打开</li><li><code>#</code>：空链接</li></ol><p>链接分类：</p><ol><li>外部链接: 例如 <code>&lt;a href=&quot;http://www.baidu.com&quot;&gt; 百度&lt;/a&gt;</code></li><li>内部链接:网站内部页面之间的相互链接. 直接链接内部页面名称即可，例如 <code>&lt;a href=&quot;index.html&quot;&gt; 首页 &lt;/a&gt;</code></li><li>空链接: 如果当时没有确定链接目标时，<code>&lt;a href=&quot;#&quot;&gt; 首页 &lt;/a&gt;</code></li><li>下载链接: 如果 href 里面地址是一个文件或者压缩包，会下载这个文件。</li><li>网页元素链接: 在网页中的各种网页元素，如文本、图像、表格、音频、视频等都可以添加超链接.</li><li>锚点链接:  点我们点击链接,可以快速定位到页面中的某个位置.<ul><li>在链接文本的 href 属性中，设置属性值为 #名字 的形式，如<code>&lt;a href=&quot;#two&quot;&gt; 第2集 &lt;/a&gt;</code></li><li>找到目标位置标签，里面添加一个 id 属性 = 刚才的名字 ，如：<code>&lt;h3 id=&quot;two&quot;&gt;第2集介绍&lt;/h3&gt;</code></li></ul></li></ol><h3 id="注释"><a class="header-anchor" href="#注释"></a>注释</h3><p>如果需要在 HTML 文档中添加一些便于阅读和理解但又不需要显示在页面中的注释文字，就需要使用注释标签。<br>HTML中的注释以<code>&lt;!--</code>开头，以<code>--&gt;</code>结束。</p><p>具体实现：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注释语句 快捷键: ctrl +  /  --&gt;</span>      </span><br></pre></td></tr></table></figure><p>添加注释是为了更好地解释代码的功能，便于相关开发人员理解和阅读代码，程序是不会执行注释内容的。</p><h3 id="特殊字符"><a class="header-anchor" href="#特殊字符"></a>特殊字符</h3><p>在 HTML 页面中，一些特殊的符号很难或者不方便直接使用，此时我们就可以使用下面的字符来替代。</p><table><thead><tr><th>特殊字符</th><th>描述</th><th>字符的代码</th></tr></thead><tbody><tr><td> </td><td>空格符</td><td><code>&amp;nbsp;</code></td></tr><tr><td>&lt;</td><td>小于号</td><td><code>&amp;lt;</code></td></tr><tr><td>&gt;</td><td>大于号</td><td><code>&amp;gt;</code></td></tr><tr><td>&amp;</td><td>and</td><td><code>&amp;amp;</code></td></tr><tr><td>¥</td><td>人民币</td><td><code>&amp;yen;</code></td></tr><tr><td>©</td><td>版权</td><td><code>&amp;copy;</code></td></tr><tr><td>®</td><td>注册商标</td><td><code>&amp;reg;</code></td></tr><tr><td>°</td><td>摄氏度</td><td><code>&amp;deg;</code></td></tr><tr><td>±</td><td>正负号</td><td><code>&amp;plusmn;</code></td></tr><tr><td>×</td><td>乘号</td><td><code>&amp;times;</code></td></tr><tr><td>÷</td><td>除号</td><td><code>&amp;divide;</code></td></tr><tr><td>²</td><td>平方</td><td><code>&amp;sup2;</code></td></tr><tr><td>³</td><td>立方</td><td><code>&amp;sup3;</code></td></tr></tbody></table><p>重点记住：空格 、大于号、 小于号 这三个， 其余的使用很少，如果需要回头查阅即可。</p><h2 id="表格"><a class="header-anchor" href="#表格"></a>表格</h2><ol><li>表格主要用于显示、展示数据，因为它可以让数据显示的非常的规整，可读性非常好。特别是后台展示数据的时候，能够熟练运用表格就显得很重要。一个清爽简约的表格能够把繁杂的数据表现得很有条理。</li><li>表格不是用来布局页面的,而是用来展示数据的。</li></ol><h3 id="表格的具体用法"><a class="header-anchor" href="#表格的具体用法"></a>表格的具体用法</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>单元格内的文字<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><code>&lt;table&gt; &lt;/table&gt;</code> 是用于定义表格的标签。</li><li><code>&lt;tr&gt; &lt;/tr&gt;</code> 标签用于定义表格中的行，必须嵌套在 <code>&lt;table&gt; &lt;/table&gt;</code>标签中。</li><li><code>&lt;td&gt; &lt;/td&gt; 用于定义表格中的单元格，必须嵌套在</code><tr></tr>`标签中。</li><li>字母 <code>td</code> 指表格数据（table data），即数据单元格的内容。</li></ol><h3 id="表头单元格标签"><a class="header-anchor" href="#表头单元格标签"></a>表头单元格标签</h3><p>表头标签的具体实现：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>一般表头单元格位于表格的第一行或第一列，表头单元格里面的文本内容加粗居中显示。<code>&lt;th&gt;</code> 标签表示 HTML 表格的表头部分（table head 的缩写）</li><li>表头单元格也是单元格，常用于表格第一行突出重要性，表头单元格里面的文字会加粗居中</li></ol><h3 id="表格属性"><a class="header-anchor" href="#表格属性"></a>表格属性</h3><p>表格标签<code>&lt;table&gt;</code>这部分属性我们实际开发我们不常用，后面通过 CSS 来设置</p><table><thead><tr><th>属性名</th><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>align</td><td>left、center、right</td><td>规定表格相对周围元素的对齐方式</td></tr><tr><td>border</td><td>1或&quot;&quot;</td><td>规定表格单元是否拥有边框，默认为&quot;&quot;，表示没有边框</td></tr><tr><td>cellpadding</td><td>像素值</td><td>规定单元边沿与其内容之间的空白，默认1像素</td></tr><tr><td>cellspacing</td><td>像素值</td><td>规定单元格之间的空白，默认2像素</td></tr><tr><td>width</td><td>像素值或百分比</td><td>规定表格的宽度</td></tr></tbody></table><h3 id="表格结构标签"><a class="header-anchor" href="#表格结构标签"></a>表格结构标签</h3><p>使用场景:因为表格可能很长,为了更好的表示表格的语义，可以将表格分割成 表格头部和表格主体两大部分。在表格标签中，分别用：<code>&lt;thead&gt;</code>标签 表格的头部区域、<code>&lt;tbody&gt;</code>标签 表格的主体区域. 这样可以更好的分清表格结构。</p><p>总结:</p><ol><li><code>&lt;thead&gt;&lt;/thead&gt;</code>：用于定义表格的头部。<code>&lt;thead&gt;</code> 内部必须拥有 <code>&lt;tr&gt;</code> 标签。 一般是位于第一行。</li><li><code>&lt;tbody&gt;&lt;/tbody&gt;</code>：用于定义表格的主体，主要用于放数据本体 。</li><li>以上标签都是放在 <code>&lt;table&gt;&lt;/table&gt;</code> 标签中。</li></ol><h3 id="合并单元格"><a class="header-anchor" href="#合并单元格"></a>合并单元格</h3><p>合并单元格方式：</p><ol><li>跨行合并：<code>rowspan=&quot;合并单元格的个数&quot;</code>，最上侧单元格为目标单元格, 写合并代码</li><li>跨列合并：<code>colspan=&quot;合并单元格的个数&quot;</code>，最左侧单元格为目标单元格, 写合并代码</li></ol><p>合并单元格三步曲：</p><ol><li>先确定是跨行还是跨列合并。</li><li>找到目标单元格。写上合并方式 = 合并的单元格数量。比如：<code>&lt;td colspan=&quot;2&quot;&gt;&lt;/td&gt;</code>。</li><li>删除多余的单元格。</li></ol><h2 id="列表"><a class="header-anchor" href="#列表"></a>列表</h2><p>表格是用来显示数据的，那么列表就是用来布局的。 列表最大的特点就是整齐、整洁、有序，它作为布局会更加自由和方便。</p><p>根据使用情景不同，列表可以分为三大类：无序列表、有序列表和自定义列表。</p><h3 id="无序列表"><a class="header-anchor" href="#无序列表"></a>无序列表</h3><p><code>&lt;ul&gt;</code> 标签表示 HTML 页面中项目的无序列表，一般会以项目符号呈现列表项，而列表项使用 <code>&lt;li&gt;</code> 标签定义。无序列表的基本语法格式如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  ... </span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>无序列表的各个列表项之间没有顺序级别之分，是并列的。</li><li><code>&lt;ul&gt;&lt;/ul&gt;</code> 中只能嵌套 <code>&lt;li&gt;&lt;/li&gt;</code>，直接在 <code>&lt;ul&gt;&lt;/ul&gt;</code> 标签中输入其他标签或者文字的做法是不被允许的。</li><li><code>&lt;li&gt;</code> 与 <code>&lt;/li&gt;</code> 之间相当于一个容器，可以容纳所有元素。</li><li>无序列表会带有自己的样式属性，但在实际使用时，我们会使用 CSS 来设置。</li></ol><h3 id="有序列表"><a class="header-anchor" href="#有序列表"></a>有序列表</h3><p>有序列表即为有排列顺序的列表，其各个列表项会按照一定的顺序排列定义。在 HTML 标签中，<code>&lt;ol&gt;</code> 标签用于定义有序列表，列表排序以数字来显示，并且使用 <code>&lt;li&gt;</code> 标签来定义列表项。有序列表的基本语法格式如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  ... </span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><code>&lt;ol&gt;&lt;/ol&gt;</code>中只能嵌套<code>&lt;li&gt;&lt;/li&gt;</code>，直接在<code>&lt;ol&gt;&lt;/ol&gt;</code>标签中输入其他标签或者文字的做法是不被允许的。</li><li><code>&lt;li&gt;</code> 与 <code>&lt;/li&gt;</code>之间相当于一个容器，可以容纳所有元素。</li><li>有序列表会带有自己样式属性，但在实际使用时，我们会使用 CSS 来设置。</li></ol><h3 id="自定义列表"><a class="header-anchor" href="#自定义列表"></a>自定义列表</h3><p>自定义列表的使用场景:自定义列表常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号。在 HTML 标签中，<code>&lt;dl&gt;</code> 标签用于定义描述列表（或定义列表），该标签会与 <code>&lt;dt&gt;</code>（定义项目/名字）和 <code>&lt;dd&gt;</code>（描述每一个项目/名字）一起使用。语法如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span>名词1<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>名词1解释1<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>名词1解释2<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用规则同上</p><h2 id="表单"><a class="header-anchor" href="#表单"></a>表单</h2><p>使用表单目的是为了收集用户信息。在我们网页中， 我们也需要跟用户进行交互，收集用户资料，此时就需要表单。</p><p>在 HTML 中，一个完整的表单通常由<font color="#FF666">表单域</font>、<font color="#FF666">表单控件</font>（也称为表单元素）和 提示信息3个部分构成。</p><h3 id="表单域"><a class="header-anchor" href="#表单域"></a>表单域</h3><p>表单域是一个包含表单元素的区域。</p><p>在 HTML 标签中， <code>&lt;form&gt;</code> 标签用于定义表单域，以实现用户信息的收集和传递。</p><p><code>&lt;form&gt;</code> 会把它范围内的表单元素信息提交给服务器。实现代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">“url地址”</span> <span class="attr">method</span>=<span class="string">“提交方式”</span> <span class="attr">name</span>=<span class="string">“表单域名称</span>&quot;&gt;</span></span><br><span class="line">  各种表单元素控件</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>表单域的常用属性：</p><table><thead><tr><th>属性名</th><th>属性值</th><th>作用</th></tr></thead><tbody><tr><td>action</td><td>URL地址</td><td>用于指定接收并处理表单数据的服务器程序的url地址</td></tr><tr><td>method</td><td>get/p</td><td>用于设置表单数据的提交方式，其取值为get或post</td></tr><tr><td>name</td><td>名称</td><td>用于指定表单的名称，以区分同一个页面中的多个表单域</td></tr></tbody></table><h3 id="表单控件-表单元素"><a class="header-anchor" href="#表单控件-表单元素"></a>表单控件(表单元素)</h3><p><code>&lt;input&gt;</code> 表单元素</p><p>在英文单词中，input 是输入的意思，而在表单元素中 <code>&lt;input&gt;</code> 标签用于收集用户信息。在 <code>&lt;input&gt;</code> 标签中，包含一个 type 属性，根据不同的 type 属性值，输入字段拥有很多种形式（可以是文本字段、复选框、掩码后的文本控件、单选按钮、按钮等）。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;属性值&quot;</span>  /&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;input /&gt;</code> 标签为单标签 type 属性设置不同的属性值用来指定不同的控件类型，type 属性的属性值及其描述如下：</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>button</td><td>定义可点击按钮（多数情况下，用于通过 JavaScript 启动脚本）。</td></tr><tr><td>checkbox</td><td>定义复选框。</td></tr><tr><td>file</td><td>定义输入字段和 &quot;浏览&quot;按钮，供文件上传。</td></tr><tr><td>hidden</td><td>定义隐藏的输入字段。</td></tr><tr><td>image</td><td>定义图像形式的提交按钮。</td></tr><tr><td>password</td><td>定义密码字段。该字段中的字符被掩码。</td></tr><tr><td>radio</td><td>定义单选按钮。</td></tr><tr><td>reset</td><td>定义重置按钮。重置按钮会清除表单中的所有数据。</td></tr><tr><td>submit</td><td>定义提交按钮。提交按钮会把表单数据发送到服务器。</td></tr><tr><td>text</td><td>定义单行的输入字段，用户可在其中输入文本。默认宽度为 20 个字符。</td></tr></tbody></table><p>除 type 属性外，<code>&lt;input/&gt;</code>标签还有其他很多属性，其常用属性如下：</p><table><thead><tr><th>属性</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://www.w3school.com.cn/tags/att_input_name.asp">name</a></td><td>field_name</td><td>定义 input 元素的名称</td></tr><tr><td><a href="https://www.w3school.com.cn/tags/att_input_value.asp">value</a></td><td>value</td><td>规定 input 元素的值</td></tr><tr><td><a href="https://www.w3school.com.cn/tags/att_input_checked.asp">checked</a></td><td>checked</td><td>规定此 input 元素首次加载时应当被选中</td></tr><tr><td><a href="https://www.w3school.com.cn/tags/att_input_maxlength.asp">maxlength</a></td><td>number</td><td>规定输入字段中的字符的最大长度</td></tr></tbody></table><ol><li>name 和 value 是每个表单元素都有的属性值，主要给后台人员使用。</li><li>name 表单元素的名字，要求单选按钮和复选框要有相同的name值。</li><li>checked属性主要针对于单选按钮和复选框主要作用一打开页面，就要可以默认选中某个表单元素。</li></ol><h3 id="标签"><a class="header-anchor" href="#标签"></a>标签</h3><p><code>&lt;label&gt;</code> 标签为 input 元素定义标注（标签）。</p><p><code>&lt;label&gt;</code> 标签用于绑定一个表单元素, 当点击<code>&lt;label&gt;</code> 标签内的文本时，浏览器就会自动将焦点(光标)转到或者选择对应的表单元素上，用来增加用户体验。语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;sex&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span>  <span class="attr">id</span>=<span class="string">&quot;sex&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>核心：<code>&lt;label&gt;</code> 标签的 for 属性应当与相关元素的 id 属性相同。</p><h3 id="下拉框"><a class="header-anchor" href="#下拉框"></a>下拉框</h3><p><code>&lt;select&gt;</code> 下拉框，使用场景: 在页面中，如果有多个选项让用户选择，并且想要节约页面空间时，我们可以使用<code>&lt;select&gt;</code>标签控件定义下拉列表。</p><p>语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">option</span>&gt;</span>选项1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">option</span>&gt;</span>选项2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">option</span>&gt;</span>选项3<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">   ...</span><br><span class="line"> <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><code>&lt;select&gt;</code> 中至少包含一对<code>&lt;option&gt;</code></li><li>在<code>&lt;optioq&gt;</code>中定义<code>selected =&quot;selected&quot;</code>时，当前项即为默认选中项</li></ol><h3 id="文本域"><a class="header-anchor" href="#文本域"></a>文本域</h3><p><code>&lt;textarea&gt;</code> 文本域</p><ol><li>使用场景: 当用户输入内容较多的情况下，我们就不能使用文本框表单了，此时我们可以使用 <code>&lt;textarea&gt;</code> 标签。</li><li>在表单元素中，<code>&lt;textarea&gt;</code> 标签是用于定义多行文本输入的控件。</li><li>使用多行文本输入控件，可以输入更多的文字，该控件常见于留言板，评论。</li></ol><p>语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">rows</span>=<span class="string">&quot;3&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;20&quot;</span>&gt;</span> 文本内容 <span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过 <code>&lt;textarea&gt;</code> 标签可以轻松地创建多行文本输入框。<code>cols=&quot;每行中的字符数&quot;</code> ，<code>rows=&quot;显示的行数&quot;</code>。我们在实际开发中不会使用，都是用 CSS 来改变大小。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;details &gt;&lt;summary&gt; 参考资料 &lt;/summary&gt;
              &lt;div class=&#39;content&#39;&gt;
              &lt;div class=&quot;tag link&quot;&gt;&lt;a class=&quot;link-card&quot; title=&quot;Web前</summary>
      
    
    
    
    <category term="Web前端" scheme="http://halo123.top/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="HTML" scheme="http://halo123.top/tags/HTML/"/>
    
  </entry>
  
</feed>
